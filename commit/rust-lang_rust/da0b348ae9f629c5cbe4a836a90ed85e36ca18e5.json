{"sha": "da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMGIzNDhhZTlmNjI5YzVjYmU0YTgzNmE5MGVkODVlMzZjYTE4ZTU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-08T08:28:42Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-08T08:28:42Z"}, "message": "migrate ra_hir to rowan 2.0", "tree": {"sha": "614fd83f614632e3c87130117421708a7a028c13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/614fd83f614632e3c87130117421708a7a028c13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "html_url": "https://github.com/rust-lang/rust/commit/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6020f516f2826dac7188171241e9a72d6248cf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6020f516f2826dac7188171241e9a72d6248cf8", "html_url": "https://github.com/rust-lang/rust/commit/d6020f516f2826dac7188171241e9a72d6248cf8"}], "stats": {"total": 435, "additions": 238, "deletions": 197}, "files": [{"sha": "613a6cdc5fb6ddf44eb84c4700393cd7b2b4698d", "filename": "Cargo.lock", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -295,7 +295,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"flexi_logger\"\n-version = \"0.10.3\"\n+version = \"0.10.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -706,7 +706,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flexi_logger 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flexi_logger 0.10.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\",\n@@ -728,7 +728,7 @@ dependencies = [\n  \"drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flexi_logger 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flexi_logger 0.10.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gen_lsp_server 0.1.0\",\n  \"im 12.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"languageserver-types 0.53.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -970,7 +970,7 @@ dependencies = [\n [[package]]\n name = \"rowan\"\n version = \"0.2.0\"\n-source = \"git+https://github.com/rust-analyzer/rowan.git?branch=new-impl#6b50db0f68a989c512e3bbebfbc8ede70ca7f221\"\n+source = \"git+https://github.com/rust-analyzer/rowan.git?branch=new-impl#c921101ffb102cfa5bd27ff3a746dc12cf56af5e\"\n dependencies = [\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smol_str 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1510,7 +1510,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"795bd83d3abeb9220f257e597aa0080a508b27533824adf336529648f6abf7e2\"\n \"checksum failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea1063915fd7ef4309e222a5a07cf9c319fb9c7836b1f89b85458672dbb127e1\"\n \"checksum fake-simd 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n-\"checksum flexi_logger 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4dda06444ccc8b0a6da19d939989b4a4e83f328710ada449eedaed48c8b903cd\"\n+\"checksum flexi_logger 0.10.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7d3681306880a7ce87740ceb3d1ce98ca92ae636ff30a629494488cbbcf85ff8\"\n \"checksum fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3\"\n \"checksum fst 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"db72126ca7dff566cdbbdd54af44668c544897d9d3862b198141f176f1238bdf\"\n \"checksum fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82\""}, {"sha": "b700be2673b2f640b66af95a05b56c129d1db537", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -42,7 +42,7 @@ pub struct StructData {\n }\n \n impl StructData {\n-    pub(crate) fn new(struct_def: ast::StructDef) -> StructData {\n+    pub(crate) fn new(struct_def: &ast::StructDef) -> StructData {\n         let name = struct_def.name().map(|n| n.as_name());\n         let variant_data = VariantData::new(struct_def.flavor());\n         let variant_data = Arc::new(variant_data);\n@@ -87,7 +87,7 @@ pub struct EnumData {\n }\n \n impl EnumData {\n-    pub(crate) fn new(enum_def: ast::EnumDef) -> Self {\n+    pub(crate) fn new(enum_def: &ast::EnumDef) -> Self {\n         let name = enum_def.name().map(|n| n.as_name());\n         let variants = if let Some(evl) = enum_def.variant_list() {\n             evl.variants()"}, {"sha": "43cddb5044e95fa12839fe0830f3a403f090631c", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -1,6 +1,6 @@\n use relative_path::RelativePathBuf;\n use ra_db::{CrateId, Cancelable, FileId};\n-use ra_syntax::{ast, SyntaxNode};\n+use ra_syntax::{ast, TreePtr, SyntaxNode};\n \n use crate::{Name, db::HirDatabase, DefId, Path, PerNs, nameres::ModuleScope};\n \n@@ -36,8 +36,8 @@ pub struct Module {\n }\n \n pub enum ModuleSource {\n-    SourceFile(ast::SourceFileNode),\n-    Module(ast::ModuleNode),\n+    SourceFile(TreePtr<ast::SourceFile>),\n+    Module(TreePtr<ast::Module>),\n }\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n@@ -66,7 +66,7 @@ impl Module {\n     pub fn declaration_source(\n         &self,\n         db: &impl HirDatabase,\n-    ) -> Cancelable<Option<(FileId, ast::ModuleNode)>> {\n+    ) -> Cancelable<Option<(FileId, TreePtr<ast::Module>)>> {\n         self.declaration_source_impl(db)\n     }\n \n@@ -104,7 +104,10 @@ impl Module {\n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> Cancelable<PerNs<DefId>> {\n         self.resolve_path_impl(db, path)\n     }\n-    pub fn problems(&self, db: &impl HirDatabase) -> Cancelable<Vec<(SyntaxNode, Problem)>> {\n+    pub fn problems(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Cancelable<Vec<(TreePtr<SyntaxNode>, Problem)>> {\n         self.problems_impl(db)\n     }\n }"}, {"sha": "0d22c9dbe591f0e919db9578a36d21ff5f6547a8", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -1,5 +1,5 @@\n use ra_db::{Cancelable, SourceRootId, FileId};\n-use ra_syntax::{ast, SyntaxNode, AstNode};\n+use ra_syntax::{ast, SyntaxNode, AstNode, TreePtr};\n \n use crate::{\n     Module, ModuleSource, Problem,\n@@ -43,20 +43,19 @@ impl Module {\n         let loc = self.def_id.loc(db);\n         let file_id = loc.source_item_id.file_id.as_original_file();\n         let syntax_node = db.file_item(loc.source_item_id);\n-        let syntax_node = syntax_node.borrowed();\n-        let module_source = if let Some(source_file) = ast::SourceFile::cast(syntax_node) {\n-            ModuleSource::SourceFile(source_file.owned())\n+        let module_source = if let Some(source_file) = ast::SourceFile::cast(&syntax_node) {\n+            ModuleSource::SourceFile(source_file.to_owned())\n         } else {\n-            let module = ast::Module::cast(syntax_node).unwrap();\n-            ModuleSource::Module(module.owned())\n+            let module = ast::Module::cast(&syntax_node).unwrap();\n+            ModuleSource::Module(module.to_owned())\n         };\n         Ok((file_id, module_source))\n     }\n \n     pub fn declaration_source_impl(\n         &self,\n         db: &impl HirDatabase,\n-    ) -> Cancelable<Option<(FileId, ast::ModuleNode)>> {\n+    ) -> Cancelable<Option<(FileId, TreePtr<ast::Module>)>> {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id)?;\n         let link = ctry!(loc.module_id.parent_link(&module_tree));\n@@ -146,7 +145,10 @@ impl Module {\n         }\n         Ok(curr_per_ns)\n     }\n-    pub fn problems_impl(&self, db: &impl HirDatabase) -> Cancelable<Vec<(SyntaxNode, Problem)>> {\n+    pub fn problems_impl(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Cancelable<Vec<(TreePtr<SyntaxNode>, Problem)>> {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id)?;\n         Ok(loc.module_id.problems(&module_tree, db))"}, {"sha": "03e65387d8ff2e03a0e26ebcd7aae75fa431bae1", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -1,6 +1,6 @@\n use std::sync::Arc;\n \n-use ra_syntax::{SyntaxNode, SourceFileNode};\n+use ra_syntax::{SyntaxNode, TreePtr, SourceFile};\n use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase, Cancelable};\n \n use crate::{\n@@ -22,7 +22,7 @@ pub trait HirDatabase: SyntaxDatabase\n     + AsRef<LocationIntener<DefLoc, DefId>>\n     + AsRef<LocationIntener<MacroCallLoc, MacroCallId>>\n {\n-    fn hir_source_file(file_id: HirFileId) -> SourceFileNode {\n+    fn hir_source_file(file_id: HirFileId) -> TreePtr<SourceFile> {\n         type HirSourceFileQuery;\n         use fn HirFileId::hir_source_file;\n     }\n@@ -66,7 +66,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn query_definitions::file_items;\n     }\n \n-    fn file_item(source_item_id: SourceItemId) -> SyntaxNode {\n+    fn file_item(source_item_id: SourceItemId) -> TreePtr<SyntaxNode> {\n         type FileItemQuery;\n         use fn query_definitions::file_item;\n     }"}, {"sha": "49c1a231b2db442feb80e0bb42bd76a754fee199", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -373,10 +373,10 @@ impl ExprCollector {\n         self.exprs.alloc(block)\n     }\n \n-    fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n+    fn collect_expr(&mut self, expr: &ast::Expr) -> ExprId {\n         let syntax_ptr = LocalSyntaxPtr::new(expr.syntax());\n-        match expr {\n-            ast::Expr::IfExpr(e) => {\n+        match expr.kind() {\n+            ast::ExprKind::IfExpr(e) => {\n                 if let Some(pat) = e.condition().and_then(|c| c.pat()) {\n                     // if let -- desugar to match\n                     let pat = self.collect_pat(pat);\n@@ -419,12 +419,12 @@ impl ExprCollector {\n                     )\n                 }\n             }\n-            ast::Expr::BlockExpr(e) => self.collect_block_opt(e.block()),\n-            ast::Expr::LoopExpr(e) => {\n+            ast::ExprKind::BlockExpr(e) => self.collect_block_opt(e.block()),\n+            ast::ExprKind::LoopExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n                 self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n             }\n-            ast::Expr::WhileExpr(e) => {\n+            ast::ExprKind::WhileExpr(e) => {\n                 let condition = if let Some(condition) = e.condition() {\n                     if condition.pat().is_none() {\n                         self.collect_expr_opt(condition.expr())\n@@ -438,7 +438,7 @@ impl ExprCollector {\n                 let body = self.collect_block_opt(e.loop_body());\n                 self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n             }\n-            ast::Expr::ForExpr(e) => {\n+            ast::ExprKind::ForExpr(e) => {\n                 let iterable = self.collect_expr_opt(e.iterable());\n                 let pat = self.collect_pat_opt(e.pat());\n                 let body = self.collect_block_opt(e.loop_body());\n@@ -451,7 +451,7 @@ impl ExprCollector {\n                     syntax_ptr,\n                 )\n             }\n-            ast::Expr::CallExpr(e) => {\n+            ast::ExprKind::CallExpr(e) => {\n                 let callee = self.collect_expr_opt(e.expr());\n                 let args = if let Some(arg_list) = e.arg_list() {\n                     arg_list.args().map(|e| self.collect_expr(e)).collect()\n@@ -460,7 +460,7 @@ impl ExprCollector {\n                 };\n                 self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n             }\n-            ast::Expr::MethodCallExpr(e) => {\n+            ast::ExprKind::MethodCallExpr(e) => {\n                 let receiver = self.collect_expr_opt(e.expr());\n                 let args = if let Some(arg_list) = e.arg_list() {\n                     arg_list.args().map(|e| self.collect_expr(e)).collect()\n@@ -480,7 +480,7 @@ impl ExprCollector {\n                     syntax_ptr,\n                 )\n             }\n-            ast::Expr::MatchExpr(e) => {\n+            ast::ExprKind::MatchExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let arms = if let Some(match_arm_list) = e.match_arm_list() {\n                     match_arm_list\n@@ -495,33 +495,33 @@ impl ExprCollector {\n                 };\n                 self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n             }\n-            ast::Expr::PathExpr(e) => {\n+            ast::ExprKind::PathExpr(e) => {\n                 let path = e\n                     .path()\n                     .and_then(Path::from_ast)\n                     .map(Expr::Path)\n                     .unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n             }\n-            ast::Expr::ContinueExpr(_e) => {\n+            ast::ExprKind::ContinueExpr(_e) => {\n                 // TODO: labels\n                 self.alloc_expr(Expr::Continue, syntax_ptr)\n             }\n-            ast::Expr::BreakExpr(e) => {\n+            ast::ExprKind::BreakExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Break { expr }, syntax_ptr)\n             }\n-            ast::Expr::ParenExpr(e) => {\n+            ast::ExprKind::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n                 // make the paren expr point to the inner expression as well\n                 self.expr_syntax_mapping.insert(syntax_ptr, inner);\n                 inner\n             }\n-            ast::Expr::ReturnExpr(e) => {\n+            ast::ExprKind::ReturnExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n-            ast::Expr::StructLit(e) => {\n+            ast::ExprKind::StructLit(e) => {\n                 let path = e.path().and_then(Path::from_ast);\n                 let fields = if let Some(nfl) = e.named_field_list() {\n                     nfl.fields()\n@@ -558,34 +558,34 @@ impl ExprCollector {\n                     syntax_ptr,\n                 )\n             }\n-            ast::Expr::FieldExpr(e) => {\n+            ast::ExprKind::FieldExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let name = e\n                     .name_ref()\n                     .map(|nr| nr.as_name())\n                     .unwrap_or_else(Name::missing);\n                 self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n             }\n-            ast::Expr::TryExpr(e) => {\n+            ast::ExprKind::TryExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n             }\n-            ast::Expr::CastExpr(e) => {\n+            ast::ExprKind::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let type_ref = TypeRef::from_ast_opt(e.type_ref());\n                 self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n             }\n-            ast::Expr::RefExpr(e) => {\n+            ast::ExprKind::RefExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let mutability = Mutability::from_mutable(e.is_mut());\n                 self.alloc_expr(Expr::Ref { expr, mutability }, syntax_ptr)\n             }\n-            ast::Expr::PrefixExpr(e) => {\n+            ast::ExprKind::PrefixExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let op = e.op();\n                 self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr)\n             }\n-            ast::Expr::LambdaExpr(e) => {\n+            ast::ExprKind::LambdaExpr(e) => {\n                 let mut args = Vec::new();\n                 let mut arg_types = Vec::new();\n                 if let Some(pl) = e.param_list() {\n@@ -606,36 +606,36 @@ impl ExprCollector {\n                     syntax_ptr,\n                 )\n             }\n-            ast::Expr::BinExpr(e) => {\n+            ast::ExprKind::BinExpr(e) => {\n                 let lhs = self.collect_expr_opt(e.lhs());\n                 let rhs = self.collect_expr_opt(e.rhs());\n                 let op = e.op();\n                 self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n \n             // TODO implement HIR for these:\n-            ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::TupleExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::ArrayExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::Literal(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::ExprKind::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::ExprKind::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::ExprKind::TupleExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::ExprKind::ArrayExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::ExprKind::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::ExprKind::Literal(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n         }\n     }\n \n-    fn collect_expr_opt(&mut self, expr: Option<ast::Expr>) -> ExprId {\n+    fn collect_expr_opt(&mut self, expr: Option<&ast::Expr>) -> ExprId {\n         if let Some(expr) = expr {\n             self.collect_expr(expr)\n         } else {\n             self.exprs.alloc(Expr::Missing)\n         }\n     }\n \n-    fn collect_block(&mut self, block: ast::Block) -> ExprId {\n+    fn collect_block(&mut self, block: &ast::Block) -> ExprId {\n         let statements = block\n             .statements()\n-            .map(|s| match s {\n-                ast::Stmt::LetStmt(stmt) => {\n+            .map(|s| match s.kind() {\n+                ast::StmtKind::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n                     let type_ref = stmt.type_ref().map(TypeRef::from_ast);\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n@@ -645,7 +645,9 @@ impl ExprCollector {\n                         initializer,\n                     }\n                 }\n-                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n+                ast::StmtKind::ExprStmt(stmt) => {\n+                    Statement::Expr(self.collect_expr_opt(stmt.expr()))\n+                }\n             })\n             .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n@@ -655,25 +657,25 @@ impl ExprCollector {\n         )\n     }\n \n-    fn collect_block_opt(&mut self, block: Option<ast::Block>) -> ExprId {\n+    fn collect_block_opt(&mut self, block: Option<&ast::Block>) -> ExprId {\n         if let Some(block) = block {\n             self.collect_block(block)\n         } else {\n             self.exprs.alloc(Expr::Missing)\n         }\n     }\n \n-    fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n+    fn collect_pat(&mut self, pat: &ast::Pat) -> PatId {\n         let syntax_ptr = LocalSyntaxPtr::new(pat.syntax());\n-        match pat {\n-            ast::Pat::BindPat(bp) => {\n+        match pat.kind() {\n+            ast::PatKind::BindPat(bp) => {\n                 let name = bp\n                     .name()\n                     .map(|nr| nr.as_name())\n                     .unwrap_or_else(Name::missing);\n                 self.alloc_pat(Pat::Bind { name }, syntax_ptr)\n             }\n-            ast::Pat::TupleStructPat(p) => {\n+            ast::PatKind::TupleStructPat(p) => {\n                 let path = p.path().and_then(Path::from_ast);\n                 let args = p.args().map(|p| self.collect_pat(p)).collect();\n                 self.alloc_pat(Pat::TupleStruct { path, args }, syntax_ptr)\n@@ -685,7 +687,7 @@ impl ExprCollector {\n         }\n     }\n \n-    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n+    fn collect_pat_opt(&mut self, pat: Option<&ast::Pat>) -> PatId {\n         if let Some(pat) = pat {\n             self.collect_pat(pat)\n         } else {\n@@ -710,7 +712,7 @@ impl ExprCollector {\n     }\n }\n \n-pub(crate) fn collect_fn_body_syntax(node: ast::FnDef) -> BodySyntaxMapping {\n+pub(crate) fn collect_fn_body_syntax(node: &ast::FnDef) -> BodySyntaxMapping {\n     let mut collector = ExprCollector::new();\n \n     let args = if let Some(param_list) = node.param_list() {\n@@ -758,9 +760,7 @@ pub(crate) fn body_syntax_mapping(\n     let body_syntax_mapping = match def {\n         Def::Function(f) => {\n             let node = f.syntax(db);\n-            let node = node.borrowed();\n-\n-            collect_fn_body_syntax(node)\n+            collect_fn_body_syntax(&node)\n         }\n         // TODO: consts, etc.\n         _ => panic!(\"Trying to get body for item type without body\"),"}, {"sha": "81b790c5f954013c05f435b71f276b4d888e0145", "filename": "crates/ra_hir/src/function.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -7,7 +7,7 @@ use std::{\n \n use ra_db::Cancelable;\n use ra_syntax::{\n-    TextRange, TextUnit,\n+    TextRange, TextUnit, TreePtr,\n     ast::{self, AstNode, DocCommentsOwner, NameOwner},\n };\n \n@@ -29,11 +29,11 @@ impl Function {\n         self.def_id\n     }\n \n-    pub fn syntax(&self, db: &impl HirDatabase) -> ast::FnDefNode {\n+    pub fn syntax(&self, db: &impl HirDatabase) -> TreePtr<ast::FnDef> {\n         let def_loc = self.def_id.loc(db);\n         assert!(def_loc.kind == DefKind::Function);\n         let syntax = db.file_item(def_loc.source_item_id);\n-        ast::FnDef::cast(syntax.borrowed()).unwrap().owned()\n+        ast::FnDef::cast(&syntax).unwrap().to_owned()\n     }\n \n     pub fn body(&self, db: &impl HirDatabase) -> Cancelable<Arc<Body>> {\n@@ -59,7 +59,7 @@ impl Function {\n \n     pub fn signature_info(&self, db: &impl HirDatabase) -> Option<FnSignatureInfo> {\n         let syntax = self.syntax(db);\n-        FnSignatureInfo::new(syntax.borrowed())\n+        FnSignatureInfo::new(&syntax)\n     }\n \n     pub fn infer(&self, db: &impl HirDatabase) -> Cancelable<Arc<InferenceResult>> {\n@@ -99,8 +99,7 @@ impl FnSignature {\n \n pub(crate) fn fn_signature(db: &impl HirDatabase, def_id: DefId) -> Arc<FnSignature> {\n     let func = Function::new(def_id);\n-    let syntax = func.syntax(db);\n-    let node = syntax.borrowed();\n+    let node = func.syntax(db);\n     let mut args = Vec::new();\n     if let Some(param_list) = node.param_list() {\n         if let Some(self_param) = param_list.self_param() {\n@@ -144,7 +143,7 @@ pub struct FnSignatureInfo {\n }\n \n impl FnSignatureInfo {\n-    fn new(node: ast::FnDef) -> Option<Self> {\n+    fn new(node: &ast::FnDef) -> Option<Self> {\n         let name = node.name()?.text().to_string();\n \n         let mut doc = None;\n@@ -207,7 +206,7 @@ impl FnSignatureInfo {\n         })\n     }\n \n-    fn extract_doc_comments(node: ast::FnDef) -> Option<(TextRange, String)> {\n+    fn extract_doc_comments(node: &ast::FnDef) -> Option<(TextRange, String)> {\n         if node.doc_comments().count() == 0 {\n             return None;\n         }\n@@ -227,7 +226,7 @@ impl FnSignatureInfo {\n         Some((range, comment_text))\n     }\n \n-    fn param_list(node: ast::FnDef) -> Vec<String> {\n+    fn param_list(node: &ast::FnDef) -> Vec<String> {\n         let mut res = vec![];\n         if let Some(param_list) = node.param_list() {\n             if let Some(self_param) = param_list.self_param() {"}, {"sha": "699784f71fe361ad10b09cea5e935023c06c34f9", "filename": "crates/ra_hir/src/function/scope.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use ra_syntax::{\n-    AstNode, SyntaxNodeRef, TextUnit, TextRange,\n+    AstNode, SyntaxNode, TextUnit, TextRange,\n     algo::generate,\n     ast,\n };\n@@ -127,7 +127,7 @@ impl ScopeEntryWithSyntax {\n }\n \n impl ScopesWithSyntaxMapping {\n-    pub fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item = ScopeId> + 'a {\n+    pub fn scope_chain<'a>(&'a self, node: &SyntaxNode) -> impl Iterator<Item = ScopeId> + 'a {\n         generate(self.scope_for(node), move |&scope| {\n             self.scopes.scopes[scope].parent\n         })\n@@ -178,7 +178,7 @@ impl ScopesWithSyntaxMapping {\n             .unwrap_or(original_scope)\n     }\n \n-    pub fn resolve_local_name(&self, name_ref: ast::NameRef) -> Option<ScopeEntryWithSyntax> {\n+    pub fn resolve_local_name(&self, name_ref: &ast::NameRef) -> Option<ScopeEntryWithSyntax> {\n         let mut shadowed = FxHashSet::default();\n         let name = name_ref.as_name();\n         let ret = self\n@@ -195,7 +195,7 @@ impl ScopesWithSyntaxMapping {\n         })\n     }\n \n-    pub fn find_all_refs(&self, pat: ast::BindPat) -> Vec<ReferenceDescriptor> {\n+    pub fn find_all_refs(&self, pat: &ast::BindPat) -> Vec<ReferenceDescriptor> {\n         let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n         let name_ptr = LocalSyntaxPtr::new(pat.syntax());\n         fn_def\n@@ -213,7 +213,7 @@ impl ScopesWithSyntaxMapping {\n             .collect()\n     }\n \n-    fn scope_for(&self, node: SyntaxNodeRef) -> Option<ScopeId> {\n+    fn scope_for(&self, node: &SyntaxNode) -> Option<ScopeId> {\n         node.ancestors()\n             .map(LocalSyntaxPtr::new)\n             .filter_map(|ptr| self.syntax_mapping.syntax_expr(ptr))\n@@ -309,7 +309,7 @@ pub struct ReferenceDescriptor {\n #[cfg(test)]\n mod tests {\n     use ra_editor::find_node_at_offset;\n-    use ra_syntax::SourceFileNode;\n+    use ra_syntax::SourceFile;\n     use test_utils::{extract_offset, assert_eq_text};\n \n     use crate::expr;\n@@ -326,9 +326,9 @@ mod tests {\n             buf.push_str(&code[off..]);\n             buf\n         };\n-        let file = SourceFileNode::parse(&code);\n-        let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n-        let fn_def: ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let file = SourceFile::parse(&code);\n+        let marker: &ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n+        let fn_def: &ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n         let body_hir = expr::collect_fn_body_syntax(fn_def);\n         let scopes = FnScopes::new(Arc::clone(body_hir.body()));\n         let scopes = ScopesWithSyntaxMapping {\n@@ -422,9 +422,9 @@ mod tests {\n \n     fn do_check_local_name(code: &str, expected_offset: u32) {\n         let (off, code) = extract_offset(code);\n-        let file = SourceFileNode::parse(&code);\n-        let fn_def: ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n-        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let file = SourceFile::parse(&code);\n+        let fn_def: &ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let name_ref: &ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n \n         let body_hir = expr::collect_fn_body_syntax(fn_def);\n         let scopes = FnScopes::new(Arc::clone(body_hir.body()));"}, {"sha": "730a3e542bc8b2a866ad0d1985cd052f8b9b0e1a", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -1,5 +1,5 @@\n use ra_db::{SourceRootId, LocationIntener, Cancelable, FileId};\n-use ra_syntax::{SourceFileNode, SyntaxKind, SyntaxNode, SyntaxNodeRef, SourceFile, AstNode, ast};\n+use ra_syntax::{TreePtr, SyntaxKind, SyntaxNode, SourceFile, AstNode, ast};\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n use crate::{HirDatabase, PerNs, ModuleId, Def, Function, Struct, Enum, ImplBlock, Crate};\n@@ -55,15 +55,18 @@ impl HirFileId {\n         }\n     }\n \n-    pub(crate) fn hir_source_file(db: &impl HirDatabase, file_id: HirFileId) -> SourceFileNode {\n+    pub(crate) fn hir_source_file(\n+        db: &impl HirDatabase,\n+        file_id: HirFileId,\n+    ) -> TreePtr<SourceFile> {\n         match file_id.0 {\n             HirFileIdRepr::File(file_id) => db.source_file(file_id),\n             HirFileIdRepr::Macro(m) => {\n                 if let Some(exp) = db.expand_macro_invocation(m) {\n                     return exp.file();\n                 }\n                 // returning an empty string looks fishy...\n-                SourceFileNode::parse(\"\")\n+                SourceFile::parse(\"\")\n             }\n         }\n     }\n@@ -233,11 +236,11 @@ pub struct SourceItemId {\n #[derive(Debug, PartialEq, Eq)]\n pub struct SourceFileItems {\n     file_id: HirFileId,\n-    arena: Arena<SourceFileItemId, SyntaxNode>,\n+    arena: Arena<SourceFileItemId, TreePtr<SyntaxNode>>,\n }\n \n impl SourceFileItems {\n-    pub(crate) fn new(file_id: HirFileId, source_file: SourceFile) -> SourceFileItems {\n+    pub(crate) fn new(file_id: HirFileId, source_file: &SourceFile) -> SourceFileItems {\n         let mut res = SourceFileItems {\n             file_id,\n             arena: Arena::default(),\n@@ -246,29 +249,29 @@ impl SourceFileItems {\n         res\n     }\n \n-    fn init(&mut self, source_file: SourceFile) {\n+    fn init(&mut self, source_file: &SourceFile) {\n         source_file.syntax().descendants().for_each(|it| {\n             if let Some(module_item) = ast::ModuleItem::cast(it) {\n-                self.alloc(module_item.syntax().owned());\n+                self.alloc(module_item.syntax().to_owned());\n             } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n-                self.alloc(macro_call.syntax().owned());\n+                self.alloc(macro_call.syntax().to_owned());\n             }\n         });\n     }\n \n-    fn alloc(&mut self, item: SyntaxNode) -> SourceFileItemId {\n+    fn alloc(&mut self, item: TreePtr<SyntaxNode>) -> SourceFileItemId {\n         self.arena.alloc(item)\n     }\n-    pub(crate) fn id_of(&self, file_id: HirFileId, item: SyntaxNodeRef) -> SourceFileItemId {\n+    pub(crate) fn id_of(&self, file_id: HirFileId, item: &SyntaxNode) -> SourceFileItemId {\n         assert_eq!(\n             self.file_id, file_id,\n             \"SourceFileItems: wrong file, expected {:?}, got {:?}\",\n             self.file_id, file_id\n         );\n         self.id_of_unchecked(item)\n     }\n-    pub(crate) fn id_of_unchecked(&self, item: SyntaxNodeRef) -> SourceFileItemId {\n-        if let Some((id, _)) = self.arena.iter().find(|(_id, i)| i.borrowed() == item) {\n+    pub(crate) fn id_of_unchecked(&self, item: &SyntaxNode) -> SourceFileItemId {\n+        if let Some((id, _)) = self.arena.iter().find(|(_id, i)| *i == item) {\n             return id;\n         }\n         // This should not happen. Let's try to give a sensible diagnostics."}, {"sha": "bb0ad84e47e5bc526d3d979f418990cb9d80b6d5", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -62,7 +62,7 @@ impl ImplData {\n         db: &impl AsRef<LocationIntener<DefLoc, DefId>>,\n         file_items: &SourceFileItems,\n         module: &Module,\n-        node: ast::ImplBlock,\n+        node: &ast::ImplBlock,\n     ) -> Self {\n         let target_trait = node.target_type().map(TypeRef::from_ast);\n         let target_type = TypeRef::from_ast_opt(node.target_type());\n@@ -71,10 +71,10 @@ impl ImplData {\n             item_list\n                 .impl_items()\n                 .map(|item_node| {\n-                    let kind = match item_node {\n-                        ast::ImplItem::FnDef(..) => DefKind::Function,\n-                        ast::ImplItem::ConstDef(..) => DefKind::Item,\n-                        ast::ImplItem::TypeDef(..) => DefKind::Item,\n+                    let kind = match item_node.kind() {\n+                        ast::ImplItemKind::FnDef(..) => DefKind::Function,\n+                        ast::ImplItemKind::ConstDef(..) => DefKind::Item,\n+                        ast::ImplItemKind::TypeDef(..) => DefKind::Item,\n                     };\n                     let item_id = file_items.id_of_unchecked(item_node.syntax());\n                     let source_item_id = SourceItemId {\n@@ -87,10 +87,10 @@ impl ImplData {\n                         ..module_loc\n                     };\n                     let def_id = def_loc.id(db);\n-                    match item_node {\n-                        ast::ImplItem::FnDef(..) => ImplItem::Method(Function::new(def_id)),\n-                        ast::ImplItem::ConstDef(..) => ImplItem::Const(def_id),\n-                        ast::ImplItem::TypeDef(..) => ImplItem::Type(def_id),\n+                    match item_node.kind() {\n+                        ast::ImplItemKind::FnDef(..) => ImplItem::Method(Function::new(def_id)),\n+                        ast::ImplItemKind::ConstDef(..) => ImplItem::Const(def_id),\n+                        ast::ImplItemKind::TypeDef(..) => ImplItem::Type(def_id),\n                     }\n                 })\n                 .collect()\n@@ -152,8 +152,8 @@ impl ModuleImplBlocks {\n     fn collect(&mut self, db: &impl HirDatabase, module: Module) -> Cancelable<()> {\n         let (file_id, module_source) = module.defenition_source(db)?;\n         let node = match &module_source {\n-            ModuleSource::SourceFile(node) => node.borrowed().syntax(),\n-            ModuleSource::Module(node) => node.borrowed().syntax(),\n+            ModuleSource::SourceFile(node) => node.syntax(),\n+            ModuleSource::Module(node) => node.syntax(),\n         };\n \n         let source_file_items = db.file_items(file_id.into());"}, {"sha": "eb1c86091ef28c685b51ce3a7cf148450e50a8c9", "filename": "crates/ra_hir/src/macros.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmacros.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -11,7 +11,7 @@ use std::sync::Arc;\n \n use ra_db::LocalSyntaxPtr;\n use ra_syntax::{\n-    TextRange, TextUnit, SourceFileNode, AstNode, SyntaxNode,\n+    TextRange, TextUnit, SourceFile, AstNode, SyntaxNode, TreePtr,\n     ast::{self, NameOwner},\n };\n \n@@ -28,14 +28,14 @@ pub enum MacroDef {\n impl MacroDef {\n     /// Expands macro call, returning the expansion and offset to be used to\n     /// convert ranges between expansion and original source.\n-    pub fn ast_expand(macro_call: ast::MacroCall) -> Option<(TextUnit, MacroExpansion)> {\n+    pub fn ast_expand(macro_call: &ast::MacroCall) -> Option<(TextUnit, MacroExpansion)> {\n         let (def, input) = MacroDef::from_call(macro_call)?;\n         let exp = def.expand(input)?;\n         let off = macro_call.token_tree()?.syntax().range().start();\n         Some((off, exp))\n     }\n \n-    fn from_call(macro_call: ast::MacroCall) -> Option<(MacroDef, MacroInput)> {\n+    fn from_call(macro_call: &ast::MacroCall) -> Option<(MacroDef, MacroInput)> {\n         let def = {\n             let path = macro_call.path()?;\n             let name_ref = path.segment()?.name_ref()?;\n@@ -77,7 +77,7 @@ impl MacroDef {\n                 }}\",\n             input.text\n         );\n-        let file = SourceFileNode::parse(&text);\n+        let file = SourceFile::parse(&text);\n         let match_expr = file.syntax().descendants().find_map(ast::MatchExpr::cast)?;\n         let match_arg = match_expr.expr()?;\n         let ptr = LocalSyntaxPtr::new(match_arg.syntax());\n@@ -92,7 +92,7 @@ impl MacroDef {\n     }\n     fn expand_vec(self, input: MacroInput) -> Option<MacroExpansion> {\n         let text = format!(r\"fn dummy() {{ {}; }}\", input.text);\n-        let file = SourceFileNode::parse(&text);\n+        let file = SourceFile::parse(&text);\n         let array_expr = file.syntax().descendants().find_map(ast::ArrayExpr::cast)?;\n         let ptr = LocalSyntaxPtr::new(array_expr.syntax());\n         let src_range = TextRange::offset_len(0.into(), TextUnit::of_str(&input.text));\n@@ -116,7 +116,7 @@ impl MacroDef {\n         }\n         let src_range = TextRange::offset_len((pos as u32).into(), TextUnit::of_str(&trait_name));\n         let text = format!(r\"trait {} {{ }}\", trait_name);\n-        let file = SourceFileNode::parse(&text);\n+        let file = SourceFile::parse(&text);\n         let trait_def = file.syntax().descendants().find_map(ast::TraitDef::cast)?;\n         let name = trait_def.name()?;\n         let ptr = LocalSyntaxPtr::new(trait_def.syntax());\n@@ -152,11 +152,11 @@ pub struct MacroExpansion {\n impl MacroExpansion {\n     // FIXME: does not really make sense, macro expansion is not neccessary a\n     // whole file. See `MacroExpansion::ptr` as well.\n-    pub(crate) fn file(&self) -> SourceFileNode {\n-        SourceFileNode::parse(&self.text)\n+    pub(crate) fn file(&self) -> TreePtr<SourceFile> {\n+        SourceFile::parse(&self.text)\n     }\n \n-    pub fn syntax(&self) -> SyntaxNode {\n+    pub fn syntax(&self) -> TreePtr<SyntaxNode> {\n         self.ptr.resolve(&self.file())\n     }\n     /// Maps range in the source code to the range in the expanded code.\n@@ -191,8 +191,7 @@ pub(crate) fn expand_macro_invocation(\n ) -> Option<Arc<MacroExpansion>> {\n     let loc = invoc.loc(db);\n     let syntax = db.file_item(loc.source_item_id);\n-    let syntax = syntax.borrowed();\n-    let macro_call = ast::MacroCall::cast(syntax).unwrap();\n+    let macro_call = ast::MacroCall::cast(&syntax).unwrap();\n \n     let (def, input) = MacroDef::from_call(macro_call)?;\n     def.expand(input).map(Arc::new)"}, {"sha": "91aab5c74ce59367115f9142f2e88063e7416d2c", "filename": "crates/ra_hir/src/module_tree.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -5,9 +5,9 @@ use arrayvec::ArrayVec;\n use relative_path::RelativePathBuf;\n use ra_db::{FileId, SourceRootId, Cancelable, SourceRoot};\n use ra_syntax::{\n+    SyntaxNode, TreePtr,\n     algo::generate,\n     ast::{self, AstNode, NameOwner},\n-    SyntaxNode,\n };\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n@@ -19,12 +19,11 @@ impl ModuleSource {\n         source_item_id: SourceItemId,\n     ) -> ModuleSource {\n         let module_syntax = db.file_item(source_item_id);\n-        let module_syntax = module_syntax.borrowed();\n-        if let Some(source_file) = ast::SourceFile::cast(module_syntax) {\n-            ModuleSource::SourceFile(source_file.owned())\n-        } else if let Some(module) = ast::Module::cast(module_syntax) {\n+        if let Some(source_file) = ast::SourceFile::cast(&module_syntax) {\n+            ModuleSource::SourceFile(source_file.to_owned())\n+        } else if let Some(module) = ast::Module::cast(&module_syntax) {\n             assert!(module.item_list().is_some(), \"expected inline module\");\n-            ModuleSource::Module(module.owned())\n+            ModuleSource::Module(module.to_owned())\n         } else {\n             panic!(\"expected file or inline module\")\n         }\n@@ -49,19 +48,18 @@ impl Submodule {\n         let module_source = ModuleSource::from_source_item_id(db, source);\n         let submodules = match module_source {\n             ModuleSource::SourceFile(source_file) => {\n-                collect_submodules(file_id, &file_items, source_file.borrowed())\n+                collect_submodules(file_id, &file_items, &*source_file)\n             }\n             ModuleSource::Module(module) => {\n-                let module = module.borrowed();\n                 collect_submodules(file_id, &file_items, module.item_list().unwrap())\n             }\n         };\n         return Ok(Arc::new(submodules));\n \n-        fn collect_submodules<'a>(\n+        fn collect_submodules(\n             file_id: HirFileId,\n             file_items: &SourceFileItems,\n-            root: impl ast::ModuleItemOwner<'a>,\n+            root: &impl ast::ModuleItemOwner,\n         ) -> Vec<Submodule> {\n             modules(root)\n                 .map(|(name, m)| Submodule {\n@@ -120,8 +118,8 @@ impl ModuleTree {\n         source_root: SourceRootId,\n     ) -> Cancelable<Arc<ModuleTree>> {\n         db.check_canceled()?;\n-        let res = create_module_tree(db, source_root)?;\n-        Ok(Arc::new(res))\n+        let res = create_module_tree(db, source_root);\n+        Ok(Arc::new(res?))\n     }\n \n     pub(crate) fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n@@ -172,14 +170,14 @@ impl ModuleId {\n         self,\n         tree: &ModuleTree,\n         db: &impl HirDatabase,\n-    ) -> Vec<(SyntaxNode, Problem)> {\n+    ) -> Vec<(TreePtr<SyntaxNode>, Problem)> {\n         tree.mods[self]\n             .children\n             .iter()\n             .filter_map(|&link| {\n                 let p = tree.links[link].problem.clone()?;\n                 let s = link.source(tree, db);\n-                let s = s.borrowed().name().unwrap().syntax().owned();\n+                let s = s.name().unwrap().syntax().to_owned();\n                 Some((s, p))\n             })\n             .collect()\n@@ -193,11 +191,9 @@ impl LinkId {\n     pub(crate) fn name(self, tree: &ModuleTree) -> &Name {\n         &tree.links[self].name\n     }\n-    pub(crate) fn source(self, tree: &ModuleTree, db: &impl HirDatabase) -> ast::ModuleNode {\n+    pub(crate) fn source(self, tree: &ModuleTree, db: &impl HirDatabase) -> TreePtr<ast::Module> {\n         let syntax_node = db.file_item(tree.links[self].source);\n-        ast::ModuleNode::cast(syntax_node.borrowed())\n-            .unwrap()\n-            .owned()\n+        ast::Module::cast(&syntax_node).unwrap().to_owned()\n     }\n }\n \n@@ -213,12 +209,10 @@ impl ModuleTree {\n     }\n }\n \n-fn modules<'a>(\n-    root: impl ast::ModuleItemOwner<'a>,\n-) -> impl Iterator<Item = (Name, ast::Module<'a>)> {\n+fn modules(root: &impl ast::ModuleItemOwner) -> impl Iterator<Item = (Name, &ast::Module)> {\n     root.items()\n-        .filter_map(|item| match item {\n-            ast::ModuleItem::Module(m) => Some(m),\n+        .filter_map(|item| match item.kind() {\n+            ast::ModuleItemKind::Module(m) => Some(m),\n             _ => None,\n         })\n         .filter_map(|module| {"}, {"sha": "dee1c9c5c518cc65c1a954d12d0608083713c44c", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -74,13 +74,13 @@ pub(crate) trait AsName {\n     fn as_name(&self) -> Name;\n }\n \n-impl AsName for ast::NameRef<'_> {\n+impl AsName for ast::NameRef {\n     fn as_name(&self) -> Name {\n         Name::new(self.text())\n     }\n }\n \n-impl AsName for ast::Name<'_> {\n+impl AsName for ast::Name {\n     fn as_name(&self) -> Name {\n         Name::new(self.text())\n     }"}, {"sha": "749fd604eb4d210f7aff959c9a4b9ded3e51b8fb", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -103,7 +103,7 @@ impl NamedImport {\n             item_id: Some(self.file_item_id),\n         };\n         let syntax = db.file_item(source_item_id);\n-        let offset = syntax.borrowed().range().start();\n+        let offset = syntax.range().start();\n         self.relative_range + offset\n     }\n }\n@@ -215,45 +215,45 @@ impl InputModuleItems {\n         &mut self,\n         file_id: HirFileId,\n         file_items: &SourceFileItems,\n-        item: ast::ModuleItem,\n+        item: &ast::ModuleItem,\n     ) -> Option<()> {\n-        match item {\n-            ast::ModuleItem::StructDef(it) => {\n+        match item.kind() {\n+            ast::ModuleItemKind::StructDef(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n-            ast::ModuleItem::EnumDef(it) => {\n+            ast::ModuleItemKind::EnumDef(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n-            ast::ModuleItem::FnDef(it) => {\n+            ast::ModuleItemKind::FnDef(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n-            ast::ModuleItem::TraitDef(it) => {\n+            ast::ModuleItemKind::TraitDef(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n-            ast::ModuleItem::TypeDef(it) => {\n+            ast::ModuleItemKind::TypeDef(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n-            ast::ModuleItem::ImplBlock(_) => {\n+            ast::ModuleItemKind::ImplBlock(_) => {\n                 // impls don't define items\n             }\n-            ast::ModuleItem::UseItem(it) => self.add_use_item(file_items, it),\n-            ast::ModuleItem::ExternCrateItem(_) => {\n+            ast::ModuleItemKind::UseItem(it) => self.add_use_item(file_items, it),\n+            ast::ModuleItemKind::ExternCrateItem(_) => {\n                 // TODO\n             }\n-            ast::ModuleItem::ConstDef(it) => {\n+            ast::ModuleItemKind::ConstDef(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n-            ast::ModuleItem::StaticDef(it) => {\n+            ast::ModuleItemKind::StaticDef(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n-            ast::ModuleItem::Module(it) => {\n+            ast::ModuleItemKind::Module(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n         }\n         Some(())\n     }\n \n-    fn add_use_item(&mut self, file_items: &SourceFileItems, item: ast::UseItem) {\n+    fn add_use_item(&mut self, file_items: &SourceFileItems, item: &ast::UseItem) {\n         let file_item_id = file_items.id_of_unchecked(item.syntax());\n         let start_offset = item.syntax().range().start();\n         Path::expand_use_item(item, |path, range| {\n@@ -270,10 +270,10 @@ impl InputModuleItems {\n }\n \n impl ModuleItem {\n-    fn new<'a>(\n+    fn new(\n         file_id: HirFileId,\n         file_items: &SourceFileItems,\n-        item: impl ast::NameOwner<'a>,\n+        item: &impl ast::NameOwner,\n     ) -> Option<ModuleItem> {\n         let name = item.name()?.as_name();\n         let kind = item.syntax().kind();"}, {"sha": "6f0b0da97a6eadf9c98fd66ee9241fd1a6c9623d", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -18,14 +18,14 @@ pub enum PathKind {\n \n impl Path {\n     /// Calls `cb` with all paths, represented by this use item.\n-    pub fn expand_use_item(item: ast::UseItem, mut cb: impl FnMut(Path, Option<TextRange>)) {\n+    pub fn expand_use_item(item: &ast::UseItem, mut cb: impl FnMut(Path, Option<TextRange>)) {\n         if let Some(tree) = item.use_tree() {\n             expand_use_tree(None, tree, &mut cb);\n         }\n     }\n \n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n-    pub fn from_ast(mut path: ast::Path) -> Option<Path> {\n+    pub fn from_ast(mut path: &ast::Path) -> Option<Path> {\n         let mut kind = PathKind::Plain;\n         let mut segments = Vec::new();\n         loop {\n@@ -53,7 +53,7 @@ impl Path {\n         segments.reverse();\n         return Some(Path { kind, segments });\n \n-        fn qualifier(path: ast::Path) -> Option<ast::Path> {\n+        fn qualifier(path: &ast::Path) -> Option<&ast::Path> {\n             if let Some(q) = path.qualifier() {\n                 return Some(q);\n             }\n@@ -66,7 +66,7 @@ impl Path {\n     }\n \n     /// Converts an `ast::NameRef` into a single-identifier `Path`.\n-    pub fn from_name_ref(name_ref: ast::NameRef) -> Path {\n+    pub fn from_name_ref(name_ref: &ast::NameRef) -> Path {\n         name_ref.as_name().into()\n     }\n \n@@ -100,7 +100,7 @@ impl From<Name> for Path {\n \n fn expand_use_tree(\n     prefix: Option<Path>,\n-    tree: ast::UseTree,\n+    tree: &ast::UseTree,\n     cb: &mut impl FnMut(Path, Option<TextRange>),\n ) {\n     if let Some(use_tree_list) = tree.use_tree_list() {\n@@ -146,7 +146,7 @@ fn expand_use_tree(\n     }\n }\n \n-fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n+fn convert_path(prefix: Option<Path>, path: &ast::Path) -> Option<Path> {\n     let prefix = if let Some(qual) = path.qualifier() {\n         Some(convert_path(prefix, qual)?)\n     } else {"}, {"sha": "380ea5410452fab0b4dbf1d18dd32df56231e445", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -5,7 +5,7 @@ use std::{\n \n use rustc_hash::FxHashMap;\n use ra_syntax::{\n-    AstNode, SyntaxNode,\n+    AstNode, SyntaxNode, TreePtr,\n     ast::{self, ModuleItemOwner}\n };\n use ra_db::{SourceRootId, Cancelable,};\n@@ -31,30 +31,34 @@ pub(super) fn struct_data(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ar\n     assert!(def_loc.kind == DefKind::Struct);\n     let syntax = db.file_item(def_loc.source_item_id);\n     let struct_def =\n-        ast::StructDef::cast(syntax.borrowed()).expect(\"struct def should point to StructDef node\");\n-    Ok(Arc::new(StructData::new(struct_def.borrowed())))\n+        ast::StructDef::cast(&syntax).expect(\"struct def should point to StructDef node\");\n+    Ok(Arc::new(StructData::new(struct_def)))\n }\n \n pub(super) fn enum_data(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<EnumData>> {\n     let def_loc = def_id.loc(db);\n     assert!(def_loc.kind == DefKind::Enum);\n     let syntax = db.file_item(def_loc.source_item_id);\n-    let enum_def =\n-        ast::EnumDef::cast(syntax.borrowed()).expect(\"enum def should point to EnumDef node\");\n-    Ok(Arc::new(EnumData::new(enum_def.borrowed())))\n+    let enum_def = ast::EnumDef::cast(&syntax).expect(\"enum def should point to EnumDef node\");\n+    Ok(Arc::new(EnumData::new(enum_def)))\n }\n \n pub(super) fn file_items(db: &impl HirDatabase, file_id: HirFileId) -> Arc<SourceFileItems> {\n     let source_file = db.hir_source_file(file_id);\n-    let source_file = source_file.borrowed();\n-    let res = SourceFileItems::new(file_id, source_file);\n+    let res = SourceFileItems::new(file_id, &source_file);\n     Arc::new(res)\n }\n \n-pub(super) fn file_item(db: &impl HirDatabase, source_item_id: SourceItemId) -> SyntaxNode {\n+pub(super) fn file_item(\n+    db: &impl HirDatabase,\n+    source_item_id: SourceItemId,\n+) -> TreePtr<SyntaxNode> {\n     match source_item_id.item_id {\n-        Some(id) => db.file_items(source_item_id.file_id)[id].clone(),\n-        None => db.hir_source_file(source_item_id.file_id).syntax().owned(),\n+        Some(id) => db.file_items(source_item_id.file_id)[id].to_owned(),\n+        None => db\n+            .hir_source_file(source_item_id.file_id)\n+            .syntax()\n+            .to_owned(),\n     }\n }\n \n@@ -88,7 +92,7 @@ pub(super) fn input_module_items(\n                     let file_id = HirFileId::from(id);\n                     let file_items = db.file_items(file_id);\n                     //FIXME: expand recursively\n-                    for item in db.hir_source_file(file_id).borrowed().items() {\n+                    for item in db.hir_source_file(file_id).items() {\n                         acc.add_item(file_id, &file_items, item);\n                     }\n                 }\n@@ -98,9 +102,9 @@ pub(super) fn input_module_items(\n \n     let mut res = InputModuleItems::default();\n     match source {\n-        ModuleSource::SourceFile(it) => fill(&mut res, &mut it.borrowed().items_with_macros()),\n+        ModuleSource::SourceFile(it) => fill(&mut res, &mut it.items_with_macros()),\n         ModuleSource::Module(it) => {\n-            if let Some(item_list) = it.borrowed().item_list() {\n+            if let Some(item_list) = it.item_list() {\n                 fill(&mut res, &mut item_list.items_with_macros())\n             }\n         }"}, {"sha": "82675c0e44f302347553cc23c839e6e19bb39639", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -8,7 +8,7 @@\n use ra_db::{FileId, FilePosition, Cancelable};\n use ra_editor::find_node_at_offset;\n use ra_syntax::{\n-    SmolStr, TextRange, SyntaxNodeRef,\n+    SmolStr, TextRange, SyntaxNode,\n     ast::{self, AstNode, NameOwner},\n };\n \n@@ -30,7 +30,7 @@ pub fn module_from_file_id(db: &impl HirDatabase, file_id: FileId) -> Cancelable\n pub fn module_from_declaration(\n     db: &impl HirDatabase,\n     file_id: FileId,\n-    decl: ast::Module,\n+    decl: &ast::Module,\n ) -> Cancelable<Option<Module>> {\n     let parent_module = module_from_file_id(db, file_id)?;\n     let child_name = decl.name();\n@@ -60,7 +60,7 @@ pub fn module_from_position(\n fn module_from_inline(\n     db: &impl HirDatabase,\n     file_id: FileId,\n-    module: ast::Module,\n+    module: &ast::Module,\n ) -> Cancelable<Option<Module>> {\n     assert!(!module.has_semi());\n     let file_id = file_id.into();\n@@ -77,7 +77,7 @@ fn module_from_inline(\n pub fn module_from_child_node(\n     db: &impl HirDatabase,\n     file_id: FileId,\n-    child: SyntaxNodeRef,\n+    child: &SyntaxNode,\n ) -> Cancelable<Option<Module>> {\n     if let Some(m) = child\n         .ancestors()\n@@ -112,7 +112,7 @@ pub fn function_from_position(\n pub fn function_from_source(\n     db: &impl HirDatabase,\n     file_id: FileId,\n-    fn_def: ast::FnDef,\n+    fn_def: &ast::FnDef,\n ) -> Cancelable<Option<Function>> {\n     let module = ctry!(module_from_child_node(db, file_id, fn_def.syntax())?);\n     let res = function_from_module(db, &module, fn_def);\n@@ -122,7 +122,7 @@ pub fn function_from_source(\n pub fn function_from_module(\n     db: &impl HirDatabase,\n     module: &Module,\n-    fn_def: ast::FnDef,\n+    fn_def: &ast::FnDef,\n ) -> Function {\n     let loc = module.def_id.loc(db);\n     let file_id = loc.source_item_id.file_id;\n@@ -144,7 +144,7 @@ pub fn function_from_module(\n pub fn function_from_child_node(\n     db: &impl HirDatabase,\n     file_id: FileId,\n-    node: SyntaxNodeRef,\n+    node: &SyntaxNode,\n ) -> Cancelable<Option<Function>> {\n     let fn_def = ctry!(node.ancestors().find_map(ast::FnDef::cast));\n     function_from_source(db, file_id, fn_def)\n@@ -170,8 +170,7 @@ pub fn macro_symbols(\n         if let Some(exp) = db.expand_macro_invocation(macro_call_id) {\n             let loc = macro_call_id.loc(db);\n             let syntax = db.file_item(loc.source_item_id);\n-            let syntax = syntax.borrowed();\n-            let macro_call = ast::MacroCall::cast(syntax).unwrap();\n+            let macro_call = ast::MacroCall::cast(&syntax).unwrap();\n             let off = macro_call.token_tree().unwrap().syntax().range().start();\n             let file = exp.file();\n             for trait_def in file.syntax().descendants().filter_map(ast::TraitDef::cast) {"}, {"sha": "c9db4e0a58b11edcf48dde8e9b449201f1954547", "filename": "crates/ra_hir/src/type_ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -56,9 +56,9 @@ pub enum TypeRef {\n \n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n-    pub(crate) fn from_ast(node: ast::TypeRef) -> Self {\n-        use ra_syntax::ast::TypeRef::*;\n-        match node {\n+    pub(crate) fn from_ast(node: &ast::TypeRef) -> Self {\n+        use ra_syntax::ast::TypeRefKind::*;\n+        match node.kind() {\n             ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n             TupleType(inner) => TypeRef::Tuple(inner.fields().map(TypeRef::from_ast).collect()),\n             NeverType(..) => TypeRef::Never,\n@@ -100,7 +100,7 @@ impl TypeRef {\n         }\n     }\n \n-    pub(crate) fn from_ast_opt(node: Option<ast::TypeRef>) -> Self {\n+    pub(crate) fn from_ast_opt(node: Option<&ast::TypeRef>) -> Self {\n         if let Some(node) = node {\n             TypeRef::from_ast(node)\n         } else {"}, {"sha": "0e303ee986346fb17f06ec212e651563f56b9953", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -53,10 +53,37 @@ pub trait FnDefOwner: AstNode {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum ItemOrMacro<'a> {\n+    Item(&'a ModuleItem),\n+    Macro(&'a MacroCall),\n+}\n+\n pub trait ModuleItemOwner: AstNode {\n     fn items(&self) -> AstChildren<ModuleItem> {\n         children(self)\n     }\n+    fn items_with_macros(&self) -> ItemOrMacroIter {\n+        ItemOrMacroIter(self.syntax().children())\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ItemOrMacroIter<'a>(SyntaxNodeChildren<'a>);\n+\n+impl<'a> Iterator for ItemOrMacroIter<'a> {\n+    type Item = ItemOrMacro<'a>;\n+    fn next(&mut self) -> Option<ItemOrMacro<'a>> {\n+        loop {\n+            let n = self.0.next()?;\n+            if let Some(item) = ModuleItem::cast(n) {\n+                return Some(ItemOrMacro::Item(item));\n+            }\n+            if let Some(call) = MacroCall::cast(n) {\n+                return Some(ItemOrMacro::Macro(call));\n+            }\n+        }\n+    }\n }\n \n pub trait TypeParamsOwner: AstNode {"}, {"sha": "1bf1806b9cd5aca108f50b9ebb275983c624519d", "filename": "crates/ra_syntax/src/yellow.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_syntax%2Fsrc%2Fyellow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0b348ae9f629c5cbe4a836a90ed85e36ca18e5/crates%2Fra_syntax%2Fsrc%2Fyellow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow.rs?ref=da0b348ae9f629c5cbe4a836a90ed85e36ca18e5", "patch": "@@ -47,6 +47,17 @@ where\n     }\n }\n \n+impl<T> PartialEq<T> for TreePtr<T>\n+where\n+    T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>,\n+    T: PartialEq<T>,\n+{\n+    fn eq(&self, other: &T) -> bool {\n+        let t: &T = self;\n+        t == other\n+    }\n+}\n+\n impl<T> Clone for TreePtr<T>\n where\n     T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>,"}]}