{"sha": "e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzOGZiMzA2YjdmNWU2NWNjYTM0ZGYyZGFiMWYwZGIxNWUxZGVmYjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-14T20:21:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-14T20:21:20Z"}, "message": "Auto merge of #81018 - m-ou-se:rollup-7202dc7, r=m-ou-se\n\nRollup of 17 pull requests\n\nSuccessful merges:\n\n - #79982 (Add missing methods to unix ExitStatusExt)\n - #80017 (Suggest `_` and `..` if a pattern has too few fields)\n - #80169 (Recommend panic::resume_unwind instead of panicking.)\n - #80217 (Add a `std::io::read_to_string` function)\n - #80444 (Add as_ref and as_mut methods for Bound)\n - #80567 (Add Iterator::intersperse_with)\n - #80829 (Get rid of `DepConstructor`)\n - #80895 (Fix handling of malicious Readers in read_to_end)\n - #80966 (Deprecate atomic::spin_loop_hint in favour of hint::spin_loop)\n - #80969 (Use better ICE message when no MIR is available)\n - #80972 (Remove unstable deprecated Vec::remove_item)\n - #80973 (Update books)\n - #80980 (Fixed incorrect doc comment)\n - #80981 (Fix -Cpasses=list and llvm version print with -vV)\n - #80985 (Fix stabilisation version of slice_strip)\n - #80990 (llvm: Remove the unused context from CreateDebugLocation)\n - #80991 (Fix formatting specifiers doc links)\n\nFailed merges:\n\n - #80944 (Use Option::map_or instead of `.map(..).unwrap_or(..)`)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "82ce55bd5d569fce5159a700c2527b85199686dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82ce55bd5d569fce5159a700c2527b85199686dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "html_url": "https://github.com/rust-lang/rust/commit/e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4275ef6c9d994bb6d0e2f42e0ee0aa1603a3c8a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4275ef6c9d994bb6d0e2f42e0ee0aa1603a3c8a6", "html_url": "https://github.com/rust-lang/rust/commit/4275ef6c9d994bb6d0e2f42e0ee0aa1603a3c8a6"}, {"sha": "9c75ee6b3be2845a2995f1488c83f795701c8b56", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c75ee6b3be2845a2995f1488c83f795701c8b56", "html_url": "https://github.com/rust-lang/rust/commit/9c75ee6b3be2845a2995f1488c83f795701c8b56"}], "stats": {"total": 961, "additions": 798, "deletions": 163}, "files": [{"sha": "955e739b2c12612728452ed514fda94cee1a3741", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -552,7 +552,6 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         unsafe {\n             llvm::LLVMRustDIBuilderCreateDebugLocation(\n-                utils::debug_context(self).llcontext,\n                 line.unwrap_or(UNKNOWN_LINE_NUMBER),\n                 col.unwrap_or(UNKNOWN_COLUMN_NUMBER),\n                 scope,"}, {"sha": "eb4f36266dbaeaef998a3706a2093ee029193bea", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -2102,7 +2102,6 @@ extern \"C\" {\n     );\n \n     pub fn LLVMRustDIBuilderCreateDebugLocation(\n-        Context: &'a Context,\n         Line: c_uint,\n         Column: c_uint,\n         Scope: &'a DIScope,"}, {"sha": "f8ceb94916e7cd462568d91934dd860a696a1eb0", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -798,7 +798,7 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n         println!(\"commit-date: {}\", unw(util::commit_date_str()));\n         println!(\"host: {}\", config::host_triple());\n         println!(\"release: {}\", unw(util::release_str()));\n-        if cfg!(llvm) {\n+        if cfg!(feature = \"llvm\") {\n             get_builtin_codegen_backend(\"llvm\")().print_version();\n         }\n     }\n@@ -1087,7 +1087,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     if cg_flags.iter().any(|x| *x == \"passes=list\") {\n-        if cfg!(llvm) {\n+        if cfg!(feature = \"llvm\") {\n             get_builtin_codegen_backend(\"llvm\")().print_passes();\n         }\n         return None;"}, {"sha": "1d6f00562f136085f69e6ce6ab806f49351f1aad", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -994,11 +994,9 @@ LLVMRustDICompositeTypeReplaceArrays(LLVMRustDIBuilderRef Builder,\n }\n \n extern \"C\" LLVMMetadataRef\n-LLVMRustDIBuilderCreateDebugLocation(LLVMContextRef ContextRef, unsigned Line,\n-                                     unsigned Column, LLVMMetadataRef Scope,\n+LLVMRustDIBuilderCreateDebugLocation(unsigned Line, unsigned Column,\n+                                     LLVMMetadataRef Scope,\n                                      LLVMMetadataRef InlinedAt) {\n-  LLVMContext &Context = *unwrap(ContextRef);\n-\n   DebugLoc debug_loc = DebugLoc::get(Line, Column, unwrapDIPtr<MDNode>(Scope),\n                                      unwrapDIPtr<MDNode>(InlinedAt));\n "}, {"sha": "65e5301c96e9e64dc2913505c3f247d75a64985a", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -29,9 +29,10 @@\n //!   contained no `DefId` for thing that had been removed.\n //!\n //! `DepNode` definition happens in the `define_dep_nodes!()` macro. This macro\n-//! defines the `DepKind` enum and a corresponding `dep_constructor` module. The\n-//! `dep_constructor` module links a `DepKind` to the parameters that are needed at\n-//! runtime in order to construct a valid `DepNode` fingerprint.\n+//! defines the `DepKind` enum. Each `DepKind` has its own parameters that are\n+//! needed at runtime in order to construct a valid `DepNode` fingerprint.\n+//! However, only `CompileCodegenUnit` is constructed explicitly (with\n+//! `make_compile_codegen_unit`).\n //!\n //! Because the macro sees what parameters a given `DepKind` requires, it can\n //! \"infer\" some properties for each kind of `DepNode`:\n@@ -44,22 +45,14 @@\n //!   `DefId` it was computed from. In other cases, too much information gets\n //!   lost during fingerprint computation.\n //!\n-//! The `dep_constructor` module, together with `DepNode::new()`, ensures that only\n+//! `make_compile_codegen_unit`, together with `DepNode::new()`, ensures that only\n //! valid `DepNode` instances can be constructed. For example, the API does not\n //! allow for constructing parameterless `DepNode`s with anything other\n //! than a zeroed out fingerprint. More generally speaking, it relieves the\n //! user of the `DepNode` API of having to know how to compute the expected\n //! fingerprint for a given set of node parameters.\n \n-use crate::mir::interpret::{GlobalId, LitToConstInput};\n-use crate::traits;\n-use crate::traits::query::{\n-    CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n-    CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n-    CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n-};\n-use crate::ty::subst::{GenericArg, SubstsRef};\n-use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use crate::ty::TyCtxt;\n \n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX};\n@@ -338,25 +331,6 @@ macro_rules! define_dep_nodes {\n             $($variant),*\n         }\n \n-        #[allow(non_camel_case_types)]\n-        pub mod dep_constructor {\n-            use super::*;\n-\n-            $(\n-                #[inline(always)]\n-                #[allow(unreachable_code, non_snake_case)]\n-                pub fn $variant(_tcx: TyCtxt<'_>, $(arg: $tuple_arg_ty)*) -> DepNode {\n-                    // tuple args\n-                    $({\n-                        erase!($tuple_arg_ty);\n-                        return DepNode::construct(_tcx, DepKind::$variant, &arg)\n-                    })*\n-\n-                    return DepNode::construct(_tcx, DepKind::$variant, &())\n-                }\n-            )*\n-        }\n-\n         fn dep_kind_from_label_string(label: &str) -> Result<DepKind, ()> {\n             match label {\n                 $(stringify!($variant) => Ok(DepKind::$variant),)*\n@@ -384,9 +358,16 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n \n     [anon] TraitSelect,\n \n+    // WARNING: if `Symbol` is changed, make sure you update `make_compile_codegen_unit` below.\n     [] CompileCodegenUnit(Symbol),\n ]);\n \n+// WARNING: `construct` is generic and does not know that `CompileCodegenUnit` takes `Symbol`s as keys.\n+// Be very careful changing this type signature!\n+crate fn make_compile_codegen_unit(tcx: TyCtxt<'_>, name: Symbol) -> DepNode {\n+    DepNode::construct(tcx, DepKind::CompileCodegenUnit, &name)\n+}\n+\n pub type DepNode = rustc_query_system::dep_graph::DepNode<DepKind>;\n \n // We keep a lot of `DepNode`s in memory during compilation. It's not"}, {"sha": "ea4d8c129970929fd780c3aeffacca255a997b87", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -13,7 +13,8 @@ pub use rustc_query_system::dep_graph::{\n     WorkProduct, WorkProductId,\n };\n \n-pub use dep_node::{dep_constructor, label_strs, DepKind, DepNode, DepNodeExt};\n+crate use dep_node::make_compile_codegen_unit;\n+pub use dep_node::{label_strs, DepKind, DepNode, DepNodeExt};\n \n pub type DepGraph = rustc_query_system::dep_graph::DepGraph<DepKind>;\n pub type TaskDeps = rustc_query_system::dep_graph::TaskDeps<DepKind>;"}, {"sha": "6d5d408f86c15bf38096ff4f8f7cbcfd3d73b89c", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{dep_constructor, DepNode, WorkProduct, WorkProductId};\n+use crate::dep_graph::{DepNode, WorkProduct, WorkProductId};\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::ty::{subst::InternalSubsts, Instance, InstanceDef, SymbolName, TyCtxt};\n use rustc_attr::InlineAttr;\n@@ -362,7 +362,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn codegen_dep_node(&self, tcx: TyCtxt<'tcx>) -> DepNode {\n-        dep_constructor::CompileCodegenUnit(tcx, self.name())\n+        crate::dep_graph::make_compile_codegen_unit(tcx, self.name())\n     }\n }\n "}, {"sha": "75f80f69beafc54741c1f534537d1e3fd806792f", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -823,7 +823,7 @@ fn should_codegen_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx>) ->\n     }\n \n     if !tcx.is_mir_available(def_id) {\n-        bug!(\"cannot create local mono-item for {:?}\", def_id)\n+        bug!(\"no MIR available for {:?}\", def_id);\n     }\n \n     true"}, {"sha": "ecc6e8599ad01d2ccd7e8084fe69b9477f658441", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 52, "deletions": 5, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -15,6 +15,7 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::Ident;\n+use rustc_span::{BytePos, DUMMY_SP};\n use rustc_trait_selection::traits::{ObligationCause, Pattern};\n \n use std::cmp;\n@@ -1001,7 +1002,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // More generally, the expected type wants a tuple variant with one field of an\n         // N-arity-tuple, e.g., `V_i((p_0, .., p_N))`. Meanwhile, the user supplied a pattern\n         // with the subpatterns directly in the tuple variant pattern, e.g., `V_i(p_0, .., p_N)`.\n-        let missing_parenthesis = match (&expected.kind(), fields, had_err) {\n+        let missing_parentheses = match (&expected.kind(), fields, had_err) {\n             // #67037: only do this if we could successfully type-check the expected type against\n             // the tuple struct pattern. Otherwise the substs could get out of range on e.g.,\n             // `let P() = U;` where `P != U` with `struct P<T>(T);`.\n@@ -1014,13 +1015,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             _ => false,\n         };\n-        if missing_parenthesis {\n+        if missing_parentheses {\n             let (left, right) = match subpats {\n                 // This is the zero case; we aim to get the \"hi\" part of the `QPath`'s\n                 // span as the \"lo\" and then the \"hi\" part of the pattern's span as the \"hi\".\n                 // This looks like:\n                 //\n-                // help: missing parenthesis\n+                // help: missing parentheses\n                 //   |\n                 // L |     let A(()) = A(());\n                 //   |          ^  ^\n@@ -1029,17 +1030,63 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // last sub-pattern. In the case of `A(x)` the first and last may coincide.\n                 // This looks like:\n                 //\n-                // help: missing parenthesis\n+                // help: missing parentheses\n                 //   |\n                 // L |     let A((x, y)) = A((1, 2));\n                 //   |           ^    ^\n                 [first, ..] => (first.span.shrink_to_lo(), subpats.last().unwrap().span),\n             };\n             err.multipart_suggestion(\n-                \"missing parenthesis\",\n+                \"missing parentheses\",\n                 vec![(left, \"(\".to_string()), (right.shrink_to_hi(), \")\".to_string())],\n                 Applicability::MachineApplicable,\n             );\n+        } else if fields.len() > subpats.len() {\n+            let after_fields_span = if pat_span == DUMMY_SP {\n+                pat_span\n+            } else {\n+                pat_span.with_hi(pat_span.hi() - BytePos(1)).shrink_to_hi()\n+            };\n+            let all_fields_span = match subpats {\n+                [] => after_fields_span,\n+                [field] => field.span,\n+                [first, .., last] => first.span.to(last.span),\n+            };\n+\n+            // Check if all the fields in the pattern are wildcards.\n+            let all_wildcards = subpats.iter().all(|pat| matches!(pat.kind, PatKind::Wild));\n+\n+            let mut wildcard_sugg = vec![\"_\"; fields.len() - subpats.len()].join(\", \");\n+            if !subpats.is_empty() {\n+                wildcard_sugg = String::from(\", \") + &wildcard_sugg;\n+            }\n+\n+            err.span_suggestion_verbose(\n+                after_fields_span,\n+                \"use `_` to explicitly ignore each field\",\n+                wildcard_sugg,\n+                Applicability::MaybeIncorrect,\n+            );\n+\n+            // Only suggest `..` if more than one field is missing\n+            // or the pattern consists of all wildcards.\n+            if fields.len() - subpats.len() > 1 || all_wildcards {\n+                if subpats.is_empty() || all_wildcards {\n+                    err.span_suggestion_verbose(\n+                        all_fields_span,\n+                        \"use `..` to ignore all fields\",\n+                        String::from(\"..\"),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    err.span_suggestion_verbose(\n+                        after_fields_span,\n+                        \"use `..` to ignore the rest of the fields\",\n+                        String::from(\", ..\"),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n         }\n \n         err.emit();"}, {"sha": "5067af1d4ff688b5d6a43b6c5c8f08ccdf7860d2", "filename": "library/alloc/src/sync/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -370,7 +370,7 @@ fn test_weak_count_locked() {\n         let n = Arc::weak_count(&a2);\n         assert!(n < 2, \"bad weak count: {}\", n);\n         #[cfg(miri)] // Miri's scheduler does not guarantee liveness, and thus needs this hint.\n-        atomic::spin_loop_hint();\n+        std::hint::spin_loop();\n     }\n     t.join().unwrap();\n }"}, {"sha": "ccc4f03a1e5058193c220f209d8c1e18fa28f949", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -1953,27 +1953,6 @@ impl<T: PartialEq, A: Allocator> Vec<T, A> {\n     }\n }\n \n-impl<T, A: Allocator> Vec<T, A> {\n-    /// Removes the first instance of `item` from the vector if the item exists.\n-    ///\n-    /// This method will be removed soon.\n-    #[unstable(feature = \"vec_remove_item\", reason = \"recently added\", issue = \"40062\")]\n-    #[rustc_deprecated(\n-        reason = \"Removing the first item equal to a needle is already easily possible \\\n-            with iterators and the current Vec methods. Furthermore, having a method for \\\n-            one particular case of removal (linear search, only the first item, no swap remove) \\\n-            but not for others is inconsistent. This method will be removed soon.\",\n-        since = \"1.46.0\"\n-    )]\n-    pub fn remove_item<V>(&mut self, item: &V) -> Option<T>\n-    where\n-        T: PartialEq<V>,\n-    {\n-        let pos = self.iter().position(|x| *x == *item)?;\n-        Some(self.remove(pos))\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Internal methods and functions\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "73cf5d138bf7539cda07231a3b7f64549d814dc2", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -456,7 +456,9 @@ impl Display for Arguments<'_> {\n ///\n /// When used with the alternate format specifier `#?`, the output is pretty-printed.\n ///\n-/// For more information on formatters, see [the module-level documentation][self].\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../../std/fmt/index.html\n ///\n /// This trait can be used with `#[derive]` if all fields implement `Debug`. When\n /// `derive`d for structs, it will use the name of the `struct`, then `{`, then a\n@@ -602,7 +604,9 @@ pub use macros::Debug;\n /// `Display` is similar to [`Debug`], but `Display` is for user-facing\n /// output, and so cannot be derived.\n ///\n-/// For more information on formatters, see [the module-level documentation][self].\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../../std/fmt/index.html\n ///\n /// # Examples\n ///\n@@ -674,7 +678,9 @@ pub trait Display {\n ///\n /// The alternate flag, `#`, adds a `0o` in front of the output.\n ///\n-/// For more information on formatters, see [the module-level documentation][self].\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../../std/fmt/index.html\n ///\n /// # Examples\n ///\n@@ -726,7 +732,9 @@ pub trait Octal {\n ///\n /// The alternate flag, `#`, adds a `0b` in front of the output.\n ///\n-/// For more information on formatters, see [the module-level documentation][self].\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../../std/fmt/index.html\n ///\n /// # Examples\n ///\n@@ -782,7 +790,9 @@ pub trait Binary {\n ///\n /// The alternate flag, `#`, adds a `0x` in front of the output.\n ///\n-/// For more information on formatters, see [the module-level documentation][self].\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../../std/fmt/index.html\n ///\n /// # Examples\n ///\n@@ -835,7 +845,9 @@ pub trait LowerHex {\n ///\n /// The alternate flag, `#`, adds a `0x` in front of the output.\n ///\n-/// For more information on formatters, see [the module-level documentation][self].\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../../std/fmt/index.html\n ///\n /// # Examples\n ///\n@@ -883,7 +895,9 @@ pub trait UpperHex {\n /// The `Pointer` trait should format its output as a memory location. This is commonly presented\n /// as hexadecimal.\n ///\n-/// For more information on formatters, see [the module-level documentation][self].\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../../std/fmt/index.html\n ///\n /// # Examples\n ///\n@@ -932,7 +946,9 @@ pub trait Pointer {\n ///\n /// The `LowerExp` trait should format its output in scientific notation with a lower-case `e`.\n ///\n-/// For more information on formatters, see [the module-level documentation][self].\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../../std/fmt/index.html\n ///\n /// # Examples\n ///\n@@ -981,7 +997,9 @@ pub trait LowerExp {\n ///\n /// The `UpperExp` trait should format its output in scientific notation with an upper-case `E`.\n ///\n-/// For more information on formatters, see [the module-level documentation][self].\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../../std/fmt/index.html\n ///\n /// # Examples\n ///\n@@ -1555,7 +1573,7 @@ impl<'a> Formatter<'a> {\n     ///     }\n     /// }\n     ///\n-    /// // We set alignment to the left with \">\".\n+    /// // We set alignment to the right with \">\".\n     /// assert_eq!(&format!(\"{:G>3}\", Foo), \"GGG\");\n     /// assert_eq!(&format!(\"{:t>6}\", Foo), \"tttttt\");\n     /// ```"}, {"sha": "1d01e9b5fb7dc9533cf8eefbdf7699538ee84e09", "filename": "library/core/src/iter/adapters/intersperse.rs", "status": "modified", "additions": 133, "deletions": 21, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fintersperse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fintersperse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fintersperse.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -1,6 +1,9 @@\n use super::Peekable;\n \n /// An iterator adapter that places a separator between all elements.\n+///\n+/// This `struct` is created by [`Iterator::intersperse`]. See its documentation\n+/// for more information.\n #[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n #[derive(Debug, Clone)]\n pub struct Intersperse<I: Iterator>\n@@ -40,37 +43,146 @@ where\n         }\n     }\n \n-    fn fold<B, F>(mut self, init: B, mut f: F) -> B\n+    fn fold<B, F>(self, init: B, f: F) -> B\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> B,\n     {\n-        let mut accum = init;\n+        let separator = self.separator;\n+        intersperse_fold(self.iter, init, f, move || separator.clone(), self.needs_sep)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        intersperse_size_hint(&self.iter, self.needs_sep)\n+    }\n+}\n+\n+/// An iterator adapter that places a separator between all elements.\n+///\n+/// This `struct` is created by [`Iterator::intersperse_with`]. See its\n+/// documentation for more information.\n+#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+pub struct IntersperseWith<I, G>\n+where\n+    I: Iterator,\n+{\n+    separator: G,\n+    iter: Peekable<I>,\n+    needs_sep: bool,\n+}\n+\n+#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+impl<I, G> crate::fmt::Debug for IntersperseWith<I, G>\n+where\n+    I: Iterator + crate::fmt::Debug,\n+    I::Item: crate::fmt::Debug,\n+    G: crate::fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {\n+        f.debug_struct(\"IntersperseWith\")\n+            .field(\"separator\", &self.separator)\n+            .field(\"iter\", &self.iter)\n+            .field(\"needs_sep\", &self.needs_sep)\n+            .finish()\n+    }\n+}\n \n-        // Use `peek()` first to avoid calling `next()` on an empty iterator.\n-        if !self.needs_sep || self.iter.peek().is_some() {\n-            if let Some(x) = self.iter.next() {\n-                accum = f(accum, x);\n-            }\n+#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+impl<I, G> crate::clone::Clone for IntersperseWith<I, G>\n+where\n+    I: Iterator + crate::clone::Clone,\n+    I::Item: crate::clone::Clone,\n+    G: Clone,\n+{\n+    fn clone(&self) -> Self {\n+        IntersperseWith {\n+            separator: self.separator.clone(),\n+            iter: self.iter.clone(),\n+            needs_sep: self.needs_sep.clone(),\n         }\n+    }\n+}\n \n-        let element = &self.separator;\n+impl<I, G> IntersperseWith<I, G>\n+where\n+    I: Iterator,\n+    G: FnMut() -> I::Item,\n+{\n+    pub(in crate::iter) fn new(iter: I, separator: G) -> Self {\n+        Self { iter: iter.peekable(), separator, needs_sep: false }\n+    }\n+}\n \n-        self.iter.fold(accum, |mut accum, x| {\n-            accum = f(accum, element.clone());\n-            accum = f(accum, x);\n-            accum\n-        })\n+#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+impl<I, G> Iterator for IntersperseWith<I, G>\n+where\n+    I: Iterator,\n+    G: FnMut() -> I::Item,\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.needs_sep && self.iter.peek().is_some() {\n+            self.needs_sep = false;\n+            Some((self.separator)())\n+        } else {\n+            self.needs_sep = true;\n+            self.iter.next()\n+        }\n+    }\n+\n+    fn fold<B, F>(self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        intersperse_fold(self.iter, init, f, self.separator, self.needs_sep)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (lo, hi) = self.iter.size_hint();\n-        let next_is_elem = !self.needs_sep;\n-        let lo = lo.saturating_sub(next_is_elem as usize).saturating_add(lo);\n-        let hi = match hi {\n-            Some(hi) => hi.saturating_sub(next_is_elem as usize).checked_add(hi),\n-            None => None,\n-        };\n-        (lo, hi)\n+        intersperse_size_hint(&self.iter, self.needs_sep)\n     }\n }\n+\n+fn intersperse_size_hint<I>(iter: &I, needs_sep: bool) -> (usize, Option<usize>)\n+where\n+    I: Iterator,\n+{\n+    let (lo, hi) = iter.size_hint();\n+    let next_is_elem = !needs_sep;\n+    let lo = lo.saturating_sub(next_is_elem as usize).saturating_add(lo);\n+    let hi = match hi {\n+        Some(hi) => hi.saturating_sub(next_is_elem as usize).checked_add(hi),\n+        None => None,\n+    };\n+    (lo, hi)\n+}\n+\n+fn intersperse_fold<I, B, F, G>(\n+    mut iter: Peekable<I>,\n+    init: B,\n+    mut f: F,\n+    mut separator: G,\n+    needs_sep: bool,\n+) -> B\n+where\n+    I: Iterator,\n+    F: FnMut(B, I::Item) -> B,\n+    G: FnMut() -> I::Item,\n+{\n+    let mut accum = init;\n+\n+    // Use `peek()` first to avoid calling `next()` on an empty iterator.\n+    if !needs_sep || iter.peek().is_some() {\n+        if let Some(x) = iter.next() {\n+            accum = f(accum, x);\n+        }\n+    }\n+\n+    iter.fold(accum, |mut accum, x| {\n+        accum = f(accum, separator());\n+        accum = f(accum, x);\n+        accum\n+    })\n+}"}, {"sha": "41a7b13232adf465dce0c20ce6d416ba2f92de46", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -43,7 +43,7 @@ pub use self::flatten::Flatten;\n pub use self::copied::Copied;\n \n #[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n-pub use self::intersperse::Intersperse;\n+pub use self::intersperse::{Intersperse, IntersperseWith};\n \n #[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n pub use self::map_while::MapWhile;"}, {"sha": "c57ba2bf626452b80fe3e23b30e67ad5cc61500c", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -395,8 +395,6 @@ pub use self::adapters::Cloned;\n pub use self::adapters::Copied;\n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n pub use self::adapters::Flatten;\n-#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n-pub use self::adapters::Intersperse;\n #[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n pub use self::adapters::MapWhile;\n #[unstable(feature = \"inplace_iteration\", issue = \"none\")]\n@@ -410,6 +408,8 @@ pub use self::adapters::{\n     Chain, Cycle, Enumerate, Filter, FilterMap, FlatMap, Fuse, Inspect, Map, Peekable, Rev, Scan,\n     Skip, SkipWhile, Take, TakeWhile, Zip,\n };\n+#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+pub use self::adapters::{Intersperse, IntersperseWith};\n \n pub(crate) use self::adapters::process_results;\n "}, {"sha": "83d339d8f40a5664d97a93bca4ff222cfc871985", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -8,7 +8,7 @@ use crate::ops::{Add, ControlFlow, Try};\n use super::super::TrustedRandomAccess;\n use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n use super::super::{FlatMap, Flatten};\n-use super::super::{FromIterator, Intersperse, Product, Sum, Zip};\n+use super::super::{FromIterator, Intersperse, IntersperseWith, Product, Sum, Zip};\n use super::super::{\n     Inspect, Map, MapWhile, Peekable, Rev, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile,\n };\n@@ -571,16 +571,22 @@ pub trait Iterator {\n \n     /// Places a copy of `separator` between all elements.\n     ///\n+    /// In case the separator does not implement [`Clone`] or needs to be\n+    /// computed every time, use [`intersperse_with`].\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n     /// ```\n     /// #![feature(iter_intersperse)]\n     ///\n-    /// let hello = [\"Hello\", \"World\"].iter().copied().intersperse(\" \").collect::<String>();\n-    /// assert_eq!(hello, \"Hello World\");\n+    /// let hello = [\"Hello\", \"World\", \"!\"].iter().copied().intersperse(\" \").collect::<String>();\n+    /// assert_eq!(hello, \"Hello World !\");\n     /// ```\n+    ///\n+    /// [`Clone`]: crate::clone::Clone\n+    /// [`intersperse_with`]: Iterator::intersperse_with\n     #[inline]\n     #[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n     fn intersperse(self, separator: Self::Item) -> Intersperse<Self>\n@@ -591,6 +597,33 @@ pub trait Iterator {\n         Intersperse::new(self, separator)\n     }\n \n+    /// Places an element generated by `separator` between all elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_intersperse)]\n+    ///\n+    /// let src = [\"Hello\", \"to\", \"all\", \"people\", \"!!\"].iter().copied();\n+    ///\n+    /// let mut happy_emojis = [\" \u2764\ufe0f \", \" \ud83d\ude00 \"].iter().copied();\n+    /// let separator = || happy_emojis.next().unwrap_or(\" \ud83e\udd80 \");\n+    ///\n+    /// let result = src.intersperse_with(separator).collect::<String>();\n+    /// assert_eq!(result, \"Hello \u2764\ufe0f to \ud83d\ude00 all \ud83e\udd80 people \ud83e\udd80 !!\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+    fn intersperse_with<G>(self, separator: G) -> IntersperseWith<Self, G>\n+    where\n+        Self: Sized,\n+        G: FnMut() -> Self::Item,\n+    {\n+        IntersperseWith::new(self, separator)\n+    }\n+\n     /// Takes a closure and creates an iterator which calls that closure on each\n     /// element.\n     ///"}, {"sha": "90964bae98c89236f8b16a862785b0735a7b208e", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -401,7 +401,7 @@ macro_rules! write {\n /// For more information, see [`write!`]. For information on the format string syntax, see\n /// [`std::fmt`].\n ///\n-/// [`std::fmt`]: crate::fmt\n+/// [`std::fmt`]: ../std/fmt/index.html\n ///\n /// # Examples\n ///\n@@ -730,7 +730,7 @@ pub(crate) mod builtin {\n     /// [`Display`]: crate::fmt::Display\n     /// [`Debug`]: crate::fmt::Debug\n     /// [`fmt::Arguments`]: crate::fmt::Arguments\n-    /// [`std::fmt`]: crate::fmt\n+    /// [`std::fmt`]: ../std/fmt/index.html\n     /// [`format!`]: ../std/macro.format.html\n     /// [`println!`]: ../std/macro.println.html\n     ///\n@@ -1194,7 +1194,7 @@ pub(crate) mod builtin {\n     /// be provided with or without arguments for formatting. See [`std::fmt`]\n     /// for syntax for this form.\n     ///\n-    /// [`std::fmt`]: crate::fmt\n+    /// [`std::fmt`]: ../std/fmt/index.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "0571dc74b9af90aaf78beac4fe6112448698c379", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -678,6 +678,29 @@ pub enum Bound<T> {\n     Unbounded,\n }\n \n+#[unstable(feature = \"bound_as_ref\", issue = \"80996\")]\n+impl<T> Bound<T> {\n+    /// Converts from `&Bound<T>` to `Bound<&T>`.\n+    #[inline]\n+    pub fn as_ref(&self) -> Bound<&T> {\n+        match *self {\n+            Included(ref x) => Included(x),\n+            Excluded(ref x) => Excluded(x),\n+            Unbounded => Unbounded,\n+        }\n+    }\n+\n+    /// Converts from `&mut Bound<T>` to `Bound<&T>`.\n+    #[inline]\n+    pub fn as_mut(&mut self) -> Bound<&mut T> {\n+        match *self {\n+            Included(ref mut x) => Included(x),\n+            Excluded(ref mut x) => Excluded(x),\n+            Unbounded => Unbounded,\n+        }\n+    }\n+}\n+\n impl<T: Clone> Bound<&T> {\n     /// Map a `Bound<&T>` to a `Bound<T>` by cloning the contents of the bound.\n     ///"}, {"sha": "6de27140594804f6ff9fbb84bfe0348ef7bf9906", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -1877,7 +1877,7 @@ impl<T> [T] {\n     ///            Some(b\"llo\".as_ref()));\n     /// ```\n     #[must_use = \"returns the subslice without modifying the original\"]\n-    #[stable(feature = \"slice_strip\", since = \"1.50.0\")]\n+    #[stable(feature = \"slice_strip\", since = \"1.51.0\")]\n     pub fn strip_prefix<P: SlicePattern<Item = T> + ?Sized>(&self, prefix: &P) -> Option<&[T]>\n     where\n         T: PartialEq,\n@@ -1911,7 +1911,7 @@ impl<T> [T] {\n     /// assert_eq!(v.strip_suffix(&[50, 30]), None);\n     /// ```\n     #[must_use = \"returns the subslice without modifying the original\"]\n-    #[stable(feature = \"slice_strip\", since = \"1.50.0\")]\n+    #[stable(feature = \"slice_strip\", since = \"1.51.0\")]\n     pub fn strip_suffix<P: SlicePattern<Item = T> + ?Sized>(&self, suffix: &P) -> Option<&[T]>\n     where\n         T: PartialEq,\n@@ -3323,7 +3323,7 @@ pub trait SlicePattern {\n     fn as_slice(&self) -> &[Self::Item];\n }\n \n-#[stable(feature = \"slice_strip\", since = \"1.50.0\")]\n+#[stable(feature = \"slice_strip\", since = \"1.51.0\")]\n impl<T> SlicePattern for [T] {\n     type Item = T;\n \n@@ -3333,7 +3333,7 @@ impl<T> SlicePattern for [T] {\n     }\n }\n \n-#[stable(feature = \"slice_strip\", since = \"1.50.0\")]\n+#[stable(feature = \"slice_strip\", since = \"1.51.0\")]\n impl<T, const N: usize> SlicePattern for [T; N] {\n     type Item = T;\n "}, {"sha": "81c9e1d1c10b2f1b129977372e324cd8f9ac39f5", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -120,21 +120,6 @@ use crate::intrinsics;\n \n use crate::hint::spin_loop;\n \n-/// Signals the processor that it is inside a busy-wait spin-loop (\"spin lock\").\n-///\n-/// This function is expected to be deprecated in favor of\n-/// [`hint::spin_loop`].\n-///\n-/// **Note**: On platforms that do not support receiving spin-loop hints this function does not\n-/// do anything at all.\n-///\n-/// [`hint::spin_loop`]: crate::hint::spin_loop\n-#[inline]\n-#[stable(feature = \"spin_loop_hint\", since = \"1.24.0\")]\n-pub fn spin_loop_hint() {\n-    spin_loop()\n-}\n-\n /// A boolean type which can be safely shared between threads.\n ///\n /// This type has the same in-memory representation as a [`bool`].\n@@ -2791,3 +2776,15 @@ impl<T> fmt::Pointer for AtomicPtr<T> {\n         fmt::Pointer::fmt(&self.load(Ordering::SeqCst), f)\n     }\n }\n+\n+/// Signals the processor that it is inside a busy-wait spin-loop (\"spin lock\").\n+///\n+/// This function is deprecated in favor of [`hint::spin_loop`].\n+///\n+/// [`hint::spin_loop`]: crate::hint::spin_loop\n+#[inline]\n+#[stable(feature = \"spin_loop_hint\", since = \"1.24.0\")]\n+#[rustc_deprecated(since = \"1.51.0\", reason = \"use hint::spin_loop instead\")]\n+pub fn spin_loop_hint() {\n+    spin_loop()\n+}"}, {"sha": "691767edea6d9659527696e870a23409a86cbb50", "filename": "library/core/tests/iter.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -3508,6 +3508,12 @@ pub fn extend_for_unit() {\n \n #[test]\n fn test_intersperse() {\n+    let v = std::iter::empty().intersperse(0u32).collect::<Vec<_>>();\n+    assert_eq!(v, vec![]);\n+\n+    let v = std::iter::once(1).intersperse(0).collect::<Vec<_>>();\n+    assert_eq!(v, vec![1]);\n+\n     let xs = [\"a\", \"\", \"b\", \"c\"];\n     let v: Vec<&str> = xs.iter().map(|x| x.clone()).intersperse(\", \").collect();\n     let text: String = v.concat();\n@@ -3520,6 +3526,9 @@ fn test_intersperse() {\n \n #[test]\n fn test_intersperse_size_hint() {\n+    let iter = std::iter::empty::<i32>().intersperse(0);\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+\n     let xs = [\"a\", \"\", \"b\", \"c\"];\n     let mut iter = xs.iter().map(|x| x.clone()).intersperse(\", \");\n     assert_eq!(iter.size_hint(), (7, Some(7)));\n@@ -3587,3 +3596,24 @@ fn test_try_fold_specialization_intersperse_err() {\n     iter.try_for_each(|item| if item == \"b\" { None } else { Some(()) });\n     assert_eq!(iter.next(), None);\n }\n+\n+#[test]\n+fn test_intersperse_with() {\n+    #[derive(PartialEq, Debug)]\n+    struct NotClone {\n+        u: u32,\n+    }\n+    let r = vec![NotClone { u: 0 }, NotClone { u: 1 }]\n+        .into_iter()\n+        .intersperse_with(|| NotClone { u: 2 })\n+        .collect::<Vec<_>>();\n+    assert_eq!(r, vec![NotClone { u: 0 }, NotClone { u: 2 }, NotClone { u: 1 }]);\n+\n+    let mut ctr = 100;\n+    let separator = || {\n+        ctr *= 2;\n+        ctr\n+    };\n+    let r = (0..3).intersperse_with(separator).collect::<Vec<_>>();\n+    assert_eq!(r, vec![0, 200, 1, 400, 2]);\n+}"}, {"sha": "3f5b7c0b29be692a611f7c51d53a642247ef2a55", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 58, "deletions": 12, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -366,7 +366,6 @@ where\n {\n     let start_len = buf.len();\n     let mut g = Guard { len: buf.len(), buf };\n-    let ret;\n     loop {\n         if g.len == g.buf.len() {\n             unsafe {\n@@ -385,21 +384,20 @@ where\n             }\n         }\n \n-        match r.read(&mut g.buf[g.len..]) {\n-            Ok(0) => {\n-                ret = Ok(g.len - start_len);\n-                break;\n+        let buf = &mut g.buf[g.len..];\n+        match r.read(buf) {\n+            Ok(0) => return Ok(g.len - start_len),\n+            Ok(n) => {\n+                // We can't allow bogus values from read. If it is too large, the returned vec could have its length\n+                // set past its capacity, or if it overflows the vec could be shortened which could create an invalid\n+                // string if this is called via read_to_string.\n+                assert!(n <= buf.len());\n+                g.len += n;\n             }\n-            Ok(n) => g.len += n,\n             Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n-            Err(e) => {\n-                ret = Err(e);\n-                break;\n-            }\n+            Err(e) => return Err(e),\n         }\n     }\n-\n-    ret\n }\n \n pub(crate) fn default_read_vectored<F>(read: F, bufs: &mut [IoSliceMut<'_>]) -> Result<usize>\n@@ -944,6 +942,54 @@ pub trait Read {\n     }\n }\n \n+/// Read all bytes from a [reader][Read] into a new [`String`].\n+///\n+/// This is a convenience function for [`Read::read_to_string`]. Using this\n+/// function avoids having to create a variable first and provides more type\n+/// safety since you can only get the buffer out if there were no errors. (If you\n+/// use [`Read::read_to_string`] you have to remember to check whether the read\n+/// succeeded because otherwise your buffer will be empty or only partially full.)\n+///\n+/// # Performance\n+///\n+/// The downside of this function's increased ease of use and type safety is\n+/// that it gives you less control over performance. For example, you can't\n+/// pre-allocate memory like you can using [`String::with_capacity`] and\n+/// [`Read::read_to_string`]. Also, you can't re-use the buffer if an error\n+/// occurs while reading.\n+///\n+/// In many cases, this function's performance will be adequate and the ease of use\n+/// and type safety tradeoffs will be worth it. However, there are cases where you\n+/// need more control over performance, and in those cases you should definitely use\n+/// [`Read::read_to_string`] directly.\n+///\n+/// # Errors\n+///\n+/// This function forces you to handle errors because the output (the `String`)\n+/// is wrapped in a [`Result`]. See [`Read::read_to_string`] for the errors\n+/// that can occur. If any error occurs, you will get an [`Err`], so you\n+/// don't have to worry about your buffer being empty or partially full.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// #![feature(io_read_to_string)]\n+///\n+/// # use std::io;\n+/// fn main() -> io::Result<()> {\n+///     let stdin = io::read_to_string(&mut io::stdin())?;\n+///     println!(\"Stdin was:\");\n+///     println!(\"{}\", stdin);\n+///     Ok(())\n+/// }\n+/// ```\n+#[unstable(feature = \"io_read_to_string\", issue = \"80218\")]\n+pub fn read_to_string<R: Read>(reader: &mut R) -> Result<String> {\n+    let mut buf = String::new();\n+    reader.read_to_string(&mut buf)?;\n+    Ok(buf)\n+}\n+\n /// A buffer type used with `Read::read_vectored`.\n ///\n /// It is semantically a wrapper around an `&mut [u8]`, but is guaranteed to be"}, {"sha": "885389ca54cd42c1df5390f7b27a8baf02ae6d28", "filename": "library/std/src/sys/hermit/mutex.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -1,9 +1,10 @@\n use crate::cell::UnsafeCell;\n use crate::collections::VecDeque;\n use crate::ffi::c_void;\n+use crate::hint;\n use crate::ops::{Deref, DerefMut, Drop};\n use crate::ptr;\n-use crate::sync::atomic::{spin_loop_hint, AtomicUsize, Ordering};\n+use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys::hermit::abi;\n \n /// This type provides a lock based on busy waiting to realize mutual exclusion\n@@ -46,7 +47,7 @@ impl<T> Spinlock<T> {\n     fn obtain_lock(&self) {\n         let ticket = self.queue.fetch_add(1, Ordering::SeqCst) + 1;\n         while self.dequeue.load(Ordering::SeqCst) != ticket {\n-            spin_loop_hint();\n+            hint::spin_loop();\n         }\n     }\n "}, {"sha": "7f1a671bab4eb73bccb31da09d1f3e4558c94ea8", "filename": "library/std/src/sys/sgx/waitqueue/spin_mutex.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fspin_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fspin_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fspin_mutex.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -2,8 +2,9 @@\n mod tests;\n \n use crate::cell::UnsafeCell;\n+use crate::hint;\n use crate::ops::{Deref, DerefMut};\n-use crate::sync::atomic::{spin_loop_hint, AtomicBool, Ordering};\n+use crate::sync::atomic::{AtomicBool, Ordering};\n \n #[derive(Default)]\n pub struct SpinMutex<T> {\n@@ -32,7 +33,7 @@ impl<T> SpinMutex<T> {\n             match self.try_lock() {\n                 None => {\n                     while self.lock.load(Ordering::Relaxed) {\n-                        spin_loop_hint()\n+                        hint::spin_loop()\n                     }\n                 }\n                 Some(guard) => return guard,"}, {"sha": "f4c67b225e6e19623e2e85f8f5e6497f931d283c", "filename": "library/std/src/sys/unix/ext/process.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -9,6 +9,14 @@ use crate::process;\n use crate::sys;\n use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n \n+mod private {\n+    /// This trait being unreachable from outside the crate\n+    /// prevents other implementations of the `ExitStatusExt` trait,\n+    /// which allows potentially adding more trait methods in the future.\n+    #[stable(feature = \"none\", since = \"1.51.0\")]\n+    pub trait Sealed {}\n+}\n+\n /// Unix-specific extensions to the [`process::Command`] builder.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait CommandExt {\n@@ -163,18 +171,48 @@ impl CommandExt for process::Command {\n }\n \n /// Unix-specific extensions to [`process::ExitStatus`].\n+///\n+/// This trait is sealed: it cannot be implemented outside the standard library.\n+/// This is so that future additional methods are not breaking changes.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait ExitStatusExt {\n+pub trait ExitStatusExt: private::Sealed {\n     /// Creates a new `ExitStatus` from the raw underlying `i32` return value of\n     /// a process.\n     #[stable(feature = \"exit_status_from\", since = \"1.12.0\")]\n     fn from_raw(raw: i32) -> Self;\n \n     /// If the process was terminated by a signal, returns that signal.\n+    ///\n+    /// In other words, if `WIFSIGNALED`, this returns `WTERMSIG`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn signal(&self) -> Option<i32>;\n+\n+    /// If the process was terminated by a signal, says whether it dumped core.\n+    #[unstable(feature = \"unix_process_wait_more\", issue = \"80695\")]\n+    fn core_dumped(&self) -> bool;\n+\n+    /// If the process was stopped by a signal, returns that signal.\n+    ///\n+    /// In other words, if `WIFSTOPPED`, this returns `WSTOPSIG`.  This is only possible if the status came from\n+    /// a `wait` system call which was passed `WUNTRACED`, was then converted into an `ExitStatus`.\n+    #[unstable(feature = \"unix_process_wait_more\", issue = \"80695\")]\n+    fn stopped_signal(&self) -> Option<i32>;\n+\n+    /// Whether the process was continued from a stopped status.\n+    ///\n+    /// Ie, `WIFCONTINUED`.  This is only possible if the status came from a `wait` system call\n+    /// which was passed `WCONTINUED`, was then converted into an `ExitStatus`.\n+    #[unstable(feature = \"unix_process_wait_more\", issue = \"80695\")]\n+    fn continued(&self) -> bool;\n+\n+    /// Returns the underlying raw `wait` status.\n+    #[unstable(feature = \"unix_process_wait_more\", issue = \"80695\")]\n+    fn into_raw(self) -> i32;\n }\n \n+#[stable(feature = \"none\", since = \"1.51.0\")]\n+impl private::Sealed for process::ExitStatus {}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ExitStatusExt for process::ExitStatus {\n     fn from_raw(raw: i32) -> Self {\n@@ -184,6 +222,22 @@ impl ExitStatusExt for process::ExitStatus {\n     fn signal(&self) -> Option<i32> {\n         self.as_inner().signal()\n     }\n+\n+    fn core_dumped(&self) -> bool {\n+        self.as_inner().core_dumped()\n+    }\n+\n+    fn stopped_signal(&self) -> Option<i32> {\n+        self.as_inner().stopped_signal()\n+    }\n+\n+    fn continued(&self) -> bool {\n+        self.as_inner().continued()\n+    }\n+\n+    fn into_raw(self) -> i32 {\n+        self.as_inner().into_raw().into()\n+    }\n }\n \n #[stable(feature = \"process_extensions\", since = \"1.2.0\")]"}, {"sha": "0d4703d7f503abe5c2c6c70705196c66d7390bea", "filename": "library/std/src/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -245,6 +245,50 @@ impl ExitStatus {\n     pub fn signal(&self) -> Option<i32> {\n         None\n     }\n+\n+    // FIXME: The actually-Unix implementation in process_unix.rs uses WSTOPSIG, WCOREDUMP et al.\n+    // I infer from the implementation of `success`, `code` and `signal` above that these are not\n+    // available on Fuchsia.\n+    //\n+    // It does not appear that Fuchsia is Unix-like enough to implement ExitStatus (or indeed many\n+    // other things from std::os::unix) properly.  This veneer is always going to be a bodge.  So\n+    // while I don't know if these implementations are actually correct, I think they will do for\n+    // now at least.\n+    pub fn core_dumped(&self) -> bool {\n+        false\n+    }\n+    pub fn stopped_signal(&self) -> Option<i32> {\n+        None\n+    }\n+    pub fn continued(&self) -> bool {\n+        false\n+    }\n+\n+    pub fn into_raw(&self) -> c_int {\n+        // We don't know what someone who calls into_raw() will do with this value, but it should\n+        // have the conventional Unix representation.  Despite the fact that this is not\n+        // standardised in SuS or POSIX, all Unix systems encode the signal and exit status the\n+        // same way.  (Ie the WIFEXITED, WEXITSTATUS etc. macros have identical behaviour on every\n+        // Unix.)\n+        //\n+        // The caller of `std::os::unix::into_raw` is probably wanting a Unix exit status, and may\n+        // do their own shifting and masking, or even pass the status to another computer running a\n+        // different Unix variant.\n+        //\n+        // The other view would be to say that the caller on Fuchsia ought to know that `into_raw`\n+        // will give a raw Fuchsia status (whatever that is - I don't know, personally).  That is\n+        // not possible here becaause we must return a c_int because that's what Unix (including\n+        // SuS and POSIX) say a wait status is, but Fuchsia apparently uses a u64, so it won't\n+        // necessarily fit.\n+        //\n+        // It seems to me that that the right answer would be to provide std::os::fuchsia with its\n+        // own ExitStatusExt, rather that trying to provide a not very convincing imitation of\n+        // Unix.  Ie, std::os::unix::process:ExitStatusExt ought not to exist on Fuchsia.  But\n+        // fixing this up that is beyond the scope of my efforts now.\n+        let exit_status_as_if_unix: u8 = self.0.try_into().expect(\"Fuchsia process return code bigger than 8 bits, but std::os::unix::ExitStatusExt::into_raw() was called to try to convert the value into a traditional Unix-style wait status, which cannot represent values greater than 255.\");\n+        let wait_status_as_if_unix = (exit_status_as_if_unix as c_int) << 8;\n+        wait_status_as_if_unix\n+    }\n }\n \n /// Converts a raw `c_int` to a type-safe `ExitStatus` by wrapping it without copying."}, {"sha": "945b43678a9192368c70eeefd49117583d6b4480", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -479,7 +479,23 @@ impl ExitStatus {\n     }\n \n     pub fn signal(&self) -> Option<i32> {\n-        if !self.exited() { Some(libc::WTERMSIG(self.0)) } else { None }\n+        if libc::WIFSIGNALED(self.0) { Some(libc::WTERMSIG(self.0)) } else { None }\n+    }\n+\n+    pub fn core_dumped(&self) -> bool {\n+        libc::WIFSIGNALED(self.0) && libc::WCOREDUMP(self.0)\n+    }\n+\n+    pub fn stopped_signal(&self) -> Option<i32> {\n+        if libc::WIFSTOPPED(self.0) { Some(libc::WSTOPSIG(self.0)) } else { None }\n+    }\n+\n+    pub fn continued(&self) -> bool {\n+        libc::WIFCONTINUED(self.0)\n+    }\n+\n+    pub fn into_raw(&self) -> c_int {\n+        self.0\n     }\n }\n "}, {"sha": "7a92381d6609b56d5a1042d350daff13711bb792", "filename": "library/std/src/sys/windows/ext/process.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fprocess.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -7,6 +7,14 @@ use crate::process;\n use crate::sys;\n use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n \n+mod private {\n+    /// This trait being unreachable from outside the crate\n+    /// prevents other implementations of the `ExitStatusExt` trait,\n+    /// which allows potentially adding more trait methods in the future.\n+    #[stable(feature = \"none\", since = \"1.51.0\")]\n+    pub trait Sealed {}\n+}\n+\n #[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n impl FromRawHandle for process::Stdio {\n     unsafe fn from_raw_handle(handle: RawHandle) -> process::Stdio {\n@@ -73,8 +81,11 @@ impl IntoRawHandle for process::ChildStderr {\n }\n \n /// Windows-specific extensions to [`process::ExitStatus`].\n+///\n+/// This trait is sealed: it cannot be implemented outside the standard library.\n+/// This is so that future additional methods are not breaking changes.\n #[stable(feature = \"exit_status_from\", since = \"1.12.0\")]\n-pub trait ExitStatusExt {\n+pub trait ExitStatusExt: private::Sealed {\n     /// Creates a new `ExitStatus` from the raw underlying `u32` return value of\n     /// a process.\n     #[stable(feature = \"exit_status_from\", since = \"1.12.0\")]\n@@ -88,6 +99,9 @@ impl ExitStatusExt for process::ExitStatus {\n     }\n }\n \n+#[stable(feature = \"none\", since = \"1.51.0\")]\n+impl private::Sealed for process::ExitStatus {}\n+\n /// Windows-specific extensions to the [`process::Command`] builder.\n #[stable(feature = \"windows_process_extensions\", since = \"1.16.0\")]\n pub trait CommandExt {"}, {"sha": "0d004a516f5944207bf7f38aaee9681ca0c3e929", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -1186,32 +1186,37 @@ impl fmt::Debug for Thread {\n /// the [`Error`](crate::error::Error) trait.\n ///\n /// Thus, a sensible way to handle a thread panic is to either:\n-/// 1. `unwrap` the `Result<T>`, propagating the panic\n+///\n+/// 1. propagate the panic with [`std::panic::resume_unwind`]\n /// 2. or in case the thread is intended to be a subsystem boundary\n /// that is supposed to isolate system-level failures,\n-/// match on the `Err` variant and handle the panic in an appropriate way.\n+/// match on the `Err` variant and handle the panic in an appropriate way\n ///\n /// A thread that completes without panicking is considered to exit successfully.\n ///\n /// # Examples\n ///\n+/// Matching on the result of a joined thread:\n+///\n /// ```no_run\n-/// use std::thread;\n-/// use std::fs;\n+/// use std::{fs, thread, panic};\n ///\n /// fn copy_in_thread() -> thread::Result<()> {\n-///     thread::spawn(move || { fs::copy(\"foo.txt\", \"bar.txt\").unwrap(); }).join()\n+///     thread::spawn(|| {\n+///         fs::copy(\"foo.txt\", \"bar.txt\").unwrap();\n+///     }).join()\n /// }\n ///\n /// fn main() {\n ///     match copy_in_thread() {\n-///         Ok(_) => println!(\"this is fine\"),\n-///         Err(_) => println!(\"thread panicked\"),\n+///         Ok(_) => println!(\"copy succeeded\"),\n+///         Err(e) => panic::resume_unwind(e),\n ///     }\n /// }\n /// ```\n ///\n /// [`Result`]: crate::result::Result\n+/// [`std::panic::resume_unwind`]: crate::panic::resume_unwind\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type Result<T> = crate::result::Result<T, Box<dyn Any + Send + 'static>>;\n "}, {"sha": "ac57a0ddd23d173b26731ccf939f3ba729753275", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -1 +1 @@\n-Subproject commit 5bb44f8b5b0aa105c8b22602e9b18800484afa21\n+Subproject commit ac57a0ddd23d173b26731ccf939f3ba729753275"}, {"sha": "ceec19e873be87c6ee5666b030c6bb612f889a96", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -1 +1 @@\n-Subproject commit ba34b8a968f9531d38c4dc4411d5568b7c076bfe\n+Subproject commit ceec19e873be87c6ee5666b030c6bb612f889a96"}, {"sha": "a8584998eacdea7106a1dfafcbf6c1c06fcdf925", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -1 +1 @@\n-Subproject commit a5a48441d411f61556b57d762b03d6874afe575d\n+Subproject commit a8584998eacdea7106a1dfafcbf6c1c06fcdf925"}, {"sha": "50af691f838937c300b47812d0507c6d88c14f97", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -1 +1 @@\n-Subproject commit b278478b766178491a8b6f67afa4bcd6b64d977a\n+Subproject commit 50af691f838937c300b47812d0507c6d88c14f97"}, {"sha": "03e23af01f0b4f83a3a513da280e1ca92587f2ec", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -1 +1 @@\n-Subproject commit 1cce0737d6a7d3ceafb139b4a206861fb1dcb2ab\n+Subproject commit 03e23af01f0b4f83a3a513da280e1ca92587f2ec"}, {"sha": "c270593cac741883fcc242d2961983adb4849b88", "filename": "src/test/ui/destructuring-assignment/tuple_struct_destructure_fail.stderr", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.stderr?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -31,6 +31,15 @@ LL | struct TupleStruct<S, T>(S, T);\n ...\n LL |     TupleStruct(_) = TupleStruct(1, 2);\n    |     ^^^^^^^^^^^^^^ expected 2 fields, found 1\n+   |\n+help: use `_` to explicitly ignore each field\n+   |\n+LL |     TupleStruct(_, _) = TupleStruct(1, 2);\n+   |                  ^^^\n+help: use `..` to ignore all fields\n+   |\n+LL |     TupleStruct(..) = TupleStruct(1, 2);\n+   |                 ^^\n \n error[E0023]: this pattern has 3 fields, but the corresponding tuple variant has 2 fields\n   --> $DIR/tuple_struct_destructure_fail.rs:34:5\n@@ -49,6 +58,15 @@ LL |     SingleVariant(S, T)\n ...\n LL |     Enum::SingleVariant(_) = Enum::SingleVariant(1, 2);\n    |     ^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n+   |\n+help: use `_` to explicitly ignore each field\n+   |\n+LL |     Enum::SingleVariant(_, _) = Enum::SingleVariant(1, 2);\n+   |                          ^^^\n+help: use `..` to ignore all fields\n+   |\n+LL |     Enum::SingleVariant(..) = Enum::SingleVariant(1, 2);\n+   |                         ^^\n \n error[E0070]: invalid left-hand side of assignment\n   --> $DIR/tuple_struct_destructure_fail.rs:40:12"}, {"sha": "832eba69722134f762552a8ab1073de8660d9a29", "filename": "src/test/ui/error-codes/E0023.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Ferror-codes%2FE0023.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Ferror-codes%2FE0023.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0023.stderr?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -6,6 +6,11 @@ LL |     Apple(String, String),\n ...\n LL |         Fruit::Apple(a) => {},\n    |         ^^^^^^^^^^^^^^^ expected 2 fields, found 1\n+   |\n+help: use `_` to explicitly ignore each field\n+   |\n+LL |         Fruit::Apple(a, _) => {},\n+   |                       ^^^\n \n error[E0023]: this pattern has 3 fields, but the corresponding tuple variant has 2 fields\n   --> $DIR/E0023.rs:12:9\n@@ -34,7 +39,7 @@ LL |     Orange((String, String)),\n LL |         Fruit::Orange(a, b) => {},\n    |         ^^^^^^^^^^^^^^^^^^^ expected 1 field, found 2\n    |\n-help: missing parenthesis\n+help: missing parentheses\n    |\n LL |         Fruit::Orange((a, b)) => {},\n    |                       ^    ^\n@@ -48,7 +53,7 @@ LL |     Banana(()),\n LL |         Fruit::Banana() => {},\n    |         ^^^^^^^^^^^^^^^ expected 1 field, found 0\n    |\n-help: missing parenthesis\n+help: missing parentheses\n    |\n LL |         Fruit::Banana(()) => {},\n    |                      ^  ^"}, {"sha": "9bdbf0bf9f40dfced6ed3e35aea1a6591fb913c0", "filename": "src/test/ui/issues/issue-67037-pat-tup-scrut-ty-diff-less-fields.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Fissues%2Fissue-67037-pat-tup-scrut-ty-diff-less-fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Fissues%2Fissue-67037-pat-tup-scrut-ty-diff-less-fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-67037-pat-tup-scrut-ty-diff-less-fields.stderr?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -17,6 +17,15 @@ LL | struct P<T>(T); // 1 type parameter wanted\n ...\n LL |     let P() = U {};\n    |         ^^^ expected 1 field, found 0\n+   |\n+help: use `_` to explicitly ignore each field\n+   |\n+LL |     let P(_) = U {};\n+   |           ^\n+help: use `..` to ignore all fields\n+   |\n+LL |     let P(..) = U {};\n+   |           ^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "a1e8ec1677db5feac9cc831ef18a2bf3809030af", "filename": "src/test/ui/issues/issue-72574-2.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Fissues%2Fissue-72574-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Fissues%2Fissue-72574-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72574-2.stderr?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -26,6 +26,11 @@ LL | struct Binder(i32, i32, i32);\n ...\n LL |         Binder(_a, _x @ ..) => {}\n    |         ^^^^^^^^^^^^^^^^^^^ expected 3 fields, found 2\n+   |\n+help: use `_` to explicitly ignore each field\n+   |\n+LL |         Binder(_a, _x @ .., _) => {}\n+   |                           ^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "37839482b31a2ef3aabae9fb356661db531c0241", "filename": "src/test/ui/match/match-pattern-field-mismatch.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Fmatch%2Fmatch-pattern-field-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Fmatch%2Fmatch-pattern-field-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-pattern-field-mismatch.stderr?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -6,6 +6,15 @@ LL |         Rgb(usize, usize, usize),\n ...\n LL |           Color::Rgb(_, _) => { }\n    |           ^^^^^^^^^^^^^^^^ expected 3 fields, found 2\n+   |\n+help: use `_` to explicitly ignore each field\n+   |\n+LL |           Color::Rgb(_, _, _) => { }\n+   |                          ^^^\n+help: use `..` to ignore all fields\n+   |\n+LL |           Color::Rgb(..) => { }\n+   |                      ^^\n \n error: aborting due to previous error\n "}, {"sha": "f7644c19ea0d9cbc3435ef5a65f2beccb0bb2038", "filename": "src/test/ui/pattern/issue-74539.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Fpattern%2Fissue-74539.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Fpattern%2Fissue-74539.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-74539.stderr?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -26,6 +26,11 @@ LL |     A(u8, u8),\n ...\n LL |         E::A(x @ ..) => {\n    |         ^^^^^^^^^^^^ expected 2 fields, found 1\n+   |\n+help: use `_` to explicitly ignore each field\n+   |\n+LL |         E::A(x @ .., _) => {\n+   |                    ^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "ed852a47bb4ee1752ea520fe2c24be41c796b7a8", "filename": "src/test/ui/pattern/pat-tuple-underfield.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-underfield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-underfield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-underfield.rs?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -0,0 +1,55 @@\n+struct S(i32, f32);\n+enum E {\n+    S(i32, f32),\n+}\n+struct Point4(i32, i32, i32, i32);\n+\n+fn main() {\n+    match S(0, 1.0) {\n+        S(x) => {}\n+        //~^ ERROR this pattern has 1 field, but the corresponding tuple struct has 2 fields\n+        //~| HELP use `_` to explicitly ignore each field\n+    }\n+    match S(0, 1.0) {\n+        S(_) => {}\n+        //~^ ERROR this pattern has 1 field, but the corresponding tuple struct has 2 fields\n+        //~| HELP use `_` to explicitly ignore each field\n+        //~| HELP use `..` to ignore all fields\n+    }\n+    match S(0, 1.0) {\n+        S() => {}\n+        //~^ ERROR this pattern has 0 fields, but the corresponding tuple struct has 2 fields\n+        //~| HELP use `_` to explicitly ignore each field\n+        //~| HELP use `..` to ignore all fields\n+    }\n+\n+    match E::S(0, 1.0) {\n+        E::S(x) => {}\n+        //~^ ERROR this pattern has 1 field, but the corresponding tuple variant has 2 fields\n+        //~| HELP use `_` to explicitly ignore each field\n+    }\n+    match E::S(0, 1.0) {\n+        E::S(_) => {}\n+        //~^ ERROR this pattern has 1 field, but the corresponding tuple variant has 2 fields\n+        //~| HELP use `_` to explicitly ignore each field\n+        //~| HELP use `..` to ignore all fields\n+    }\n+    match E::S(0, 1.0) {\n+        E::S() => {}\n+        //~^ ERROR this pattern has 0 fields, but the corresponding tuple variant has 2 fields\n+        //~| HELP use `_` to explicitly ignore each field\n+        //~| HELP use `..` to ignore all fields\n+    }\n+    match E::S(0, 1.0) {\n+        E::S => {}\n+        //~^ ERROR expected unit struct, unit variant or constant, found tuple variant `E::S`\n+        //~| HELP use the tuple variant pattern syntax instead\n+    }\n+\n+    match Point4(0, 1, 2, 3) {\n+        Point4(   a   ,     _    ) => {}\n+        //~^ ERROR this pattern has 2 fields, but the corresponding tuple struct has 4 fields\n+        //~| HELP use `_` to explicitly ignore each field\n+        //~| HELP use `..` to ignore the rest of the fields\n+    }\n+}"}, {"sha": "76323d9a7bf56cba5ce792cbb2929dec11830858", "filename": "src/test/ui/pattern/pat-tuple-underfield.stderr", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-underfield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e38fb306b7f5e65cca34df2dab1f0db15e1defb4/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-underfield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-underfield.stderr?ref=e38fb306b7f5e65cca34df2dab1f0db15e1defb4", "patch": "@@ -0,0 +1,131 @@\n+error[E0532]: expected unit struct, unit variant or constant, found tuple variant `E::S`\n+  --> $DIR/pat-tuple-underfield.rs:44:9\n+   |\n+LL |     S(i32, f32),\n+   |     ----------- `E::S` defined here\n+...\n+LL |         E::S => {}\n+   |         ^^^^ help: use the tuple variant pattern syntax instead: `E::S(_, _)`\n+\n+error[E0023]: this pattern has 1 field, but the corresponding tuple struct has 2 fields\n+  --> $DIR/pat-tuple-underfield.rs:9:9\n+   |\n+LL | struct S(i32, f32);\n+   | ------------------- tuple struct defined here\n+...\n+LL |         S(x) => {}\n+   |         ^^^^ expected 2 fields, found 1\n+   |\n+help: use `_` to explicitly ignore each field\n+   |\n+LL |         S(x, _) => {}\n+   |            ^^^\n+\n+error[E0023]: this pattern has 1 field, but the corresponding tuple struct has 2 fields\n+  --> $DIR/pat-tuple-underfield.rs:14:9\n+   |\n+LL | struct S(i32, f32);\n+   | ------------------- tuple struct defined here\n+...\n+LL |         S(_) => {}\n+   |         ^^^^ expected 2 fields, found 1\n+   |\n+help: use `_` to explicitly ignore each field\n+   |\n+LL |         S(_, _) => {}\n+   |            ^^^\n+help: use `..` to ignore all fields\n+   |\n+LL |         S(..) => {}\n+   |           ^^\n+\n+error[E0023]: this pattern has 0 fields, but the corresponding tuple struct has 2 fields\n+  --> $DIR/pat-tuple-underfield.rs:20:9\n+   |\n+LL | struct S(i32, f32);\n+   | ------------------- tuple struct defined here\n+...\n+LL |         S() => {}\n+   |         ^^^ expected 2 fields, found 0\n+   |\n+help: use `_` to explicitly ignore each field\n+   |\n+LL |         S(_, _) => {}\n+   |           ^^^^\n+help: use `..` to ignore all fields\n+   |\n+LL |         S(..) => {}\n+   |           ^^\n+\n+error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n+  --> $DIR/pat-tuple-underfield.rs:27:9\n+   |\n+LL |     S(i32, f32),\n+   |     ----------- tuple variant defined here\n+...\n+LL |         E::S(x) => {}\n+   |         ^^^^^^^ expected 2 fields, found 1\n+   |\n+help: use `_` to explicitly ignore each field\n+   |\n+LL |         E::S(x, _) => {}\n+   |               ^^^\n+\n+error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n+  --> $DIR/pat-tuple-underfield.rs:32:9\n+   |\n+LL |     S(i32, f32),\n+   |     ----------- tuple variant defined here\n+...\n+LL |         E::S(_) => {}\n+   |         ^^^^^^^ expected 2 fields, found 1\n+   |\n+help: use `_` to explicitly ignore each field\n+   |\n+LL |         E::S(_, _) => {}\n+   |               ^^^\n+help: use `..` to ignore all fields\n+   |\n+LL |         E::S(..) => {}\n+   |              ^^\n+\n+error[E0023]: this pattern has 0 fields, but the corresponding tuple variant has 2 fields\n+  --> $DIR/pat-tuple-underfield.rs:38:9\n+   |\n+LL |     S(i32, f32),\n+   |     ----------- tuple variant defined here\n+...\n+LL |         E::S() => {}\n+   |         ^^^^^^ expected 2 fields, found 0\n+   |\n+help: use `_` to explicitly ignore each field\n+   |\n+LL |         E::S(_, _) => {}\n+   |              ^^^^\n+help: use `..` to ignore all fields\n+   |\n+LL |         E::S(..) => {}\n+   |              ^^\n+\n+error[E0023]: this pattern has 2 fields, but the corresponding tuple struct has 4 fields\n+  --> $DIR/pat-tuple-underfield.rs:50:9\n+   |\n+LL | struct Point4(i32, i32, i32, i32);\n+   | ---------------------------------- tuple struct defined here\n+...\n+LL |         Point4(   a   ,     _    ) => {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 4 fields, found 2\n+   |\n+help: use `_` to explicitly ignore each field\n+   |\n+LL |         Point4(   a   ,     _    , _, _) => {}\n+   |                                  ^^^^^^\n+help: use `..` to ignore the rest of the fields\n+   |\n+LL |         Point4(   a   ,     _    , ..) => {}\n+   |                                  ^^^^\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors have detailed explanations: E0023, E0532.\n+For more information about an error, try `rustc --explain E0023`."}]}