{"sha": "dad59bdcbcf5860e21dcbfe5769e8887e73486fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZDU5YmRjYmNmNTg2MGUyMWRjYmZlNTc2OWU4ODg3ZTczNDg2ZmI=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-01T16:07:10Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-01T19:42:30Z"}, "message": "Remove std::io::signal\n\nThe `std::io::signal` API was only implemented under `librustuv`, which\nis now being removed. Rather than keep around an unimplemented API, this\ncommit removes it altogether.\n\nSee the [runtime removal\nRFC](https://github.com/rust-lang/rfcs/pull/230) for more context.\n\nSee [green-rs](https://github.com/alexcrichton/green-rs/) for a possible\nmigration path for signal handling code, although in the long run we\nplan to add native signal handling to `std::io`.\n\n[breaking-change]", "tree": {"sha": "2c0825ec3dfbe6916da08073d6f503f3102db9e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c0825ec3dfbe6916da08073d6f503f3102db9e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dad59bdcbcf5860e21dcbfe5769e8887e73486fb", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dad59bdcbcf5860e21dcbfe5769e8887e73486fb", "html_url": "https://github.com/rust-lang/rust/commit/dad59bdcbcf5860e21dcbfe5769e8887e73486fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dad59bdcbcf5860e21dcbfe5769e8887e73486fb/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5d2ed54a364776b1d3b7552bd474191df3619fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5d2ed54a364776b1d3b7552bd474191df3619fb", "html_url": "https://github.com/rust-lang/rust/commit/c5d2ed54a364776b1d3b7552bd474191df3619fb"}], "stats": {"total": 239, "additions": 1, "deletions": 238}, "files": [{"sha": "b929e7c464df02f0f2e83a09728011ad9353fa0d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dad59bdcbcf5860e21dcbfe5769e8887e73486fb/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad59bdcbcf5860e21dcbfe5769e8887e73486fb/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=dad59bdcbcf5860e21dcbfe5769e8887e73486fb", "patch": "@@ -21,7 +21,7 @@\n `std::io` provides Rust's basic I/O types,\n for reading and writing to files, TCP, UDP,\n and other types of sockets and pipes,\n-manipulating the file system, spawning processes and signal handling.\n+manipulating the file system, spawning processes.\n \n # Examples\n \n@@ -275,7 +275,6 @@ pub mod fs;\n pub mod net;\n pub mod pipe;\n pub mod process;\n-pub mod signal;\n pub mod stdio;\n pub mod test;\n pub mod timer;"}, {"sha": "79a00e90b40746d8fde0b6a3ce555bb3f17d8130", "filename": "src/libstd/io/signal.rs", "status": "removed", "additions": 0, "deletions": 236, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/c5d2ed54a364776b1d3b7552bd474191df3619fb/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d2ed54a364776b1d3b7552bd474191df3619fb/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=c5d2ed54a364776b1d3b7552bd474191df3619fb", "patch": "@@ -1,236 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Signal handling\n-\n-This modules provides bindings to receive signals safely, built on top of the\n-local I/O factory. There are a number of defined signals which can be caught,\n-but not all signals will work across all platforms (windows doesn't have\n-definitions for a number of signals.\n-\n-*/\n-\n-use clone::Clone;\n-use collections::MutableSeq;\n-use comm::{Sender, Receiver, channel};\n-use io;\n-use iter::Iterator;\n-use kinds::Send;\n-use mem::drop;\n-use option::{Some, None};\n-use boxed::Box;\n-use result::{Ok, Err};\n-use rt::rtio::{IoFactory, LocalIo, RtioSignal, Callback};\n-use slice::ImmutableSlice;\n-use vec::Vec;\n-\n-/// Signals that can be sent and received\n-#[repr(int)]\n-#[deriving(PartialEq, Hash, Show)]\n-pub enum Signum {\n-    /// Equivalent to SIGBREAK, delivered when the user presses Ctrl-Break.\n-    Break = 21i,\n-    /// Equivalent to SIGHUP, delivered when the user closes the terminal\n-    /// window. On delivery of HangUp, the program is given approximately\n-    /// 10 seconds to perform any cleanup. After that, Windows will\n-    /// unconditionally terminate it.\n-    HangUp = 1i,\n-    /// Equivalent to SIGINT, delivered when the user presses Ctrl-c.\n-    Interrupt = 2i,\n-    /// Equivalent to SIGQUIT, delivered when the user presses Ctrl-\\.\n-    Quit = 3i,\n-    /// Equivalent to SIGTSTP, delivered when the user presses Ctrl-z.\n-    StopTemporarily = 20i,\n-    /// Equivalent to SIGUSR1.\n-    User1 = 10i,\n-    /// Equivalent to SIGUSR2.\n-    User2 = 12i,\n-    /// Equivalent to SIGWINCH, delivered when the console has been resized.\n-    /// WindowSizeChange may not be delivered in a timely manner; size change\n-    /// will only be detected when the cursor is being moved.\n-    WindowSizeChange = 28i,\n-}\n-\n-/// Listener provides a receiver to listen for registered signals.\n-///\n-/// Listener automatically unregisters its handles once it is out of scope.\n-/// However, clients can still unregister signums manually.\n-///\n-/// # Example\n-///\n-/// ```rust,no_run\n-/// # #![allow(unused_must_use)]\n-/// use std::io::signal::{Listener, Interrupt};\n-///\n-/// let mut listener = Listener::new();\n-/// listener.register(Interrupt);\n-///\n-/// loop {\n-///     match listener.rx.recv() {\n-///         Interrupt => println!(\"Got Interrupt'ed\"),\n-///         _ => (),\n-///     }\n-/// }\n-/// ```\n-pub struct Listener {\n-    /// A map from signums to handles to keep the handles in memory\n-    handles: Vec<(Signum, Box<RtioSignal + Send>)>,\n-    /// This is where all the handles send signums, which are received by\n-    /// the clients from the receiver.\n-    tx: Sender<Signum>,\n-\n-    /// Clients of Listener can `recv()` on this receiver. This is exposed to\n-    /// allow selection over it as well as manipulation of the receiver\n-    /// directly.\n-    pub rx: Receiver<Signum>,\n-}\n-\n-impl Listener {\n-    /// Creates a new listener for signals. Once created, signals are bound via\n-    /// the `register` method (otherwise nothing will ever be received)\n-    pub fn new() -> Listener {\n-        let (tx, rx) = channel();\n-        Listener {\n-            tx: tx,\n-            rx: rx,\n-            handles: vec!(),\n-        }\n-    }\n-\n-    /// Listen for a signal, returning true when successfully registered for\n-    /// signum. Signals can be received using `recv()`.\n-    ///\n-    /// Once a signal is registered, this listener will continue to receive\n-    /// notifications of signals until it is unregistered. This occurs\n-    /// regardless of the number of other listeners registered in other tasks\n-    /// (or on this task).\n-    ///\n-    /// Signals are still received if there is no task actively waiting for\n-    /// a signal, and a later call to `recv` will return the signal that was\n-    /// received while no task was waiting on it.\n-    ///\n-    /// # Error\n-    ///\n-    /// If this function fails to register a signal handler, then an error will\n-    /// be returned.\n-    pub fn register(&mut self, signum: Signum) -> io::IoResult<()> {\n-        struct SignalCallback {\n-            signum: Signum,\n-            tx: Sender<Signum>,\n-        }\n-        impl Callback for SignalCallback {\n-            fn call(&mut self) { self.tx.send(self.signum) }\n-        }\n-\n-        if self.handles.iter().any(|&(sig, _)| sig == signum) {\n-            return Ok(()); // self is already listening to signum, so succeed\n-        }\n-        match LocalIo::maybe_raise(|io| {\n-            io.signal(signum as int, box SignalCallback {\n-                signum: signum,\n-                tx: self.tx.clone(),\n-            })\n-        }) {\n-            Ok(handle) => {\n-                self.handles.push((signum, handle));\n-                Ok(())\n-            }\n-            Err(e) => Err(io::IoError::from_rtio_error(e))\n-        }\n-    }\n-\n-    /// Unregisters a signal. If this listener currently had a handler\n-    /// registered for the signal, then it will stop receiving any more\n-    /// notification about the signal. If the signal has already been received,\n-    /// it may still be returned by `recv`.\n-    pub fn unregister(&mut self, signum: Signum) {\n-        match self.handles.iter().position(|&(i, _)| i == signum) {\n-            Some(i) => drop(self.handles.remove(i)),\n-            None => {}\n-        }\n-    }\n-}\n-\n-#[cfg(all(test, unix))]\n-mod test_unix {\n-    use prelude::*;\n-    use libc;\n-    use comm::Empty;\n-    use io::timer;\n-    use super::{Listener, Interrupt};\n-    use time::Duration;\n-\n-    fn sigint() {\n-        unsafe {\n-            libc::funcs::posix88::signal::kill(libc::getpid(), libc::SIGINT);\n-        }\n-    }\n-\n-    #[test] #[cfg(not(target_os=\"android\"))] // FIXME(#10378)\n-    fn test_io_signal_smoketest() {\n-        let mut signal = Listener::new();\n-        signal.register(Interrupt).unwrap();\n-        sigint();\n-        timer::sleep(Duration::milliseconds(10));\n-        match signal.rx.recv() {\n-            Interrupt => (),\n-            s => fail!(\"Expected Interrupt, got {:?}\", s),\n-        }\n-    }\n-\n-    #[test] #[cfg(not(target_os=\"android\"))] // FIXME(#10378)\n-    fn test_io_signal_two_signal_one_signum() {\n-        let mut s1 = Listener::new();\n-        let mut s2 = Listener::new();\n-        s1.register(Interrupt).unwrap();\n-        s2.register(Interrupt).unwrap();\n-        sigint();\n-        timer::sleep(Duration::milliseconds(10));\n-        match s1.rx.recv() {\n-            Interrupt => (),\n-            s => fail!(\"Expected Interrupt, got {:?}\", s),\n-        }\n-        match s2.rx.recv() {\n-            Interrupt => (),\n-            s => fail!(\"Expected Interrupt, got {:?}\", s),\n-        }\n-    }\n-\n-    #[test] #[cfg(not(target_os=\"android\"))] // FIXME(#10378)\n-    fn test_io_signal_unregister() {\n-        let mut s1 = Listener::new();\n-        let mut s2 = Listener::new();\n-        s1.register(Interrupt).unwrap();\n-        s2.register(Interrupt).unwrap();\n-        s2.unregister(Interrupt);\n-        sigint();\n-        timer::sleep(Duration::milliseconds(10));\n-        assert_eq!(s2.rx.try_recv(), Err(Empty));\n-    }\n-}\n-\n-#[cfg(all(test, windows))]\n-mod test_windows {\n-    use super::{User1, Listener};\n-    use result::{Ok, Err};\n-\n-    #[test]\n-    fn test_io_signal_invalid_signum() {\n-        let mut s = Listener::new();\n-        match s.register(User1) {\n-            Ok(..) => {\n-                fail!(\"Unexpected successful registry of signum {:?}\", User1);\n-            }\n-            Err(..) => {}\n-        }\n-    }\n-}"}]}