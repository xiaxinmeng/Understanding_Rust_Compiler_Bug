{"sha": "4a9dd3f8403f84ad518b0119fa2312c379df5dd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhOWRkM2Y4NDAzZjg0YWQ1MThiMDExOWZhMjMxMmMzNzlkZjVkZDc=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-02-12T00:57:23Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-02-16T21:53:09Z"}, "message": "Expose more of std::path\n\nThis commit exposes the `is_sep` function and `MAIN_SEP` constant, as\nwell as Windows path prefixes. The path prefix enum is safely exposed on\nall platforms, but it only yielded as a component for Windows.\n\nExposing the prefix enum as part of prefix components involved changing\nthe type from `OsStr` to the `Prefix` enum, which is a:\n\n[breaking-change]", "tree": {"sha": "5391b0b4ce4e82a704318b45267c14c596e3700c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5391b0b4ce4e82a704318b45267c14c596e3700c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a9dd3f8403f84ad518b0119fa2312c379df5dd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a9dd3f8403f84ad518b0119fa2312c379df5dd7", "html_url": "https://github.com/rust-lang/rust/commit/4a9dd3f8403f84ad518b0119fa2312c379df5dd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a9dd3f8403f84ad518b0119fa2312c379df5dd7/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e29f42025513374f1a88404491d1b40386acf994", "url": "https://api.github.com/repos/rust-lang/rust/commits/e29f42025513374f1a88404491d1b40386acf994", "html_url": "https://github.com/rust-lang/rust/commit/e29f42025513374f1a88404491d1b40386acf994"}], "stats": {"total": 249, "additions": 126, "deletions": 123}, "files": [{"sha": "485f5d8014d1f503fd237e570169a6c51674a30b", "filename": "src/libstd/path.rs", "status": "modified", "additions": 126, "deletions": 123, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/4a9dd3f8403f84ad518b0119fa2312c379df5dd7/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a9dd3f8403f84ad518b0119fa2312c379df5dd7/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=4a9dd3f8403f84ad518b0119fa2312c379df5dd7", "patch": "@@ -107,6 +107,7 @@\n \n use core::prelude::*;\n \n+use ascii::*;\n use borrow::BorrowFrom;\n use cmp;\n use iter;\n@@ -118,7 +119,7 @@ use fmt;\n \n use ffi::{OsStr, OsString, AsOsStr};\n \n-use self::platform::{is_sep, is_verbatim_sep, MAIN_SEP_STR, parse_prefix, Prefix};\n+use self::platform::{is_sep_byte, is_verbatim_sep, MAIN_SEP_STR, parse_prefix};\n \n ////////////////////////////////////////////////////////////////////////////////\n // GENERAL NOTES\n@@ -139,11 +140,12 @@ use self::platform::{is_sep, is_verbatim_sep, MAIN_SEP_STR, parse_prefix, Prefix\n \n #[cfg(unix)]\n mod platform {\n+    use super::Prefix;\n     use core::prelude::*;\n     use ffi::OsStr;\n \n     #[inline]\n-    pub fn is_sep(b: u8) -> bool {\n+    pub fn is_sep_byte(b: u8) -> bool {\n         b == b'/'\n     }\n \n@@ -156,34 +158,21 @@ mod platform {\n         None\n     }\n \n-    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-    pub struct Prefix<'a>;\n-\n-    impl<'a> Prefix<'a> {\n-        #[inline]\n-        pub fn len(&self) -> usize { 0 }\n-        #[inline]\n-        pub fn is_verbatim(&self) -> bool { false }\n-        #[inline]\n-        pub fn is_drive(&self) -> bool { false }\n-        #[inline]\n-        pub fn has_implicit_root(&self) -> bool { false }\n-    }\n-\n     pub const MAIN_SEP_STR: &'static str = \"/\";\n+    pub const MAIN_SEP: char = '/';\n }\n \n #[cfg(windows)]\n mod platform {\n     use core::prelude::*;\n+    use ascii::*;\n \n     use char::CharExt as UnicodeCharExt;\n-    use super::{os_str_as_u8_slice, u8_slice_as_os_str};\n-    use ascii::*;\n+    use super::{os_str_as_u8_slice, u8_slice_as_os_str, Prefix};\n     use ffi::OsStr;\n \n     #[inline]\n-    pub fn is_sep(b: u8) -> bool {\n+    pub fn is_sep_byte(b: u8) -> bool {\n         b == b'/' || b == b'\\\\'\n     }\n \n@@ -193,7 +182,7 @@ mod platform {\n     }\n \n     pub fn parse_prefix<'a>(path: &'a OsStr) -> Option<Prefix> {\n-        use self::Prefix::*;\n+        use super::Prefix::*;\n         unsafe {\n             // The unsafety here stems from converting between &OsStr and &[u8]\n             // and back. This is safe to do because (1) we only look at ASCII\n@@ -224,8 +213,7 @@ mod platform {\n                             let c = path[0];\n                             if c.is_ascii() && (c as char).is_alphabetic() {\n                                 // \\\\?\\C:\\ path\n-                                let slice = u8_slice_as_os_str(&path[0..1]);\n-                                return Some(VerbatimDisk(slice));\n+                                return Some(VerbatimDisk(c.to_ascii_uppercase()));\n                             }\n                         }\n                         let slice = &path[.. idx.unwrap_or(path.len())];\n@@ -237,7 +225,7 @@ mod platform {\n                     let slice = &path[.. path.position_elem(&b'\\\\').unwrap_or(path.len())];\n                     return Some(DeviceNS(u8_slice_as_os_str(slice)));\n                 }\n-                match parse_two_comps(path, is_sep) {\n+                match parse_two_comps(path, is_sep_byte) {\n                     Some((server, share)) if server.len() > 0 && share.len() > 0 => {\n                         // \\\\server\\share\n                         return Some(UNC(u8_slice_as_os_str(server),\n@@ -249,7 +237,7 @@ mod platform {\n                 // C:\n                 let c = path[0];\n                 if c.is_ascii() && (c as char).is_alphabetic() {\n-                    return Some(Disk(u8_slice_as_os_str(&path[0..1])));\n+                    return Some(Disk(c.to_ascii_uppercase()));\n                 }\n             }\n             return None;\n@@ -267,99 +255,102 @@ mod platform {\n         }\n     }\n \n-    /// Windows path prefixes.\n-    ///\n-    /// Windows uses a variety of path styles, including references to drive\n-    /// volumes (like `C:`), network shared (like `\\\\server\\share`) and\n-    /// others. In addition, some path prefixes are \"verbatim\", in which case\n-    /// `/` is *not* treated as a separator and essentially no normalization is\n-    /// performed.\n-    #[derive(Copy, Clone, Debug, Hash, Eq)]\n-    pub enum Prefix<'a> {\n-        /// Prefix `\\\\?\\`, together with the given component immediately following it.\n-        Verbatim(&'a OsStr),\n-\n-        /// Prefix `\\\\?\\UNC\\`, with the \"server\" and \"share\" components following it.\n-        VerbatimUNC(&'a OsStr, &'a OsStr),\n-\n-        /// Prefix like `\\\\?\\C:\\`, for the given drive letter\n-        VerbatimDisk(&'a OsStr),\n-\n-        /// Prefix `\\\\.\\`, together with the given component immediately following it.\n-        DeviceNS(&'a OsStr),\n-\n-        /// Prefix `\\\\server\\share`, with the given \"server\" and \"share\" components.\n-        UNC(&'a OsStr, &'a OsStr),\n-\n-        /// Prefix `C:` for the given disk drive.\n-        Disk(&'a OsStr),\n-    }\n-\n-    impl<'a> Prefix<'a> {\n-        #[inline]\n-        pub fn len(&self) -> usize {\n-            use self::Prefix::*;\n-            fn os_str_len(s: &OsStr) -> usize {\n-                os_str_as_u8_slice(s).len()\n-            }\n-            match *self {\n-                Verbatim(x) => 4 + os_str_len(x),\n-                VerbatimUNC(x,y) => 8 + os_str_len(x) +\n-                    if os_str_len(y) > 0 { 1 + os_str_len(y) }\n-                    else { 0 },\n-                VerbatimDisk(_) => 6,\n-                UNC(x,y) => 2 + os_str_len(x) +\n-                    if os_str_len(y) > 0 { 1 + os_str_len(y) }\n-                    else { 0 },\n-                DeviceNS(x) => 4 + os_str_len(x),\n-                Disk(_) => 2\n-            }\n+    pub const MAIN_SEP_STR: &'static str = \"\\\\\";\n+    pub const MAIN_SEP: char = '\\\\';\n+}\n \n-        }\n+////////////////////////////////////////////////////////////////////////////////\n+// Windows Prefixes\n+////////////////////////////////////////////////////////////////////////////////\n \n-        #[inline]\n-        pub fn is_verbatim(&self) -> bool {\n-            use self::Prefix::*;\n-            match *self {\n-                Verbatim(_) | VerbatimDisk(_) | VerbatimUNC(_, _) => true,\n-                _ => false\n-            }\n-        }\n+/// Path prefixes (Windows only).\n+///\n+/// Windows uses a variety of path styles, including references to drive\n+/// volumes (like `C:`), network shared (like `\\\\server\\share`) and\n+/// others. In addition, some path prefixes are \"verbatim\", in which case\n+/// `/` is *not* treated as a separator and essentially no normalization is\n+/// performed.\n+#[derive(Copy, Clone, Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]\n+pub enum Prefix<'a> {\n+    /// Prefix `\\\\?\\`, together with the given component immediately following it.\n+    Verbatim(&'a OsStr),\n+\n+    /// Prefix `\\\\?\\UNC\\`, with the \"server\" and \"share\" components following it.\n+    VerbatimUNC(&'a OsStr, &'a OsStr),\n+\n+    /// Prefix like `\\\\?\\C:\\`, for the given drive letter\n+    VerbatimDisk(u8),\n+\n+    /// Prefix `\\\\.\\`, together with the given component immediately following it.\n+    DeviceNS(&'a OsStr),\n+\n+    /// Prefix `\\\\server\\share`, with the given \"server\" and \"share\" components.\n+    UNC(&'a OsStr, &'a OsStr),\n+\n+    /// Prefix `C:` for the given disk drive.\n+    Disk(u8),\n+}\n \n-        #[inline]\n-        pub fn is_drive(&self) -> bool {\n-            match *self {\n-                Prefix::Disk(_) => true,\n-                _ => false,\n-            }\n+impl<'a> Prefix<'a> {\n+    #[inline]\n+    fn len(&self) -> usize {\n+        use self::Prefix::*;\n+        fn os_str_len(s: &OsStr) -> usize {\n+            os_str_as_u8_slice(s).len()\n+        }\n+        match *self {\n+            Verbatim(x) => 4 + os_str_len(x),\n+            VerbatimUNC(x,y) => 8 + os_str_len(x) +\n+                if os_str_len(y) > 0 { 1 + os_str_len(y) }\n+                else { 0 },\n+            VerbatimDisk(_) => 6,\n+            UNC(x,y) => 2 + os_str_len(x) +\n+                if os_str_len(y) > 0 { 1 + os_str_len(y) }\n+                else { 0 },\n+            DeviceNS(x) => 4 + os_str_len(x),\n+            Disk(_) => 2\n         }\n \n-        #[inline]\n-        pub fn has_implicit_root(&self) -> bool {\n-            !self.is_drive()\n+    }\n+\n+    /// Determine if the prefix is verbatim, i.e. begins `\\\\?\\`.\n+    #[inline]\n+    pub fn is_verbatim(&self) -> bool {\n+        use self::Prefix::*;\n+        match *self {\n+            Verbatim(_) | VerbatimDisk(_) | VerbatimUNC(_, _) => true,\n+            _ => false\n         }\n     }\n \n-    impl<'a> PartialEq for Prefix<'a> {\n-        fn eq(&self, other: &Prefix<'a>) -> bool {\n-            use self::Prefix::*;\n-            match (*self, *other) {\n-                (Verbatim(x), Verbatim(y)) => x == y,\n-                (VerbatimUNC(x1, x2), VerbatimUNC(y1, y2)) => x1 == y1 && x2 == y2,\n-                (VerbatimDisk(x), VerbatimDisk(y)) =>\n-                    os_str_as_u8_slice(x).eq_ignore_ascii_case(os_str_as_u8_slice(y)),\n-                (DeviceNS(x), DeviceNS(y)) => x == y,\n-                (UNC(x1, x2), UNC(y1, y2)) => x1 == y1 && x2 == y2,\n-                (Disk(x), Disk(y)) =>\n-                    os_str_as_u8_slice(x).eq_ignore_ascii_case(os_str_as_u8_slice(y)),\n-                _ => false,\n-            }\n+    #[inline]\n+    fn is_drive(&self) -> bool {\n+        match *self {\n+            Prefix::Disk(_) => true,\n+            _ => false,\n         }\n     }\n \n-    pub const MAIN_SEP_STR: &'static str = \"\\\\\";\n+    #[inline]\n+    fn has_implicit_root(&self) -> bool {\n+        !self.is_drive()\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Exposed parsing helpers\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Determine whether the character is one of the permitted path\n+/// separators for the current platform.\n+pub fn is_separator(c: char) -> bool {\n+    use ascii::*;\n+    c.is_ascii() && is_sep_byte(c as u8)\n }\n \n+/// The primary sperator for the current platform\n+pub const MAIN_SEPARATOR: char = platform::MAIN_SEP;\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Misc helpers\n ////////////////////////////////////////////////////////////////////////////////\n@@ -403,7 +394,7 @@ fn has_suffix(s: &[u8], prefix: Option<Prefix>) -> bool {\n         (p.len(), p.is_verbatim())\n     } else { (0, false) };\n     if prefix_len > 0 && prefix_len == s.len() && !verbatim { return true; }\n-    let mut splits = s[prefix_len..].split(|b| is_sep(*b));\n+    let mut splits = s[prefix_len..].split(|b| is_sep_byte(*b));\n     let last = splits.next_back().unwrap();\n     let more = splits.next_back().is_some();\n     more && last == b\"\"\n@@ -412,7 +403,7 @@ fn has_suffix(s: &[u8], prefix: Option<Prefix>) -> bool {\n /// Says whether the first byte after the prefix is a separator.\n fn has_physical_root(s: &[u8], prefix: Option<Prefix>) -> bool {\n     let path = if let Some(p) = prefix { &s[p.len()..] } else { s };\n-    path.len() > 0 && is_sep(path[0])\n+    path.len() > 0 && is_sep_byte(path[0])\n }\n \n fn parse_single_component(comp: &[u8]) -> Option<Component> {\n@@ -473,8 +464,16 @@ enum State {\n /// their role in the API.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n pub enum Component<'a> {\n-    /// A Windows path prefix, e.g. `C:` or `\\server\\share`\n-    Prefix(&'a OsStr),\n+    /// A Windows path prefix, e.g. `C:` or `\\server\\share`.\n+    ///\n+    /// Does not occur on Unix.\n+    Prefix {\n+        /// The prefix as an unparsed `OsStr` slice.\n+        raw: &'a OsStr,\n+\n+        /// The parsed prefix data.\n+        parsed: Prefix<'a>\n+    },\n \n     /// An empty component. Only used on Windows for the last component of\n     /// verbatim paths ending with a separator (e.g. the last component of\n@@ -498,7 +497,7 @@ impl<'a> Component<'a> {\n     /// Extract the underlying `OsStr` slice\n     pub fn as_os_str(self) -> &'a OsStr {\n         match self {\n-            Component::Prefix(path) => path,\n+            Component::Prefix { raw, .. } => &raw,\n             Component::Empty => OsStr::from_str(\"\"),\n             Component::RootDir => OsStr::from_str(MAIN_SEP_STR),\n             Component::CurDir => OsStr::from_str(\".\"),\n@@ -568,11 +567,11 @@ impl<'a> Components<'a> {\n     }\n \n     #[inline]\n-    fn is_sep(&self, b: u8) -> bool {\n+    fn is_sep_byte(&self, b: u8) -> bool {\n         if self.prefix_verbatim() {\n             is_verbatim_sep(b)\n         } else {\n-            is_sep(b)\n+            is_sep_byte(b)\n         }\n     }\n \n@@ -601,7 +600,7 @@ impl<'a> Components<'a> {\n     // remove the component\n     fn parse_next_component(&self) -> (usize, Option<Component<'a>>) {\n         debug_assert!(self.front == State::Body);\n-        let (extra, comp) = match self.path.iter().position(|b| self.is_sep(*b)) {\n+        let (extra, comp) = match self.path.iter().position(|b| self.is_sep_byte(*b)) {\n             None => (0, self.path),\n             Some(i) => (1, &self.path[.. i]),\n         };\n@@ -613,7 +612,7 @@ impl<'a> Components<'a> {\n     fn parse_next_component_back(&self) -> (usize, Option<Component<'a>>) {\n         debug_assert!(self.back == State::Body);\n         let start = self.prefix_and_root();\n-        let (extra, comp) = match self.path[start..].iter().rposition(|b| self.is_sep(*b)) {\n+        let (extra, comp) = match self.path[start..].iter().rposition(|b| self.is_sep_byte(*b)) {\n             None => (0, &self.path[start ..]),\n             Some(i) => (1, &self.path[start + i + 1 ..]),\n         };\n@@ -680,9 +679,12 @@ impl<'a> Iterator for Components<'a> {\n                 State::Prefix if self.prefix_len() > 0 => {\n                     self.front = State::Root;\n                     debug_assert!(self.prefix_len() <= self.path.len());\n-                    let prefix = &self.path[.. self.prefix_len()];\n+                    let raw = &self.path[.. self.prefix_len()];\n                     self.path = &self.path[self.prefix_len() .. ];\n-                    return Some(Component::Prefix(unsafe { u8_slice_as_os_str(prefix) }))\n+                    return Some(Component::Prefix {\n+                        raw: unsafe { u8_slice_as_os_str(raw) },\n+                        parsed: self.prefix.unwrap()\n+                    })\n                 }\n                 State::Prefix => {\n                     self.front = State::Root;\n@@ -755,9 +757,10 @@ impl<'a> DoubleEndedIterator for Components<'a> {\n                 }\n                 State::Prefix if self.prefix_len() > 0 => {\n                     self.back = State::Done;\n-                    return Some(Component::Prefix(unsafe {\n-                        u8_slice_as_os_str(self.path)\n-                    }))\n+                    return Some(Component::Prefix {\n+                        raw: unsafe { u8_slice_as_os_str(self.path) },\n+                        parsed: self.prefix.unwrap()\n+                    })\n                 }\n                 State::Prefix => {\n                     self.back = State::Done;\n@@ -844,7 +847,7 @@ impl PathBuf {\n     /// * if `path` has a prefix but no root, it replaces `self.\n     pub fn push<P: ?Sized>(&mut self, path: &P) where P: AsPath {\n         // in general, a separator is needed if the rightmost byte is not a separator\n-        let mut need_sep = self.as_mut_vec().last().map(|c| !is_sep(*c)).unwrap_or(false);\n+        let mut need_sep = self.as_mut_vec().last().map(|c| !is_sep_byte(*c)).unwrap_or(false);\n \n         // in the special case of `C:` on Windows, do *not* add a separator\n         {\n@@ -1135,11 +1138,11 @@ impl Path {\n \n         match (comp, comps.next_back()) {\n             (Some(Component::CurDir), Some(Component::RootDir)) => None,\n-            (Some(Component::CurDir), Some(Component::Prefix(_))) => None,\n+            (Some(Component::CurDir), Some(Component::Prefix { .. })) => None,\n             (Some(Component::Empty), Some(Component::RootDir)) => None,\n-            (Some(Component::Empty), Some(Component::Prefix(_))) => None,\n-            (Some(Component::Prefix(_)), None) => None,\n-            (Some(Component::RootDir), Some(Component::Prefix(_))) => None,\n+            (Some(Component::Empty), Some(Component::Prefix { .. })) => None,\n+            (Some(Component::Prefix { .. }), None) => None,\n+            (Some(Component::RootDir), Some(Component::Prefix { .. })) => None,\n             _ => rest\n         }\n     }"}]}