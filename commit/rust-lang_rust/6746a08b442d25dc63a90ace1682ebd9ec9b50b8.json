{"sha": "6746a08b442d25dc63a90ace1682ebd9ec9b50b8", "node_id": "C_kwDOAAsO6NoAKDY3NDZhMDhiNDQyZDI1ZGM2M2E5MGFjZTE2ODJlYmQ5ZWM5YjUwYjg", "commit": {"author": {"name": "Zachary S", "email": "zasample18+github@gmail.com", "date": "2022-08-07T02:11:02Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-15T12:10:00Z"}, "message": "fix: Fix return type of async closures.\n\n(rebased onto 6dfd8ae)", "tree": {"sha": "d5612027c13f9e2768c05e5c8b62aa8149dab10d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5612027c13f9e2768c05e5c8b62aa8149dab10d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6746a08b442d25dc63a90ace1682ebd9ec9b50b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6746a08b442d25dc63a90ace1682ebd9ec9b50b8", "html_url": "https://github.com/rust-lang/rust/commit/6746a08b442d25dc63a90ace1682ebd9ec9b50b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6746a08b442d25dc63a90ace1682ebd9ec9b50b8/comments", "author": {"login": "zachs18", "id": 8355914, "node_id": "MDQ6VXNlcjgzNTU5MTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8355914?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zachs18", "html_url": "https://github.com/zachs18", "followers_url": "https://api.github.com/users/zachs18/followers", "following_url": "https://api.github.com/users/zachs18/following{/other_user}", "gists_url": "https://api.github.com/users/zachs18/gists{/gist_id}", "starred_url": "https://api.github.com/users/zachs18/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zachs18/subscriptions", "organizations_url": "https://api.github.com/users/zachs18/orgs", "repos_url": "https://api.github.com/users/zachs18/repos", "events_url": "https://api.github.com/users/zachs18/events{/privacy}", "received_events_url": "https://api.github.com/users/zachs18/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1787c14e725e4ac416828f986b095a23ecd11494", "url": "https://api.github.com/repos/rust-lang/rust/commits/1787c14e725e4ac416828f986b095a23ecd11494", "html_url": "https://github.com/rust-lang/rust/commit/1787c14e725e4ac416828f986b095a23ecd11494"}], "stats": {"total": 114, "additions": 82, "deletions": 32}, "files": [{"sha": "fedaf39559858099094328286961bf44b7842bf2", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6746a08b442d25dc63a90ace1682ebd9ec9b50b8/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6746a08b442d25dc63a90ace1682ebd9ec9b50b8/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=6746a08b442d25dc63a90ace1682ebd9ec9b50b8", "patch": "@@ -499,6 +499,8 @@ impl ExprCollector<'_> {\n                         Movability::Movable\n                     };\n                     ClosureKind::Generator(movability)\n+                } else if e.async_token().is_some() {\n+                    ClosureKind::Async\n                 } else {\n                     ClosureKind::Closure\n                 };"}, {"sha": "610b7d8008d599e6ef8a8a1e3319a185831507e0", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6746a08b442d25dc63a90ace1682ebd9ec9b50b8/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6746a08b442d25dc63a90ace1682ebd9ec9b50b8/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=6746a08b442d25dc63a90ace1682ebd9ec9b50b8", "patch": "@@ -375,9 +375,20 @@ impl<'a> Printer<'a> {\n                     }\n                 }\n                 w!(self, \"|\");\n-                if let Some(ret_ty) = ret_type {\n-                    w!(self, \" -> \");\n-                    self.print_type_ref(ret_ty);\n+                match (ret_type, closure_kind) {\n+                    (Some(ret_ty), ClosureKind::Async) => {\n+                        w!(self, \" -> impl Future<Output = \");\n+                        self.print_type_ref(ret_ty);\n+                        w!(self, \">\");\n+                    }\n+                    (Some(ret_ty), _) => {\n+                        w!(self, \" -> \");\n+                        self.print_type_ref(ret_ty);\n+                    }\n+                    (None, ClosureKind::Async) => {\n+                        w!(self, \" -> impl Future<Output = {{unknown}}>\"); // FIXME(zachs18): {unknown} or ()?\n+                    }\n+                    (None, _) => {}\n                 }\n                 self.whitespace();\n                 self.print_expr(*body);"}, {"sha": "19fa6b25419e112cc92987a85d9a1308112b0bfd", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6746a08b442d25dc63a90ace1682ebd9ec9b50b8/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6746a08b442d25dc63a90ace1682ebd9ec9b50b8/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=6746a08b442d25dc63a90ace1682ebd9ec9b50b8", "patch": "@@ -245,6 +245,7 @@ pub enum Expr {\n pub enum ClosureKind {\n     Closure,\n     Generator(Movability),\n+    Async,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]"}, {"sha": "8113b0bd537af6782e09fae6dcaa8268e8c4ab03", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 65, "deletions": 29, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/6746a08b442d25dc63a90ace1682ebd9ec9b50b8/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6746a08b442d25dc63a90ace1682ebd9ec9b50b8/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=6746a08b442d25dc63a90ace1682ebd9ec9b50b8", "patch": "@@ -286,33 +286,38 @@ impl<'a> InferenceContext<'a> {\n                 })\n                 .intern(Interner);\n \n-                let (ty, resume_yield_tys) = if matches!(closure_kind, ClosureKind::Generator(_)) {\n-                    // FIXME: report error when there are more than 1 parameter.\n-                    let resume_ty = match sig_tys.first() {\n-                        // When `sig_tys.len() == 1` the first type is the return type, not the\n-                        // first parameter type.\n-                        Some(ty) if sig_tys.len() > 1 => ty.clone(),\n-                        _ => self.result.standard_types.unit.clone(),\n-                    };\n-                    let yield_ty = self.table.new_type_var();\n-\n-                    let subst = TyBuilder::subst_for_generator(self.db, self.owner)\n-                        .push(resume_ty.clone())\n-                        .push(yield_ty.clone())\n-                        .push(ret_ty.clone())\n-                        .build();\n+                let (closure_id, ty, resume_yield_tys) = match closure_kind {\n+                    ClosureKind::Generator(_) => {\n+                        // FIXME: report error when there are more than 1 parameter.\n+                        let resume_ty = match sig_tys.first() {\n+                            // When `sig_tys.len() == 1` the first type is the return type, not the\n+                            // first parameter type.\n+                            Some(ty) if sig_tys.len() > 1 => ty.clone(),\n+                            _ => self.result.standard_types.unit.clone(),\n+                        };\n+                        let yield_ty = self.table.new_type_var();\n+\n+                        let subst = TyBuilder::subst_for_generator(self.db, self.owner)\n+                            .push(resume_ty.clone())\n+                            .push(yield_ty.clone())\n+                            .push(ret_ty.clone())\n+                            .build();\n \n-                    let generator_id = self.db.intern_generator((self.owner, tgt_expr)).into();\n-                    let generator_ty = TyKind::Generator(generator_id, subst).intern(Interner);\n+                        let generator_id = self.db.intern_generator((self.owner, tgt_expr)).into();\n+                        let generator_ty = TyKind::Generator(generator_id, subst).intern(Interner);\n \n-                    (generator_ty, Some((resume_ty, yield_ty)))\n-                } else {\n-                    let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n-                    let closure_ty =\n-                        TyKind::Closure(closure_id, Substitution::from1(Interner, sig_ty.clone()))\n-                            .intern(Interner);\n+                        (None, generator_ty, Some((resume_ty, yield_ty)))\n+                    }\n+                    ClosureKind::Async | ClosureKind::Closure => {\n+                        let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n+                        let closure_ty = TyKind::Closure(\n+                            closure_id,\n+                            Substitution::from1(Interner, sig_ty.clone()),\n+                        )\n+                        .intern(Interner);\n \n-                    (closure_ty, None)\n+                        (Some(closure_id), closure_ty, None)\n+                    }\n                 };\n \n                 // Eagerly try to relate the closure type with the expected\n@@ -321,7 +326,7 @@ impl<'a> InferenceContext<'a> {\n                 self.deduce_closure_type_from_expectations(tgt_expr, &ty, &sig_ty, expected);\n \n                 // Now go through the argument patterns\n-                for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n+                for (arg_pat, arg_ty) in args.iter().zip(&sig_tys) {\n                     self.infer_top_pat(*arg_pat, &arg_ty);\n                 }\n \n@@ -333,16 +338,47 @@ impl<'a> InferenceContext<'a> {\n                 let prev_resume_yield_tys =\n                     mem::replace(&mut self.resume_yield_tys, resume_yield_tys);\n \n-                self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n-                    this.infer_return(*body);\n-                });\n+                let (breaks, ()) =\n+                    self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n+                        this.infer_return(*body);\n+                    });\n+\n+                let inner_ty = if matches!(closure_kind, ClosureKind::Async) {\n+                    // Use the first type parameter as the output type of future.\n+                    // existential type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n+                    let impl_trait_id =\n+                        crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, *body);\n+                    let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n+                    TyKind::OpaqueType(opaque_ty_id, Substitution::from1(Interner, ret_ty.clone()))\n+                        .intern(Interner)\n+                } else {\n+                    ret_ty.clone()\n+                };\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n                 self.return_coercion = prev_ret_coercion;\n                 self.resume_yield_tys = prev_resume_yield_tys;\n \n-                ty\n+                sig_tys.pop();\n+                sig_tys.push(inner_ty);\n+\n+                let sig_ty = TyKind::Function(FnPointer {\n+                    num_binders: 0,\n+                    sig: FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic: false },\n+                    substitution: FnSubst(\n+                        Substitution::from_iter(Interner, sig_tys.clone()).shifted_in(Interner),\n+                    ),\n+                })\n+                .intern(Interner);\n+\n+                match closure_id {\n+                    Some(closure_id) => {\n+                        TyKind::Closure(closure_id, Substitution::from1(Interner, sig_ty.clone()))\n+                            .intern(Interner)\n+                    }\n+                    None => ty,\n+                }\n             }\n             Expr::Call { callee, args, .. } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());"}]}