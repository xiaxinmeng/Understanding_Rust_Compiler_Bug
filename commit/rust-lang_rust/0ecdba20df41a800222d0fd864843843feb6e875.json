{"sha": "0ecdba20df41a800222d0fd864843843feb6e875", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlY2RiYTIwZGY0MWE4MDAyMjJkMGZkODY0ODQzODQzZmViNmU4NzU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-11T11:49:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-11T11:49:07Z"}, "message": "Merge #3920\n\n3920: Implement expand_task and list_macros in proc_macro_srv r=matklad a=edwin0cheng\n\nThis PR finish up the remain `proc_macro_srv` implementation :\r\n\r\n1. Added dylib loading code for proc-macro crate dylib. Note that we have to add some special flags for unix loading because of a bug in old version of glibc, see https://github.com/fedochet/rust-proc-macro-panic-inside-panic-expample/issues/1 and https://github.com/rust-lang/rust/issues/60593 for details.\r\n\r\n2. Added tests for proc-macro expansion: We use a trick here by adding `serde_derive` to dev-dependencies and calling `cargo-metadata` for searching its dylib path, and expand it in our tests. \r\n\r\n[EDIT]\r\nNote that this PR **DO NOT** implement the final glue code with rust-analzyer and proc-macro-srv yet.\r\n \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "f8c96eaece90cd0630075e2693f833e4385404f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8c96eaece90cd0630075e2693f833e4385404f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ecdba20df41a800222d0fd864843843feb6e875", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeka6zCRBK7hj4Ov3rIwAAdHIIAH6QPoAJIQbVMVVLMZH7rhEc\nLSOc+YHto9kFHmZwEG5Mt9e5ocbeB/REbrInCFb4aQF/bA6xteMUW9yzHhVd3AgR\n1Ay6vMlBusDxirtWR920fIFb4d2tC7cW/fJmPixlPKb0hvf84xeS1WKj9YVNUYRx\nIhCwAGjpn1LncwUN2CseRsPNCi4ftvdVcD9NWWrClN59nqzgPOnQSNQ6zQryJfJ2\n0nVHQmUGX7F869DI5uLmNeoRJihaFiz9S5dLXJ46qJYV8JplsJ5uvvjFaS2S0t2X\nqxyRYajGFQL1vqpcm73bEiX36cqJmPYOmZMYLO5rJ1pwyo3wlptqj0A9QxDFCEI=\n=Rvgu\n-----END PGP SIGNATURE-----\n", "payload": "tree f8c96eaece90cd0630075e2693f833e4385404f7\nparent 54bdb9c78b012c560efc142971dc3e724989e807\nparent 31d163aa3be9c938ffe713534e4f648550a35f6c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586605747 +0000\ncommitter GitHub <noreply@github.com> 1586605747 +0000\n\nMerge #3920\n\n3920: Implement expand_task and list_macros in proc_macro_srv r=matklad a=edwin0cheng\n\nThis PR finish up the remain `proc_macro_srv` implementation :\r\n\r\n1. Added dylib loading code for proc-macro crate dylib. Note that we have to add some special flags for unix loading because of a bug in old version of glibc, see https://github.com/fedochet/rust-proc-macro-panic-inside-panic-expample/issues/1 and https://github.com/rust-lang/rust/issues/60593 for details.\r\n\r\n2. Added tests for proc-macro expansion: We use a trick here by adding `serde_derive` to dev-dependencies and calling `cargo-metadata` for searching its dylib path, and expand it in our tests. \r\n\r\n[EDIT]\r\nNote that this PR **DO NOT** implement the final glue code with rust-analzyer and proc-macro-srv yet.\r\n \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ecdba20df41a800222d0fd864843843feb6e875", "html_url": "https://github.com/rust-lang/rust/commit/0ecdba20df41a800222d0fd864843843feb6e875", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ecdba20df41a800222d0fd864843843feb6e875/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54bdb9c78b012c560efc142971dc3e724989e807", "url": "https://api.github.com/repos/rust-lang/rust/commits/54bdb9c78b012c560efc142971dc3e724989e807", "html_url": "https://github.com/rust-lang/rust/commit/54bdb9c78b012c560efc142971dc3e724989e807"}, {"sha": "31d163aa3be9c938ffe713534e4f648550a35f6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/31d163aa3be9c938ffe713534e4f648550a35f6c", "html_url": "https://github.com/rust-lang/rust/commit/31d163aa3be9c938ffe713534e4f648550a35f6c"}], "stats": {"total": 605, "additions": 600, "deletions": 5}, "files": [{"sha": "975c1aef86835efa0d24274770146933addcfd35", "filename": "Cargo.lock", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0ecdba20df41a800222d0fd864843843feb6e875/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0ecdba20df41a800222d0fd864843843feb6e875/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0ecdba20df41a800222d0fd864843843feb6e875", "patch": "@@ -424,6 +424,17 @@ dependencies = [\n  \"regex\",\n ]\n \n+[[package]]\n+name = \"goblin\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ddd5e3132801a1ac34ac53b97acde50c4685414dd2f291b9ea52afa6f07468c8\"\n+dependencies = [\n+ \"log\",\n+ \"plain\",\n+ \"scroll\",\n+]\n+\n [[package]]\n name = \"heck\"\n version = \"0.3.1\"\n@@ -586,6 +597,15 @@ version = \"0.2.68\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dea0c0405123bba743ee3f91f49b1c7cfb684eef0da0a50110f758ccf24cdff0\"\n \n+[[package]]\n+name = \"libloading\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2c979a19ffb457f0273965c333053f3d586bf759bf7b683fbebc37f9a9ebedc4\"\n+dependencies = [\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"linked-hash-map\"\n version = \"0.5.2\"\n@@ -825,6 +845,12 @@ version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3ad1f1b834a05d42dae330066e9699a173b28185b3bdc3dbf14ca239585de8cc\"\n \n+[[package]]\n+name = \"plain\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b4596b6d070b27117e987119b4dac604f3c58cfb0b191112e24771b2faeac1a6\"\n+\n [[package]]\n name = \"ppv-lite86\"\n version = \"0.2.6\"\n@@ -1082,10 +1108,13 @@ version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata\",\n  \"difference\",\n+ \"goblin\",\n+ \"libloading\",\n  \"ra_mbe\",\n  \"ra_proc_macro\",\n  \"ra_tt\",\n  \"serde_derive\",\n+ \"test_utils\",\n ]\n \n [[package]]\n@@ -1403,6 +1432,26 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n \n+[[package]]\n+name = \"scroll\"\n+version = \"0.10.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"abb2332cb595d33f7edd5700f4cbf94892e680c7f0ae56adab58a35190b66cb1\"\n+dependencies = [\n+ \"scroll_derive\",\n+]\n+\n+[[package]]\n+name = \"scroll_derive\"\n+version = \"0.10.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f8584eea9b9ff42825b46faf46a8c24d2cff13ec152fa2a50df788b87c07ee28\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"semver\"\n version = \"0.9.0\""}, {"sha": "1e0f5033920ce9001e8a92207ac2814c8d0f6686", "filename": "crates/ra_proc_macro_srv/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ecdba20df41a800222d0fd864843843feb6e875/crates%2Fra_proc_macro_srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0ecdba20df41a800222d0fd864843843feb6e875/crates%2Fra_proc_macro_srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2FCargo.toml?ref=0ecdba20df41a800222d0fd864843843feb6e875", "patch": "@@ -12,9 +12,12 @@ doctest = false\n ra_tt = { path = \"../ra_tt\" }\n ra_mbe = { path = \"../ra_mbe\" }\n ra_proc_macro = { path = \"../ra_proc_macro\" }\n+goblin = \"0.2.1\"\n+libloading = \"0.6.0\"\n+test_utils = { path = \"../test_utils\" }\n \n [dev-dependencies]\n cargo_metadata = \"0.9.1\"\n difference = \"2.0.0\"\n # used as proc macro test target\n-serde_derive = \"=1.0.104\"\n\\ No newline at end of file\n+serde_derive = \"=1.0.104\""}, {"sha": "ec63d587bb294e23ed1f795e86a9bcd1f2ca19ec", "filename": "crates/ra_proc_macro_srv/src/dylib.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/0ecdba20df41a800222d0fd864843843feb6e875/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecdba20df41a800222d0fd864843843feb6e875/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs?ref=0ecdba20df41a800222d0fd864843843feb6e875", "patch": "@@ -0,0 +1,211 @@\n+//! Handles dynamic library loading for proc macro\n+\n+use crate::{proc_macro::bridge, rustc_server::TokenStream};\n+use std::path::Path;\n+\n+use goblin::{mach::Mach, Object};\n+use libloading::Library;\n+use ra_proc_macro::ProcMacroKind;\n+\n+use std::io::Error as IoError;\n+use std::io::ErrorKind as IoErrorKind;\n+\n+const NEW_REGISTRAR_SYMBOL: &str = \"_rustc_proc_macro_decls_\";\n+\n+fn invalid_data_err(e: impl Into<Box<dyn std::error::Error + Send + Sync>>) -> IoError {\n+    IoError::new(IoErrorKind::InvalidData, e)\n+}\n+\n+fn get_symbols_from_lib(file: &Path) -> Result<Vec<String>, IoError> {\n+    let buffer = std::fs::read(file)?;\n+    let object = Object::parse(&buffer).map_err(invalid_data_err)?;\n+\n+    match object {\n+        Object::Elf(elf) => {\n+            let symbols = elf.dynstrtab.to_vec().map_err(invalid_data_err)?;\n+            let names = symbols.iter().map(|s| s.to_string()).collect();\n+            Ok(names)\n+        }\n+        Object::PE(pe) => {\n+            let symbol_names =\n+                pe.exports.iter().flat_map(|s| s.name).map(|n| n.to_string()).collect();\n+            Ok(symbol_names)\n+        }\n+        Object::Mach(mach) => match mach {\n+            Mach::Binary(binary) => {\n+                let exports = binary.exports().map_err(invalid_data_err)?;\n+                let names = exports\n+                    .into_iter()\n+                    .map(|s| {\n+                        // In macos doc:\n+                        // https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlsym.3.html\n+                        // Unlike other dyld API's, the symbol name passed to dlsym() must NOT be\n+                        // prepended with an underscore.\n+                        if s.name.starts_with(\"_\") {\n+                            s.name[1..].to_string()\n+                        } else {\n+                            s.name\n+                        }\n+                    })\n+                    .collect();\n+                Ok(names)\n+            }\n+            Mach::Fat(_) => Ok(vec![]),\n+        },\n+        Object::Archive(_) | Object::Unknown(_) => Ok(vec![]),\n+    }\n+}\n+\n+fn is_derive_registrar_symbol(symbol: &str) -> bool {\n+    symbol.contains(NEW_REGISTRAR_SYMBOL)\n+}\n+\n+fn find_registrar_symbol(file: &Path) -> Result<Option<String>, IoError> {\n+    let symbols = get_symbols_from_lib(file)?;\n+    Ok(symbols.into_iter().find(|s| is_derive_registrar_symbol(s)))\n+}\n+\n+/// Loads dynamic library in platform dependent manner.\n+///\n+/// For unix, you have to use RTLD_DEEPBIND flag to escape problems described\n+/// [here](https://github.com/fedochet/rust-proc-macro-panic-inside-panic-expample)\n+/// and [here](https://github.com/rust-lang/rust/issues/60593).\n+///\n+/// Usage of RTLD_DEEPBIND\n+/// [here](https://github.com/fedochet/rust-proc-macro-panic-inside-panic-expample/issues/1)\n+///\n+/// It seems that on Windows that behaviour is default, so we do nothing in that case.\n+#[cfg(windows)]\n+fn load_library(file: &Path) -> Result<Library, libloading::Error> {\n+    Library::new(file)\n+}\n+\n+#[cfg(unix)]\n+fn load_library(file: &Path) -> Result<Library, libloading::Error> {\n+    use libloading::os::unix::Library as UnixLibrary;\n+    use std::os::raw::c_int;\n+\n+    const RTLD_NOW: c_int = 0x00002;\n+    const RTLD_DEEPBIND: c_int = 0x00008;\n+\n+    UnixLibrary::open(Some(file), RTLD_NOW | RTLD_DEEPBIND).map(|lib| lib.into())\n+}\n+\n+struct ProcMacroLibraryLibloading {\n+    // Hold the dylib to prevent it for unloadeding\n+    _lib: Library,\n+    exported_macros: Vec<bridge::client::ProcMacro>,\n+}\n+\n+impl ProcMacroLibraryLibloading {\n+    fn open(file: &Path) -> Result<Self, IoError> {\n+        let symbol_name = find_registrar_symbol(file)?\n+            .ok_or(invalid_data_err(format!(\"Cannot find registrar symbol in file {:?}\", file)))?;\n+\n+        let lib = load_library(file).map_err(invalid_data_err)?;\n+        let exported_macros = {\n+            let macros: libloading::Symbol<&&[bridge::client::ProcMacro]> =\n+                unsafe { lib.get(symbol_name.as_bytes()) }.map_err(invalid_data_err)?;\n+            macros.to_vec()\n+        };\n+\n+        Ok(ProcMacroLibraryLibloading { _lib: lib, exported_macros })\n+    }\n+}\n+\n+type ProcMacroLibraryImpl = ProcMacroLibraryLibloading;\n+\n+pub struct Expander {\n+    libs: Vec<ProcMacroLibraryImpl>,\n+}\n+\n+impl Expander {\n+    pub fn new<P: AsRef<Path>>(lib: &P) -> Result<Expander, String> {\n+        let mut libs = vec![];\n+        /* Some libraries for dynamic loading require canonicalized path (even when it is\n+        already absolute\n+        */\n+        let lib =\n+            lib.as_ref().canonicalize().expect(&format!(\"Cannot canonicalize {:?}\", lib.as_ref()));\n+\n+        let library = ProcMacroLibraryImpl::open(&lib).map_err(|e| e.to_string())?;\n+        libs.push(library);\n+\n+        Ok(Expander { libs })\n+    }\n+\n+    pub fn expand(\n+        &self,\n+        macro_name: &str,\n+        macro_body: &ra_tt::Subtree,\n+        attributes: Option<&ra_tt::Subtree>,\n+    ) -> Result<ra_tt::Subtree, bridge::PanicMessage> {\n+        let parsed_body = TokenStream::with_subtree(macro_body.clone());\n+\n+        let parsed_attributes = attributes\n+            .map_or(crate::rustc_server::TokenStream::new(), |attr| {\n+                TokenStream::with_subtree(attr.clone())\n+            });\n+\n+        for lib in &self.libs {\n+            for proc_macro in &lib.exported_macros {\n+                match proc_macro {\n+                    bridge::client::ProcMacro::CustomDerive { trait_name, client, .. }\n+                        if *trait_name == macro_name =>\n+                    {\n+                        let res = client.run(\n+                            &crate::proc_macro::bridge::server::SameThread,\n+                            crate::rustc_server::Rustc::default(),\n+                            parsed_body,\n+                        );\n+                        return res.map(|it| it.subtree);\n+                    }\n+                    bridge::client::ProcMacro::Bang { name, client } if *name == macro_name => {\n+                        let res = client.run(\n+                            &crate::proc_macro::bridge::server::SameThread,\n+                            crate::rustc_server::Rustc::default(),\n+                            parsed_body,\n+                        );\n+                        return res.map(|it| it.subtree);\n+                    }\n+                    bridge::client::ProcMacro::Attr { name, client } if *name == macro_name => {\n+                        let res = client.run(\n+                            &crate::proc_macro::bridge::server::SameThread,\n+                            crate::rustc_server::Rustc::default(),\n+                            parsed_attributes,\n+                            parsed_body,\n+                        );\n+\n+                        return res.map(|it| it.subtree);\n+                    }\n+                    _ => continue,\n+                }\n+            }\n+        }\n+\n+        Err(bridge::PanicMessage::String(\"Nothing to expand\".to_string()))\n+    }\n+\n+    pub fn list_macros(&self) -> Result<Vec<(String, ProcMacroKind)>, bridge::PanicMessage> {\n+        let mut result = vec![];\n+\n+        for lib in &self.libs {\n+            for proc_macro in &lib.exported_macros {\n+                let res = match proc_macro {\n+                    bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n+                        (trait_name.to_string(), ProcMacroKind::CustomDerive)\n+                    }\n+                    bridge::client::ProcMacro::Bang { name, .. } => {\n+                        (name.to_string(), ProcMacroKind::FuncLike)\n+                    }\n+                    bridge::client::ProcMacro::Attr { name, .. } => {\n+                        (name.to_string(), ProcMacroKind::Attr)\n+                    }\n+                };\n+                result.push(res);\n+            }\n+        }\n+\n+        Ok(result)\n+    }\n+}"}, {"sha": "59716cbb3b0323bb0d0a7cd44cb3bdb544c20dae", "filename": "crates/ra_proc_macro_srv/src/lib.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0ecdba20df41a800222d0fd864843843feb6e875/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecdba20df41a800222d0fd864843843feb6e875/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs?ref=0ecdba20df41a800222d0fd864843843feb6e875", "patch": "@@ -17,13 +17,41 @@ mod proc_macro;\n #[doc(hidden)]\n mod rustc_server;\n \n+mod dylib;\n+\n use proc_macro::bridge::client::TokenStream;\n use ra_proc_macro::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask};\n \n-pub fn expand_task(_task: &ExpansionTask) -> Result<ExpansionResult, String> {\n-    unimplemented!()\n+pub fn expand_task(task: &ExpansionTask) -> Result<ExpansionResult, String> {\n+    let expander = dylib::Expander::new(&task.lib)\n+        .expect(&format!(\"Cannot expand with provided libraries: ${:?}\", &task.lib));\n+\n+    match expander.expand(&task.macro_name, &task.macro_body, task.attributes.as_ref()) {\n+        Ok(expansion) => Ok(ExpansionResult { expansion }),\n+        Err(msg) => {\n+            let reason = format!(\n+                \"Cannot perform expansion for {}: error {:?}!\",\n+                &task.macro_name,\n+                msg.as_str()\n+            );\n+            Err(reason)\n+        }\n+    }\n }\n \n-pub fn list_macros(_task: &ListMacrosTask) -> Result<ListMacrosResult, String> {\n-    unimplemented!()\n+pub fn list_macros(task: &ListMacrosTask) -> Result<ListMacrosResult, String> {\n+    let expander = dylib::Expander::new(&task.lib)\n+        .expect(&format!(\"Cannot expand with provided libraries: ${:?}\", &task.lib));\n+\n+    match expander.list_macros() {\n+        Ok(macros) => Ok(ListMacrosResult { macros }),\n+        Err(msg) => {\n+            let reason =\n+                format!(\"Cannot perform expansion for {:?}: error {:?}!\", &task.lib, msg.as_str());\n+            Err(reason)\n+        }\n+    }\n }\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "ec0d356922d0191cfbf436ea6e897a1f6248bc5f", "filename": "crates/ra_proc_macro_srv/src/rustc_server.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ecdba20df41a800222d0fd864843843feb6e875/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecdba20df41a800222d0fd864843843feb6e875/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs?ref=0ecdba20df41a800222d0fd864843843feb6e875", "patch": "@@ -34,6 +34,10 @@ impl TokenStream {\n         TokenStream { subtree: Default::default() }\n     }\n \n+    pub fn with_subtree(subtree: tt::Subtree) -> Self {\n+        TokenStream { subtree }\n+    }\n+\n     pub fn is_empty(&self) -> bool {\n         self.subtree.token_trees.is_empty()\n     }"}, {"sha": "24507d98d76f686b9372383c5bafec0eca2e4a32", "filename": "crates/ra_proc_macro_srv/src/tests/fixtures/test_serialize_proc_macro.txt", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/0ecdba20df41a800222d0fd864843843feb6e875/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Ffixtures%2Ftest_serialize_proc_macro.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0ecdba20df41a800222d0fd864843843feb6e875/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Ffixtures%2Ftest_serialize_proc_macro.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Ffixtures%2Ftest_serialize_proc_macro.txt?ref=0ecdba20df41a800222d0fd864843843feb6e875", "patch": "@@ -0,0 +1,188 @@\n+SUBTREE $\n+  PUNCH   # [alone] 4294967295\n+  SUBTREE [] 4294967295\n+    IDENT   allow 4294967295\n+    SUBTREE () 4294967295\n+      IDENT   non_upper_case_globals 4294967295\n+      PUNCH   , [alone] 4294967295\n+      IDENT   unused_attributes 4294967295\n+      PUNCH   , [alone] 4294967295\n+      IDENT   unused_qualifications 4294967295\n+  IDENT   const 4294967295\n+  IDENT   _IMPL_SERIALIZE_FOR_Foo 4294967295\n+  PUNCH   : [alone] 4294967295\n+  SUBTREE () 4294967295\n+  PUNCH   = [alone] 4294967295\n+  SUBTREE {} 4294967295\n+    PUNCH   # [alone] 4294967295\n+    SUBTREE [] 4294967295\n+      IDENT   allow 4294967295\n+      SUBTREE () 4294967295\n+        IDENT   unknown_lints 4294967295\n+    PUNCH   # [alone] 4294967295\n+    SUBTREE [] 4294967295\n+      IDENT   cfg_attr 4294967295\n+      SUBTREE () 4294967295\n+        IDENT   feature 4294967295\n+        PUNCH   = [alone] 4294967295\n+        SUBTREE $\n+          LITERAL \"cargo-clippy\" 0\n+        PUNCH   , [alone] 4294967295\n+        IDENT   allow 4294967295\n+        SUBTREE () 4294967295\n+          IDENT   useless_attribute 4294967295\n+    PUNCH   # [alone] 4294967295\n+    SUBTREE [] 4294967295\n+      IDENT   allow 4294967295\n+      SUBTREE () 4294967295\n+        IDENT   rust_2018_idioms 4294967295\n+    IDENT   extern 4294967295\n+    IDENT   crate 4294967295\n+    IDENT   serde 4294967295\n+    IDENT   as 4294967295\n+    IDENT   _serde 4294967295\n+    PUNCH   ; [alone] 4294967295\n+    PUNCH   # [alone] 4294967295\n+    SUBTREE [] 4294967295\n+      IDENT   allow 4294967295\n+      SUBTREE () 4294967295\n+        IDENT   unused_macros 4294967295\n+    IDENT   macro_rules 4294967295\n+    PUNCH   ! [alone] 4294967295\n+    IDENT   try 4294967295\n+    SUBTREE {} 4294967295\n+      SUBTREE () 4294967295\n+        PUNCH   $ [alone] 4294967295\n+        IDENT   __expr 4294967295\n+        PUNCH   : [alone] 4294967295\n+        IDENT   expr 4294967295\n+      PUNCH   = [joint] 4294967295\n+      PUNCH   > [alone] 4294967295\n+      SUBTREE {} 4294967295\n+        IDENT   match 4294967295\n+        PUNCH   $ [alone] 4294967295\n+        IDENT   __expr 4294967295\n+        SUBTREE {} 4294967295\n+          IDENT   _serde 4294967295\n+          PUNCH   : [joint] 4294967295\n+          PUNCH   : [alone] 4294967295\n+          IDENT   export 4294967295\n+          PUNCH   : [joint] 4294967295\n+          PUNCH   : [alone] 4294967295\n+          IDENT   Ok 4294967295\n+          SUBTREE () 4294967295\n+            IDENT   __val 4294967295\n+          PUNCH   = [joint] 4294967295\n+          PUNCH   > [alone] 4294967295\n+          IDENT   __val 4294967295\n+          PUNCH   , [alone] 4294967295\n+          IDENT   _serde 4294967295\n+          PUNCH   : [joint] 4294967295\n+          PUNCH   : [alone] 4294967295\n+          IDENT   export 4294967295\n+          PUNCH   : [joint] 4294967295\n+          PUNCH   : [alone] 4294967295\n+          IDENT   Err 4294967295\n+          SUBTREE () 4294967295\n+            IDENT   __err 4294967295\n+          PUNCH   = [joint] 4294967295\n+          PUNCH   > [alone] 4294967295\n+          SUBTREE {} 4294967295\n+            IDENT   return 4294967295\n+            IDENT   _serde 4294967295\n+            PUNCH   : [joint] 4294967295\n+            PUNCH   : [alone] 4294967295\n+            IDENT   export 4294967295\n+            PUNCH   : [joint] 4294967295\n+            PUNCH   : [alone] 4294967295\n+            IDENT   Err 4294967295\n+            SUBTREE () 4294967295\n+              IDENT   __err 4294967295\n+            PUNCH   ; [alone] 4294967295\n+    PUNCH   # [alone] 4294967295\n+    SUBTREE [] 4294967295\n+      IDENT   automatically_derived 4294967295\n+    IDENT   impl 4294967295\n+    IDENT   _serde 4294967295\n+    PUNCH   : [joint] 4294967295\n+    PUNCH   : [alone] 4294967295\n+    IDENT   Serialize 4294967295\n+    IDENT   for 4294967295\n+    IDENT   Foo 1\n+    SUBTREE {} 4294967295\n+      IDENT   fn 4294967295\n+      IDENT   serialize 4294967295\n+      PUNCH   < [alone] 4294967295\n+      IDENT   __S 4294967295\n+      PUNCH   > [alone] 4294967295\n+      SUBTREE () 4294967295\n+        PUNCH   & [alone] 4294967295\n+        IDENT   self 4294967295\n+        PUNCH   , [alone] 4294967295\n+        IDENT   __serializer 4294967295\n+        PUNCH   : [alone] 4294967295\n+        IDENT   __S 4294967295\n+      PUNCH   - [joint] 4294967295\n+      PUNCH   > [alone] 4294967295\n+      IDENT   _serde 4294967295\n+      PUNCH   : [joint] 4294967295\n+      PUNCH   : [alone] 4294967295\n+      IDENT   export 4294967295\n+      PUNCH   : [joint] 4294967295\n+      PUNCH   : [alone] 4294967295\n+      IDENT   Result 4294967295\n+      PUNCH   < [alone] 4294967295\n+      IDENT   __S 4294967295\n+      PUNCH   : [joint] 4294967295\n+      PUNCH   : [alone] 4294967295\n+      IDENT   Ok 4294967295\n+      PUNCH   , [alone] 4294967295\n+      IDENT   __S 4294967295\n+      PUNCH   : [joint] 4294967295\n+      PUNCH   : [alone] 4294967295\n+      IDENT   Error 4294967295\n+      PUNCH   > [alone] 4294967295\n+      IDENT   where 4294967295\n+      IDENT   __S 4294967295\n+      PUNCH   : [alone] 4294967295\n+      IDENT   _serde 4294967295\n+      PUNCH   : [joint] 4294967295\n+      PUNCH   : [alone] 4294967295\n+      IDENT   Serializer 4294967295\n+      PUNCH   , [alone] 4294967295\n+      SUBTREE {} 4294967295\n+        IDENT   let 4294967295\n+        IDENT   __serde_state 4294967295\n+        PUNCH   = [alone] 4294967295\n+        IDENT   try 4294967295\n+        PUNCH   ! [alone] 4294967295\n+        SUBTREE () 4294967295\n+          IDENT   _serde 4294967295\n+          PUNCH   : [joint] 4294967295\n+          PUNCH   : [alone] 4294967295\n+          IDENT   Serializer 4294967295\n+          PUNCH   : [joint] 4294967295\n+          PUNCH   : [alone] 4294967295\n+          IDENT   serialize_struct 4294967295\n+          SUBTREE () 4294967295\n+            IDENT   __serializer 4294967295\n+            PUNCH   , [alone] 4294967295\n+            LITERAL \"Foo\" 4294967295\n+            PUNCH   , [alone] 4294967295\n+            IDENT   false 4294967295\n+            IDENT   as 4294967295\n+            IDENT   usize 4294967295\n+        PUNCH   ; [alone] 4294967295\n+        IDENT   _serde 4294967295\n+        PUNCH   : [joint] 4294967295\n+        PUNCH   : [alone] 4294967295\n+        IDENT   ser 4294967295\n+        PUNCH   : [joint] 4294967295\n+        PUNCH   : [alone] 4294967295\n+        IDENT   SerializeStruct 4294967295\n+        PUNCH   : [joint] 4294967295\n+        PUNCH   : [alone] 4294967295\n+        IDENT   end 4294967295\n+        SUBTREE () 4294967295\n+          IDENT   __serde_state 4294967295\n+  PUNCH   ; [alone] 4294967295\n\\ No newline at end of file"}, {"sha": "03f79bc5d60f22b3177ea7e7cf46d69e6b171ad0", "filename": "crates/ra_proc_macro_srv/src/tests/mod.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0ecdba20df41a800222d0fd864843843feb6e875/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecdba20df41a800222d0fd864843843feb6e875/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Fmod.rs?ref=0ecdba20df41a800222d0fd864843843feb6e875", "patch": "@@ -0,0 +1,47 @@\n+//! proc-macro tests\n+\n+#[macro_use]\n+mod utils;\n+use test_utils::assert_eq_text;\n+use utils::*;\n+\n+#[test]\n+fn test_derive_serialize_proc_macro() {\n+    assert_expand(\n+        \"serde_derive\",\n+        \"Serialize\",\n+        \"1.0.104\",\n+        r##\"struct Foo {}\"##,\n+        include_str!(\"fixtures/test_serialize_proc_macro.txt\"),\n+    );\n+}\n+\n+#[test]\n+fn test_derive_serialize_proc_macro_failed() {\n+    assert_expand(\n+        \"serde_derive\",\n+        \"Serialize\",\n+        \"1.0.104\",\n+        r##\"\n+    struct {}\n+\"##,\n+        r##\"\n+SUBTREE $\n+  IDENT   compile_error 4294967295\n+  PUNCH   ! [alone] 4294967295\n+  SUBTREE {} 4294967295\n+    LITERAL \"expected identifier\" 4294967295\n+\"##,\n+    );\n+}\n+\n+#[test]\n+fn test_derive_proc_macro_list() {\n+    let res = list(\"serde_derive\", \"1.0.104\").join(\"\\n\");\n+\n+    assert_eq_text!(\n+        &res,\n+        r#\"Serialize [CustomDerive]\n+Deserialize [CustomDerive]\"#\n+    );\n+}"}, {"sha": "1ee409449222a2f59d0497c8e04b5307c4ec162b", "filename": "crates/ra_proc_macro_srv/src/tests/utils.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0ecdba20df41a800222d0fd864843843feb6e875/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecdba20df41a800222d0fd864843843feb6e875/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=0ecdba20df41a800222d0fd864843843feb6e875", "patch": "@@ -0,0 +1,65 @@\n+//! utils used in proc-macro tests\n+\n+use crate::dylib;\n+use crate::list_macros;\n+pub use difference::Changeset as __Changeset;\n+use ra_proc_macro::ListMacrosTask;\n+use std::str::FromStr;\n+use test_utils::assert_eq_text;\n+\n+mod fixtures {\n+    use cargo_metadata::{parse_messages, Message};\n+    use std::process::Command;\n+\n+    // Use current project metadata to get the proc-macro dylib path\n+    pub fn dylib_path(crate_name: &str, version: &str) -> std::path::PathBuf {\n+        let command = Command::new(\"cargo\")\n+            .args(&[\"check\", \"--message-format\", \"json\"])\n+            .output()\n+            .unwrap()\n+            .stdout;\n+\n+        for message in parse_messages(command.as_slice()) {\n+            match message.unwrap() {\n+                Message::CompilerArtifact(artifact) => {\n+                    if artifact.target.kind.contains(&\"proc-macro\".to_string()) {\n+                        let repr = format!(\"{} {}\", crate_name, version);\n+                        if artifact.package_id.repr.starts_with(&repr) {\n+                            return artifact.filenames[0].clone();\n+                        }\n+                    }\n+                }\n+                _ => (), // Unknown message\n+            }\n+        }\n+\n+        panic!(\"No proc-macro dylib for {} found!\", crate_name);\n+    }\n+}\n+\n+fn parse_string(code: &str) -> Option<crate::rustc_server::TokenStream> {\n+    Some(crate::rustc_server::TokenStream::from_str(code).unwrap())\n+}\n+\n+pub fn assert_expand(\n+    crate_name: &str,\n+    macro_name: &str,\n+    version: &str,\n+    fixture: &str,\n+    expect: &str,\n+) {\n+    let path = fixtures::dylib_path(crate_name, version);\n+    let expander = dylib::Expander::new(&path).unwrap();\n+    let fixture = parse_string(fixture).unwrap();\n+\n+    let res = expander.expand(macro_name, &fixture.subtree, None).unwrap();\n+    assert_eq_text!(&format!(\"{:?}\", res), &expect.trim());\n+}\n+\n+pub fn list(crate_name: &str, version: &str) -> Vec<String> {\n+    let path = fixtures::dylib_path(crate_name, version);\n+    let task = ListMacrosTask { lib: path };\n+\n+    let res = list_macros(&task).unwrap();\n+    res.macros.into_iter().map(|(name, kind)| format!(\"{} [{:?}]\", name, kind)).collect()\n+}"}]}