{"sha": "6a562126497d3160c6131a125d0842bc4e3d61ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNTYyMTI2NDk3ZDMxNjBjNjEzMWExMjVkMDg0MmJjNGUzZDYxY2U=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-24T23:27:09Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-25T00:57:41Z"}, "message": "A bunch of code refactoring in method matching.", "tree": {"sha": "94c8e981af32fbf1bb8548da98ae53cecbbc0521", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94c8e981af32fbf1bb8548da98ae53cecbbc0521"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a562126497d3160c6131a125d0842bc4e3d61ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a562126497d3160c6131a125d0842bc4e3d61ce", "html_url": "https://github.com/rust-lang/rust/commit/6a562126497d3160c6131a125d0842bc4e3d61ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a562126497d3160c6131a125d0842bc4e3d61ce/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf62433f43d60304c991d27437529ee53980c2e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf62433f43d60304c991d27437529ee53980c2e3", "html_url": "https://github.com/rust-lang/rust/commit/cf62433f43d60304c991d27437529ee53980c2e3"}], "stats": {"total": 168, "additions": 80, "deletions": 88}, "files": [{"sha": "656c995c5ace3f4430905eff248b5b9e40b4e2f6", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 80, "deletions": 88, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/6a562126497d3160c6131a125d0842bc4e3d61ce/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a562126497d3160c6131a125d0842bc4e3d61ce/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=6a562126497d3160c6131a125d0842bc4e3d61ce", "patch": "@@ -135,74 +135,26 @@ struct lookup {\n           }\n         }\n \n-        loop {\n-            match ty::get(self.self_ty).struct {\n-              // First, see whether this is a bounded parameter.\n-              ty::ty_param(p) => {\n-                self.add_candidates_from_param(p.idx, p.def_id);\n-              }\n+        let matching_modes =\n+            [subtyping_mode, assignability_mode,\n+             immutable_reference_mode, mutable_reference_mode];\n \n-              ty::ty_trait(did, substs, _) => {\n-                self.add_candidates_from_trait(did, substs);\n-              }\n-              ty::ty_class(did, substs) => {\n-                self.add_candidates_from_class(did, substs);\n-              }\n-              ty::ty_self => {\n-                // Call is of the form \"self.foo()\" and appears in one\n-                // of a trait's provided methods.\n-                let self_def_id = self.fcx.self_impl_def_id.expect(\n-                    ~\"unexpected `none` for self_impl_def_id\");\n-\n-                let substs = {\n-                    self_r: none,\n-                    self_ty: none,\n-                    tps: ~[],\n-                };\n-\n-                self.add_candidates_from_trait(self_def_id, substs);\n-              }\n-              _ => ()\n-            }\n+        loop {\n+            self.add_candidates_from_type();\n \n             // if we found anything, stop now.  otherwise continue to\n             // loop for impls in scope.  Note: I don't love these\n             // semantics, but that's what we had so I am preserving\n             // it.\n             if self.candidates.len() > 0u { break; }\n \n-            // Look for inherent and extension methods, using subtyping.\n-            self.add_inherent_and_extension_candidates\n-                (optional_inherent_methods, subtyping_mode);\n-\n-            // if we found anything, stop before trying borrows\n-            if self.candidates.len() > 0u {\n-                debug!(\"(checking method) found at least one inherent \\\n-                        method; giving up looking now\");\n-                break;\n+            // Try each of the possible matching semantics in turn.\n+            for matching_modes.each |mode| {\n+                self.add_inherent_and_extension_candidates(\n+                    optional_inherent_methods, mode);\n+                // If we find anything, stop.\n+                if self.candidates.len() > 0u { break; }\n             }\n-\n-            // Again, look for inherent and extension methods, this time using\n-            // assignability.\n-            self.add_inherent_and_extension_candidates\n-                (optional_inherent_methods, assignability_mode);\n-\n-            // If we found anything, stop before trying auto-ref.\n-            if self.candidates.len() > 0u { break; }\n-\n-            // Now look for inherent and extension methods, this time using an\n-            // immutable reference.\n-            self.add_inherent_and_extension_candidates\n-                (optional_inherent_methods, immutable_reference_mode);\n-\n-            // if we found anything, stop before attempting mutable auto-ref.\n-            if self.candidates.len() > 0u { break; }\n-\n-            // Now look for inherent and extension methods, this time using a\n-            // mutable reference.\n-            self.add_inherent_and_extension_candidates\n-                (optional_inherent_methods, mutable_reference_mode);\n-\n             // if we found anything, stop before attempting auto-deref.\n             if self.candidates.len() > 0u {\n                 debug!(\"(checking method) found at least one inherent \\\n@@ -283,6 +235,37 @@ struct lookup {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n+    fn add_candidates_from_type() {\n+        match ty::get(self.self_ty).struct {\n+          // First, see whether this is a bounded parameter.\n+          ty::ty_param(p) => {\n+            self.add_candidates_from_param(p.idx, p.def_id);\n+          }\n+\n+          ty::ty_trait(did, substs, _) => {\n+            self.add_candidates_from_trait(did, substs);\n+          }\n+          ty::ty_class(did, substs) => {\n+            self.add_candidates_from_class(did, substs);\n+          }\n+          ty::ty_self => {\n+            // Call is of the form \"self.foo()\" and appears in one\n+            // of a trait's provided methods.\n+            let self_def_id = self.fcx.self_impl_def_id.expect(\n+                ~\"unexpected `none` for self_impl_def_id\");\n+\n+            let substs = {\n+                self_r: none,\n+                self_ty: none,\n+                tps: ~[],\n+            };\n+\n+            self.add_candidates_from_trait(self_def_id, substs);\n+          }\n+          _ => ()\n+        }\n+    }\n+\n     fn add_candidates_from_param(n: uint, did: ast::def_id) {\n         debug!(\"add_candidates_from_param\");\n \n@@ -420,6 +403,43 @@ struct lookup {\n         */\n     }\n \n+    fn check_type_match(impl_ty: ty::t,\n+                        mode: method_lookup_mode)\n+        -> result<(), ty::type_err> {\n+        // Depending on our argument, we find potential matches by\n+        // checking subtypability, type assignability, or reference\n+        // subtypability. Collect the matches.\n+        let matches;\n+        match mode {\n+          subtyping_mode => {\n+            matches = self.fcx.can_mk_subty(self.self_ty, impl_ty);\n+          }\n+          assignability_mode => {\n+            matches = self.fcx.can_mk_assignty(self.self_expr,\n+                                               self.borrow_lb,\n+                                               self.self_ty,\n+                                               impl_ty);\n+          }\n+          immutable_reference_mode => {\n+            let region = self.fcx.infcx.next_region_var(\n+                self.self_expr.span,\n+                self.self_expr.id);\n+            let tm = { ty: self.self_ty, mutbl: ast::m_imm };\n+            let ref_ty = ty::mk_rptr(self.tcx(), region, tm);\n+            matches = self.fcx.can_mk_subty(ref_ty, impl_ty);\n+          }\n+          mutable_reference_mode => {\n+            let region = self.fcx.infcx.next_region_var(\n+                self.self_expr.span,\n+                self.self_expr.id);\n+            let tm = { ty: self.self_ty, mutbl: ast::m_mutbl };\n+            let ref_ty = ty::mk_rptr(self.tcx(), region, tm);\n+            matches = self.fcx.can_mk_subty(ref_ty, impl_ty);\n+          }\n+        }\n+        matches\n+    }\n+\n     // Returns true if any were added and false otherwise.\n     fn add_candidates_from_impl(im: @resolve3::Impl, mode: method_lookup_mode)\n                              -> bool {\n@@ -440,35 +460,7 @@ struct lookup {\n                 self.tcx(), impl_substs.self_r,\n                 impl_ty, m.self_type);\n \n-            // Depending on our argument, we find potential matches by\n-            // checking subtypability, type assignability, or reference\n-            // subtypability. Collect the matches.\n-            let matches;\n-            match mode {\n-                subtyping_mode =>\n-                    matches = self.fcx.can_mk_subty(self.self_ty, impl_ty),\n-                assignability_mode =>\n-                    matches = self.fcx.can_mk_assignty(self.self_expr,\n-                                                       self.borrow_lb,\n-                                                       self.self_ty,\n-                                                       impl_ty),\n-                immutable_reference_mode => {\n-                    let region = self.fcx.infcx.next_region_var(\n-                        self.self_expr.span,\n-                        self.self_expr.id);\n-                    let tm = { ty: self.self_ty, mutbl: ast::m_imm };\n-                    let ref_ty = ty::mk_rptr(self.tcx(), region, tm);\n-                    matches = self.fcx.can_mk_subty(ref_ty, impl_ty);\n-                }\n-                mutable_reference_mode => {\n-                    let region = self.fcx.infcx.next_region_var(\n-                        self.self_expr.span,\n-                        self.self_expr.id);\n-                    let tm = { ty: self.self_ty, mutbl: ast::m_mutbl };\n-                    let ref_ty = ty::mk_rptr(self.tcx(), region, tm);\n-                    matches = self.fcx.can_mk_subty(ref_ty, impl_ty);\n-                }\n-            }\n+            let matches = self.check_type_match(impl_ty, mode);\n             debug!(\"matches = %?\", matches);\n             match matches {\n               result::err(_) => { /* keep looking */ }"}]}