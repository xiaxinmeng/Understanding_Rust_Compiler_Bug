{"sha": "6ef02eff89e3d2a29eab3346bff393821df6e033", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlZjAyZWZmODllM2QyYTI5ZWFiMzM0NmJmZjM5MzgyMWRmNmUwMzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-26T18:20:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-26T18:20:58Z"}, "message": "Auto merge of #30043 - arielb1:split-metadata, r=nikomatsakis\n\nThis improves bootstrap times because of better parallelism - though I need to measure how much - and allows metadata to be modified without triggering a full recompile. This also ensures that metadata handling and the rest of rustc remain decoupled, which is a first step for switching to a new metadata format.\n\nThis is a [breaking-change] to all plugin authors because of the following renames:\n * `rustc::plugin` is now `rustc_plugin`\n * `rustc::metadata` is now `rustc_metadata`\n * Most data types from `rustc::metadata`, along with `LOCAL_CRATE`, are now in `rustc::middle::cstore`.\n * The CStore methods were split between the `rustc::middle::CrateStore` trait (and trait object) and the `rustc_metadata::cstore::CStore`, with an `Rc<CrateStore>` stored in the `Session`. The inner `CStore` can be accessed via the inner `Any` bound, but this is deprecated.\n\nr? @nikomatsakis", "tree": {"sha": "076a4a0e092ef845b9b836b0853d97203a144271", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/076a4a0e092ef845b9b836b0853d97203a144271"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ef02eff89e3d2a29eab3346bff393821df6e033", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ef02eff89e3d2a29eab3346bff393821df6e033", "html_url": "https://github.com/rust-lang/rust/commit/6ef02eff89e3d2a29eab3346bff393821df6e033", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ef02eff89e3d2a29eab3346bff393821df6e033/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f3becb18ad01707584035a590746e35bd64d8e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f3becb18ad01707584035a590746e35bd64d8e8", "html_url": "https://github.com/rust-lang/rust/commit/6f3becb18ad01707584035a590746e35bd64d8e8"}, {"sha": "43a6deb95f06709a1a1b333ff040373037f6c7e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/43a6deb95f06709a1a1b333ff040373037f6c7e5", "html_url": "https://github.com/rust-lang/rust/commit/43a6deb95f06709a1a1b333ff040373037f6c7e5"}], "stats": {"total": 3004, "additions": 1760, "deletions": 1244}, "files": [{"sha": "8ce0a41d9786c01c3eee35a481c71cc2b0574118", "filename": "mk/crates.mk", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -56,7 +56,8 @@ TARGET_CRATES := libc std flate arena term \\\n \t\t alloc_system\n RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n-                rustc_data_structures rustc_front rustc_platform_intrinsics\n+                rustc_data_structures rustc_front rustc_platform_intrinsics \\\n+                rustc_plugin rustc_metadata\n HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc fmt_macros\n TOOLS := compiletest rustdoc rustc rustbook error-index-generator\n \n@@ -87,21 +88,23 @@ DEPS_test := std getopts serialize rbml term native:rust_test_helpers\n \n DEPS_syntax := std term serialize log fmt_macros arena libc rustc_bitflags\n \n-DEPS_rustc := syntax flate arena serialize getopts rbml rustc_front\\\n+DEPS_rustc := syntax flate arena serialize getopts rustc_front\\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\n DEPS_rustc_back := std syntax rustc_llvm rustc_front flate log libc\n DEPS_rustc_borrowck := rustc rustc_front log graphviz syntax\n DEPS_rustc_data_structures := std log serialize\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n                      rustc_typeck rustc_mir rustc_resolve log syntax serialize rustc_llvm \\\n-\t\t             rustc_trans rustc_privacy rustc_lint rustc_front\n-\n+\t             rustc_trans rustc_privacy rustc_lint rustc_front rustc_plugin \\\n+                     rustc_metadata\n DEPS_rustc_front := std syntax log serialize\n DEPS_rustc_lint := rustc log syntax\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n+DEPS_rustc_metadata := rustc rustc_front syntax rbml\n DEPS_rustc_mir := rustc rustc_front syntax\n DEPS_rustc_resolve := rustc rustc_front log syntax\n DEPS_rustc_platform_intrinsics := rustc rustc_llvm\n+DEPS_rustc_plugin := rustc rustc_metadata syntax\n DEPS_rustc_privacy := rustc rustc_front log syntax\n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back rustc_mir \\\n                     log syntax serialize rustc_llvm rustc_front rustc_platform_intrinsics"}, {"sha": "800be13a243fb9e09b17e2e6655e98ee0f80978b", "filename": "src/doc/book/compiler-plugins.md", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Fdoc%2Fbook%2Fcompiler-plugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Fdoc%2Fbook%2Fcompiler-plugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcompiler-plugins.md?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -8,12 +8,12 @@ extend the compiler's behavior with new syntax extensions, lint checks, etc.\n A plugin is a dynamic library crate with a designated *registrar* function that\n registers extensions with `rustc`. Other crates can load these extensions using\n the crate attribute `#![plugin(...)]`.  See the\n-[`rustc::plugin`](../rustc/plugin/index.html) documentation for more about the\n+[`rustc_plugin`](../rustc_plugin/index.html) documentation for more about the\n mechanics of defining and loading a plugin.\n \n If present, arguments passed as `#![plugin(foo(... args ...))]` are not\n interpreted by rustc itself.  They are provided to the plugin through the\n-`Registry`'s [`args` method](../rustc/plugin/registry/struct.Registry.html#method.args).\n+`Registry`'s [`args` method](../rustc_plugin/registry/struct.Registry.html#method.args).\n \n In the vast majority of cases, a plugin should *only* be used through\n `#![plugin]` and not through an `extern crate` item.  Linking a plugin would\n@@ -43,13 +43,14 @@ that implements Roman numeral integer literals.\n \n extern crate syntax;\n extern crate rustc;\n+extern crate rustc_plugin;\n \n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::ast::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n use syntax::ext::build::AstBuilder;  // trait for expr_usize\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         -> Box<MacResult + 'static> {\n@@ -120,7 +121,7 @@ The advantages over a simple `fn(&str) -> u32` are:\n In addition to procedural macros, you can define new\n [`derive`](../reference.html#derive)-like attributes and other kinds of\n extensions.  See\n-[`Registry::register_syntax_extension`](../rustc/plugin/registry/struct.Registry.html#method.register_syntax_extension)\n+[`Registry::register_syntax_extension`](../rustc_plugin/registry/struct.Registry.html#method.register_syntax_extension)\n and the [`SyntaxExtension`\n enum](https://doc.rust-lang.org/syntax/ext/base/enum.SyntaxExtension.html).  For\n a more involved macro example, see\n@@ -189,10 +190,11 @@ extern crate syntax;\n // Load rustc as a plugin to get macros\n #[macro_use]\n extern crate rustc;\n+extern crate rustc_plugin;\n \n use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass,\n                   EarlyLintPassObject, LintArray};\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n use syntax::ast;\n \n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");"}, {"sha": "55abebf496dcaeaa6710f82db71507633451e05e", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -158,7 +158,7 @@ can be combined to control the exact logging you want to see. For example, when\n debugging linking in the compiler, you might set the following:\n \n ```sh\n-RUST_LOG=rustc::metadata::creader,rustc::util::filesearch,rustc::back::rpath\n+RUST_LOG=rustc_metadata::creader,rustc::util::filesearch,rustc::back::rpath\n ```\n \n For a full description, see [the logging crate][1]."}, {"sha": "f04830ee969bd9115e688c84ee5197dd26b43958", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -25,7 +25,9 @@ use std::path::Path;\n use syntax::parse;\n use syntax::parse::lexer;\n use rustc::session::{self, config};\n+use rustc::middle::cstore::DummyCrateStore;\n \n+use std::rc::Rc;\n use syntax::ast;\n use syntax::ast::Name;\n use syntax::codemap;\n@@ -286,7 +288,8 @@ fn main() {\n \n     let options = config::basic_options();\n     let session = session::build_session(options, None,\n-                                         syntax::diagnostics::registry::Registry::new(&[]));\n+                                         syntax::diagnostics::registry::Registry::new(&[]),\n+                                         Rc::new(DummyCrateStore));\n     let filemap = session.parse_sess.codemap().new_filemap(String::from(\"<n/a>\"), code);\n     let mut lexer = lexer::StringReader::new(session.diagnostic(), filemap);\n     let cm = session.codemap();"}, {"sha": "b4e188c498d7409e0d98d027b0481260b5ff4acd", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -1899,51 +1899,6 @@ contain references (with a maximum lifetime of `'a`).\n [1]: https://github.com/rust-lang/rfcs/pull/1156\n \"##,\n \n-E0454: r##\"\n-A link name was given with an empty name. Erroneous code example:\n-\n-```\n-#[link(name = \"\")] extern {} // error: #[link(name = \"\")] given with empty name\n-```\n-\n-The rust compiler cannot link to an external library if you don't give it its\n-name. Example:\n-\n-```\n-#[link(name = \"some_lib\")] extern {} // ok!\n-```\n-\"##,\n-\n-E0458: r##\"\n-An unknown \"kind\" was specified for a link attribute. Erroneous code example:\n-\n-```\n-#[link(kind = \"wonderful_unicorn\")] extern {}\n-// error: unknown kind: `wonderful_unicorn`\n-```\n-\n-Please specify a valid \"kind\" value, from one of the following:\n- * static\n- * dylib\n- * framework\n-\"##,\n-\n-E0459: r##\"\n-A link was used without a name parameter. Erroneous code example:\n-\n-```\n-#[link(kind = \"dylib\")] extern {}\n-// error: #[link(...)] specified without `name = \"foo\"`\n-```\n-\n-Please add the name parameter to allow the rust compiler to find the library\n-you want. Example:\n-\n-```\n-#[link(kind = \"dylib\", name = \"some_lib\")] extern {} // ok!\n-```\n-\"##,\n-\n E0493: r##\"\n A type with a destructor was assigned to an invalid type of variable. Erroneous\n code example:\n@@ -2144,20 +2099,6 @@ register_diagnostics! {\n     E0400, // overloaded derefs are not allowed in constants\n     E0452, // malformed lint attribute\n     E0453, // overruled by outer forbid\n-    E0455, // native frameworks are only available on OSX targets\n-    E0456, // plugin `..` is not available for triple `..`\n-    E0457, // plugin `..` only found in rlib format, but must be available...\n-    E0460, // found possibly newer version of crate `..`\n-    E0461, // couldn't find crate `..` with expected target triple ..\n-    E0462, // found staticlib `..` instead of rlib or dylib\n-    E0463, // can't find crate for `..`\n-    E0464, // multiple matching crates for `..`\n-    E0465, // multiple .. candidates for `..` found\n-    E0466, // bad macro import\n-    E0467, // bad macro reexport\n-    E0468, // an `extern crate` loading macros must be at the crate root\n-    E0469, // imported macro not found\n-    E0470, // reexported macro not found\n     E0471, // constant evaluation error: ..\n     E0472, // asm! is unsupported on this target\n     E0473, // dereference of reference outside its lifetime\n@@ -2181,6 +2122,4 @@ register_diagnostics! {\n     E0491, // in type `..`, reference has a longer lifetime than the data it...\n     E0492, // cannot borrow a constant which contains interior mutability\n     E0495, // cannot infer an appropriate lifetime due to conflicting requirements\n-    E0498, // malformed plugin attribute\n-    E0514, // metadata version mismatch\n }"}, {"sha": "0f0d59e70b0b8985c42c34d1be294b36f5c8fd93", "filename": "src/librustc/front/map/definitions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Ffront%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Ffront%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fdefinitions.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use metadata::cstore::LOCAL_CRATE;\n+use middle::cstore::LOCAL_CRATE;\n use middle::def_id::{DefId, DefIndex};\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_front::hir;"}, {"sha": "8c3da2cddd5610391a8497dc8d5152ec42903884", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -14,8 +14,8 @@ use self::MapEntry::*;\n use self::collector::NodeCollector;\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData, DisambiguatedDefPathData};\n \n-use metadata::inline::InlinedItem;\n-use metadata::inline::InlinedItem as II;\n+use middle::cstore::InlinedItem;\n+use middle::cstore::InlinedItem as II;\n use middle::def_id::DefId;\n \n use syntax::abi;"}, {"sha": "6da4f174e3e0942f44fd0b6357d4e67faf2f311c", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -33,7 +33,6 @@\n #![feature(const_fn)]\n #![feature(core)]\n #![feature(duration_span)]\n-#![feature(dynamic_lib)]\n #![feature(enumset)]\n #![feature(hashmap_hasher)]\n #![feature(into_cow)]\n@@ -68,7 +67,6 @@ extern crate rustc_back;\n extern crate rustc_front;\n extern crate rustc_data_structures;\n extern crate serialize;\n-extern crate rbml;\n extern crate collections;\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n@@ -100,9 +98,8 @@ pub mod front {\n }\n \n pub mod middle {\n-    pub mod expr_use_visitor; // STAGE0: increase glitch immunity\n     pub mod astconv_util;\n-    pub mod astencode;\n+    pub mod expr_use_visitor; // STAGE0: increase glitch immunity\n     pub mod cfg;\n     pub mod check_const;\n     pub mod check_static_recursion;\n@@ -111,6 +108,7 @@ pub mod middle {\n     pub mod check_no_asm;\n     pub mod check_rvalues;\n     pub mod const_eval;\n+    pub mod cstore;\n     pub mod dataflow;\n     pub mod dead;\n     pub mod def;\n@@ -138,12 +136,8 @@ pub mod middle {\n     pub mod weak_lang_items;\n }\n \n-pub mod metadata;\n-\n pub mod session;\n \n-pub mod plugin;\n-\n pub mod lint;\n \n pub mod util {"}, {"sha": "09dec375a69a54ef639cf9e666d48cad7ca7abb5", "filename": "src/librustc/metadata/csearch.rs", "status": "removed", "additions": 0, "deletions": 409, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/6f3becb18ad01707584035a590746e35bd64d8e8/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f3becb18ad01707584035a590746e35bd64d8e8/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=6f3becb18ad01707584035a590746e35bd64d8e8", "patch": "@@ -1,409 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Searching for information from the cstore\n-\n-use front::map as ast_map;\n-use metadata::cstore;\n-use metadata::decoder;\n-use metadata::inline::InlinedItem;\n-use middle::def_id::{DefId, DefIndex};\n-use middle::lang_items;\n-use middle::ty;\n-use util::nodemap::FnvHashMap;\n-\n-use std::rc::Rc;\n-use syntax::ast;\n-use syntax::attr;\n-use rustc_front::hir;\n-\n-#[derive(Copy, Clone)]\n-pub struct MethodInfo {\n-    pub name: ast::Name,\n-    pub def_id: DefId,\n-    pub vis: hir::Visibility,\n-}\n-\n-pub fn get_symbol(cstore: &cstore::CStore, def: DefId) -> String {\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_symbol(&cdata, def.index)\n-}\n-\n-/// Iterates over all the language items in the given crate.\n-pub fn each_lang_item<F>(cstore: &cstore::CStore,\n-                         cnum: ast::CrateNum,\n-                         f: F)\n-                         -> bool where\n-    F: FnMut(DefIndex, usize) -> bool,\n-{\n-    let crate_data = cstore.get_crate_data(cnum);\n-    decoder::each_lang_item(&*crate_data, f)\n-}\n-\n-/// Iterates over each child of the given item.\n-pub fn each_child_of_item<F>(cstore: &cstore::CStore,\n-                             def_id: DefId,\n-                             callback: F) where\n-    F: FnMut(decoder::DefLike, ast::Name, hir::Visibility),\n-{\n-    let crate_data = cstore.get_crate_data(def_id.krate);\n-    let get_crate_data = |cnum| {\n-        cstore.get_crate_data(cnum)\n-    };\n-    decoder::each_child_of_item(cstore.intr.clone(),\n-                                &*crate_data,\n-                                def_id.index,\n-                                get_crate_data,\n-                                callback)\n-}\n-\n-/// Iterates over each top-level crate item.\n-pub fn each_top_level_item_of_crate<F>(cstore: &cstore::CStore,\n-                                       cnum: ast::CrateNum,\n-                                       callback: F) where\n-    F: FnMut(decoder::DefLike, ast::Name, hir::Visibility),\n-{\n-    let crate_data = cstore.get_crate_data(cnum);\n-    let get_crate_data = |cnum| {\n-        cstore.get_crate_data(cnum)\n-    };\n-    decoder::each_top_level_item_of_crate(cstore.intr.clone(),\n-                                          &*crate_data,\n-                                          get_crate_data,\n-                                          callback)\n-}\n-\n-pub fn get_item_path(tcx: &ty::ctxt, def: DefId) -> Vec<ast_map::PathElem> {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    let path = decoder::get_item_path(&*cdata, def.index);\n-\n-    cdata.with_local_path(|cpath| {\n-        let mut r = Vec::with_capacity(cpath.len() + path.len());\n-        r.push_all(cpath);\n-        r.push_all(&path);\n-        r\n-    })\n-}\n-\n-pub fn get_item_name(tcx: &ty::ctxt, def: DefId) -> ast::Name {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_item_name(&cstore.intr, &cdata, def.index)\n-}\n-\n-pub enum FoundAst<'ast> {\n-    Found(&'ast InlinedItem),\n-    FoundParent(DefId, &'ast InlinedItem),\n-    NotFound,\n-}\n-\n-// Finds the AST for this item in the crate metadata, if any.  If the item was\n-// not marked for inlining, then the AST will not be present and hence none\n-// will be returned.\n-pub fn maybe_get_item_ast<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId,\n-                                decode_inlined_item: decoder::DecodeInlinedItem)\n-                                -> FoundAst<'tcx> {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::maybe_get_item_ast(&*cdata, tcx, def.index, decode_inlined_item)\n-}\n-\n-/// Returns information about the given implementation.\n-pub fn get_impl_items(cstore: &cstore::CStore, impl_def_id: DefId)\n-                      -> Vec<ty::ImplOrTraitItemId> {\n-    let cdata = cstore.get_crate_data(impl_def_id.krate);\n-    decoder::get_impl_items(&*cdata, impl_def_id.index)\n-}\n-\n-pub fn get_impl_or_trait_item<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n-                                    -> ty::ImplOrTraitItem<'tcx> {\n-    let cdata = tcx.sess.cstore.get_crate_data(def.krate);\n-    decoder::get_impl_or_trait_item(tcx.sess.cstore.intr.clone(),\n-                                    &*cdata,\n-                                    def.index,\n-                                    tcx)\n-}\n-\n-pub fn get_trait_name(cstore: &cstore::CStore, def: DefId) -> ast::Name {\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_trait_name(cstore.intr.clone(),\n-                            &*cdata,\n-                            def.index)\n-}\n-\n-pub fn is_static_method(cstore: &cstore::CStore, def: DefId) -> bool {\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::is_static_method(&*cdata, def.index)\n-}\n-\n-pub fn get_trait_item_def_ids(cstore: &cstore::CStore, def: DefId)\n-                              -> Vec<ty::ImplOrTraitItemId> {\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_trait_item_def_ids(&*cdata, def.index)\n-}\n-\n-pub fn get_item_variances(cstore: &cstore::CStore,\n-                          def: DefId) -> ty::ItemVariances {\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_item_variances(&*cdata, def.index)\n-}\n-\n-pub fn get_provided_trait_methods<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                        def: DefId)\n-                                        -> Vec<Rc<ty::Method<'tcx>>> {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.index, tcx)\n-}\n-\n-pub fn get_associated_consts<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n-                                   -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_associated_consts(cstore.intr.clone(), &*cdata, def.index, tcx)\n-}\n-\n-pub fn get_methods_if_impl(cstore: &cstore::CStore,\n-                                  def: DefId)\n-                               -> Option<Vec<MethodInfo> > {\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_methods_if_impl(cstore.intr.clone(), &*cdata, def.index)\n-}\n-\n-pub fn get_item_attrs(cstore: &cstore::CStore,\n-                      def_id: DefId)\n-                      -> Vec<ast::Attribute> {\n-    let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_item_attrs(&*cdata, def_id.index)\n-}\n-\n-pub fn get_struct_field_names(cstore: &cstore::CStore, def: DefId) -> Vec<ast::Name> {\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_struct_field_names(&cstore.intr, &*cdata, def.index)\n-}\n-\n-pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: DefId)\n-                              -> FnvHashMap<DefId, Vec<ast::Attribute>> {\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_struct_field_attrs(&*cdata)\n-}\n-\n-pub fn get_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                      def: DefId)\n-                      -> ty::TypeScheme<'tcx> {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_type(&*cdata, def.index, tcx)\n-}\n-\n-pub fn get_trait_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::TraitDef<'tcx> {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_trait_def(&*cdata, def.index, tcx)\n-}\n-\n-pub fn get_adt_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx> {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_adt_def(&cstore.intr, &*cdata, def.index, tcx)\n-}\n-\n-pub fn get_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n-                            -> ty::GenericPredicates<'tcx>\n-{\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_predicates(&*cdata, def.index, tcx)\n-}\n-\n-pub fn get_super_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n-                                  -> ty::GenericPredicates<'tcx>\n-{\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_super_predicates(&*cdata, def.index, tcx)\n-}\n-\n-pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                               def: DefId)\n-                               -> Option<hir::ImplPolarity>\n-{\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_impl_polarity(&*cdata, def.index)\n-}\n-\n-pub fn get_custom_coerce_unsized_kind<'tcx>(\n-    tcx: &ty::ctxt<'tcx>,\n-    def: DefId)\n-    -> Option<ty::adjustment::CustomCoerceUnsized>\n-{\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_custom_coerce_unsized_kind(&*cdata, def.index)\n-}\n-\n-// Given a def_id for an impl, return the trait it implements,\n-// if there is one.\n-pub fn get_impl_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                            def: DefId)\n-                            -> Option<ty::TraitRef<'tcx>> {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_impl_trait(&*cdata, def.index, tcx)\n-}\n-\n-pub fn get_native_libraries(cstore: &cstore::CStore, crate_num: ast::CrateNum)\n-                            -> Vec<(cstore::NativeLibraryKind, String)> {\n-    let cdata = cstore.get_crate_data(crate_num);\n-    decoder::get_native_libraries(&*cdata)\n-}\n-\n-pub fn each_inherent_implementation_for_type<F>(cstore: &cstore::CStore,\n-                                                def_id: DefId,\n-                                                callback: F) where\n-    F: FnMut(DefId),\n-{\n-    let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::each_inherent_implementation_for_type(&*cdata, def_id.index, callback)\n-}\n-\n-pub fn each_implementation_for_trait<F>(cstore: &cstore::CStore,\n-                                        def_id: DefId,\n-                                        mut callback: F) where\n-    F: FnMut(DefId),\n-{\n-    cstore.iter_crate_data(|_, cdata| {\n-        decoder::each_implementation_for_trait(cdata, def_id, &mut callback)\n-    })\n-}\n-\n-/// If the given def ID describes an item belonging to a trait (either a\n-/// default method or an implementation of a trait method), returns the ID of\n-/// the trait that the method belongs to. Otherwise, returns `None`.\n-pub fn get_trait_of_item(cstore: &cstore::CStore,\n-                         def_id: DefId,\n-                         tcx: &ty::ctxt)\n-                         -> Option<DefId> {\n-    let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_trait_of_item(&*cdata, def_id.index, tcx)\n-}\n-\n-pub fn get_tuple_struct_definition_if_ctor(cstore: &cstore::CStore,\n-                                           def_id: DefId)\n-    -> Option<DefId>\n-{\n-    let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_tuple_struct_definition_if_ctor(&*cdata, def_id.index)\n-}\n-\n-pub fn get_dylib_dependency_formats(cstore: &cstore::CStore,\n-                                    cnum: ast::CrateNum)\n-    -> Vec<(ast::CrateNum, cstore::LinkagePreference)>\n-{\n-    let cdata = cstore.get_crate_data(cnum);\n-    decoder::get_dylib_dependency_formats(&*cdata)\n-}\n-\n-pub fn get_missing_lang_items(cstore: &cstore::CStore, cnum: ast::CrateNum)\n-    -> Vec<lang_items::LangItem>\n-{\n-    let cdata = cstore.get_crate_data(cnum);\n-    decoder::get_missing_lang_items(&*cdata)\n-}\n-\n-pub fn get_method_arg_names(cstore: &cstore::CStore, did: DefId)\n-    -> Vec<String>\n-{\n-    let cdata = cstore.get_crate_data(did.krate);\n-    decoder::get_method_arg_names(&*cdata, did.index)\n-}\n-\n-pub fn get_reachable_ids(cstore: &cstore::CStore, cnum: ast::CrateNum)\n-    -> Vec<DefId>\n-{\n-    let cdata = cstore.get_crate_data(cnum);\n-    decoder::get_reachable_ids(&*cdata)\n-}\n-\n-pub fn is_typedef(cstore: &cstore::CStore, did: DefId) -> bool {\n-    let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_typedef(&*cdata, did.index)\n-}\n-\n-pub fn is_const_fn(cstore: &cstore::CStore, did: DefId) -> bool {\n-    let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_const_fn(&*cdata, did.index)\n-}\n-\n-pub fn is_static(cstore: &cstore::CStore, did: DefId) -> bool {\n-    let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_static(&*cdata, did.index)\n-}\n-\n-pub fn is_impl(cstore: &cstore::CStore, did: DefId) -> bool {\n-    let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_impl(&*cdata, did.index)\n-}\n-\n-pub fn get_stability(cstore: &cstore::CStore,\n-                     def: DefId)\n-                     -> Option<attr::Stability> {\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_stability(&*cdata, def.index)\n-}\n-\n-pub fn is_staged_api(cstore: &cstore::CStore, krate: ast::CrateNum) -> bool {\n-    cstore.get_crate_data(krate).staged_api\n-}\n-\n-pub fn get_repr_attrs(cstore: &cstore::CStore, def: DefId)\n-                      -> Vec<attr::ReprAttr> {\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_repr_attrs(&*cdata, def.index)\n-}\n-\n-pub fn is_defaulted_trait(cstore: &cstore::CStore, trait_def_id: DefId) -> bool {\n-    let cdata = cstore.get_crate_data(trait_def_id.krate);\n-    decoder::is_defaulted_trait(&*cdata, trait_def_id.index)\n-}\n-\n-pub fn is_default_impl(cstore: &cstore::CStore, impl_did: DefId) -> bool {\n-    let cdata = cstore.get_crate_data(impl_did.krate);\n-    decoder::is_default_impl(&*cdata, impl_did.index)\n-}\n-\n-pub fn is_extern_fn(cstore: &cstore::CStore, did: DefId,\n-                    tcx: &ty::ctxt) -> bool {\n-    let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_extern_fn(&*cdata, did.index, tcx)\n-}\n-\n-pub fn closure_kind<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: DefId) -> ty::ClosureKind {\n-    assert!(!def_id.is_local());\n-    let cdata = tcx.sess.cstore.get_crate_data(def_id.krate);\n-    decoder::closure_kind(&*cdata, def_id.index)\n-}\n-\n-pub fn closure_ty<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx> {\n-    assert!(!def_id.is_local());\n-    let cdata = tcx.sess.cstore.get_crate_data(def_id.krate);\n-    decoder::closure_ty(&*cdata, def_id.index, tcx)\n-}\n-\n-pub fn def_path(tcx: &ty::ctxt, def: DefId) -> ast_map::DefPath {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    let path = decoder::def_path(&*cdata, def.index);\n-    let local_path = cdata.local_def_path();\n-    local_path.into_iter().chain(path).collect()\n-}\n-"}, {"sha": "e621a4166d719ae0d6385d46b97eac09d253505d", "filename": "src/librustc/metadata/inline.rs", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6f3becb18ad01707584035a590746e35bd64d8e8/src%2Flibrustc%2Fmetadata%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f3becb18ad01707584035a590746e35bd64d8e8/src%2Flibrustc%2Fmetadata%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Finline.rs?ref=6f3becb18ad01707584035a590746e35bd64d8e8", "patch": "@@ -1,60 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use middle::def_id::DefId;\n-use rustc_front::hir;\n-use rustc_front::util::IdVisitor;\n-use syntax::ast_util::{IdRange, IdRangeComputingVisitor, IdVisitingOperation};\n-use syntax::ptr::P;\n-use rustc_front::intravisit::Visitor;\n-use self::InlinedItem::*;\n-\n-/// The data we save and restore about an inlined item or method.  This is not\n-/// part of the AST that we parse from a file, but it becomes part of the tree\n-/// that we trans.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum InlinedItem {\n-    Item(P<hir::Item>),\n-    TraitItem(DefId /* impl id */, P<hir::TraitItem>),\n-    ImplItem(DefId /* impl id */, P<hir::ImplItem>),\n-    Foreign(P<hir::ForeignItem>),\n-}\n-\n-/// A borrowed version of `hir::InlinedItem`.\n-pub enum InlinedItemRef<'a> {\n-    Item(&'a hir::Item),\n-    TraitItem(DefId, &'a hir::TraitItem),\n-    ImplItem(DefId, &'a hir::ImplItem),\n-    Foreign(&'a hir::ForeignItem)\n-}\n-\n-impl InlinedItem {\n-    pub fn visit<'ast,V>(&'ast self, visitor: &mut V)\n-        where V: Visitor<'ast>\n-    {\n-        match *self {\n-            Item(ref i) => visitor.visit_item(&**i),\n-            Foreign(ref i) => visitor.visit_foreign_item(&**i),\n-            TraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n-            ImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n-        }\n-    }\n-\n-    pub fn visit_ids<O: IdVisitingOperation>(&self, operation: &mut O) {\n-        let mut id_visitor = IdVisitor::new(operation);\n-        self.visit(&mut id_visitor);\n-    }\n-\n-    pub fn compute_id_range(&self) -> IdRange {\n-        let mut visitor = IdRangeComputingVisitor::new();\n-        self.visit_ids(&mut visitor);\n-        visitor.result()\n-    }\n-}"}, {"sha": "21ece8f381ebfb60a0d25e074c3f5891357af30c", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -16,9 +16,8 @@ use self::EvalHint::*;\n \n use front::map as ast_map;\n use front::map::blocks::FnLikeNode;\n-use metadata::csearch;\n-use metadata::inline::InlinedItem;\n-use middle::{astencode, def, infer, subst, traits};\n+use middle::cstore::{self, CrateStore, InlinedItem};\n+use middle::{def, infer, subst, traits};\n use middle::def_id::DefId;\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n@@ -145,13 +144,12 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n             None => {}\n         }\n         let mut used_ref_id = false;\n-        let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n-            Box::new(astencode::decode_inlined_item)) {\n-            csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n+        let expr_id = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n+            cstore::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n                 hir::ItemConst(_, ref const_expr) => Some(const_expr.id),\n                 _ => None\n             },\n-            csearch::FoundAst::Found(&InlinedItem::TraitItem(trait_id, ref ti)) => match ti.node {\n+            cstore::FoundAst::Found(&InlinedItem::TraitItem(trait_id, ref ti)) => match ti.node {\n                 hir::ConstTraitItem(_, _) => {\n                     used_ref_id = true;\n                     match maybe_ref_id {\n@@ -170,7 +168,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                 }\n                 _ => None\n             },\n-            csearch::FoundAst::Found(&InlinedItem::ImplItem(_, ref ii)) => match ii.node {\n+            cstore::FoundAst::Found(&InlinedItem::ImplItem(_, ref ii)) => match ii.node {\n                 hir::ImplItemKind::Const(_, ref expr) => Some(expr.id),\n                 _ => None\n             },\n@@ -196,15 +194,14 @@ fn inline_const_fn_from_external_crate(tcx: &ty::ctxt, def_id: DefId)\n         None => {}\n     }\n \n-    if !csearch::is_const_fn(&tcx.sess.cstore, def_id) {\n+    if !tcx.sess.cstore.is_const_fn(def_id) {\n         tcx.extern_const_fns.borrow_mut().insert(def_id, ast::DUMMY_NODE_ID);\n         return None;\n     }\n \n-    let fn_id = match csearch::maybe_get_item_ast(tcx, def_id,\n-        box astencode::decode_inlined_item) {\n-        csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => Some(item.id),\n-        csearch::FoundAst::Found(&InlinedItem::ImplItem(_, ref item)) => Some(item.id),\n+    let fn_id = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n+        cstore::FoundAst::Found(&InlinedItem::Item(ref item)) => Some(item.id),\n+        cstore::FoundAst::Found(&InlinedItem::ImplItem(_, ref item)) => Some(item.id),\n         _ => None\n     };\n     tcx.extern_const_fns.borrow_mut().insert(def_id,"}, {"sha": "81375bd3a5a14bfed03c2bfccccc460224f1c966", "filename": "src/librustc/middle/cstore.rs", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -0,0 +1,407 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// the rustc crate store interface. This also includes types that\n+// are *mostly* used as a part of that interface, but these should\n+// probably get a better home if someone can find one.\n+\n+use back::svh::Svh;\n+use front::map as hir_map;\n+use middle::def;\n+use middle::lang_items;\n+use middle::ty::{self, Ty};\n+use middle::def_id::{DefId, DefIndex};\n+use session::Session;\n+use session::search_paths::PathKind;\n+use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n+use std::any::Any;\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+use std::path::PathBuf;\n+use syntax::ast;\n+use syntax::ast_util::{IdVisitingOperation};\n+use syntax::attr;\n+use syntax::codemap::Span;\n+use syntax::ptr::P;\n+use rustc_back::target::Target;\n+use rustc_front::hir;\n+use rustc_front::intravisit::Visitor;\n+use rustc_front::util::IdVisitor;\n+\n+pub use self::DefLike::{DlDef, DlField, DlImpl};\n+pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};\n+\n+// lonely orphan structs and enums looking for a better home\n+\n+#[derive(Clone, Debug)]\n+pub struct LinkMeta {\n+    pub crate_name: String,\n+    pub crate_hash: Svh,\n+}\n+\n+// Where a crate came from on the local filesystem. One of these two options\n+// must be non-None.\n+#[derive(PartialEq, Clone, Debug)]\n+pub struct CrateSource {\n+    pub dylib: Option<(PathBuf, PathKind)>,\n+    pub rlib: Option<(PathBuf, PathKind)>,\n+    pub cnum: ast::CrateNum,\n+}\n+\n+#[derive(Copy, Debug, PartialEq, Clone)]\n+pub enum LinkagePreference {\n+    RequireDynamic,\n+    RequireStatic,\n+}\n+\n+enum_from_u32! {\n+    #[derive(Copy, Clone, PartialEq)]\n+    pub enum NativeLibraryKind {\n+        NativeStatic,    // native static library (.a archive)\n+        NativeFramework, // OSX-specific\n+        NativeUnknown,   // default way to specify a dynamic library\n+    }\n+}\n+\n+// Something that a name can resolve to.\n+#[derive(Copy, Clone, Debug)]\n+pub enum DefLike {\n+    DlDef(def::Def),\n+    DlImpl(DefId),\n+    DlField\n+}\n+\n+/// The data we save and restore about an inlined item or method.  This is not\n+/// part of the AST that we parse from a file, but it becomes part of the tree\n+/// that we trans.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum InlinedItem {\n+    Item(P<hir::Item>),\n+    TraitItem(DefId /* impl id */, P<hir::TraitItem>),\n+    ImplItem(DefId /* impl id */, P<hir::ImplItem>),\n+    Foreign(P<hir::ForeignItem>),\n+}\n+\n+/// A borrowed version of `hir::InlinedItem`.\n+pub enum InlinedItemRef<'a> {\n+    Item(&'a hir::Item),\n+    TraitItem(DefId, &'a hir::TraitItem),\n+    ImplItem(DefId, &'a hir::ImplItem),\n+    Foreign(&'a hir::ForeignItem)\n+}\n+\n+/// Item definitions in the currently-compiled crate would have the CrateNum\n+/// LOCAL_CRATE in their DefId.\n+pub const LOCAL_CRATE: ast::CrateNum = 0;\n+\n+pub struct ChildItem {\n+    pub def: DefLike,\n+    pub name: ast::Name,\n+    pub vis: hir::Visibility\n+}\n+\n+pub enum FoundAst<'ast> {\n+    Found(&'ast InlinedItem),\n+    FoundParent(DefId, &'ast InlinedItem),\n+    NotFound,\n+}\n+\n+/// A store of Rust crates, through with their metadata\n+/// can be accessed.\n+///\n+/// The `: Any` bound is a temporary measure that allows access\n+/// to the backing `rustc_metadata::cstore::CStore` object. It\n+/// will be removed in the near future - if you need to access\n+/// internal APIs, please tell us.\n+pub trait CrateStore<'tcx> : Any {\n+    // item info\n+    fn stability(&self, def: DefId) -> Option<attr::Stability>;\n+    fn closure_kind(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)\n+                    -> ty::ClosureKind;\n+    fn closure_ty(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)\n+                  -> ty::ClosureTy<'tcx>;\n+    fn item_variances(&self, def: DefId) -> ty::ItemVariances;\n+    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n+    fn item_type(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                 -> ty::TypeScheme<'tcx>;\n+    fn item_path(&self, def: DefId) -> Vec<hir_map::PathElem>;\n+    fn item_name(&self, def: DefId) -> ast::Name;\n+    fn item_predicates(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                       -> ty::GenericPredicates<'tcx>;\n+    fn item_super_predicates(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                             -> ty::GenericPredicates<'tcx>;\n+    fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n+    fn item_symbol(&self, def: DefId) -> String;\n+    fn trait_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n+    fn adt_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n+    fn method_arg_names(&self, did: DefId) -> Vec<String>;\n+    fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n+\n+    // trait info\n+    fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId>;\n+    fn provided_trait_methods(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                              -> Vec<Rc<ty::Method<'tcx>>>;\n+    fn trait_item_def_ids(&self, def: DefId)\n+                          -> Vec<ty::ImplOrTraitItemId>;\n+\n+    // impl info\n+    fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>;\n+    fn impl_trait_ref(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                      -> Option<ty::TraitRef<'tcx>>;\n+    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity>;\n+    fn custom_coerce_unsized_kind(&self, def: DefId)\n+                                  -> Option<ty::adjustment::CustomCoerceUnsized>;\n+    fn associated_consts(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                         -> Vec<Rc<ty::AssociatedConst<'tcx>>>;\n+\n+    // trait/impl-item info\n+    fn trait_of_item(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)\n+                     -> Option<DefId>;\n+    fn impl_or_trait_item(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                          -> ty::ImplOrTraitItem<'tcx>;\n+\n+    // flags\n+    fn is_const_fn(&self, did: DefId) -> bool;\n+    fn is_defaulted_trait(&self, did: DefId) -> bool;\n+    fn is_impl(&self, did: DefId) -> bool;\n+    fn is_default_impl(&self, impl_did: DefId) -> bool;\n+    fn is_extern_fn(&self, tcx: &ty::ctxt<'tcx>, did: DefId) -> bool;\n+    fn is_static(&self, did: DefId) -> bool;\n+    fn is_static_method(&self, did: DefId) -> bool;\n+    fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n+    fn is_typedef(&self, did: DefId) -> bool;\n+\n+    // crate metadata\n+    fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n+                                    -> Vec<(ast::CrateNum, LinkagePreference)>;\n+    fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>;\n+    fn missing_lang_items(&self, cnum: ast::CrateNum) -> Vec<lang_items::LangItem>;\n+    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool;\n+    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool;\n+    fn is_allocator(&self, cnum: ast::CrateNum) -> bool;\n+    fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>;\n+    fn crate_name(&self, cnum: ast::CrateNum) -> String;\n+    fn crate_hash(&self, cnum: ast::CrateNum) -> Svh;\n+    fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n+                                -> FnvHashMap<DefId, Vec<ast::Attribute>>;\n+    fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>;\n+    fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>;\n+    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId>;\n+\n+    // resolve\n+    fn def_path(&self, def: DefId) -> hir_map::DefPath;\n+    fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>;\n+    fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n+    fn item_children(&self, did: DefId) -> Vec<ChildItem>;\n+    fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>;\n+\n+    // misc. metadata\n+    fn maybe_get_item_ast(&'tcx self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                          -> FoundAst<'tcx>;\n+    // This is basically a 1-based range of ints, which is a little\n+    // silly - I may fix that.\n+    fn crates(&self) -> Vec<ast::CrateNum>;\n+    fn used_libraries(&self) -> Vec<(String, NativeLibraryKind)>;\n+    fn used_link_args(&self) -> Vec<String>;\n+\n+    // utility functions\n+    fn metadata_filename(&self) -> &str;\n+    fn metadata_section_name(&self, target: &Target) -> &str;\n+    fn encode_type(&self, tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Vec<u8>;\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>;\n+    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource;\n+    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>;\n+    fn encode_metadata(&self,\n+                       tcx: &ty::ctxt<'tcx>,\n+                       reexports: &def::ExportMap,\n+                       item_symbols: &RefCell<NodeMap<String>>,\n+                       link_meta: &LinkMeta,\n+                       reachable: &NodeSet,\n+                       krate: &hir::Crate) -> Vec<u8>;\n+    fn metadata_encoding_version(&self) -> &[u8];\n+}\n+\n+impl InlinedItem {\n+    pub fn visit<'ast,V>(&'ast self, visitor: &mut V)\n+        where V: Visitor<'ast>\n+    {\n+        match *self {\n+            InlinedItem::Item(ref i) => visitor.visit_item(&**i),\n+            InlinedItem::Foreign(ref i) => visitor.visit_foreign_item(&**i),\n+            InlinedItem::TraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n+            InlinedItem::ImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n+        }\n+    }\n+\n+    pub fn visit_ids<O: IdVisitingOperation>(&self, operation: &mut O) {\n+        let mut id_visitor = IdVisitor::new(operation);\n+        self.visit(&mut id_visitor);\n+    }\n+}\n+\n+// FIXME: find a better place for this?\n+pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n+    let say = |s: &str| {\n+        match (sp, sess) {\n+            (_, None) => panic!(\"{}\", s),\n+            (Some(sp), Some(sess)) => sess.span_err(sp, s),\n+            (None, Some(sess)) => sess.err(s),\n+        }\n+    };\n+    if s.is_empty() {\n+        say(\"crate name must not be empty\");\n+    }\n+    for c in s.chars() {\n+        if c.is_alphanumeric() { continue }\n+        if c == '_'  { continue }\n+        say(&format!(\"invalid character `{}` in crate name: `{}`\", c, s));\n+    }\n+    match sess {\n+        Some(sess) => sess.abort_if_errors(),\n+        None => {}\n+    }\n+}\n+\n+/// A dummy crate store that does not support any non-local crates,\n+/// for test purposes.\n+pub struct DummyCrateStore;\n+#[allow(unused_variables)]\n+impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n+    // item info\n+    fn stability(&self, def: DefId) -> Option<attr::Stability> { unimplemented!() }\n+    fn closure_kind(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)\n+                    -> ty::ClosureKind  { unimplemented!() }\n+    fn closure_ty(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)\n+                  -> ty::ClosureTy<'tcx>  { unimplemented!() }\n+    fn item_variances(&self, def: DefId) -> ty::ItemVariances { unimplemented!() }\n+    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { unimplemented!() }\n+    fn item_type(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                 -> ty::TypeScheme<'tcx> { unimplemented!() }\n+    fn item_path(&self, def: DefId) -> Vec<hir_map::PathElem> { unimplemented!() }\n+    fn item_name(&self, def: DefId) -> ast::Name { unimplemented!() }\n+    fn item_predicates(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                       -> ty::GenericPredicates<'tcx> { unimplemented!() }\n+    fn item_super_predicates(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                             -> ty::GenericPredicates<'tcx> { unimplemented!() }\n+    fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { unimplemented!() }\n+    fn item_symbol(&self, def: DefId) -> String { unimplemented!() }\n+    fn trait_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n+        { unimplemented!() }\n+    fn adt_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n+        { unimplemented!() }\n+    fn method_arg_names(&self, did: DefId) -> Vec<String> { unimplemented!() }\n+    fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n+\n+    // trait info\n+    fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n+    fn provided_trait_methods(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                              -> Vec<Rc<ty::Method<'tcx>>> { unimplemented!() }\n+    fn trait_item_def_ids(&self, def: DefId)\n+                          -> Vec<ty::ImplOrTraitItemId> { unimplemented!() }\n+\n+    // impl info\n+    fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n+        { unimplemented!() }\n+    fn impl_trait_ref(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                      -> Option<ty::TraitRef<'tcx>> { unimplemented!() }\n+    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity> { unimplemented!() }\n+    fn custom_coerce_unsized_kind(&self, def: DefId)\n+                                  -> Option<ty::adjustment::CustomCoerceUnsized>\n+        { unimplemented!() }\n+    fn associated_consts(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                         -> Vec<Rc<ty::AssociatedConst<'tcx>>> { unimplemented!() }\n+\n+    // trait/impl-item info\n+    fn trait_of_item(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)\n+                     -> Option<DefId> { unimplemented!() }\n+    fn impl_or_trait_item(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                          -> ty::ImplOrTraitItem<'tcx> { unimplemented!() }\n+\n+    // flags\n+    fn is_const_fn(&self, did: DefId) -> bool { unimplemented!() }\n+    fn is_defaulted_trait(&self, did: DefId) -> bool { unimplemented!() }\n+    fn is_impl(&self, did: DefId) -> bool { unimplemented!() }\n+    fn is_default_impl(&self, impl_did: DefId) -> bool { unimplemented!() }\n+    fn is_extern_fn(&self, tcx: &ty::ctxt<'tcx>, did: DefId) -> bool { unimplemented!() }\n+    fn is_static(&self, did: DefId) -> bool { unimplemented!() }\n+    fn is_static_method(&self, did: DefId) -> bool { unimplemented!() }\n+    fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n+    fn is_typedef(&self, did: DefId) -> bool { unimplemented!() }\n+\n+    // crate metadata\n+    fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n+                                    -> Vec<(ast::CrateNum, LinkagePreference)>\n+        { unimplemented!() }\n+    fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>\n+        { unimplemented!() }\n+    fn missing_lang_items(&self, cnum: ast::CrateNum) -> Vec<lang_items::LangItem>\n+        { unimplemented!() }\n+    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool { unimplemented!() }\n+    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool { unimplemented!() }\n+    fn is_allocator(&self, cnum: ast::CrateNum) -> bool { unimplemented!() }\n+    fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>\n+        { unimplemented!() }\n+    fn crate_name(&self, cnum: ast::CrateNum) -> String { unimplemented!() }\n+    fn crate_hash(&self, cnum: ast::CrateNum) -> Svh { unimplemented!() }\n+    fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n+                                -> FnvHashMap<DefId, Vec<ast::Attribute>>\n+        { unimplemented!() }\n+    fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>\n+        { unimplemented!() }\n+    fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>\n+        { unimplemented!() }\n+    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId> { unimplemented!() }\n+\n+    // resolve\n+    fn def_path(&self, def: DefId) -> hir_map::DefPath { unimplemented!() }\n+    fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>\n+        { unimplemented!() }\n+    fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { unimplemented!() }\n+    fn item_children(&self, did: DefId) -> Vec<ChildItem> { unimplemented!() }\n+    fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>\n+        { unimplemented!() }\n+\n+    // misc. metadata\n+    fn maybe_get_item_ast(&'tcx self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                          -> FoundAst<'tcx> { unimplemented!() }\n+    // This is basically a 1-based range of ints, which is a little\n+    // silly - I may fix that.\n+    fn crates(&self) -> Vec<ast::CrateNum> { vec![] }\n+    fn used_libraries(&self) -> Vec<(String, NativeLibraryKind)> { vec![] }\n+    fn used_link_args(&self) -> Vec<String> { vec![] }\n+\n+    // utility functions\n+    fn metadata_filename(&self) -> &str { unimplemented!() }\n+    fn metadata_section_name(&self, target: &Target) -> &str { unimplemented!() }\n+    fn encode_type(&self, tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Vec<u8>\n+        { unimplemented!() }\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>\n+        { vec![] }\n+    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource { unimplemented!() }\n+    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum> { None }\n+    fn encode_metadata(&self,\n+                       tcx: &ty::ctxt<'tcx>,\n+                       reexports: &def::ExportMap,\n+                       item_symbols: &RefCell<NodeMap<String>>,\n+                       link_meta: &LinkMeta,\n+                       reachable: &NodeSet,\n+                       krate: &hir::Crate) -> Vec<u8> { vec![] }\n+    fn metadata_encoding_version(&self) -> &[u8] { unimplemented!() }\n+}"}, {"sha": "4d0005f47c4f200d9e210278b18e52ef95668bea", "filename": "src/librustc/middle/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef_id.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use metadata::cstore::LOCAL_CRATE;\n+use middle::cstore::LOCAL_CRATE;\n use middle::ty;\n use syntax::ast::CrateNum;\n use std::fmt;"}, {"sha": "ab5153e1a61d4b86025656e4fb4a856034cd61af", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -65,8 +65,8 @@ use syntax::ast;\n \n use session;\n use session::config;\n-use metadata::cstore;\n-use metadata::csearch;\n+use middle::cstore::CrateStore;\n+use middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n use util::nodemap::FnvHashMap;\n \n /// A list of dependencies for a certain crate type.\n@@ -123,12 +123,12 @@ fn calculate_type(sess: &session::Session,\n                 Some(v) => return v,\n                 None => {}\n             }\n-            sess.cstore.iter_crate_data(|cnum, data| {\n-                let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n-                if src.rlib.is_some() { return }\n+            for cnum in sess.cstore.crates() {\n+                let src = sess.cstore.used_crate_source(cnum);\n+                if src.rlib.is_some() { continue }\n                 sess.err(&format!(\"dependency `{}` not found in rlib format\",\n-                                 data.name));\n-            });\n+                                  sess.cstore.crate_name(cnum)));\n+            }\n             return Vec::new();\n         }\n \n@@ -151,25 +151,27 @@ fn calculate_type(sess: &session::Session,\n     // Sweep all crates for found dylibs. Add all dylibs, as well as their\n     // dependencies, ensuring there are no conflicts. The only valid case for a\n     // dependency to be relied upon twice is for both cases to rely on a dylib.\n-    sess.cstore.iter_crate_data(|cnum, data| {\n-        let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n+    for cnum in sess.cstore.crates() {\n+        let name = sess.cstore.crate_name(cnum);\n+        let src = sess.cstore.used_crate_source(cnum);\n         if src.dylib.is_some() {\n-            info!(\"adding dylib: {}\", data.name);\n-            add_library(sess, cnum, cstore::RequireDynamic, &mut formats);\n-            let deps = csearch::get_dylib_dependency_formats(&sess.cstore, cnum);\n+            info!(\"adding dylib: {}\", name);\n+            add_library(sess, cnum, RequireDynamic, &mut formats);\n+            let deps = sess.cstore.dylib_dependency_formats(cnum);\n             for &(depnum, style) in &deps {\n                 info!(\"adding {:?}: {}\", style,\n-                      sess.cstore.get_crate_data(depnum).name.clone());\n+                      sess.cstore.crate_name(depnum));\n                 add_library(sess, depnum, style, &mut formats);\n             }\n         }\n-    });\n+    }\n \n     // Collect what we've got so far in the return vector.\n-    let mut ret = (1..sess.cstore.next_crate_num()).map(|i| {\n-        match formats.get(&i) {\n-            Some(&cstore::RequireDynamic) => Linkage::Dynamic,\n-            Some(&cstore::RequireStatic) => Linkage::IncludedFromDylib,\n+    let last_crate = sess.cstore.crates().len() as ast::CrateNum;\n+    let mut ret = (1..last_crate+1).map(|cnum| {\n+        match formats.get(&cnum) {\n+            Some(&RequireDynamic) => Linkage::Dynamic,\n+            Some(&RequireStatic) => Linkage::IncludedFromDylib,\n             None => Linkage::NotLinked,\n         }\n     }).collect::<Vec<_>>();\n@@ -179,17 +181,17 @@ fn calculate_type(sess: &session::Session,\n     //\n     // If the crate hasn't been included yet and it's not actually required\n     // (e.g. it's an allocator) then we skip it here as well.\n-    sess.cstore.iter_crate_data(|cnum, data| {\n-        let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n+    for cnum in sess.cstore.crates() {\n+        let src = sess.cstore.used_crate_source(cnum);\n         if src.dylib.is_none() &&\n            !formats.contains_key(&cnum) &&\n-           data.explicitly_linked.get() {\n+           sess.cstore.is_explicitly_linked(cnum) {\n             assert!(src.rlib.is_some());\n-            info!(\"adding staticlib: {}\", data.name);\n-            add_library(sess, cnum, cstore::RequireStatic, &mut formats);\n+            info!(\"adding staticlib: {}\", sess.cstore.crate_name(cnum));\n+            add_library(sess, cnum, RequireStatic, &mut formats);\n             ret[cnum as usize - 1] = Linkage::Static;\n         }\n-    });\n+    }\n \n     // We've gotten this far because we're emitting some form of a final\n     // artifact which means that we're going to need an allocator of some form.\n@@ -205,7 +207,7 @@ fn calculate_type(sess: &session::Session,\n     // making sure that everything is available in the requested format.\n     for (cnum, kind) in ret.iter().enumerate() {\n         let cnum = (cnum + 1) as ast::CrateNum;\n-        let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n+        let src = sess.cstore.used_crate_source(cnum);\n         match *kind {\n             Linkage::NotLinked |\n             Linkage::IncludedFromDylib => {}\n@@ -216,10 +218,10 @@ fn calculate_type(sess: &session::Session,\n                     Linkage::Static => \"rlib\",\n                     _ => \"dylib\",\n                 };\n-                let data = sess.cstore.get_crate_data(cnum);\n+                let name = sess.cstore.crate_name(cnum);\n                 sess.err(&format!(\"crate `{}` required to be available in {}, \\\n                                   but it was not available in this form\",\n-                                 data.name, kind));\n+                                  name, kind));\n             }\n         }\n     }\n@@ -229,8 +231,8 @@ fn calculate_type(sess: &session::Session,\n \n fn add_library(sess: &session::Session,\n                cnum: ast::CrateNum,\n-               link: cstore::LinkagePreference,\n-               m: &mut FnvHashMap<ast::CrateNum, cstore::LinkagePreference>) {\n+               link: LinkagePreference,\n+               m: &mut FnvHashMap<ast::CrateNum, LinkagePreference>) {\n     match m.get(&cnum) {\n         Some(&link2) => {\n             // If the linkages differ, then we'd have two copies of the library\n@@ -240,10 +242,9 @@ fn add_library(sess: &session::Session,\n             //\n             // This error is probably a little obscure, but I imagine that it\n             // can be refined over time.\n-            if link2 != link || link == cstore::RequireStatic {\n-                let data = sess.cstore.get_crate_data(cnum);\n+            if link2 != link || link == RequireStatic {\n                 sess.err(&format!(\"cannot satisfy dependencies so `{}` only \\\n-                                   shows up once\", data.name));\n+                                   shows up once\", sess.cstore.crate_name(cnum)));\n                 sess.help(\"having upstream crates all available in one format \\\n                            will likely make this go away\");\n             }\n@@ -253,15 +254,16 @@ fn add_library(sess: &session::Session,\n }\n \n fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n-    let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n+    let crates = sess.cstore.used_crates(RequireStatic);\n     if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n         return None\n     }\n \n     // All crates are available in an rlib format, so we're just going to link\n     // everything in explicitly so long as it's actually required.\n-    let mut ret = (1..sess.cstore.next_crate_num()).map(|cnum| {\n-        if sess.cstore.get_crate_data(cnum).explicitly_linked.get() {\n+    let last_crate = sess.cstore.crates().len() as ast::CrateNum;\n+    let mut ret = (1..last_crate+1).map(|cnum| {\n+        if sess.cstore.is_explicitly_linked(cnum) {\n             Linkage::Static\n         } else {\n             Linkage::NotLinked\n@@ -288,7 +290,7 @@ fn activate_allocator(sess: &session::Session, list: &mut DependencyList) {\n     let mut allocator_found = false;\n     for (i, slot) in list.iter().enumerate() {\n         let cnum = (i + 1) as ast::CrateNum;\n-        if !sess.cstore.get_crate_data(cnum).is_allocator() {\n+        if !sess.cstore.is_allocator(cnum) {\n             continue\n         }\n         if let Linkage::NotLinked = *slot {\n@@ -314,18 +316,18 @@ fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n     let mut allocator = None;\n     for (i, linkage) in list.iter().enumerate() {\n         let cnum = (i + 1) as ast::CrateNum;\n-        let data = sess.cstore.get_crate_data(cnum);\n-        if !data.is_allocator() {\n+        if !sess.cstore.is_allocator(cnum) {\n             continue\n         }\n         if let Linkage::NotLinked = *linkage {\n             continue\n         }\n         if let Some(prev_alloc) = allocator {\n-            let prev = sess.cstore.get_crate_data(prev_alloc);\n+            let prev_name = sess.cstore.crate_name(prev_alloc);\n+            let cur_name = sess.cstore.crate_name(cnum);\n             sess.err(&format!(\"cannot link together two \\\n                                allocators: {} and {}\",\n-                              prev.name(), data.name()));\n+                              prev_name, cur_name));\n         }\n         allocator = Some(cnum);\n     }"}, {"sha": "5563cd8043819dbaa3251fcb3102dfb68bbec932", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -76,6 +76,7 @@ use front::map as ast_map;\n use rustc_front::hir;\n use rustc_front::print::pprust;\n \n+use middle::cstore::CrateStore;\n use middle::def;\n use middle::def_id::DefId;\n use middle::infer::{self, TypeOrigin};\n@@ -498,8 +499,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 // We compare strings because PathMod and PathName can be different\n                 // for imported and non-imported crates\n                 if exp_path == found_path {\n-                    let crate_name = self.tcx.sess.cstore\n-                                         .get_crate_data(did1.krate).name();\n+                    let crate_name = self.tcx.sess.cstore.crate_name(did1.krate);\n                     self.tcx.sess.span_note(sp, &format!(\"Perhaps two different versions \\\n                                                           of crate `{}` are being used?\",\n                                                           crate_name));"}, {"sha": "ec55daca9ecdf137dc42bbb9c58a4efe1f57eb78", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -23,7 +23,7 @@ pub use self::LangItem::*;\n \n use front::map as hir_map;\n use session::Session;\n-use metadata::csearch::each_lang_item;\n+use middle::cstore::CrateStore;\n use middle::def_id::DefId;\n use middle::ty;\n use middle::weak_lang_items;\n@@ -203,14 +203,13 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n     }\n \n     pub fn collect_external_language_items(&mut self) {\n-        let crate_store = &self.session.cstore;\n-        crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n-            each_lang_item(crate_store, crate_number, |index, item_index| {\n-                let def_id = DefId { krate: crate_number, index: index };\n+        let cstore = &self.session.cstore;\n+        for cnum in cstore.crates() {\n+            for (index, item_index) in cstore.lang_items(cnum) {\n+                let def_id = DefId { krate: cnum, index: index };\n                 self.collect_item(item_index, def_id, DUMMY_SP);\n-                true\n-            });\n-        })\n+            }\n+        }\n     }\n \n     pub fn collect(&mut self, krate: &hir::Crate) {"}, {"sha": "e3504b6a744dcc46f813314d8efb284658525921", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -16,10 +16,10 @@\n //! Most of the documentation on regions can be found in\n //! `middle/typeck/infer/region_inference.rs`\n \n-use metadata::inline::InlinedItem;\n use front::map as ast_map;\n use session::Session;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n+use middle::cstore::InlinedItem;\n use middle::ty::{self, Ty};\n \n use std::cell::RefCell;"}, {"sha": "0d92c3da83c8bed89dde98903e70b2db4f213b63", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -15,12 +15,11 @@ pub use self::StabilityLevel::*;\n \n use session::Session;\n use lint;\n-use metadata::cstore::LOCAL_CRATE;\n+use middle::cstore::{CrateStore, LOCAL_CRATE};\n use middle::def;\n use middle::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::ty;\n use middle::privacy::AccessLevels;\n-use metadata::csearch;\n use syntax::parse::token::InternedString;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::ast;\n@@ -448,7 +447,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &hir::Item, warn_about_defns: bool,\n             // compiler-generated `extern crate` items have a dummy span.\n             if item.span == DUMMY_SP { return }\n \n-            let cnum = match tcx.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n+            let cnum = match tcx.sess.cstore.extern_mod_stmt_cnum(item.id) {\n                 Some(cnum) => cnum,\n                 None => return,\n             };\n@@ -621,7 +620,7 @@ fn is_staged_api(tcx: &ty::ctxt, id: DefId) -> bool {\n             }\n         _ => {\n             *tcx.stability.borrow_mut().staged_api.entry(id.krate).or_insert_with(\n-                || csearch::is_staged_api(&tcx.sess.cstore, id.krate))\n+                || tcx.sess.cstore.is_staged_api(id.krate))\n         }\n     }\n }\n@@ -653,7 +652,7 @@ fn lookup_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stabil\n     let item_stab = if id.is_local() {\n         None // The stability cache is filled partially lazily\n     } else {\n-        csearch::get_stability(&tcx.sess.cstore, id).map(|st| tcx.intern_stability(st))\n+        tcx.sess.cstore.stability(id).map(|st| tcx.intern_stability(st))\n     };\n \n     item_stab.or_else(|| {"}, {"sha": "56dc259b1c2f012b543c789915f7bc2fcb184c1a", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -17,7 +17,7 @@ use super::PredicateObligation;\n use super::project;\n use super::util;\n \n-use metadata::cstore::LOCAL_CRATE;\n+use middle::cstore::LOCAL_CRATE;\n use middle::def_id::DefId;\n use middle::subst::{Subst, Substs, TypeSpace};\n use middle::ty::{self, Ty};"}, {"sha": "4b61453992111d7f96254b8bcbe64f6903d87784", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -16,8 +16,8 @@\n use front::map as ast_map;\n use session::Session;\n use lint;\n-use metadata::csearch;\n use middle;\n+use middle::cstore::CrateStore;\n use middle::def::DefMap;\n use middle::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n@@ -155,7 +155,7 @@ impl<'tcx> Tables<'tcx> {\n             return kind;\n         }\n \n-        let kind = csearch::closure_kind(tcx, def_id);\n+        let kind = tcx.sess.cstore.closure_kind(tcx, def_id);\n         this.borrow_mut().closure_kinds.insert(def_id, kind);\n         kind\n     }\n@@ -173,7 +173,7 @@ impl<'tcx> Tables<'tcx> {\n             return ty.subst(tcx, &substs.func_substs);\n         }\n \n-        let ty = csearch::closure_ty(tcx, def_id);\n+        let ty = tcx.sess.cstore.closure_ty(tcx, def_id);\n         this.borrow_mut().closure_tys.insert(def_id, ty.clone());\n         ty.subst(tcx, &substs.func_substs)\n     }"}, {"sha": "71ae8e40b45f0ecbe7c331cb1602ee5626ecd906", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -21,9 +21,8 @@ pub use self::LvaluePreference::*;\n \n use front::map as ast_map;\n use front::map::LinkedPath;\n-use metadata::csearch;\n-use metadata::cstore::LOCAL_CRATE;\n use middle;\n+use middle::cstore::{CrateStore, LOCAL_CRATE};\n use middle::def::{self, ExportMap};\n use middle::def_id::DefId;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n@@ -2131,7 +2130,7 @@ impl<'tcx> ctxt<'tcx> {\n                 self.sess.bug(&format!(\"provided_trait_methods: `{:?}` is not a trait\", id))\n             }\n         } else {\n-            csearch::get_provided_trait_methods(self, id)\n+            self.sess.cstore.provided_trait_methods(self, id)\n         }\n     }\n \n@@ -2176,7 +2175,7 @@ impl<'tcx> ctxt<'tcx> {\n                 }\n             }\n         } else {\n-            csearch::get_associated_consts(self, id)\n+            self.sess.cstore.associated_consts(self, id)\n         }\n     }\n \n@@ -2208,14 +2207,14 @@ impl<'tcx> ctxt<'tcx> {\n                 _ => None\n             }\n         } else {\n-            csearch::get_impl_polarity(self, id)\n+            self.sess.cstore.impl_polarity(id)\n         }\n     }\n \n     pub fn custom_coerce_unsized_kind(&self, did: DefId) -> adjustment::CustomCoerceUnsized {\n         memoized(&self.custom_coerce_unsized_kinds, did, |did: DefId| {\n             let (kind, src) = if did.krate != LOCAL_CRATE {\n-                (csearch::get_custom_coerce_unsized_kind(self, did), \"external\")\n+                (self.sess.cstore.custom_coerce_unsized_kind(did), \"external\")\n             } else {\n                 (None, \"local\")\n             };\n@@ -2234,21 +2233,21 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn impl_or_trait_item(&self, id: DefId) -> ImplOrTraitItem<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"impl_or_trait_items\", id, &self.impl_or_trait_items,\n-            || csearch::get_impl_or_trait_item(self, id))\n+            || self.sess.cstore.impl_or_trait_item(self, id))\n     }\n \n     pub fn trait_item_def_ids(&self, id: DefId) -> Rc<Vec<ImplOrTraitItemId>> {\n         lookup_locally_or_in_crate_store(\n             \"trait_item_def_ids\", id, &self.trait_item_def_ids,\n-            || Rc::new(csearch::get_trait_item_def_ids(&self.sess.cstore, id)))\n+            || Rc::new(self.sess.cstore.trait_item_def_ids(id)))\n     }\n \n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n     /// an inherent impl.\n     pub fn impl_trait_ref(&self, id: DefId) -> Option<TraitRef<'tcx>> {\n         lookup_locally_or_in_crate_store(\n             \"impl_trait_refs\", id, &self.impl_trait_refs,\n-            || csearch::get_impl_trait(self, id))\n+            || self.sess.cstore.impl_trait_ref(self, id))\n     }\n \n     /// Returns whether this DefId refers to an impl\n@@ -2261,7 +2260,7 @@ impl<'tcx> ctxt<'tcx> {\n                 false\n             }\n         } else {\n-            csearch::is_impl(&self.sess.cstore, id)\n+            self.sess.cstore.is_impl(id)\n         }\n     }\n \n@@ -2277,7 +2276,7 @@ impl<'tcx> ctxt<'tcx> {\n         if id.is_local() {\n             self.map.def_path(id)\n         } else {\n-            csearch::def_path(self, id)\n+            self.sess.cstore.def_path(id)\n         }\n     }\n \n@@ -2287,15 +2286,15 @@ impl<'tcx> ctxt<'tcx> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.with_path(id, f)\n         } else {\n-            f(csearch::get_item_path(self, id).iter().cloned().chain(LinkedPath::empty()))\n+            f(self.sess.cstore.item_path(id).iter().cloned().chain(LinkedPath::empty()))\n         }\n     }\n \n     pub fn item_name(&self, id: DefId) -> ast::Name {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.get_path_elem(id).name()\n         } else {\n-            csearch::get_item_name(self, id)\n+            self.sess.cstore.item_name(id)\n         }\n     }\n \n@@ -2309,14 +2308,14 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn lookup_item_type(&self, did: DefId) -> TypeScheme<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"tcache\", did, &self.tcache,\n-            || csearch::get_type(self, did))\n+            || self.sess.cstore.item_type(self, did))\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n     pub fn lookup_trait_def(&self, did: DefId) -> &'tcx TraitDef<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"trait_defs\", did, &self.trait_defs,\n-            || self.alloc_trait_def(csearch::get_trait_def(self, did))\n+            || self.alloc_trait_def(self.sess.cstore.trait_def(self, did))\n         )\n     }\n \n@@ -2326,7 +2325,7 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn lookup_adt_def_master(&self, did: DefId) -> AdtDefMaster<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"adt_defs\", did, &self.adt_defs,\n-            || csearch::get_adt_def(self, did)\n+            || self.sess.cstore.adt_def(self, did)\n         )\n     }\n \n@@ -2341,22 +2340,22 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn lookup_predicates(&self, did: DefId) -> GenericPredicates<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"predicates\", did, &self.predicates,\n-            || csearch::get_predicates(self, did))\n+            || self.sess.cstore.item_predicates(self, did))\n     }\n \n     /// Given the did of a trait, returns its superpredicates.\n     pub fn lookup_super_predicates(&self, did: DefId) -> GenericPredicates<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"super_predicates\", did, &self.super_predicates,\n-            || csearch::get_super_predicates(self, did))\n+            || self.sess.cstore.item_super_predicates(self, did))\n     }\n \n     /// Get the attributes of a definition.\n     pub fn get_attrs(&self, did: DefId) -> Cow<'tcx, [ast::Attribute]> {\n         if let Some(id) = self.map.as_local_node_id(did) {\n             Cow::Borrowed(self.map.attrs(id))\n         } else {\n-            Cow::Owned(csearch::get_item_attrs(&self.sess.cstore, did))\n+            Cow::Owned(self.sess.cstore.item_attrs(did))\n         }\n     }\n \n@@ -2384,15 +2383,15 @@ impl<'tcx> ctxt<'tcx> {\n                     attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n                 }).collect()\n             } else {\n-                csearch::get_repr_attrs(&self.sess.cstore, did)\n+                self.sess.cstore.repr_attrs(did)\n             })\n         })\n     }\n \n     pub fn item_variances(&self, item_id: DefId) -> Rc<ItemVariances> {\n         lookup_locally_or_in_crate_store(\n             \"item_variance_map\", item_id, &self.item_variance_map,\n-            || Rc::new(csearch::get_item_variances(&self.sess.cstore, item_id)))\n+            || Rc::new(self.sess.cstore.item_variances(item_id)))\n     }\n \n     pub fn trait_has_default_impl(&self, trait_def_id: DefId) -> bool {\n@@ -2422,7 +2421,7 @@ impl<'tcx> ctxt<'tcx> {\n         debug!(\"populate_implementations_for_primitive_if_necessary: searching for {:?}\",\n                primitive_def_id);\n \n-        let impl_items = csearch::get_impl_items(&self.sess.cstore, primitive_def_id);\n+        let impl_items = self.sess.cstore.impl_items(primitive_def_id);\n \n         // Store the implementation info.\n         self.impl_items.borrow_mut().insert(primitive_def_id, impl_items);\n@@ -2444,15 +2443,12 @@ impl<'tcx> ctxt<'tcx> {\n         debug!(\"populate_inherent_implementations_for_type_if_necessary: searching for {:?}\",\n                type_id);\n \n-        let mut inherent_impls = Vec::new();\n-        csearch::each_inherent_implementation_for_type(&self.sess.cstore, type_id, |impl_def_id| {\n-            // Record the implementation.\n-            inherent_impls.push(impl_def_id);\n-\n+        let inherent_impls = self.sess.cstore.inherent_implementations_for_type(type_id);\n+        for &impl_def_id in &inherent_impls {\n             // Store the implementation info.\n-            let impl_items = csearch::get_impl_items(&self.sess.cstore, impl_def_id);\n+            let impl_items = self.sess.cstore.impl_items(impl_def_id);\n             self.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n-        });\n+        }\n \n         self.inherent_impls.borrow_mut().insert(type_id, Rc::new(inherent_impls));\n         self.populated_external_types.borrow_mut().insert(type_id);\n@@ -2472,12 +2468,12 @@ impl<'tcx> ctxt<'tcx> {\n \n         debug!(\"populate_implementations_for_trait_if_necessary: searching for {:?}\", def);\n \n-        if csearch::is_defaulted_trait(&self.sess.cstore, trait_id) {\n+        if self.sess.cstore.is_defaulted_trait(trait_id) {\n             self.record_trait_has_default_impl(trait_id);\n         }\n \n-        csearch::each_implementation_for_trait(&self.sess.cstore, trait_id, |impl_def_id| {\n-            let impl_items = csearch::get_impl_items(&self.sess.cstore, impl_def_id);\n+        for impl_def_id in self.sess.cstore.implementations_of_trait(trait_id) {\n+            let impl_items = self.sess.cstore.impl_items(impl_def_id);\n             let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n             // Record the trait->implementation mapping.\n             def.record_impl(self, impl_def_id, trait_ref);\n@@ -2493,7 +2489,7 @@ impl<'tcx> ctxt<'tcx> {\n \n             // Store the implementation info.\n             self.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n-        });\n+        }\n \n         def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n     }\n@@ -2520,8 +2516,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// ID of the impl that the method belongs to. Otherwise, return `None`.\n     pub fn impl_of_method(&self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return match csearch::get_impl_or_trait_item(self,\n-                                                         def_id).container() {\n+            return match self.sess.cstore.impl_or_trait_item(self, def_id).container() {\n                 TraitContainer(_) => None,\n                 ImplContainer(def_id) => Some(def_id),\n             };\n@@ -2542,7 +2537,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// the trait that the method belongs to. Otherwise, return `None`.\n     pub fn trait_of_item(&self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return csearch::get_trait_of_item(&self.sess.cstore, def_id, self);\n+            return self.sess.cstore.trait_of_item(self, def_id);\n         }\n         match self.impl_or_trait_items.borrow().get(&def_id).cloned() {\n             Some(impl_or_trait_item) => {"}, {"sha": "0517769356f7511936eaee116cc1b2e7e6b59981", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -458,7 +458,7 @@ impl<'tcx> ty::ctxt<'tcx> {\n                 let h = if did.is_local() {\n                     svh.clone()\n                 } else {\n-                    tcx.sess.cstore.get_crate_hash(did.krate)\n+                    tcx.sess.cstore.crate_hash(did.krate)\n                 };\n                 h.as_str().hash(state);\n                 did.index.hash(state);"}, {"sha": "78cdc99f047d720c523cafa66dd93a188ed09dc1", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -12,7 +12,7 @@\n \n use session::config;\n use session::Session;\n-use metadata::csearch;\n+use middle::cstore::CrateStore;\n use middle::lang_items;\n \n use syntax::ast;\n@@ -79,11 +79,11 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n     if !needs_check { return }\n \n     let mut missing = HashSet::new();\n-    sess.cstore.iter_crate_data(|cnum, _| {\n-        for item in &csearch::get_missing_lang_items(&sess.cstore, cnum) {\n-            missing.insert(*item);\n+    for cnum in sess.cstore.crates() {\n+        for item in sess.cstore.missing_lang_items(cnum) {\n+            missing.insert(item);\n         }\n-    });\n+    }\n \n     $(\n         if missing.contains(&lang_items::$item) && items.$name().is_none() {"}, {"sha": "dbeb4c3ed734cee8d28b408c3198992b2a7b0211", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -22,7 +22,7 @@ use session::search_paths::SearchPaths;\n \n use rustc_back::target::Target;\n use lint;\n-use metadata::cstore;\n+use middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy};\n use syntax::attr;\n@@ -1122,10 +1122,11 @@ impl fmt::Display for CrateType {\n \n #[cfg(test)]\n mod tests {\n-\n+    use middle::cstore::DummyCrateStore;\n     use session::config::{build_configuration, optgroups, build_session_options};\n     use session::build_session;\n \n+    use std::rc::Rc;\n     use getopts::getopts;\n     use syntax::attr;\n     use syntax::attr::AttrMetaMethods;\n@@ -1141,7 +1142,7 @@ mod tests {\n             };\n         let registry = diagnostics::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n-        let sess = build_session(sessopts, None, registry);\n+        let sess = build_session(sessopts, None, registry, Rc::new(DummyCrateStore));\n         let cfg = build_configuration(&sess);\n         assert!((attr::contains_name(&cfg[..], \"test\")));\n     }\n@@ -1160,7 +1161,8 @@ mod tests {\n             };\n         let registry = diagnostics::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n-        let sess = build_session(sessopts, None, registry);\n+        let sess = build_session(sessopts, None, registry,\n+                                 Rc::new(DummyCrateStore));\n         let cfg = build_configuration(&sess);\n         let mut test_items = cfg.iter().filter(|m| m.name() == \"test\");\n         assert!(test_items.next().is_some());\n@@ -1175,7 +1177,8 @@ mod tests {\n             ], &optgroups()).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n-            let sess = build_session(sessopts, None, registry);\n+            let sess = build_session(sessopts, None, registry,\n+                                     Rc::new(DummyCrateStore));\n             assert!(!sess.can_print_warnings);\n         }\n \n@@ -1186,7 +1189,8 @@ mod tests {\n             ], &optgroups()).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n-            let sess = build_session(sessopts, None, registry);\n+            let sess = build_session(sessopts, None, registry,\n+                                     Rc::new(DummyCrateStore));\n             assert!(sess.can_print_warnings);\n         }\n \n@@ -1196,7 +1200,8 @@ mod tests {\n             ], &optgroups()).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n-            let sess = build_session(sessopts, None, registry);\n+            let sess = build_session(sessopts, None, registry,\n+                                     Rc::new(DummyCrateStore));\n             assert!(sess.can_print_warnings);\n         }\n     }"}, {"sha": "09c6b54d99cf88242a6e5e09c9dc0690a650046b", "filename": "src/librustc/session/filesearch.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Ffilesearch.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "previous_filename": "src/librustc/metadata/filesearch.rs"}, {"sha": "7bf96b41dce7f4eb3e5242a713eb25b3caefe2ef", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use lint;\n-use metadata::cstore::CStore;\n-use metadata::filesearch;\n+use middle::cstore::CrateStore;\n use middle::dependency_format;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeMap, FnvHashMap};\n@@ -21,7 +20,6 @@ use syntax::diagnostic::{self, Emitter};\n use syntax::diagnostics;\n use syntax::feature_gate;\n use syntax::parse;\n-use syntax::parse::token;\n use syntax::parse::ParseSess;\n use syntax::{ast, codemap};\n use syntax::feature_gate::AttributeType;\n@@ -32,8 +30,10 @@ use std::path::{Path, PathBuf};\n use std::cell::{Cell, RefCell};\n use std::collections::HashSet;\n use std::env;\n+use std::rc::Rc;\n \n pub mod config;\n+pub mod filesearch;\n pub mod search_paths;\n \n // Represents the data associated with a compilation\n@@ -42,7 +42,7 @@ pub struct Session {\n     pub target: config::Config,\n     pub host: Target,\n     pub opts: config::Options,\n-    pub cstore: CStore,\n+    pub cstore: Rc<for<'a> CrateStore<'a>>,\n     pub parse_sess: ParseSess,\n     // For a library crate, this is always none\n     pub entry_fn: RefCell<Option<(NodeId, codemap::Span)>>,\n@@ -392,7 +392,8 @@ fn split_msg_into_multilines(msg: &str) -> Option<String> {\n \n pub fn build_session(sopts: config::Options,\n                      local_crate_source_file: Option<PathBuf>,\n-                     registry: diagnostics::registry::Registry)\n+                     registry: diagnostics::registry::Registry,\n+                     cstore: Rc<for<'a> CrateStore<'a>>)\n                      -> Session {\n     // FIXME: This is not general enough to make the warning lint completely override\n     // normal diagnostic warnings, since the warning lint can also be denied and changed\n@@ -410,12 +411,13 @@ pub fn build_session(sopts: config::Options,\n     let span_diagnostic_handler =\n         diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n \n-    build_session_(sopts, local_crate_source_file, span_diagnostic_handler)\n+    build_session_(sopts, local_crate_source_file, span_diagnostic_handler, cstore)\n }\n \n pub fn build_session_(sopts: config::Options,\n                       local_crate_source_file: Option<PathBuf>,\n-                      span_diagnostic: diagnostic::SpanHandler)\n+                      span_diagnostic: diagnostic::SpanHandler,\n+                      cstore: Rc<for<'a> CrateStore<'a>>)\n                       -> Session {\n     let host = match Target::search(config::host_triple()) {\n         Ok(t) => t,\n@@ -451,7 +453,7 @@ pub fn build_session_(sopts: config::Options,\n         target: target_cfg,\n         host: host,\n         opts: sopts,\n-        cstore: CStore::new(token::get_ident_interner()),\n+        cstore: cstore,\n         parse_sess: p_s,\n         // For a library crate, this is always none\n         entry_fn: RefCell::new(None),"}, {"sha": "1429a6a54a668bc3588262dac2fbae45213dd911", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -16,22 +16,23 @@ use rustc::session::Session;\n use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n-use rustc::metadata;\n-use rustc::metadata::creader::LocalCrateReader;\n use rustc::middle::{stability, ty, reachable};\n use rustc::middle::dependency_format;\n use rustc::middle;\n-use rustc::plugin::registry::Registry;\n-use rustc::plugin;\n use rustc::util::nodemap::NodeMap;\n use rustc::util::common::time;\n use rustc_borrowck as borrowck;\n use rustc_resolve as resolve;\n+use rustc_metadata::macro_import;\n+use rustc_metadata::creader::LocalCrateReader;\n+use rustc_metadata::cstore::CStore;\n use rustc_trans::back::link;\n use rustc_trans::back::write;\n use rustc_trans::trans;\n use rustc_typeck as typeck;\n use rustc_privacy;\n+use rustc_plugin::registry::Registry;\n+use rustc_plugin as plugin;\n use rustc_front::hir;\n use rustc_front::lowering::{lower_crate, LoweringContext};\n use super::Compilation;\n@@ -57,6 +58,7 @@ use syntax::visit;\n use syntax;\n \n pub fn compile_input(sess: Session,\n+                     cstore: &CStore,\n                      cfg: ast::CrateConfig,\n                      input: &Input,\n                      outdir: &Option<PathBuf>,\n@@ -87,6 +89,7 @@ pub fn compile_input(sess: Session,\n             let outputs = build_output_filenames(input, outdir, output, &krate.attrs, &sess);\n             let id = link::find_crate_name(Some(&sess), &krate.attrs, input);\n             let expanded_crate = match phase_2_configure_and_expand(&sess,\n+                                                                    &cstore,\n                                                                     krate,\n                                                                     &id[..],\n                                                                     addl_plugins) {\n@@ -136,6 +139,7 @@ pub fn compile_input(sess: Session,\n              || lint::check_ast_crate(&sess, &expanded_crate));\n \n         phase_3_run_analysis_passes(&sess,\n+                                    &cstore,\n                                     ast_map,\n                                     &arenas,\n                                     &id,\n@@ -434,6 +438,7 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n ///\n /// Returns `None` if we're aborting after handling -W help.\n pub fn phase_2_configure_and_expand(sess: &Session,\n+                                    cstore: &CStore,\n                                     mut krate: ast::Crate,\n                                     crate_name: &str,\n                                     addl_plugins: Option<Vec<String>>)\n@@ -477,11 +482,11 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n     let macros = time(time_passes,\n                       \"macro loading\",\n-                      || metadata::macro_import::read_macro_defs(sess, &krate));\n+                      || macro_import::read_macro_defs(sess, &cstore, &krate));\n \n     let mut addl_plugins = Some(addl_plugins);\n     let registrars = time(time_passes, \"plugin loading\", || {\n-        plugin::load::load_plugins(sess, &krate, addl_plugins.take().unwrap())\n+        plugin::load::load_plugins(sess, &cstore, &krate, addl_plugins.take().unwrap())\n     });\n \n     let mut registry = Registry::new(sess, &krate);\n@@ -670,6 +675,7 @@ pub fn make_map<'ast>(sess: &Session,\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n+                                               cstore: &CStore,\n                                                ast_map: front::map::Map<'tcx>,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                name: &str,\n@@ -683,7 +689,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     time(time_passes,\n          \"external crate/lib resolution\",\n-         || LocalCrateReader::new(sess, &ast_map).read_crates(krate));\n+         || LocalCrateReader::new(sess, cstore, &ast_map).read_crates(krate));\n \n     let lang_items = time(time_passes,\n                           \"language item collection\","}, {"sha": "3a91b573fd4aa8db3abb4bf82611d0926ea6f060", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -33,6 +33,7 @@\n #![feature(set_stdio)]\n #![feature(staged_api)]\n #![feature(vec_push_all)]\n+#![feature(raw)] // remove after snapshot\n \n extern crate arena;\n extern crate flate;\n@@ -44,7 +45,9 @@ extern crate rustc_back;\n extern crate rustc_borrowck;\n extern crate rustc_front;\n extern crate rustc_lint;\n+extern crate rustc_plugin;\n extern crate rustc_privacy;\n+extern crate rustc_metadata;\n extern crate rustc_mir;\n extern crate rustc_resolve;\n extern crate rustc_trans;\n@@ -66,9 +69,11 @@ use rustc_trans::back::link;\n use rustc_trans::save;\n use rustc::session::{config, Session, build_session};\n use rustc::session::config::{Input, PrintRequest, OutputType};\n+use rustc::middle::cstore::CrateStore;\n use rustc::lint::Lint;\n use rustc::lint;\n-use rustc::metadata;\n+use rustc_metadata::loader;\n+use rustc_metadata::cstore::CStore;\n use rustc::util::common::time;\n \n use std::cmp::Ordering::Equal;\n@@ -77,6 +82,7 @@ use std::io::{self, Read, Write};\n use std::iter::repeat;\n use std::path::PathBuf;\n use std::process;\n+use std::rc::Rc;\n use std::str;\n use std::sync::{Arc, Mutex};\n use std::thread;\n@@ -87,6 +93,7 @@ use syntax::ast;\n use syntax::parse;\n use syntax::diagnostic::Emitter;\n use syntax::diagnostics;\n+use syntax::parse::token;\n \n #[cfg(test)]\n pub mod test;\n@@ -99,6 +106,23 @@ pub mod target_features;\n const BUG_REPORT_URL: &'static str = \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.\\\n                                       md#bug-reports\";\n \n+// SNAP 1af31d4\n+// This is a terrible hack. Our stage0 is older than 1.4 and does not\n+// support DST coercions, so this function performs the corecion\n+// manually. This should go away.\n+pub fn cstore_to_cratestore(a: Rc<CStore>) -> Rc<for<'s> CrateStore<'s>>\n+{\n+    use std::mem;\n+    use std::raw::TraitObject;\n+    unsafe {\n+        let TraitObject { vtable, .. } =\n+            mem::transmute::<&for<'s> CrateStore<'s>, TraitObject>(&*a);\n+        mem::transmute(TraitObject {\n+            data: mem::transmute(a),\n+            vtable: vtable\n+        })\n+    }\n+}\n \n pub fn run(args: Vec<String>) -> isize {\n     monitor(move || run_compiler(&args, &mut RustcDefaultCalls));\n@@ -135,7 +159,9 @@ pub fn run_compiler<'a>(args: &[String], callbacks: &mut CompilerCalls<'a>) {\n         },\n     };\n \n-    let mut sess = build_session(sopts, input_file_path, descriptions);\n+    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+    let cstore_ = cstore_to_cratestore(cstore.clone());\n+    let mut sess = build_session(sopts, input_file_path, descriptions, cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     if sess.unstable_options() {\n         sess.opts.show_span = matches.opt_str(\"show-span\");\n@@ -150,7 +176,7 @@ pub fn run_compiler<'a>(args: &[String], callbacks: &mut CompilerCalls<'a>) {\n     let pretty = callbacks.parse_pretty(&sess, &matches);\n     match pretty {\n         Some((ppm, opt_uii)) => {\n-            pretty::pretty_print_input(sess, cfg, &input, ppm, opt_uii, ofile);\n+            pretty::pretty_print_input(sess, &cstore, cfg, &input, ppm, opt_uii, ofile);\n             return;\n         }\n         None => {\n@@ -160,7 +186,8 @@ pub fn run_compiler<'a>(args: &[String], callbacks: &mut CompilerCalls<'a>) {\n \n     let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n     let control = callbacks.build_controller(&sess);\n-    driver::compile_input(sess, cfg, &input, &odir, &ofile, Some(plugins), control);\n+    driver::compile_input(sess, &cstore, cfg, &input, &odir, &ofile,\n+                          Some(plugins), control);\n }\n \n // Extract output directory and file from matches.\n@@ -329,7 +356,9 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                     describe_lints(&ls, false);\n                     return None;\n                 }\n-                let sess = build_session(sopts.clone(), None, descriptions.clone());\n+                let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+                let cstore_ = cstore_to_cratestore(cstore.clone());\n+                let sess = build_session(sopts.clone(), None, descriptions.clone(), cstore_);\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let should_stop = RustcDefaultCalls::print_crate_info(&sess, None, odir, ofile);\n                 if should_stop == Compilation::Stop {\n@@ -423,7 +452,7 @@ impl RustcDefaultCalls {\n                 &Input::File(ref ifile) => {\n                     let path = &(*ifile);\n                     let mut v = Vec::new();\n-                    metadata::loader::list_file_metadata(&sess.target.target, path, &mut v)\n+                    loader::list_file_metadata(&sess.target.target, path, &mut v)\n                         .unwrap();\n                     println!(\"{}\", String::from_utf8(v).unwrap());\n                 }"}, {"sha": "630c42db68c79051d987b8f4a1f3d34f411b912f", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -27,6 +27,7 @@ use rustc::session::config::Input;\n use rustc_borrowck as borrowck;\n use rustc_borrowck::graphviz as borrowck_dot;\n use rustc_resolve as resolve;\n+use rustc_metadata::cstore::CStore;\n \n use syntax::ast;\n use syntax::codemap;\n@@ -167,6 +168,7 @@ impl PpSourceMode {\n     }\n     fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n                                                sess: &'tcx Session,\n+                                               cstore: &CStore,\n                                                ast_map: &hir_map::Map<'tcx>,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                id: &str,\n@@ -193,6 +195,7 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 driver::phase_3_run_analysis_passes(sess,\n+                                                    cstore,\n                                                     ast_map.clone(),\n                                                     arenas,\n                                                     id,\n@@ -668,6 +671,7 @@ impl fold::Folder for ReplaceBodyWithLoop {\n }\n \n pub fn pretty_print_input(sess: Session,\n+                          cstore: &CStore,\n                           cfg: ast::CrateConfig,\n                           input: &Input,\n                           ppm: PpMode,\n@@ -687,7 +691,7 @@ pub fn pretty_print_input(sess: Session,\n     let is_expanded = needs_expansion(&ppm);\n     let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n     let krate = if compute_ast_map {\n-        match driver::phase_2_configure_and_expand(&sess, krate, &id[..], None) {\n+        match driver::phase_2_configure_and_expand(&sess, &cstore, krate, &id[..], None) {\n             None => return,\n             Some(k) => driver::assign_node_ids(&sess, k),\n         }\n@@ -741,6 +745,7 @@ pub fn pretty_print_input(sess: Session,\n         (PpmHir(s), None) => {\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(&sess,\n+                                       cstore,\n                                        &ast_map.unwrap(),\n                                        &arenas,\n                                        &id,\n@@ -762,6 +767,7 @@ pub fn pretty_print_input(sess: Session,\n         (PpmHir(s), Some(uii)) => {\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(&sess,\n+                                       cstore,\n                                        &ast_map.unwrap(),\n                                        &arenas,\n                                        &id,\n@@ -811,6 +817,7 @@ pub fn pretty_print_input(sess: Session,\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n                     driver::phase_3_run_analysis_passes(&sess,\n+                                                        &cstore,\n                                                         ast_map,\n                                                         &arenas,\n                                                         &id,"}, {"sha": "2fb23c943c76a3fe327376b2369d50efa3974424", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -29,8 +29,10 @@ use rustc_typeck::middle::infer::{self, TypeOrigin};\n use rustc_typeck::middle::infer::lub::Lub;\n use rustc_typeck::middle::infer::glb::Glb;\n use rustc_typeck::middle::infer::sub::Sub;\n+use rustc_metadata::cstore::CStore;\n use rustc::front::map as hir_map;\n use rustc::session::{self, config};\n+use std::rc::Rc;\n use syntax::{abi, ast};\n use syntax::codemap;\n use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n@@ -107,12 +109,14 @@ fn test_env<F>(source_string: &str,\n     let diagnostic_handler = diagnostic::Handler::with_emitter(true, emitter);\n     let span_diagnostic_handler = diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n \n-    let sess = session::build_session_(options, None, span_diagnostic_handler);\n+    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+    let sess = session::build_session_(options, None, span_diagnostic_handler,\n+                                       cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let krate_config = Vec::new();\n     let input = config::Input::Str(source_string.to_string());\n     let krate = driver::phase_1_parse_input(&sess, krate_config, &input);\n-    let krate = driver::phase_2_configure_and_expand(&sess, krate, \"test\", None)\n+    let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate, \"test\", None)\n                     .expect(\"phase 2 aborted\");\n \n     let krate = driver::assign_node_ids(&sess, krate);"}, {"sha": "739c5f12ecb30ed35c9b343f5d6782eec1b55201", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -28,8 +28,8 @@\n //! Use the former for unit-like structs and the latter for structs with\n //! a `pub fn new()`.\n \n-use metadata::decoder;\n use middle::{cfg, def, infer, stability, traits};\n+use middle::cstore::CrateStore;\n use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n@@ -936,8 +936,8 @@ impl LateLintPass for PluginAsLibrary {\n             _ => return,\n         };\n \n-        let md = match cx.sess().cstore.find_extern_mod_stmt_cnum(it.id) {\n-            Some(cnum) => cx.sess().cstore.get_crate_data(cnum),\n+        let prfn = match cx.sess().cstore.extern_mod_stmt_cnum(it.id) {\n+            Some(cnum) => cx.sess().cstore.plugin_registrar_fn(cnum),\n             None => {\n                 // Probably means we aren't linking the crate for some reason.\n                 //\n@@ -946,7 +946,7 @@ impl LateLintPass for PluginAsLibrary {\n             }\n         };\n \n-        if decoder::get_plugin_registrar_fn(md.data()).is_some() {\n+        if prfn.is_some() {\n             cx.span_lint(PLUGIN_AS_LIBRARY, it.span,\n                          \"compiler plugin used as an ordinary library\");\n         }"}, {"sha": "1d7431404f54550148a1157a24ed940517316cb0", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -13,7 +13,7 @@\n //! This currently only contains the definitions and implementations\n //! of most of the lints that `rustc` supports directly, it does not\n //! contain the infrastructure for defining/registering lints. That is\n-//! available in `rustc::lint` and `rustc::plugin` respectively.\n+//! available in `rustc::lint` and `rustc_plugin` respectively.\n //!\n //! # Note\n //!\n@@ -50,7 +50,6 @@ extern crate rustc_front;\n extern crate rustc_back;\n \n pub use rustc::lint as lint;\n-pub use rustc::metadata as metadata;\n pub use rustc::middle as middle;\n pub use rustc::session as session;\n pub use rustc::util as util;"}, {"sha": "b8750cccb4b729d7c4f78bb21a4c121fdbaddc25", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use metadata::csearch;\n use middle::pat_util;\n use middle::ty;\n use middle::ty::adjustment;\n-use rustc::front::map as hir_map;\n use util::nodemap::FnvHashMap;\n use lint::{LateContext, EarlyContext, LintContext, LintArray};\n use lint::{LintPass, EarlyLintPass, LateLintPass};\n@@ -138,16 +136,8 @@ impl LateLintPass for UnusedResults {\n             ty::TyBool => return,\n             ty::TyStruct(def, _) |\n             ty::TyEnum(def, _) => {\n-                if let Some(def_node_id) = cx.tcx.map.as_local_node_id(def.did) {\n-                    if let hir_map::NodeItem(it) = cx.tcx.map.get(def_node_id) {\n-                        check_must_use(cx, &it.attrs, s.span)\n-                    } else {\n-                        false\n-                    }\n-                } else {\n-                    let attrs = csearch::get_item_attrs(&cx.sess().cstore, def.did);\n-                    check_must_use(cx, &attrs[..], s.span)\n-                }\n+                let attrs = cx.tcx.get_attrs(def.did);\n+                check_must_use(cx, &attrs[..], s.span)\n             }\n             _ => false,\n         };\n@@ -459,4 +449,3 @@ impl LateLintPass for UnusedAllocation {\n         }\n     }\n }\n-"}, {"sha": "2ecf715424b16cbde1e4885f213146e7e5c8e1c9", "filename": "src/librustc_metadata/astencode.rs", "status": "renamed", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -12,19 +12,21 @@\n // FIXME: remove this after snapshot, and Results are handled\n #![allow(unused_must_use)]\n \n-use front::map as ast_map;\n+use rustc::front::map as ast_map;\n+use rustc::session::Session;\n+\n use rustc_front::hir;\n use rustc_front::fold;\n use rustc_front::fold::Folder;\n \n-use metadata::common as c;\n-use metadata::cstore as cstore;\n-use session::Session;\n-use metadata::decoder;\n-use metadata::encoder as e;\n-use metadata::inline::{InlinedItem, InlinedItemRef};\n-use metadata::tydecode;\n-use metadata::tyencode;\n+use common as c;\n+use cstore;\n+use decoder;\n+use encoder as e;\n+use tydecode;\n+use tyencode;\n+\n+use middle::cstore::{InlinedItem, InlinedItemRef};\n use middle::ty::adjustment;\n use middle::ty::cast;\n use middle::check_const::ConstQualif;\n@@ -89,7 +91,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n \n     // Folding could be avoided with a smarter encoder.\n     let ii = simplify_ast(ii);\n-    let id_range = ii.compute_id_range();\n+    let id_range = inlined_item_id_range(&ii);\n \n     rbml_w.start_tag(c::tag_ast as usize);\n     id_range.encode(rbml_w);\n@@ -1326,6 +1328,12 @@ fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem, orig_did: DefId) {\n     }\n }\n \n+fn inlined_item_id_range(v: &InlinedItem) -> ast_util::IdRange {\n+    let mut visitor = ast_util::IdRangeComputingVisitor::new();\n+    v.visit_ids(&mut visitor);\n+    visitor.result()\n+}\n+\n // ______________________________________________________________________\n // Testing of astencode_gen\n ", "previous_filename": "src/librustc/middle/astencode.rs"}, {"sha": "b6454a4c81a2f8ce4aeee63dc3481ba7da670cdf", "filename": "src/librustc_metadata/common.rs", "status": "renamed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -12,8 +12,6 @@\n \n pub use self::astencode_tag::*;\n \n-use back::svh::Svh;\n-\n // RBML enum definitions and utils shared by the encoder and decoder\n //\n // 0x00..0x1f: reserved for RBML generic type tags\n@@ -191,12 +189,6 @@ pub const tag_items_data_item_stability: usize = 0x88;\n \n pub const tag_items_data_item_repr: usize = 0x89;\n \n-#[derive(Clone, Debug)]\n-pub struct LinkMeta {\n-    pub crate_name: String,\n-    pub crate_hash: Svh,\n-}\n-\n pub const tag_struct_fields: usize = 0x10d; // top-level only\n pub const tag_struct_field: usize = 0x8a;\n ", "previous_filename": "src/librustc/metadata/common.rs"}, {"sha": "4420da5f9b87dfd3f7d77fcb18f73d24381e1b27", "filename": "src/librustc_metadata/creader.rs", "status": "renamed", "additions": 42, "deletions": 59, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -12,17 +12,17 @@\n \n //! Validates all used crates and extern libraries and loads their metadata\n \n-use back::svh::Svh;\n-use session::{config, Session};\n-use session::search_paths::PathKind;\n-use metadata::common::rustc_version;\n-use metadata::cstore;\n-use metadata::cstore::{CStore, CrateSource, MetadataBlob};\n-use metadata::decoder;\n-use metadata::loader;\n-use metadata::loader::CratePaths;\n-use util::nodemap::FnvHashMap;\n-use front::map as hir_map;\n+use common::rustc_version;\n+use cstore::{self, CStore, CrateSource, MetadataBlob};\n+use decoder;\n+use loader::{self, CratePaths};\n+\n+use rustc::back::svh::Svh;\n+use rustc::session::{config, Session};\n+use rustc::session::search_paths::PathKind;\n+use rustc::middle::cstore::{CrateStore, validate_crate_name};\n+use rustc::util::nodemap::FnvHashMap;\n+use rustc::front::map as hir_map;\n \n use std::cell::{RefCell, Cell};\n use std::path::PathBuf;\n@@ -43,12 +43,14 @@ use log;\n \n pub struct LocalCrateReader<'a, 'b:'a> {\n     sess: &'a Session,\n+    cstore: &'a CStore,\n     creader: CrateReader<'a>,\n     ast_map: &'a hir_map::Map<'b>,\n }\n \n pub struct CrateReader<'a> {\n     sess: &'a Session,\n+    cstore: &'a CStore,\n     next_crate_num: ast::CrateNum,\n     foreign_item_map: FnvHashMap<String, Vec<ast::NodeId>>,\n }\n@@ -89,30 +91,8 @@ struct CrateInfo {\n     should_link: bool,\n }\n \n-pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n-    let say = |s: &str| {\n-        match (sp, sess) {\n-            (_, None) => panic!(\"{}\", s),\n-            (Some(sp), Some(sess)) => sess.span_err(sp, s),\n-            (None, Some(sess)) => sess.err(s),\n-        }\n-    };\n-    if s.is_empty() {\n-        say(\"crate name must not be empty\");\n-    }\n-    for c in s.chars() {\n-        if c.is_alphanumeric() { continue }\n-        if c == '_'  { continue }\n-        say(&format!(\"invalid character `{}` in crate name: `{}`\", c, s));\n-    }\n-    match sess {\n-        Some(sess) => sess.abort_if_errors(),\n-        None => {}\n-    }\n-}\n-\n-\n fn register_native_lib(sess: &Session,\n+                       cstore: &CStore,\n                        span: Option<Span>,\n                        name: String,\n                        kind: cstore::NativeLibraryKind) {\n@@ -139,7 +119,7 @@ fn register_native_lib(sess: &Session,\n             None => sess.err(msg),\n         }\n     }\n-    sess.cstore.add_used_library(name, kind);\n+    cstore.add_used_library(name, kind);\n }\n \n // Extra info about a crate loaded for plugins or exported macros.\n@@ -164,10 +144,11 @@ impl PMDSource {\n }\n \n impl<'a> CrateReader<'a> {\n-    pub fn new(sess: &'a Session) -> CrateReader<'a> {\n+    pub fn new(sess: &'a Session, cstore: &'a CStore) -> CrateReader<'a> {\n         CrateReader {\n             sess: sess,\n-            next_crate_num: sess.cstore.next_crate_num(),\n+            cstore: cstore,\n+            next_crate_num: cstore.next_crate_num(),\n             foreign_item_map: FnvHashMap(),\n         }\n     }\n@@ -224,7 +205,7 @@ impl<'a> CrateReader<'a> {\n     fn existing_match(&self, name: &str, hash: Option<&Svh>, kind: PathKind)\n                       -> Option<ast::CrateNum> {\n         let mut ret = None;\n-        self.sess.cstore.iter_crate_data(|cnum, data| {\n+        self.cstore.iter_crate_data(|cnum, data| {\n             if data.name != name { return }\n \n             match hash {\n@@ -242,7 +223,7 @@ impl<'a> CrateReader<'a> {\n             // We're also sure to compare *paths*, not actual byte slices. The\n             // `source` stores paths which are normalized which may be different\n             // from the strings on the command line.\n-            let source = self.sess.cstore.get_used_crate_source(cnum).unwrap();\n+            let source = self.cstore.used_crate_source(cnum);\n             if let Some(locs) = self.sess.opts.externs.get(name) {\n                 let found = locs.iter().any(|l| {\n                     let l = fs::canonicalize(l).ok();\n@@ -342,8 +323,8 @@ impl<'a> CrateReader<'a> {\n             cnum: cnum,\n         };\n \n-        self.sess.cstore.set_crate_data(cnum, cmeta.clone());\n-        self.sess.cstore.add_used_crate_source(source.clone());\n+        self.cstore.set_crate_data(cnum, cmeta.clone());\n+        self.cstore.add_used_crate_source(source.clone());\n         (cnum, cmeta, source)\n     }\n \n@@ -398,7 +379,7 @@ impl<'a> CrateReader<'a> {\n                 let meta_hash = decoder::get_crate_hash(library.metadata\n                                                                .as_slice());\n                 let mut result = LookupResult::Loaded(library);\n-                self.sess.cstore.iter_crate_data(|cnum, data| {\n+                self.cstore.iter_crate_data(|cnum, data| {\n                     if data.name() == name && meta_hash == data.hash() {\n                         assert!(hash.is_none());\n                         result = LookupResult::Previous(cnum);\n@@ -410,11 +391,11 @@ impl<'a> CrateReader<'a> {\n \n         match result {\n             LookupResult::Previous(cnum) => {\n-                let data = self.sess.cstore.get_crate_data(cnum);\n+                let data = self.cstore.get_crate_data(cnum);\n                 if explicitly_linked && !data.explicitly_linked.get() {\n                     data.explicitly_linked.set(explicitly_linked);\n                 }\n-                (cnum, data, self.sess.cstore.get_used_crate_source(cnum).unwrap())\n+                (cnum, data, self.cstore.used_crate_source(cnum))\n             }\n             LookupResult::Loaded(library) => {\n                 self.register_crate(root, ident, name, span, library,\n@@ -512,7 +493,7 @@ impl<'a> CrateReader<'a> {\n         let source_name = format!(\"<{} macros>\", item.ident);\n         let mut macros = vec![];\n         decoder::each_exported_macro(ekrate.metadata.as_slice(),\n-                                     &*self.sess.cstore.intr,\n+                                     &*self.cstore.intr,\n             |name, attrs, body| {\n                 // NB: Don't use parse::parse_tts_from_source_str because it parses with\n                 // quote_depth > 0.\n@@ -593,14 +574,14 @@ impl<'a> CrateReader<'a> {\n     }\n \n     fn register_statically_included_foreign_items(&mut self) {\n-        let libs = self.sess.cstore.get_used_libraries();\n+        let libs = self.cstore.get_used_libraries();\n         for (lib, list) in self.foreign_item_map.iter() {\n             let is_static = libs.borrow().iter().any(|&(ref name, kind)| {\n                 lib == name && kind == cstore::NativeStatic\n             });\n             if is_static {\n                 for id in list {\n-                    self.sess.cstore.add_statically_included_foreign_item(*id);\n+                    self.cstore.add_statically_included_foreign_item(*id);\n                 }\n             }\n         }\n@@ -614,7 +595,7 @@ impl<'a> CrateReader<'a> {\n         // also bail out as we don't need to implicitly inject one.\n         let mut needs_allocator = false;\n         let mut found_required_allocator = false;\n-        self.sess.cstore.iter_crate_data(|cnum, data| {\n+        self.cstore.iter_crate_data(|cnum, data| {\n             needs_allocator = needs_allocator || data.needs_allocator();\n             if data.is_allocator() {\n                 debug!(\"{} required by rlib and is an allocator\", data.name());\n@@ -693,7 +674,7 @@ impl<'a> CrateReader<'a> {\n         //\n         // Here we inject a dependency from all crates with #![needs_allocator]\n         // to the crate tagged with #![allocator] for this compilation unit.\n-        self.sess.cstore.iter_crate_data(|cnum, data| {\n+        self.cstore.iter_crate_data(|cnum, data| {\n             if !data.needs_allocator() {\n                 return\n             }\n@@ -707,10 +688,10 @@ impl<'a> CrateReader<'a> {\n \n         fn validate(me: &CrateReader, krate: ast::CrateNum,\n                     allocator: ast::CrateNum) {\n-            let data = me.sess.cstore.get_crate_data(krate);\n+            let data = me.cstore.get_crate_data(krate);\n             if data.needs_allocator() {\n                 let krate_name = data.name();\n-                let data = me.sess.cstore.get_crate_data(allocator);\n+                let data = me.cstore.get_crate_data(allocator);\n                 let alloc_name = data.name();\n                 me.sess.err(&format!(\"the allocator crate `{}` cannot depend \\\n                                       on a crate that needs an allocator, but \\\n@@ -726,10 +707,12 @@ impl<'a> CrateReader<'a> {\n }\n \n impl<'a, 'b> LocalCrateReader<'a, 'b> {\n-    pub fn new(sess: &'a Session, map: &'a hir_map::Map<'b>) -> LocalCrateReader<'a, 'b> {\n+    pub fn new(sess: &'a Session, cstore: &'a CStore,\n+               map: &'a hir_map::Map<'b>) -> LocalCrateReader<'a, 'b> {\n         LocalCrateReader {\n             sess: sess,\n-            creader: CrateReader::new(sess),\n+            cstore: cstore,\n+            creader: CrateReader::new(sess, cstore),\n             ast_map: map,\n         }\n     }\n@@ -743,19 +726,19 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n         self.creader.inject_allocator_crate();\n \n         if log_enabled!(log::INFO) {\n-            dump_crates(&self.sess.cstore);\n+            dump_crates(&self.cstore);\n         }\n \n         for &(ref name, kind) in &self.sess.opts.libs {\n-            register_native_lib(self.sess, None, name.clone(), kind);\n+            register_native_lib(self.sess, self.cstore, None, name.clone(), kind);\n         }\n         self.creader.register_statically_included_foreign_items();\n     }\n \n     fn process_crate(&self, c: &hir::Crate) {\n         for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n             match a.value_str() {\n-                Some(ref linkarg) => self.sess.cstore.add_used_link_args(&linkarg),\n+                Some(ref linkarg) => self.cstore.add_used_link_args(&linkarg),\n                 None => { /* fallthrough */ }\n             }\n         }\n@@ -783,7 +766,7 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n                         self.ast_map.with_path(i.id, |path| {\n                             cmeta.update_local_path(path)\n                         });\n-                        self.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n+                        self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n                     }\n                     None => ()\n                 }\n@@ -801,7 +784,7 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n         // First, add all of the custom #[link_args] attributes\n         for m in i.attrs.iter().filter(|a| a.check_name(\"link_args\")) {\n             if let Some(linkarg) = m.value_str() {\n-                self.sess.cstore.add_used_link_args(&linkarg);\n+                self.cstore.add_used_link_args(&linkarg);\n             }\n         }\n \n@@ -836,7 +819,7 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n                     InternedString::new(\"foo\")\n                 }\n             };\n-            register_native_lib(self.sess, Some(m.span), n.to_string(), kind);\n+            register_native_lib(self.sess, self.cstore, Some(m.span), n.to_string(), kind);\n         }\n \n         // Finally, process the #[linked_from = \"...\"] attribute", "previous_filename": "src/librustc/metadata/creader.rs"}, {"sha": "3c97692ee56eb5a4d205cc9ddc5d9c848464ee3d", "filename": "src/librustc_metadata/csearch.rs", "status": "added", "additions": 487, "deletions": 0, "changes": 487, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -0,0 +1,487 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use astencode;\n+use cstore;\n+use decoder;\n+use encoder;\n+use loader;\n+\n+use middle::cstore::{CrateStore, CrateSource, ChildItem, FoundAst};\n+use middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n+use middle::def;\n+use middle::lang_items;\n+use middle::ty::{self, Ty};\n+use middle::def_id::{DefId, DefIndex};\n+\n+use rustc::front::map as ast_map;\n+use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+use std::path::PathBuf;\n+use syntax::ast;\n+use syntax::attr;\n+use rustc_back::svh::Svh;\n+use rustc_back::target::Target;\n+use rustc_front::hir;\n+\n+impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n+    fn stability(&self, def: DefId) -> Option<attr::Stability>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_stability(&*cdata, def.index)\n+    }\n+\n+    fn closure_kind(&self, _tcx: &ty::ctxt<'tcx>, def_id: DefId) -> ty::ClosureKind\n+    {\n+        assert!(!def_id.is_local());\n+        let cdata = self.get_crate_data(def_id.krate);\n+        decoder::closure_kind(&*cdata, def_id.index)\n+    }\n+\n+    fn closure_ty(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx>\n+    {\n+        assert!(!def_id.is_local());\n+        let cdata = self.get_crate_data(def_id.krate);\n+        decoder::closure_ty(&*cdata, def_id.index, tcx)\n+    }\n+\n+    fn item_variances(&self, def: DefId) -> ty::ItemVariances {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_item_variances(&*cdata, def.index)\n+    }\n+\n+    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_repr_attrs(&*cdata, def.index)\n+    }\n+\n+    fn item_type(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                 -> ty::TypeScheme<'tcx>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_type(&*cdata, def.index, tcx)\n+    }\n+\n+    fn item_predicates(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                       -> ty::GenericPredicates<'tcx>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_predicates(&*cdata, def.index, tcx)\n+    }\n+\n+    fn item_super_predicates(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                             -> ty::GenericPredicates<'tcx>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_super_predicates(&*cdata, def.index, tcx)\n+    }\n+\n+    fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>\n+    {\n+        let cdata = self.get_crate_data(def_id.krate);\n+        decoder::get_item_attrs(&*cdata, def_id.index)\n+    }\n+\n+    fn item_symbol(&self, def: DefId) -> String\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_symbol(&cdata, def.index)\n+    }\n+\n+    fn trait_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_trait_def(&*cdata, def.index, tcx)\n+    }\n+\n+    fn adt_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_adt_def(&self.intr, &*cdata, def.index, tcx)\n+    }\n+\n+    fn method_arg_names(&self, did: DefId) -> Vec<String>\n+    {\n+        let cdata = self.get_crate_data(did.krate);\n+        decoder::get_method_arg_names(&cdata, did.index)\n+    }\n+\n+    fn item_path(&self, def: DefId) -> Vec<ast_map::PathElem> {\n+        let cdata = self.get_crate_data(def.krate);\n+        let path = decoder::get_item_path(&*cdata, def.index);\n+\n+        cdata.with_local_path(|cpath| {\n+            let mut r = Vec::with_capacity(cpath.len() + path.len());\n+            r.push_all(cpath);\n+            r.push_all(&path);\n+            r\n+        })\n+    }\n+\n+    fn item_name(&self, def: DefId) -> ast::Name {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_item_name(&self.intr, &cdata, def.index)\n+    }\n+\n+\n+    fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>\n+    {\n+        let mut result = vec![];\n+        let cdata = self.get_crate_data(def_id.krate);\n+        decoder::each_inherent_implementation_for_type(&*cdata, def_id.index,\n+                                                       |iid| result.push(iid));\n+        result\n+    }\n+\n+    fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId>\n+    {\n+        let mut result = vec![];\n+        self.iter_crate_data(|_, cdata| {\n+            decoder::each_implementation_for_trait(cdata, def_id, &mut |iid| {\n+                result.push(iid)\n+            })\n+        });\n+        result\n+    }\n+\n+    fn provided_trait_methods(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                              -> Vec<Rc<ty::Method<'tcx>>>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_provided_trait_methods(self.intr.clone(), &*cdata, def.index, tcx)\n+    }\n+\n+    fn trait_item_def_ids(&self, def: DefId)\n+                          -> Vec<ty::ImplOrTraitItemId>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_trait_item_def_ids(&*cdata, def.index)\n+    }\n+\n+    fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n+    {\n+        let cdata = self.get_crate_data(impl_def_id.krate);\n+        decoder::get_impl_items(&*cdata, impl_def_id.index)\n+    }\n+\n+    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_impl_polarity(&*cdata, def.index)\n+    }\n+\n+    fn impl_trait_ref(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                      -> Option<ty::TraitRef<'tcx>>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_impl_trait(&*cdata, def.index, tcx)\n+    }\n+\n+    fn custom_coerce_unsized_kind(&self, def: DefId)\n+                                  -> Option<ty::adjustment::CustomCoerceUnsized>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_custom_coerce_unsized_kind(&*cdata, def.index)\n+    }\n+\n+    // FIXME: killme\n+    fn associated_consts(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                         -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_associated_consts(self.intr.clone(), &*cdata, def.index, tcx)\n+    }\n+\n+    fn trait_of_item(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId) -> Option<DefId>\n+    {\n+        let cdata = self.get_crate_data(def_id.krate);\n+        decoder::get_trait_of_item(&*cdata, def_id.index, tcx)\n+    }\n+\n+    fn impl_or_trait_item(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                          -> ty::ImplOrTraitItem<'tcx>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_impl_or_trait_item(\n+            self.intr.clone(),\n+            &*cdata,\n+            def.index,\n+            tcx)\n+    }\n+\n+    fn is_const_fn(&self, did: DefId) -> bool\n+    {\n+        let cdata = self.get_crate_data(did.krate);\n+        decoder::is_const_fn(&cdata, did.index)\n+    }\n+\n+    fn is_defaulted_trait(&self, trait_def_id: DefId) -> bool\n+    {\n+        let cdata = self.get_crate_data(trait_def_id.krate);\n+        decoder::is_defaulted_trait(&*cdata, trait_def_id.index)\n+    }\n+\n+    fn is_impl(&self, did: DefId) -> bool\n+    {\n+        let cdata = self.get_crate_data(did.krate);\n+        decoder::is_impl(&*cdata, did.index)\n+    }\n+\n+    fn is_default_impl(&self, impl_did: DefId) -> bool {\n+        let cdata = self.get_crate_data(impl_did.krate);\n+        decoder::is_default_impl(&*cdata, impl_did.index)\n+    }\n+\n+    fn is_extern_fn(&self, tcx: &ty::ctxt<'tcx>, did: DefId) -> bool\n+    {\n+        let cdata = self.get_crate_data(did.krate);\n+        decoder::is_extern_fn(&*cdata, did.index, tcx)\n+    }\n+\n+    fn is_static(&self, did: DefId) -> bool\n+    {\n+        let cdata = self.get_crate_data(did.krate);\n+        decoder::is_static(&*cdata, did.index)\n+    }\n+\n+    fn is_static_method(&self, def: DefId) -> bool\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::is_static_method(&*cdata, def.index)\n+    }\n+\n+    fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool\n+    {\n+        self.do_is_statically_included_foreign_item(id)\n+    }\n+\n+    fn is_typedef(&self, did: DefId) -> bool {\n+        let cdata = self.get_crate_data(did.krate);\n+        decoder::is_typedef(&*cdata, did.index)\n+    }\n+\n+    fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n+                                -> Vec<(ast::CrateNum, LinkagePreference)>\n+    {\n+        let cdata = self.get_crate_data(cnum);\n+        decoder::get_dylib_dependency_formats(&cdata)\n+    }\n+\n+    fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>\n+    {\n+        let mut result = vec![];\n+        let crate_data = self.get_crate_data(cnum);\n+        decoder::each_lang_item(&*crate_data, |did, lid| {\n+            result.push((did, lid)); true\n+        });\n+        result\n+    }\n+\n+    fn missing_lang_items(&self, cnum: ast::CrateNum)\n+                          -> Vec<lang_items::LangItem>\n+    {\n+        let cdata = self.get_crate_data(cnum);\n+        decoder::get_missing_lang_items(&*cdata)\n+    }\n+\n+    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool\n+    {\n+        self.get_crate_data(cnum).staged_api\n+    }\n+\n+    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool\n+    {\n+        self.get_crate_data(cnum).explicitly_linked.get()\n+    }\n+\n+    fn is_allocator(&self, cnum: ast::CrateNum) -> bool\n+    {\n+        self.get_crate_data(cnum).is_allocator()\n+    }\n+\n+    fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>\n+    {\n+        decoder::get_crate_attributes(self.get_crate_data(cnum).data())\n+    }\n+\n+    fn crate_name(&self, cnum: ast::CrateNum) -> String\n+    {\n+        self.get_crate_data(cnum).name.clone()\n+    }\n+\n+    fn crate_hash(&self, cnum: ast::CrateNum) -> Svh\n+    {\n+        let cdata = self.get_crate_data(cnum);\n+        decoder::get_crate_hash(cdata.data())\n+    }\n+\n+    fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n+                                -> FnvHashMap<DefId, Vec<ast::Attribute>>\n+    {\n+        decoder::get_struct_field_attrs(&*self.get_crate_data(cnum))\n+    }\n+\n+    fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>\n+    {\n+        let cdata = self.get_crate_data(cnum);\n+        decoder::get_plugin_registrar_fn(cdata.data()).map(|index| DefId {\n+            krate: cnum,\n+            index: index\n+        })\n+    }\n+\n+    fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>\n+    {\n+        let cdata = self.get_crate_data(cnum);\n+        decoder::get_native_libraries(&*cdata)\n+    }\n+\n+    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId>\n+    {\n+        let cdata = self.get_crate_data(cnum);\n+        decoder::get_reachable_ids(&*cdata)\n+    }\n+\n+    fn def_path(&self, def: DefId) -> ast_map::DefPath\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        let path = decoder::def_path(&*cdata, def.index);\n+        let local_path = cdata.local_def_path();\n+        local_path.into_iter().chain(path).collect()\n+    }\n+\n+    fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>\n+    {\n+        let cdata = self.get_crate_data(did.krate);\n+        decoder::get_tuple_struct_definition_if_ctor(&*cdata, did.index)\n+    }\n+\n+    fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_struct_field_names(&self.intr, &*cdata, def.index)\n+    }\n+\n+    fn item_children(&self, def_id: DefId) -> Vec<ChildItem>\n+    {\n+        let mut result = vec![];\n+        let crate_data = self.get_crate_data(def_id.krate);\n+        let get_crate_data = |cnum| self.get_crate_data(cnum);\n+        decoder::each_child_of_item(\n+            self.intr.clone(), &*crate_data,\n+            def_id.index, get_crate_data,\n+            |def, name, vis| result.push(ChildItem {\n+                def: def,\n+                name: name,\n+                vis: vis\n+            }));\n+        result\n+    }\n+\n+    fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>\n+    {\n+        let mut result = vec![];\n+        let crate_data = self.get_crate_data(cnum);\n+        let get_crate_data = |cnum| self.get_crate_data(cnum);\n+        decoder::each_top_level_item_of_crate(\n+            self.intr.clone(), &*crate_data, get_crate_data,\n+            |def, name, vis| result.push(ChildItem {\n+                def: def,\n+                name: name,\n+                vis: vis\n+            }));\n+        result\n+    }\n+\n+    fn maybe_get_item_ast(&'tcx self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                          -> FoundAst<'tcx>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        let decode_inlined_item = Box::new(astencode::decode_inlined_item);\n+        decoder::maybe_get_item_ast(&*cdata, tcx, def.index, decode_inlined_item)\n+    }\n+\n+    fn crates(&self) -> Vec<ast::CrateNum>\n+    {\n+        let mut result = vec![];\n+        self.iter_crate_data(|cnum, _| result.push(cnum));\n+        result\n+    }\n+\n+    fn used_libraries(&self) -> Vec<(String, NativeLibraryKind)>\n+    {\n+        self.get_used_libraries().borrow().clone()\n+    }\n+\n+    fn used_link_args(&self) -> Vec<String>\n+    {\n+        self.get_used_link_args().borrow().clone()\n+    }\n+\n+    fn metadata_filename(&self) -> &str\n+    {\n+        loader::METADATA_FILENAME\n+    }\n+\n+    fn metadata_section_name(&self, target: &Target) -> &str\n+    {\n+        loader::meta_section_name(target)\n+    }\n+    fn encode_type(&self, tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Vec<u8>\n+    {\n+        encoder::encoded_ty(tcx, ty)\n+    }\n+\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>\n+    {\n+        self.do_get_used_crates(prefer)\n+    }\n+\n+    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource\n+    {\n+        self.opt_used_crate_source(cnum).unwrap()\n+    }\n+\n+    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>\n+    {\n+        self.do_extern_mod_stmt_cnum(emod_id)\n+    }\n+\n+    fn encode_metadata(&self,\n+                       tcx: &ty::ctxt<'tcx>,\n+                       reexports: &def::ExportMap,\n+                       item_symbols: &RefCell<NodeMap<String>>,\n+                       link_meta: &LinkMeta,\n+                       reachable: &NodeSet,\n+                       krate: &hir::Crate) -> Vec<u8>\n+    {\n+        let encode_inlined_item: encoder::EncodeInlinedItem =\n+            Box::new(|ecx, rbml_w, ii| astencode::encode_inlined_item(ecx, rbml_w, ii));\n+\n+        let encode_params = encoder::EncodeParams {\n+            diag: tcx.sess.diagnostic(),\n+            tcx: tcx,\n+            reexports: reexports,\n+            item_symbols: item_symbols,\n+            link_meta: link_meta,\n+            cstore: self,\n+            encode_inlined_item: encode_inlined_item,\n+            reachable: reachable\n+        };\n+        encoder::encode_metadata(encode_params, krate)\n+\n+    }\n+\n+    fn metadata_encoding_version(&self) -> &[u8]\n+    {\n+        encoder::metadata_encoding_version\n+    }\n+}"}, {"sha": "b0eef29467ba21b4db5faade747da69189d898bd", "filename": "src/librustc_metadata/cstore.rs", "status": "renamed", "additions": 25, "deletions": 48, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -14,13 +14,15 @@\n // crates and libraries\n \n pub use self::MetadataBlob::*;\n-pub use self::LinkagePreference::*;\n-pub use self::NativeLibraryKind::*;\n \n-use back::svh::Svh;\n-use metadata::{creader, decoder, index, loader};\n-use session::search_paths::PathKind;\n-use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n+use creader;\n+use decoder;\n+use index;\n+use loader;\n+\n+use rustc::back::svh::Svh;\n+use rustc::front::map as ast_map;\n+use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use std::cell::{RefCell, Ref, Cell};\n use std::rc::Rc;\n@@ -32,7 +34,10 @@ use syntax::codemap;\n use syntax::parse::token;\n use syntax::parse::token::IdentInterner;\n use syntax::util::small_vector::SmallVector;\n-use front::map as ast_map;\n+\n+pub use middle::cstore::{NativeLibraryKind, LinkagePreference};\n+pub use middle::cstore::{NativeStatic, NativeFramework, NativeUnknown};\n+pub use middle::cstore::{CrateSource, LinkMeta};\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n@@ -77,30 +82,6 @@ pub struct crate_metadata {\n     pub explicitly_linked: Cell<bool>,\n }\n \n-#[derive(Copy, Debug, PartialEq, Clone)]\n-pub enum LinkagePreference {\n-    RequireDynamic,\n-    RequireStatic,\n-}\n-\n-enum_from_u32! {\n-    #[derive(Copy, Clone, PartialEq)]\n-    pub enum NativeLibraryKind {\n-        NativeStatic,    // native static library (.a archive)\n-        NativeFramework, // OSX-specific\n-        NativeUnknown,   // default way to specify a dynamic library\n-    }\n-}\n-\n-// Where a crate came from on the local filesystem. One of these two options\n-// must be non-None.\n-#[derive(PartialEq, Clone)]\n-pub struct CrateSource {\n-    pub dylib: Option<(PathBuf, PathKind)>,\n-    pub rlib: Option<(PathBuf, PathKind)>,\n-    pub cnum: ast::CrateNum,\n-}\n-\n pub struct CStore {\n     metas: RefCell<FnvHashMap<ast::CrateNum, Rc<crate_metadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n@@ -112,10 +93,6 @@ pub struct CStore {\n     pub intr: Rc<IdentInterner>,\n }\n \n-/// Item definitions in the currently-compiled crate would have the CrateNum\n-/// LOCAL_CRATE in their DefId.\n-pub const LOCAL_CRATE: ast::CrateNum = 0;\n-\n impl CStore {\n     pub fn new(intr: Rc<IdentInterner>) -> CStore {\n         CStore {\n@@ -159,7 +136,7 @@ impl CStore {\n         I: FnMut(ast::CrateNum, &crate_metadata, Option<CrateSource>),\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n-            let origin = self.get_used_crate_source(k);\n+            let origin = self.opt_used_crate_source(k);\n             origin.as_ref().map(|cs| { assert!(k == cs.cnum); });\n             i(k, &**v, origin);\n         }\n@@ -172,8 +149,8 @@ impl CStore {\n         }\n     }\n \n-    pub fn get_used_crate_source(&self, cnum: ast::CrateNum)\n-                                     -> Option<CrateSource> {\n+    pub fn opt_used_crate_source(&self, cnum: ast::CrateNum)\n+                                 -> Option<CrateSource> {\n         self.used_crate_sources.borrow_mut()\n             .iter().find(|source| source.cnum == cnum).cloned()\n     }\n@@ -196,8 +173,8 @@ impl CStore {\n     // In order to get this left-to-right dependency ordering, we perform a\n     // topological sort of all crates putting the leaves at the right-most\n     // positions.\n-    pub fn get_used_crates(&self, prefer: LinkagePreference)\n-                           -> Vec<(ast::CrateNum, Option<PathBuf>)> {\n+    pub fn do_get_used_crates(&self, prefer: LinkagePreference)\n+                              -> Vec<(ast::CrateNum, Option<PathBuf>)> {\n         let mut ordering = Vec::new();\n         fn visit(cstore: &CStore, cnum: ast::CrateNum,\n                  ordering: &mut Vec<ast::CrateNum>) {\n@@ -216,8 +193,8 @@ impl CStore {\n         let mut libs = self.used_crate_sources.borrow()\n             .iter()\n             .map(|src| (src.cnum, match prefer {\n-                RequireDynamic => src.dylib.clone().map(|p| p.0),\n-                RequireStatic => src.rlib.clone().map(|p| p.0),\n+                LinkagePreference::RequireDynamic => src.dylib.clone().map(|p| p.0),\n+                LinkagePreference::RequireStatic => src.rlib.clone().map(|p| p.0),\n             }))\n             .collect::<Vec<_>>();\n         libs.sort_by(|&(a, _), &(b, _)| {\n@@ -255,18 +232,18 @@ impl CStore {\n         self.extern_mod_crate_map.borrow_mut().insert(emod_id, cnum);\n     }\n \n-    pub fn find_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId)\n-                                     -> Option<ast::CrateNum> {\n-        self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n-    }\n-\n     pub fn add_statically_included_foreign_item(&self, id: ast::NodeId) {\n         self.statically_included_foreign_items.borrow_mut().insert(id);\n     }\n \n-    pub fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool {\n+    pub fn do_is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool {\n         self.statically_included_foreign_items.borrow().contains(&id)\n     }\n+\n+    pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>\n+    {\n+        self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n+    }\n }\n \n impl crate_metadata {", "previous_filename": "src/librustc/metadata/cstore.rs"}, {"sha": "092f7849115c3eed714dc13438f7462cf6c1319e", "filename": "src/librustc_metadata/decoder.rs", "status": "renamed", "additions": 19, "deletions": 66, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -12,30 +12,27 @@\n \n #![allow(non_camel_case_types)]\n \n-pub use self::DefLike::*;\n use self::Family::*;\n \n-use front::map as hir_map;\n+use cstore::{self, crate_metadata};\n+use common::*;\n+use encoder::def_to_u64;\n+use index;\n+use tydecode::TyDecoder;\n+\n+use rustc::back::svh::Svh;\n+use rustc::front::map as hir_map;\n+use rustc::util::nodemap::FnvHashMap;\n use rustc_front::hir;\n \n-use back::svh::Svh;\n-use metadata::cstore::crate_metadata;\n-use metadata::cstore::LOCAL_CRATE;\n-use metadata::common::*;\n-use metadata::csearch::MethodInfo;\n-use metadata::csearch;\n-use metadata::cstore;\n-use metadata::encoder::def_to_u64;\n-use metadata::index;\n-use metadata::inline::InlinedItem;\n-use metadata::tydecode::TyDecoder;\n+use middle::cstore::{LOCAL_CRATE, FoundAst, InlinedItem, LinkagePreference};\n+use middle::cstore::{DefLike, DlDef, DlField, DlImpl};\n use middle::def;\n use middle::def_id::{DefId, DefIndex};\n use middle::lang_items;\n use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty::{self, RegionEscape, Ty};\n-use util::nodemap::FnvHashMap;\n \n use std::cell::{Cell, RefCell};\n use std::io::prelude::*;\n@@ -591,14 +588,6 @@ pub fn get_symbol_from_buf(data: &[u8], id: DefIndex) -> String {\n     item_symbol(doc)\n }\n \n-// Something that a name can resolve to.\n-#[derive(Copy, Clone, Debug)]\n-pub enum DefLike {\n-    DlDef(def::Def),\n-    DlImpl(DefId),\n-    DlField\n-}\n-\n /// Iterates over the language items in the given crate.\n pub fn each_lang_item<F>(cdata: Cmd, mut f: F) -> bool where\n     F: FnMut(DefIndex, usize) -> bool,\n@@ -771,24 +760,24 @@ pub type DecodeInlinedItem<'a> =\n \n pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: DefIndex,\n                                 mut decode_inlined_item: DecodeInlinedItem)\n-                                -> csearch::FoundAst<'tcx> {\n+                                -> FoundAst<'tcx> {\n     debug!(\"Looking up item: {:?}\", id);\n     let item_doc = cdata.lookup_item(id);\n     let item_did = item_def_id(item_doc, cdata);\n     let path = item_path(item_doc).split_last().unwrap().1.to_vec();\n     let def_path = def_path(cdata, id);\n     match decode_inlined_item(cdata, tcx, path, def_path, item_doc, item_did) {\n-        Ok(ii) => csearch::FoundAst::Found(ii),\n+        Ok(ii) => FoundAst::Found(ii),\n         Err((path, def_path)) => {\n             match item_parent_item(cdata, item_doc) {\n                 Some(did) => {\n                     let parent_item = cdata.lookup_item(did.index);\n                     match decode_inlined_item(cdata, tcx, path, def_path, parent_item, did) {\n-                        Ok(ii) => csearch::FoundAst::FoundParent(did, ii),\n-                        Err(_) => csearch::FoundAst::NotFound\n+                        Ok(ii) => FoundAst::FoundParent(did, ii),\n+                        Err(_) => FoundAst::NotFound\n                     }\n                 }\n-                None => csearch::FoundAst::NotFound\n+                None => FoundAst::NotFound\n             }\n         }\n     }\n@@ -997,42 +986,6 @@ pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n     }).collect()\n }\n \n-pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n-                                  cdata: Cmd,\n-                                  node_id: DefIndex)\n-                               -> Option<Vec<MethodInfo> > {\n-    let item = cdata.lookup_item(node_id);\n-    if item_family(item) != Impl {\n-        return None;\n-    }\n-\n-    // If this impl implements a trait, don't consider it.\n-    if reader::tagged_docs(item, tag_item_trait_ref).next().is_some() {\n-        return None;\n-    }\n-\n-    let impl_method_ids = reader::tagged_docs(item, tag_item_impl_item)\n-        .map(|impl_method_doc| item_def_id(impl_method_doc, cdata));\n-\n-    let mut impl_methods = Vec::new();\n-    for impl_method_id in impl_method_ids {\n-        let impl_method_doc = cdata.lookup_item(impl_method_id.index);\n-        let family = item_family(impl_method_doc);\n-        match family {\n-            StaticMethod | Method => {\n-                impl_methods.push(MethodInfo {\n-                    name: item_name(&*intr, impl_method_doc),\n-                    def_id: item_def_id(impl_method_doc, cdata),\n-                    vis: item_visibility(impl_method_doc),\n-                });\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    return Some(impl_methods);\n-}\n-\n /// If node_id is the constructor of a tuple struct, retrieve the NodeId of\n /// the actual type definition, otherwise, return None\n pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n@@ -1352,7 +1305,7 @@ pub fn each_exported_macro<F>(data: &[u8], intr: &IdentInterner, mut f: F) where\n }\n \n pub fn get_dylib_dependency_formats(cdata: Cmd)\n-    -> Vec<(ast::CrateNum, cstore::LinkagePreference)>\n+    -> Vec<(ast::CrateNum, LinkagePreference)>\n {\n     let formats = reader::get_doc(rbml::Doc::new(cdata.data()),\n                                   tag_dylib_dependency_formats);\n@@ -1369,9 +1322,9 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n             None => panic!(\"didn't find a crate in the cnum_map\")\n         };\n         result.push((cnum, if link == \"d\" {\n-            cstore::RequireDynamic\n+            LinkagePreference::RequireDynamic\n         } else {\n-            cstore::RequireStatic\n+            LinkagePreference::RequireStatic\n         }));\n     }\n     return result;", "previous_filename": "src/librustc/metadata/decoder.rs"}, {"sha": "2340efd2cae7ae8d6e84d8102fb1093ad1bf6930", "filename": "src/librustc_metadata/diagnostics.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdiagnostics.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+register_long_diagnostics! {\n+E0454: r##\"\n+A link name was given with an empty name. Erroneous code example:\n+\n+```\n+#[link(name = \"\")] extern {} // error: #[link(name = \"\")] given with empty name\n+```\n+\n+The rust compiler cannot link to an external library if you don't give it its\n+name. Example:\n+\n+```\n+#[link(name = \"some_lib\")] extern {} // ok!\n+```\n+\"##,\n+\n+E0458: r##\"\n+An unknown \"kind\" was specified for a link attribute. Erroneous code example:\n+\n+```\n+#[link(kind = \"wonderful_unicorn\")] extern {}\n+// error: unknown kind: `wonderful_unicorn`\n+```\n+\n+Please specify a valid \"kind\" value, from one of the following:\n+ * static\n+ * dylib\n+ * framework\n+\"##,\n+\n+E0459: r##\"\n+A link was used without a name parameter. Erroneous code example:\n+\n+```\n+#[link(kind = \"dylib\")] extern {}\n+// error: #[link(...)] specified without `name = \"foo\"`\n+```\n+\n+Please add the name parameter to allow the rust compiler to find the library\n+you want. Example:\n+\n+```\n+#[link(kind = \"dylib\", name = \"some_lib\")] extern {} // ok!\n+```\n+\"##,\n+\n+}\n+\n+register_diagnostics! {\n+    E0455, // native frameworks are only available on OSX targets\n+    E0456, // plugin `..` is not available for triple `..`\n+    E0457, // plugin `..` only found in rlib format, but must be available...\n+    E0514, // metadata version mismatch\n+    E0460, // found possibly newer version of crate `..`\n+    E0461, // couldn't find crate `..` with expected target triple ..\n+    E0462, // found staticlib `..` instead of rlib or dylib\n+    E0463, // can't find crate for `..`\n+    E0464, // multiple matching crates for `..`\n+    E0465, // multiple .. candidates for `..` found\n+    E0466, // bad macro import\n+    E0467, // bad macro reexport\n+    E0468, // an `extern crate` loading macros must be at the crate root\n+    E0469, // imported macro not found\n+    E0470, // reexported macro not found\n+}"}, {"sha": "1d88fa4454bda19f1bff4bde693d4d3513e7dac3", "filename": "src/librustc_metadata/encoder.rs", "status": "renamed", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -13,22 +13,25 @@\n #![allow(unused_must_use)] // everything is just a MemWriter, can't fail\n #![allow(non_camel_case_types)]\n \n-use back::svh::Svh;\n-use session::config;\n-use metadata::common::*;\n-use metadata::cstore;\n-use metadata::cstore::LOCAL_CRATE;\n-use metadata::decoder;\n-use metadata::tyencode;\n-use metadata::index::{self, IndexData};\n-use metadata::inline::InlinedItemRef;\n+use common::*;\n+use cstore;\n+use decoder;\n+use tyencode;\n+use index::{self, IndexData};\n+\n+use middle::cstore::{LOCAL_CRATE, CrateStore, InlinedItemRef, LinkMeta};\n use middle::def;\n use middle::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n use middle::stability;\n use middle::subst;\n use middle::ty::{self, Ty};\n-use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n+\n+use rustc::back::svh::Svh;\n+use rustc::front::map::{LinkedPath, PathElem, PathElems};\n+use rustc::front::map as ast_map;\n+use rustc::session::config;\n+use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use serialize::Encodable;\n use std::cell::RefCell;\n@@ -48,8 +51,6 @@ use rbml::writer::Encoder;\n use rustc_front::hir;\n use rustc_front::intravisit::Visitor;\n use rustc_front::intravisit;\n-use front::map::{LinkedPath, PathElem, PathElems};\n-use front::map as ast_map;\n \n pub type EncodeInlinedItem<'a> =\n     Box<FnMut(&EncodeContext, &mut Encoder, InlinedItemRef) + 'a>;\n@@ -1652,8 +1653,7 @@ fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n fn encode_native_libraries(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_native_libraries);\n \n-    for &(ref lib, kind) in ecx.tcx.sess.cstore.get_used_libraries()\n-                               .borrow().iter() {\n+    for &(ref lib, kind) in ecx.tcx.sess.cstore.used_libraries().iter() {\n         match kind {\n             cstore::NativeStatic => {} // these libraries are not propagated\n             cstore::NativeFramework | cstore::NativeUnknown => {", "previous_filename": "src/librustc/metadata/encoder.rs"}, {"sha": "60bbdaddd751607c7e75c1ffeade30db3d440852", "filename": "src/librustc_metadata/index.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "previous_filename": "src/librustc/metadata/index.rs"}, {"sha": "6affbd2b5936c4323a08192352ee29e915860c1f", "filename": "src/librustc_metadata/lib.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg_attr(stage0, feature(custom_attribute))]\n+#![crate_name = \"rustc_metadata\"]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![cfg_attr(stage0, staged_api)]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+\n+#![feature(box_patterns)]\n+#![feature(duration_span)]\n+#![feature(enumset)]\n+#![feature(quote)]\n+#![feature(staged_api)]\n+#![feature(vec_push_all)]\n+#![feature(rustc_diagnostic_macros)]\n+#![feature(rustc_private)]\n+\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n+#[macro_use] #[no_link] extern crate rustc_bitflags;\n+\n+extern crate flate;\n+extern crate rbml;\n+extern crate serialize;\n+\n+extern crate rustc;\n+extern crate rustc_back;\n+extern crate rustc_front;\n+extern crate rustc_llvm;\n+\n+pub use rustc::middle;\n+\n+#[macro_use]\n+mod macros;\n+\n+pub mod diagnostics;\n+\n+pub mod astencode;\n+pub mod common;\n+pub mod tyencode;\n+pub mod tydecode;\n+pub mod encoder;\n+pub mod decoder;\n+pub mod creader;\n+pub mod csearch;\n+pub mod cstore;\n+pub mod index;\n+pub mod loader;\n+pub mod macro_import;"}, {"sha": "72938a7660a53805c8d0ccc235ce8e59f1c97685", "filename": "src/librustc_metadata/loader.rs", "status": "renamed", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -212,19 +212,21 @@\n //! no means all of the necessary details. Take a look at the rest of\n //! metadata::loader or metadata::creader for all the juicy details!\n \n-use back::svh::Svh;\n-use session::Session;\n-use session::search_paths::PathKind;\n-use llvm;\n-use llvm::{False, ObjectFile, mk_section_iter};\n-use llvm::archive_ro::ArchiveRO;\n-use metadata::cstore::{MetadataBlob, MetadataVec, MetadataArchive};\n-use metadata::decoder;\n-use metadata::encoder;\n-use metadata::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n+use cstore::{MetadataBlob, MetadataVec, MetadataArchive};\n+use decoder;\n+use encoder;\n+\n+use rustc::back::svh::Svh;\n+use rustc::session::Session;\n+use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n+use rustc::session::search_paths::PathKind;\n+use rustc::util::common;\n+\n+use rustc_llvm as llvm;\n+use rustc_llvm::{False, ObjectFile, mk_section_iter};\n+use rustc_llvm::archive_ro::ArchiveRO;\n use syntax::codemap::Span;\n use syntax::diagnostic::SpanHandler;\n-use util::common;\n use rustc_back::target::Target;\n \n use std::cmp;", "previous_filename": "src/librustc/metadata/loader.rs"}, {"sha": "d67fc3a0eaba525acd0c792d8ff8af01f802fd47", "filename": "src/librustc_metadata/macro_import.rs", "status": "renamed", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -10,8 +10,10 @@\n \n //! Used by `rustc` when loading a crate with exported macros.\n \n-use session::Session;\n-use metadata::creader::CrateReader;\n+use creader::CrateReader;\n+use cstore::CStore;\n+\n+use rustc::session::Session;\n \n use std::collections::{HashSet, HashMap};\n use syntax::codemap::Span;\n@@ -30,11 +32,11 @@ struct MacroLoader<'a> {\n }\n \n impl<'a> MacroLoader<'a> {\n-    fn new(sess: &'a Session) -> MacroLoader<'a> {\n+    fn new(sess: &'a Session, cstore: &'a CStore) -> MacroLoader<'a> {\n         MacroLoader {\n             sess: sess,\n             span_whitelist: HashSet::new(),\n-            reader: CrateReader::new(sess),\n+            reader: CrateReader::new(sess, cstore),\n             macros: vec![],\n         }\n     }\n@@ -45,8 +47,10 @@ pub fn call_bad_macro_reexport(a: &Session, b: Span) {\n }\n \n /// Read exported macros.\n-pub fn read_macro_defs(sess: &Session, krate: &ast::Crate) -> Vec<ast::MacroDef> {\n-    let mut loader = MacroLoader::new(sess);\n+pub fn read_macro_defs(sess: &Session, cstore: &CStore, krate: &ast::Crate)\n+                       -> Vec<ast::MacroDef>\n+{\n+    let mut loader = MacroLoader::new(sess, cstore);\n \n     // We need to error on `#[macro_use] extern crate` when it isn't at the\n     // crate root, because `$crate` won't work properly. Identify these by", "previous_filename": "src/librustc/metadata/macro_import.rs"}, {"sha": "ed764ebd9f95dd4e27b579342fc0f4c66e77a486", "filename": "src/librustc_metadata/macros.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacros.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! enum_from_u32 {\n+    ($(#[$attr:meta])* pub enum $name:ident {\n+        $($variant:ident = $e:expr,)*\n+    }) => {\n+        $(#[$attr])*\n+        pub enum $name {\n+            $($variant = $e),*\n+        }\n+\n+        impl $name {\n+            pub fn from_u32(u: u32) -> Option<$name> {\n+                $(if u == $name::$variant as u32 {\n+                    return Some($name::$variant)\n+                })*\n+                None\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* pub enum $name:ident {\n+        $($variant:ident,)*\n+    }) => {\n+        $(#[$attr])*\n+        pub enum $name {\n+            $($variant,)*\n+        }\n+\n+        impl $name {\n+            pub fn from_u32(u: u32) -> Option<$name> {\n+                $(if u == $name::$variant as u32 {\n+                    return Some($name::$variant)\n+                })*\n+                None\n+            }\n+        }\n+    }\n+}"}, {"sha": "d03af6b672284b2accff9b886315e06aa71ad880", "filename": "src/librustc_metadata/tydecode.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "previous_filename": "src/librustc/metadata/tydecode.rs"}, {"sha": "bc1edd5c7671815d8fbb0ab473106ab95e6ee57a", "filename": "src/librustc_metadata/tyencode.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -23,7 +23,7 @@ use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::ParamTy;\n use middle::ty::{self, Ty};\n-use util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FnvHashMap;\n \n use rustc_front::hir;\n ", "previous_filename": "src/librustc/metadata/tyencode.rs"}, {"sha": "00f58c6af91554d8e63e6b1234e40be39413db70", "filename": "src/librustc_plugin/build.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "previous_filename": "src/librustc/plugin/build.rs"}, {"sha": "100c1db1439743e8bf62a99396904c5bab1431aa", "filename": "src/librustc_plugin/diagnostics.rs", "status": "renamed", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_plugin%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_plugin%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fdiagnostics.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,16 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub mod common;\n-pub mod tyencode;\n-pub mod tydecode;\n-pub mod encoder;\n-pub mod decoder;\n-pub mod creader;\n-pub mod cstore;\n-pub mod csearch;\n-pub mod index;\n-pub mod loader;\n-pub mod filesearch;\n-pub mod macro_import;\n-pub mod inline;\n+#![allow(non_snake_case)]\n+\n+register_long_diagnostics! {\n+\n+}\n+\n+register_diagnostics! {\n+    E0498  // malformed plugin attribute\n+}", "previous_filename": "src/librustc/metadata/mod.rs"}, {"sha": "5dedef7ab6c79b6d85f3eb461916b842cf5d38eb", "filename": "src/librustc_plugin/lib.rs", "status": "renamed", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -50,8 +50,32 @@\n //! See the [Plugins Chapter](../../book/compiler-plugins.html) of the book\n //! for more examples.\n \n+#![cfg_attr(stage0, feature(custom_attribute))]\n+#![crate_name = \"rustc_plugin\"]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![cfg_attr(stage0, staged_api)]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+\n+#![feature(dynamic_lib)]\n+#![feature(staged_api)]\n+#![feature(rustc_diagnostic_macros)]\n+#![feature(rustc_private)]\n+\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n+#[macro_use] #[no_link] extern crate rustc_bitflags;\n+\n+extern crate rustc;\n+extern crate rustc_front;\n+extern crate rustc_metadata;\n+\n pub use self::registry::Registry;\n \n+pub mod diagnostics;\n pub mod registry;\n pub mod load;\n pub mod build;", "previous_filename": "src/librustc/plugin/mod.rs"}, {"sha": "51eec07505a4297af17a2188965e0ff9a9e39d65", "filename": "src/librustc_plugin/load.rs", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -10,9 +10,10 @@\n \n //! Used by `rustc` when loading a plugin.\n \n-use session::Session;\n-use metadata::creader::CrateReader;\n-use plugin::registry::Registry;\n+use rustc::session::Session;\n+use rustc_metadata::creader::CrateReader;\n+use rustc_metadata::cstore::CStore;\n+use registry::Registry;\n \n use std::borrow::ToOwned;\n use std::env;\n@@ -43,9 +44,9 @@ fn call_malformed_plugin_attribute(a: &Session, b: Span) {\n }\n \n /// Read plugin metadata and dynamically load registrar functions.\n-pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n+pub fn load_plugins(sess: &Session, cstore: &CStore, krate: &ast::Crate,\n                     addl_plugins: Option<Vec<String>>) -> Vec<PluginRegistrar> {\n-    let mut loader = PluginLoader::new(sess);\n+    let mut loader = PluginLoader::new(sess, cstore);\n \n     for attr in &krate.attrs {\n         if !attr.check_name(\"plugin\") {\n@@ -81,10 +82,10 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n }\n \n impl<'a> PluginLoader<'a> {\n-    fn new(sess: &'a Session) -> PluginLoader<'a> {\n+    fn new(sess: &'a Session, cstore: &'a CStore) -> PluginLoader<'a> {\n         PluginLoader {\n             sess: sess,\n-            reader: CrateReader::new(sess),\n+            reader: CrateReader::new(sess, cstore),\n             plugins: vec![],\n         }\n     }", "previous_filename": "src/librustc/plugin/load.rs"}, {"sha": "3138d7fa1db56ff8ac4648cac363bad373618afd", "filename": "src/librustc_plugin/registry.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -10,8 +10,8 @@\n \n //! Used by plugin crates to tell `rustc` about the plugins they provide.\n \n-use lint::{EarlyLintPassObject, LateLintPassObject, LintId, Lint};\n-use session::Session;\n+use rustc::lint::{EarlyLintPassObject, LateLintPassObject, LintId, Lint};\n+use rustc::session::Session;\n \n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n use syntax::ext::base::{IdentTT, MultiModifier, MultiDecorator};", "previous_filename": "src/librustc/plugin/registry.rs"}, {"sha": "13f7e3181631a815b5975d77bc272471c42fda25", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 26, "deletions": 45, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -28,8 +28,7 @@ use {resolve_error, ResolutionError};\n \n use self::DuplicateCheckingMode::*;\n \n-use rustc::metadata::csearch;\n-use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n+use rustc::middle::cstore::{CrateStore, ChildItem, DlDef, DlField, DlImpl};\n use rustc::middle::def::*;\n use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n \n@@ -310,7 +309,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             ItemExternCrate(_) => {\n                 // n.b. we don't need to look at the path option here, because cstore already\n                 // did\n-                if let Some(crate_id) = self.session.cstore.find_extern_mod_stmt_cnum(item.id) {\n+                if let Some(crate_id) = self.session.cstore.extern_mod_stmt_cnum(item.id) {\n                     let def_id = DefId {\n                         krate: crate_id,\n                         index: CRATE_DEF_INDEX,\n@@ -625,7 +624,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             }\n             DefFn(ctor_id, true) => {\n                 child_name_bindings.define_value(\n-                csearch::get_tuple_struct_definition_if_ctor(&self.session.cstore, ctor_id)\n+                self.session.cstore.tuple_struct_definition_if_ctor(ctor_id)\n                     .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, modifiers);\n             }\n             DefFn(..) |\n@@ -654,11 +653,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 // If this is a trait, add all the trait item names to the trait\n                 // info.\n \n-                let trait_item_def_ids = csearch::get_trait_item_def_ids(&self.session.cstore,\n-                                                                         def_id);\n+                let trait_item_def_ids = self.session.cstore.trait_item_def_ids(def_id);\n                 for trait_item_def in &trait_item_def_ids {\n-                    let trait_item_name = csearch::get_trait_name(&self.session.cstore,\n-                                                                  trait_item_def.def_id());\n+                    let trait_item_name =\n+                        self.session.cstore.item_name(trait_item_def.def_id());\n \n                     debug!(\"(building reduced graph for external crate) ... adding trait item \\\n                             '{}'\",\n@@ -695,7 +693,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 debug!(\"(building reduced graph for external crate) building type and value for \\\n                         {}\",\n                        final_ident);\n-                let fields = csearch::get_struct_field_names(&self.session.cstore, def_id);\n+                child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+                let fields = self.session.cstore.struct_field_names(def_id);\n \n                 if fields.is_empty() {\n                     child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n@@ -719,39 +718,29 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_def(&mut self,\n                                                   root: &Rc<Module>,\n-                                                  def_like: DefLike,\n-                                                  name: Name,\n-                                                  def_visibility: Visibility) {\n-        match def_like {\n+                                                  xcdef: ChildItem) {\n+        match xcdef.def {\n             DlDef(def) => {\n                 // Add the new child item, if necessary.\n                 match def {\n                     DefForeignMod(def_id) => {\n                         // Foreign modules have no names. Recur and populate\n                         // eagerly.\n-                        csearch::each_child_of_item(&self.session.cstore,\n-                                                    def_id,\n-                                                    |def_like,\n-                                                     child_name,\n-                                                     vis| {\n-                            self.build_reduced_graph_for_external_crate_def(\n-                                root,\n-                                def_like,\n-                                child_name,\n-                                vis)\n-                        });\n+                        for child in self.session.cstore.item_children(def_id) {\n+                            self.build_reduced_graph_for_external_crate_def(root, child)\n+                        }\n                     }\n                     _ => {\n-                        let child_name_bindings = self.add_child(name,\n+                        let child_name_bindings = self.add_child(xcdef.name,\n                                                                  root,\n                                                                  OverwriteDuplicates,\n                                                                  DUMMY_SP);\n \n                         self.handle_external_def(def,\n-                                                 def_visibility,\n+                                                 xcdef.vis,\n                                                  &child_name_bindings,\n-                                                 &name.as_str(),\n-                                                 name,\n+                                                 &xcdef.name.as_str(),\n+                                                 xcdef.name,\n                                                  root);\n                     }\n                 }\n@@ -778,16 +767,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             Some(def_id) => def_id,\n         };\n \n-        csearch::each_child_of_item(&self.session.cstore,\n-                                    def_id,\n-                                    |def_like, child_name, visibility| {\n-                                        debug!(\"(populating external module) ... found ident: {}\",\n-                                               child_name);\n-                                        self.build_reduced_graph_for_external_crate_def(module,\n-                                                                                        def_like,\n-                                                                                        child_name,\n-                                                                                        visibility)\n-                                    });\n+        for child in self.session.cstore.item_children(def_id) {\n+            debug!(\"(populating external module) ... found ident: {}\",\n+                   child.name);\n+            self.build_reduced_graph_for_external_crate_def(module, child);\n+        }\n         module.populated.set(true)\n     }\n \n@@ -803,13 +787,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// Builds the reduced graph rooted at the 'use' directive for an external\n     /// crate.\n     fn build_reduced_graph_for_external_crate(&mut self, root: &Rc<Module>) {\n-        csearch::each_top_level_item_of_crate(&self.session.cstore,\n-                                              root.def_id()\n-                                                  .unwrap()\n-                                                  .krate,\n-                                              |def_like, name, visibility| {\n-            self.build_reduced_graph_for_external_crate_def(root, def_like, name, visibility)\n-        });\n+        let root_cnum = root.def_id().unwrap().krate;\n+        for child in self.session.cstore.crate_top_level_items(root_cnum) {\n+            self.build_reduced_graph_for_external_crate_def(root, child);\n+        }\n     }\n \n     /// Creates and adds an import directive to the given module."}, {"sha": "7f740f9c03335a26d127c2b22096ef298f774ce2", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n \n         match item.node {\n             hir::ItemExternCrate(_) => {\n-                if let Some(crate_num) = self.session.cstore.find_extern_mod_stmt_cnum(item.id) {\n+                if let Some(crate_num) = self.session.cstore.extern_mod_stmt_cnum(item.id) {\n                     if !self.used_crates.contains(&crate_num) {\n                         self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n                                               item.id,"}, {"sha": "ef03ac520df46d699662fb098dc9505958dc045b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -54,8 +54,7 @@ use self::FallbackChecks::*;\n use rustc::front::map as hir_map;\n use rustc::session::Session;\n use rustc::lint;\n-use rustc::metadata::csearch;\n-use rustc::metadata::decoder::{DefLike, DlDef};\n+use rustc::middle::cstore::{CrateStore, DefLike, DlDef};\n use rustc::middle::def::*;\n use rustc::middle::def_id::DefId;\n use rustc::middle::pat_util::pat_bindings_hygienic;\n@@ -1235,7 +1234,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if let Some(node_id) = self.ast_map.as_local_node_id(did) {\n             self.ast_map.expect_item(node_id).name\n         } else {\n-            csearch::get_trait_name(&self.session.cstore, did)\n+            self.session.cstore.item_name(did)\n         }\n     }\n \n@@ -3298,7 +3297,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n                 sig.explicit_self.node == hir::SelfStatic\n             } else {\n-                csearch::is_static_method(&this.session.cstore, did)\n+                this.session.cstore.is_static_method(did)\n             }\n         }\n "}, {"sha": "f5431554a75642547f975b38cd8237908199ef9d", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -21,10 +21,11 @@ use std::process::{Command, Output, Stdio};\n use std::ptr;\n use std::str;\n \n+use middle::cstore::CrateStore;\n+\n use libc;\n use llvm::archive_ro::{ArchiveRO, Child};\n use llvm::{self, ArchiveKind};\n-use rustc::metadata::loader::METADATA_FILENAME;\n use rustc::session::Session;\n use rustc_back::tempdir::TempDir;\n \n@@ -169,11 +170,13 @@ impl<'a> ArchiveBuilder<'a> {\n         // Ignoring all bytecode files, no matter of\n         // name\n         let bc_ext = \".bytecode.deflate\";\n+        let metadata_filename =\n+            self.config.sess.cstore.metadata_filename().to_owned();\n \n         self.add_archive(rlib, &name[..], move |fname: &str| {\n             let skip_obj = lto && fname.starts_with(&obj_start)\n                 && fname.ends_with(\".o\");\n-            skip_obj || fname.ends_with(bc_ext) || fname == METADATA_FILENAME\n+            skip_obj || fname.ends_with(bc_ext) || fname == metadata_filename\n         })\n     }\n "}, {"sha": "d7b4243afee21d8dbeb68eca822bde6a46343cdb", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -17,11 +17,11 @@ use super::svh::Svh;\n use session::config;\n use session::config::NoDebugInfo;\n use session::config::{OutputFilenames, Input, OutputType};\n+use session::filesearch;\n use session::search_paths::PathKind;\n use session::Session;\n-use metadata::common::LinkMeta;\n-use metadata::loader::METADATA_FILENAME;\n-use metadata::{encoder, cstore, filesearch, csearch, creader};\n+use middle::cstore::{self, CrateStore, LinkMeta};\n+use middle::cstore::{LinkagePreference, NativeLibraryKind};\n use middle::dependency_format::Linkage;\n use middle::ty::{self, Ty};\n use rustc::front::map::DefPath;\n@@ -137,7 +137,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n     let validate = |s: String, span: Option<Span>| {\n-        creader::validate_crate_name(sess, &s[..], span);\n+        cstore::validate_crate_name(sess, &s[..], span);\n         s\n     };\n \n@@ -216,7 +216,7 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n         symbol_hasher.input_str(&meta[..]);\n     }\n     symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input(&encoder::encoded_ty(tcx, t));\n+    symbol_hasher.input(&tcx.sess.cstore.encode_type(tcx, t));\n     // Prefix with 'h' so that it never blends into adjacent digits\n     let mut hash = String::from(\"h\");\n     hash.push_str(&truncated_hash_result(symbol_hasher));\n@@ -504,7 +504,7 @@ pub fn filename_for_input(sess: &Session,\n \n pub fn each_linked_rlib(sess: &Session,\n                         f: &mut FnMut(ast::CrateNum, &Path)) {\n-    let crates = sess.cstore.get_used_crates(cstore::RequireStatic).into_iter();\n+    let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic).into_iter();\n     let fmts = sess.dependency_formats.borrow();\n     let fmts = fmts.get(&config::CrateTypeExecutable).or_else(|| {\n         fmts.get(&config::CrateTypeStaticlib)\n@@ -516,7 +516,7 @@ pub fn each_linked_rlib(sess: &Session,\n             Linkage::NotLinked | Linkage::IncludedFromDylib => continue,\n             _ => {}\n         }\n-        let name = sess.cstore.get_crate_data(cnum).name.clone();\n+        let name = sess.cstore.crate_name(cnum).clone();\n         let path = match path {\n             Some(p) => p,\n             None => {\n@@ -621,10 +621,11 @@ fn link_rlib<'a>(sess: &'a Session,\n         ab.add_file(obj);\n     }\n \n-    for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n+    for (l, kind) in sess.cstore.used_libraries() {\n         match kind {\n-            cstore::NativeStatic => ab.add_native_library(&l),\n-            cstore::NativeFramework | cstore::NativeUnknown => {}\n+            NativeLibraryKind::NativeStatic => ab.add_native_library(&l),\n+            NativeLibraryKind::NativeFramework |\n+            NativeLibraryKind::NativeUnknown => {}\n         }\n     }\n \n@@ -666,7 +667,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // contain the metadata in a separate file. We use a temp directory\n             // here so concurrent builds in the same directory don't try to use\n             // the same filename for metadata (stomping over one another)\n-            let metadata = tmpdir.join(METADATA_FILENAME);\n+            let metadata = tmpdir.join(sess.cstore.metadata_filename());\n             match fs::File::create(&metadata).and_then(|mut f| {\n                 f.write_all(&trans.metadata)\n             }) {\n@@ -805,10 +806,10 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n     let mut all_native_libs = vec![];\n \n     each_linked_rlib(sess, &mut |cnum, path| {\n-        let name = sess.cstore.get_crate_data(cnum).name();\n+        let name = sess.cstore.crate_name(cnum);\n         ab.add_rlib(path, &name, sess.lto()).unwrap();\n \n-        let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n+        let native_libs = sess.cstore.native_libraries(cnum);\n         all_native_libs.extend(native_libs);\n     });\n \n@@ -824,9 +825,9 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n \n     for &(kind, ref lib) in &all_native_libs {\n         let name = match kind {\n-            cstore::NativeStatic => \"static library\",\n-            cstore::NativeUnknown => \"library\",\n-            cstore::NativeFramework => \"framework\",\n+            NativeLibraryKind::NativeStatic => \"static library\",\n+            NativeLibraryKind::NativeUnknown => \"library\",\n+            NativeLibraryKind::NativeFramework => \"framework\",\n         };\n         sess.note(&format!(\"{}: {}\", name, *lib));\n     }\n@@ -968,7 +969,7 @@ fn link_args(cmd: &mut Linker,\n     // sections if possible. See more comments in linker.rs\n     cmd.gc_sections(dylib);\n \n-    let used_link_args = sess.cstore.get_used_link_args().borrow();\n+    let used_link_args = sess.cstore.used_link_args();\n \n     if !dylib && t.options.position_independent_executables {\n         let empty_vec = Vec::new();\n@@ -1049,7 +1050,7 @@ fn link_args(cmd: &mut Linker,\n             path\n         };\n         let mut rpath_config = RPathConfig {\n-            used_crates: sess.cstore.get_used_crates(cstore::RequireDynamic),\n+            used_crates: sess.cstore.used_crates(LinkagePreference::RequireDynamic),\n             out_filename: out_filename.to_path_buf(),\n             has_rpath: sess.target.target.options.has_rpath,\n             is_like_osx: sess.target.target.options.is_like_osx,\n@@ -1085,14 +1086,13 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n         }\n     });\n \n-    let libs = sess.cstore.get_used_libraries();\n-    let libs = libs.borrow();\n+    let libs = sess.cstore.used_libraries();\n \n     let staticlibs = libs.iter().filter_map(|&(ref l, kind)| {\n-        if kind == cstore::NativeStatic {Some(l)} else {None}\n+        if kind == NativeLibraryKind::NativeStatic {Some(l)} else {None}\n     });\n     let others = libs.iter().filter(|&&(_, kind)| {\n-        kind != cstore::NativeStatic\n+        kind != NativeLibraryKind::NativeStatic\n     });\n \n     // Some platforms take hints about whether a library is static or dynamic.\n@@ -1116,9 +1116,9 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n \n     for &(ref l, kind) in others {\n         match kind {\n-            cstore::NativeUnknown => cmd.link_dylib(l),\n-            cstore::NativeFramework => cmd.link_framework(l),\n-            cstore::NativeStatic => unreachable!(),\n+            NativeLibraryKind::NativeUnknown => cmd.link_dylib(l),\n+            NativeLibraryKind::NativeFramework => cmd.link_framework(l),\n+            NativeLibraryKind::NativeStatic => unreachable!(),\n         }\n     }\n }\n@@ -1147,13 +1147,13 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of\n     // crates.\n-    let deps = sess.cstore.get_used_crates(cstore::RequireDynamic);\n+    let deps = sess.cstore.used_crates(LinkagePreference::RequireDynamic);\n \n     for &(cnum, _) in &deps {\n         // We may not pass all crates through to the linker. Some crates may\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n-        let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n+        let src = sess.cstore.used_crate_source(cnum);\n         match data[cnum as usize - 1] {\n             Linkage::NotLinked |\n             Linkage::IncludedFromDylib => {}\n@@ -1217,7 +1217,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n         time(sess.time_passes(), &format!(\"altering {}.rlib\", name), || {\n             let cfg = archive_config(sess, &dst, Some(cratepath));\n             let mut archive = ArchiveBuilder::new(cfg);\n-            archive.remove_file(METADATA_FILENAME);\n+            archive.remove_file(sess.cstore.metadata_filename());\n             archive.update_symbols();\n \n             let mut any_objects = false;\n@@ -1292,14 +1292,14 @@ fn add_upstream_native_libraries(cmd: &mut Linker, sess: &Session) {\n     // This passes RequireStatic, but the actual requirement doesn't matter,\n     // we're just getting an ordering of crate numbers, we're not worried about\n     // the paths.\n-    let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n+    let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic);\n     for (cnum, _) in crates {\n-        let libs = csearch::get_native_libraries(&sess.cstore, cnum);\n+        let libs = sess.cstore.native_libraries(cnum);\n         for &(kind, ref lib) in &libs {\n             match kind {\n-                cstore::NativeUnknown => cmd.link_dylib(lib),\n-                cstore::NativeFramework => cmd.link_framework(lib),\n-                cstore::NativeStatic => {\n+                NativeLibraryKind::NativeUnknown => cmd.link_dylib(lib),\n+                NativeLibraryKind::NativeFramework => cmd.link_framework(lib),\n+                NativeLibraryKind::NativeStatic => {\n                     sess.bug(\"statics shouldn't be propagated\");\n                 }\n             }"}, {"sha": "1ee1c9f1912c778f85c441160dbecf831ea1e7e8", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -16,7 +16,7 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use back::archive;\n-use metadata::csearch;\n+use middle::cstore::CrateStore;\n use middle::dependency_format::Linkage;\n use session::Session;\n use session::config::CrateTypeDylib;\n@@ -342,9 +342,9 @@ impl<'a> Linker for MsvcLinker<'a> {\n                     None\n                 }\n             }).flat_map(|cnum| {\n-                csearch::get_reachable_ids(cstore, cnum)\n+                cstore.reachable_ids(cnum)\n             }).map(|did| {\n-                csearch::get_symbol(cstore, did)\n+                cstore.item_symbol(did)\n             });\n             for symbol in symbols {\n                 try!(writeln!(f, \"  {}\", symbol));"}, {"sha": "b672c49bdca7e4567cde04c438c489e46c5726c9", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -62,10 +62,8 @@ extern crate serialize;\n #[macro_use] extern crate syntax;\n \n pub use rustc::session;\n-pub use rustc::metadata;\n pub use rustc::middle;\n pub use rustc::lint;\n-pub use rustc::plugin;\n pub use rustc::util;\n \n pub mod back {"}, {"sha": "2964d87ec1c0987c16b165a46e2bc1c3f589ca64", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -909,7 +909,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                     None => item.ident.to_string(),\n                 };\n                 let alias_span = self.span.span_for_last_ident(item.span);\n-                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n+                let cnum = match self.sess.cstore.extern_mod_stmt_cnum(item.id) {\n                     Some(cnum) => cnum,\n                     None => 0,\n                 };\n@@ -1216,4 +1216,3 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n         walk_list!(self, visit_expr, &l.init);\n     }\n }\n-"}, {"sha": "cc5322d7f9f46c04484caee61af584fae6606507", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -199,12 +199,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_external_crates(&self) -> Vec<CrateData> {\n         let mut result = Vec::new();\n \n-        self.tcx.sess.cstore.iter_crate_data(|n, cmd| {\n+        for n in self.tcx.sess.cstore.crates() {\n             result.push(CrateData {\n-                name: cmd.name.clone(),\n+                name: self.tcx.sess.cstore.crate_name(n),\n                 number: n,\n             });\n-        });\n+        }\n \n         result\n     }"}, {"sha": "a95a4c052fa2e1f6e133bccf8f5ca28af4676027", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -13,7 +13,7 @@ pub use self::Row::*;\n use super::escape;\n use super::span_utils::SpanUtils;\n \n-use metadata::cstore::LOCAL_CRATE;\n+use middle::cstore::LOCAL_CRATE;\n use middle::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::ty;\n "}, {"sha": "d6b33672df0a7074054d007ec2a2f5726663b1be", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 22, "deletions": 40, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -34,9 +34,8 @@ use back::{link, abi};\n use lint;\n use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n-use metadata::{csearch, encoder, loader};\n-use middle::astencode;\n use middle::cfg;\n+use middle::cstore::CrateStore;\n use middle::def_id::DefId;\n use middle::infer;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n@@ -199,7 +198,7 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let f = declare::declare_rust_fn(ccx, name, fn_ty);\n \n-    let attrs = csearch::get_item_attrs(&ccx.sess().cstore, did);\n+    let attrs = ccx.sess().cstore.item_attrs(did);\n     attributes::from_fn_attrs(ccx, &attrs[..], f);\n \n     ccx.externs().borrow_mut().insert(name.to_string(), f);\n@@ -230,7 +229,7 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   did: DefId,\n                                   t: Ty<'tcx>)\n                                   -> ValueRef {\n-    let name = csearch::get_symbol(&ccx.sess().cstore, did);\n+    let name = ccx.sess().cstore.item_symbol(did);\n     let ty = type_of(ccx, t);\n     match ccx.externs().borrow_mut().get(&name) {\n         Some(n) => return *n,\n@@ -874,7 +873,7 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      did: DefId,\n                                      t: Ty<'tcx>)\n                                      -> ValueRef {\n-    let name = csearch::get_symbol(&ccx.sess().cstore, did);\n+    let name = ccx.sess().cstore.item_symbol(did);\n     match t.sty {\n         ty::TyBareFn(_, ref fn_ty) => {\n             match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n@@ -885,7 +884,7 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n                 _ => {\n-                    let attrs = csearch::get_item_attrs(&ccx.sess().cstore, did);\n+                    let attrs = ccx.sess().cstore.item_attrs(did);\n                     foreign::register_foreign_item_fn(ccx, fn_ty.abi, t, &name, &attrs)\n                 }\n             }\n@@ -2513,10 +2512,9 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n                                                                .as_local_node_id(start_def_id) {\n                     get_item_val(ccx, start_node_id)\n                 } else {\n-                    let start_fn_type = csearch::get_type(ccx.tcx(), start_def_id).ty;\n+                    let start_fn_type = ccx.tcx().lookup_item_type(start_def_id).ty;\n                     trans_external_path(ccx, start_def_id, start_fn_type)\n                 };\n-\n                 let args = {\n                     let opaque_rust_main =\n                         llvm::LLVMBuildPointerCast(bld,\n@@ -2552,7 +2550,7 @@ fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                            -> String {\n     match ccx.external_srcs().borrow().get(&id) {\n         Some(&did) => {\n-            let sym = csearch::get_symbol(&ccx.sess().cstore, did);\n+            let sym = ccx.sess().cstore.item_symbol(did);\n             debug!(\"found item {} in other crate...\", sym);\n             return sym;\n         }\n@@ -2602,7 +2600,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let v = match i.node {\n                 hir::ItemStatic(..) => {\n                     // If this static came from an external crate, then\n-                    // we need to get the symbol from csearch instead of\n+                    // we need to get the symbol from metadata instead of\n                     // using the current crate's name/version\n                     // information in the hash of the symbol\n                     let sym = sym();\n@@ -2757,22 +2755,6 @@ fn register_method(ccx: &CrateContext,\n     }\n }\n \n-pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'a, 'tcx>,\n-                                            ie: encoder::EncodeInlinedItem<'a>,\n-                                            reachable: &'a NodeSet)\n-                                            -> encoder::EncodeParams<'a, 'tcx> {\n-    encoder::EncodeParams {\n-        diag: cx.sess().diagnostic(),\n-        tcx: cx.tcx(),\n-        reexports: cx.export_map(),\n-        item_symbols: cx.item_symbols(),\n-        link_meta: cx.link_meta(),\n-        cstore: &cx.sess().cstore,\n-        encode_inlined_item: ie,\n-        reachable: reachable,\n-    }\n-}\n-\n pub fn write_metadata(cx: &SharedCrateContext, krate: &hir::Crate, reachable: &NodeSet) -> Vec<u8> {\n     use flate;\n \n@@ -2785,14 +2767,13 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &hir::Crate, reachable: &N\n         return Vec::new();\n     }\n \n-    let encode_inlined_item: encoder::EncodeInlinedItem = Box::new(|ecx, rbml_w, ii| {\n-        astencode::encode_inlined_item(ecx, rbml_w, ii)\n-    });\n-\n-    let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item, reachable);\n-    let metadata = encoder::encode_metadata(encode_parms, krate);\n-    let mut compressed = encoder::metadata_encoding_version.to_vec();\n+    let cstore = &cx.tcx().sess.cstore;\n+    let metadata = cstore.encode_metadata(\n+        cx.tcx(), cx.export_map(), cx.item_symbols(), cx.link_meta(), reachable,\n+        krate);\n+    let mut compressed = cstore.metadata_encoding_version().to_vec();\n     compressed.push_all(&flate::deflate_bytes(&metadata));\n+\n     let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed[..]);\n     let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\",\n@@ -2804,7 +2785,8 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &hir::Crate, reachable: &N\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        let name = loader::meta_section_name(&cx.sess().target.target);\n+        let name =\n+            cx.tcx().sess.cstore.metadata_section_name(&cx.sess().target.target);\n         let name = CString::new(name).unwrap();\n         llvm::LLVMSetSection(llglobal, name.as_ptr())\n     }\n@@ -3105,15 +3087,15 @@ pub fn trans_crate<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // reachable extern fns. These functions are all part of the public ABI of\n     // the final product, so LTO needs to preserve them.\n     if sess.lto() {\n-        sess.cstore.iter_crate_data(|cnum, _| {\n-            let syms = csearch::get_reachable_ids(&sess.cstore, cnum);\n+        for cnum in sess.cstore.crates() {\n+            let syms = sess.cstore.reachable_ids(cnum);\n             reachable_symbols.extend(syms.into_iter().filter(|did| {\n-                csearch::is_extern_fn(&sess.cstore, *did, shared_ccx.tcx()) ||\n-                csearch::is_static(&sess.cstore, *did)\n+                sess.cstore.is_extern_fn(shared_ccx.tcx(), *did) ||\n+                sess.cstore.is_static(*did)\n             }).map(|did| {\n-                csearch::get_symbol(&sess.cstore, did)\n+                sess.cstore.item_symbol(did)\n             }));\n-        });\n+        }\n     }\n \n     if codegen_units > 1 {"}, {"sha": "0c0bda45d8cd96715a42b6fd4335abf0b23f8f55", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -22,7 +22,7 @@ use arena::TypedArena;\n use back::link;\n use session;\n use llvm::{self, ValueRef, get_params};\n-use metadata::cstore::LOCAL_CRATE;\n+use middle::cstore::LOCAL_CRATE;\n use middle::def;\n use middle::def_id::DefId;\n use middle::infer;"}, {"sha": "6f40283064bd05011a3bfb4c659649f963d8f8da", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -13,8 +13,8 @@ use back::abi;\n use llvm;\n use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n-use metadata::cstore::LOCAL_CRATE;\n use middle::{check_const, def};\n+use middle::cstore::LOCAL_CRATE;\n use middle::const_eval::{self, ConstVal, ConstEvalErr};\n use middle::const_eval::{const_int_checked_neg, const_uint_checked_neg};\n use middle::const_eval::{const_int_checked_add, const_uint_checked_add};"}, {"sha": "c6ca2e176aa58913985241843d4d80bd3a73d350", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -10,7 +10,7 @@\n \n use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef, BuilderRef};\n-use metadata::common::LinkMeta;\n+use middle::cstore::LinkMeta;\n use middle::def::ExportMap;\n use middle::def_id::DefId;\n use middle::traits;"}, {"sha": "9eed014ac73a4c89165a4e0ded42a66629f8c343", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -343,7 +343,7 @@ impl<'tcx> TypeMap<'tcx> {\n             let crate_hash = if source_def_id.is_local() {\n                 cx.link_meta().crate_hash.clone()\n             } else {\n-                cx.sess().cstore.get_crate_hash(source_def_id.krate)\n+                cx.sess().cstore.crate_hash(source_def_id.krate)\n             };\n \n             output.push_str(crate_hash.as_str());"}, {"sha": "29965755eac76c76cd7dd6257f14c154de96e7c8", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -9,17 +9,14 @@\n // except according to those terms.\n \n use llvm::{AvailableExternallyLinkage, InternalLinkage, SetLinkage};\n-use metadata::csearch;\n-use metadata::inline::InlinedItem;\n-use middle::astencode;\n+use middle::cstore::{CrateStore, FoundAst, InlinedItem};\n use middle::def_id::DefId;\n use middle::subst::Substs;\n use trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n use trans::common::*;\n \n use rustc_front::hir;\n \n-\n fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n     -> Option<DefId> {\n     debug!(\"instantiate_inline({:?})\", fn_id);\n@@ -41,17 +38,13 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n         }\n     }\n \n-    let csearch_result =\n-        csearch::maybe_get_item_ast(\n-            ccx.tcx(), fn_id,\n-            Box::new(astencode::decode_inlined_item));\n-\n-    let inline_id = match csearch_result {\n-        csearch::FoundAst::NotFound => {\n+    let inlined = ccx.tcx().sess.cstore.maybe_get_item_ast(ccx.tcx(), fn_id);\n+    let inline_id = match inlined {\n+        FoundAst::NotFound => {\n             ccx.external().borrow_mut().insert(fn_id, None);\n             return None;\n         }\n-        csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => {\n+        FoundAst::Found(&InlinedItem::Item(ref item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n \n@@ -94,12 +87,12 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n \n             item.id\n         }\n-        csearch::FoundAst::Found(&InlinedItem::Foreign(ref item)) => {\n+        FoundAst::Found(&InlinedItem::Foreign(ref item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n             item.id\n         }\n-        csearch::FoundAst::FoundParent(parent_id, &InlinedItem::Item(ref item)) => {\n+        FoundAst::FoundParent(parent_id, &InlinedItem::Item(ref item)) => {\n             ccx.external().borrow_mut().insert(parent_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, parent_id);\n \n@@ -129,11 +122,11 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n             trans_item(ccx, &**item);\n             my_id\n         }\n-        csearch::FoundAst::FoundParent(_, _) => {\n+        FoundAst::FoundParent(_, _) => {\n             ccx.sess().bug(\"maybe_get_item_ast returned a FoundParent \\\n                             with a non-item parent\");\n         }\n-        csearch::FoundAst::Found(&InlinedItem::TraitItem(_, ref trait_item)) => {\n+        FoundAst::Found(&InlinedItem::TraitItem(_, ref trait_item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(trait_item.id));\n             ccx.external_srcs().borrow_mut().insert(trait_item.id, fn_id);\n \n@@ -153,7 +146,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n             // don't.\n             trait_item.id\n         }\n-        csearch::FoundAst::Found(&InlinedItem::ImplItem(impl_did, ref impl_item)) => {\n+        FoundAst::Found(&InlinedItem::ImplItem(impl_did, ref impl_item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(impl_item.id));\n             ccx.external_srcs().borrow_mut().insert(impl_item.id, fn_id);\n "}, {"sha": "b102e96af20e2ae3e974316b55af3db7210062ec", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use llvm::{ContextRef, ModuleRef};\n-use metadata::common::LinkMeta;\n+use middle::cstore::LinkMeta;\n \n pub use self::base::trans_crate;\n pub use self::context::CrateContext;"}, {"sha": "6a23be682e9d3cd0a0c1ff3c4ba7682bf74babd4", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -25,7 +25,7 @@ use super::UnresolvedTypeAction;\n use super::write_call;\n \n use CrateCtxt;\n-use metadata::cstore::LOCAL_CRATE;\n+use middle::cstore::LOCAL_CRATE;\n use middle::def_id::DefId;\n use middle::infer;\n use middle::ty::{self, LvaluePreference, Ty};"}, {"sha": "955bc92a8f31e89bf1a9c982c4b98371ab793798", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -17,12 +17,12 @@ use astconv::AstConv;\n use check::{self, FnCtxt};\n use front::map as hir_map;\n use middle::ty::{self, Ty, ToPolyTraitRef, ToPredicate, HasTypeFlags};\n+use middle::cstore::{self, CrateStore, DefLike};\n use middle::def;\n use middle::def_id::DefId;\n use middle::lang_items::FnOnceTraitLangItem;\n use middle::subst::Substs;\n use middle::traits::{Obligation, SelectionContext};\n-use metadata::{csearch, cstore, decoder};\n use util::nodemap::{FnvHashSet};\n \n use syntax::ast;\n@@ -418,32 +418,32 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n         fn handle_external_def(traits: &mut AllTraitsVec,\n                                external_mods: &mut FnvHashSet<DefId>,\n                                ccx: &CrateCtxt,\n-                               cstore: &cstore::CStore,\n-                               dl: decoder::DefLike) {\n+                               cstore: &for<'a> cstore::CrateStore<'a>,\n+                               dl: cstore::DefLike) {\n             match dl {\n-                decoder::DlDef(def::DefTrait(did)) => {\n+                cstore::DlDef(def::DefTrait(did)) => {\n                     traits.push(TraitInfo::new(did));\n                 }\n-                decoder::DlDef(def::DefMod(did)) => {\n+                cstore::DlDef(def::DefMod(did)) => {\n                     if !external_mods.insert(did) {\n                         return;\n                     }\n-                    csearch::each_child_of_item(cstore, did, |dl, _, _| {\n+                    for child in cstore.item_children(did) {\n                         handle_external_def(traits, external_mods,\n-                                            ccx, cstore, dl)\n-                    })\n+                                            ccx, cstore, child.def)\n+                    }\n                 }\n                 _ => {}\n             }\n         }\n-        let cstore = &ccx.tcx.sess.cstore;\n-        cstore.iter_crate_data(|cnum, _| {\n-            csearch::each_top_level_item_of_crate(cstore, cnum, |dl, _, _| {\n-                handle_external_def(&mut traits,\n-                                    &mut external_mods,\n-                                    ccx, cstore, dl)\n-            })\n-        });\n+        let cstore = &*ccx.tcx.sess.cstore;\n+\n+        for cnum in ccx.tcx.sess.cstore.crates() {\n+            for child in cstore.crate_top_level_items(cnum) {\n+                handle_external_def(&mut traits, &mut external_mods,\n+                                    ccx, cstore, child.def)\n+            }\n+        }\n \n         *ccx.all_traits.borrow_mut() = Some(traits);\n     }"}, {"sha": "be60d2f3dcf8e004cca1ef8cc67bf59c520d1e96", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -83,8 +83,8 @@ use self::TupleArgumentsFlag::*;\n use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n use check::_match::pat_ctxt;\n use fmt_macros::{Parser, Piece, Position};\n-use metadata::cstore::LOCAL_CRATE;\n use middle::astconv_util::prohibit_type_params;\n+use middle::cstore::LOCAL_CRATE;\n use middle::def;\n use middle::def_id::DefId;\n use middle::infer;"}, {"sha": "e6e31ba0819c5d605f1afeab1e4424ef1aeb2272", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -11,7 +11,7 @@\n //! Orphan checker: every impl either implements a trait defined in this\n //! crate or pertains to a type defined in this crate.\n \n-use metadata::cstore::LOCAL_CRATE;\n+use middle::cstore::LOCAL_CRATE;\n use middle::def_id::DefId;\n use middle::traits;\n use middle::ty;"}, {"sha": "693c8716ab58acec4bdf1da31fe32cbb9094707b", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -11,7 +11,7 @@\n //! Overlap: No two impls for the same trait are implemented for the\n //! same type.\n \n-use metadata::cstore::LOCAL_CRATE;\n+use middle::cstore::{CrateStore, LOCAL_CRATE};\n use middle::def_id::DefId;\n use middle::traits;\n use middle::ty;\n@@ -156,9 +156,8 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n             span_note!(self.tcx.sess, self.span_of_impl(impl2),\n                        \"note conflicting implementation here\");\n         } else {\n-            let crate_store = &self.tcx.sess.cstore;\n-            let cdata = crate_store.get_crate_data(impl2.krate);\n-            self.tcx.sess.note(&format!(\"conflicting implementation in crate `{}`\", cdata.name));\n+            let cname = self.tcx.sess.cstore.crate_name(impl2.krate);\n+            self.tcx.sess.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n         }\n     }\n "}, {"sha": "4c09df418950bd27ba36e7a7c65b13c6c4e61d36", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -99,7 +99,6 @@ extern crate rustc_back;\n \n pub use rustc::front;\n pub use rustc::lint;\n-pub use rustc::metadata;\n pub use rustc::middle;\n pub use rustc::session;\n pub use rustc::util;"}, {"sha": "40cd5e5bf278715ce39ea3b7f23c8ddf0c2fb105", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -16,8 +16,7 @@ use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n use rustc_front::hir;\n \n-use rustc::metadata::csearch;\n-use rustc::metadata::decoder;\n+use rustc::middle::cstore::{self, CrateStore};\n use rustc::middle::def;\n use rustc::middle::def_id::DefId;\n use rustc::middle::ty;\n@@ -129,8 +128,7 @@ fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n \n pub fn load_attrs(cx: &DocContext, tcx: &ty::ctxt,\n                   did: DefId) -> Vec<clean::Attribute> {\n-    let attrs = csearch::get_item_attrs(&tcx.sess.cstore, did);\n-    attrs.into_iter().map(|a| a.clean(cx)).collect()\n+    tcx.get_attrs(did).iter().map(|a| a.clean(cx)).collect()\n }\n \n /// Record an external fully qualified name in the external_paths cache.\n@@ -140,7 +138,7 @@ pub fn load_attrs(cx: &DocContext, tcx: &ty::ctxt,\n pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n     match cx.tcx_opt() {\n         Some(tcx) => {\n-            let fqn = csearch::get_item_path(tcx, did);\n+            let fqn = tcx.sess.cstore.item_path(did);\n             let fqn = fqn.into_iter().map(|i| i.to_string()).collect();\n             cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n         }\n@@ -171,7 +169,7 @@ fn build_external_function(cx: &DocContext, tcx: &ty::ctxt, did: DefId) -> clean\n         _ => panic!(\"bad function\"),\n     };\n \n-    let constness = if csearch::is_const_fn(&tcx.sess.cstore, did) {\n+    let constness = if tcx.sess.cstore.is_const_fn(did) {\n         hir::Constness::Const\n     } else {\n         hir::Constness::NotConst\n@@ -211,7 +209,7 @@ fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: DefId) -> clean::ItemEnum {\n     let t = tcx.lookup_item_type(did);\n     let predicates = tcx.lookup_predicates(did);\n     match t.ty.sty {\n-        ty::TyEnum(edef, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n+        ty::TyEnum(edef, _) if !tcx.sess.cstore.is_typedef(did) => {\n             return clean::EnumItem(clean::Enum {\n                 generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n                 variants_stripped: false,\n@@ -250,23 +248,19 @@ pub fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n     // type being inlined, but impls can also be used when generating\n     // documentation for primitives (no way to find those specifically).\n     if cx.populated_crate_impls.borrow_mut().insert(did.krate) {\n-        csearch::each_top_level_item_of_crate(&tcx.sess.cstore,\n-                                              did.krate,\n-                                              |def, _, _| {\n-            populate_impls(cx, tcx, def, &mut impls)\n-        });\n+        for item in tcx.sess.cstore.crate_top_level_items(did.krate) {\n+            populate_impls(cx, tcx, item.def, &mut impls);\n+        }\n \n         fn populate_impls(cx: &DocContext, tcx: &ty::ctxt,\n-                          def: decoder::DefLike,\n+                          def: cstore::DefLike,\n                           impls: &mut Vec<clean::Item>) {\n             match def {\n-                decoder::DlImpl(did) => build_impl(cx, tcx, did, impls),\n-                decoder::DlDef(def::DefMod(did)) => {\n-                    csearch::each_child_of_item(&tcx.sess.cstore,\n-                                                did,\n-                                                |def, _, _| {\n-                        populate_impls(cx, tcx, def, impls)\n-                    })\n+                cstore::DlImpl(did) => build_impl(cx, tcx, did, impls),\n+                cstore::DlDef(def::DefMod(did)) => {\n+                    for item in tcx.sess.cstore.item_children(did) {\n+                        populate_impls(cx, tcx, item.def, impls)\n+                    }\n                 }\n                 _ => {}\n             }\n@@ -285,7 +279,7 @@ pub fn build_impl(cx: &DocContext,\n     }\n \n     let attrs = load_attrs(cx, tcx, did);\n-    let associated_trait = csearch::get_impl_trait(tcx, did);\n+    let associated_trait = tcx.impl_trait_ref(did);\n     if let Some(ref t) = associated_trait {\n         // If this is an impl for a #[doc(hidden)] trait, be sure to not inline\n         let trait_attrs = load_attrs(cx, tcx, t.def_id);\n@@ -295,7 +289,7 @@ pub fn build_impl(cx: &DocContext,\n     }\n \n     // If this is a defaulted impl, then bail out early here\n-    if csearch::is_default_impl(&tcx.sess.cstore, did) {\n+    if tcx.sess.cstore.is_default_impl(did) {\n         return ret.push(clean::Item {\n             inner: clean::DefaultImplItem(clean::DefaultImpl {\n                 // FIXME: this should be decoded\n@@ -315,7 +309,7 @@ pub fn build_impl(cx: &DocContext,\n     }\n \n     let predicates = tcx.lookup_predicates(did);\n-    let trait_items = csearch::get_impl_items(&tcx.sess.cstore, did)\n+    let trait_items = tcx.sess.cstore.impl_items(did)\n             .iter()\n             .filter_map(|did| {\n         let did = did.def_id();\n@@ -352,7 +346,7 @@ pub fn build_impl(cx: &DocContext,\n                     clean::TyMethodItem(clean::TyMethod {\n                         unsafety, decl, self_, generics, abi\n                     }) => {\n-                        let constness = if csearch::is_const_fn(&tcx.sess.cstore, did) {\n+                        let constness = if tcx.sess.cstore.is_const_fn(did) {\n                             hir::Constness::Const\n                         } else {\n                             hir::Constness::NotConst\n@@ -393,7 +387,7 @@ pub fn build_impl(cx: &DocContext,\n             }\n         }\n     }).collect::<Vec<_>>();\n-    let polarity = csearch::get_impl_polarity(tcx, did);\n+    let polarity = tcx.trait_impl_polarity(did);\n     let ty = tcx.lookup_item_type(did);\n     let trait_ = associated_trait.clean(cx).map(|bound| {\n         match bound {\n@@ -454,24 +448,24 @@ fn build_module(cx: &DocContext, tcx: &ty::ctxt,\n         // two namespaces, so the target may be listed twice. Make sure we only\n         // visit each node at most once.\n         let mut visited = HashSet::new();\n-        csearch::each_child_of_item(&tcx.sess.cstore, did, |def, _, vis| {\n-            match def {\n-                decoder::DlDef(def::DefForeignMod(did)) => {\n+        for item in tcx.sess.cstore.item_children(did) {\n+            match item.def {\n+                cstore::DlDef(def::DefForeignMod(did)) => {\n                     fill_in(cx, tcx, did, items);\n                 }\n-                decoder::DlDef(def) if vis == hir::Public => {\n+                cstore::DlDef(def) if item.vis == hir::Public => {\n                     if !visited.insert(def) { return }\n                     match try_inline_def(cx, tcx, def) {\n                         Some(i) => items.extend(i),\n                         None => {}\n                     }\n                 }\n-                decoder::DlDef(..) => {}\n+                cstore::DlDef(..) => {}\n                 // All impls were inlined above\n-                decoder::DlImpl(..) => {}\n-                decoder::DlField => panic!(\"unimplemented field\"),\n+                cstore::DlImpl(..) => {}\n+                cstore::DlField => panic!(\"unimplemented field\"),\n             }\n-        });\n+        }\n     }\n }\n "}, {"sha": "a1b3d88f083f241bceddc7ae3f8ebdc72fceaf7f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -35,9 +35,7 @@ use syntax::parse::token::{self, InternedString, special_idents};\n use syntax::ptr::P;\n \n use rustc_trans::back::link;\n-use rustc::metadata::cstore;\n-use rustc::metadata::csearch;\n-use rustc::metadata::decoder;\n+use rustc::middle::cstore::{self, CrateStore};\n use rustc::middle::def;\n use rustc::middle::def_id::{DefId, DefIndex};\n use rustc::middle::subst::{self, ParamSpace, VecPerParamSpace};\n@@ -126,6 +124,8 @@ pub struct Crate {\n     pub external_traits: HashMap<DefId, Trait>,\n }\n \n+struct CrateNum(ast::CrateNum);\n+\n impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n     fn clean(&self, cx: &DocContext) -> Crate {\n         use rustc::session::config::Input;\n@@ -135,9 +135,9 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n         }\n \n         let mut externs = Vec::new();\n-        cx.sess().cstore.iter_crate_data(|n, meta| {\n-            externs.push((n, meta.clean(cx)));\n-        });\n+        for cnum in cx.sess().cstore.crates() {\n+            externs.push((cnum, CrateNum(cnum).clean(cx)));\n+        }\n         externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n         // Figure out the name of this crate\n@@ -219,24 +219,22 @@ pub struct ExternalCrate {\n     pub primitives: Vec<PrimitiveType>,\n }\n \n-impl Clean<ExternalCrate> for cstore::crate_metadata {\n+impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext) -> ExternalCrate {\n         let mut primitives = Vec::new();\n         cx.tcx_opt().map(|tcx| {\n-            csearch::each_top_level_item_of_crate(&tcx.sess.cstore,\n-                                                  self.cnum,\n-                                                  |def, _, _| {\n-                let did = match def {\n-                    decoder::DlDef(def::DefMod(did)) => did,\n-                    _ => return\n+            for item in tcx.sess.cstore.crate_top_level_items(self.0) {\n+                let did = match item.def {\n+                    cstore::DlDef(def::DefMod(did)) => did,\n+                    _ => continue\n                 };\n                 let attrs = inline::load_attrs(cx, tcx, did);\n                 PrimitiveType::find(&attrs).map(|prim| primitives.push(prim));\n-            })\n+            }\n         });\n         ExternalCrate {\n-            name: self.name.to_string(),\n-            attrs: decoder::get_crate_attributes(self.data()).clean(cx),\n+            name: cx.sess().cstore.crate_name(self.0),\n+            attrs: cx.sess().cstore.crate_attrs(self.0).clean(cx),\n             primitives: primitives,\n         }\n     }\n@@ -656,7 +654,7 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n                 (tcx.lang_items.sync_trait().unwrap(),\n                  external_path(cx, \"Sync\", None, vec![], &empty)),\n         };\n-        let fqn = csearch::get_item_path(tcx, did);\n+        let fqn = tcx.sess.cstore.item_path(did);\n         let fqn = fqn.into_iter().map(|i| i.to_string()).collect();\n         cx.external_paths.borrow_mut().as_mut().unwrap().insert(did,\n                                                                 (fqn, TypeTrait));\n@@ -678,7 +676,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n             Some(tcx) => tcx,\n             None => return RegionBound(Lifetime::statik())\n         };\n-        let fqn = csearch::get_item_path(tcx, self.def_id);\n+        let fqn = tcx.sess.cstore.item_path(self.def_id);\n         let fqn = fqn.into_iter().map(|i| i.to_string())\n                      .collect::<Vec<String>>();\n         let path = external_path(cx, fqn.last().unwrap(),\n@@ -1140,7 +1138,7 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n         let mut names = if let Some(_) = cx.map.as_local_node_id(did) {\n             vec![].into_iter()\n         } else {\n-            csearch::get_method_arg_names(&cx.tcx().sess.cstore, did).into_iter()\n+            cx.tcx().sess.cstore.method_arg_names(did).into_iter()\n         }.peekable();\n         if names.peek().map(|s| &**s) == Some(\"self\") {\n             let _ = names.next();\n@@ -1665,7 +1663,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::TyStruct(def, substs) |\n             ty::TyEnum(def, substs) => {\n                 let did = def.did;\n-                let fqn = csearch::get_item_path(cx.tcx(), did);\n+                let fqn = cx.tcx().sess.cstore.item_path(did);\n                 let fqn: Vec<_> = fqn.into_iter().map(|i| i.to_string()).collect();\n                 let kind = match self.sty {\n                     ty::TyStruct(..) => TypeStruct,\n@@ -1683,7 +1681,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             }\n             ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n                 let did = principal.def_id();\n-                let fqn = csearch::get_item_path(cx.tcx(), did);\n+                let fqn = cx.tcx().sess.cstore.item_path(did);\n                 let fqn: Vec<_> = fqn.into_iter().map(|i| i.to_string()).collect();\n                 let (typarams, bindings) = bounds.clean(cx);\n                 let path = external_path(cx, &fqn.last().unwrap().to_string(),\n@@ -1737,9 +1735,9 @@ impl Clean<Item> for hir::StructField {\n impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         use syntax::parse::token::special_idents::unnamed_field;\n-        use rustc::metadata::csearch;\n-\n-        let attr_map = csearch::get_struct_field_attrs(&cx.tcx().sess.cstore, self.did);\n+        // FIXME: possible O(n^2)-ness! Not my fault.\n+        let attr_map =\n+            cx.tcx().sess.cstore.crate_struct_field_attrs(self.did.krate);\n \n         let (name, attrs) = if self.name == unnamed_field.name {\n             (None, None)\n@@ -2815,7 +2813,7 @@ fn lang_struct(cx: &DocContext, did: Option<DefId>,\n         Some(did) => did,\n         None => return fallback(box t.clean(cx)),\n     };\n-    let fqn = csearch::get_item_path(cx.tcx(), did);\n+    let fqn = cx.tcx().sess.cstore.item_path(did);\n     let fqn: Vec<String> = fqn.into_iter().map(|i| {\n         i.to_string()\n     }).collect();"}, {"sha": "1ccab1b16ebdb09ee2e91d86ad616b194e31d0f7", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -20,12 +20,15 @@ use rustc::lint;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_front::lowering::{lower_crate, LoweringContext};\n+use rustc_metadata::cstore::CStore;\n \n use syntax::{ast, codemap, diagnostic};\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::parse::token;\n \n use std::cell::{RefCell, Cell};\n use std::collections::{HashMap, HashSet};\n+use std::rc::Rc;\n \n use visit_ast::RustdocVisitor;\n use clean;\n@@ -118,8 +121,10 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let span_diagnostic_handler =\n         diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n \n+    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+    let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n     let sess = session::build_session_(sessopts, cpath,\n-                                       span_diagnostic_handler);\n+                                       span_diagnostic_handler, cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess);\n@@ -130,7 +135,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let name = link::find_crate_name(Some(&sess), &krate.attrs,\n                                      &input);\n \n-    let krate = driver::phase_2_configure_and_expand(&sess, krate, &name, None)\n+    let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate, &name, None)\n                     .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let krate = driver::assign_node_ids(&sess, krate);\n@@ -141,6 +146,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let hir_map = driver::make_map(&sess, &mut hir_forest);\n \n     driver::phase_3_run_analysis_passes(&sess,\n+                                        &cstore,\n                                         hir_map,\n                                         &arenas,\n                                         &name,"}, {"sha": "1a4085e30e8f3560857671fe22de472d7b14fdf1", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -18,7 +18,7 @@\n use std::fmt;\n use std::iter::repeat;\n \n-use rustc::metadata::cstore::LOCAL_CRATE;\n+use rustc::middle::cstore::LOCAL_CRATE;\n use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n use syntax::abi::Abi;\n use rustc_front::hir;"}, {"sha": "574b9b599f5f8d35aded223a14aeda010fa69a3b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -54,7 +54,7 @@ use externalfiles::ExternalHtml;\n \n use serialize::json::{self, ToJson};\n use syntax::{abi, ast};\n-use rustc::metadata::cstore::LOCAL_CRATE;\n+use rustc::middle::cstore::LOCAL_CRATE;\n use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;"}, {"sha": "6997fa45cec985d0b937367aa34c046079d87628", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -43,6 +43,7 @@ extern crate rustc_resolve;\n extern crate rustc_lint;\n extern crate rustc_back;\n extern crate rustc_front;\n+extern crate rustc_metadata;\n extern crate serialize;\n extern crate syntax;\n extern crate test as testing;"}, {"sha": "3e303b29d5c7ab2f5a9c1515e2ae9bf0651f9ea8", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -19,6 +19,7 @@ use std::io::prelude::*;\n use std::io;\n use std::path::PathBuf;\n use std::process::Command;\n+use std::rc::Rc;\n use std::str;\n use std::sync::{Arc, Mutex};\n \n@@ -31,8 +32,10 @@ use rustc::session::search_paths::{SearchPaths, PathKind};\n use rustc_front::lowering::{lower_crate, LoweringContext};\n use rustc_back::tempdir::TempDir;\n use rustc_driver::{driver, Compilation};\n+use rustc_metadata::cstore::CStore;\n use syntax::codemap::CodeMap;\n use syntax::diagnostic;\n+use syntax::parse::token;\n \n use core;\n use clean;\n@@ -73,15 +76,18 @@ pub fn run(input: &str,\n     let span_diagnostic_handler =\n     diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n \n+    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+    let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n     let sess = session::build_session_(sessopts,\n-                                      Some(input_path.clone()),\n-                                      span_diagnostic_handler);\n+                                       Some(input_path.clone()),\n+                                       span_diagnostic_handler,\n+                                       cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess);\n     cfg.extend(config::parse_cfgspecs(cfgs));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n-    let krate = driver::phase_2_configure_and_expand(&sess, krate,\n+    let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate,\n                                                      \"rustdoc-test\", None)\n         .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n     let krate = driver::assign_node_ids(&sess, krate);\n@@ -223,9 +229,12 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     let span_diagnostic_handler =\n         diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n \n+    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+    let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n     let sess = session::build_session_(sessopts,\n                                        None,\n-                                       span_diagnostic_handler);\n+                                       span_diagnostic_handler,\n+                                       cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let outdir = TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\");\n@@ -236,7 +245,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     if no_run {\n         control.after_analysis.stop = Compilation::Stop;\n     }\n-    driver::compile_input(sess, cfg, &input, &out, &None, None, control);\n+    driver::compile_input(sess, &cstore, cfg, &input, &out, &None, None, control);\n \n     if no_run { return }\n "}, {"sha": "bab3721a313328b0c067ceb84b7af36ad262a3ee", "filename": "src/test/auxiliary/attr_plugin_test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fattr_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fattr_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fattr_plugin_test.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -16,9 +16,10 @@\n extern crate syntax;\n \n extern crate rustc;\n+extern crate rustc_plugin;\n \n use syntax::feature_gate::AttributeType;\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n \n "}, {"sha": "542b10fd1c68c396b83af758252288e73efd3965", "filename": "src/test/auxiliary/custom_derive_plugin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -16,6 +16,7 @@\n \n extern crate syntax;\n extern crate rustc;\n+extern crate rustc_plugin;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -25,7 +26,7 @@ use syntax::ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_subst\n use syntax::ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n use syntax::parse::token;\n use syntax::ptr::P;\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {"}, {"sha": "f44e77d563a9e8b018b6c1c12db9e6cb0de7f298", "filename": "src/test/auxiliary/custom_derive_plugin_attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -16,6 +16,7 @@\n \n extern crate syntax;\n extern crate rustc;\n+extern crate rustc_plugin;\n \n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n@@ -27,7 +28,7 @@ use syntax::ext::deriving::generic::{Substructure, Struct, EnumMatching};\n use syntax::ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n use syntax::parse::token;\n use syntax::ptr::P;\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {"}, {"sha": "25a75c2d2952e406bb94478833e2839259063a3c", "filename": "src/test/auxiliary/issue_16723_multiple_items_syntax_ext.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fissue_16723_multiple_items_syntax_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fissue_16723_multiple_items_syntax_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_16723_multiple_items_syntax_ext.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -15,12 +15,13 @@\n \n extern crate syntax;\n extern crate rustc;\n+extern crate rustc_plugin;\n \n use syntax::ast;\n use syntax::codemap;\n use syntax::ext::base::{ExtCtxt, MacResult, MacEager};\n use syntax::util::small_vector::SmallVector;\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {"}, {"sha": "1933188ccbf0287de2f5ee7cbc8f215603b84f57", "filename": "src/test/auxiliary/lint_for_crate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Flint_for_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Flint_for_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_for_crate.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -15,10 +15,11 @@\n \n #[macro_use] extern crate rustc;\n extern crate rustc_front;\n+extern crate rustc_plugin;\n extern crate syntax;\n \n use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n use rustc_front::hir;\n use syntax::attr;\n "}, {"sha": "98ed86bb390f3e397773e9e103a73d8b019e1ff8", "filename": "src/test/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -18,10 +18,11 @@ extern crate rustc_front;\n // Load rustc as a plugin to get macros\n #[macro_use]\n extern crate rustc;\n+extern crate rustc_plugin;\n \n use rustc_front::hir;\n use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n "}, {"sha": "8ea131da338cb1bd61f60fac56e32fe166a8beb6", "filename": "src/test/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -18,10 +18,11 @@ extern crate syntax;\n // Load rustc as a plugin to get macros\n #[macro_use]\n extern crate rustc;\n+extern crate rustc_plugin;\n \n use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass,\n                   EarlyLintPassObject, LintArray};\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n use syntax::ast;\n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n "}, {"sha": "59cfdd1e04a03cc890875a9a799f2985ab022a16", "filename": "src/test/auxiliary/llvm_pass_plugin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fllvm_pass_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fllvm_pass_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fllvm_pass_plugin.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -14,8 +14,9 @@\n #![feature(rustc_private)]\n \n extern crate rustc;\n+extern crate rustc_plugin;\n \n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {"}, {"sha": "9cf0d756f40ba101ef30c251e20945be2f266ff8", "filename": "src/test/auxiliary/lto-syntax-extension-plugin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Flto-syntax-extension-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Flto-syntax-extension-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flto-syntax-extension-plugin.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -14,8 +14,9 @@\n #![feature(rustc_private)]\n \n extern crate rustc;\n+extern crate rustc_plugin;\n \n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(_reg: &mut Registry) {}"}, {"sha": "9e693fcc56440fdee349c02e96b290ca71ead35d", "filename": "src/test/auxiliary/macro_crate_MacroRulesTT.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fmacro_crate_MacroRulesTT.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fmacro_crate_MacroRulesTT.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_MacroRulesTT.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -14,10 +14,11 @@\n \n extern crate syntax;\n extern crate rustc;\n+extern crate rustc_plugin;\n \n use syntax::parse::token;\n use syntax::ext::base::MacroRulesTT;\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {"}, {"sha": "fe61c80b4c3821680f2a66319bb9e58d782604a3", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -14,13 +14,14 @@\n \n extern crate syntax;\n extern crate rustc;\n+extern crate rustc_plugin;\n \n use syntax::ast::{self, TokenTree, Item, MetaItem, ImplItem, TraitItem};\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n #[macro_export]\n macro_rules! exported_macro { () => (2) }"}, {"sha": "f6e80266a15f51f679b09f1f2e227f8072a79062", "filename": "src/test/auxiliary/plugin_args.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fplugin_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fplugin_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_args.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -15,6 +15,7 @@\n \n extern crate syntax;\n extern crate rustc;\n+extern crate rustc_plugin;\n \n use std::borrow::ToOwned;\n use syntax::ast;\n@@ -24,7 +25,7 @@ use syntax::ext::base::{TTMacroExpander, ExtCtxt, MacResult, MacEager, NormalTT}\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n struct Expander {\n     args: Vec<P<ast::MetaItem>>,"}, {"sha": "f56983c14b1bc88e560746d0b7c483bea01f1a67", "filename": "src/test/auxiliary/plugin_crate_outlive_expansion_phase.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -14,10 +14,11 @@\n #![feature(box_syntax, rustc_private)]\n \n extern crate rustc;\n+extern crate rustc_plugin;\n \n use std::any::Any;\n use std::cell::RefCell;\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n struct Foo {\n     foo: isize"}, {"sha": "8b5ff7cf07c6951d6caad3844edaaffaa167b4d7", "filename": "src/test/auxiliary/plugin_with_plugin_lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fplugin_with_plugin_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fplugin_with_plugin_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_with_plugin_lib.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -15,8 +15,9 @@\n \n extern crate macro_crate_test;\n extern crate rustc;\n+extern crate rustc_plugin;\n \n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(_: &mut Registry) { }"}, {"sha": "713a7d1e811a2c891281f4ab3a763e0fd44c7a87", "filename": "src/test/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -15,6 +15,7 @@\n \n extern crate syntax;\n extern crate rustc;\n+extern crate rustc_plugin;\n \n use syntax::codemap::Span;\n use syntax::parse::token::{self, str_to_ident, NtExpr, NtPat};\n@@ -24,7 +25,7 @@ use syntax::ext::build::AstBuilder;\n use syntax::ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use syntax::ext::tt::macro_parser::{Success, Failure, Error};\n use syntax::ptr::P;\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n fn expand_mbe_matches(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         -> Box<MacResult + 'static> {"}, {"sha": "ae1568b2f88e1c7f819985534bedcb7b39f5ece9", "filename": "src/test/auxiliary/rlib_crate_test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Frlib_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Frlib_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Frlib_crate_test.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -14,8 +14,9 @@\n #![feature(plugin_registrar, rustc_private)]\n \n extern crate rustc;\n+extern crate rustc_plugin;\n \n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(_: &mut Registry) {}"}, {"sha": "c262b0dba2553c8b0ef566e5e955ed2e9f038f1d", "filename": "src/test/auxiliary/roman_numerals.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Froman_numerals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Froman_numerals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Froman_numerals.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -16,13 +16,14 @@\n \n extern crate syntax;\n extern crate rustc;\n+extern crate rustc_plugin;\n \n use syntax::codemap::Span;\n use syntax::ast::TokenTree;\n use syntax::parse::token;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n use syntax::ext::build::AstBuilder;  // trait for expr_usize\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n // WARNING WARNING WARNING WARNING WARNING\n // ======================================="}, {"sha": "7281698a7fb3491f2f132130b98394f7c2c0a7ce", "filename": "src/test/auxiliary/syntax_extension_with_dll_deps_2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fsyntax_extension_with_dll_deps_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fauxiliary%2Fsyntax_extension_with_dll_deps_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsyntax_extension_with_dll_deps_2.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -16,11 +16,12 @@\n extern crate syntax_extension_with_dll_deps_1 as other;\n extern crate syntax;\n extern crate rustc;\n+extern crate rustc_plugin;\n \n use syntax::ast::{TokenTree, Item, MetaItem};\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n-use rustc::plugin::Registry;\n+use rustc_plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {"}, {"sha": "e6c9b1b41c0486bebef3aa6c1e04b86309658a8a", "filename": "src/test/compile-fail/use-from-trait-xc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -22,13 +22,13 @@ use use_from_trait_xc::Trait::CONST;\n //~^ ERROR `CONST` is not directly importable\n \n use use_from_trait_xc::Foo::new;\n-//~^ ERROR `new` is not directly importable\n+//~^ ERROR unresolved import `use_from_trait_xc::Foo::new`\n \n use use_from_trait_xc::Foo::C;\n //~^ ERROR unresolved import `use_from_trait_xc::Foo::C`\n \n use use_from_trait_xc::Bar::new as bnew;\n-//~^ ERROR `bnew` is not directly importable\n+//~^ ERROR unresolved import `use_from_trait_xc::Bar::new`\n \n use use_from_trait_xc::Baz::new as baznew;\n //~^ ERROR `baznew` is not directly importable"}, {"sha": "20dd16872a6535b5ba587114def42df640b15658", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -16,26 +16,30 @@ extern crate rustc;\n extern crate rustc_driver;\n extern crate rustc_front;\n extern crate rustc_lint;\n+extern crate rustc_metadata;\n extern crate rustc_resolve;\n extern crate syntax;\n \n use std::ffi::{CStr, CString};\n use std::mem::transmute;\n use std::path::PathBuf;\n+use std::rc::Rc;\n use std::thread::Builder;\n \n use rustc::front::map as ast_map;\n use rustc::llvm;\n-use rustc::metadata::cstore::RequireDynamic;\n+use rustc::middle::cstore::{CrateStore, LinkagePreference};\n use rustc::middle::ty;\n use rustc::session::config::{self, basic_options, build_configuration, Input, Options};\n use rustc::session::build_session;\n use rustc_driver::driver;\n use rustc_front::lowering::{lower_crate, LoweringContext};\n use rustc_resolve::MakeGlobMap;\n+use rustc_metadata::cstore::CStore;\n use libc::c_void;\n \n use syntax::diagnostics::registry::Registry;\n+use syntax::parse::token;\n \n fn main() {\n     let program = r#\"\n@@ -210,7 +214,10 @@ fn compile_program(input: &str, sysroot: PathBuf)\n \n     let handle = thread.spawn(move || {\n         let opts = build_exec_options(sysroot);\n-        let sess = build_session(opts, None, Registry::new(&rustc::DIAGNOSTICS));\n+        let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+        let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n+        let sess = build_session(opts, None, Registry::new(&rustc::DIAGNOSTICS),\n+                                 cstore_);\n         rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n         let cfg = build_configuration(&sess);\n@@ -219,7 +226,7 @@ fn compile_program(input: &str, sysroot: PathBuf)\n \n         let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n \n-        let krate = driver::phase_2_configure_and_expand(&sess, krate, &id, None)\n+        let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate, &id, None)\n             .expect(\"phase_2 returned `None`\");\n \n         let krate = driver::assign_node_ids(&sess, krate);\n@@ -229,11 +236,12 @@ fn compile_program(input: &str, sysroot: PathBuf)\n         let ast_map = driver::make_map(&sess, &mut hir_forest);\n \n         driver::phase_3_run_analysis_passes(\n-            &sess, ast_map, &arenas, &id, MakeGlobMap::No, |tcx, mir_map, analysis| {\n+            &sess, &cstore, ast_map, &arenas, &id,\n+            MakeGlobMap::No, |tcx, mir_map, analysis| {\n \n             let trans = driver::phase_4_translate_to_llvm(tcx, mir_map, analysis);\n \n-            let crates = tcx.sess.cstore.get_used_crates(RequireDynamic);\n+            let crates = tcx.sess.cstore.used_crates(LinkagePreference::RequireDynamic);\n \n             // Collect crates used in the session.\n             // Reverse order finds dependencies first."}, {"sha": "58bf5049cf13edfce6a04807455691b108af5c77", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -13,14 +13,18 @@\n extern crate rustc;\n extern crate rustc_driver;\n extern crate rustc_lint;\n+extern crate rustc_metadata;\n extern crate syntax;\n \n use rustc::session::{build_session, Session};\n use rustc::session::config::{basic_options, build_configuration, Input, OutputType};\n use rustc_driver::driver::{compile_input, CompileController};\n+use rustc_metadata::cstore::CStore;\n use syntax::diagnostics::registry::Registry;\n+use syntax::parse::token;\n \n use std::path::PathBuf;\n+use std::rc::Rc;\n \n fn main() {\n     let src = r#\"\n@@ -44,23 +48,25 @@ fn main() {\n     compile(src.to_string(), tmpdir.join(\"out\"), sysroot.clone());\n }\n \n-fn basic_sess(sysroot: PathBuf) -> Session {\n+fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n     let mut opts = basic_options();\n     opts.output_types.insert(OutputType::Exe, None);\n     opts.maybe_sysroot = Some(sysroot);\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n-    let sess = build_session(opts, None, descriptions);\n+    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+    let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n+    let sess = build_session(opts, None, descriptions, cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-    sess\n+    (sess, cstore)\n }\n \n fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n-    let sess = basic_sess(sysroot);\n+    let (sess, cstore) = basic_sess(sysroot);\n     let cfg = build_configuration(&sess);\n     let control = CompileController::basic();\n \n-    compile_input(sess,\n+    compile_input(sess, &cstore,\n             cfg,\n             &Input::Str(code),\n             &None,"}, {"sha": "2f425121f66a775927f28f5b46bacde73f7fd5b9", "filename": "src/test/run-make/libs-through-symlinks/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Frun-make%2Flibs-through-symlinks%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Frun-make%2Flibs-through-symlinks%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flibs-through-symlinks%2FMakefile?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -10,5 +10,5 @@ all:\n \tmkdir -p $(TMPDIR)/outdir\n \t$(RUSTC) foo.rs -o $(TMPDIR)/outdir/$(NAME)\n \tln -nsf outdir/$(NAME) $(TMPDIR)\n-\tRUST_LOG=rustc::metadata::loader $(RUSTC) bar.rs\n+\tRUST_LOG=rustc_metadata::loader $(RUSTC) bar.rs\n endif"}]}