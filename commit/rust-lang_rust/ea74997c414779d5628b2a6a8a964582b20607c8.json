{"sha": "ea74997c414779d5628b2a6a8a964582b20607c8", "node_id": "C_kwDOAAsO6NoAKGVhNzQ5OTdjNDE0Nzc5ZDU2MjhiMmE2YThhOTY0NTgyYjIwNjA3Yzg", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-23T00:45:40Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-26T21:58:28Z"}, "message": "Add a test checking the output of builtin derives.", "tree": {"sha": "3fcb51bbf1c9435e0a11747ddd151531269ca5bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fcb51bbf1c9435e0a11747ddd151531269ca5bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea74997c414779d5628b2a6a8a964582b20607c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea74997c414779d5628b2a6a8a964582b20607c8", "html_url": "https://github.com/rust-lang/rust/commit/ea74997c414779d5628b2a6a8a964582b20607c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea74997c414779d5628b2a6a8a964582b20607c8/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "788ddedb0d88e40db9cd62b6163d5a471813044b", "url": "https://api.github.com/repos/rust-lang/rust/commits/788ddedb0d88e40db9cd62b6163d5a471813044b", "html_url": "https://github.com/rust-lang/rust/commit/788ddedb0d88e40db9cd62b6163d5a471813044b"}], "stats": {"total": 1163, "additions": 1163, "deletions": 0}, "files": [{"sha": "2f6ef74ac49410866b0cf515bdd4aba01619ca84", "filename": "src/test/ui/deriving/deriving-all-codegen.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ea74997c414779d5628b2a6a8a964582b20607c8/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74997c414779d5628b2a6a8a964582b20607c8/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.rs?ref=ea74997c414779d5628b2a6a8a964582b20607c8", "patch": "@@ -0,0 +1,63 @@\n+// check-pass\n+// compile-flags: -Zunpretty=expanded\n+// edition:2021\n+//\n+// This test checks the code generated for all[*] the builtin derivable traits\n+// on a variety of structs and enums. It protects against accidental changes to\n+// the generated code, and makes deliberate changes to the generated code\n+// easier to review.\n+//\n+// [*] It excludes `Copy` in some cases, because that changes the code\n+// generated for `Clone`.\n+//\n+// [*] It excludes `RustcEncodable` and `RustDecodable`, which are obsolete and\n+// also require the `rustc_serialize` crate.\n+\n+#![crate_type = \"lib\"]\n+#![allow(dead_code)]\n+#![allow(deprecated)]\n+\n+// Empty struct.\n+#[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+struct Empty;\n+\n+// A basic struct.\n+#[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+struct Point {\n+    x: u32,\n+    y: u32,\n+}\n+\n+// A long struct.\n+#[derive(Clone, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+struct Big {\n+    b1: u32, b2: u32, b3: u32, b4: u32, b5: u32, b6: u32, b7: u32, b8:u32,\n+}\n+\n+// A C-like, fieldless enum.\n+#[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+enum Fieldless {\n+    #[default]\n+    A,\n+    B,\n+    C,\n+}\n+\n+// An enum with multiple fieldless and fielded variants.\n+#[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+enum Mixed {\n+    #[default]\n+    P,\n+    Q,\n+    R(u32),\n+    S { d1: u32, d2: u32 },\n+}\n+\n+// An enum with no fieldless variants. Note that `Default` cannot be derived\n+// for this enum.\n+#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+enum Fielded {\n+    X(u32),\n+    Y(bool),\n+    Z(Option<i32>),\n+}"}, {"sha": "88aae2da6545952f60af852ba798cb97f9bb53dd", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "added", "additions": 1100, "deletions": 0, "changes": 1100, "blob_url": "https://github.com/rust-lang/rust/blob/ea74997c414779d5628b2a6a8a964582b20607c8/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ea74997c414779d5628b2a6a8a964582b20607c8/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=ea74997c414779d5628b2a6a8a964582b20607c8", "patch": "@@ -0,0 +1,1100 @@\n+#![feature(prelude_import)]\n+// check-pass\n+// compile-flags: -Zunpretty=expanded\n+// edition:2021\n+//\n+// This test checks the code generated for all[*] the builtin derivable traits\n+// on a variety of structs and enums. It protects against accidental changes to\n+// the generated code, and makes deliberate changes to the generated code\n+// easier to review.\n+//\n+// [*] It excludes `Copy` in some cases, because that changes the code\n+// generated for `Clone`.\n+//\n+// [*] It excludes `RustcEncodable` and `RustDecodable`, which are obsolete and\n+// also require the `rustc_serialize` crate.\n+\n+#![crate_type = \"lib\"]\n+#![allow(dead_code)]\n+#![allow(deprecated)]\n+#[prelude_import]\n+use std::prelude::rust_2021::*;\n+#[macro_use]\n+extern crate std;\n+\n+// Empty struct.\n+struct Empty;\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Empty {\n+    #[inline]\n+    fn clone(&self) -> Empty { { *self } }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::marker::Copy for Empty { }\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::fmt::Debug for Empty {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        match *self { Self => ::core::fmt::Formatter::write_str(f, \"Empty\"), }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::default::Default for Empty {\n+    #[inline]\n+    fn default() -> Empty { Empty {} }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::hash::Hash for Empty {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        match *self { Self => {} }\n+    }\n+}\n+impl ::core::marker::StructuralPartialEq for Empty {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialEq for Empty {\n+    #[inline]\n+    fn eq(&self, other: &Empty) -> bool {\n+        match *other { Self => match *self { Self => true, }, }\n+    }\n+}\n+impl ::core::marker::StructuralEq for Empty {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Eq for Empty {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () { {} }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialOrd for Empty {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Empty)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        match *other {\n+            Self =>\n+                match *self {\n+                    Self =>\n+                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                },\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Ord for Empty {\n+    #[inline]\n+    fn cmp(&self, other: &Empty) -> ::core::cmp::Ordering {\n+        match *other {\n+            Self => match *self { Self => ::core::cmp::Ordering::Equal, },\n+        }\n+    }\n+}\n+\n+// A basic struct.\n+struct Point {\n+    x: u32,\n+    y: u32,\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Point {\n+    #[inline]\n+    fn clone(&self) -> Point {\n+        {\n+            let _: ::core::clone::AssertParamIsClone<u32>;\n+            let _: ::core::clone::AssertParamIsClone<u32>;\n+            *self\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::marker::Copy for Point { }\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::fmt::Debug for Point {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        match *self {\n+            Self { x: ref __self_0_0, y: ref __self_0_1 } =>\n+                ::core::fmt::Formatter::debug_struct_field2_finish(f, \"Point\",\n+                    \"x\", &&(*__self_0_0), \"y\", &&(*__self_0_1)),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::default::Default for Point {\n+    #[inline]\n+    fn default() -> Point {\n+        Point {\n+            x: ::core::default::Default::default(),\n+            y: ::core::default::Default::default(),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::hash::Hash for Point {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        match *self {\n+            Self { x: ref __self_0_0, y: ref __self_0_1 } => {\n+                ::core::hash::Hash::hash(&(*__self_0_0), state);\n+                ::core::hash::Hash::hash(&(*__self_0_1), state)\n+            }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralPartialEq for Point {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialEq for Point {\n+    #[inline]\n+    fn eq(&self, other: &Point) -> bool {\n+        match *other {\n+            Self { x: ref __self_1_0, y: ref __self_1_1 } =>\n+                match *self {\n+                    Self { x: ref __self_0_0, y: ref __self_0_1 } =>\n+                        (*__self_0_0) == (*__self_1_0) &&\n+                            (*__self_0_1) == (*__self_1_1),\n+                },\n+        }\n+    }\n+    #[inline]\n+    fn ne(&self, other: &Point) -> bool {\n+        match *other {\n+            Self { x: ref __self_1_0, y: ref __self_1_1 } =>\n+                match *self {\n+                    Self { x: ref __self_0_0, y: ref __self_0_1 } =>\n+                        (*__self_0_0) != (*__self_1_0) ||\n+                            (*__self_0_1) != (*__self_1_1),\n+                },\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralEq for Point {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Eq for Point {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () {\n+        {\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialOrd for Point {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Point)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        match *other {\n+            Self { x: ref __self_1_0, y: ref __self_1_1 } =>\n+                match *self {\n+                    Self { x: ref __self_0_0, y: ref __self_0_1 } =>\n+                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),\n+                                &(*__self_1_0)) {\n+                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                =>\n+                                match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),\n+                                        &(*__self_1_1)) {\n+                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                        =>\n+                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                                    cmp => cmp,\n+                                },\n+                            cmp => cmp,\n+                        },\n+                },\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Ord for Point {\n+    #[inline]\n+    fn cmp(&self, other: &Point) -> ::core::cmp::Ordering {\n+        match *other {\n+            Self { x: ref __self_1_0, y: ref __self_1_1 } =>\n+                match *self {\n+                    Self { x: ref __self_0_0, y: ref __self_0_1 } =>\n+                        match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0))\n+                            {\n+                            ::core::cmp::Ordering::Equal =>\n+                                match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1))\n+                                    {\n+                                    ::core::cmp::Ordering::Equal =>\n+                                        ::core::cmp::Ordering::Equal,\n+                                    cmp => cmp,\n+                                },\n+                            cmp => cmp,\n+                        },\n+                },\n+        }\n+    }\n+}\n+\n+// A long struct.\n+struct Big {\n+    b1: u32,\n+    b2: u32,\n+    b3: u32,\n+    b4: u32,\n+    b5: u32,\n+    b6: u32,\n+    b7: u32,\n+    b8: u32,\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Big {\n+    #[inline]\n+    fn clone(&self) -> Big {\n+        match *self {\n+            Self {\n+                b1: ref __self_0_0,\n+                b2: ref __self_0_1,\n+                b3: ref __self_0_2,\n+                b4: ref __self_0_3,\n+                b5: ref __self_0_4,\n+                b6: ref __self_0_5,\n+                b7: ref __self_0_6,\n+                b8: ref __self_0_7 } =>\n+                Big {\n+                    b1: ::core::clone::Clone::clone(&(*__self_0_0)),\n+                    b2: ::core::clone::Clone::clone(&(*__self_0_1)),\n+                    b3: ::core::clone::Clone::clone(&(*__self_0_2)),\n+                    b4: ::core::clone::Clone::clone(&(*__self_0_3)),\n+                    b5: ::core::clone::Clone::clone(&(*__self_0_4)),\n+                    b6: ::core::clone::Clone::clone(&(*__self_0_5)),\n+                    b7: ::core::clone::Clone::clone(&(*__self_0_6)),\n+                    b8: ::core::clone::Clone::clone(&(*__self_0_7)),\n+                },\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::fmt::Debug for Big {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        match *self {\n+            Self {\n+                b1: ref __self_0_0,\n+                b2: ref __self_0_1,\n+                b3: ref __self_0_2,\n+                b4: ref __self_0_3,\n+                b5: ref __self_0_4,\n+                b6: ref __self_0_5,\n+                b7: ref __self_0_6,\n+                b8: ref __self_0_7 } => {\n+                let names: &'static _ =\n+                    &[\"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\", \"b8\"];\n+                let values: &[&dyn ::core::fmt::Debug] =\n+                    &[&&(*__self_0_0), &&(*__self_0_1), &&(*__self_0_2),\n+                                &&(*__self_0_3), &&(*__self_0_4), &&(*__self_0_5),\n+                                &&(*__self_0_6), &&(*__self_0_7)];\n+                ::core::fmt::Formatter::debug_struct_fields_finish(f, \"Big\",\n+                    names, values)\n+            }\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::default::Default for Big {\n+    #[inline]\n+    fn default() -> Big {\n+        Big {\n+            b1: ::core::default::Default::default(),\n+            b2: ::core::default::Default::default(),\n+            b3: ::core::default::Default::default(),\n+            b4: ::core::default::Default::default(),\n+            b5: ::core::default::Default::default(),\n+            b6: ::core::default::Default::default(),\n+            b7: ::core::default::Default::default(),\n+            b8: ::core::default::Default::default(),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::hash::Hash for Big {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        match *self {\n+            Self {\n+                b1: ref __self_0_0,\n+                b2: ref __self_0_1,\n+                b3: ref __self_0_2,\n+                b4: ref __self_0_3,\n+                b5: ref __self_0_4,\n+                b6: ref __self_0_5,\n+                b7: ref __self_0_6,\n+                b8: ref __self_0_7 } => {\n+                ::core::hash::Hash::hash(&(*__self_0_0), state);\n+                ::core::hash::Hash::hash(&(*__self_0_1), state);\n+                ::core::hash::Hash::hash(&(*__self_0_2), state);\n+                ::core::hash::Hash::hash(&(*__self_0_3), state);\n+                ::core::hash::Hash::hash(&(*__self_0_4), state);\n+                ::core::hash::Hash::hash(&(*__self_0_5), state);\n+                ::core::hash::Hash::hash(&(*__self_0_6), state);\n+                ::core::hash::Hash::hash(&(*__self_0_7), state)\n+            }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralPartialEq for Big {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialEq for Big {\n+    #[inline]\n+    fn eq(&self, other: &Big) -> bool {\n+        match *other {\n+            Self {\n+                b1: ref __self_1_0,\n+                b2: ref __self_1_1,\n+                b3: ref __self_1_2,\n+                b4: ref __self_1_3,\n+                b5: ref __self_1_4,\n+                b6: ref __self_1_5,\n+                b7: ref __self_1_6,\n+                b8: ref __self_1_7 } =>\n+                match *self {\n+                    Self {\n+                        b1: ref __self_0_0,\n+                        b2: ref __self_0_1,\n+                        b3: ref __self_0_2,\n+                        b4: ref __self_0_3,\n+                        b5: ref __self_0_4,\n+                        b6: ref __self_0_5,\n+                        b7: ref __self_0_6,\n+                        b8: ref __self_0_7 } =>\n+                        (*__self_0_0) == (*__self_1_0) &&\n+                                                    (*__self_0_1) == (*__self_1_1) &&\n+                                                (*__self_0_2) == (*__self_1_2) &&\n+                                            (*__self_0_3) == (*__self_1_3) &&\n+                                        (*__self_0_4) == (*__self_1_4) &&\n+                                    (*__self_0_5) == (*__self_1_5) &&\n+                                (*__self_0_6) == (*__self_1_6) &&\n+                            (*__self_0_7) == (*__self_1_7),\n+                },\n+        }\n+    }\n+    #[inline]\n+    fn ne(&self, other: &Big) -> bool {\n+        match *other {\n+            Self {\n+                b1: ref __self_1_0,\n+                b2: ref __self_1_1,\n+                b3: ref __self_1_2,\n+                b4: ref __self_1_3,\n+                b5: ref __self_1_4,\n+                b6: ref __self_1_5,\n+                b7: ref __self_1_6,\n+                b8: ref __self_1_7 } =>\n+                match *self {\n+                    Self {\n+                        b1: ref __self_0_0,\n+                        b2: ref __self_0_1,\n+                        b3: ref __self_0_2,\n+                        b4: ref __self_0_3,\n+                        b5: ref __self_0_4,\n+                        b6: ref __self_0_5,\n+                        b7: ref __self_0_6,\n+                        b8: ref __self_0_7 } =>\n+                        (*__self_0_0) != (*__self_1_0) ||\n+                                                    (*__self_0_1) != (*__self_1_1) ||\n+                                                (*__self_0_2) != (*__self_1_2) ||\n+                                            (*__self_0_3) != (*__self_1_3) ||\n+                                        (*__self_0_4) != (*__self_1_4) ||\n+                                    (*__self_0_5) != (*__self_1_5) ||\n+                                (*__self_0_6) != (*__self_1_6) ||\n+                            (*__self_0_7) != (*__self_1_7),\n+                },\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralEq for Big {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Eq for Big {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () {\n+        {\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialOrd for Big {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Big)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        match *other {\n+            Self {\n+                b1: ref __self_1_0,\n+                b2: ref __self_1_1,\n+                b3: ref __self_1_2,\n+                b4: ref __self_1_3,\n+                b5: ref __self_1_4,\n+                b6: ref __self_1_5,\n+                b7: ref __self_1_6,\n+                b8: ref __self_1_7 } =>\n+                match *self {\n+                    Self {\n+                        b1: ref __self_0_0,\n+                        b2: ref __self_0_1,\n+                        b3: ref __self_0_2,\n+                        b4: ref __self_0_3,\n+                        b5: ref __self_0_4,\n+                        b6: ref __self_0_5,\n+                        b7: ref __self_0_6,\n+                        b8: ref __self_0_7 } =>\n+                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),\n+                                &(*__self_1_0)) {\n+                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                =>\n+                                match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),\n+                                        &(*__self_1_1)) {\n+                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                        =>\n+                                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_2),\n+                                                &(*__self_1_2)) {\n+                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                                =>\n+                                                match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_3),\n+                                                        &(*__self_1_3)) {\n+                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                                        =>\n+                                                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_4),\n+                                                                &(*__self_1_4)) {\n+                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                                                =>\n+                                                                match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_5),\n+                                                                        &(*__self_1_5)) {\n+                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                                                        =>\n+                                                                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_6),\n+                                                                                &(*__self_1_6)) {\n+                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                                                                =>\n+                                                                                match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_7),\n+                                                                                        &(*__self_1_7)) {\n+                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                                                                        =>\n+                                                                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                                                                                    cmp => cmp,\n+                                                                                },\n+                                                                            cmp => cmp,\n+                                                                        },\n+                                                                    cmp => cmp,\n+                                                                },\n+                                                            cmp => cmp,\n+                                                        },\n+                                                    cmp => cmp,\n+                                                },\n+                                            cmp => cmp,\n+                                        },\n+                                    cmp => cmp,\n+                                },\n+                            cmp => cmp,\n+                        },\n+                },\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Ord for Big {\n+    #[inline]\n+    fn cmp(&self, other: &Big) -> ::core::cmp::Ordering {\n+        match *other {\n+            Self {\n+                b1: ref __self_1_0,\n+                b2: ref __self_1_1,\n+                b3: ref __self_1_2,\n+                b4: ref __self_1_3,\n+                b5: ref __self_1_4,\n+                b6: ref __self_1_5,\n+                b7: ref __self_1_6,\n+                b8: ref __self_1_7 } =>\n+                match *self {\n+                    Self {\n+                        b1: ref __self_0_0,\n+                        b2: ref __self_0_1,\n+                        b3: ref __self_0_2,\n+                        b4: ref __self_0_3,\n+                        b5: ref __self_0_4,\n+                        b6: ref __self_0_5,\n+                        b7: ref __self_0_6,\n+                        b8: ref __self_0_7 } =>\n+                        match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0))\n+                            {\n+                            ::core::cmp::Ordering::Equal =>\n+                                match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1))\n+                                    {\n+                                    ::core::cmp::Ordering::Equal =>\n+                                        match ::core::cmp::Ord::cmp(&(*__self_0_2), &(*__self_1_2))\n+                                            {\n+                                            ::core::cmp::Ordering::Equal =>\n+                                                match ::core::cmp::Ord::cmp(&(*__self_0_3), &(*__self_1_3))\n+                                                    {\n+                                                    ::core::cmp::Ordering::Equal =>\n+                                                        match ::core::cmp::Ord::cmp(&(*__self_0_4), &(*__self_1_4))\n+                                                            {\n+                                                            ::core::cmp::Ordering::Equal =>\n+                                                                match ::core::cmp::Ord::cmp(&(*__self_0_5), &(*__self_1_5))\n+                                                                    {\n+                                                                    ::core::cmp::Ordering::Equal =>\n+                                                                        match ::core::cmp::Ord::cmp(&(*__self_0_6), &(*__self_1_6))\n+                                                                            {\n+                                                                            ::core::cmp::Ordering::Equal =>\n+                                                                                match ::core::cmp::Ord::cmp(&(*__self_0_7), &(*__self_1_7))\n+                                                                                    {\n+                                                                                    ::core::cmp::Ordering::Equal =>\n+                                                                                        ::core::cmp::Ordering::Equal,\n+                                                                                    cmp => cmp,\n+                                                                                },\n+                                                                            cmp => cmp,\n+                                                                        },\n+                                                                    cmp => cmp,\n+                                                                },\n+                                                            cmp => cmp,\n+                                                        },\n+                                                    cmp => cmp,\n+                                                },\n+                                            cmp => cmp,\n+                                        },\n+                                    cmp => cmp,\n+                                },\n+                            cmp => cmp,\n+                        },\n+                },\n+        }\n+    }\n+}\n+\n+// A C-like, fieldless enum.\n+enum Fieldless {\n+\n+    #[default]\n+    A,\n+    B,\n+    C,\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Fieldless {\n+    #[inline]\n+    fn clone(&self) -> Fieldless { { *self } }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::marker::Copy for Fieldless { }\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::fmt::Debug for Fieldless {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        match (&*self,) {\n+            (&Fieldless::A,) => ::core::fmt::Formatter::write_str(f, \"A\"),\n+            (&Fieldless::B,) => ::core::fmt::Formatter::write_str(f, \"B\"),\n+            (&Fieldless::C,) => ::core::fmt::Formatter::write_str(f, \"C\"),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::default::Default for Fieldless {\n+    #[inline]\n+    fn default() -> Fieldless { Self::A }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::hash::Hash for Fieldless {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        match (&*self,) {\n+            _ => {\n+                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n+                    state)\n+            }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralPartialEq for Fieldless {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialEq for Fieldless {\n+    #[inline]\n+    fn eq(&self, other: &Fieldless) -> bool {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if true && __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) { _ => true, }\n+                } else { false }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralEq for Fieldless {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Eq for Fieldless {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () { {} }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialOrd for Fieldless {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Fieldless)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if true && __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        _ =>\n+                            ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                    }\n+                } else {\n+                   ::core::cmp::PartialOrd::partial_cmp(&__self_vi,\n+                       &__arg_1_vi)\n+               }\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Ord for Fieldless {\n+    #[inline]\n+    fn cmp(&self, other: &Fieldless) -> ::core::cmp::Ordering {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if true && __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        _ => ::core::cmp::Ordering::Equal,\n+                    }\n+                } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n+        }\n+    }\n+}\n+\n+// An enum with multiple fieldless and fielded variants.\n+enum Mixed {\n+\n+    #[default]\n+    P,\n+    Q,\n+    R(u32),\n+    S {\n+        d1: u32,\n+        d2: u32,\n+    },\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Mixed {\n+    #[inline]\n+    fn clone(&self) -> Mixed {\n+        {\n+            let _: ::core::clone::AssertParamIsClone<u32>;\n+            let _: ::core::clone::AssertParamIsClone<u32>;\n+            let _: ::core::clone::AssertParamIsClone<u32>;\n+            *self\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::marker::Copy for Mixed { }\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::fmt::Debug for Mixed {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        match (&*self,) {\n+            (&Mixed::P,) => ::core::fmt::Formatter::write_str(f, \"P\"),\n+            (&Mixed::Q,) => ::core::fmt::Formatter::write_str(f, \"Q\"),\n+            (&Mixed::R(ref __self_0),) =>\n+                ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"R\",\n+                    &&(*__self_0)),\n+            (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },) =>\n+                ::core::fmt::Formatter::debug_struct_field2_finish(f, \"S\",\n+                    \"d1\", &&(*__self_0), \"d2\", &&(*__self_1)),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::default::Default for Mixed {\n+    #[inline]\n+    fn default() -> Mixed { Self::P }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::hash::Hash for Mixed {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        match (&*self,) {\n+            (&Mixed::R(ref __self_0),) => {\n+                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n+                    state);\n+                ::core::hash::Hash::hash(&(*__self_0), state)\n+            }\n+            (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },) => {\n+                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n+                    state);\n+                ::core::hash::Hash::hash(&(*__self_0), state);\n+                ::core::hash::Hash::hash(&(*__self_1), state)\n+            }\n+            _ => {\n+                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n+                    state)\n+            }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralPartialEq for Mixed {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialEq for Mixed {\n+    #[inline]\n+    fn eq(&self, other: &Mixed) -> bool {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if true && __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                            (*__self_0) == (*__arg_1_0),\n+                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                            (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),\n+                        _ => true,\n+                    }\n+                } else { false }\n+        }\n+    }\n+    #[inline]\n+    fn ne(&self, other: &Mixed) -> bool {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if true && __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                            (*__self_0) != (*__arg_1_0),\n+                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                            (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),\n+                        _ => false,\n+                    }\n+                } else { true }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralEq for Mixed {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Eq for Mixed {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () {\n+        {\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialOrd for Mixed {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Mixed)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if true && __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n+                                    &(*__arg_1_0)) {\n+                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                    =>\n+                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                                cmp => cmp,\n+                            },\n+                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n+                                    &(*__arg_1_0)) {\n+                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                    =>\n+                                    match ::core::cmp::PartialOrd::partial_cmp(&(*__self_1),\n+                                            &(*__arg_1_1)) {\n+                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                            =>\n+                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                                        cmp => cmp,\n+                                    },\n+                                cmp => cmp,\n+                            },\n+                        _ =>\n+                            ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                    }\n+                } else {\n+                   ::core::cmp::PartialOrd::partial_cmp(&__self_vi,\n+                       &__arg_1_vi)\n+               }\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Ord for Mixed {\n+    #[inline]\n+    fn cmp(&self, other: &Mixed) -> ::core::cmp::Ordering {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if true && __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n+                                ::core::cmp::Ordering::Equal =>\n+                                    ::core::cmp::Ordering::Equal,\n+                                cmp => cmp,\n+                            },\n+                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n+                                ::core::cmp::Ordering::Equal =>\n+                                    match ::core::cmp::Ord::cmp(&(*__self_1), &(*__arg_1_1)) {\n+                                        ::core::cmp::Ordering::Equal =>\n+                                            ::core::cmp::Ordering::Equal,\n+                                        cmp => cmp,\n+                                    },\n+                                cmp => cmp,\n+                            },\n+                        _ => ::core::cmp::Ordering::Equal,\n+                    }\n+                } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n+        }\n+    }\n+}\n+\n+// An enum with no fieldless variants. Note that `Default` cannot be derived\n+// for this enum.\n+enum Fielded { X(u32), Y(bool), Z(Option<i32>), }\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Fielded {\n+    #[inline]\n+    fn clone(&self) -> Fielded {\n+        match (&*self,) {\n+            (&Fielded::X(ref __self_0),) =>\n+                Fielded::X(::core::clone::Clone::clone(&(*__self_0))),\n+            (&Fielded::Y(ref __self_0),) =>\n+                Fielded::Y(::core::clone::Clone::clone(&(*__self_0))),\n+            (&Fielded::Z(ref __self_0),) =>\n+                Fielded::Z(::core::clone::Clone::clone(&(*__self_0))),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::fmt::Debug for Fielded {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        match (&*self,) {\n+            (&Fielded::X(ref __self_0),) =>\n+                ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"X\",\n+                    &&(*__self_0)),\n+            (&Fielded::Y(ref __self_0),) =>\n+                ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Y\",\n+                    &&(*__self_0)),\n+            (&Fielded::Z(ref __self_0),) =>\n+                ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Z\",\n+                    &&(*__self_0)),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::hash::Hash for Fielded {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        match (&*self,) {\n+            (&Fielded::X(ref __self_0),) => {\n+                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n+                    state);\n+                ::core::hash::Hash::hash(&(*__self_0), state)\n+            }\n+            (&Fielded::Y(ref __self_0),) => {\n+                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n+                    state);\n+                ::core::hash::Hash::hash(&(*__self_0), state)\n+            }\n+            (&Fielded::Z(ref __self_0),) => {\n+                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n+                    state);\n+                ::core::hash::Hash::hash(&(*__self_0), state)\n+            }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralPartialEq for Fielded {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialEq for Fielded {\n+    #[inline]\n+    fn eq(&self, other: &Fielded) -> bool {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if true && __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                            (*__self_0) == (*__arg_1_0),\n+                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                            (*__self_0) == (*__arg_1_0),\n+                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                            (*__self_0) == (*__arg_1_0),\n+                        _ => unsafe { ::core::intrinsics::unreachable() }\n+                    }\n+                } else { false }\n+        }\n+    }\n+    #[inline]\n+    fn ne(&self, other: &Fielded) -> bool {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if true && __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                            (*__self_0) != (*__arg_1_0),\n+                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                            (*__self_0) != (*__arg_1_0),\n+                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                            (*__self_0) != (*__arg_1_0),\n+                        _ => unsafe { ::core::intrinsics::unreachable() }\n+                    }\n+                } else { true }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralEq for Fielded {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Eq for Fielded {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () {\n+        {\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<bool>;\n+            let _: ::core::cmp::AssertParamIsEq<Option<i32>>;\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialOrd for Fielded {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Fielded)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if true && __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n+                                    &(*__arg_1_0)) {\n+                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                    =>\n+                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                                cmp => cmp,\n+                            },\n+                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n+                                    &(*__arg_1_0)) {\n+                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                    =>\n+                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                                cmp => cmp,\n+                            },\n+                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n+                                    &(*__arg_1_0)) {\n+                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                    =>\n+                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                                cmp => cmp,\n+                            },\n+                        _ => unsafe { ::core::intrinsics::unreachable() }\n+                    }\n+                } else {\n+                   ::core::cmp::PartialOrd::partial_cmp(&__self_vi,\n+                       &__arg_1_vi)\n+               }\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Ord for Fielded {\n+    #[inline]\n+    fn cmp(&self, other: &Fielded) -> ::core::cmp::Ordering {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if true && __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n+                                ::core::cmp::Ordering::Equal =>\n+                                    ::core::cmp::Ordering::Equal,\n+                                cmp => cmp,\n+                            },\n+                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n+                                ::core::cmp::Ordering::Equal =>\n+                                    ::core::cmp::Ordering::Equal,\n+                                cmp => cmp,\n+                            },\n+                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n+                                ::core::cmp::Ordering::Equal =>\n+                                    ::core::cmp::Ordering::Equal,\n+                                cmp => cmp,\n+                            },\n+                        _ => unsafe { ::core::intrinsics::unreachable() }\n+                    }\n+                } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n+        }\n+    }\n+}"}]}