{"sha": "6d7b35bd98858a8095fbc205115cedf069434f7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkN2IzNWJkOTg4NThhODA5NWZiYzIwNTExNWNlZGYwNjk0MzRmN2Y=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-06-03T20:15:00Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-06-09T22:06:37Z"}, "message": "Address review comments + fix rebase", "tree": {"sha": "e08cdb6ca15086992180b9b05204f67801cdc0a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e08cdb6ca15086992180b9b05204f67801cdc0a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d7b35bd98858a8095fbc205115cedf069434f7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d7b35bd98858a8095fbc205115cedf069434f7f", "html_url": "https://github.com/rust-lang/rust/commit/6d7b35bd98858a8095fbc205115cedf069434f7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d7b35bd98858a8095fbc205115cedf069434f7f/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e783a0a5e39d5ae2fa147508197d09a51530fae8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e783a0a5e39d5ae2fa147508197d09a51530fae8", "html_url": "https://github.com/rust-lang/rust/commit/e783a0a5e39d5ae2fa147508197d09a51530fae8"}], "stats": {"total": 218, "additions": 51, "deletions": 167}, "files": [{"sha": "d513af10b361829b8590491f14602d0655daf14d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6d7b35bd98858a8095fbc205115cedf069434f7f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7b35bd98858a8095fbc205115cedf069434f7f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=6d7b35bd98858a8095fbc205115cedf069434f7f", "patch": "@@ -1105,17 +1105,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         (*op)(self, cmt.clone(), pat);\n \n-        // This function can be used during region checking when not all paths are fully\n-        // resolved. Partially resolved paths in patterns can only legally refer to\n-        // associated constants which don't require categorization.\n-        let opt_def = if let Some(path_res) = self.tcx().def_map.borrow().get(&pat.id) {\n-            if path_res.depth != 0 || path_res.base_def == Def::Err {\n-                return Err(());\n-            }\n-            Some(path_res.full_def())\n-        } else {\n-            None\n-        };\n+        let opt_def = self.tcx().expect_def_or_none(pat.id);\n+        if opt_def == Some(Def::Err) {\n+            return Err(());\n+        }\n \n         // Note: This goes up here (rather than within the PatKind::TupleStruct arm\n         // alone) because struct patterns can refer to struct types or"}, {"sha": "1bc3954a5fe7589dc1ca000cbaa1e618cc262fc7", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d7b35bd98858a8095fbc205115cedf069434f7f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7b35bd98858a8095fbc205115cedf069434f7f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=6d7b35bd98858a8095fbc205115cedf069434f7f", "patch": "@@ -162,7 +162,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n             }\n \n             PatKind::Binding(bm, ref ident, ref sub) => {\n-                let id = self.cx.tcx.def_map.borrow()[&pat.id].full_def().var_id();\n+                let id = self.cx.tcx.expect_def(pat.id).var_id();\n                 let var_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(&r, _) => Some(r),"}, {"sha": "75bfe7c0f2f9524bf9baa8a363d7c3501fe48986", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6d7b35bd98858a8095fbc205115cedf069434f7f/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7b35bd98858a8095fbc205115cedf069434f7f/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=6d7b35bd98858a8095fbc205115cedf069434f7f", "patch": "@@ -584,7 +584,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         hir::ExprStruct(..) => {\n-            if v.tcx.expect_def(e.id).def_id() == v.tcx.lang_items.unsafe_cell_type().unwrap() {\n+            // unsafe_cell_type doesn't necessarily exist with no_core\n+            if Some(v.tcx.expect_def(e.id).def_id()) == v.tcx.lang_items.unsafe_cell_type() {\n                 v.add_qualif(ConstQualif::MUTABLE_MEM);\n             }\n         }"}, {"sha": "476b9a5447b0788d40f230b0853d51be460eff55", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 126, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/6d7b35bd98858a8095fbc205115cedf069434f7f/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7b35bd98858a8095fbc205115cedf069434f7f/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=6d7b35bd98858a8095fbc205115cedf069434f7f", "patch": "@@ -677,100 +677,6 @@ fn foo<T>(x: T) {} // ok!\n ```\n \"##,\n \n-E0413: r##\"\n-A declaration shadows an enum variant or unit-like struct in scope. Example of\n-erroneous code:\n-\n-```compile_fail\n-struct Foo;\n-\n-let Foo = 12i32; // error: declaration of `Foo` shadows an enum variant or\n-                 //        unit-like struct in scope\n-```\n-\n-To fix this error, rename the variable such that it doesn't shadow any enum\n-variable or structure in scope. Example:\n-\n-```\n-struct Foo;\n-\n-let foo = 12i32; // ok!\n-```\n-\n-Or:\n-\n-```\n-struct FooStruct;\n-\n-let Foo = 12i32; // ok!\n-```\n-\n-The goal here is to avoid a conflict of names.\n-\"##,\n-\n-E0414: r##\"\n-A variable binding in an irrefutable pattern is shadowing the name of a\n-constant. Example of erroneous code:\n-\n-```compile_fail\n-const FOO: u8 = 7;\n-\n-let FOO = 5; // error: variable bindings cannot shadow constants\n-\n-// or\n-\n-fn bar(FOO: u8) { // error: variable bindings cannot shadow constants\n-\n-}\n-\n-// or\n-\n-for FOO in bar {\n-\n-}\n-```\n-\n-Introducing a new variable in Rust is done through a pattern. Thus you can have\n-`let` bindings like `let (a, b) = ...`. However, patterns also allow constants\n-in them, e.g. if you want to match over a constant:\n-\n-```ignore\n-const FOO: u8 = 1;\n-\n-match (x,y) {\n- (3, 4) => { .. }, // it is (3,4)\n- (FOO, 1) => { .. }, // it is (1,1)\n- (foo, 1) => { .. }, // it is (anything, 1)\n-                     // call the value in the first slot \"foo\"\n- _ => { .. } // it is anything\n-}\n-```\n-\n-Here, the second arm matches the value of `x` against the constant `FOO`,\n-whereas the third arm will accept any value of `x` and call it `foo`.\n-\n-This works for `match`, however in cases where an irrefutable pattern is\n-required, constants can't be used. An irrefutable pattern is one which always\n-matches, whose purpose is only to bind variable names to values. These are\n-required by let, for, and function argument patterns.\n-\n-Refutable patterns in such a situation do not make sense, for example:\n-\n-```ignore\n-let Some(x) = foo; // what if foo is None, instead?\n-\n-let (1, x) = foo; // what if foo.0 is not 1?\n-\n-let (SOME_CONST, x) = foo; // what if foo.0 is not SOME_CONST?\n-\n-let SOME_CONST = foo; // what if foo is not SOME_CONST?\n-```\n-\n-Thus, an irrefutable variable binding can't contain a constant.\n-\n-To fix this error, just give the marked variable a different name.\n-\"##,\n-\n E0415: r##\"\n More than one function parameter have the same name. Example of erroneous code:\n \n@@ -814,34 +720,6 @@ match (A, B, C) {\n ```\n \"##,\n \n-E0417: r##\"\n-A static variable was referenced in a pattern. Example of erroneous code:\n-\n-```compile_fail\n-static FOO : i32 = 0;\n-\n-match 0 {\n-    FOO => {} // error: static variables cannot be referenced in a\n-              //        pattern, use a `const` instead\n-    _ => {}\n-}\n-```\n-\n-The compiler needs to know the value of the pattern at compile time;\n-compile-time patterns can defined via const or enum items. Please verify\n-that the identifier is spelled correctly, and if so, use a const instead\n-of static to define it. Example:\n-\n-```\n-const FOO : i32 = 0;\n-\n-match 0 {\n-    FOO => {} // ok!\n-    _ => {}\n-}\n-```\n-\"##,\n-\n E0422: r##\"\n You are trying to use an identifier that is either undefined or not a struct.\n For instance:\n@@ -1221,11 +1099,23 @@ impl Foo for i32 {}\n }\n \n register_diagnostics! {\n+//  E0153, unused error code\n+//  E0157, unused error code\n     E0254, // import conflicts with imported crate in this module\n+//  E0257,\n+//  E0258,\n     E0402, // cannot use an outer type parameter in this context\n     E0406, // undeclared associated type\n-    E0418, // X bindings cannot shadow Ys\n-    E0419, // unresolved pattern path kind `name`\n-    E0420, // expected pattern path kind, found another pattern path kind\n-    E0427, // cannot use `ref` binding mode with ...\n+//  E0410, merged into 408\n+//  E0413, merged into 530\n+//  E0414, merged into 530\n+//  E0417, merged into 532\n+//  E0418, merged into 532\n+//  E0419, merged into 531\n+//  E0420, merged into 532\n+//  E0421, merged into 531\n+    E0530, // X bindings cannot shadow Ys\n+    E0531, // unresolved pattern path kind `name`\n+    E0532, // expected pattern path kind, found another pattern path kind\n+//  E0427, merged into 530\n }"}, {"sha": "377863b016d85057a803617f621ed49fc47362c6", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6d7b35bd98858a8095fbc205115cedf069434f7f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7b35bd98858a8095fbc205115cedf069434f7f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6d7b35bd98858a8095fbc205115cedf069434f7f", "patch": "@@ -155,11 +155,11 @@ enum ResolutionError<'a> {\n     CannotCaptureDynamicEnvironmentInFnItem,\n     /// error E0435: attempt to use a non-constant value in a constant\n     AttemptToUseNonConstantValueInConstant,\n-    /// error E0418: X bindings cannot shadow Ys\n+    /// error E0530: X bindings cannot shadow Ys\n     BindingShadowsSomethingUnacceptable(&'a str, &'a str, Name),\n-    /// error E0419: unresolved pattern path kind `name`\n+    /// error E0531: unresolved pattern path kind `name`\n     PatPathUnresolved(&'a str, &'a Path),\n-    /// error E0420: expected pattern path kind, found another pattern path kind\n+    /// error E0532: expected pattern path kind, found another pattern path kind\n     PatPathUnexpected(&'a str, &'a str, &'a Path),\n }\n \n@@ -426,11 +426,10 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n         ResolutionError::BindingShadowsSomethingUnacceptable(what_binding, shadows_what, name) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n-                                           E0418,\n+                                           E0530,\n                                            \"{}s cannot shadow {}s\", what_binding, shadows_what);\n             err.span_label(span, &format!(\"cannot be named the same as a {}\", shadows_what));\n-            if let Some(binding) = resolver.current_module\n-                                           .resolve_name_in_lexical_scope(name, ValueNS) {\n+            if let Success(binding) = resolver.current_module.resolve_name(name, ValueNS, true) {\n                 let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n                 err.span_label(binding.span, &format!(\"a {} `{}` is {} here\",\n                                                       shadows_what, name, participle));\n@@ -440,15 +439,15 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n         ResolutionError::PatPathUnresolved(expected_what, path) => {\n             struct_span_err!(resolver.session,\n                              span,\n-                             E0419,\n+                             E0531,\n                              \"unresolved {} `{}`\",\n                              expected_what,\n                              path.segments.last().unwrap().identifier)\n         }\n         ResolutionError::PatPathUnexpected(expected_what, found_what, path) => {\n             struct_span_err!(resolver.session,\n                              span,\n-                             E0420,\n+                             E0532,\n                              \"expected {}, found {} `{}`\",\n                              expected_what,\n                              found_what,\n@@ -2201,15 +2200,15 @@ impl<'a> Resolver<'a> {\n                      pat_id: NodeId,\n                      outer_pat_id: NodeId,\n                      pat_src: PatternSource,\n-                     bindings_list: &mut HashMap<Name, NodeId>)\n+                     bindings: &mut HashMap<Name, NodeId>)\n                      -> PathResolution {\n         // Add the binding to the local ribs, if it\n-        // doesn't already exist in the bindings list. (We\n-        // must not add it if it's in the bindings list\n+        // doesn't already exist in the bindings map. (We\n+        // must not add it if it's in the bindings map\n         // because that breaks the assumptions later\n         // passes make about or-patterns.)\n         let renamed = mtwt::resolve(ident.node);\n-        let def = match bindings_list.get(&renamed).cloned() {\n+        let def = match bindings.get(&renamed).cloned() {\n             Some(id) if id == outer_pat_id => {\n                 // `Variant(a, a)`, error\n                 resolve_error(\n@@ -2231,8 +2230,9 @@ impl<'a> Resolver<'a> {\n                 Def::Err\n             }\n             Some(..) if pat_src == PatternSource::Match => {\n-                // `Varian1(a) | Varian2(a)`, ok\n-                Def::Local(self.definitions.local_def_id(pat_id), pat_id)\n+                // `Variant1(a) | Variant2(a)`, ok\n+                // Reuse definition from the first `a`.\n+                self.value_ribs.last_mut().unwrap().bindings[&renamed]\n             }\n             Some(..) => {\n                 span_bug!(ident.span, \"two bindings with the same name from \\\n@@ -2244,7 +2244,7 @@ impl<'a> Resolver<'a> {\n                 // define `Invalid` bindings as `Def::Local`, just don't add them to the lists.\n                 let def = Def::Local(self.definitions.local_def_id(pat_id), pat_id);\n                 if ident.node.name != keywords::Invalid.name() {\n-                    bindings_list.insert(renamed, outer_pat_id);\n+                    bindings.insert(renamed, outer_pat_id);\n                     self.value_ribs.last_mut().unwrap().bindings.insert(renamed, def);\n                 }\n                 def\n@@ -2255,12 +2255,12 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_pattern_path<ExpectedFn>(&mut self,\n-                            pat_id: NodeId,\n-                            qself: Option<&QSelf>,\n-                            path: &Path,\n-                            namespace: Namespace,\n-                            expected_fn: ExpectedFn,\n-                            expected_what: &'static str)\n+                                        pat_id: NodeId,\n+                                        qself: Option<&QSelf>,\n+                                        path: &Path,\n+                                        namespace: Namespace,\n+                                        expected_fn: ExpectedFn,\n+                                        expected_what: &str)\n         where ExpectedFn: FnOnce(Def) -> bool\n     {\n         let resolution = if let Some(resolution) = self.resolve_possibly_assoc_item(pat_id,\n@@ -2307,8 +2307,8 @@ impl<'a> Resolver<'a> {\n                        pat_src: PatternSource,\n                        // Maps idents to the node ID for the\n                        // outermost pattern that binds them.\n-                       bindings_list: &mut HashMap<Name, NodeId>) {\n-        // Visit all direct subpatterns of this pattern with the same PatternBindingMode.\n+                       bindings: &mut HashMap<Name, NodeId>) {\n+        // Visit all direct subpatterns of this pattern.\n         let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n             match pat.node {\n@@ -2340,7 +2340,7 @@ impl<'a> Resolver<'a> {\n                                 // These entities are explicitly allowed\n                                 // to be shadowed by fresh bindings.\n                                 self.fresh_binding(ident, pat.id, outer_pat_id,\n-                                                   pat_src, bindings_list)\n+                                                   pat_src, bindings)\n                             }\n                             def => {\n                                 span_bug!(ident.span, \"unexpected definition for an \\\n@@ -2349,7 +2349,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     } else {\n                         // Fall back to a fresh binding.\n-                        self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings_list)\n+                        self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n                     };\n \n                     self.record_def(pat.id, resolution);"}, {"sha": "1cff392cf8338060f3e5dfbf85822449ad782e8f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d7b35bd98858a8095fbc205115cedf069434f7f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7b35bd98858a8095fbc205115cedf069434f7f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=6d7b35bd98858a8095fbc205115cedf069434f7f", "patch": "@@ -151,7 +151,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // is good enough.\n                 self.demand_suptype(pat.span, expected, const_ty);\n             }\n-            PatKind::Binding(bm, ref path, ref sub) => {\n+            PatKind::Binding(bm, _, ref sub) => {\n                 let typ = self.local_ty(pat.span, pat.id);\n                 match bm {\n                     hir::BindByRef(mutbl) => {\n@@ -180,7 +180,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n-                match tcx.def_map.borrow()[&pat.id].full_def() {\n+                match tcx.expect_def(pat.id) {\n                     Def::Err => {}\n                     Def::Local(_, var_id) => {\n                         if var_id != pat.id {"}, {"sha": "d9dd122d07376e49b7ecf28c176d98b35ba3df42", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d7b35bd98858a8095fbc205115cedf069434f7f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7b35bd98858a8095fbc205115cedf069434f7f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6d7b35bd98858a8095fbc205115cedf069434f7f", "patch": "@@ -86,8 +86,8 @@ use fmt_macros::{Parser, Piece, Position};\n use middle::cstore::LOCAL_CRATE;\n use hir::def::{self, Def};\n use hir::def_id::DefId;\n+use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n-use hir::pat_util::{self};\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::{GenericPredicates, TypeScheme};"}]}