{"sha": "d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxOGY3ODU0NTc4ZThjMmUxZDdkY2U5MGRiNmUzYjVjZjliZWZiYTk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-07T22:38:38Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-11T16:35:58Z"}, "message": "librustc: Replace all uses of `fn()` with `&fn()`. rs=defun", "tree": {"sha": "518a4098922b97624778cff41bbdc86547e43afe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/518a4098922b97624778cff41bbdc86547e43afe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "html_url": "https://github.com/rust-lang/rust/commit/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51cdca0bf0d3efc554c1815df9306ea10e881a14", "url": "https://api.github.com/repos/rust-lang/rust/commits/51cdca0bf0d3efc554c1815df9306ea10e881a14", "html_url": "https://github.com/rust-lang/rust/commit/51cdca0bf0d3efc554c1815df9306ea10e881a14"}], "stats": {"total": 1625, "additions": 813, "deletions": 812}, "files": [{"sha": "7d0a4d7dcc805ae0dfaeccf3cdb63b29f922d143", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -103,7 +103,7 @@ pub fn is_test_ignored(config: config, testfile: &Path) -> bool {\n     }\n }\n \n-fn iter_header(testfile: &Path, it: fn(~str) -> bool) -> bool {\n+fn iter_header(testfile: &Path, it: &fn(~str) -> bool) -> bool {\n     let rdr = io::file_reader(testfile).get();\n     while !rdr.eof() {\n         let ln = rdr.read_line();"}, {"sha": "f95a530831b931a040938ce8ef0e62b2e6b9da64", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -530,7 +530,7 @@ fn compose_and_run(config: config, testfile: &Path,\n }\n \n fn make_compile_args(config: config, props: TestProps, extras: ~[~str],\n-                     xform: fn(config, (&Path)) -> Path,\n+                     xform: &fn(config, (&Path)) -> Path,\n                      testfile: &Path) -> ProcArgs {\n     let prog = config.rustc_path;\n     let mut args = ~[testfile.to_str(),"}, {"sha": "fa19e24aa0830be77f8385d555df9645284f9a4b", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -61,7 +61,7 @@ pub pure fn capacity<T>(v: @[const T]) -> uint {\n  */\n #[inline(always)]\n pub pure fn build_sized<A>(size: uint,\n-                           builder: &fn(push: pure fn(v: A))) -> @[A] {\n+                           builder: &fn(push: &pure fn(v: A))) -> @[A] {\n     let mut vec: @[const A] = @[];\n     unsafe { raw::reserve(&mut vec, size); }\n     builder(|+x| unsafe { raw::push(&mut vec, x) });\n@@ -79,7 +79,7 @@ pub pure fn build_sized<A>(size: uint,\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A>(builder: &fn(push: pure fn(v: A))) -> @[A] {\n+pub pure fn build<A>(builder: &fn(push: &pure fn(v: A))) -> @[A] {\n     build_sized(4, builder)\n }\n \n@@ -97,7 +97,7 @@ pub pure fn build<A>(builder: &fn(push: pure fn(v: A))) -> @[A] {\n  */\n #[inline(always)]\n pub pure fn build_sized_opt<A>(size: Option<uint>,\n-                               builder: &fn(push: pure fn(v: A))) -> @[A] {\n+                               builder: &fn(push: &pure fn(v: A))) -> @[A] {\n     build_sized(size.get_or_default(4), builder)\n }\n "}, {"sha": "512855d8f86c0a0fd9a9557a8d8c86f43071aeda", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -67,7 +67,7 @@ pub pure fn to_str(v: bool) -> ~str { if v { ~\"true\" } else { ~\"false\" } }\n  * Iterates over all truth values by passing them to `blk` in an unspecified\n  * order\n  */\n-pub fn all_values(blk: fn(v: bool)) {\n+pub fn all_values(blk: &fn(v: bool)) {\n     blk(true);\n     blk(false);\n }"}, {"sha": "91a4ded60efd65a69755d9887f6f56bbf2cb4310", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -54,7 +54,7 @@ pub impl<T> Cell<T> {\n     }\n \n     // Calls a closure with a reference to the value.\n-    fn with_ref<R>(&self, op: fn(v: &T) -> R) -> R {\n+    fn with_ref<R>(&self, op: &fn(v: &T) -> R) -> R {\n         let v = self.take();\n         let r = op(&v);\n         self.put_back(v);"}, {"sha": "faa6db45df2f6fe5a94a11bd93134753126ebf9a", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -124,7 +124,7 @@ struct AnnihilateStats {\n     n_bytes_freed: uint\n }\n \n-unsafe fn each_live_alloc(f: fn(box: *mut BoxRepr, uniq: bool) -> bool) {\n+unsafe fn each_live_alloc(f: &fn(box: *mut BoxRepr, uniq: bool) -> bool) {\n     use managed;\n \n     let task: *Task = transmute(rustrt::rust_get_task());"}, {"sha": "4f1f6004aad770b6bf610f543d17775d4a347712", "filename": "src/libcore/container.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -30,10 +30,10 @@ pub trait Map<K, V>: Mutable {\n     pure fn contains_key(&self, key: &K) -> bool;\n \n     /// Visit all keys\n-    pure fn each_key(&self, f: fn(&K) -> bool);\n+    pure fn each_key(&self, f: &fn(&K) -> bool);\n \n     /// Visit all values\n-    pure fn each_value(&self, f: fn(&V) -> bool);\n+    pure fn each_value(&self, f: &fn(&V) -> bool);\n \n     /// Return the value corresponding to the key in the map\n     pure fn find(&self, key: &K) -> Option<&self/V>;\n@@ -71,14 +71,14 @@ pub trait Set<T>: Mutable {\n     pure fn is_superset(&self, other: &Self) -> bool;\n \n     /// Visit the values representing the difference\n-    pure fn difference(&self, other: &Self, f: fn(&T) -> bool);\n+    pure fn difference(&self, other: &Self, f: &fn(&T) -> bool);\n \n     /// Visit the values representing the symmetric difference\n-    pure fn symmetric_difference(&self, other: &Self, f: fn(&T) -> bool);\n+    pure fn symmetric_difference(&self, other: &Self, f: &fn(&T) -> bool);\n \n     /// Visit the values representing the intersection\n-    pure fn intersection(&self, other: &Self, f: fn(&T) -> bool);\n+    pure fn intersection(&self, other: &Self, f: &fn(&T) -> bool);\n \n     /// Visit the values representing the union\n-    pure fn union(&self, other: &Self, f: fn(&T) -> bool);\n+    pure fn union(&self, other: &Self, f: &fn(&T) -> bool);\n }"}, {"sha": "fd3ba2e6f451f0d190daa940a18cd6eb9267eaf3", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -399,7 +399,7 @@ pub impl<T> DList<T> {\n     }\n \n     /// Iterate over nodes.\n-    pure fn each_node(@mut self, f: fn(@mut DListNode<T>) -> bool) {\n+    pure fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) {\n         let mut link = self.peek_n();\n         while link.is_some() {\n             let nobe = link.get();"}, {"sha": "e4b7bbbd99e87c9529f2f8ba5a252e78b8d9784e", "filename": "src/libcore/either.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -24,8 +24,8 @@ pub enum Either<T, U> {\n }\n \n #[inline(always)]\n-pub fn either<T, U, V>(f_left: fn(&T) -> V,\n-                       f_right: fn(&U) -> V, value: &Either<T, U>) -> V {\n+pub fn either<T, U, V>(f_left: &fn(&T) -> V,\n+                       f_right: &fn(&U) -> V, value: &Either<T, U>) -> V {\n     /*!\n      * Applies a function based on the given either value\n      *\n@@ -148,7 +148,7 @@ pub pure fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n \n pub impl<T, U> Either<T, U> {\n     #[inline(always)]\n-    fn either<V>(&self, f_left: fn(&T) -> V, f_right: fn(&U) -> V) -> V {\n+    fn either<V>(&self, f_left: &fn(&T) -> V, f_right: &fn(&U) -> V) -> V {\n         either(f_left, f_right, self)\n     }\n "}, {"sha": "6f63cdbabb57d01e0bb737b2d0bac2cdc8b607e4", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -86,7 +86,7 @@ pub mod linear {\n \n         #[inline(always)]\n         pure fn bucket_sequence(&self, hash: uint,\n-                                op: fn(uint) -> bool) -> uint {\n+                                op: &fn(uint) -> bool) -> uint {\n             let start_idx = self.to_bucket(hash);\n             let len_buckets = self.buckets.len();\n             let mut idx = start_idx;\n@@ -263,7 +263,7 @@ pub mod linear {\n         }\n \n         fn search(&self, hash: uint,\n-                  op: fn(x: &Option<Bucket<K, V>>) -> bool) {\n+                  op: &fn(x: &Option<Bucket<K, V>>) -> bool) {\n             let _ = self.bucket_sequence(hash, |i| op(&self.buckets[i]));\n         }\n     }\n@@ -272,7 +272,7 @@ pub mod linear {\n         BaseIter<(&self/K, &self/V)> for LinearMap<K, V>\n     {\n         /// Visit all key-value pairs\n-        pure fn each(&self, blk: fn(&(&self/K, &self/V)) -> bool) {\n+        pure fn each(&self, blk: &fn(&(&self/K, &self/V)) -> bool) {\n             for uint::range(0, self.buckets.len()) |i| {\n                 let mut broke = false;\n                 do self.buckets[i].map |bucket| {\n@@ -315,12 +315,12 @@ pub mod linear {\n         }\n \n         /// Visit all keys\n-        pure fn each_key(&self, blk: fn(k: &K) -> bool) {\n+        pure fn each_key(&self, blk: &fn(k: &K) -> bool) {\n             self.each(|&(k, _)| blk(k))\n         }\n \n         /// Visit all values\n-        pure fn each_value(&self, blk: fn(v: &V) -> bool) {\n+        pure fn each_value(&self, blk: &fn(v: &V) -> bool) {\n             self.each(|&(_, v)| blk(v))\n         }\n \n@@ -428,7 +428,7 @@ pub mod linear {\n \n         /// Return the value corresponding to the key in the map, or create,\n         /// insert, and return a new value if it doesn't exist.\n-        fn find_or_insert_with(&mut self, k: K, f: fn(&K) -> V) -> &self/V {\n+        fn find_or_insert_with(&mut self, k: K, f: &fn(&K) -> V) -> &self/V {\n             if self.size >= self.resize_at {\n                 // n.b.: We could also do this after searching, so\n                 // that we do not resize if this call to insert is\n@@ -457,7 +457,7 @@ pub mod linear {\n             }\n         }\n \n-        fn consume(&mut self, f: fn(K, V)) {\n+        fn consume(&mut self, f: &fn(K, V)) {\n             let mut buckets = ~[];\n             self.buckets <-> buckets;\n             self.size = 0;\n@@ -526,7 +526,7 @@ pub mod linear {\n \n     impl<T:Hash + IterBytes + Eq> BaseIter<T> for LinearSet<T> {\n         /// Visit all values in order\n-        pure fn each(&self, f: fn(&T) -> bool) { self.map.each_key(f) }\n+        pure fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n         pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n     }\n \n@@ -583,7 +583,7 @@ pub mod linear {\n         }\n \n         /// Visit the values representing the difference\n-        pure fn difference(&self, other: &LinearSet<T>, f: fn(&T) -> bool) {\n+        pure fn difference(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n             for self.each |v| {\n                 if !other.contains(v) {\n                     if !f(v) { return }\n@@ -593,13 +593,13 @@ pub mod linear {\n \n         /// Visit the values representing the symmetric difference\n         pure fn symmetric_difference(&self, other: &LinearSet<T>,\n-                                     f: fn(&T) -> bool) {\n+                                     f: &fn(&T) -> bool) {\n             self.difference(other, f);\n             other.difference(self, f);\n         }\n \n         /// Visit the values representing the intersection\n-        pure fn intersection(&self, other: &LinearSet<T>, f: fn(&T) -> bool) {\n+        pure fn intersection(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n             for self.each |v| {\n                 if other.contains(v) {\n                     if !f(v) { return }\n@@ -608,7 +608,7 @@ pub mod linear {\n         }\n \n         /// Visit the values representing the union\n-        pure fn union(&self, other: &LinearSet<T>, f: fn(&T) -> bool) {\n+        pure fn union(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n             for self.each |v| {\n                 if !f(v) { return }\n             }"}, {"sha": "b04bb15f5e30b9617ddd4ebca34b4fd442ce954d", "filename": "src/libcore/io.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -118,13 +118,13 @@ pub trait ReaderUtil {\n     fn read_whole_stream(&self) -> ~[u8];\n \n     /// Iterate over every byte until the iterator breaks or EOF.\n-    fn each_byte(&self, it: fn(int) -> bool);\n+    fn each_byte(&self, it: &fn(int) -> bool);\n \n     /// Iterate over every char until the iterator breaks or EOF.\n-    fn each_char(&self, it: fn(char) -> bool);\n+    fn each_char(&self, it: &fn(char) -> bool);\n \n     /// Iterate over every line until the iterator breaks or EOF.\n-    fn each_line(&self, it: fn(&str) -> bool);\n+    fn each_line(&self, it: &fn(&str) -> bool);\n \n     /// Read n (between 1 and 8) little-endian unsigned integer bytes.\n     fn read_le_uint_n(&self, nbytes: uint) -> u64;\n@@ -315,19 +315,19 @@ impl<T:Reader> ReaderUtil for T {\n         bytes\n     }\n \n-    fn each_byte(&self, it: fn(int) -> bool) {\n+    fn each_byte(&self, it: &fn(int) -> bool) {\n         while !self.eof() {\n             if !it(self.read_byte()) { break; }\n         }\n     }\n \n-    fn each_char(&self, it: fn(char) -> bool) {\n+    fn each_char(&self, it: &fn(char) -> bool) {\n         while !self.eof() {\n             if !it(self.read_char()) { break; }\n         }\n     }\n \n-    fn each_line(&self, it: fn(s: &str) -> bool) {\n+    fn each_line(&self, it: &fn(s: &str) -> bool) {\n         while !self.eof() {\n             if !it(self.read_line()) { break; }\n         }\n@@ -618,11 +618,11 @@ impl Reader for BytesReader/&self {\n     fn tell(&self) -> uint { self.pos }\n }\n \n-pub pure fn with_bytes_reader<t>(bytes: &[u8], f: fn(@Reader) -> t) -> t {\n+pub pure fn with_bytes_reader<t>(bytes: &[u8], f: &fn(@Reader) -> t) -> t {\n     f(@BytesReader { bytes: bytes, pos: 0u } as @Reader)\n }\n \n-pub pure fn with_str_reader<T>(s: &str, f: fn(@Reader) -> T) -> T {\n+pub pure fn with_str_reader<T>(s: &str, f: &fn(@Reader) -> T) -> T {\n     str::byte_slice(s, |bytes| with_bytes_reader(bytes, f))\n }\n \n@@ -819,7 +819,7 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n }\n \n pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n-                          f: fn(v: &[u8]) -> T) -> T {\n+                          f: &fn(v: &[u8]) -> T) -> T {\n     fail_unless!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n@@ -851,7 +851,7 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n }\n \n pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n-                           f: fn(v: &[u8]) -> T) -> T {\n+                           f: &fn(v: &[u8]) -> T) -> T {\n     fail_unless!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n@@ -1142,14 +1142,14 @@ pub pure fn BytesWriter() -> BytesWriter {\n     BytesWriter { bytes: ~[], mut pos: 0u }\n }\n \n-pub pure fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n+pub pure fn with_bytes_writer(f: &fn(Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as Writer);\n     let @BytesWriter{bytes, _} = wr;\n     return bytes;\n }\n \n-pub pure fn with_str_writer(f: fn(Writer)) -> ~str {\n+pub pure fn with_str_writer(f: &fn(Writer)) -> ~str {\n     let mut v = with_bytes_writer(f);\n \n     // FIXME (#3758): This should not be needed.\n@@ -1251,7 +1251,7 @@ pub mod fsync {\n     // FIXME (#2004) find better way to create resources within lifetime of\n     // outer res\n     pub fn FILE_res_sync(file: &FILERes, opt_level: Option<Level>,\n-                         blk: fn(v: Res<*libc::FILE>)) {\n+                         blk: &fn(v: Res<*libc::FILE>)) {\n         unsafe {\n             blk(Res(Arg {\n                 val: file.f, opt_level: opt_level,\n@@ -1266,7 +1266,7 @@ pub mod fsync {\n \n     // fsync fd after executing blk\n     pub fn fd_res_sync(fd: &FdRes, opt_level: Option<Level>,\n-                       blk: fn(v: Res<fd_t>)) {\n+                       blk: &fn(v: Res<fd_t>)) {\n         blk(Res(Arg {\n             val: fd.fd, opt_level: opt_level,\n             fsync_fn: |fd, l| os::fsync_fd(fd, l) as int\n@@ -1278,7 +1278,7 @@ pub mod fsync {\n \n     // Call o.fsync after executing blk\n     pub fn obj_sync(o: FSyncable, opt_level: Option<Level>,\n-                    blk: fn(v: Res<FSyncable>)) {\n+                    blk: &fn(v: Res<FSyncable>)) {\n         blk(Res(Arg {\n             val: o, opt_level: opt_level,\n             fsync_fn: |o, l| o.fsync(l)"}, {"sha": "8931b4088263eeab3685671e3f3069f29cdcd108", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -23,22 +23,22 @@ use vec;\n pub type InitOp<T> = &self/fn(uint) -> T;\n \n pub trait BaseIter<A> {\n-    pure fn each(&self, blk: fn(v: &A) -> bool);\n+    pure fn each(&self, blk: &fn(v: &A) -> bool);\n     pure fn size_hint(&self) -> Option<uint>;\n }\n \n pub trait ReverseIter<A>: BaseIter<A> {\n-    pure fn each_reverse(&self, blk: fn(&A) -> bool);\n+    pure fn each_reverse(&self, blk: &fn(&A) -> bool);\n }\n \n pub trait ExtendedIter<A> {\n-    pure fn eachi(&self, blk: fn(uint, v: &A) -> bool);\n-    pure fn all(&self, blk: fn(&A) -> bool) -> bool;\n-    pure fn any(&self, blk: fn(&A) -> bool) -> bool;\n-    pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B;\n-    pure fn position(&self, f: fn(&A) -> bool) -> Option<uint>;\n-    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B];\n-    pure fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: fn(&A) -> IB)\n+    pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool);\n+    pure fn all(&self, blk: &fn(&A) -> bool) -> bool;\n+    pure fn any(&self, blk: &fn(&A) -> bool) -> bool;\n+    pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B;\n+    pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint>;\n+    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B];\n+    pure fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B];\n }\n \n@@ -48,13 +48,13 @@ pub trait EqIter<A:Eq> {\n }\n \n pub trait Times {\n-    pure fn times(&self, it: fn() -> bool);\n+    pure fn times(&self, it: &fn() -> bool);\n }\n \n pub trait CopyableIter<A:Copy> {\n-    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A];\n+    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A];\n     pure fn to_vec(&self) -> ~[A];\n-    pure fn find(&self, p: fn(&A) -> bool) -> Option<A>;\n+    pure fn find(&self, p: &fn(&A) -> bool) -> Option<A>;\n }\n \n pub trait CopyableOrderedIter<A:Copy + Ord> {\n@@ -86,12 +86,12 @@ pub trait Buildable<A> {\n      *             onto the sequence being constructed.\n      */\n      static pure fn build_sized(size: uint,\n-                                builder: fn(push: pure fn(A))) -> Self;\n+                                builder: &fn(push: &pure fn(A))) -> Self;\n }\n \n #[inline(always)]\n pub pure fn eachi<A,IA:BaseIter<A>>(self: &IA,\n-                                    blk: fn(uint, &A) -> bool) {\n+                                    blk: &fn(uint, &A) -> bool) {\n     let mut i = 0;\n     for self.each |a| {\n         if !blk(i, a) { break; }\n@@ -101,7 +101,7 @@ pub pure fn eachi<A,IA:BaseIter<A>>(self: &IA,\n \n #[inline(always)]\n pub pure fn all<A,IA:BaseIter<A>>(self: &IA,\n-                                  blk: fn(&A) -> bool) -> bool {\n+                                  blk: &fn(&A) -> bool) -> bool {\n     for self.each |a| {\n         if !blk(a) { return false; }\n     }\n@@ -110,7 +110,7 @@ pub pure fn all<A,IA:BaseIter<A>>(self: &IA,\n \n #[inline(always)]\n pub pure fn any<A,IA:BaseIter<A>>(self: &IA,\n-                                  blk: fn(&A) -> bool) -> bool {\n+                                  blk: &fn(&A) -> bool) -> bool {\n     for self.each |a| {\n         if blk(a) { return true; }\n     }\n@@ -119,7 +119,7 @@ pub pure fn any<A,IA:BaseIter<A>>(self: &IA,\n \n #[inline(always)]\n pub pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(\n-    self: &IA, prd: fn(&A) -> bool) -> ~[A] {\n+    self: &IA, prd: &fn(&A) -> bool) -> ~[A] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n             if prd(a) { push(*a); }\n@@ -129,7 +129,7 @@ pub pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(\n \n #[inline(always)]\n pub pure fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA,\n-                                           op: fn(&A) -> B)\n+                                           op: &fn(&A) -> B)\n     -> ~[B] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n@@ -140,7 +140,7 @@ pub pure fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA,\n \n #[inline(always)]\n pub pure fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(\n-    self: &IA, op: fn(&A) -> IB) -> ~[B] {\n+    self: &IA, op: &fn(&A) -> IB) -> ~[B] {\n     do vec::build |push| {\n         for self.each |a| {\n             for op(a).each |&b| {\n@@ -152,7 +152,7 @@ pub pure fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(\n \n #[inline(always)]\n pub pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B,\n-                                      blk: fn(&B, &A) -> B)\n+                                      blk: &fn(&B, &A) -> B)\n     -> B {\n     let mut b = b0;\n     for self.each |a| {\n@@ -186,7 +186,7 @@ pub pure fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n }\n \n #[inline(always)]\n-pub pure fn position<A,IA:BaseIter<A>>(self: &IA, f: fn(&A) -> bool)\n+pub pure fn position<A,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n     -> Option<uint>\n {\n     let mut i = 0;\n@@ -202,7 +202,7 @@ pub pure fn position<A,IA:BaseIter<A>>(self: &IA, f: fn(&A) -> bool)\n // it would have to be implemented with foldr, which is too inefficient.\n \n #[inline(always)]\n-pub pure fn repeat(times: uint, blk: fn() -> bool) {\n+pub pure fn repeat(times: uint, blk: &fn() -> bool) {\n     let mut i = 0;\n     while i < times {\n         if !blk() { break }\n@@ -242,7 +242,7 @@ pub pure fn max<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n \n #[inline(always)]\n pub pure fn find<A:Copy,IA:BaseIter<A>>(self: &IA,\n-                                   f: fn(&A) -> bool) -> Option<A> {\n+                                   f: &fn(&A) -> bool) -> Option<A> {\n     for self.each |i| {\n         if f(i) { return Some(*i) }\n     }\n@@ -262,7 +262,7 @@ pub pure fn find<A:Copy,IA:BaseIter<A>>(self: &IA,\n  *             onto the sequence being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(A)))\n+pub pure fn build<A,B: Buildable<A>>(builder: &fn(push: &pure fn(A)))\n     -> B {\n     Buildable::build_sized(4, builder)\n }\n@@ -283,7 +283,7 @@ pub pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(A)))\n #[inline(always)]\n pub pure fn build_sized_opt<A,B: Buildable<A>>(\n     size: Option<uint>,\n-    builder: fn(push: pure fn(A))) -> B {\n+    builder: &fn(push: &pure fn(A))) -> B {\n \n     Buildable::build_sized(size.get_or_default(4), builder)\n }\n@@ -292,7 +292,7 @@ pub pure fn build_sized_opt<A,B: Buildable<A>>(\n \n /// Applies a function to each element of an iterable and returns the results.\n #[inline(always)]\n-pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: fn(&T) -> U)\n+pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: &fn(&T) -> U)\n     -> BU {\n     do build_sized_opt(v.size_hint()) |push| {\n         for v.each() |elem| {"}, {"sha": "cef8542823a674b5b7e44a7335de19938dd93fd4", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -100,7 +100,7 @@ pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n  */\n #[inline(always)]\n /// Iterate over the range [`start`,`start`+`step`..`stop`)\n-pub pure fn range_step(start: T, stop: T, step: T, it: fn(T) -> bool) {\n+pub pure fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) {\n     let mut i = start;\n     if step == 0 {\n         fail!(~\"range_step called with step == 0\");\n@@ -119,13 +119,13 @@ pub pure fn range_step(start: T, stop: T, step: T, it: fn(T) -> bool) {\n \n #[inline(always)]\n /// Iterate over the range [`lo`..`hi`)\n-pub pure fn range(lo: T, hi: T, it: fn(T) -> bool) {\n+pub pure fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n     range_step(lo, hi, 1 as T, it);\n }\n \n #[inline(always)]\n /// Iterate over the range [`hi`..`lo`)\n-pub pure fn range_rev(hi: T, lo: T, it: fn(T) -> bool) {\n+pub pure fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n     range_step(hi, lo, -1 as T, it);\n }\n \n@@ -237,7 +237,7 @@ impl FromStrRadix for T {\n \n /// Convert to a string as a byte slice in a given base.\n #[inline(always)]\n-pub pure fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n+pub pure fn to_str_bytes<U>(n: T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)"}, {"sha": "9a141bfd34161e21ac12235924903bbb00f82c31", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -67,7 +67,7 @@ pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n  * Iterate over the range [`start`,`start`+`step`..`stop`)\n  *\n  */\n-pub pure fn range_step(start: T, stop: T, step: T_SIGNED, it: fn(T) -> bool) {\n+pub pure fn range_step(start: T, stop: T, step: T_SIGNED, it: &fn(T) -> bool) {\n     let mut i = start;\n     if step == 0 {\n         fail!(~\"range_step called with step == 0\");\n@@ -88,13 +88,13 @@ pub pure fn range_step(start: T, stop: T, step: T_SIGNED, it: fn(T) -> bool) {\n \n #[inline(always)]\n /// Iterate over the range [`lo`..`hi`)\n-pub pure fn range(lo: T, hi: T, it: fn(T) -> bool) {\n+pub pure fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n     range_step(lo, hi, 1 as T_SIGNED, it);\n }\n \n #[inline(always)]\n /// Iterate over the range [`hi`..`lo`)\n-pub pure fn range_rev(hi: T, lo: T, it: fn(T) -> bool) {\n+pub pure fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n     range_step(hi, lo, -1 as T_SIGNED, it);\n }\n \n@@ -200,7 +200,7 @@ impl FromStrRadix for T {\n \n /// Convert to a string as a byte slice in a given base.\n #[inline(always)]\n-pub pure fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n+pub pure fn to_str_bytes<U>(n: T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)"}, {"sha": "f73ff4442ceee0ba16a18d6be12d1d76cece060f", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -101,7 +101,7 @@ pub mod inst {\n     * `true` If execution proceeded correctly, `false` if it was interrupted,\n     * that is if `it` returned `false` at any point.\n     */\n-    pub pure fn iterate(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n+    pub pure fn iterate(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n         let mut i = lo;\n         while i < hi {\n             if (!it(i)) { return false; }\n@@ -122,7 +122,7 @@ pub mod inst {\n         * use with integer literals of inferred integer-type as\n         * the self-value (eg. `for 100.times { ... }`).\n         */\n-        pure fn times(&self, it: fn() -> bool) {\n+        pure fn times(&self, it: &fn() -> bool) {\n             let mut i = *self;\n             while i > 0 {\n                 if !it() { break }"}, {"sha": "e0393fdf5e35a287101c9a12bc72b1fa6733c8ab", "filename": "src/libcore/option.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -131,15 +131,15 @@ pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n }\n \n #[inline(always)]\n-pub pure fn map<T, U>(opt: &r/Option<T>, f: fn(x: &r/T) -> U) -> Option<U> {\n+pub pure fn map<T, U>(opt: &r/Option<T>, f: &fn(x: &r/T) -> U) -> Option<U> {\n     //! Maps a `some` value by reference from one type to another\n \n     match *opt { Some(ref x) => Some(f(x)), None => None }\n }\n \n #[inline(always)]\n pub pure fn map_consume<T, U>(opt: Option<T>,\n-                              f: fn(v: T) -> U) -> Option<U> {\n+                              f: &fn(v: T) -> U) -> Option<U> {\n     /*!\n      * As `map`, but consumes the option and gives `f` ownership to avoid\n      * copying.\n@@ -149,7 +149,7 @@ pub pure fn map_consume<T, U>(opt: Option<T>,\n \n #[inline(always)]\n pub pure fn chain<T, U>(opt: Option<T>,\n-                        f: fn(t: T) -> Option<U>) -> Option<U> {\n+                        f: &fn(t: T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content through a\n      * function that returns an option.\n@@ -163,7 +163,7 @@ pub pure fn chain<T, U>(opt: Option<T>,\n \n #[inline(always)]\n pub pure fn chain_ref<T, U>(opt: &Option<T>,\n-                            f: fn(x: &T) -> Option<U>) -> Option<U> {\n+                            f: &fn(x: &T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content by reference\n      * through a function that returns an option.\n@@ -184,7 +184,7 @@ pub pure fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n }\n \n #[inline(always)]\n-pub pure fn while_some<T>(x: Option<T>, blk: fn(v: T) -> Option<T>) {\n+pub pure fn while_some<T>(x: Option<T>, blk: &fn(v: T) -> Option<T>) {\n     //! Applies a function zero or more times until the result is none.\n \n     let mut opt = x;\n@@ -223,7 +223,7 @@ pub pure fn get_or_default<T:Copy>(opt: Option<T>, def: T) -> T {\n \n #[inline(always)]\n pub pure fn map_default<T, U>(opt: &r/Option<T>, def: U,\n-                              f: fn(&r/T) -> U) -> U {\n+                              f: &fn(&r/T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n     match *opt { None => def, Some(ref t) => f(t) }\n@@ -279,7 +279,7 @@ pub pure fn expect<T>(opt: Option<T>, reason: &str) -> T {\n impl<T> BaseIter<T> for Option<T> {\n     /// Performs an operation on the contained value by reference\n     #[inline(always)]\n-    pure fn each(&self, f: fn(x: &self/T) -> bool) {\n+    pure fn each(&self, f: &fn(x: &self/T) -> bool) {\n         match *self { None => (), Some(ref t) => { f(t); } }\n     }\n \n@@ -303,43 +303,43 @@ pub impl<T> Option<T> {\n      * through a function that returns an option.\n      */\n     #[inline(always)]\n-    pure fn chain_ref<U>(&self, f: fn(x: &T) -> Option<U>) -> Option<U> {\n+    pure fn chain_ref<U>(&self, f: &fn(x: &T) -> Option<U>) -> Option<U> {\n         chain_ref(self, f)\n     }\n \n     /// Maps a `some` value from one type to another by reference\n     #[inline(always)]\n-    pure fn map<U>(&self, f: fn(&self/T) -> U) -> Option<U> { map(self, f) }\n+    pure fn map<U>(&self, f: &fn(&self/T) -> U) -> Option<U> { map(self, f) }\n \n     /// As `map`, but consumes the option and gives `f` ownership to avoid\n     /// copying.\n     #[inline(always)]\n-    pure fn map_consume<U>(self, f: fn(v: T) -> U) -> Option<U> {\n+    pure fn map_consume<U>(self, f: &fn(v: T) -> U) -> Option<U> {\n         map_consume(self, f)\n     }\n \n     /// Applies a function to the contained value or returns a default\n     #[inline(always)]\n-    pure fn map_default<U>(&self, def: U, f: fn(&self/T) -> U) -> U {\n+    pure fn map_default<U>(&self, def: U, f: &fn(&self/T) -> U) -> U {\n         map_default(self, def, f)\n     }\n \n     /// As `map_default`, but consumes the option and gives `f`\n     /// ownership to avoid copying.\n     #[inline(always)]\n-    pure fn map_consume_default<U>(self, def: U, f: fn(v: T) -> U) -> U {\n+    pure fn map_consume_default<U>(self, def: U, f: &fn(v: T) -> U) -> U {\n         match self { None => def, Some(v) => f(v) }\n     }\n \n     /// Apply a function to the contained value or do nothing\n-    fn mutate(&mut self, f: fn(T) -> T) {\n+    fn mutate(&mut self, f: &fn(T) -> T) {\n         if self.is_some() {\n             *self = Some(f(self.swap_unwrap()));\n         }\n     }\n \n     /// Apply a function to the contained value or set it to a default\n-    fn mutate_default(&mut self, def: T, f: fn(T) -> T) {\n+    fn mutate_default(&mut self, def: T, f: &fn(T) -> T) {\n         if self.is_some() {\n             *self = Some(f(self.swap_unwrap()));\n         } else {\n@@ -420,7 +420,7 @@ pub impl<T:Copy> Option<T> {\n \n     /// Applies a function zero or more times until the result is none.\n     #[inline(always)]\n-    pure fn while_some(self, blk: fn(v: T) -> Option<T>) {\n+    pure fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n         while_some(self, blk)\n     }\n }"}, {"sha": "ba16c14a85add108be30ed3ff723032e0beb4bd9", "filename": "src/libcore/os.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -75,11 +75,11 @@ pub fn getcwd() -> Path {\n     }\n }\n \n-pub fn as_c_charp<T>(s: &str, f: fn(*c_char) -> T) -> T {\n+pub fn as_c_charp<T>(s: &str, f: &fn(*c_char) -> T) -> T {\n     str::as_c_str(s, |b| f(b as *c_char))\n }\n \n-pub fn fill_charp_buf(f: fn(*mut c_char, size_t) -> bool)\n+pub fn fill_charp_buf(f: &fn(*mut c_char, size_t) -> bool)\n     -> Option<~str> {\n     let mut buf = vec::from_elem(TMPBUF_SZ, 0u8 as c_char);\n     do vec::as_mut_buf(buf) |b, sz| {\n@@ -103,7 +103,7 @@ pub mod win32 {\n     use os::TMPBUF_SZ;\n     use libc::types::os::arch::extra::DWORD;\n \n-    pub fn fill_utf16_buf_and_decode(f: fn(*mut u16, DWORD) -> DWORD)\n+    pub fn fill_utf16_buf_and_decode(f: &fn(*mut u16, DWORD) -> DWORD)\n         -> Option<~str> {\n         unsafe {\n             let mut n = TMPBUF_SZ as DWORD;\n@@ -133,7 +133,7 @@ pub mod win32 {\n         }\n     }\n \n-    pub fn as_utf16_p<T>(s: &str, f: fn(*u16) -> T) -> T {\n+    pub fn as_utf16_p<T>(s: &str, f: &fn(*u16) -> T) -> T {\n         let mut t = str::to_utf16(s);\n         // Null terminate before passing on.\n         t += ~[0u16];\n@@ -518,11 +518,11 @@ pub fn tmpdir() -> Path {\n     }\n }\n /// Recursively walk a directory structure\n-pub fn walk_dir(p: &Path, f: fn(&Path) -> bool) {\n+pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) {\n \n     walk_dir_(p, f);\n \n-    fn walk_dir_(p: &Path, f: fn(&Path) -> bool) -> bool {\n+    fn walk_dir_(p: &Path, f: &fn(&Path) -> bool) -> bool {\n         let mut keepgoing = true;\n         do list_dir(p).each |q| {\n             let path = &p.push(*q);"}, {"sha": "fd823e9dda0d73888476ab7983f569ad68fcb9c6", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -246,7 +246,7 @@ pub fn packet<T>() -> *Packet<T> {\n #[doc(hidden)]\n pub fn entangle_buffer<T:Owned,Tstart:Owned>(\n     buffer: ~Buffer<T>,\n-    init: fn(*libc::c_void, x: &T) -> *Packet<Tstart>)\n+    init: &fn(*libc::c_void, x: &T) -> *Packet<Tstart>)\n     -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>)\n {\n     let p = init(unsafe { reinterpret_cast(&buffer) }, &buffer.data);"}, {"sha": "b66c1c4696fcf917ca597f339a524de15d5f5913", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -82,7 +82,7 @@ pub unsafe fn buf_len<T>(buf: **T) -> uint {\n \n /// Return the first offset `i` such that `f(buf[i]) == true`.\n #[inline(always)]\n-pub unsafe fn position<T>(buf: *T, f: fn(&T) -> bool) -> uint {\n+pub unsafe fn position<T>(buf: *T, f: &fn(&T) -> bool) -> uint {\n     let mut i = 0;\n     loop {\n         if f(&(*offset(buf, i))) { return i; }"}, {"sha": "30c46cd3e35d12c317c3f24b5d738c6dd61de0cf", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -26,7 +26,7 @@ use vec;\n  * then build a MovePtrAdaptor wrapped around your struct.\n  */\n pub trait MovePtr {\n-    fn move_ptr(&self, adjustment: fn(*c_void) -> *c_void);\n+    fn move_ptr(&self, adjustment: &fn(*c_void) -> *c_void);\n     fn push_ptr(&self);\n     fn pop_ptr(&self);\n }"}, {"sha": "ad85c5e5ceff4b6f0587c41f8f4a9cc568174e12", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -159,7 +159,7 @@ pub fn ReprVisitor(ptr: *c_void, writer: @Writer) -> ReprVisitor {\n \n impl MovePtr for ReprVisitor {\n     #[inline(always)]\n-    fn move_ptr(&self, adjustment: fn(*c_void) -> *c_void) {\n+    fn move_ptr(&self, adjustment: &fn(*c_void) -> *c_void) {\n         self.ptr = adjustment(self.ptr);\n     }\n     fn push_ptr(&self) {\n@@ -175,7 +175,7 @@ pub impl ReprVisitor {\n     // Various helpers for the TyVisitor impl\n \n     #[inline(always)]\n-    fn get<T>(&self, f: fn(&T)) -> bool {\n+    fn get<T>(&self, f: &fn(&T)) -> bool {\n         unsafe {\n             f(transmute::<*c_void,&T>(copy self.ptr));\n         }"}, {"sha": "e3fd279a996099d3e390093bfe47e62806d7ec15", "filename": "src/libcore/result.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -122,7 +122,7 @@ pub pure fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n  *     }\n  */\n #[inline(always)]\n-pub pure fn chain<T, U, V>(res: Result<T, V>, op: fn(T)\n+pub pure fn chain<T, U, V>(res: Result<T, V>, op: &fn(T)\n     -> Result<U, V>) -> Result<U, V> {\n     match res {\n         Ok(t) => op(t),\n@@ -141,7 +141,7 @@ pub pure fn chain<T, U, V>(res: Result<T, V>, op: fn(T)\n #[inline(always)]\n pub pure fn chain_err<T, U, V>(\n     res: Result<T, V>,\n-    op: fn(t: V) -> Result<T, U>)\n+    op: &fn(t: V) -> Result<T, U>)\n     -> Result<T, U> {\n     match res {\n       Ok(t) => Ok(t),\n@@ -164,7 +164,7 @@ pub pure fn chain_err<T, U, V>(\n  *     }\n  */\n #[inline(always)]\n-pub pure fn iter<T, E>(res: &Result<T, E>, f: fn(&T)) {\n+pub pure fn iter<T, E>(res: &Result<T, E>, f: &fn(&T)) {\n     match *res {\n       Ok(ref t) => f(t),\n       Err(_) => ()\n@@ -180,7 +180,7 @@ pub pure fn iter<T, E>(res: &Result<T, E>, f: fn(&T)) {\n  * handling an error.\n  */\n #[inline(always)]\n-pub pure fn iter_err<T, E>(res: &Result<T, E>, f: fn(&E)) {\n+pub pure fn iter_err<T, E>(res: &Result<T, E>, f: &fn(&E)) {\n     match *res {\n       Ok(_) => (),\n       Err(ref e) => f(e)\n@@ -202,7 +202,7 @@ pub pure fn iter_err<T, E>(res: &Result<T, E>, f: fn(&E)) {\n  *     }\n  */\n #[inline(always)]\n-pub pure fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn(&T) -> U)\n+pub pure fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n   -> Result<U, E> {\n     match *res {\n       Ok(ref t) => Ok(op(t)),\n@@ -219,7 +219,7 @@ pub pure fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn(&T) -> U)\n  * successful result while handling an error.\n  */\n #[inline(always)]\n-pub pure fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: fn(&E) -> F)\n+pub pure fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n   -> Result<T, F> {\n     match *res {\n       Ok(copy t) => Ok(t),\n@@ -238,10 +238,10 @@ pub impl<T, E> Result<T, E> {\n     pure fn is_err(&self) -> bool { is_err(self) }\n \n     #[inline(always)]\n-    pure fn iter(&self, f: fn(&T)) { iter(self, f) }\n+    pure fn iter(&self, f: &fn(&T)) { iter(self, f) }\n \n     #[inline(always)]\n-    pure fn iter_err(&self, f: fn(&E)) { iter_err(self, f) }\n+    pure fn iter_err(&self, f: &fn(&E)) { iter_err(self, f) }\n \n     #[inline(always)]\n     pure fn unwrap(self) -> T { unwrap(self) }\n@@ -250,12 +250,12 @@ pub impl<T, E> Result<T, E> {\n     pure fn unwrap_err(self) -> E { unwrap_err(self) }\n \n     #[inline(always)]\n-    pure fn chain<U>(self, op: fn(T) -> Result<U,E>) -> Result<U,E> {\n+    pure fn chain<U>(self, op: &fn(T) -> Result<U,E>) -> Result<U,E> {\n         chain(self, op)\n     }\n \n     #[inline(always)]\n-    pure fn chain_err<F>(self, op: fn(E) -> Result<T,F>) -> Result<T,F> {\n+    pure fn chain_err<F>(self, op: &fn(E) -> Result<T,F>) -> Result<T,F> {\n         chain_err(self, op)\n     }\n }\n@@ -265,7 +265,7 @@ pub impl<T:Copy,E> Result<T, E> {\n     pure fn get(&self) -> T { get(self) }\n \n     #[inline(always)]\n-    pure fn map_err<F:Copy>(&self, op: fn(&E) -> F) -> Result<T,F> {\n+    pure fn map_err<F:Copy>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n         map_err(self, op)\n     }\n }\n@@ -275,7 +275,7 @@ pub impl<T, E: Copy> Result<T, E> {\n     pure fn get_err(&self) -> E { get_err(self) }\n \n     #[inline(always)]\n-    pure fn map<U:Copy>(&self, op: fn(&T) -> U) -> Result<U,E> {\n+    pure fn map<U:Copy>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n         map(self, op)\n     }\n }\n@@ -299,7 +299,7 @@ pub impl<T, E: Copy> Result<T, E> {\n  */\n #[inline(always)]\n pub fn map_vec<T,U:Copy,V:Copy>(\n-    ts: &[T], op: fn(&T) -> Result<V,U>) -> Result<~[V],U> {\n+    ts: &[T], op: &fn(&T) -> Result<V,U>) -> Result<~[V],U> {\n \n     let mut vs: ~[V] = vec::with_capacity(vec::len(ts));\n     for vec::each(ts) |t| {\n@@ -313,7 +313,7 @@ pub fn map_vec<T,U:Copy,V:Copy>(\n \n #[inline(always)]\n pub fn map_opt<T,U:Copy,V:Copy>(\n-    o_t: &Option<T>, op: fn(&T) -> Result<V,U>) -> Result<Option<V>,U> {\n+    o_t: &Option<T>, op: &fn(&T) -> Result<V,U>) -> Result<Option<V>,U> {\n \n     match *o_t {\n       None => Ok(None),\n@@ -335,7 +335,7 @@ pub fn map_opt<T,U:Copy,V:Copy>(\n  */\n #[inline(always)]\n pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n-                op: fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n+                op: &fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n \n     fail_unless!(vec::same_length(ss, ts));\n     let n = vec::len(ts);\n@@ -358,7 +358,7 @@ pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n  */\n #[inline(always)]\n pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n-                         op: fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n+                         op: &fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n \n     fail_unless!(vec::same_length(ss, ts));\n     let n = vec::len(ts);"}, {"sha": "a9d96d891c9442be91bd7ae52d44feb7c571f0f0", "filename": "src/libcore/run.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -102,7 +102,7 @@ pub fn spawn_process(prog: &str, args: &[~str],\n }\n \n fn with_argv<T>(prog: &str, args: &[~str],\n-                cb: fn(**libc::c_char) -> T) -> T {\n+                cb: &fn(**libc::c_char) -> T) -> T {\n     let mut argptrs = str::as_c_str(prog, |b| ~[b]);\n     let mut tmps = ~[];\n     for vec::each(args) |arg| {\n@@ -116,7 +116,7 @@ fn with_argv<T>(prog: &str, args: &[~str],\n \n #[cfg(unix)]\n fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n-                cb: fn(*c_void) -> T) -> T {\n+                cb: &fn(*c_void) -> T) -> T {\n     // On posixy systems we can pass a char** for envp, which is\n     // a null-terminated array of \"k=v\\n\" strings.\n     match *env {\n@@ -141,7 +141,7 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n \n #[cfg(windows)]\n fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n-                cb: fn(*c_void) -> T) -> T {\n+                cb: &fn(*c_void) -> T) -> T {\n     // On win32 we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n@@ -165,7 +165,7 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n }\n \n fn with_dirp<T>(d: &Option<~str>,\n-                cb: fn(*libc::c_char) -> T) -> T {\n+                cb: &fn(*libc::c_char) -> T) -> T {\n     match *d {\n       Some(ref dir) => str::as_c_str(*dir, cb),\n       None => cb(ptr::null())"}, {"sha": "955e486649b99a3578b44107706f6dcd07c769b4", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -24,7 +24,7 @@ pub fn Frame(fp: *Word) -> Frame {\n     }\n }\n \n-pub fn walk_stack(visit: fn(Frame) -> bool) {\n+pub fn walk_stack(visit: &fn(Frame) -> bool) {\n \n     debug!(\"beginning stack walk\");\n \n@@ -80,7 +80,7 @@ fn breakpoint() {\n     }\n }\n \n-fn frame_address(f: fn(++x: *u8)) {\n+fn frame_address(f: &fn(++x: *u8)) {\n     unsafe {\n         rusti::frame_address(f)\n     }"}, {"sha": "415c12e33a8a8d8b12115d50eb4d89cd8d8ad948", "filename": "src/libcore/str.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -382,7 +382,7 @@ pub pure fn to_bytes(s: &str) -> ~[u8] {\n \n /// Work with the string as a byte slice, not including trailing null.\n #[inline(always)]\n-pub pure fn byte_slice<T>(s: &str, f: fn(v: &[u8]) -> T) -> T {\n+pub pure fn byte_slice<T>(s: &str, f: &fn(v: &[u8]) -> T) -> T {\n     do as_buf(s) |p,n| {\n         unsafe { vec::raw::buf_as_slice(p, n-1u, f) }\n     }\n@@ -483,24 +483,24 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n \n \n /// Splits a string into substrings using a character function\n-pub pure fn split(s: &str, sepfn: fn(char) -> bool) -> ~[~str] {\n+pub pure fn split(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), true)\n }\n \n /**\n  * Splits a string into substrings using a character function, cutting at\n  * most `count` times.\n  */\n-pub pure fn splitn(s: &str, sepfn: fn(char) -> bool, count: uint) -> ~[~str] {\n+pub pure fn splitn(s: &str, sepfn: &fn(char) -> bool, count: uint) -> ~[~str] {\n     split_inner(s, sepfn, count, true)\n }\n \n /// Like `split`, but omits empty strings from the returned vector\n-pub pure fn split_nonempty(s: &str, sepfn: fn(char) -> bool) -> ~[~str] {\n+pub pure fn split_nonempty(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), false)\n }\n \n-pure fn split_inner(s: &str, sepfn: fn(cc: char) -> bool, count: uint,\n+pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n                allow_empty: bool) -> ~[~str] {\n     let l = len(s);\n     let mut result = ~[], i = 0u, start = 0u, done = 0u;\n@@ -526,7 +526,7 @@ pure fn split_inner(s: &str, sepfn: fn(cc: char) -> bool, count: uint,\n }\n \n // See Issue #1932 for why this is a naive search\n-pure fn iter_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n+pure fn iter_matches(s: &a/str, sep: &b/str, f: &fn(uint, uint)) {\n     let sep_len = len(sep), l = len(s);\n     fail_unless!(sep_len > 0u);\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n@@ -553,7 +553,7 @@ pure fn iter_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n     }\n }\n \n-pure fn iter_between_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n+pure fn iter_between_matches(s: &a/str, sep: &b/str, f: &fn(uint, uint)) {\n     let mut last_end = 0u;\n     do iter_matches(s, sep) |from, to| {\n         f(last_end, from);\n@@ -912,20 +912,20 @@ Section: Iterating through strings\n  * Return true if a predicate matches all characters or if the string\n  * contains no characters\n  */\n-pub pure fn all(s: &str, it: fn(char) -> bool) -> bool {\n+pub pure fn all(s: &str, it: &fn(char) -> bool) -> bool {\n     all_between(s, 0u, len(s), it)\n }\n \n /**\n  * Return true if a predicate matches any character (and false if it\n  * matches none or there are no characters)\n  */\n-pub pure fn any(ss: &str, pred: fn(char) -> bool) -> bool {\n+pub pure fn any(ss: &str, pred: &fn(char) -> bool) -> bool {\n     !all(ss, |cc| !pred(cc))\n }\n \n /// Apply a function to each character\n-pub pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n+pub pure fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n     unsafe {\n         reserve(&mut result, len(ss));\n@@ -937,7 +937,7 @@ pub pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n }\n \n /// Iterate over the bytes in a string\n-pub pure fn bytes_each(ss: &str, it: fn(u8) -> bool) {\n+pub pure fn bytes_each(ss: &str, it: &fn(u8) -> bool) {\n     let mut pos = 0u;\n     let len = len(ss);\n \n@@ -949,13 +949,13 @@ pub pure fn bytes_each(ss: &str, it: fn(u8) -> bool) {\n \n /// Iterate over the bytes in a string\n #[inline(always)]\n-pub pure fn each(s: &str, it: fn(u8) -> bool) {\n+pub pure fn each(s: &str, it: &fn(u8) -> bool) {\n     eachi(s, |_i, b| it(b) )\n }\n \n /// Iterate over the bytes in a string, with indices\n #[inline(always)]\n-pub pure fn eachi(s: &str, it: fn(uint, u8) -> bool) {\n+pub pure fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n     let mut i = 0u, l = len(s);\n     while (i < l) {\n         if !it(i, s[i]) { break; }\n@@ -965,13 +965,13 @@ pub pure fn eachi(s: &str, it: fn(uint, u8) -> bool) {\n \n /// Iterates over the chars in a string\n #[inline(always)]\n-pub pure fn each_char(s: &str, it: fn(char) -> bool) {\n+pub pure fn each_char(s: &str, it: &fn(char) -> bool) {\n     each_chari(s, |_i, c| it(c))\n }\n \n /// Iterates over the chars in a string, with indices\n #[inline(always)]\n-pub pure fn each_chari(s: &str, it: fn(uint, char) -> bool) {\n+pub pure fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n     let mut pos = 0u, ch_pos = 0u;\n     let len = len(s);\n     while pos < len {\n@@ -983,7 +983,7 @@ pub pure fn each_chari(s: &str, it: fn(uint, char) -> bool) {\n }\n \n /// Iterate over the characters in a string\n-pub pure fn chars_each(s: &str, it: fn(char) -> bool) {\n+pub pure fn chars_each(s: &str, it: &fn(char) -> bool) {\n     let mut pos = 0u;\n     let len = len(s);\n     while (pos < len) {\n@@ -994,7 +994,7 @@ pub pure fn chars_each(s: &str, it: fn(char) -> bool) {\n }\n \n /// Apply a function to each substring after splitting by character\n-pub pure fn split_char_each(ss: &str, cc: char, ff: fn(v: &str) -> bool) {\n+pub pure fn split_char_each(ss: &str, cc: char, ff: &fn(v: &str) -> bool) {\n     vec::each(split_char(ss, cc), |s| ff(*s))\n }\n \n@@ -1003,19 +1003,19 @@ pub pure fn split_char_each(ss: &str, cc: char, ff: fn(v: &str) -> bool) {\n  * `count` times\n  */\n pub pure fn splitn_char_each(ss: &str, sep: char, count: uint,\n-                         ff: fn(v: &str) -> bool) {\n+                         ff: &fn(v: &str) -> bool) {\n     vec::each(splitn_char(ss, sep, count), |s| ff(*s))\n }\n \n /// Apply a function to each word\n-pub pure fn words_each(ss: &str, ff: fn(v: &str) -> bool) {\n+pub pure fn words_each(ss: &str, ff: &fn(v: &str) -> bool) {\n     vec::each(words(ss), |s| ff(*s))\n }\n \n /**\n  * Apply a function to each line (by '\\n')\n  */\n-pub pure fn lines_each(ss: &str, ff: fn(v: &str) -> bool) {\n+pub pure fn lines_each(ss: &str, ff: &fn(v: &str) -> bool) {\n     vec::each(lines(ss), |s| ff(*s))\n }\n \n@@ -1195,7 +1195,7 @@ pub pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n  * An `option` containing the byte index of the first matching character\n  * or `none` if there is no match\n  */\n-pub pure fn find(s: &str, f: fn(char) -> bool) -> Option<uint> {\n+pub pure fn find(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n     find_between(s, 0u, len(s), f)\n }\n \n@@ -1219,7 +1219,7 @@ pub pure fn find(s: &str, f: fn(char) -> bool) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pub pure fn find_from(s: &str, start: uint, f: fn(char)\n+pub pure fn find_from(s: &str, start: uint, f: &fn(char)\n     -> bool) -> Option<uint> {\n     find_between(s, start, len(s), f)\n }\n@@ -1246,7 +1246,7 @@ pub pure fn find_from(s: &str, start: uint, f: fn(char)\n  * or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`.\n  */\n-pub pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n+pub pure fn find_between(s: &str, start: uint, end: uint, f: &fn(char) -> bool)\n     -> Option<uint> {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(s));\n@@ -1274,7 +1274,7 @@ pub pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n  * An option containing the byte index of the last matching character\n  * or `none` if there is no match\n  */\n-pub pure fn rfind(s: &str, f: fn(char) -> bool) -> Option<uint> {\n+pub pure fn rfind(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n     rfind_between(s, len(s), 0u, f)\n }\n \n@@ -1298,7 +1298,7 @@ pub pure fn rfind(s: &str, f: fn(char) -> bool) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)', `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`\n  */\n-pub pure fn rfind_from(s: &str, start: uint, f: fn(char) -> bool)\n+pub pure fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool)\n     -> Option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n@@ -1326,7 +1326,7 @@ pub pure fn rfind_from(s: &str, start: uint, f: fn(char) -> bool)\n  * boundary, as defined by `is_char_boundary`\n  */\n pub pure fn rfind_between(s: &str, start: uint, end: uint,\n-                          f: fn(char) -> bool)\n+                          f: &fn(char) -> bool)\n     -> Option<uint> {\n     fail_unless!(start >= end);\n     fail_unless!(start <= len(s));\n@@ -1589,7 +1589,7 @@ pub pure fn to_utf16(s: &str) -> ~[u16] {\n     u\n }\n \n-pub pure fn utf16_chars(v: &[u16], f: fn(char)) {\n+pub pure fn utf16_chars(v: &[u16], f: &fn(char)) {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n@@ -1815,7 +1815,7 @@ pure fn char_range_at_reverse(ss: &str, start: uint) -> CharRange {\n  * that is if `it` returned `false` at any point.\n  */\n pub pure fn all_between(s: &str, start: uint, end: uint,\n-                    it: fn(char) -> bool) -> bool {\n+                    it: &fn(char) -> bool) -> bool {\n     fail_unless!(is_char_boundary(s, start));\n     let mut i = start;\n     while i < end {\n@@ -1848,7 +1848,7 @@ pub pure fn all_between(s: &str, start: uint, end: uint,\n  * `true` if `it` returns `true` for any character\n  */\n pub pure fn any_between(s: &str, start: uint, end: uint,\n-                    it: fn(char) -> bool) -> bool {\n+                    it: &fn(char) -> bool) -> bool {\n     !all_between(s, start, end, |c| !it(c))\n }\n \n@@ -1886,7 +1886,7 @@ pub const nan_buf: [u8*3] = ['N' as u8, 'a' as u8, 'N' as u8];\n  * let i = str::as_bytes(\"Hello World\") { |bytes| vec::len(bytes) };\n  * ~~~\n  */\n-pub pure fn as_bytes<T>(s: &const ~str, f: fn(&~[u8]) -> T) -> T {\n+pub pure fn as_bytes<T>(s: &const ~str, f: &fn(&~[u8]) -> T) -> T {\n     unsafe {\n         let v: *~[u8] = cast::transmute(copy s);\n         f(&*v)\n@@ -1921,7 +1921,7 @@ pub pure fn as_bytes_slice(s: &a/str) -> &a/[u8] {\n  * let s = str::as_c_str(\"PATH\", { |path| libc::getenv(path) });\n  * ~~~\n  */\n-pub pure fn as_c_str<T>(s: &str, f: fn(*libc::c_char) -> T) -> T {\n+pub pure fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n     do as_buf(s) |buf, len| {\n         // NB: len includes the trailing null.\n         fail_unless!(len > 0);\n@@ -1943,7 +1943,7 @@ pub pure fn as_c_str<T>(s: &str, f: fn(*libc::c_char) -> T) -> T {\n  * to full strings, or suffixes of them.\n  */\n #[inline(always)]\n-pub pure fn as_buf<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n+pub pure fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n     unsafe {\n         let v : *(*u8,uint) = ::cast::reinterpret_cast(&ptr::addr_of(&s));\n         let (buf,len) = *v;\n@@ -2088,7 +2088,7 @@ pub mod raw {\n \n     /// Form a slice from a *u8 buffer of the given length without copying.\n     pub unsafe fn buf_as_slice<T>(buf: *u8, len: uint,\n-                              f: fn(v: &str) -> T) -> T {\n+                              f: &fn(v: &str) -> T) -> T {\n         let v = (buf, len + 1);\n         fail_unless!(is_utf8(::cast::reinterpret_cast(&v)));\n         f(::cast::transmute(v))\n@@ -2238,21 +2238,21 @@ pub mod traits {\n pub mod traits {}\n \n pub trait StrSlice {\n-    pure fn all(&self, it: fn(char) -> bool) -> bool;\n-    pure fn any(&self, it: fn(char) -> bool) -> bool;\n+    pure fn all(&self, it: &fn(char) -> bool) -> bool;\n+    pure fn any(&self, it: &fn(char) -> bool) -> bool;\n     pure fn contains(&self, needle: &a/str) -> bool;\n     pure fn contains_char(&self, needle: char) -> bool;\n-    pure fn each(&self, it: fn(u8) -> bool);\n-    pure fn eachi(&self, it: fn(uint, u8) -> bool);\n-    pure fn each_char(&self, it: fn(char) -> bool);\n-    pure fn each_chari(&self, it: fn(uint, char) -> bool);\n+    pure fn each(&self, it: &fn(u8) -> bool);\n+    pure fn eachi(&self, it: &fn(uint, u8) -> bool);\n+    pure fn each_char(&self, it: &fn(char) -> bool);\n+    pure fn each_chari(&self, it: &fn(uint, char) -> bool);\n     pure fn ends_with(&self, needle: &str) -> bool;\n     pure fn is_empty(&self) -> bool;\n     pure fn is_whitespace(&self) -> bool;\n     pure fn is_alphanumeric(&self) -> bool;\n     pure fn len(&self) -> uint;\n     pure fn slice(&self, begin: uint, end: uint) -> ~str;\n-    pure fn split(&self, sepfn: fn(char) -> bool) -> ~[~str];\n+    pure fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str];\n     pure fn split_char(&self, sep: char) -> ~[~str];\n     pure fn split_str(&self, sep: &a/str) -> ~[~str];\n     pure fn starts_with(&self, needle: &a/str) -> bool;\n@@ -2276,13 +2276,13 @@ impl StrSlice for &self/str {\n      * contains no characters\n      */\n     #[inline]\n-    pure fn all(&self, it: fn(char) -> bool) -> bool { all(*self, it) }\n+    pure fn all(&self, it: &fn(char) -> bool) -> bool { all(*self, it) }\n     /**\n      * Return true if a predicate matches any character (and false if it\n      * matches none or there are no characters)\n      */\n     #[inline]\n-    pure fn any(&self, it: fn(char) -> bool) -> bool { any(*self, it) }\n+    pure fn any(&self, it: &fn(char) -> bool) -> bool { any(*self, it) }\n     /// Returns true if one string contains another\n     #[inline]\n     pure fn contains(&self, needle: &a/str) -> bool {\n@@ -2295,16 +2295,16 @@ impl StrSlice for &self/str {\n     }\n     /// Iterate over the bytes in a string\n     #[inline]\n-    pure fn each(&self, it: fn(u8) -> bool) { each(*self, it) }\n+    pure fn each(&self, it: &fn(u8) -> bool) { each(*self, it) }\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n-    pure fn eachi(&self, it: fn(uint, u8) -> bool) { eachi(*self, it) }\n+    pure fn eachi(&self, it: &fn(uint, u8) -> bool) { eachi(*self, it) }\n     /// Iterate over the chars in a string\n     #[inline]\n-    pure fn each_char(&self, it: fn(char) -> bool) { each_char(*self, it) }\n+    pure fn each_char(&self, it: &fn(char) -> bool) { each_char(*self, it) }\n     /// Iterate over the chars in a string, with indices\n     #[inline]\n-    pure fn each_chari(&self, it: fn(uint, char) -> bool) {\n+    pure fn each_chari(&self, it: &fn(uint, char) -> bool) {\n         each_chari(*self, it)\n     }\n     /// Returns true if one string ends with another\n@@ -2345,7 +2345,7 @@ impl StrSlice for &self/str {\n     }\n     /// Splits a string into substrings using a character function\n     #[inline]\n-    pure fn split(&self, sepfn: fn(char) -> bool) -> ~[~str] {\n+    pure fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str] {\n         split(*self, sepfn)\n     }\n     /**"}, {"sha": "179a33ae43ea36d72ef31580270fd6dd64bd0bdd", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -227,7 +227,7 @@ pub mod tests {\n     pub fn synthesize_closure() {\n         unsafe {\n             let x = 10;\n-            let f: fn(int) -> int = |y| x + y;\n+            let f: &fn(int) -> int = |y| x + y;\n \n             fail_unless!(f(20) == 30);\n \n@@ -241,7 +241,7 @@ pub mod tests {\n                 env: environment\n             };\n \n-            let new_f: fn(int) -> int = cast::transmute(new_closure);\n+            let new_f: &fn(int) -> int = cast::transmute(new_closure);\n             fail_unless!(new_f(20) == 30);\n         }\n     }"}, {"sha": "690b3aedc5a4968646e0912bd9e98754158b21a9", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -79,7 +79,7 @@ pub unsafe fn local_data_set<T:Durable>(\n  */\n pub unsafe fn local_data_modify<T:Durable>(\n     key: LocalDataKey<T>,\n-    modify_fn: fn(Option<@T>) -> Option<@T>) {\n+    modify_fn: &fn(Option<@T>) -> Option<@T>) {\n \n     local_modify(rt::rust_get_task(), key, modify_fn)\n }"}, {"sha": "bb05520e1a363a44328104514430023fd153319f", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -176,7 +176,7 @@ pub unsafe fn local_set<T:Durable>(\n \n pub unsafe fn local_modify<T:Durable>(\n     task: *rust_task, key: LocalDataKey<T>,\n-    modify_fn: fn(Option<@T>) -> Option<@T>) {\n+    modify_fn: &fn(Option<@T>) -> Option<@T>) {\n \n     // Could be more efficient by doing the lookup work, but this is easy.\n     let newdata = modify_fn(local_pop(task, key));"}, {"sha": "31c44531efec0727a84cfc1f15c3758f5d757e59", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -295,7 +295,7 @@ pub impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn future_result(&self, blk: fn(v: Port<TaskResult>)) -> TaskBuilder {\n+    fn future_result(&self, blk: &fn(v: Port<TaskResult>)) -> TaskBuilder {\n         // FIXME (#3725): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -572,7 +572,7 @@ pub fn get_scheduler() -> Scheduler {\n  * }\n  * ~~~\n  */\n-pub unsafe fn unkillable<U>(f: fn() -> U) -> U {\n+pub unsafe fn unkillable<U>(f: &fn() -> U) -> U {\n     struct AllowFailure {\n         t: *rust_task,\n         drop {\n@@ -597,7 +597,7 @@ pub unsafe fn unkillable<U>(f: fn() -> U) -> U {\n }\n \n /// The inverse of unkillable. Only ever to be used nested in unkillable().\n-pub unsafe fn rekillable<U>(f: fn() -> U) -> U {\n+pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n     struct DisallowFailure {\n         t: *rust_task,\n         drop {\n@@ -625,7 +625,7 @@ pub unsafe fn rekillable<U>(f: fn() -> U) -> U {\n  * A stronger version of unkillable that also inhibits scheduling operations.\n  * For use with exclusive ARCs, which use pthread mutexes directly.\n  */\n-pub unsafe fn atomically<U>(f: fn() -> U) -> U {\n+pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n     struct DeferInterrupts {\n         t: *rust_task,\n         drop {"}, {"sha": "617149f7fd57dcd94b2c85e0eb5e043aa8ffbedd", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -108,7 +108,7 @@ fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     let was_present = tasks.remove(&task);\n     fail_unless!(was_present);\n }\n-pub fn taskset_each(tasks: &TaskSet, blk: fn(v: *rust_task) -> bool) {\n+pub fn taskset_each(tasks: &TaskSet, blk: &fn(v: *rust_task) -> bool) {\n     tasks.each(|k| blk(*k))\n }\n \n@@ -155,13 +155,13 @@ enum AncestorList = Option<unstable::Exclusive<AncestorNode>>;\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n-fn access_group<U>(x: &TaskGroupArc, blk: fn(TaskGroupInner) -> U) -> U {\n+fn access_group<U>(x: &TaskGroupArc, blk: &fn(TaskGroupInner) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n \n #[inline(always)]\n fn access_ancestors<U>(x: &unstable::Exclusive<AncestorNode>,\n-                       blk: fn(x: &mut AncestorNode) -> U) -> U {\n+                       blk: &fn(x: &mut AncestorNode) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n \n@@ -175,7 +175,7 @@ fn access_ancestors<U>(x: &unstable::Exclusive<AncestorNode>,\n // allocations. Once that bug is fixed, changing the sigil should suffice.\n fn each_ancestor(list:        &mut AncestorList,\n                  bail_opt:    Option<@fn(TaskGroupInner)>,\n-                 forward_blk: fn(TaskGroupInner) -> bool)\n+                 forward_blk: &fn(TaskGroupInner) -> bool)\n               -> bool {\n     // \"Kickoff\" call - there was no last generation.\n     return !coalesce(list, bail_opt, forward_blk, uint::max_value);\n@@ -184,7 +184,7 @@ fn each_ancestor(list:        &mut AncestorList,\n     // whether or not unwinding is needed (i.e., !successful iteration).\n     fn coalesce(list:            &mut AncestorList,\n                 bail_opt:        Option<@fn(TaskGroupInner)>,\n-                forward_blk:     fn(TaskGroupInner) -> bool,\n+                forward_blk:     &fn(TaskGroupInner) -> bool,\n                 last_generation: uint) -> bool {\n         // Need to swap the list out to use it, to appease borrowck.\n         let tmp_list = util::replace(&mut *list, AncestorList(None));\n@@ -288,7 +288,7 @@ fn each_ancestor(list:        &mut AncestorList,\n \n         // Wrapper around exclusive::with that appeases borrowck.\n         fn with_parent_tg<U>(parent_group: &mut Option<TaskGroupArc>,\n-                             blk: fn(TaskGroupInner) -> U) -> U {\n+                             blk: &fn(TaskGroupInner) -> U) -> U {\n             // If this trips, more likely the problem is 'blk' failed inside.\n             let tmp_arc = option::swap_unwrap(&mut *parent_group);\n             let result = do access_group(&tmp_arc) |tg_opt| { blk(tg_opt) };"}, {"sha": "4bd751adc3c5e6b158dc1fe19d08067528bb891a", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -32,7 +32,7 @@ pub struct TrieMap<T> {\n impl<T> BaseIter<(uint, &'self T)> for TrieMap<T> {\n     /// Visit all key-value pairs in order\n     #[inline(always)]\n-    pure fn each(&self, f: fn(&(uint, &self/T)) -> bool) {\n+    pure fn each(&self, f: &fn(&(uint, &self/T)) -> bool) {\n         self.root.each(f);\n     }\n     #[inline(always)]\n@@ -42,7 +42,7 @@ impl<T> BaseIter<(uint, &'self T)> for TrieMap<T> {\n impl<T> ReverseIter<(uint, &'self T)> for TrieMap<T> {\n     /// Visit all key-value pairs in reverse order\n     #[inline(always)]\n-    pure fn each_reverse(&self, f: fn(&(uint, &self/T)) -> bool) {\n+    pure fn each_reverse(&self, f: &fn(&(uint, &self/T)) -> bool) {\n         self.root.each_reverse(f);\n     }\n }\n@@ -75,13 +75,13 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Visit all keys in order\n     #[inline(always)]\n-    pure fn each_key(&self, f: fn(&uint) -> bool) {\n+    pure fn each_key(&self, f: &fn(&uint) -> bool) {\n         self.each(|&(k, _)| f(&k))\n     }\n \n     /// Visit all values in order\n     #[inline(always)]\n-    pure fn each_value(&self, f: fn(&T) -> bool) { self.each(|&(_, v)| f(v)) }\n+    pure fn each_value(&self, f: &fn(&T) -> bool) { self.each(|&(_, v)| f(v)) }\n \n     /// Return the value corresponding to the key in the map\n     #[inline(hint)]\n@@ -138,18 +138,18 @@ impl<T> TrieMap<T> {\n impl<T> TrieMap<T> {\n     /// Visit all keys in reverse order\n     #[inline(always)]\n-    pure fn each_key_reverse(&self, f: fn(&uint) -> bool) {\n+    pure fn each_key_reverse(&self, f: &fn(&uint) -> bool) {\n         self.each_reverse(|&(k, _)| f(&k))\n     }\n \n     /// Visit all values in reverse order\n     #[inline(always)]\n-    pure fn each_value_reverse(&self, f: fn(&T) -> bool) {\n+    pure fn each_value_reverse(&self, f: &fn(&T) -> bool) {\n         self.each_reverse(|&(_, v)| f(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, f: fn(uint, &mut T) -> bool) {\n+    fn mutate_values(&mut self, f: &fn(uint, &mut T) -> bool) {\n         self.root.mutate_values(f);\n     }\n }\n@@ -160,13 +160,13 @@ pub struct TrieSet {\n \n impl BaseIter<uint> for TrieSet {\n     /// Visit all values in order\n-    pure fn each(&self, f: fn(&uint) -> bool) { self.map.each_key(f) }\n+    pure fn each(&self, f: &fn(&uint) -> bool) { self.map.each_key(f) }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl ReverseIter<uint> for TrieSet {\n     /// Visit all values in reverse order\n-    pure fn each_reverse(&self, f: fn(&uint) -> bool) {\n+    pure fn each_reverse(&self, f: &fn(&uint) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n }\n@@ -223,7 +223,7 @@ impl<T> TrieNode<T> {\n }\n \n impl<T> TrieNode<T> {\n-    pure fn each(&self, f: fn(&(uint, &self/T)) -> bool) -> bool {\n+    pure fn each(&self, f: &fn(&(uint, &self/T)) -> bool) -> bool {\n         for uint::range(0, self.children.len()) |idx| {\n             match self.children[idx] {\n                 Internal(ref x) => if !x.each(f) { return false },\n@@ -234,7 +234,7 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n-    pure fn each_reverse(&self, f: fn(&(uint, &self/T)) -> bool) -> bool {\n+    pure fn each_reverse(&self, f: &fn(&(uint, &self/T)) -> bool) -> bool {\n         for uint::range_rev(self.children.len(), 0) |idx| {\n             match self.children[idx - 1] {\n                 Internal(ref x) => if !x.each_reverse(f) { return false },\n@@ -245,7 +245,7 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n-    fn mutate_values(&mut self, f: fn(uint, &mut T) -> bool) -> bool {\n+    fn mutate_values(&mut self, f: &fn(uint, &mut T) -> bool) -> bool {\n         for vec::each_mut(self.children) |child| {\n             match *child {\n                 Internal(ref mut x) => if !x.mutate_values(f) {"}, {"sha": "4f45535d0f856eb7da02cb22434b873209096c79", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -232,7 +232,7 @@ fn LittleLock() -> LittleLock {\n \n pub impl LittleLock {\n     #[inline(always)]\n-    unsafe fn lock<T>(&self, f: fn() -> T) -> T {\n+    unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n         struct Unlock {\n             l: rust_little_lock,\n             drop {\n@@ -284,7 +284,7 @@ pub impl<T:Owned> Exclusive<T> {\n     // accessing the provided condition variable) are prohibited while inside\n     // the exclusive. Supporting that is a work in progress.\n     #[inline(always)]\n-    unsafe fn with<U>(&self, f: fn(x: &mut T) -> U) -> U {\n+    unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n         unsafe {\n             let rec = get_shared_mutable_state(&self.x);\n             do (*rec).lock.lock {\n@@ -301,7 +301,7 @@ pub impl<T:Owned> Exclusive<T> {\n     }\n \n     #[inline(always)]\n-    unsafe fn with_imm<U>(&self, f: fn(x: &T) -> U) -> U {\n+    unsafe fn with_imm<U>(&self, f: &fn(x: &T) -> U) -> U {\n         do self.with |x| {\n             f(cast::transmute_immut(x))\n         }"}, {"sha": "aed98f3573e71b249980a4a628214331304dad49", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 114, "deletions": 112, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -175,7 +175,7 @@ pub pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n  */\n #[inline(always)]\n pub pure fn build_sized<A>(size: uint,\n-                       builder: fn(push: pure fn(v: A))) -> ~[A] {\n+                       builder: &fn(push: &pure fn(v: A))) -> ~[A] {\n     let mut vec = with_capacity(size);\n     builder(|x| unsafe { vec.push(x) });\n     vec\n@@ -192,7 +192,7 @@ pub pure fn build_sized<A>(size: uint,\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A>(builder: fn(push: pure fn(v: A))) -> ~[A] {\n+pub pure fn build<A>(builder: &fn(push: &pure fn(v: A))) -> ~[A] {\n     build_sized(4, builder)\n }\n \n@@ -210,7 +210,7 @@ pub pure fn build<A>(builder: fn(push: pure fn(v: A))) -> ~[A] {\n  */\n #[inline(always)]\n pub pure fn build_sized_opt<A>(size: Option<uint>,\n-                           builder: fn(push: pure fn(v: A))) -> ~[A] {\n+                           builder: &fn(push: &pure fn(v: A))) -> ~[A] {\n     build_sized(size.get_or_default(4), builder)\n }\n \n@@ -305,7 +305,7 @@ pub pure fn const_slice<T>(v: &r/[const T],\n /// Copies\n \n /// Split the vector `v` by applying each element against the predicate `f`.\n-pub fn split<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn split<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -328,7 +328,7 @@ pub fn split<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n  * Split the vector `v` by applying each element against the predicate `f` up\n  * to `n` times.\n  */\n-pub fn splitn<T:Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn splitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -354,7 +354,7 @@ pub fn splitn<T:Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n  * Reverse split the vector `v` by applying each element against the predicate\n  * `f`.\n  */\n-pub fn rsplit<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn rsplit<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0) { return ~[] }\n \n@@ -378,7 +378,7 @@ pub fn rsplit<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n  * Reverse split the vector `v` by applying each element against the predicate\n  * `f` up to `n times.\n  */\n-pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -405,7 +405,7 @@ pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n  * Partitions a vector into two new vectors: those that satisfies the\n  * predicate, and those that do not.\n  */\n-pub fn partition<T>(v: ~[T], f: fn(&T) -> bool) -> (~[T], ~[T]) {\n+pub fn partition<T>(v: ~[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n     let mut lefts  = ~[];\n     let mut rights = ~[];\n \n@@ -426,7 +426,7 @@ pub fn partition<T>(v: ~[T], f: fn(&T) -> bool) -> (~[T], ~[T]) {\n  * Partitions a vector into two new vectors: those that satisfies the\n  * predicate, and those that do not.\n  */\n-pub pure fn partitioned<T:Copy>(v: &[T], f: fn(&T) -> bool) -> (~[T], ~[T]) {\n+pub pure fn partitioned<T:Copy>(v: &[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n     let mut lefts  = ~[];\n     let mut rights = ~[];\n \n@@ -535,7 +535,7 @@ pub fn remove<T>(v: &mut ~[T], i: uint) -> T {\n     v.pop()\n }\n \n-pub fn consume<T>(mut v: ~[T], f: fn(uint, v: T)) {\n+pub fn consume<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n     unsafe {\n         do as_mut_buf(v) |p, ln| {\n             for uint::range(0, ln) |i| {\n@@ -780,7 +780,7 @@ pub fn grow_set<T:Copy>(v: &mut ~[T], index: uint, initval: &T, val: T) {\n // Functional utilities\n \n /// Apply a function to each element of a vector and return the results\n-pub pure fn map<T, U>(v: &[T], f: fn(t: &T) -> U) -> ~[U] {\n+pub pure fn map<T, U>(v: &[T], f: &fn(t: &T) -> U) -> ~[U] {\n     let mut result = with_capacity(len(v));\n     for each(v) |elem| {\n         unsafe {\n@@ -790,7 +790,7 @@ pub pure fn map<T, U>(v: &[T], f: fn(t: &T) -> U) -> ~[U] {\n     result\n }\n \n-pub fn map_consume<T, U>(v: ~[T], f: fn(v: T) -> U) -> ~[U] {\n+pub fn map_consume<T, U>(v: ~[T], f: &fn(v: T) -> U) -> ~[U] {\n     let mut result = ~[];\n     do consume(v) |_i, x| {\n         result.push(f(x));\n@@ -799,7 +799,7 @@ pub fn map_consume<T, U>(v: ~[T], f: fn(v: T) -> U) -> ~[U] {\n }\n \n /// Apply a function to each element of a vector and return the results\n-pub pure fn mapi<T, U>(v: &[T], f: fn(uint, t: &T) -> U) -> ~[U] {\n+pub pure fn mapi<T, U>(v: &[T], f: &fn(uint, t: &T) -> U) -> ~[U] {\n     let mut i = 0;\n     do map(v) |e| {\n         i += 1;\n@@ -811,15 +811,15 @@ pub pure fn mapi<T, U>(v: &[T], f: fn(uint, t: &T) -> U) -> ~[U] {\n  * Apply a function to each element of a vector and return a concatenation\n  * of each result vector\n  */\n-pub pure fn flat_map<T, U>(v: &[T], f: fn(t: &T) -> ~[U]) -> ~[U] {\n+pub pure fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| { unsafe{ result.push_all_move(f(elem)); } }\n     result\n }\n \n /// Apply a function to each pair of elements and return the results\n pub pure fn map2<T:Copy,U:Copy,V>(v0: &[T], v1: &[U],\n-                                  f: fn(t: &T, v: &U) -> V) -> ~[V] {\n+                                  f: &fn(t: &T, v: &U) -> V) -> ~[V] {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { fail!(); }\n     let mut u: ~[V] = ~[];\n@@ -833,7 +833,7 @@ pub pure fn map2<T:Copy,U:Copy,V>(v0: &[T], v1: &[U],\n \n pub fn filter_map<T, U>(\n     v: ~[T],\n-    f: fn(t: T) -> Option<U>) -> ~[U]\n+    f: &fn(t: T) -> Option<U>) -> ~[U]\n {\n     /*!\n      *\n@@ -854,7 +854,7 @@ pub fn filter_map<T, U>(\n \n pub pure fn filter_mapped<T, U: Copy>(\n     v: &[T],\n-    f: fn(t: &T) -> Option<U>) -> ~[U]\n+    f: &fn(t: &T) -> Option<U>) -> ~[U]\n {\n     /*!\n      *\n@@ -879,7 +879,7 @@ pub pure fn filter_mapped<T, U: Copy>(\n  * Apply function `f` to each element of `v` and return a vector containing\n  * only those elements for which `f` returned true.\n  */\n-pub fn filter<T>(v: ~[T], f: fn(t: &T) -> bool) -> ~[T] {\n+pub fn filter<T>(v: ~[T], f: &fn(t: &T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     // FIXME (#4355 maybe): using v.consume here crashes\n     // do v.consume |_, elem| {\n@@ -896,7 +896,7 @@ pub fn filter<T>(v: ~[T], f: fn(t: &T) -> bool) -> ~[T] {\n  * Apply function `f` to each element of `v` and return a vector containing\n  * only those elements for which `f` returned true.\n  */\n-pub pure fn filtered<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[T] {\n+pub pure fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n         if f(elem) { unsafe { result.push(*elem); } }\n@@ -907,7 +907,7 @@ pub pure fn filtered<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[T] {\n /**\n  * Like `filter()`, but in place.  Preserves order of `v`.  Linear time.\n  */\n-pub fn retain<T>(v: &mut ~[T], f: pure fn(t: &T) -> bool) {\n+pub fn retain<T>(v: &mut ~[T], f: &pure fn(t: &T) -> bool) {\n     let len = v.len();\n     let mut deleted: uint = 0;\n \n@@ -963,7 +963,7 @@ pub pure fn connect<T:Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n  * ~~~\n  *\n  */\n-pub pure fn foldl<T, U>(z: T, v: &[U], p: fn(t: T, u: &U) -> T) -> T {\n+pub pure fn foldl<T, U>(z: T, v: &[U], p: &fn(t: T, u: &U) -> T) -> T {\n     let mut accum = z;\n     let mut i = 0;\n     let l = v.len();\n@@ -995,7 +995,7 @@ pub pure fn foldl<T, U>(z: T, v: &[U], p: fn(t: T, u: &U) -> T) -> T {\n  * ~~~\n  *\n  */\n-pub pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(t: &T, u: U) -> U) -> U {\n+pub pure fn foldr<T, U: Copy>(v: &[T], z: U, p: &fn(t: &T, u: U) -> U) -> U {\n     let mut accum = z;\n     for rev_each(v) |elt| {\n         accum = p(elt, accum);\n@@ -1008,7 +1008,7 @@ pub pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(t: &T, u: U) -> U) -> U {\n  *\n  * If the vector contains no elements then false is returned.\n  */\n-pub pure fn any<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n+pub pure fn any<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n     for each(v) |elem| { if f(elem) { return true; } }\n     false\n }\n@@ -1019,7 +1019,7 @@ pub pure fn any<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n  * If the vectors contains no elements then false is returned.\n  */\n pub pure fn any2<T, U>(v0: &[T], v1: &[U],\n-                   f: fn(a: &T, b: &U) -> bool) -> bool {\n+                   f: &fn(a: &T, b: &U) -> bool) -> bool {\n     let v0_len = len(v0);\n     let v1_len = len(v1);\n     let mut i = 0u;\n@@ -1035,7 +1035,7 @@ pub pure fn any2<T, U>(v0: &[T], v1: &[U],\n  *\n  * If the vector contains no elements then true is returned.\n  */\n-pub pure fn all<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n+pub pure fn all<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n     for each(v) |elem| { if !f(elem) { return false; } }\n     true\n }\n@@ -1045,7 +1045,7 @@ pub pure fn all<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n  *\n  * If the vector contains no elements then true is returned.\n  */\n-pub pure fn alli<T>(v: &[T], f: fn(uint, t: &T) -> bool) -> bool {\n+pub pure fn alli<T>(v: &[T], f: &fn(uint, t: &T) -> bool) -> bool {\n     for eachi(v) |i, elem| { if !f(i, elem) { return false; } }\n     true\n }\n@@ -1056,7 +1056,7 @@ pub pure fn alli<T>(v: &[T], f: fn(uint, t: &T) -> bool) -> bool {\n  * If the vectors are not the same size then false is returned.\n  */\n pub pure fn all2<T, U>(v0: &[T], v1: &[U],\n-                   f: fn(t: &T, u: &U) -> bool) -> bool {\n+                   f: &fn(t: &T, u: &U) -> bool) -> bool {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { return false; }\n     let mut i = 0u;\n@@ -1084,7 +1084,7 @@ pub pure fn count<T:Eq>(v: &[T], x: &T) -> uint {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pub pure fn find<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n+pub pure fn find<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n     find_between(v, 0u, len(v), f)\n }\n \n@@ -1096,7 +1096,7 @@ pub pure fn find<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n  * the element is returned. If `f` matches no elements then none is returned.\n  */\n pub pure fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n-                      f: fn(t: &T) -> bool) -> Option<T> {\n+                      f: &fn(t: &T) -> bool) -> Option<T> {\n     position_between(v, start, end, f).map(|i| v[*i])\n }\n \n@@ -1107,7 +1107,7 @@ pub pure fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n  * `f` returns true then an option containing the element is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pub pure fn rfind<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n+pub pure fn rfind<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n     rfind_between(v, 0u, len(v), f)\n }\n \n@@ -1119,7 +1119,7 @@ pub pure fn rfind<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n  * the element is returned. If `f` matches no elements then none is return.\n  */\n pub pure fn rfind_between<T:Copy>(v: &[T], start: uint, end: uint,\n-                               f: fn(t: &T) -> bool) -> Option<T> {\n+                               f: &fn(t: &T) -> bool) -> Option<T> {\n     rposition_between(v, start, end, f).map(|i| v[*i])\n }\n \n@@ -1135,7 +1135,7 @@ pub pure fn position_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n  * then an option containing the index is returned. If `f` matches no elements\n  * then none is returned.\n  */\n-pub pure fn position<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n+pub pure fn position<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n     position_between(v, 0u, len(v), f)\n }\n \n@@ -1147,7 +1147,7 @@ pub pure fn position<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n  * the index is returned. If `f` matches no elements then none is returned.\n  */\n pub pure fn position_between<T>(v: &[T], start: uint, end: uint,\n-                            f: fn(t: &T) -> bool) -> Option<uint> {\n+                            f: &fn(t: &T) -> bool) -> Option<uint> {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(v));\n     let mut i = start;\n@@ -1167,7 +1167,7 @@ pure fn rposition_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n  * `f` returns true then an option containing the index is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pub pure fn rposition<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n+pub pure fn rposition<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n     rposition_between(v, 0u, len(v), f)\n }\n \n@@ -1180,7 +1180,7 @@ pub pure fn rposition<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n  * returned.\n  */\n pub pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n-                             f: fn(t: &T) -> bool) -> Option<uint> {\n+                             f: &fn(t: &T) -> bool) -> Option<uint> {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(v));\n     let mut i = end;\n@@ -1334,7 +1334,7 @@ pub pure fn reversed<T:Copy>(v: &[const T]) -> ~[T] {\n  * ~~~\n  */\n #[inline(always)]\n-pub pure fn each<T>(v: &r/[T], f: fn(&r/T) -> bool) {\n+pub pure fn each<T>(v: &r/[T], f: &fn(&r/T) -> bool) {\n     //             ^^^^\n     // NB---this CANNOT be &[const T]!  The reason\n     // is that you are passing it to `f()` using\n@@ -1358,7 +1358,7 @@ pub pure fn each<T>(v: &r/[T], f: fn(&r/T) -> bool) {\n /// a vector with mutable contents and you would like\n /// to mutate the contents as you iterate.\n #[inline(always)]\n-pub fn each_mut<T>(v: &mut [T], f: fn(elem: &mut T) -> bool) {\n+pub fn each_mut<T>(v: &mut [T], f: &fn(elem: &mut T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1372,7 +1372,7 @@ pub fn each_mut<T>(v: &mut [T], f: fn(elem: &mut T) -> bool) {\n /// Like `each()`, but for the case where you have a vector that *may or may\n /// not* have mutable contents.\n #[inline(always)]\n-pub pure fn each_const<T>(v: &[const T], f: fn(elem: &const T) -> bool) {\n+pub pure fn each_const<T>(v: &[const T], f: &fn(elem: &const T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1389,7 +1389,7 @@ pub pure fn each_const<T>(v: &[const T], f: fn(elem: &const T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn eachi<T>(v: &r/[T], f: fn(uint, v: &r/T) -> bool) {\n+pub pure fn eachi<T>(v: &r/[T], f: &fn(uint, v: &r/T) -> bool) {\n     let mut i = 0;\n     for each(v) |p| {\n         if !f(i, p) { return; }\n@@ -1403,7 +1403,7 @@ pub pure fn eachi<T>(v: &r/[T], f: fn(uint, v: &r/T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn rev_each<T>(v: &r/[T], blk: fn(v: &r/T) -> bool) {\n+pub pure fn rev_each<T>(v: &r/[T], blk: &fn(v: &r/T) -> bool) {\n     rev_eachi(v, |_i, v| blk(v))\n }\n \n@@ -1413,7 +1413,7 @@ pub pure fn rev_each<T>(v: &r/[T], blk: fn(v: &r/T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n+pub pure fn rev_eachi<T>(v: &r/[T], blk: &fn(i: uint, v: &r/T) -> bool) {\n     let mut i = v.len();\n     while i > 0 {\n         i -= 1;\n@@ -1431,7 +1431,7 @@ pub pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n  * Both vectors must have the same length\n  */\n #[inline]\n-pub pure fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n+pub pure fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n     fail_unless!(len(v1) == len(v2));\n     for uint::range(0u, len(v1)) |i| {\n         if !f(&v1[i], &v2[i]) {\n@@ -1450,7 +1450,7 @@ pub pure fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n  * The total number of permutations produced is `len(v)!`.  If `v` contains\n  * repeated elements, then some permutations are repeated.\n  */\n-pub pure fn each_permutation<T:Copy>(v: &[T], put: fn(ts: &[T]) -> bool) {\n+pub pure fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n     let ln = len(v);\n     if ln <= 1 {\n         put(v);\n@@ -1497,7 +1497,7 @@ pub pure fn windowed<TT:Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n #[inline(always)]\n pub pure fn as_imm_buf<T,U>(s: &[T],\n                             /* NB---this CANNOT be const, see below */\n-                            f: fn(*T, uint) -> U) -> U {\n+                            f: &fn(*T, uint) -> U) -> U {\n \n     // NB---Do not change the type of s to `&[const T]`.  This is\n     // unsound.  The reason is that we are going to create immutable pointers\n@@ -1516,7 +1516,7 @@ pub pure fn as_imm_buf<T,U>(s: &[T],\n /// Similar to `as_imm_buf` but passing a `*const T`\n #[inline(always)]\n pub pure fn as_const_buf<T,U>(s: &[const T],\n-                          f: fn(*const T, uint) -> U) -> U {\n+                          f: &fn(*const T, uint) -> U) -> U {\n \n     unsafe {\n         let v : *(*const T,uint) =\n@@ -1529,7 +1529,7 @@ pub pure fn as_const_buf<T,U>(s: &[const T],\n /// Similar to `as_imm_buf` but passing a `*mut T`\n #[inline(always)]\n pub pure fn as_mut_buf<T,U>(s: &mut [T],\n-                        f: fn(*mut T, uint) -> U) -> U {\n+                        f: &fn(*mut T, uint) -> U) -> U {\n \n     unsafe {\n         let v : *(*mut T,uint) =\n@@ -1721,13 +1721,13 @@ pub trait ImmutableVector<T> {\n     pure fn initn(&self, n: uint) -> &self/[T];\n     pure fn last(&self) -> &self/T;\n     pure fn last_opt(&self) -> Option<&self/T>;\n-    pure fn foldr<U: Copy>(&self, z: U, p: fn(t: &T, u: U) -> U) -> U;\n-    pure fn map<U>(&self, f: fn(t: &T) -> U) -> ~[U];\n-    pure fn mapi<U>(&self, f: fn(uint, t: &T) -> U) -> ~[U];\n-    fn map_r<U>(&self, f: fn(x: &T) -> U) -> ~[U];\n-    pure fn alli(&self, f: fn(uint, t: &T) -> bool) -> bool;\n-    pure fn flat_map<U>(&self, f: fn(t: &T) -> ~[U]) -> ~[U];\n-    pure fn filter_mapped<U:Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U];\n+    pure fn foldr<U: Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U;\n+    pure fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n+    pure fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n+    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U];\n+    pure fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool;\n+    pure fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n+    pure fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n }\n \n /// Extension methods for vectors\n@@ -1772,24 +1772,24 @@ impl<T> ImmutableVector<T> for &self/[T] {\n \n     /// Reduce a vector from right to left\n     #[inline]\n-    pure fn foldr<U:Copy>(&self, z: U, p: fn(t: &T, u: U) -> U) -> U {\n+    pure fn foldr<U:Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U {\n         foldr(*self, z, p)\n     }\n \n     /// Apply a function to each element of a vector and return the results\n     #[inline]\n-    pure fn map<U>(&self, f: fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n+    pure fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n \n     /**\n      * Apply a function to the index and value of each element in the vector\n      * and return the results\n      */\n-    pure fn mapi<U>(&self, f: fn(uint, t: &T) -> U) -> ~[U] {\n+    pure fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U] {\n         mapi(*self, f)\n     }\n \n     #[inline]\n-    fn map_r<U>(&self, f: fn(x: &T) -> U) -> ~[U] {\n+    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U] {\n         let mut r = ~[];\n         let mut i = 0;\n         while i < self.len() {\n@@ -1804,15 +1804,15 @@ impl<T> ImmutableVector<T> for &self/[T] {\n      *\n      *     If the vector is empty, true is returned.\n      */\n-    pure fn alli(&self, f: fn(uint, t: &T) -> bool) -> bool {\n+    pure fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool {\n         alli(*self, f)\n     }\n     /**\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector\n      */\n     #[inline]\n-    pure fn flat_map<U>(&self, f: fn(t: &T) -> ~[U]) -> ~[U] {\n+    pure fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n         flat_map(*self, f)\n     }\n     /**\n@@ -1822,15 +1822,15 @@ impl<T> ImmutableVector<T> for &self/[T] {\n      * the resulting vector.\n      */\n     #[inline]\n-    pure fn filter_mapped<U:Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U] {\n+    pure fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n         filter_mapped(*self, f)\n     }\n }\n \n pub trait ImmutableEqVector<T:Eq> {\n-    pure fn position(&self, f: fn(t: &T) -> bool) -> Option<uint>;\n+    pure fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n     pure fn position_elem(&self, t: &T) -> Option<uint>;\n-    pure fn rposition(&self, f: fn(t: &T) -> bool) -> Option<uint>;\n+    pure fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n     pure fn rposition_elem(&self, t: &T) -> Option<uint>;\n }\n \n@@ -1843,7 +1843,7 @@ impl<T:Eq> ImmutableEqVector<T> for &self/[T] {\n      * elements then none is returned.\n      */\n     #[inline]\n-    pure fn position(&self, f: fn(t: &T) -> bool) -> Option<uint> {\n+    pure fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n         position(*self, f)\n     }\n \n@@ -1861,7 +1861,7 @@ impl<T:Eq> ImmutableEqVector<T> for &self/[T] {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rposition(&self, f: fn(t: &T) -> bool) -> Option<uint> {\n+    pure fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n         rposition(*self, f)\n     }\n \n@@ -1873,9 +1873,9 @@ impl<T:Eq> ImmutableEqVector<T> for &self/[T] {\n }\n \n pub trait ImmutableCopyableVector<T> {\n-    pure fn filtered(&self, f: fn(&T) -> bool) -> ~[T];\n-    pure fn rfind(&self, f: fn(t: &T) -> bool) -> Option<T>;\n-    pure fn partitioned(&self, f: fn(&T) -> bool) -> (~[T], ~[T]);\n+    pure fn filtered(&self, f: &fn(&T) -> bool) -> ~[T];\n+    pure fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T>;\n+    pure fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n }\n \n /// Extension methods for vectors\n@@ -1888,7 +1888,7 @@ impl<T:Copy> ImmutableCopyableVector<T> for &self/[T] {\n      * containing only those elements for which `f` returned true.\n      */\n     #[inline]\n-    pure fn filtered(&self, f: fn(t: &T) -> bool) -> ~[T] {\n+    pure fn filtered(&self, f: &fn(t: &T) -> bool) -> ~[T] {\n         filtered(*self, f)\n     }\n \n@@ -1900,7 +1900,7 @@ impl<T:Copy> ImmutableCopyableVector<T> for &self/[T] {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rfind(&self, f: fn(t: &T) -> bool) -> Option<T> {\n+    pure fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T> {\n         rfind(*self, f)\n     }\n \n@@ -1909,7 +1909,7 @@ impl<T:Copy> ImmutableCopyableVector<T> for &self/[T] {\n      * those that do not.\n      */\n     #[inline]\n-    pure fn partitioned(&self, f: fn(&T) -> bool) -> (~[T], ~[T]) {\n+    pure fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n         partitioned(*self, f)\n     }\n }\n@@ -1924,10 +1924,10 @@ pub trait OwnedVector<T> {\n     fn remove(&mut self, i: uint) -> T;\n     fn swap_remove(&mut self, index: uint) -> T;\n     fn truncate(&mut self, newlen: uint);\n-    fn retain(&mut self, f: pure fn(t: &T) -> bool);\n-    fn consume(self, f: fn(uint, v: T));\n-    fn filter(self, f: fn(t: &T) -> bool) -> ~[T];\n-    fn partition(self, f: pure fn(&T) -> bool) -> (~[T], ~[T]);\n+    fn retain(&mut self, f: &pure fn(t: &T) -> bool);\n+    fn consume(self, f: &fn(uint, v: T));\n+    fn filter(self, f: &fn(t: &T) -> bool) -> ~[T];\n+    fn partition(self, f: &pure fn(&T) -> bool) -> (~[T], ~[T]);\n     fn grow_fn(&mut self, n: uint, op: iter::InitOp<T>);\n }\n \n@@ -1978,17 +1978,17 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    fn retain(&mut self, f: pure fn(t: &T) -> bool) {\n+    fn retain(&mut self, f: &pure fn(t: &T) -> bool) {\n         retain(self, f);\n     }\n \n     #[inline]\n-    fn consume(self, f: fn(uint, v: T)) {\n+    fn consume(self, f: &fn(uint, v: T)) {\n         consume(self, f)\n     }\n \n     #[inline]\n-    fn filter(self, f: fn(&T) -> bool) -> ~[T] {\n+    fn filter(self, f: &fn(&T) -> bool) -> ~[T] {\n         filter(self, f)\n     }\n \n@@ -1997,7 +1997,7 @@ impl<T> OwnedVector<T> for ~[T] {\n      * those that do not.\n      */\n     #[inline]\n-    fn partition(self, f: fn(&T) -> bool) -> (~[T], ~[T]) {\n+    fn partition(self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n         partition(self, f)\n     }\n \n@@ -2138,7 +2138,7 @@ pub mod raw {\n     #[inline(always)]\n     pub unsafe fn buf_as_slice<T,U>(p: *T,\n                                     len: uint,\n-                                    f: fn(v: &[T]) -> U) -> U {\n+                                    f: &fn(v: &[T]) -> U) -> U {\n         let pair = (p, len * sys::nonzero_size_of::<T>());\n         let v : *(&blk/[T]) =\n             ::cast::reinterpret_cast(&addr_of(&pair));\n@@ -2270,99 +2270,101 @@ pub mod bytes {\n \n impl<A> iter::BaseIter<A> for &self/[A] {\n     #[inline(always)]\n-    pure fn each(&self, blk: fn(v: &'self A) -> bool) { each(*self, blk) }\n+    pub pure fn each(&self, blk: &fn(v: &'self A) -> bool) {\n+        each(*self, blk)\n+    }\n     #[inline(always)]\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::BaseIter<A> for ~[A] {\n     #[inline(always)]\n-    pure fn each(&self, blk: fn(v: &'self A) -> bool) { each(*self, blk) }\n+    pure fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::BaseIter<A> for @[A] {\n     #[inline(always)]\n-    pure fn each(&self, blk: fn(v: &'self A) -> bool) { each(*self, blk) }\n+    pure fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<A> iter::ExtendedIter<A> for &self/[A] {\n-    pub pure fn eachi(&self, blk: fn(uint, v: &A) -> bool) {\n+    pub pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n-    pub pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n+    pub pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n-    pub pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n+    pub pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n-    pub pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B {\n+    pub pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n-    pub pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n+    pub pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n-    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B] {\n+    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: fn(&A) -> IB)\n+    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::ExtendedIter<A> for ~[A] {\n-    pub pure fn eachi(&self, blk: fn(uint, v: &A) -> bool) {\n+    pub pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n-    pub pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n+    pub pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n-    pub pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n+    pub pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n-    pub pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B {\n+    pub pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n-    pub pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n+    pub pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n-    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B] {\n+    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: fn(&A) -> IB)\n+    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::ExtendedIter<A> for @[A] {\n-    pub pure fn eachi(&self, blk: fn(uint, v: &A) -> bool) {\n+    pub pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n-    pub pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n+    pub pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n-    pub pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n+    pub pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n-    pub pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B {\n+    pub pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n-    pub pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n+    pub pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n-    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B] {\n+    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: fn(&A) -> IB)\n+    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n@@ -2386,33 +2388,33 @@ impl<A:Eq> iter::EqIter<A> for @[A] {\n }\n \n impl<A:Copy> iter::CopyableIter<A> for &self/[A] {\n-    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n+    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n     pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n-    pub pure fn find(&self, f: fn(&A) -> bool) -> Option<A> {\n+    pub pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableIter<A> for ~[A] {\n-    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n+    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n     pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n-    pub pure fn find(&self, f: fn(&A) -> bool) -> Option<A> {\n+    pub pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableIter<A> for @[A] {\n-    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n+    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n     pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n-    pub pure fn find(&self, f: fn(&A) -> bool) -> Option<A> {\n+    pub pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }\n@@ -2435,7 +2437,7 @@ impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for @[A] {\n }\n \n impl<A:Copy> iter::CopyableNonstrictIter<A> for &self/[A] {\n-    pure fn each_val(&const self, f: fn(A) -> bool) {\n+    pure fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < self.len() {\n             if !f(copy self[i]) { break; }\n@@ -2446,7 +2448,7 @@ impl<A:Copy> iter::CopyableNonstrictIter<A> for &self/[A] {\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableNonstrictIter<A> for ~[A] {\n-    pure fn each_val(&const self, f: fn(A) -> bool) {\n+    pure fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < self.len() {\n             if !f(copy self[i]) { break; }\n@@ -2457,7 +2459,7 @@ impl<A:Copy> iter::CopyableNonstrictIter<A> for ~[A] {\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableNonstrictIter<A> for @[A] {\n-    pure fn each_val(&const self, f: fn(A) -> bool) {\n+    pure fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < self.len() {\n             if !f(copy self[i]) { break; }"}, {"sha": "90ada832327f4cb4b66e71bdc010bc0f390e2fc3", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -247,7 +247,7 @@ pub fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n     *crate2\n }\n \n-pub fn under(n: uint, it: fn(uint)) {\n+pub fn under(n: uint, it: &fn(uint)) {\n     let mut i: uint = 0u;\n     while i < n { it(i); i += 1u; }\n }"}, {"sha": "fec3f77668137d1bfd8c0f2c584745032e93b791", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -153,7 +153,7 @@ pub mod jit {\n                     code: entry,\n                     env: ptr::null()\n                 };\n-                let func: fn(++argv: ~[~str]) = cast::transmute(closure);\n+                let func: &fn(++argv: ~[~str]) = cast::transmute(closure);\n \n                 func(~[/*bad*/copy sess.opts.binary]);\n             }"}, {"sha": "2b61c9480457deb831dec84f48355790e6f036e8", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -164,7 +164,7 @@ pub fn parse_input(sess: Session, +cfg: ast::crate_cfg, input: input)\n     }\n }\n \n-pub fn time<T>(do_it: bool, what: ~str, thunk: fn() -> T) -> T {\n+pub fn time<T>(do_it: bool, what: ~str, thunk: &fn() -> T) -> T {\n     if !do_it { return thunk(); }\n     let start = std::time::precise_time_s();\n     let rv = thunk();"}, {"sha": "d2d0ceff6331df663477fee8a0012c254e4cd98c", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -306,7 +306,7 @@ pub fn basic_options() -> @options {\n // Seems out of place, but it uses session, so I'm putting it here\n pub fn expect<T:Copy>(sess: Session,\n                        opt: Option<T>,\n-                       msg: fn() -> ~str)\n+                       msg: &fn() -> ~str)\n                     -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }"}, {"sha": "47ee477210b78c04cdb02eccf440dd473cb9d2d9", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -155,7 +155,7 @@ pub fn get_static_methods_if_impl(cstore: @mut cstore::CStore,\n \n pub fn get_item_attrs(cstore: @mut cstore::CStore,\n                       def_id: ast::def_id,\n-                      f: fn(~[@ast::meta_item])) {\n+                      f: &fn(~[@ast::meta_item])) {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::get_item_attrs(cdata, def_id.node, f)\n }"}, {"sha": "0909a4437369daa14d085a34acf4b9755658fa81", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -88,7 +88,7 @@ pub fn have_crate_data(cstore: @mut CStore, cnum: ast::crate_num) -> bool {\n }\n \n pub fn iter_crate_data(cstore: @mut CStore,\n-                       i: fn(ast::crate_num, @crate_metadata)) {\n+                       i: &fn(ast::crate_num, @crate_metadata)) {\n     let metas = cstore.metas;\n     for metas.each |&k, &v| {\n         i(k, v);"}, {"sha": "2643012d30ae2255cc12c3dd6671bd2b5b2a5481", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -48,7 +48,7 @@ type cmd = @crate_metadata;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash(d: ebml::Doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n+fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: uint) ->\n    Option<ebml::Doc> {\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n@@ -193,7 +193,7 @@ fn item_def_id(d: ebml::Doc, cdata: cmd) -> ast::def_id {\n                                                     |d| parse_def_id(d)));\n }\n \n-fn each_reexport(d: ebml::Doc, f: fn(ebml::Doc) -> bool) {\n+fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) {\n     for reader::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n         if !f(reexport_doc) {\n             return;\n@@ -451,7 +451,7 @@ pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) {\n /// Iterates over all the paths in the given crate.\n pub fn each_path(intr: @ident_interner, cdata: cmd,\n                  get_crate_data: GetCrateDataCb,\n-                 f: fn(&str, def_like) -> bool) {\n+                 f: &fn(&str, def_like) -> bool) {\n     let root = reader::Doc(cdata.data);\n     let items = reader::get_doc(root, tag_items);\n     let items_data = reader::get_doc(items, tag_items_data);\n@@ -855,7 +855,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n \n pub fn get_item_attrs(cdata: cmd,\n                       node_id: ast::node_id,\n-                      f: fn(~[@ast::meta_item])) {\n+                      f: &fn(~[@ast::meta_item])) {\n \n     let item = lookup_item(node_id, cdata.data);\n     for reader::tagged_docs(item, tag_attributes) |attributes| {\n@@ -1093,7 +1093,7 @@ pub fn get_crate_vers(data: @~[u8]) -> @~str {\n \n fn iter_crate_items(intr: @ident_interner, cdata: cmd,\n                     get_crate_data: GetCrateDataCb,\n-                    proc: fn(path: &str, ast::def_id)) {\n+                    proc: &fn(path: &str, ast::def_id)) {\n     for each_path(intr, cdata, get_crate_data) |path_string, def_like| {\n         match def_like {\n             dl_impl(*) | dl_field => {}"}, {"sha": "fc42ac2ffedb9c43419ae159b559a10b6efbd2bb", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -1054,7 +1054,7 @@ fn create_index<T:Copy + Hash + IterBytes>(index: ~[entry<T>]) ->\n }\n \n fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n-                   write_fn: fn(io::Writer, T)) {\n+                   write_fn: &fn(io::Writer, T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs: ~[uint] = ~[];"}, {"sha": "63b14cc51be1c4c89fb7efe27ec21fbdc9edd33d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -217,7 +217,7 @@ fn parse_region(st: @mut PState) -> ty::Region {\n     }\n }\n \n-fn parse_opt<T>(st: @mut PState, f: fn() -> T) -> Option<T> {\n+fn parse_opt<T>(st: @mut PState, f: &fn() -> T) -> Option<T> {\n     match next(st) {\n       'n' => None,\n       's' => Some(f()),"}, {"sha": "b9cb0b1d4b5a3e38eabe65b05600ed5e01b093c6", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -122,7 +122,7 @@ fn enc_mt(w: io::Writer, cx: @ctxt, mt: ty::mt) {\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T>(w: io::Writer, t: Option<T>, enc_f: fn(T)) {\n+fn enc_opt<T>(w: io::Writer, t: Option<T>, enc_f: &fn(T)) {\n     match &t {\n       &None => w.write_char('n'),\n       &Some(ref v) => {"}, {"sha": "c1a8f79b9b131dace1eab45060767b2bc60fc52d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -795,12 +795,12 @@ impl ebml_writer_helpers for writer::Encoder {\n }\n \n trait write_tag_and_id {\n-    fn tag(&self, tag_id: c::astencode_tag, f: fn());\n+    fn tag(&self, tag_id: c::astencode_tag, f: &fn());\n     fn id(&self, id: ast::node_id);\n }\n \n impl write_tag_and_id for writer::Encoder {\n-    fn tag(&self, tag_id: c::astencode_tag, f: fn()) {\n+    fn tag(&self, tag_id: c::astencode_tag, f: &fn()) {\n         do self.wr_tag(tag_id as uint) { f() }\n     }\n "}, {"sha": "3e637071624170c8e703d59233fd3c58ea306a92", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -510,7 +510,7 @@ pub impl BorrowckCtxt {\n                                  method_map: self.method_map}\n     }\n \n-    fn cat_pattern(&self, cmt: cmt, pat: @ast::pat, op: fn(cmt, @ast::pat)) {\n+    fn cat_pattern(&self, cmt: cmt, pat: @ast::pat, op: &fn(cmt, @ast::pat)) {\n         let mc = self.mc_ctxt();\n         mc.cat_pattern(cmt, pat, op);\n     }"}, {"sha": "48d136ce65f365aeff60cd3a93017cc5a2538058", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -95,7 +95,7 @@ type check_fn = @fn(Context, @freevar_entry);\n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the node_id for some expression that creates the\n // closure.\n-fn with_appropriate_checker(cx: Context, id: node_id, b: fn(check_fn)) {\n+fn with_appropriate_checker(cx: Context, id: node_id, b: &fn(check_fn)) {\n     fn check_for_uniq(cx: Context, fv: @freevar_entry) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in."}, {"sha": "5ff731a27f030e24168e59aabb8a011a1f4f8fef", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -342,7 +342,7 @@ pub impl Context {\n      * current lint context, call the provided function, then reset the\n      * lints in effect to their previous state.\n      */\n-    fn with_lint_attrs(&self, attrs: ~[ast::attribute], f: fn(Context)) {\n+    fn with_lint_attrs(&self, attrs: ~[ast::attribute], f: &fn(Context)) {\n \n         let mut new_ctxt = *self;\n         let mut triples = ~[];"}, {"sha": "1bde1e85843fe3ce448a2d652ec0aa8a7278c4fc", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -735,7 +735,7 @@ pub impl Liveness {\n         }\n     }\n \n-    fn pat_bindings(&self, pat: @pat, f: fn(LiveNode, Variable, span)) {\n+    fn pat_bindings(&self, pat: @pat, f: &fn(LiveNode, Variable, span)) {\n         let def_map = self.tcx.def_map;\n         do pat_util::pat_bindings(def_map, pat) |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n@@ -745,7 +745,7 @@ pub impl Liveness {\n     }\n \n     fn arm_pats_bindings(&self,\n-                         pats: &[@pat], f: fn(LiveNode, Variable, span)) {\n+                         pats: &[@pat], f: &fn(LiveNode, Variable, span)) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n         // the \"authoratative\" set of ids\n@@ -809,15 +809,14 @@ pub impl Liveness {\n         self.assigned_on_entry(copy self.successors[*ln], var)\n     }\n \n-    fn indices(&self, ln: LiveNode, op: fn(uint)) {\n+    fn indices(&self, ln: LiveNode, op: &fn(uint)) {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for uint::range(0, self.ir.num_vars) |var_idx| {\n             op(node_base_idx + var_idx)\n         }\n     }\n \n-    fn indices2(&self, ln: LiveNode, succ_ln: LiveNode,\n-                op: fn(uint, uint)) {\n+    fn indices2(&self, ln: LiveNode, succ_ln: LiveNode, op: &fn(uint, uint)) {\n         let node_base_idx = self.idx(ln, Variable(0u));\n         let succ_base_idx = self.idx(succ_ln, Variable(0u));\n         for uint::range(0u, self.ir.num_vars) |var_idx| {\n@@ -827,7 +826,7 @@ pub impl Liveness {\n \n     fn write_vars(&self, wr: io::Writer,\n                   ln: LiveNode,\n-                  test: fn(uint) -> LiveNode) {\n+                  test: &fn(uint) -> LiveNode) {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for uint::range(0, self.ir.num_vars) |var_idx| {\n             let idx = node_base_idx + var_idx;\n@@ -1510,7 +1509,7 @@ pub impl Liveness {\n     fn with_loop_nodes<R>(&self, loop_node_id: node_id,\n                           break_ln: LiveNode,\n                           cont_ln: LiveNode,\n-                          f: fn() -> R) -> R {\n+                          f: &fn() -> R) -> R {\n       debug!(\"with_loop_nodes: %d %u\", loop_node_id, *break_ln);\n         self.loop_scope.push(loop_node_id);\n         self.break_ln.insert(loop_node_id, break_ln);"}, {"sha": "9e0ecb5a218595ad934aeda074b50544326b1e63", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -856,7 +856,7 @@ pub impl mem_categorization_ctxt {\n     fn cat_pattern(&self,\n                    cmt: cmt,\n                    pat: @ast::pat,\n-                   op: fn(cmt, @ast::pat))\n+                   op: &fn(cmt, @ast::pat))\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against."}, {"sha": "4522977a4ab1293b3c0d45888afca7d56206161b", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -72,7 +72,7 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n }\n \n pub fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n-                it: fn(binding_mode, node_id, span, @path)) {\n+                it: &fn(binding_mode, node_id, span, @path)) {\n     do walk_pat(pat) |p| {\n         match p.node {\n           pat_ident(binding_mode, pth, _) if pat_is_binding(dm, p) => {"}, {"sha": "7ac559161af4fe47ffbfa5dbcb75a223c2642aac", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -3241,7 +3241,7 @@ pub impl Resolver {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope(@mut self, name: Option<ident>, f: fn()) {\n+    fn with_scope(@mut self, name: Option<ident>, f: &fn()) {\n         let orig_module = self.current_module;\n \n         // Move down in the graph.\n@@ -3661,7 +3661,7 @@ pub impl Resolver {\n \n     fn with_type_parameter_rib(@mut self,\n                                type_parameters: TypeParameters,\n-                               f: fn()) {\n+                               f: &fn()) {\n         match type_parameters {\n             HasTypeParameters(generics, node_id, initial_index,\n                               rib_kind) => {\n@@ -3702,13 +3702,13 @@ pub impl Resolver {\n         }\n     }\n \n-    fn with_label_rib(@mut self, f: fn()) {\n+    fn with_label_rib(@mut self, f: &fn()) {\n         self.label_ribs.push(@Rib(NormalRibKind));\n         f();\n         self.label_ribs.pop();\n     }\n \n-    fn with_constant_rib(@mut self, f: fn()) {\n+    fn with_constant_rib(@mut self, f: &fn()) {\n         self.value_ribs.push(@Rib(ConstantItemRibKind));\n         f();\n         self.value_ribs.pop();"}, {"sha": "d4ed0004c8f9be66c3e7edbdf93f764ae7073dc0", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -728,8 +728,8 @@ pub fn cast_shift_const_rhs(op: ast::binop,\n \n pub fn cast_shift_rhs(op: ast::binop,\n                       lhs: ValueRef, rhs: ValueRef,\n-                      trunc: fn(ValueRef, TypeRef) -> ValueRef,\n-                      zext: fn(ValueRef, TypeRef) -> ValueRef)\n+                      trunc: &fn(ValueRef, TypeRef) -> ValueRef,\n+                      zext: &fn(ValueRef, TypeRef) -> ValueRef)\n                    -> ValueRef {\n     // Shifts may have any size int on the rhs\n     unsafe {\n@@ -863,7 +863,7 @@ pub fn have_cached_lpad(bcx: block) -> bool {\n     return res;\n }\n \n-pub fn in_lpad_scope_cx(bcx: block, f: fn(+si: &mut scope_info)) {\n+pub fn in_lpad_scope_cx(bcx: block, f: &fn(+si: &mut scope_info)) {\n     let mut bcx = bcx;\n     loop {\n         {\n@@ -1326,7 +1326,7 @@ pub fn leave_block(bcx: block, out_of: block) -> block {\n pub fn with_scope(bcx: block,\n                   opt_node_info: Option<NodeInfo>,\n                   +name: ~str,\n-                  f: fn(block) -> block) -> block {\n+                  f: &fn(block) -> block) -> block {\n     let _icx = bcx.insn_ctxt(\"with_scope\");\n \n     debug!(\"with_scope(bcx=%s, opt_node_info=%?, name=%s)\",\n@@ -1341,7 +1341,7 @@ pub fn with_scope(bcx: block,\n pub fn with_scope_result(bcx: block,\n                          opt_node_info: Option<NodeInfo>,\n                          +name: ~str,\n-                         f: fn(block) -> Result) -> Result {\n+                         f: &fn(block) -> Result) -> Result {\n     let _icx = bcx.insn_ctxt(\"with_scope_result\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n     Br(bcx, scope_cx.llbb);\n@@ -1350,7 +1350,7 @@ pub fn with_scope_result(bcx: block,\n }\n \n pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<NodeInfo>,\n-                             +name: ~str, f: fn(block) -> datum::DatumBlock)\n+                             +name: ~str, f: &fn(block) -> datum::DatumBlock)\n                           -> datum::DatumBlock {\n     use middle::trans::datum::DatumBlock;\n \n@@ -1361,7 +1361,7 @@ pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<NodeInfo>,\n     DatumBlock {bcx: leave_block(bcx, scope_cx), datum: datum}\n }\n \n-pub fn block_locals(b: &ast::blk, it: fn(@ast::local)) {\n+pub fn block_locals(b: &ast::blk, it: &fn(@ast::local)) {\n     for vec::each(b.node.stmts) |s| {\n         match s.node {\n           ast::stmt_decl(d, _) => {\n@@ -1401,7 +1401,7 @@ pub fn alloc_local(cx: block, local: @ast::local) -> block {\n }\n \n \n-pub fn with_cond(bcx: block, val: ValueRef, f: fn(block) -> block) -> block {\n+pub fn with_cond(bcx: block, val: ValueRef, f: &fn(block) -> block) -> block {\n     let _icx = bcx.insn_ctxt(\"with_cond\");\n     let next_cx = base::sub_block(bcx, ~\"next\");\n     let cond_cx = base::sub_block(bcx, ~\"cond\");\n@@ -1742,8 +1742,8 @@ pub fn trans_closure(ccx: @CrateContext,\n                      param_substs: Option<@param_substs>,\n                      id: ast::node_id,\n                      impl_id: Option<ast::def_id>,\n-                     maybe_load_env: fn(fn_ctxt),\n-                     finish: fn(block)) {\n+                     maybe_load_env: &fn(fn_ctxt),\n+                     finish: &fn(block)) {\n     ccx.stats.n_closures += 1;\n     let _icx = ccx.insn_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);"}, {"sha": "7e159ef606242853ef4adc63efb6755768327de0", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -37,7 +37,7 @@ pub struct FnType {\n }\n \n pub impl FnType {\n-    fn decl_fn(&self, decl: fn(fnty: TypeRef) -> ValueRef) -> ValueRef {\n+    fn decl_fn(&self, decl: &fn(fnty: TypeRef) -> ValueRef) -> ValueRef {\n         let atys = vec::map(self.arg_tys, |t| t.ty);\n         let rty = self.ret_ty.ty;\n         let fnty = T_fn(atys, rty);"}, {"sha": "d5877ec563123fa79ad68d98da935897b3ac9f61", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -346,7 +346,7 @@ fn x86_64_tys(atys: &[TypeRef],\n     }\n \n     fn x86_64_ty(ty: TypeRef,\n-                 is_mem_cls: fn(cls: &[x86_64_reg_class]) -> bool,\n+                 is_mem_cls: &fn(cls: &[x86_64_reg_class]) -> bool,\n                  attr: Attribute) -> (LLVMType, Option<Attribute>) {\n         let mut cast = false;\n         let mut ty_attr = option::None;"}, {"sha": "9e38252dc9a8ad5a25e7255ac4c6a68313148748", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -438,7 +438,7 @@ pub fn trans_call_inner(\n     call_info: Option<NodeInfo>,\n     fn_expr_ty: ty::t,\n     ret_ty: ty::t,\n-    get_callee: fn(block) -> Callee,\n+    get_callee: &fn(block) -> Callee,\n     args: CallArgs,\n     dest: expr::Dest,\n     autoref_arg: AutorefArg) -> block {"}, {"sha": "11d3e1552028fe5144dc1f5065b36f3ffe2adf13", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -515,7 +515,7 @@ pub impl Datum {\n     fn get_element(&self, bcx: block,\n                    ty: ty::t,\n                    source: DatumCleanup,\n-                   gep: fn(ValueRef) -> ValueRef) -> Datum {\n+                   gep: &fn(ValueRef) -> ValueRef) -> Datum {\n         let base_val = self.to_ref_llval(bcx);\n         Datum {\n             val: gep(base_val),"}, {"sha": "af54d4734314c1d6ea8c63550ef6a2424d61d998", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -190,7 +190,7 @@ fn md_from_metadata<T>(val: debug_metadata) -> T {\n \n fn cached_metadata<T:Copy>(cache: metadata_cache,\n                             mdtag: int,\n-                            eq_fn: fn(md: T) -> bool)\n+                            eq_fn: &fn(md: T) -> bool)\n                          -> Option<T> {\n     unsafe {\n         if cache.contains_key(&mdtag) {"}, {"sha": "e38b0be7bccba6b280d4659d110a3db37c4c9792", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -1135,7 +1135,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n pub fn with_field_tys<R>(tcx: ty::ctxt,\n                          ty: ty::t,\n                          node_id_opt: Option<ast::node_id>,\n-                         op: fn(int, (&[ty::field])) -> R) -> R {\n+                         op: &fn(int, (&[ty::field])) -> R) -> R {\n     match ty::get(ty).sty {\n         ty::ty_struct(did, ref substs) => {\n             op(0, struct_mutable_fields(tcx, did, substs))"}, {"sha": "5552364df239de726eaf185669ccfeaeb4fcbafb", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -1138,11 +1138,11 @@ pub fn encl_region(cx: ctxt, id: ast::node_id) -> ty::Region {\n     }\n }\n \n-pub fn walk_ty(ty: t, f: fn(t)) {\n+pub fn walk_ty(ty: t, f: &fn(t)) {\n     maybe_walk_ty(ty, |t| { f(t); true });\n }\n \n-pub fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n+pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n     if !f(ty) { return; }\n     match /*bad*/copy get(ty).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n@@ -1170,11 +1170,11 @@ pub fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n     }\n }\n \n-pub fn fold_sty_to_ty(tcx: ty::ctxt, sty: &sty, foldop: fn(t) -> t) -> t {\n+pub fn fold_sty_to_ty(tcx: ty::ctxt, sty: &sty, foldop: &fn(t) -> t) -> t {\n     mk_t(tcx, fold_sty(sty, foldop))\n }\n \n-pub fn fold_sig(sig: &FnSig, fldop: fn(t) -> t) -> FnSig {\n+pub fn fold_sig(sig: &FnSig, fldop: &fn(t) -> t) -> FnSig {\n     let args = do sig.inputs.map |arg| {\n         arg { mode: arg.mode, ty: fldop(arg.ty) }\n     };\n@@ -1185,8 +1185,8 @@ pub fn fold_sig(sig: &FnSig, fldop: fn(t) -> t) -> FnSig {\n     }\n }\n \n-fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n-    fn fold_substs(substs: &substs, fldop: fn(t) -> t) -> substs {\n+fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n+    fn fold_substs(substs: &substs, fldop: &fn(t) -> t) -> substs {\n         substs {self_r: substs.self_r,\n                 self_ty: substs.self_ty.map(|t| fldop(*t)),\n                 tps: substs.tps.map(|t| fldop(*t))}\n@@ -1241,16 +1241,16 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n }\n \n // Folds types from the bottom up.\n-pub fn fold_ty(cx: ctxt, t0: t, fldop: fn(t) -> t) -> t {\n+pub fn fold_ty(cx: ctxt, t0: t, fldop: &fn(t) -> t) -> t {\n     let sty = fold_sty(&get(t0).sty, |t| fold_ty(cx, fldop(t), fldop));\n     fldop(mk_t(cx, sty))\n }\n \n pub fn walk_regions_and_ty(\n     cx: ctxt,\n     ty: t,\n-    walkr: fn(r: Region),\n-    walkt: fn(t: t) -> bool) {\n+    walkr: &fn(r: Region),\n+    walkt: &fn(t: t) -> bool) {\n \n     if (walkt(ty)) {\n         fold_regions_and_ty(\n@@ -1264,14 +1264,14 @@ pub fn walk_regions_and_ty(\n pub fn fold_regions_and_ty(\n     cx: ctxt,\n     ty: t,\n-    fldr: fn(r: Region) -> Region,\n-    fldfnt: fn(t: t) -> t,\n-    fldt: fn(t: t) -> t) -> t {\n+    fldr: &fn(r: Region) -> Region,\n+    fldfnt: &fn(t: t) -> t,\n+    fldt: &fn(t: t) -> t) -> t {\n \n     fn fold_substs(\n         substs: &substs,\n-        fldr: fn(r: Region) -> Region,\n-        fldt: fn(t: t) -> t)\n+        fldr: &fn(r: Region) -> Region,\n+        fldt: &fn(t: t) -> t)\n      -> substs {\n         substs {\n             self_r: substs.self_r.map(|r| fldr(*r)),\n@@ -1325,9 +1325,9 @@ pub fn fold_regions_and_ty(\n pub fn fold_regions(\n     cx: ctxt,\n     ty: t,\n-    fldr: fn(r: Region, in_fn: bool) -> Region) -> t {\n+    fldr: &fn(r: Region, in_fn: bool) -> Region) -> t {\n     fn do_fold(cx: ctxt, ty: t, in_fn: bool,\n-               fldr: fn(Region, bool) -> Region) -> t {\n+               fldr: &fn(Region, bool) -> Region) -> t {\n         debug!(\"do_fold(ty=%s, in_fn=%b)\", ty_to_str(cx, ty), in_fn);\n         if !type_has_regions(ty) { return ty; }\n         fold_regions_and_ty(\n@@ -2274,7 +2274,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n \n pub fn type_structurally_contains(cx: ctxt,\n                                   ty: t,\n-                                  test: fn(x: &sty) -> bool)\n+                                  test: &fn(x: &sty) -> bool)\n                                -> bool {\n     let sty = &get(ty).sty;\n     debug!(\"type_structurally_contains: %s\",\n@@ -4008,7 +4008,7 @@ pub fn struct_fields(cx: ctxt,\n fn struct_item_fields(cx:ctxt,\n                      did: ast::def_id,\n                      substs: &substs,\n-                     frob_mutability: fn(struct_mutability) -> mutability)\n+                     frob_mutability: &fn(struct_mutability) -> mutability)\n     -> ~[field] {\n     do lookup_struct_fields(cx, did).map |f| {\n        // consider all instance vars mut, because the"}, {"sha": "6c27decc283451d251e8819f69a726e79acb921b", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -36,7 +36,7 @@\n  * scopes and (b) the default region may change.  To understand case (a),\n  * consider something like:\n  *\n- *   type foo = { x: &a.int, y: fn(&a.int) }\n+ *   type foo = { x: &a.int, y: &fn(&a.int) }\n  *\n  * The type of `x` is an error because there is no region `a` in scope.\n  * In the type of `y`, however, region `a` is considered a bound region\n@@ -224,7 +224,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n         rscope: &RS,\n         a_seq_ty: ast::mt,\n         vst: ty::vstore,\n-        constr: fn(ty::mt) -> ty::t) -> ty::t\n+        constr: &fn(ty::mt) -> ty::t) -> ty::t\n     {\n         let tcx = self.tcx();\n "}, {"sha": "1bb71c156c3dc346ef0d73e8f228ee783d8032d6", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -33,7 +33,7 @@ pub fn subtype(fcx: @mut FnCtxt, sp: span, expected: ty::t, actual: ty::t) {\n pub fn suptype_with_fn(fcx: @mut FnCtxt,\n                        sp: span, b_is_expected: bool,\n                        ty_a: ty::t, ty_b: ty::t,\n-                       handle_err: fn(span, ty::t, ty::t, &ty::type_err)) {\n+                       handle_err: &fn(span, ty::t, ty::t, &ty::type_err)) {\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx(), b_is_expected, sp,\n                           ty_b, ty_a) {"}, {"sha": "f3804934186d4b070852a759c77575d9556b78ff", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -1142,7 +1142,7 @@ pub fn break_here() {\n pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                expr: @ast::expr,\n                                expected: Option<ty::t>,\n-                               unifier: fn()) -> bool {\n+                               unifier: &fn()) -> bool {\n     debug!(\">> typechecking %s\", fcx.expr_to_str(expr));\n \n     // A generic function to factor out common logic from call and\n@@ -1602,7 +1602,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // returns `none`.\n     fn unpack_expected<O:Copy>(fcx: @mut FnCtxt,\n                                 expected: Option<ty::t>,\n-                                unpack: fn(&ty::sty) -> Option<O>)\n+                                unpack: &fn(&ty::sty) -> Option<O>)\n                              -> Option<O> {\n         match expected {\n             Some(t) => {"}, {"sha": "98f49e48c08491fed70ba22591415b954e9d2a4c", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -30,7 +30,7 @@ pub fn replace_bound_regions_in_fn_sig(\n     isr: isr_alist,\n     self_info: Option<SelfInfo>,\n     fn_sig: &ty::FnSig,\n-    mapf: fn(ty::bound_region) -> ty::Region) ->\n+    mapf: &fn(ty::bound_region) -> ty::Region) ->\n     (isr_alist, Option<SelfInfo>, ty::FnSig) {\n     // Take self_info apart; the self_ty part is the only one we want\n     // to update here.\n@@ -96,7 +96,7 @@ pub fn replace_bound_regions_in_fn_sig(\n         tcx: ty::ctxt,\n         isr: isr_alist,\n         tys: ~[ty::t],\n-        to_r: fn(ty::bound_region) -> ty::Region) -> isr_alist {\n+        to_r: &fn(ty::bound_region) -> ty::Region) -> isr_alist {\n \n         // Takes `isr` (described above), `to_r` (described above),\n         // and `r`, a region.  If `r` is anything other than a bound\n@@ -106,7 +106,7 @@ pub fn replace_bound_regions_in_fn_sig(\n         // updated isr_alist that now contains a mapping from `r` to\n         // the result of calling `to_r` on it.\n         fn append_isr(isr: isr_alist,\n-                      to_r: fn(ty::bound_region) -> ty::Region,\n+                      to_r: &fn(ty::bound_region) -> ty::Region,\n                       r: ty::Region) -> isr_alist {\n             match r {\n               ty::re_free(_, _) | ty::re_static | ty::re_scope(_) |"}, {"sha": "49e5fe617627e09f1c71a4f139815ee573b239c7", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -228,7 +228,7 @@ impl Combine for Glb {\n                 // NB---I do not believe this algorithm computes\n                 // (necessarily) the GLB.  As written it can\n                 // spuriously fail.  In particular, if there is a case\n-                // like: fn(fn(&a)) and fn(fn(&b)), where a and b are\n+                // like: &fn(fn(&a)) and fn(fn(&b)), where a and b are\n                 // free, it will return fn(&c) where c = GLB(a,b).  If\n                 // however this GLB is not defined, then the result is\n                 // an error, even though something like"}, {"sha": "f68a0db63870b9895952c47299f9a6f4165b7f30", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -481,12 +481,12 @@ fn resolve_borrowings(cx: @mut InferCtxt) {\n */\n \n trait then {\n-    fn then<T:Copy>(&self, f: fn() -> Result<T,ty::type_err>)\n+    fn then<T:Copy>(&self, f: &fn() -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err>;\n }\n \n impl then for ures {\n-    fn then<T:Copy>(&self, f: fn() -> Result<T,ty::type_err>)\n+    fn then<T:Copy>(&self, f: &fn() -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err> {\n         self.chain(|_i| f())\n     }\n@@ -506,11 +506,11 @@ impl<T> ToUres for cres<T> {\n }\n \n trait CresCompare<T> {\n-    fn compare(&self, t: T, f: fn() -> ty::type_err) -> cres<T>;\n+    fn compare(&self, t: T, f: &fn() -> ty::type_err) -> cres<T>;\n }\n \n impl<T:Copy + Eq> CresCompare<T> for cres<T> {\n-    fn compare(&self, t: T, f: fn() -> ty::type_err) -> cres<T> {\n+    fn compare(&self, t: T, f: &fn() -> ty::type_err) -> cres<T> {\n         do self.chain |s| {\n             if s == t {\n                 *self\n@@ -584,7 +584,7 @@ pub impl @mut InferCtxt {\n     }\n \n     /// Execute `f` and commit the bindings if successful\n-    fn commit<T,E>(&self, f: fn() -> Result<T,E>) -> Result<T,E> {\n+    fn commit<T,E>(&self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         fail_unless!(!self.in_snapshot());\n \n         debug!(\"commit()\");\n@@ -599,7 +599,7 @@ pub impl @mut InferCtxt {\n     }\n \n     /// Execute `f`, unroll bindings on failure\n-    fn try<T,E>(&self, f: fn() -> Result<T,E>) -> Result<T,E> {\n+    fn try<T,E>(&self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         debug!(\"try()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n@@ -613,7 +613,7 @@ pub impl @mut InferCtxt {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    fn probe<T,E>(&self, f: fn() -> Result<T,E>) -> Result<T,E> {\n+    fn probe<T,E>(&self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         debug!(\"probe()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n@@ -706,7 +706,7 @@ pub impl @mut InferCtxt {\n         }\n     }\n \n-    fn type_error_message(&self, sp: span, mk_msg: fn(~str) -> ~str,\n+    fn type_error_message(&self, sp: span, mk_msg: &fn(~str) -> ~str,\n                           actual_ty: ty::t, err: Option<&ty::type_err>) {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n "}, {"sha": "cceef9fc0c30123e20cc72badc2814ca849bedf1", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -153,7 +153,7 @@ The problem we are addressing is that there is a kind of subtyping\n between functions with bound region parameters.  Consider, for\n example, whether the following relation holds:\n \n-    fn(&a/int) <: fn(&b/int)? (Yes, a => b)\n+    fn(&a/int) <: &fn(&b/int)? (Yes, a => b)\n \n The answer is that of course it does.  These two types are basically\n the same, except that in one we used the name `a` and one we used\n@@ -170,7 +170,7 @@ Now let's consider two more function types.  Here, we assume that the\n `self` lifetime is defined somewhere outside and hence is not a\n lifetime parameter bound by the function type (it \"appears free\"):\n \n-    fn<a>(&a/int) <: fn(&self/int)? (Yes, a => self)\n+    fn<a>(&a/int) <: &fn(&self/int)? (Yes, a => self)\n \n This subtyping relation does in fact hold.  To see why, you have to\n consider what subtyping means.  One way to look at `T1 <: T2` is to\n@@ -187,7 +187,7 @@ to the same thing: a function that accepts pointers with any lifetime\n \n So, what if we reverse the order of the two function types, like this:\n \n-    fn(&self/int) <: fn<a>(&a/int)? (No)\n+    fn(&self/int) <: &fn<a>(&a/int)? (No)\n \n Does the subtyping relationship still hold?  The answer of course is\n no.  In this case, the function accepts *only the lifetime `&self`*,\n@@ -196,8 +196,8 @@ accepted any lifetime.\n \n What about these two examples:\n \n-    fn<a,b>(&a/int, &b/int) <: fn<a>(&a/int, &a/int)? (Yes)\n-    fn<a>(&a/int, &a/int) <: fn<a,b>(&a/int, &b/int)? (No)\n+    fn<a,b>(&a/int, &b/int) <: &fn<a>(&a/int, &a/int)? (Yes)\n+    fn<a>(&a/int, &a/int) <: &fn<a,b>(&a/int, &b/int)? (No)\n \n Here, it is true that functions which take two pointers with any two\n lifetimes can be treated as if they only accepted two pointers with\n@@ -221,12 +221,12 @@ Let's walk through some examples and see how this algorithm plays out.\n \n We'll start with the first example, which was:\n \n-    1. fn<a>(&a/T) <: fn<b>(&b/T)?        Yes: a -> b\n+    1. fn<a>(&a/T) <: &fn<b>(&b/T)?        Yes: a -> b\n \n After steps 1 and 2 of the algorithm we will have replaced the types\n like so:\n \n-    1. fn(&A/T) <: fn(&x/T)?\n+    1. fn(&A/T) <: &fn(&x/T)?\n \n Here the upper case `&A` indicates a *region variable*, that is, a\n region whose value is being inferred by the system.  I also replaced\n@@ -255,12 +255,12 @@ So far we have encountered no error, so the subtype check succeeds.\n \n Now let's look first at the third example, which was:\n \n-    3. fn(&self/T)    <: fn<b>(&b/T)?        No!\n+    3. fn(&self/T)    <: &fn<b>(&b/T)?        No!\n \n After steps 1 and 2 of the algorithm we will have replaced the types\n like so:\n \n-    3. fn(&self/T) <: fn(&x/T)?\n+    3. fn(&self/T) <: &fn(&x/T)?\n \n This looks pretty much the same as before, except that on the LHS\n `&self` was not bound, and hence was left as-is and not replaced with\n@@ -275,7 +275,7 @@ You may be wondering about that mysterious last step in the algorithm.\n So far it has not been relevant.  The purpose of that last step is to\n catch something like *this*:\n \n-    fn<a>() -> fn(&a/T) <: fn() -> fn<b>(&b/T)?   No.\n+    fn<a>() -> fn(&a/T) <: &fn() -> fn<b>(&b/T)?   No.\n \n Here the function types are the same but for where the binding occurs.\n The subtype returns a function that expects a value in precisely one\n@@ -289,15 +289,15 @@ So let's step through what happens when we perform this subtype check.\n We first replace the bound regions in the subtype (the supertype has\n no bound regions).  This gives us:\n \n-    fn() -> fn(&A/T) <: fn() -> fn<b>(&b/T)?\n+    fn() -> fn(&A/T) <: &fn() -> fn<b>(&b/T)?\n \n Now we compare the return types, which are covariant, and hence we have:\n \n-    fn(&A/T) <: fn<b>(&b/T)?\n+    fn(&A/T) <: &fn<b>(&b/T)?\n \n Here we skolemize the bound region in the supertype to yield:\n \n-    fn(&A/T) <: fn(&x/T)?\n+    fn(&A/T) <: &fn(&x/T)?\n \n And then proceed to compare the argument types:\n \n@@ -314,7 +314,7 @@ The difference between this example and the first one is that the variable\n `A` already existed at the point where the skolemization occurred.  In\n the first example, you had two functions:\n \n-    fn<a>(&a/T) <: fn<b>(&b/T)\n+    fn<a>(&a/T) <: &fn<b>(&b/T)\n \n and hence `&A` and `&x` were created \"together\".  In general, the\n intention of the skolemized names is that they are supposed to be\n@@ -1657,7 +1657,7 @@ pub impl RegionVarBindings {\n                  graph: &Graph,\n                  node_idx: RegionVid,\n                  dir: Direction,\n-                 op: fn(edge: &GraphEdge) -> bool) {\n+                 op: &fn(edge: &GraphEdge) -> bool) {\n         let mut edge_idx = graph.nodes[*node_idx].head_edge[dir as uint];\n         while edge_idx != uint::max_value {\n             let edge_ptr = &graph.edges[edge_idx];"}, {"sha": "abaf658a1a43e9159276aeafda08efca46b70ef2", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -225,7 +225,7 @@ pub fn require_same_types(\n     span: span,\n     t1: ty::t,\n     t2: ty::t,\n-    msg: fn() -> ~str) -> bool {\n+    msg: &fn() -> ~str) -> bool {\n \n     let l_tcx, l_infcx;\n     match maybe_infcx {"}, {"sha": "c7945f74f55a54e43803812b340f3e69814cb897", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -17,7 +17,7 @@ use syntax::visit;\n use core::str;\n use std::oldmap::HashMap;\n \n-pub fn indent<R>(op: fn() -> R) -> R {\n+pub fn indent<R>(op: &fn() -> R) -> R {\n     // Use in conjunction with the log post-processor like `src/etc/indenter`\n     // to make debug output more readable.\n     debug!(\">>\");"}, {"sha": "f5cf98759b3752e7671c0e50ded8cc27e178f138", "filename": "src/librustdoc/rustdoc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rc?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -143,7 +143,7 @@ fn run(config: Config) {\n     }\n }\n \n-pub fn time<T>(what: ~str, f: fn() -> T) -> T {\n+pub fn time<T>(what: ~str, f: &fn() -> T) -> T {\n     let start = std::time::precise_time_s();\n     let rv = f();\n     let end = std::time::precise_time_s();"}, {"sha": "0367a771ffbd17b84462eb6bca4ae9b3b59cde06", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -59,7 +59,7 @@ enum CmdAction {\n \n /// A utility function that hands off a pretty printer to a callback.\n fn with_pp(intr: @token::ident_interner,\n-           cb: fn(@pprust::ps, io::Writer)) -> ~str {\n+           cb: &fn(@pprust::ps, io::Writer)) -> ~str {\n     do io::with_str_writer |writer| {\n         let pp = pprust::rust_printer(writer, intr);\n "}, {"sha": "7d2b8eccd6c0e2034b43077d205b8bb05dcadbb7", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -260,7 +260,7 @@ pub fn hash(data: ~str) -> ~str {\n     hasher.result_str()\n }\n \n-pub fn temp_change_dir<T>(dir: &Path, cb: fn() -> T) {\n+pub fn temp_change_dir<T>(dir: &Path, cb: &fn() -> T) {\n     let cwd = os::getcwd();\n \n     os::change_dir(dir);"}, {"sha": "46e6980be581a0c14a73381dc87f9a0debe7afd6", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -176,7 +176,7 @@ pub impl<T:Owned> MutexARC<T> {\n      * blocked on the mutex) will also fail immediately.\n      */\n     #[inline(always)]\n-    unsafe fn access<U>(&self, blk: fn(x: &mut T) -> U) -> U {\n+    unsafe fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n         unsafe {\n             let state = get_shared_mutable_state(&self.x);\n             // Borrowck would complain about this if the function were\n@@ -301,7 +301,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * poison the ARC, so subsequent readers and writers will both also fail.\n      */\n     #[inline(always)]\n-    fn write<U>(&self, blk: fn(x: &mut T) -> U) -> U {\n+    fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n         unsafe {\n             let state = get_shared_mutable_state(&self.x);\n             do (*borrow_rwlock(state)).write {\n@@ -313,7 +313,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n     }\n     /// As write(), but with a condvar, as sync::rwlock.write_cond().\n     #[inline(always)]\n-    fn write_cond<U>(&self, blk: fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n+    fn write_cond<U>(&self, blk: &fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n         unsafe {\n             let state = get_shared_mutable_state(&self.x);\n             do (*borrow_rwlock(state)).write_cond |cond| {\n@@ -335,7 +335,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * Failing will unlock the ARC while unwinding. However, unlike all other\n      * access modes, this will not poison the ARC.\n      */\n-    fn read<U>(&self, blk: fn(x: &T) -> U) -> U {\n+    fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n         let state = unsafe { get_shared_immutable_state(&self.x) };\n         do (&state.lock).read {\n             check_poison(false, state.failed);\n@@ -360,7 +360,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * }\n      * ~~~\n      */\n-    fn write_downgrade<U>(&self, blk: fn(v: RWWriteMode<T>) -> U) -> U {\n+    fn write_downgrade<U>(&self, blk: &fn(v: RWWriteMode<T>) -> U) -> U {\n         unsafe {\n             let state = get_shared_mutable_state(&self.x);\n             do (*borrow_rwlock(state)).write_downgrade |write_mode| {\n@@ -408,7 +408,7 @@ pub enum RWReadMode<T> = (&self/T, sync::RWlockReadMode/&self);\n \n pub impl<T:Const + Owned> RWWriteMode/&self<T> {\n     /// Access the pre-downgrade RWARC in write mode.\n-    fn write<U>(&self, blk: fn(x: &mut T) -> U) -> U {\n+    fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n         match *self {\n             RWWriteMode((ref data, ref token, _)) => {\n                 do token.write {\n@@ -418,7 +418,7 @@ pub impl<T:Const + Owned> RWWriteMode/&self<T> {\n         }\n     }\n     /// Access the pre-downgrade RWARC in write mode with a condvar.\n-    fn write_cond<U>(&self, blk: fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n+    fn write_cond<U>(&self, blk: &fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n         match *self {\n             RWWriteMode((ref data, ref token, ref poison)) => {\n                 do token.write_cond |cond| {\n@@ -438,7 +438,7 @@ pub impl<T:Const + Owned> RWWriteMode/&self<T> {\n \n pub impl<T:Const + Owned> RWReadMode/&self<T> {\n     /// Access the post-downgrade rwlock in read mode.\n-    fn read<U>(&self, blk: fn(x: &T) -> U) -> U {\n+    fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n         match *self {\n             RWReadMode((data, ref token)) => {\n                 do token.read { blk(data) }"}, {"sha": "695b3d01376c3e1cece1cf9907afc218538a8a84", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -201,7 +201,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_pod<T>(&self, op: fn() -> T) -> &self/T {\n+    fn alloc_pod<T>(&self, op: &fn() -> T) -> &self/T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n@@ -246,7 +246,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_nonpod<T>(&self, op: fn() -> T) -> &self/T {\n+    fn alloc_nonpod<T>(&self, op: &fn() -> T) -> &self/T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let (ty_ptr, ptr) =\n@@ -268,7 +268,7 @@ pub impl Arena {\n \n     // The external interface\n     #[inline(always)]\n-    fn alloc<T>(&self, op: fn() -> T) -> &self/T {\n+    fn alloc<T>(&self, op: &fn() -> T) -> &self/T {\n         unsafe {\n             if !rusti::needs_drop::<T>() {\n                 self.alloc_pod(op)"}, {"sha": "8dbdb83698c6f2eb4c80c46e412fd6554e894a68", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -33,7 +33,7 @@ pub impl SmallBitv {\n \n     #[inline(always)]\n     fn bits_op(&mut self, right_bits: uint, nbits: uint,\n-               f: fn(uint, uint) -> uint) -> bool {\n+               f: &fn(uint, uint) -> uint) -> bool {\n         let mask = small_mask(nbits);\n         let old_b: uint = self.bits;\n         let new_b = f(old_b, right_bits);\n@@ -130,7 +130,7 @@ pub impl BigBitv {\n \n     #[inline(always)]\n     fn process(&mut self, b: &BigBitv, nbits: uint,\n-               op: fn(uint, uint) -> uint) -> bool {\n+               op: &fn(uint, uint) -> uint) -> bool {\n         let len = b.storage.len();\n         fail_unless!((self.storage.len() == len));\n         let mut changed = false;\n@@ -148,7 +148,7 @@ pub impl BigBitv {\n     }\n \n     #[inline(always)]\n-    fn each_storage(&mut self, op: fn(v: &mut uint) -> bool) {\n+    fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) {\n         for uint::range(0, self.storage.len()) |i| {\n             let mut w = self.storage[i];\n             let b = op(&mut w);\n@@ -392,7 +392,7 @@ pub impl Bitv {\n     }\n \n     #[inline(always)]\n-    fn each(&self, f: fn(bool) -> bool) {\n+    fn each(&self, f: &fn(bool) -> bool) {\n         let mut i = 0;\n         while i < self.nbits {\n             if !f(self.get(i)) { break; }\n@@ -493,7 +493,7 @@ pub impl Bitv {\n         true\n     }\n \n-    fn ones(&self, f: fn(uint) -> bool) {\n+    fn ones(&self, f: &fn(uint) -> bool) {\n         for uint::range(0, self.nbits) |i| {\n             if self.get(i) {\n                 if !f(i) { break }\n@@ -546,7 +546,7 @@ pub fn from_bools(bools: &[bool]) -> Bitv {\n  * Create a bitv of the specified length where the value at each\n  * index is f(index).\n  */\n-pub fn from_fn(len: uint, f: fn(index: uint) -> bool) -> Bitv {\n+pub fn from_fn(len: uint, f: &fn(index: uint) -> bool) -> Bitv {\n     let mut bitv = Bitv::new(len, false);\n     for uint::range(0, len) |i| {\n         bitv.set(i, f(i));\n@@ -561,7 +561,7 @@ impl ops::Index<uint,bool> for Bitv {\n }\n \n #[inline(always)]\n-pure fn iterate_bits(base: uint, bits: uint, f: fn(uint) -> bool) -> bool {\n+pure fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n     if bits == 0 {\n         return true;\n     }\n@@ -622,7 +622,7 @@ pub impl BitvSet {\n     }\n \n     #[inline(always)]\n-    priv fn other_op(&mut self, other: &BitvSet, f: fn(uint, uint) -> uint) {\n+    priv fn other_op(&mut self, other: &BitvSet, f: &fn(uint, uint) -> uint) {\n         fn nbits(mut w: uint) -> uint {\n             let mut bits = 0;\n             for uint::bits.times {\n@@ -669,7 +669,7 @@ pub impl BitvSet {\n impl BaseIter<uint> for BitvSet {\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n \n-    pure fn each(&self, blk: fn(v: &uint) -> bool) {\n+    pure fn each(&self, blk: &fn(v: &uint) -> bool) {\n         for self.bitv.storage.eachi |i, &w| {\n             if !iterate_bits(i * uint::bits, w, |b| blk(&b)) {\n                 return;\n@@ -778,7 +778,7 @@ impl Set<uint> for BitvSet {\n         other.is_subset(self)\n     }\n \n-    pure fn difference(&self, other: &BitvSet, f: fn(&uint) -> bool) {\n+    pure fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n                 return;\n@@ -791,7 +791,7 @@ impl Set<uint> for BitvSet {\n     }\n \n     pure fn symmetric_difference(&self, other: &BitvSet,\n-                                 f: fn(&uint) -> bool) {\n+                                 f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n                 return;\n@@ -802,15 +802,15 @@ impl Set<uint> for BitvSet {\n         );\n     }\n \n-    pure fn intersection(&self, other: &BitvSet, f: fn(&uint) -> bool) {\n+    pure fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 & w2, |b| f(&b)) {\n                 return;\n             }\n         }\n     }\n \n-    pure fn union(&self, other: &BitvSet, f: fn(&uint) -> bool) {\n+    pure fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n                 return;\n@@ -828,7 +828,7 @@ priv impl BitvSet {\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n     pure fn each_common(&self, other: &BitvSet,\n-                        f: fn(uint, uint, uint) -> bool) {\n+                        f: &fn(uint, uint, uint) -> bool) {\n         let min = uint::min(self.bitv.storage.len(),\n                             other.bitv.storage.len());\n         for self.bitv.storage.view(0, min).eachi |i, &w| {\n@@ -846,7 +846,7 @@ priv impl BitvSet {\n     /// is true if the word comes from 'self', and false if it comes from\n     /// 'other'.\n     pure fn each_outlier(&self, other: &BitvSet,\n-                         f: fn(bool, uint, uint) -> bool) {\n+                         f: &fn(bool, uint, uint) -> bool) {\n         let len1 = self.bitv.storage.len();\n         let len2 = other.bitv.storage.len();\n         let min = uint::min(len1, len2);"}, {"sha": "a55d4bc97ec560bc0c2a509e7c172c8e08d5e839", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -142,7 +142,7 @@ pub mod reader {\n         }\n     }\n \n-    pub fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n+    pub fn docs(d: Doc, it: &fn(uint, Doc) -> bool) {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = vuint_at(*d.data, pos);\n@@ -155,7 +155,7 @@ pub mod reader {\n         }\n     }\n \n-    pub fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n+    pub fn tagged_docs(d: Doc, tg: uint, it: &fn(Doc) -> bool) {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = vuint_at(*d.data, pos);\n@@ -175,7 +175,7 @@ pub mod reader {\n         vec::slice::<u8>(*d.data, d.start, d.end).to_vec()\n     }\n \n-    pub fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n+    pub fn with_doc_data<T>(d: Doc, f: &fn(x: &[u8]) -> T) -> T {\n         f(vec::slice(*d.data, d.start, d.end))\n     }\n \n@@ -255,7 +255,7 @@ pub mod reader {\n             r_doc\n         }\n \n-        fn push_doc<T>(&self, d: Doc, f: fn() -> T) -> T {\n+        fn push_doc<T>(&self, d: Doc, f: &fn() -> T) -> T {\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n             self.parent = d;\n@@ -274,7 +274,7 @@ pub mod reader {\n     }\n \n     pub impl Decoder {\n-        fn read_opaque<R>(&self, op: fn(Doc) -> R) -> R {\n+        fn read_opaque<R>(&self, op: &fn(Doc) -> R) -> R {\n             do self.push_doc(self.next_doc(EsOpaque)) {\n                 op(copy self.parent)\n             }\n@@ -321,23 +321,23 @@ pub mod reader {\n         fn read_managed_str(&self) -> @str { fail!(~\"read_managed_str()\"); }\n \n         // Compound types:\n-        fn read_owned<T>(&self, f: fn() -> T) -> T {\n+        fn read_owned<T>(&self, f: &fn() -> T) -> T {\n             debug!(\"read_owned()\");\n             f()\n         }\n \n-        fn read_managed<T>(&self, f: fn() -> T) -> T {\n+        fn read_managed<T>(&self, f: &fn() -> T) -> T {\n             debug!(\"read_managed()\");\n             f()\n         }\n \n-        fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T {\n+        fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T {\n             debug!(\"read_enum(%s)\", name);\n             self._check_label(name);\n             self.push_doc(self.next_doc(EsEnum), f)\n         }\n \n-        fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T {\n+        fn read_enum_variant<T>(&self, f: &fn(uint) -> T) -> T {\n             debug!(\"read_enum_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n             debug!(\"  idx=%u\", idx);\n@@ -346,12 +346,12 @@ pub mod reader {\n             }\n         }\n \n-        fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T {\n+        fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n             debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n             f()\n         }\n \n-        fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T {\n+        fn read_owned_vec<T>(&self, f: &fn(uint) -> T) -> T {\n             debug!(\"read_owned_vec()\");\n             do self.push_doc(self.next_doc(EsVec)) {\n                 let len = self._next_uint(EsVecLen);\n@@ -360,7 +360,7 @@ pub mod reader {\n             }\n         }\n \n-        fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n+        fn read_managed_vec<T>(&self, f: &fn(uint) -> T) -> T {\n             debug!(\"read_managed_vec()\");\n             do self.push_doc(self.next_doc(EsVec)) {\n                 let len = self._next_uint(EsVecLen);\n@@ -369,33 +369,33 @@ pub mod reader {\n             }\n         }\n \n-        fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+        fn read_vec_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n             debug!(\"read_vec_elt(idx=%u)\", idx);\n             self.push_doc(self.next_doc(EsVecElt), f)\n         }\n \n-        fn read_rec<T>(&self, f: fn() -> T) -> T {\n+        fn read_rec<T>(&self, f: &fn() -> T) -> T {\n             debug!(\"read_rec()\");\n             f()\n         }\n \n-        fn read_struct<T>(&self, name: &str, _len: uint, f: fn() -> T) -> T {\n+        fn read_struct<T>(&self, name: &str, _len: uint, f: &fn() -> T) -> T {\n             debug!(\"read_struct(name=%s)\", name);\n             f()\n         }\n \n-        fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n+        fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n             debug!(\"read_field(name=%s, idx=%u)\", name, idx);\n             self._check_label(name);\n             f()\n         }\n \n-        fn read_tup<T>(&self, len: uint, f: fn() -> T) -> T {\n+        fn read_tup<T>(&self, len: uint, f: &fn() -> T) -> T {\n             debug!(\"read_tup(len=%u)\", len);\n             f()\n         }\n \n-        fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+        fn read_tup_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n             debug!(\"read_tup_elt(idx=%u)\", idx);\n             f()\n         }\n@@ -469,7 +469,7 @@ pub mod writer {\n             debug!(\"End tag (size = %u)\", size);\n         }\n \n-        fn wr_tag(&self, tag_id: uint, blk: fn()) {\n+        fn wr_tag(&self, tag_id: uint, blk: &fn()) {\n             self.start_tag(tag_id);\n             blk();\n             self.end_tag();\n@@ -566,7 +566,7 @@ pub mod writer {\n     }\n \n     pub impl Encoder {\n-        fn emit_opaque(&self, f: fn()) {\n+        fn emit_opaque(&self, f: &fn()) {\n             do self.wr_tag(EsOpaque as uint) {\n                 f()\n             }\n@@ -623,49 +623,49 @@ pub mod writer {\n             self.emit_borrowed_str(v)\n         }\n \n-        fn emit_borrowed(&self, f: fn()) { f() }\n-        fn emit_owned(&self, f: fn()) { f() }\n-        fn emit_managed(&self, f: fn()) { f() }\n+        fn emit_borrowed(&self, f: &fn()) { f() }\n+        fn emit_owned(&self, f: &fn()) { f() }\n+        fn emit_managed(&self, f: &fn()) { f() }\n \n-        fn emit_enum(&self, name: &str, f: fn()) {\n+        fn emit_enum(&self, name: &str, f: &fn()) {\n             self._emit_label(name);\n             self.wr_tag(EsEnum as uint, f)\n         }\n         fn emit_enum_variant(&self, _v_name: &str, v_id: uint, _cnt: uint,\n-                             f: fn()) {\n+                             f: &fn()) {\n             self._emit_tagged_uint(EsEnumVid, v_id);\n             self.wr_tag(EsEnumBody as uint, f)\n         }\n-        fn emit_enum_variant_arg(&self, _idx: uint, f: fn()) { f() }\n+        fn emit_enum_variant_arg(&self, _idx: uint, f: &fn()) { f() }\n \n-        fn emit_borrowed_vec(&self, len: uint, f: fn()) {\n+        fn emit_borrowed_vec(&self, len: uint, f: &fn()) {\n             do self.wr_tag(EsVec as uint) {\n                 self._emit_tagged_uint(EsVecLen, len);\n                 f()\n             }\n         }\n \n-        fn emit_owned_vec(&self, len: uint, f: fn()) {\n+        fn emit_owned_vec(&self, len: uint, f: &fn()) {\n             self.emit_borrowed_vec(len, f)\n         }\n \n-        fn emit_managed_vec(&self, len: uint, f: fn()) {\n+        fn emit_managed_vec(&self, len: uint, f: &fn()) {\n             self.emit_borrowed_vec(len, f)\n         }\n \n-        fn emit_vec_elt(&self, _idx: uint, f: fn()) {\n+        fn emit_vec_elt(&self, _idx: uint, f: &fn()) {\n             self.wr_tag(EsVecElt as uint, f)\n         }\n \n-        fn emit_rec(&self, f: fn()) { f() }\n-        fn emit_struct(&self, _name: &str, _len: uint, f: fn()) { f() }\n-        fn emit_field(&self, name: &str, _idx: uint, f: fn()) {\n+        fn emit_rec(&self, f: &fn()) { f() }\n+        fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) { f() }\n+        fn emit_field(&self, name: &str, _idx: uint, f: &fn()) {\n             self._emit_label(name);\n             f()\n         }\n \n-        fn emit_tup(&self, _len: uint, f: fn()) { f() }\n-        fn emit_tup_elt(&self, _idx: uint, f: fn()) { f() }\n+        fn emit_tup(&self, _len: uint, f: &fn()) { f() }\n+        fn emit_tup_elt(&self, _idx: uint, f: &fn()) { f() }\n     }\n \n }"}, {"sha": "735f86b34eca7c5a911f8f6d154027f71594f467", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -61,7 +61,7 @@ pub fn find<K:Eq + Ord,V:Copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n }\n \n /// Visit all pairs in the map in order.\n-pub fn traverse<K, V: Copy>(m: Treemap<K, V>, f: fn(&K, &V)) {\n+pub fn traverse<K, V: Copy>(m: Treemap<K, V>, f: &fn(&K, &V)) {\n     match *m {\n       Empty => (),\n       /*"}, {"sha": "8c6a870b98cd4e3fc3e760f6230a28e07b2e37cc", "filename": "src/libstd/json.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -116,15 +116,15 @@ impl serialize::Encoder for Encoder {\n     fn emit_owned_str(&self, v: &str) { self.emit_borrowed_str(v) }\n     fn emit_managed_str(&self, v: &str) { self.emit_borrowed_str(v) }\n \n-    fn emit_borrowed(&self, f: fn()) { f() }\n-    fn emit_owned(&self, f: fn()) { f() }\n-    fn emit_managed(&self, f: fn()) { f() }\n+    fn emit_borrowed(&self, f: &fn()) { f() }\n+    fn emit_owned(&self, f: &fn()) { f() }\n+    fn emit_managed(&self, f: &fn()) { f() }\n \n-    fn emit_enum(&self, _name: &str, f: fn()) {\n+    fn emit_enum(&self, _name: &str, f: &fn()) {\n         f()\n     }\n \n-    fn emit_enum_variant(&self, name: &str, _id: uint, _cnt: uint, f: fn()) {\n+    fn emit_enum_variant(&self, name: &str, _id: uint, _cnt: uint, f: &fn()) {\n         // encoding of enums is special-cased for Option. Specifically:\n         // Some(34) => 34\n         // None => null\n@@ -160,49 +160,49 @@ impl serialize::Encoder for Encoder {\n         }\n     }\n \n-    fn emit_enum_variant_arg(&self, idx: uint, f: fn()) {\n+    fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n         if (idx != 0) {self.wr.write_char(',');}\n         f();\n     }\n \n-    fn emit_borrowed_vec(&self, _len: uint, f: fn()) {\n+    fn emit_borrowed_vec(&self, _len: uint, f: &fn()) {\n         self.wr.write_char('[');\n         f();\n         self.wr.write_char(']');\n     }\n \n-    fn emit_owned_vec(&self, len: uint, f: fn()) {\n+    fn emit_owned_vec(&self, len: uint, f: &fn()) {\n         self.emit_borrowed_vec(len, f)\n     }\n-    fn emit_managed_vec(&self, len: uint, f: fn()) {\n+    fn emit_managed_vec(&self, len: uint, f: &fn()) {\n         self.emit_borrowed_vec(len, f)\n     }\n-    fn emit_vec_elt(&self, idx: uint, f: fn()) {\n+    fn emit_vec_elt(&self, idx: uint, f: &fn()) {\n         if idx != 0 { self.wr.write_char(','); }\n         f()\n     }\n \n-    fn emit_rec(&self, f: fn()) {\n+    fn emit_rec(&self, f: &fn()) {\n         self.wr.write_char('{');\n         f();\n         self.wr.write_char('}');\n     }\n-    fn emit_struct(&self, _name: &str, _len: uint, f: fn()) {\n+    fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) {\n         self.wr.write_char('{');\n         f();\n         self.wr.write_char('}');\n     }\n-    fn emit_field(&self, name: &str, idx: uint, f: fn()) {\n+    fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx != 0 { self.wr.write_char(','); }\n         self.wr.write_str(escape_str(name));\n         self.wr.write_char(':');\n         f();\n     }\n \n-    fn emit_tup(&self, len: uint, f: fn()) {\n+    fn emit_tup(&self, len: uint, f: &fn()) {\n         self.emit_borrowed_vec(len, f);\n     }\n-    fn emit_tup_elt(&self, idx: uint, f: fn()) {\n+    fn emit_tup_elt(&self, idx: uint, f: &fn()) {\n         self.emit_vec_elt(idx, f)\n     }\n }\n@@ -251,39 +251,39 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_owned_str(&self, v: &str) { self.emit_borrowed_str(v) }\n     fn emit_managed_str(&self, v: &str) { self.emit_borrowed_str(v) }\n \n-    fn emit_borrowed(&self, f: fn()) { f() }\n-    fn emit_owned(&self, f: fn()) { f() }\n-    fn emit_managed(&self, f: fn()) { f() }\n+    fn emit_borrowed(&self, f: &fn()) { f() }\n+    fn emit_owned(&self, f: &fn()) { f() }\n+    fn emit_managed(&self, f: &fn()) { f() }\n \n-    fn emit_enum(&self, name: &str, f: fn()) {\n+    fn emit_enum(&self, name: &str, f: &fn()) {\n         if name != \"option\" { fail!(~\"only supports option enum\") }\n         f()\n     }\n-    fn emit_enum_variant(&self, _name: &str, id: uint, _cnt: uint, f: fn()) {\n+    fn emit_enum_variant(&self, _name: &str, id: uint, _cnt: uint, f: &fn()) {\n         if id == 0 {\n             self.emit_nil();\n         } else {\n             f()\n         }\n     }\n-    fn emit_enum_variant_arg(&self, _idx: uint, f: fn()) {\n+    fn emit_enum_variant_arg(&self, _idx: uint, f: &fn()) {\n         f()\n     }\n \n-    fn emit_borrowed_vec(&self, _len: uint, f: fn()) {\n+    fn emit_borrowed_vec(&self, _len: uint, f: &fn()) {\n         self.wr.write_char('[');\n         self.indent += 2;\n         f();\n         self.indent -= 2;\n         self.wr.write_char(']');\n     }\n-    fn emit_owned_vec(&self, len: uint, f: fn()) {\n+    fn emit_owned_vec(&self, len: uint, f: &fn()) {\n         self.emit_borrowed_vec(len, f)\n     }\n-    fn emit_managed_vec(&self, len: uint, f: fn()) {\n+    fn emit_managed_vec(&self, len: uint, f: &fn()) {\n         self.emit_borrowed_vec(len, f)\n     }\n-    fn emit_vec_elt(&self, idx: uint, f: fn()) {\n+    fn emit_vec_elt(&self, idx: uint, f: &fn()) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n         } else {\n@@ -293,17 +293,17 @@ impl serialize::Encoder for PrettyEncoder {\n         f()\n     }\n \n-    fn emit_rec(&self, f: fn()) {\n+    fn emit_rec(&self, f: &fn()) {\n         self.wr.write_char('{');\n         self.indent += 2;\n         f();\n         self.indent -= 2;\n         self.wr.write_char('}');\n     }\n-    fn emit_struct(&self, _name: &str, _len: uint, f: fn()) {\n+    fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) {\n         self.emit_rec(f)\n     }\n-    fn emit_field(&self, name: &str, idx: uint, f: fn()) {\n+    fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n         } else {\n@@ -314,10 +314,10 @@ impl serialize::Encoder for PrettyEncoder {\n         self.wr.write_str(\": \");\n         f();\n     }\n-    fn emit_tup(&self, sz: uint, f: fn()) {\n+    fn emit_tup(&self, sz: uint, f: &fn()) {\n         self.emit_borrowed_vec(sz, f);\n     }\n-    fn emit_tup_elt(&self, idx: uint, f: fn()) {\n+    fn emit_tup_elt(&self, idx: uint, f: &fn()) {\n         self.emit_vec_elt(idx, f)\n     }\n }\n@@ -828,23 +828,23 @@ impl serialize::Decoder for Decoder/&self {\n         }\n     }\n \n-    fn read_owned<T>(&self, f: fn() -> T) -> T {\n+    fn read_owned<T>(&self, f: &fn() -> T) -> T {\n         debug!(\"read_owned()\");\n         f()\n     }\n \n-    fn read_managed<T>(&self, f: fn() -> T) -> T {\n+    fn read_managed<T>(&self, f: &fn() -> T) -> T {\n         debug!(\"read_managed()\");\n         f()\n     }\n \n-    fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T {\n+    fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T {\n         debug!(\"read_enum(%s)\", name);\n         if name != ~\"option\" { fail!(~\"only supports the option enum\") }\n         f()\n     }\n \n-    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T {\n+    fn read_enum_variant<T>(&self, f: &fn(uint) -> T) -> T {\n         debug!(\"read_enum_variant()\");\n         let idx = match *self.peek() {\n             Null => 0,\n@@ -853,13 +853,13 @@ impl serialize::Decoder for Decoder/&self {\n         f(idx)\n     }\n \n-    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T {\n+    fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n         debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n         if idx != 0 { fail!(~\"unknown index\") }\n         f()\n     }\n \n-    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T {\n+    fn read_owned_vec<T>(&self, f: &fn(uint) -> T) -> T {\n         debug!(\"read_owned_vec()\");\n         let len = match *self.peek() {\n             List(ref list) => list.len(),\n@@ -870,7 +870,7 @@ impl serialize::Decoder for Decoder/&self {\n         res\n     }\n \n-    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n+    fn read_managed_vec<T>(&self, f: &fn(uint) -> T) -> T {\n         debug!(\"read_owned_vec()\");\n         let len = match *self.peek() {\n             List(ref list) => list.len(),\n@@ -881,7 +881,7 @@ impl serialize::Decoder for Decoder/&self {\n         res\n     }\n \n-    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+    fn read_vec_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n         debug!(\"read_vec_elt(idx=%u)\", idx);\n         match *self.peek() {\n             List(ref list) => {\n@@ -892,21 +892,21 @@ impl serialize::Decoder for Decoder/&self {\n         }\n     }\n \n-    fn read_rec<T>(&self, f: fn() -> T) -> T {\n+    fn read_rec<T>(&self, f: &fn() -> T) -> T {\n         debug!(\"read_rec()\");\n         let value = f();\n         self.pop();\n         value\n     }\n \n-    fn read_struct<T>(&self, _name: &str, _len: uint, f: fn() -> T) -> T {\n+    fn read_struct<T>(&self, _name: &str, _len: uint, f: &fn() -> T) -> T {\n         debug!(\"read_struct()\");\n         let value = f();\n         self.pop();\n         value\n     }\n \n-    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n+    fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n         debug!(\"read_rec_field(%s, idx=%u)\", name, idx);\n         let top = self.peek();\n         match *top {\n@@ -929,14 +929,14 @@ impl serialize::Decoder for Decoder/&self {\n         }\n     }\n \n-    fn read_tup<T>(&self, len: uint, f: fn() -> T) -> T {\n+    fn read_tup<T>(&self, len: uint, f: &fn() -> T) -> T {\n         debug!(\"read_tup(len=%u)\", len);\n         let value = f();\n         self.pop();\n         value\n     }\n \n-    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+    fn read_tup_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n         debug!(\"read_tup_elt(idx=%u)\", idx);\n         match *self.peek() {\n             List(ref list) => {"}, {"sha": "3a0f299257e096d408890f7a318be6ea8e2bff06", "filename": "src/libstd/list.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -39,7 +39,7 @@ pub pure fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n  * * z - The initial value\n  * * f - The function to apply\n  */\n-pub fn foldl<T:Copy,U>(z: T, ls: @List<U>, f: fn(&T, &U) -> T) -> T {\n+pub fn foldl<T:Copy,U>(z: T, ls: @List<U>, f: &fn(&T, &U) -> T) -> T {\n     let mut accum: T = z;\n     do iter(ls) |elt| { accum = f(&accum, elt);}\n     accum\n@@ -52,7 +52,7 @@ pub fn foldl<T:Copy,U>(z: T, ls: @List<U>, f: fn(&T, &U) -> T) -> T {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pub pure fn find<T:Copy>(ls: @List<T>, f: fn(&T) -> bool) -> Option<T> {\n+pub pure fn find<T:Copy>(ls: @List<T>, f: &fn(&T) -> bool) -> Option<T> {\n     let mut ls = ls;\n     loop {\n         ls = match *ls {\n@@ -125,7 +125,7 @@ pure fn push<T:Copy>(ll: &mut @list<T>, vv: T) {\n */\n \n /// Iterate over a list\n-pub pure fn iter<T>(l: @List<T>, f: fn(&T)) {\n+pub pure fn iter<T>(l: @List<T>, f: &fn(&T)) {\n     let mut cur = l;\n     loop {\n         cur = match *cur {\n@@ -139,7 +139,7 @@ pub pure fn iter<T>(l: @List<T>, f: fn(&T)) {\n }\n \n /// Iterate over a list\n-pub pure fn each<T>(l: @List<T>, f: fn(&T) -> bool) {\n+pub pure fn each<T>(l: @List<T>, f: &fn(&T) -> bool) {\n     let mut cur = l;\n     loop {\n         cur = match *cur {"}, {"sha": "df254543512b0833af14c0e3b8e586920749a011", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -105,7 +105,7 @@ pub pure fn md4(msg: &[u8]) -> Quad {\n \n pub pure fn md4_str(msg: &[u8]) -> ~str {\n     let Quad {a, b, c, d} = md4(msg);\n-    pure fn app(a: u32, b: u32, c: u32, d: u32, f: fn(u32)) {\n+    pure fn app(a: u32, b: u32, c: u32, d: u32, f: &fn(u32)) {\n         f(a); f(b); f(c); f(d);\n     }\n     let mut result = ~\"\";"}, {"sha": "18527cfece111499e91d9f77bb64eea449574f11", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -134,7 +134,7 @@ pub mod chained {\n     }\n \n     pub impl<K:Eq + IterBytes + Hash,V> T<K, V> {\n-        pure fn each_entry(&self, blk: fn(@Entry<K,V>) -> bool) {\n+        pure fn each_entry(&self, blk: &fn(@Entry<K,V>) -> bool) {\n             // n.b. we can't use vec::iter() here because self.chains\n             // is stored in a mutable location.\n             let mut i = 0u, n = self.chains.len();\n@@ -236,17 +236,17 @@ pub mod chained {\n             }\n         }\n \n-        pure fn each(&self, blk: fn(key: &K, value: &V) -> bool) {\n+        pure fn each(&self, blk: &fn(key: &K, value: &V) -> bool) {\n             for self.each_entry |entry| {\n                 if !blk(&entry.key, &entry.value) { break; }\n             }\n         }\n \n-        pure fn each_key(&self, blk: fn(key: &K) -> bool) {\n+        pure fn each_key(&self, blk: &fn(key: &K) -> bool) {\n             self.each(|k, _v| blk(k))\n         }\n \n-        pure fn each_value(&self, blk: fn(value: &V) -> bool) {\n+        pure fn each_value(&self, blk: &fn(value: &V) -> bool) {\n             self.each(|_k, v| blk(v))\n         }\n     }\n@@ -260,8 +260,8 @@ pub mod chained {\n             }\n         }\n \n-        fn update_with_key(&self, key: K, newval: V, ff: fn(K, V, V) -> V)\n-                          -> bool {\n+        fn update_with_key(&self, key: K, newval: V, ff: &fn(K, V, V) -> V)\n+                        -> bool {\n /*\n             match self.find(key) {\n                 None            => return self.insert(key, val),\n@@ -312,7 +312,7 @@ pub mod chained {\n             }\n         }\n \n-        fn update(&self, key: K, newval: V, ff: fn(V, V) -> V) -> bool {\n+        fn update(&self, key: K, newval: V, ff: &fn(V, V) -> V) -> bool {\n             return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n         }\n "}, {"sha": "d2d80eb7da80311f8263e380863b5f02a427f23f", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -98,87 +98,87 @@ impl serialize::Encoder for Serializer {\n         self.wr.write_str(fmt!(\"@%?\", v));\n     }\n \n-    fn emit_borrowed(&self, f: fn()) {\n+    fn emit_borrowed(&self, f: &fn()) {\n         self.wr.write_str(~\"&\");\n         f();\n     }\n \n-    fn emit_owned(&self, f: fn()) {\n+    fn emit_owned(&self, f: &fn()) {\n         self.wr.write_str(~\"~\");\n         f();\n     }\n \n-    fn emit_managed(&self, f: fn()) {\n+    fn emit_managed(&self, f: &fn()) {\n         self.wr.write_str(~\"@\");\n         f();\n     }\n \n-    fn emit_enum(&self, _name: &str, f: fn()) {\n+    fn emit_enum(&self, _name: &str, f: &fn()) {\n         f();\n     }\n \n     fn emit_enum_variant(&self, v_name: &str, _v_id: uint, sz: uint,\n-                         f: fn()) {\n+                         f: &fn()) {\n         self.wr.write_str(v_name);\n         if sz > 0u { self.wr.write_str(~\"(\"); }\n         f();\n         if sz > 0u { self.wr.write_str(~\")\"); }\n     }\n \n-    fn emit_enum_variant_arg(&self, idx: uint, f: fn()) {\n+    fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n         if idx > 0u { self.wr.write_str(~\", \"); }\n         f();\n     }\n \n-    fn emit_borrowed_vec(&self, _len: uint, f: fn()) {\n+    fn emit_borrowed_vec(&self, _len: uint, f: &fn()) {\n         self.wr.write_str(~\"&[\");\n         f();\n         self.wr.write_str(~\"]\");\n     }\n \n-    fn emit_owned_vec(&self, _len: uint, f: fn()) {\n+    fn emit_owned_vec(&self, _len: uint, f: &fn()) {\n         self.wr.write_str(~\"~[\");\n         f();\n         self.wr.write_str(~\"]\");\n     }\n \n-    fn emit_managed_vec(&self, _len: uint, f: fn()) {\n+    fn emit_managed_vec(&self, _len: uint, f: &fn()) {\n         self.wr.write_str(~\"@[\");\n         f();\n         self.wr.write_str(~\"]\");\n     }\n \n-    fn emit_vec_elt(&self, idx: uint, f: fn()) {\n+    fn emit_vec_elt(&self, idx: uint, f: &fn()) {\n         if idx > 0u { self.wr.write_str(~\", \"); }\n         f();\n     }\n \n-    fn emit_rec(&self, f: fn()) {\n+    fn emit_rec(&self, f: &fn()) {\n         self.wr.write_str(~\"{\");\n         f();\n         self.wr.write_str(~\"}\");\n     }\n \n-    fn emit_struct(&self, name: &str, _len: uint, f: fn()) {\n+    fn emit_struct(&self, name: &str, _len: uint, f: &fn()) {\n         self.wr.write_str(fmt!(\"%s {\", name));\n         f();\n         self.wr.write_str(~\"}\");\n     }\n \n-    fn emit_field(&self, name: &str, idx: uint, f: fn()) {\n+    fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx > 0u { self.wr.write_str(~\", \"); }\n         self.wr.write_str(name);\n         self.wr.write_str(~\": \");\n         f();\n     }\n \n-    fn emit_tup(&self, _len: uint, f: fn()) {\n+    fn emit_tup(&self, _len: uint, f: &fn()) {\n         self.wr.write_str(~\"(\");\n         f();\n         self.wr.write_str(~\")\");\n     }\n \n-    fn emit_tup_elt(&self, idx: uint, f: fn()) {\n+    fn emit_tup_elt(&self, idx: uint, f: &fn()) {\n         if idx > 0u { self.wr.write_str(~\", \"); }\n         f();\n     }"}, {"sha": "31f29ce23f2cda84027826d45ae9b165ade969c5", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -31,7 +31,7 @@ impl<T:Ord> BaseIter<T> for PriorityQueue<T> {\n     /// Visit all values in the underlying vector.\n     ///\n     /// The values are **not** visited in order.\n-    pure fn each(&self, f: fn(&T) -> bool) { self.data.each(f) }\n+    pure fn each(&self, f: &fn(&T) -> bool) { self.data.each(f) }\n     pure fn size_hint(&self) -> Option<uint> { self.data.size_hint() }\n }\n "}, {"sha": "dd2f5b58fb96a20a8b07455f6ca5a2179f056dfe", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -393,7 +393,7 @@ Section: Iterating\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-pub fn loop_chars(rope: Rope, it: fn(c: char) -> bool) -> bool {\n+pub fn loop_chars(rope: Rope, it: &fn(c: char) -> bool) -> bool {\n    match (rope) {\n       node::Empty => return true,\n       node::Content(x) => return node::loop_chars(x, it)\n@@ -407,7 +407,7 @@ pub fn loop_chars(rope: Rope, it: fn(c: char) -> bool) -> bool {\n  * * rope - A rope to traverse. It may be empty\n  * * it - A block to execute with each consecutive character of the rope.\n  */\n-pub fn iter_chars(rope: Rope, it: fn(char)) {\n+pub fn iter_chars(rope: Rope, it: &fn(char)) {\n     do loop_chars(rope) |x| {\n         it(x);\n         true\n@@ -436,7 +436,7 @@ pub fn iter_chars(rope: Rope, it: fn(char)) {\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-pub fn loop_leaves(rope: Rope, it: fn(node::Leaf) -> bool) -> bool{\n+pub fn loop_leaves(rope: Rope, it: &fn(node::Leaf) -> bool) -> bool{\n    match (rope) {\n       node::Empty => return true,\n       node::Content(x) => return node::loop_leaves(x, it)\n@@ -1078,7 +1078,7 @@ pub mod node {\n         return result;\n     }\n \n-    pub fn loop_chars(node: @Node, it: fn(c: char) -> bool) -> bool {\n+    pub fn loop_chars(node: @Node, it: &fn(c: char) -> bool) -> bool {\n         return loop_leaves(node,|leaf| {\n             str::all_between(*leaf.content,\n                              leaf.byte_offset,\n@@ -1100,7 +1100,7 @@ pub mod node {\n      * `true` If execution proceeded correctly, `false` if it was interrupted,\n      * that is if `it` returned `false` at any point.\n      */\n-    pub fn loop_leaves(node: @Node, it: fn(Leaf) -> bool) -> bool{\n+    pub fn loop_leaves(node: @Node, it: &fn(Leaf) -> bool) -> bool{\n         let mut current = node;\n         loop {\n             match (*current) {"}, {"sha": "7b8a06f1b93afe42bdaf7d3cd0d365d7a62c2902", "filename": "src/libstd/semver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsemver.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -140,7 +140,7 @@ condition! {\n \n fn take_nonempty_prefix(rdr: io::Reader,\n                         ch: char,\n-                        pred: fn(char) -> bool) -> (~str, char) {\n+                        pred: &fn(char) -> bool) -> (~str, char) {\n     let mut buf = ~\"\";\n     let mut ch = ch;\n     while pred(ch) {"}, {"sha": "0288155d29ebd73d83d0f239ff019eeda24f5447", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -43,25 +43,25 @@ pub trait Encoder {\n     fn emit_managed_str(&self, v: &str);\n \n     // Compound types:\n-    fn emit_borrowed(&self, f: fn());\n-    fn emit_owned(&self, f: fn());\n-    fn emit_managed(&self, f: fn());\n+    fn emit_borrowed(&self, f: &fn());\n+    fn emit_owned(&self, f: &fn());\n+    fn emit_managed(&self, f: &fn());\n \n-    fn emit_enum(&self, name: &str, f: fn());\n-    fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: fn());\n-    fn emit_enum_variant_arg(&self, idx: uint, f: fn());\n+    fn emit_enum(&self, name: &str, f: &fn());\n+    fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: &fn());\n+    fn emit_enum_variant_arg(&self, idx: uint, f: &fn());\n \n-    fn emit_borrowed_vec(&self, len: uint, f: fn());\n-    fn emit_owned_vec(&self, len: uint, f: fn());\n-    fn emit_managed_vec(&self, len: uint, f: fn());\n-    fn emit_vec_elt(&self, idx: uint, f: fn());\n+    fn emit_borrowed_vec(&self, len: uint, f: &fn());\n+    fn emit_owned_vec(&self, len: uint, f: &fn());\n+    fn emit_managed_vec(&self, len: uint, f: &fn());\n+    fn emit_vec_elt(&self, idx: uint, f: &fn());\n \n-    fn emit_rec(&self, f: fn());\n-    fn emit_struct(&self, name: &str, _len: uint, f: fn());\n-    fn emit_field(&self, f_name: &str, f_idx: uint, f: fn());\n+    fn emit_rec(&self, f: &fn());\n+    fn emit_struct(&self, name: &str, _len: uint, f: &fn());\n+    fn emit_field(&self, f_name: &str, f_idx: uint, f: &fn());\n \n-    fn emit_tup(&self, len: uint, f: fn());\n-    fn emit_tup_elt(&self, idx: uint, f: fn());\n+    fn emit_tup(&self, len: uint, f: &fn());\n+    fn emit_tup_elt(&self, idx: uint, f: &fn());\n }\n \n pub trait Decoder {\n@@ -86,23 +86,23 @@ pub trait Decoder {\n     fn read_managed_str(&self) -> @str;\n \n     // Compound types:\n-    fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T;\n-    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T;\n-    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T;\n+    fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T;\n+    fn read_enum_variant<T>(&self, f: &fn(uint) -> T) -> T;\n+    fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T;\n \n-    fn read_owned<T>(&self, f: fn() -> T) -> T;\n-    fn read_managed<T>(&self, f: fn() -> T) -> T;\n+    fn read_owned<T>(&self, f: &fn() -> T) -> T;\n+    fn read_managed<T>(&self, f: &fn() -> T) -> T;\n \n-    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T;\n-    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T;\n-    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n+    fn read_owned_vec<T>(&self, f: &fn(uint) -> T) -> T;\n+    fn read_managed_vec<T>(&self, f: &fn(uint) -> T) -> T;\n+    fn read_vec_elt<T>(&self, idx: uint, f: &fn() -> T) -> T;\n \n-    fn read_rec<T>(&self, f: fn() -> T) -> T;\n-    fn read_struct<T>(&self, name: &str, _len: uint, f: fn() -> T) -> T;\n-    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T;\n+    fn read_rec<T>(&self, f: &fn() -> T) -> T;\n+    fn read_struct<T>(&self, name: &str, _len: uint, f: &fn() -> T) -> T;\n+    fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T;\n \n-    fn read_tup<T>(&self, sz: uint, f: fn() -> T) -> T;\n-    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n+    fn read_tup<T>(&self, sz: uint, f: &fn() -> T) -> T;\n+    fn read_tup_elt<T>(&self, idx: uint, f: &fn() -> T) -> T;\n }\n \n pub trait Encodable<S:Encoder> {\n@@ -547,11 +547,11 @@ impl<\n // In some cases, these should eventually be coded as traits.\n \n pub trait EncoderHelpers {\n-    fn emit_from_vec<T>(&self, v: &[T], f: fn(v: &T));\n+    fn emit_from_vec<T>(&self, v: &[T], f: &fn(v: &T));\n }\n \n impl<S:Encoder> EncoderHelpers for S {\n-    fn emit_from_vec<T>(&self, v: &[T], f: fn(v: &T)) {\n+    fn emit_from_vec<T>(&self, v: &[T], f: &fn(v: &T)) {\n         do self.emit_owned_vec(v.len()) {\n             for v.eachi |i, e| {\n                 do self.emit_vec_elt(i) {\n@@ -563,11 +563,11 @@ impl<S:Encoder> EncoderHelpers for S {\n }\n \n pub trait DecoderHelpers {\n-    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n+    fn read_to_vec<T>(&self, f: &fn() -> T) -> ~[T];\n }\n \n impl<D:Decoder> DecoderHelpers for D {\n-    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n+    fn read_to_vec<T>(&self, f: &fn() -> T) -> ~[T] {\n         do self.read_owned_vec |len| {\n             do vec::from_fn(len) |i| {\n                 self.read_vec_elt(i, || f())"}, {"sha": "726e7c36abd1b0804e1c2b778911b3ccabcd4b5a", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -24,7 +24,7 @@ pub struct SmallIntMap<T> {\n \n impl<V> BaseIter<(uint, &self/V)> for SmallIntMap<V> {\n     /// Visit all key-value pairs in order\n-    pure fn each(&self, it: fn(&(uint, &self/V)) -> bool) {\n+    pure fn each(&self, it: &fn(&(uint, &self/V)) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n               Some(ref elt) => if !it(&(i, elt)) { break },\n@@ -38,7 +38,7 @@ impl<V> BaseIter<(uint, &self/V)> for SmallIntMap<V> {\n \n impl<V> ReverseIter<(uint, &self/V)> for SmallIntMap<V> {\n     /// Visit all key-value pairs in reverse order\n-    pure fn each_reverse(&self, it: fn(&(uint, &self/V)) -> bool) {\n+    pure fn each_reverse(&self, it: &fn(&(uint, &self/V)) -> bool) {\n         for uint::range_rev(self.v.len(), 0) |i| {\n             match self.v[i - 1] {\n               Some(ref elt) => if !it(&(i - 1, elt)) { break },\n@@ -76,12 +76,12 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Visit all keys in order\n-    pure fn each_key(&self, blk: fn(key: &uint) -> bool) {\n+    pure fn each_key(&self, blk: &fn(key: &uint) -> bool) {\n         self.each(|&(k, _)| blk(&k))\n     }\n \n     /// Visit all values in order\n-    pure fn each_value(&self, blk: fn(value: &V) -> bool) {\n+    pure fn each_value(&self, blk: &fn(value: &V) -> bool) {\n         self.each(|&(_, v)| blk(v))\n     }\n \n@@ -133,15 +133,15 @@ pub impl<V> SmallIntMap<V> {\n \n pub impl<V:Copy> SmallIntMap<V> {\n     fn update_with_key(&mut self, key: uint, val: V,\n-                       ff: fn(uint, V, V) -> V) -> bool {\n+                       ff: &fn(uint, V, V) -> V) -> bool {\n         let new_val = match self.find(&key) {\n             None => val,\n             Some(orig) => ff(key, *orig, val)\n         };\n         self.insert(key, new_val)\n     }\n \n-    fn update(&mut self, key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n+    fn update(&mut self, key: uint, newval: V, ff: &fn(V, V) -> V) -> bool {\n         self.update_with_key(key, newval, |_k, v, v1| ff(v,v1))\n     }\n }"}, {"sha": "a68fe5f10a3c3d4ad90db220fcffbf469b4f0dad", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -135,7 +135,7 @@ pub impl<Q:Owned> &self/Sem<Q> {\n // FIXME(#3154) move both copies of this into Sem<Q>, and unify the 2 structs\n #[doc(hidden)]\n pub impl &self/Sem<()> {\n-    fn access<U>(&self, blk: fn() -> U) -> U {\n+    fn access<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n@@ -148,7 +148,7 @@ pub impl &self/Sem<()> {\n }\n #[doc(hidden)]\n pub impl &self/Sem<~[Waitqueue]> {\n-    fn access<U>(&self, blk: fn() -> U) -> U {\n+    fn access<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n@@ -332,7 +332,7 @@ pub impl Condvar/&self {\n #[inline(always)]\n #[doc(hidden)]\n fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n-                        blk: fn() -> U) -> U {\n+                        blk: &fn() -> U) -> U {\n     match out_of_bounds {\n         Some(0) =>\n             fail!(fmt!(\"%s with illegal ID %u - this lock has no condvars!\",\n@@ -347,7 +347,7 @@ fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n #[doc(hidden)]\n pub impl Sem<~[Waitqueue]> {\n     // The only other place that condvars get built is rwlock_write_mode.\n-    fn access_cond<U>(&self, blk: fn(c: &Condvar) -> U) -> U {\n+    fn access_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n         do self.access { blk(&Condvar { sem: self }) }\n     }\n }\n@@ -385,7 +385,7 @@ pub impl Semaphore {\n     fn release(&self) { (&self.sem).release() }\n \n     /// Run a function with ownership of one of the semaphore's resources.\n-    fn access<U>(&self, blk: fn() -> U) -> U { (&self.sem).access(blk) }\n+    fn access<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n }\n \n /****************************************************************************\n@@ -421,10 +421,10 @@ impl Clone for Mutex {\n \n pub impl Mutex {\n     /// Run a function with ownership of the mutex.\n-    fn lock<U>(&self, blk: fn() -> U) -> U { (&self.sem).access(blk) }\n+    fn lock<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n \n     /// Run a function with ownership of the mutex and a handle to a condvar.\n-    fn lock_cond<U>(&self, blk: fn(c: &Condvar) -> U) -> U {\n+    fn lock_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n         (&self.sem).access_cond(blk)\n     }\n }\n@@ -480,7 +480,7 @@ pub impl RWlock {\n      * Run a function with the rwlock in read mode. Calls to 'read' from other\n      * tasks may run concurrently with this one.\n      */\n-    fn read<U>(&self, blk: fn() -> U) -> U {\n+    fn read<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n@@ -511,7 +511,7 @@ pub impl RWlock {\n      * Run a function with the rwlock in write mode. No calls to 'read' or\n      * 'write' from other tasks will run concurrently with this one.\n      */\n-    fn write<U>(&self, blk: fn() -> U) -> U {\n+    fn write<U>(&self, blk: &fn() -> U) -> U {\n         unsafe {\n             do task::unkillable {\n                 (&self.order_lock).acquire();\n@@ -529,7 +529,7 @@ pub impl RWlock {\n      * the waiting task is signalled. (Note: a writer that waited and then\n      * was signalled might reacquire the lock before other waiting writers.)\n      */\n-    fn write_cond<U>(&self, blk: fn(c: &Condvar) -> U) -> U {\n+    fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n         // NB: You might think I should thread the order_lock into the cond\n         // wait call, so that it gets waited on before access_lock gets\n         // reacquired upon being woken up. However, (a) this would be not\n@@ -564,7 +564,7 @@ pub impl RWlock {\n      * }\n      * ~~~\n      */\n-    fn write_downgrade<U>(&self, blk: fn(v: RWlockWriteMode) -> U) -> U {\n+    fn write_downgrade<U>(&self, blk: &fn(v: RWlockWriteMode) -> U) -> U {\n         // Implementation slightly different from the slicker 'write's above.\n         // The exit path is conditional on whether the caller downgrades.\n         let mut _release = None;\n@@ -692,16 +692,16 @@ impl Drop for RWlockReadMode/&self { fn finalize(&self) {} }\n \n pub impl RWlockWriteMode/&self {\n     /// Access the pre-downgrade rwlock in write mode.\n-    fn write<U>(&self, blk: fn() -> U) -> U { blk() }\n+    fn write<U>(&self, blk: &fn() -> U) -> U { blk() }\n     /// Access the pre-downgrade rwlock in write mode with a condvar.\n-    fn write_cond<U>(&self, blk: fn(c: &Condvar) -> U) -> U {\n+    fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n         blk(&Condvar { sem: &self.lock.access_lock })\n     }\n }\n \n pub impl RWlockReadMode/&self {\n     /// Access the post-downgrade rwlock in read mode.\n-    fn read<U>(&self, blk: fn() -> U) -> U { blk() }\n+    fn read<U>(&self, blk: &fn() -> U) -> U { blk() }\n }\n \n /****************************************************************************\n@@ -1082,7 +1082,7 @@ mod tests {\n     #[cfg(test)]\n     pub enum RWlockMode { Read, Write, Downgrade, DowngradeRead }\n     #[cfg(test)]\n-    pub fn lock_rwlock_in_mode(x: &RWlock, mode: RWlockMode, blk: fn()) {\n+    pub fn lock_rwlock_in_mode(x: &RWlock, mode: RWlockMode, blk: &fn()) {\n         match mode {\n             Read => x.read(blk),\n             Write => x.write(blk),\n@@ -1239,7 +1239,7 @@ mod tests {\n                                              dg1: bool,\n                                              dg2: bool) {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n-        fn lock_cond(x: &RWlock, downgrade: bool, blk: fn(c: &Condvar)) {\n+        fn lock_cond(x: &RWlock, downgrade: bool, blk: &fn(c: &Condvar)) {\n             if downgrade {\n                 do x.write_downgrade |mode| {\n                     (&mode).write_cond(blk)"}, {"sha": "f053bcfd397cedb2b746c30452c4b2460d8df40c", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -96,7 +96,7 @@ impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n \n impl<'self, K: TotalOrd, V> BaseIter<(&'self K, &'self V)> for TreeMap<K, V> {\n     /// Visit all key-value pairs in order\n-    pure fn each(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n+    pure fn each(&self, f: &fn(&(&self/K, &self/V)) -> bool) {\n         each(&self.root, f)\n     }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n@@ -107,7 +107,7 @@ impl<'self, K: TotalOrd, V>\n     for TreeMap<K, V>\n {\n     /// Visit all key-value pairs in reverse order\n-    pure fn each_reverse(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n+    pure fn each_reverse(&self, f: &fn(&(&self/K, &self/V)) -> bool) {\n         each_reverse(&self.root, f);\n     }\n }\n@@ -135,10 +135,10 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n \n     /// Visit all keys in order\n-    pure fn each_key(&self, f: fn(&K) -> bool) { self.each(|&(k, _)| f(k)) }\n+    pure fn each_key(&self, f: &fn(&K) -> bool) { self.each(|&(k, _)| f(k)) }\n \n     /// Visit all values in order\n-    pure fn each_value(&self, f: fn(&V) -> bool) { self.each(|&(_, v)| f(v)) }\n+    pure fn each_value(&self, f: &fn(&V) -> bool) { self.each(|&(_, v)| f(v)) }\n \n     /// Return the value corresponding to the key in the map\n     pure fn find(&self, key: &K) -> Option<&self/V> {\n@@ -180,12 +180,12 @@ pub impl<K: TotalOrd, V> TreeMap<K, V> {\n     static pure fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n     /// Visit all keys in reverse order\n-    pure fn each_key_reverse(&self, f: fn(&K) -> bool) {\n+    pure fn each_key_reverse(&self, f: &fn(&K) -> bool) {\n         self.each_reverse(|&(k, _)| f(k))\n     }\n \n     /// Visit all values in reverse order\n-    pure fn each_value_reverse(&self, f: fn(&V) -> bool) {\n+    pure fn each_value_reverse(&self, f: &fn(&V) -> bool) {\n         self.each_reverse(|&(_, v)| f(v))\n     }\n \n@@ -225,7 +225,7 @@ pub fn map_next<K, V>(iter: &mut TreeMapIterator/&r<K, V>)\n \n /// Advance the iterator through the map\n pub fn map_advance<K, V>(iter: &mut TreeMapIterator/&r<K, V>,\n-                         f: fn((&r/K, &r/V)) -> bool) {\n+                         f: &fn((&r/K, &r/V)) -> bool) {\n     loop {\n         match map_next(iter) {\n           Some(x) => {\n@@ -242,13 +242,13 @@ pub struct TreeSet<T> {\n \n impl<T: TotalOrd> BaseIter<T> for TreeSet<T> {\n     /// Visit all values in order\n-    pure fn each(&self, f: fn(&T) -> bool) { self.map.each_key(f) }\n+    pure fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<T: TotalOrd> ReverseIter<T> for TreeSet<T> {\n     /// Visit all values in reverse order\n-    pure fn each_reverse(&self, f: fn(&T) -> bool) {\n+    pure fn each_reverse(&self, f: &fn(&T) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n }\n@@ -350,7 +350,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the difference\n-    pure fn difference(&self, other: &TreeSet<T>, f: fn(&T) -> bool) {\n+    pure fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -383,7 +383,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n \n     /// Visit the values (in-order) representing the symmetric difference\n     pure fn symmetric_difference(&self, other: &TreeSet<T>,\n-                                 f: fn(&T) -> bool) {\n+                                 f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -422,7 +422,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the intersection\n-    pure fn intersection(&self, other: &TreeSet<T>, f: fn(&T) -> bool) {\n+    pure fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -449,7 +449,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the union\n-    pure fn union(&self, other: &TreeSet<T>, f: fn(&T) -> bool) {\n+    pure fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -508,7 +508,7 @@ pub fn set_next<T>(iter: &mut TreeSetIterator/&r<T>) -> Option<&r/T> {\n \n /// Advance the iterator through the set\n fn set_advance<T>(iter: &mut TreeSetIterator/&r<T>,\n-                       f: fn(&r/T) -> bool) {\n+                       f: &fn(&r/T) -> bool) {\n     do map_advance(&mut iter.iter) |(k, _)| { f(k) }\n }\n \n@@ -530,15 +530,15 @@ pub impl<K: TotalOrd, V> TreeNode<K, V> {\n }\n \n pure fn each<K: TotalOrd, V>(node: &r/Option<~TreeNode<K, V>>,\n-                        f: fn(&(&r/K, &r/V)) -> bool) {\n+                        f: &fn(&(&r/K, &r/V)) -> bool) {\n     for node.each |x| {\n         each(&x.left, f);\n         if f(&(&x.key, &x.value)) { each(&x.right, f) }\n     }\n }\n \n pure fn each_reverse<K: TotalOrd, V>(node: &r/Option<~TreeNode<K, V>>,\n-                                f: fn(&(&r/K, &r/V)) -> bool) {\n+                                f: &fn(&(&r/K, &r/V)) -> bool) {\n     for node.each |x| {\n         each_reverse(&x.right, f);\n         if f(&(&x.key, &x.value)) { each_reverse(&x.left, f) }"}, {"sha": "68a6f8effaa7710d8de3c4884b2d0b4ca67efab2", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -269,7 +269,7 @@ pub impl Context {\n               Decodable<json::Decoder/&static>>( // FIXME(#5121)\n                   @self,\n                   fn_name:&str,\n-                  blk: fn(@Mut<Prep>)->Work<T>) -> Work<T> {\n+                  blk: &fn(@Mut<Prep>)->Work<T>) -> Work<T> {\n         let p = @Mut(Prep {ctxt: self,\n                            fn_name: fn_name.to_owned(),\n                            declared_inputs: LinearMap::new()});"}, {"sha": "a7d5c0ce75fa0410ea9f431e8a46e798c94fb7da", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -423,7 +423,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n }\n \n pub fn node_item_query<Result>(items: map, id: node_id,\n-                               query: fn(@item) -> Result,\n+                               query: &fn(@item) -> Result,\n                                +error_msg: ~str) -> Result {\n     match items.find(&id) {\n         Some(node_item(it, _)) => query(it),"}, {"sha": "35b188a248fd41e1f8973ab40c6772f85cdcd3f3", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -516,7 +516,7 @@ pub pure fn is_item_impl(item: @ast::item) -> bool {\n     }\n }\n \n-pub fn walk_pat(pat: @pat, it: fn(@pat)) {\n+pub fn walk_pat(pat: @pat, it: &fn(@pat)) {\n     it(pat);\n     match pat.node {\n         pat_ident(_, _, Some(p)) => walk_pat(p, it),"}, {"sha": "4e177fecec9e6bacbafb5975fe153940436e4b00", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -306,7 +306,7 @@ fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n \n pub fn expect<T:Copy>(diag: span_handler,\n                        opt: Option<T>,\n-                       msg: fn() -> ~str) -> T {\n+                       msg: &fn() -> ~str) -> T {\n     match opt {\n        Some(ref t) => (*t),\n        None => diag.handler().bug(msg())"}, {"sha": "8aa03e14fa47fcde697be2bcd3529b6b75ef3c1c", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -432,7 +432,7 @@ fn mk_impl(\n     ty_param: ast::TyParam,\n     path: @ast::path,\n     generics: &ast::Generics,\n-    f: fn(@ast::Ty) -> @ast::method\n+    f: &fn(@ast::Ty) -> @ast::method\n ) -> @ast::item {\n     /*!\n      *\n@@ -1256,51 +1256,51 @@ mod test {\n         fn emit_owned_str(&self, +_v: &str) { self.add_unknown_to_log(); }\n         fn emit_managed_str(&self, +_v: &str) { self.add_unknown_to_log(); }\n \n-        fn emit_borrowed(&self, f: fn()) { self.add_unknown_to_log(); f() }\n-        fn emit_owned(&self, f: fn()) { self.add_unknown_to_log(); f() }\n-        fn emit_managed(&self, f: fn()) { self.add_unknown_to_log(); f() }\n+        fn emit_borrowed(&self, f: &fn()) { self.add_unknown_to_log(); f() }\n+        fn emit_owned(&self, f: &fn()) { self.add_unknown_to_log(); f() }\n+        fn emit_managed(&self, f: &fn()) { self.add_unknown_to_log(); f() }\n \n-        fn emit_enum(&self, name: &str, f: fn()) {\n+        fn emit_enum(&self, name: &str, f: &fn()) {\n             self.add_to_log(CallToEmitEnum(name.to_str())); f(); }\n \n         fn emit_enum_variant(&self, name: &str, +id: uint,\n-                             +cnt: uint, f: fn()) {\n+                             +cnt: uint, f: &fn()) {\n             self.add_to_log(CallToEmitEnumVariant (name.to_str(),id,cnt));\n             f();\n         }\n \n-        fn emit_enum_variant_arg(&self, +idx: uint, f: fn()) {\n+        fn emit_enum_variant_arg(&self, +idx: uint, f: &fn()) {\n             self.add_to_log(CallToEmitEnumVariantArg (idx)); f();\n         }\n \n-        fn emit_borrowed_vec(&self, +_len: uint, f: fn()) {\n+        fn emit_borrowed_vec(&self, +_len: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n \n-        fn emit_owned_vec(&self, +_len: uint, f: fn()) {\n+        fn emit_owned_vec(&self, +_len: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n-        fn emit_managed_vec(&self, +_len: uint, f: fn()) {\n+        fn emit_managed_vec(&self, +_len: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n-        fn emit_vec_elt(&self, +_idx: uint, f: fn()) {\n+        fn emit_vec_elt(&self, +_idx: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n \n-        fn emit_rec(&self, f: fn()) {\n+        fn emit_rec(&self, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n-        fn emit_struct(&self, name: &str, +len: uint, f: fn()) {\n+        fn emit_struct(&self, name: &str, +len: uint, f: &fn()) {\n             self.add_to_log(CallToEmitStruct (name.to_str(),len)); f();\n         }\n-        fn emit_field(&self, name: &str, +idx: uint, f: fn()) {\n+        fn emit_field(&self, name: &str, +idx: uint, f: &fn()) {\n             self.add_to_log(CallToEmitField (name.to_str(),idx)); f();\n         }\n \n-        fn emit_tup(&self, +_len: uint, f: fn()) {\n+        fn emit_tup(&self, +_len: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n-        fn emit_tup_elt(&self, +_idx: uint, f: fn()) {\n+        fn emit_tup_elt(&self, +_idx: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n     }"}, {"sha": "dc9abd536d11fc0d6dce3c628d7c9f1625cf4862", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -104,7 +104,7 @@ pub impl state_ {\n \n     /// Iterate over the states that can be reached in one message\n     /// from this state.\n-    fn reachable(&self, f: fn(state) -> bool) {\n+    fn reachable(&self, f: &fn(state) -> bool) {\n         for self.messages.each |m| {\n             match *m {\n               message(_, _, _, _, Some(next_state { state: ref id, _ })) => {"}, {"sha": "ba0c7a71b7c17cf07db98f8a3eea6d9783fe934f", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -122,7 +122,7 @@ impl<A:Eq> Eq for OptVec<A> {\n }\n \n impl<A> BaseIter<A> for OptVec<A> {\n-    pure fn each(&self, blk: fn(v: &A) -> bool) {\n+    pure fn each(&self, blk: &fn(v: &A) -> bool) {\n         match *self {\n             Empty => {}\n             Vec(ref v) => v.each(blk)\n@@ -136,31 +136,31 @@ impl<A> BaseIter<A> for OptVec<A> {\n \n impl<A> iter::ExtendedIter<A> for OptVec<A> {\n     #[inline(always)]\n-    pure fn eachi(&self, blk: fn(+v: uint, v: &A) -> bool) {\n+    pure fn eachi(&self, blk: &fn(+v: uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n     #[inline(always)]\n-    pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n+    pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n     #[inline(always)]\n-    pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n+    pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n     #[inline(always)]\n-    pure fn foldl<B>(&self, +b0: B, blk: fn(&B, &A) -> B) -> B {\n+    pure fn foldl<B>(&self, +b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n     #[inline(always)]\n-    pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n+    pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n     #[inline(always)]\n-    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B] {\n+    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n     #[inline(always)]\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: fn(&A) -> IB)\n+    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n@@ -176,13 +176,13 @@ impl<A: Eq> iter::EqIter<A> for OptVec<A> {\n \n impl<A: Copy> iter::CopyableIter<A> for OptVec<A> {\n     #[inline(always)]\n-    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n+    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n     #[inline(always)]\n     pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n     #[inline(always)]\n-    pure fn find(&self, f: fn(&A) -> bool) -> Option<A> {\n+    pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }"}, {"sha": "c7b9a769293d6b32eaa26ee4b1925b0036693b54", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -248,7 +248,7 @@ pub impl Parser {\n     fn parse_seq_to_before_gt<T: Copy>(\n         &self,\n         sep: Option<token::Token>,\n-        f: fn(&Parser) -> T\n+        f: &fn(&Parser) -> T\n     ) -> OptVec<T> {\n         let mut first = true;\n         let mut v = opt_vec::Empty;\n@@ -269,7 +269,7 @@ pub impl Parser {\n     fn parse_seq_to_gt<T: Copy>(\n         &self,\n         sep: Option<token::Token>,\n-        f: fn(&Parser) -> T\n+        f: &fn(&Parser) -> T\n     ) -> OptVec<T> {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n@@ -283,7 +283,7 @@ pub impl Parser {\n         &self,\n         ket: &token::Token,\n         sep: SeqSep,\n-        f: fn(&Parser) -> T\n+        f: &fn(&Parser) -> T\n     ) -> ~[T] {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n@@ -297,7 +297,7 @@ pub impl Parser {\n         &self,\n         ket: &token::Token,\n         sep: SeqSep,\n-        f: fn(&Parser) -> T\n+        f: &fn(&Parser) -> T\n     ) -> ~[T] {\n         let mut first: bool = true;\n         let mut v: ~[T] = ~[];\n@@ -323,7 +323,7 @@ pub impl Parser {\n         bra: &token::Token,\n         ket: &token::Token,\n         sep: SeqSep,\n-        f: fn(&Parser) -> T\n+        f: &fn(&Parser) -> T\n     ) -> ~[T] {\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n@@ -338,7 +338,7 @@ pub impl Parser {\n         bra: &token::Token,\n         ket: &token::Token,\n         sep: SeqSep,\n-        f: fn(&Parser) -> T\n+        f: &fn(&Parser) -> T\n     ) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);"}, {"sha": "fd84f8670686b5aafc16c9f25942209dc87ad598", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -173,7 +173,7 @@ pub fn parse_tts_from_source_str(\n }\n \n pub fn parse_from_source_str<T>(\n-    f: fn (Parser) -> T,\n+    f: &fn (Parser) -> T,\n     name: ~str, ss: codemap::FileSubstr,\n     source: @~str,\n     +cfg: ast::crate_cfg,"}, {"sha": "92ff83a39756f60b33b625bb843c5a1802d0e7c8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -1829,7 +1829,7 @@ pub impl Parser {\n \n     fn parse_sugary_call_expr(&self, keyword: ~str,\n                               sugar: CallSugar,\n-                              ctor: fn(+v: @expr) -> expr_) -> @expr {\n+                              ctor: &fn(+v: @expr) -> expr_) -> @expr {\n         let lo = self.last_span;\n         // Parse the callee `foo` in\n         //    for foo || {\n@@ -2769,7 +2769,7 @@ pub impl Parser {\n         (lifetimes, opt_vec::take_vec(result))\n     }\n \n-    fn parse_fn_decl(&self, parse_arg_fn: fn(&Parser) -> arg_or_capture_item)\n+    fn parse_fn_decl(&self, parse_arg_fn: &fn(&Parser) -> arg_or_capture_item)\n         -> fn_decl\n     {\n         let args_or_capture_items: ~[arg_or_capture_item] =\n@@ -2816,7 +2816,7 @@ pub impl Parser {\n         fn(&Parser) -> arg_or_capture_item\n     ) -> (self_ty, fn_decl) {\n         fn maybe_parse_self_ty(\n-            cnstr: fn(+v: mutability) -> ast::self_ty_,\n+            cnstr: &fn(+v: mutability) -> ast::self_ty_,\n             p: &Parser\n         ) -> ast::self_ty_ {\n             // We need to make sure it isn't a mode or a type"}, {"sha": "e7e2435587ef1dbf19de194c4393a49956f05405", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -314,8 +314,8 @@ pub fn commasep<IN>(s: @ps, b: breaks, elts: ~[IN], op: &fn(@ps, IN)) {\n }\n \n \n-pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: ~[IN], op: fn(@ps, IN),\n-                         get_span: fn(IN) -> codemap::span) {\n+pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: ~[IN], op: &fn(@ps, IN),\n+                         get_span: &fn(IN) -> codemap::span) {\n     box(s, 0u, b);\n     let len = vec::len::<IN>(elts);\n     let mut i = 0u;"}, {"sha": "b7149be00cca92d48730e1920df465b8c447f1d6", "filename": "src/test/auxiliary/cci_impl_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -11,12 +11,12 @@\n #[link(name=\"cci_impl_lib\", vers=\"0.0\")];\n \n trait uint_helpers {\n-    fn to(v: uint, f: fn(uint));\n+    fn to(v: uint, f: &fn(uint));\n }\n \n impl uint_helpers for uint {\n     #[inline]\n-    fn to(v: uint, f: fn(uint)) {\n+    fn to(v: uint, f: &fn(uint)) {\n         let mut i = self;\n         while i < v {\n             f(i);"}, {"sha": "107f0ac32a4bf9cef4173c5dd03494d11c67649c", "filename": "src/test/auxiliary/cci_iter_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -12,7 +12,7 @@\n #[legacy_modes];\n \n #[inline]\n-pub fn iter<T>(v: ~[T], f: fn(T)) {\n+pub fn iter<T>(v: ~[T], f: &fn(T)) {\n     let mut i = 0u;\n     let n = vec::len(v);\n     while i < n {"}, {"sha": "407f62adb0251ef2a0b8c82013d4f00aa6069cb4", "filename": "src/test/auxiliary/cci_no_inline_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -11,7 +11,7 @@\n #[link(name=\"cci_no_inline_lib\", vers=\"0.0\")];\n \n // same as cci_iter_lib, more-or-less, but not marked inline\n-pub fn iter(v: ~[uint], f: fn(uint)) {\n+pub fn iter(v: ~[uint], f: &fn(uint)) {\n     let mut i = 0u;\n     let n = vec::len(v);\n     while i < n {"}, {"sha": "c86d2fe4d9332340783cf4dbec27849724b9f808", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -25,7 +25,7 @@ struct Results {\n }\n \n fn timed(result: &mut float,\n-         op: fn()) {\n+         op: &fn()) {\n     let start = std::time::precise_time_s();\n     op();\n     let end = std::time::precise_time_s();"}, {"sha": "adfde66e57a011755c795a7fe471cba74f96d0d8", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -24,7 +24,7 @@ struct Results {\n     delete_strings: float\n }\n \n-fn timed(result: &mut float, op: fn()) {\n+fn timed(result: &mut float, op: &fn()) {\n     let start = std::time::precise_time_s();\n     op();\n     let end = std::time::precise_time_s();\n@@ -33,7 +33,7 @@ fn timed(result: &mut float, op: fn()) {\n \n pub impl Results {\n     fn bench_int<T:Set<uint>>(&mut self, rng: @rand::Rng, num_keys: uint,\n-                               rand_cap: uint, f: fn() -> T) {\n+                               rand_cap: uint, f: &fn() -> T) {\n         {\n             let mut set = f();\n             do timed(&mut self.sequential_ints) {\n@@ -71,7 +71,7 @@ pub impl Results {\n     }\n \n     fn bench_str<T:Set<~str>>(&mut self, rng: @rand::Rng, num_keys: uint,\n-                               f: fn() -> T) {\n+                               f: &fn() -> T) {\n         {\n             let mut set = f();\n             do timed(&mut self.sequential_strings) {"}, {"sha": "e8fb86fda788988e5731590a7f10934f1d510e60", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -34,7 +34,7 @@ fn main() {\n     bench!(vec_push_all);\n }\n \n-fn maybe_run_test(argv: &[~str], name: ~str, test: fn()) {\n+fn maybe_run_test(argv: &[~str], name: ~str, test: &fn()) {\n     let mut run_test = false;\n \n     if os::getenv(~\"RUST_BENCH\").is_some() { run_test = true }"}, {"sha": "731605e82bd1f3205cf19fbe33bcae21b42ff3ac", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -71,7 +71,7 @@ macro_rules! follow (\n )\n \n fn switch<T:Owned,Tb:Owned,U>(+endp: core::pipes::RecvPacketBuffered<T, Tb>,\n-                      f: fn(+v: Option<T>) -> U) -> U {\n+                      f: &fn(+v: Option<T>) -> U) -> U {\n     f(core::pipes::try_recv(endp))\n }\n \n@@ -131,7 +131,7 @@ fn unbounded(count: uint) {\n     }\n }\n \n-fn timeit(f: fn()) -> float {\n+fn timeit(f: &fn()) -> float {\n     let start = precise_time_s();\n     f();\n     let stop = precise_time_s();"}, {"sha": "fc980e3d6db53eb03713e334274cb3f2e939cebd", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -85,7 +85,7 @@ fn update_freq(mm: HashMap<~[u8], uint>, key: &[u8]) {\n // i.e., for \"hello\" and windows of size four,\n // run it(\"hell\") and it(\"ello\"), then return \"llo\"\n fn windows_with_carry(bb: &[u8], nn: uint,\n-                      it: fn(window: &[u8])) -> ~[u8] {\n+                      it: &fn(window: &[u8])) -> ~[u8] {\n    let mut ii = 0u;\n \n    let len = vec::len(bb);"}, {"sha": "2efc16de8307fbcd5819e3d8421878f14f014e3b", "filename": "src/test/compile-fail/arg-style-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Farg-style-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Farg-style-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farg-style-mismatch.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -11,5 +11,5 @@\n // error-pattern: mismatched types\n \n fn f(&&_x: int) {}\n-fn g(_a: fn(+v: int)) {}\n+fn g(_a: &fn(+v: int)) {}\n fn main() { g(f); }"}, {"sha": "8835c577fa8fdf8995d267f0992c4a06fe4c2ef0", "filename": "src/test/compile-fail/bad-for-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    fn baz(_x: fn(y: int) -> int) {}\n+    fn baz(_x: &fn(y: int) -> int) {}\n     for baz |_e| { } //~ ERROR A `for` loop iterator should expect a closure that returns `bool`\n }"}, {"sha": "980dc66b4af5980e8ba3472de019fcdad471c3b7", "filename": "src/test/compile-fail/block-coerce-no.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -11,9 +11,9 @@\n // Make sure that fn-to-block coercion isn't incorrectly lifted over\n // other tycons.\n \n-fn coerce(b: fn()) -> extern fn() {\n-    fn lol(+f: extern fn(+v: fn()) -> extern fn(),\n-           +g: fn()) -> extern fn() { return f(g); }\n+fn coerce(b: &fn()) -> extern fn() {\n+    fn lol(+f: extern fn(+v: &fn()) -> extern fn(),\n+           +g: &fn()) -> extern fn() { return f(g); }\n     fn fn_id(+f: extern fn()) -> extern fn() { return f }\n     return lol(fn_id, b);\n     //~^ ERROR mismatched types"}, {"sha": "25b56abb5ba005a1ff02e46e840b6e600733f8ea", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -22,7 +22,7 @@ fn a() {\n     p[0] = 5; //~ ERROR assigning to mutable vec content prohibited due to outstanding loan\n }\n \n-fn borrow(_x: &[int], _f: fn()) {}\n+fn borrow(_x: &[int], _f: &fn()) {}\n \n fn b() {\n     // here we alias the mutable vector into an imm slice and try to"}, {"sha": "237c1b86713523c4f493cbeed6e5cda641ca50a8", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n enum X = Either<(uint,uint),extern fn()>;\n pub impl &'self X {\n-    fn with(blk: fn(x: &Either<(uint,uint),extern fn()>)) {\n+    fn with(blk: &fn(x: &Either<(uint,uint),extern fn()>)) {\n         blk(&**self)\n     }\n }"}, {"sha": "788c5397e35d0c236fe555047222ffd3d3a265fd", "filename": "src/test/compile-fail/borrowck-insert-during-each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -15,7 +15,7 @@ struct Foo {\n }\n \n pub impl Foo {\n-  fn foo(&mut self, fun: fn(&int)) {\n+  fn foo(&mut self, fun: &fn(&int)) {\n     for self.n.each |f| {\n       fun(f);\n     }"}, {"sha": "ed6446a6311b8dbd5b06110fac120fc2851bd25f", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -94,7 +94,7 @@ fn loop_in_block() {\n }\n \n fn at_most_once_block() {\n-    fn at_most_once(f: fn()) { f() }\n+    fn at_most_once(f: &fn()) { f() }\n \n     // Here, the borrow check has no way of knowing that the block is\n     // executed at most once."}, {"sha": "784fce1300f769cef13b3ed3d0f4aeaa18d85243", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn borrow(v: &int, f: fn(x: &int)) {\n+fn borrow(v: &int, f: &fn(x: &int)) {\n     f(v);\n }\n "}, {"sha": "332ec3fe697d0cbe0be8524192c833bc5cb91ef7", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn borrow(v: &int, f: fn(x: &int)) {\n+fn borrow(v: &int, f: &fn(x: &int)) {\n     f(v);\n }\n "}, {"sha": "85989bf9d21402fc8f3ca2861395d3891d4a83fd", "filename": "src/test/compile-fail/borrowck-loan-rcvr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -12,15 +12,15 @@ struct point { x: int, y: int }\n \n trait methods {\n     fn impurem();\n-    fn blockm(f: fn());\n+    fn blockm(f: &fn());\n     pure fn purem();\n }\n \n impl methods for point {\n     fn impurem() {\n     }\n \n-    fn blockm(f: fn()) { f() }\n+    fn blockm(f: &fn()) { f() }\n \n     pure fn purem() {\n     }"}, {"sha": "d27d690437affb79993a7805f717f26dd6045e16", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -12,7 +12,7 @@\n // (locally rooted) mutable, unique vector, and that we then prevent\n // modifications to the contents.\n \n-fn takes_imm_elt(_v: &int, f: fn()) {\n+fn takes_imm_elt(_v: &int, f: &fn()) {\n     f();\n }\n \n@@ -29,7 +29,7 @@ fn has_mut_vec_but_tries_to_change_it() {\n     }\n }\n \n-fn takes_const_elt(_v: &const int, f: fn()) {\n+fn takes_const_elt(_v: &const int, f: &fn()) {\n     f();\n }\n "}, {"sha": "aad0e8bcbb6dd874fa5ead459190574cdcfeb112", "filename": "src/test/compile-fail/closure-that-fails.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -1,4 +1,4 @@\n-fn foo(f: fn() -> !) {}\n+fn foo(f: &fn() -> !) {}\n \n fn main() {\n     // Type inference didn't use to be able to handle this:"}, {"sha": "4daa7f71adf28e3c6a758941ac316286f546bad9", "filename": "src/test/compile-fail/extern-wrong-value-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -13,5 +13,5 @@ extern fn f() {\n \n fn main() {\n     // extern functions are *u8 types\n-    let _x: fn() = f; //~ ERROR mismatched types: expected `&fn()` but found `*u8`\n+    let _x: &fn() = f; //~ ERROR mismatched types: expected `&fn()` but found `*u8`\n }"}, {"sha": "c5c29bd3ecfe70908b8f3bf498f31350c9716915", "filename": "src/test/compile-fail/fn-variance-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -14,7 +14,7 @@ fn takes_mut(&&x: @mut int) { }\n fn takes_const(&&x: @const int) { }\n fn takes_imm(&&x: @int) { }\n \n-fn apply<T>(t: T, f: fn(T)) {\n+fn apply<T>(t: T, f: &fn(T)) {\n     f(t)\n }\n "}, {"sha": "2084729372d1dea12a1e40ec1e6d90afdd1de28b", "filename": "src/test/compile-fail/immut-function-arguments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -13,7 +13,7 @@ fn f(y: ~int) {\n }\n \n fn g() {\n-    let _frob: fn(~int) = |q| { *q = 2; }; //~ ERROR assigning to dereference of immutable ~ pointer\n+    let _frob: &fn(~int) = |q| { *q = 2; }; //~ ERROR assigning to dereference of immutable ~ pointer\n \n }\n "}, {"sha": "361a20ad45133ce83ce5b00692aac015a2feb5af", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n trait vec_monad<A> {\n-    fn bind<B>(f: fn(A) -> ~[B]);\n+    fn bind<B>(f: &fn(A) -> ~[B]);\n }\n \n impl<A> vec_monad<A> for ~[A] {\n-    fn bind<B>(f: fn(A) -> ~[B]) {\n+    fn bind<B>(f: &fn(A) -> ~[B]) {\n         let mut r = fail!();\n         for self.each |elt| { r += f(*elt); }\n         //~^ WARNING unreachable expression"}, {"sha": "6084552f0ed6da17aa3d28eef8991c677af1afd5", "filename": "src/test/compile-fail/issue-2817-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fissue-2817-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fissue-2817-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2817-2.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn not_bool(f: fn(int) -> ~str) {}\n+fn not_bool(f: &fn(int) -> ~str) {}\n \n fn main() {\n     for uint::range(0, 100000) |_i| { //~ ERROR A for-loop body must return (), but"}, {"sha": "b1fc6a870d0867a2618cefaf56b997a4bc3ccdcf", "filename": "src/test/compile-fail/liveness-closure-require-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fliveness-closure-require-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fliveness-closure-require-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-closure-require-ret.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn force(f: fn() -> int) -> int { f() }\n+fn force(f: &fn() -> int) -> int { f() }\n fn main() { log(debug, force(|| {})); } //~ ERROR mismatched types"}, {"sha": "974f30feb065185be8b11202167fc12df867087d", "filename": "src/test/compile-fail/missing-do.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n // Regression test for issue #2783\n \n-fn foo(f: fn()) { f() }\n+fn foo(f: &fn()) { f() }\n \n fn main() {\n     ~\"\" || 42; //~ ERROR binary operation || cannot be applied to type `~str`"}, {"sha": "d9f6cf8b2d722dcd5666bc2c783cca7e569bdc42", "filename": "src/test/compile-fail/mode-inference-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -13,8 +13,8 @@\n // In this test, the mode gets inferred to ++ due to the apply_int(),\n // but then we get a failure in the generic apply().\n \n-fn apply<A>(f: fn(A) -> A, a: A) -> A { f(a) }\n-fn apply_int(f: fn(int) -> int, a: int) -> int { f(a) }\n+fn apply<A>(f: &fn(A) -> A, a: A) -> A { f(a) }\n+fn apply_int(f: &fn(int) -> int, a: int) -> int { f(a) }\n \n fn main() {\n     let f = {|i| i};"}, {"sha": "6d262bc04e1e482a77bf8ada93868dffc5e3a07a", "filename": "src/test/compile-fail/pure-higher-order.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -16,21 +16,21 @@ struct S<'self> {\n     f: &'self fn(uint)\n }\n \n-pure fn range(from: uint, to: uint, f: fn(uint)) {\n+pure fn range(from: uint, to: uint, f: &fn(uint)) {\n     let mut i = from;\n     while i < to {\n         f(i); // Note: legal to call argument, even if it is not pure.\n         i += 1u;\n     }\n }\n \n-pure fn range2(from: uint, to: uint, f: fn(uint)) {\n+pure fn range2(from: uint, to: uint, f: &fn(uint)) {\n     do range(from, to) |i| {\n         f(i*2u);\n     }\n }\n \n-pure fn range3(from: uint, to: uint, f: fn(uint)) {\n+pure fn range3(from: uint, to: uint, f: &fn(uint)) {\n     range(from, to, f)\n }\n "}, {"sha": "3e5296530fa35c11772c0cc6966793f3a36e29ba", "filename": "src/test/compile-fail/purity-infer-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fpurity-infer-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fpurity-infer-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpurity-infer-fail.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn something(f: pure fn()) { f(); }\n+fn something(f: &pure fn()) { f(); }\n \n fn main() {\n     let mut x = ~[];"}, {"sha": "eda207f711d68865e3f3a12536929c68e65fb46b", "filename": "src/test/compile-fail/qquote-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -62,7 +62,7 @@ fn main() {\n     check_pp(expr3,  pprust::print_expr, \"2 - 23 + 7\");\n }\n \n-fn check_pp<T>(expr: T, f: fn(pprust::ps, T), expect: str) {\n+fn check_pp<T>(expr: T, f: &fn(pprust::ps, T), expect: str) {\n     fail!();\n }\n "}, {"sha": "c669053400831142b9bcfa24376345ba463338e3", "filename": "src/test/compile-fail/qquote-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -57,7 +57,7 @@ fn main() {\n     check_pp(*stmt,  pprust::print_stmt, \"\");\n }\n \n-fn check_pp<T>(expr: T, f: fn(pprust::ps, T), expect: str) {\n+fn check_pp<T>(expr: T, f: &fn(pprust::ps, T), expect: str) {\n     fail!();\n }\n "}, {"sha": "88f2eefd369052fd72cd1ca940e31f4c576e8817", "filename": "src/test/compile-fail/regions-creating-enums.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -29,7 +29,7 @@ fn compute(x: &ast) -> uint {\n     }\n }\n \n-fn map_nums(x: &ast, f: fn(uint) -> uint) -> &ast {\n+fn map_nums(x: &ast, f: &fn(uint) -> uint) -> &ast {\n     match *x {\n       num(x) => {\n         return &num(f(x)); //~ ERROR illegal borrow"}, {"sha": "9cee55643f89ca620a7cdac69375d8ec94d41db6", "filename": "src/test/compile-fail/regions-escape-bound-fn-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn with_int(f: fn(x: &int)) {\n+fn with_int(f: &fn(x: &int)) {\n     let x = 3;\n     f(&x);\n }"}, {"sha": "c81ef77f497db8b7a9d0f0c33684588b02e3a601", "filename": "src/test/compile-fail/regions-escape-bound-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn with_int(f: fn(x: &int)) {\n+fn with_int(f: &fn(x: &int)) {\n     let x = 3;\n     f(&x);\n }"}, {"sha": "767d7c9174dfae79a64f0760dd9a51621e5b21cd", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -18,7 +18,7 @@ impl deref for &'self int {\n     }\n }\n \n-fn with<R:deref>(f: fn(x: &int) -> R) -> int {\n+fn with<R:deref>(f: &fn(x: &int) -> R) -> int {\n     f(&3).get()\n }\n "}, {"sha": "ef8f6748d36af8c571c55746ae00127fbbe6e560", "filename": "src/test/compile-fail/regions-infer-borrow-scope-within-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n fn borrow<T>(x: &r/T) -> &r/T {x}\n \n-fn foo(cond: fn() -> bool, box: fn() -> @int) {\n+fn foo(cond: &fn() -> bool, box: &fn() -> @int) {\n     let mut y: &int;\n     loop {\n         let x = box();"}, {"sha": "49d3f6aee65c8825d74ea16383319170d5bb32e3", "filename": "src/test/compile-fail/regions-infer-call-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-infer-call-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-infer-call-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-call-3.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n fn select(x: &r/int, y: &r/int) -> &r/int { x }\n \n-fn with<T>(f: fn(x: &int) -> T) -> T {\n+fn with<T>(f: &fn(x: &int) -> T) -> T {\n     f(&20)\n }\n "}, {"sha": "ab6a37b58de6fa7c6367814b94bb27c0e69ef652", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -12,7 +12,7 @@\n // some point regions-ret-borrowed reported an error but this file did\n // not, due to special hardcoding around the anonymous region.\n \n-fn with<R>(f: fn(x: &a/int) -> R) -> R {\n+fn with<R>(f: &fn(x: &a/int) -> R) -> R {\n     f(&3)\n }\n "}, {"sha": "157b99de9e80685477f06f789f13851d79641030", "filename": "src/test/compile-fail/regions-ret-borrowed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -15,7 +15,7 @@\n // used to successfully compile because we failed to account for the\n // fact that fn(x: &int) rebound the region &.\n \n-fn with<R>(f: fn(x: &int) -> R) -> R {\n+fn with<R>(f: &fn(x: &int) -> R) -> R {\n     f(&3)\n }\n "}, {"sha": "e675d4d455f2c801c84d66f850d9f7eee09bca40", "filename": "src/test/compile-fail/regions-scoping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn with<T>(t: T, f: fn(T)) { f(t) }\n+fn with<T>(t: T, f: &fn(T)) { f(t) }\n \n fn nested<'x>(x: &'x int) {  // (1)\n     do with("}, {"sha": "07dc677c0476338b7a0a76a795bda0b481d02256", "filename": "src/test/compile-fail/type-arg-out-of-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,6 +10,6 @@\n \n // error-pattern:attempt to use a type argument out of scope\n fn foo<T>(x: T) {\n-    fn bar(f: fn(T) -> T) { }\n+    fn bar(f: &fn(T) -> T) { }\n }\n fn main() { foo(1); }"}, {"sha": "1b28d2f6c6d63ee9d9eab7069020c83eb4833b74", "filename": "src/test/run-fail/unwind-iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-fail%2Funwind-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-fail%2Funwind-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-iter.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n // error-pattern:fail\n \n-fn x(it: fn(int)) {\n+fn x(it: &fn(int)) {\n     fail!();\n     it(0);\n }"}, {"sha": "286e5f4976430cf93c178f32790d99d742085762", "filename": "src/test/run-fail/unwind-iter2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-fail%2Funwind-iter2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-fail%2Funwind-iter2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-iter2.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n // error-pattern:fail\n \n-fn x(it: fn(int)) {\n+fn x(it: &fn(int)) {\n     let a = @0;\n     it(1);\n }"}, {"sha": "613480e3a63cdaa604e9b89e8d0b4bc0b2dc11bf", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -75,7 +75,7 @@ fn main() {\n }\n \n fn check_pp<T>(cx: fake_ext_ctxt,\n-               expr: T, f: fn(pprust::ps, T), expect: ~str) {\n+               expr: T, f: &fn(pprust::ps, T), expect: ~str) {\n     let s = do io::with_str_writer |wr| {\n         let pp = pprust::rust_printer(wr, cx.parse_sess().interner);\n         f(pp, expr);"}, {"sha": "40d215883500256bd51a97248f07623a365bd67a", "filename": "src/test/run-pass/alt-phi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Falt-phi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Falt-phi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-phi.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -12,7 +12,7 @@\n \n enum thing { a, b, c, }\n \n-fn foo(it: fn(int)) { it(10); }\n+fn foo(it: &fn(int)) { it(10); }\n \n pub fn main() {\n     let mut x = true;"}, {"sha": "ae046babfdf83edd59c8446a16bf5080ee6910b7", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -13,19 +13,19 @@\n // it.\n \n trait iterable<A> {\n-    fn iterate(blk: fn(x: &A) -> bool);\n+    fn iterate(blk: &fn(x: &A) -> bool);\n }\n \n impl<A> iterable<A> for &self/[A] {\n-    fn iterate(f: fn(x: &A) -> bool) {\n+    fn iterate(f: &fn(x: &A) -> bool) {\n         for vec::each(self) |e| {\n             if !f(e) { break; }\n         }\n     }\n }\n \n impl<A> iterable<A> for ~[A] {\n-    fn iterate(f: fn(x: &A) -> bool) {\n+    fn iterate(f: &fn(x: &A) -> bool) {\n         for vec::each(self) |e| {\n             if !f(e) { break; }\n         }"}, {"sha": "44688a8dfce964541cce1277c91dc91180b7019c", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,10 +10,10 @@\n \n fn f<T:Copy>(x: ~[T]) -> T { return x[0]; }\n \n-fn g(act: fn(~[int]) -> int) -> int { return act(~[1, 2, 3]); }\n+fn g(act: &fn(~[int]) -> int) -> int { return act(~[1, 2, 3]); }\n \n pub fn main() {\n     fail_unless!((g(f) == 1));\n-    let f1: fn(~[~str]) -> ~str = f;\n+    let f1: &fn(~[~str]) -> ~str = f;\n     fail_unless!((f1(~[~\"x\", ~\"y\", ~\"z\"]) == ~\"x\"));\n }"}, {"sha": "b2e1bc515865a6abe751160f56f5e20293416bf3", "filename": "src/test/run-pass/block-arg-can-be-followed-by-block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    fn f(i: fn() -> uint) -> uint { i() }\n+    fn f(i: &fn() -> uint) -> uint { i() }\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n     let z = do do vec::foldl(f, v) |x, _y| { x } { 22u };\n     fail_unless!(z == 22u);"}, {"sha": "ae110a04773742af91b10816b358c4cfbf396a68", "filename": "src/test/run-pass/block-arg-used-as-any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn call_any(f: fn() -> uint) -> uint {\n+fn call_any(f: &fn() -> uint) -> uint {\n     return f();\n }\n "}, {"sha": "b24a655667a6b8727bfeb84703edf127089d8128", "filename": "src/test/run-pass/block-explicit-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n pub fn main() {\n-    fn as_buf<T>(s: ~str, f: fn(~str) -> T) -> T { f(s) }\n+    fn as_buf<T>(s: ~str, f: &fn(~str) -> T) -> T { f(s) }\n     as_buf(~\"foo\", |foo: ~str| -> () log(error, foo) );\n }"}, {"sha": "dc8ad25e27606329e01a0df8f3a8edc64842d737", "filename": "src/test/run-pass/block-fn-coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn force(f: fn() -> int) -> int { return f(); }\n+fn force(f: &fn() -> int) -> int { return f(); }\n pub fn main() {\n     fn f() -> int { return 7; }\n     fail_unless!((force(f) == 7));"}, {"sha": "d0a24f80c0b9074f5c0a399a14b6cb00e0d6d509", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n \n-fn iter_vec<T>(v: ~[T], f: fn(&T)) { for v.each |x| { f(x); } }\n+fn iter_vec<T>(v: ~[T], f: &fn(&T)) { for v.each |x| { f(x); } }\n \n pub fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7];"}, {"sha": "acffb6830deded415928a819f5558b2f205e45f1", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n \n-fn iter_vec<T>(v: ~[T], f: fn(&T)) { for v.each |x| { f(x); } }\n+fn iter_vec<T>(v: ~[T], f: &fn(&T)) { for v.each |x| { f(x); } }\n \n pub fn main() {\n     let v = ~[1, 2, 3, 4, 5];"}, {"sha": "0422be9d333df34e0aa4c0bfd91a6bbb98c4612e", "filename": "src/test/run-pass/borrowck-borrow-from-expr-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn borrow(x: &int, f: fn(x: &int)) {\n+fn borrow(x: &int, f: &fn(x: &int)) {\n     f(x)\n }\n "}, {"sha": "5f5b9c59d7680cfb53092a753d2d1b3b705db879", "filename": "src/test/run-pass/borrowck-mut-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -18,7 +18,7 @@ fn add_int(x: &mut Ints, v: int) {\n     x.values <-> values;\n }\n \n-fn iter_ints(x: &Ints, f: fn(x: &int) -> bool) {\n+fn iter_ints(x: &Ints, f: &fn(x: &int) -> bool) {\n     let l = x.values.len();\n     uint::range(0, l, |i| f(&x.values[i]))\n }"}, {"sha": "795b074e37c4fa82e8c76a9c33c887addec29377", "filename": "src/test/run-pass/borrowck-preserve-box-in-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n // exec-env:RUST_POISON_ON_FREE=1\n \n-fn borrow(x: &int, f: fn(x: &int)) {\n+fn borrow(x: &int, f: &fn(x: &int)) {\n     let before = *x;\n     f(x);\n     let after = *x;"}, {"sha": "11ec78b681cbbb422fadedcbd58391cc66399001", "filename": "src/test/run-pass/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n // exec-env:RUST_POISON_ON_FREE=1\n \n-fn borrow(x: &int, f: fn(x: &int)) {\n+fn borrow(x: &int, f: &fn(x: &int)) {\n     let before = *x;\n     f(x);\n     let after = *x;"}, {"sha": "8d625476f57dc9c99d7bae76d0a01a6e2e5f5c7f", "filename": "src/test/run-pass/borrowck-preserve-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n // exec-env:RUST_POISON_ON_FREE=1\n \n-fn borrow(x: &int, f: fn(x: &int)) {\n+fn borrow(x: &int, f: &fn(x: &int)) {\n     let before = *x;\n     f(x);\n     let after = *x;"}, {"sha": "fcb84eaaf00aba00f93a7ce1a6df25c194be8e82", "filename": "src/test/run-pass/borrowck-preserve-expl-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n // exec-env:RUST_POISON_ON_FREE=1\n \n-fn borrow(x: &int, f: fn(x: &int)) {\n+fn borrow(x: &int, f: &fn(x: &int)) {\n     let before = *x;\n     f(x);\n     let after = *x;"}, {"sha": "87573b84dc885dcbd2255486b2164ed2094a0a52", "filename": "src/test/run-pass/class-impl-parameterized-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -57,17 +57,17 @@ class cat : map<int, bool> {\n   fn [](&&k:int) -> bool { k <= self.meows }\n   fn find(&&k:int) -> Option<bool> { Some(self.get(k)) }\n   fn remove(&&k:int) -> Option<bool> { self.meows -= k; Some(true) }\n-  fn each(f: fn(&&int, &&bool) -> bool) {\n+  fn each(f: &fn(&&int, &&bool) -> bool) {\n     let mut n = int::abs(self.meows);\n     while n > 0 {\n         if !f(n, true) { break; }\n         n -= 1;\n     }\n   }\n-  fn each_key(&&f: fn(&&int) -> bool) {\n+  fn each_key(&&f: &fn(&&int) -> bool) {\n     for self.each |k, _v| { if !f(k) { break; } again;};\n   }\n-  fn each_value(&&f: fn(&&bool) -> bool) {\n+  fn each_value(&&f: &fn(&&bool) -> bool) {\n     for self.each |_k, v| { if !f(v) { break; } again;};\n   }\n   fn clear() { }"}, {"sha": "6cb0749ddb57fd4d106e45452bb546b497854797", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -50,7 +50,7 @@ pub impl<T> cat<T> {\n }\n \n impl<T> BaseIter<(int, &'self T)> for cat<T> {\n-    pure fn each(&self, f: fn(&(int, &'self T)) -> bool) {\n+    pure fn each(&self, f: &fn(&(int, &'self T)) -> bool) {\n         let mut n = int::abs(self.meows);\n         while n > 0 {\n             if !f(&(n, &self.name)) { break; }\n@@ -73,11 +73,11 @@ impl<T> Mutable for cat<T> {\n impl<T> Map<int, T> for cat<T> {\n     pure fn contains_key(&self, k: &int) -> bool { *k <= self.meows }\n \n-    pure fn each_key(&self, f: fn(v: &int) -> bool) {\n+    pure fn each_key(&self, f: &fn(v: &int) -> bool) {\n         for self.each |&(k, _)| { if !f(&k) { break; } loop;};\n     }\n \n-    pure fn each_value(&self, f: fn(v: &T) -> bool) {\n+    pure fn each_value(&self, f: &fn(v: &T) -> bool) {\n         for self.each |&(_, v)| { if !f(v) { break; } loop;};\n     }\n "}, {"sha": "e525312d6da5b6d7c595727b4e555008967e1895", "filename": "src/test/run-pass/class-trait-bounded-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -22,9 +22,9 @@ class keys<K:Copy,V:Copy,M:Copy + map<K,V>>\n         self.map = map;\n     }\n \n-    fn each(blk: fn(K) -> bool) { self.map.each(|k, _v| blk(k) ) }\n+    fn each(blk: &fn(K) -> bool) { self.map.each(|k, _v| blk(k) ) }\n     fn size_hint() -> Option<uint> { Some(self.map.size()) }\n-    fn eachi(blk: fn(uint, K) -> bool) { iter::eachi(self, blk) }\n+    fn eachi(blk: &fn(uint, K) -> bool) { iter::eachi(self, blk) }\n }\n \n pub fn main() {"}, {"sha": "e61636a323a65a556c5262455debda938579eb32", "filename": "src/test/run-pass/closure-inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fclosure-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fclosure-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-inference.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -12,7 +12,7 @@\n \n fn foo(i: int) -> int { i + 1 }\n \n-fn apply<A>(f: fn(A) -> A, v: A) -> A { f(v) }\n+fn apply<A>(f: &fn(A) -> A, v: A) -> A { f(v) }\n \n pub fn main() {\n     let f = {|i| foo(i)};"}, {"sha": "c86c1768111f70776b2da2b7eb34e10177650dab", "filename": "src/test/run-pass/do-for-empty-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fdo-for-empty-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fdo-for-empty-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo-for-empty-args.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -11,7 +11,7 @@\n // no-reformat\n // Testing various forms of `do` and `for` with empty arg lists\n \n-fn f(f: fn() -> bool) {\n+fn f(f: &fn() -> bool) {\n }\n \n pub fn main() {"}, {"sha": "41686cf5b3736baf5eb32c10cd07ad0653ecf927", "filename": "src/test/run-pass/do-pure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fdo-pure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fdo-pure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo-pure.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pure fn f(f: fn()) {\n+pure fn f(f: &fn()) {\n }\n \n pure fn g() {"}, {"sha": "9ab6af0ac276e3094e1e08cf046be0bf9d69d172", "filename": "src/test/run-pass/fn-assign-managed-to-bare-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Ffn-assign-managed-to-bare-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Ffn-assign-managed-to-bare-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-assign-managed-to-bare-1.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -15,6 +15,6 @@ fn add(n: int) -> @fn(int) -> int {\n \n pub fn main() {\n       fail_unless!(add(3)(4) == 7);\n-      let add3 : fn(int)->int = add(3);\n+      let add3 : &fn(int)->int = add(3);\n       fail_unless!(add3(4) == 7);\n }"}, {"sha": "db7604d11484d583b7c67d31098363be64af10e1", "filename": "src/test/run-pass/fn-bare-coerce-to-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Ffn-bare-coerce-to-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Ffn-bare-coerce-to-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-coerce-to-block.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n fn bare() {}\n \n-fn likes_block(f: fn()) { f() }\n+fn likes_block(f: &fn()) { f() }\n \n pub fn main() {\n     likes_block(bare);"}, {"sha": "3f5d3818e1c12d57fccefaa65842569c44cef3b9", "filename": "src/test/run-pass/fn-pattern-expected-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let f: fn((int,int)) = |(x, y)| {\n+    let f: &fn((int,int)) = |(x, y)| {\n         fail_unless!(x == 1);\n         fail_unless!(y == 2);\n     };"}, {"sha": "a94131b36c051db5d23d630c8fb46dcdf91a96b9", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -12,7 +12,7 @@\n \n \n // -*- rust -*-\n-fn two(it: fn(int)) { it(0); it(1); }\n+fn two(it: &fn(int)) { it(0); it(1); }\n \n pub fn main() {\n     let mut a: ~[int] = ~[-1, -1, -1, -1];"}, {"sha": "1a71cf52de25946971b82ee3a762e1982efa480f", "filename": "src/test/run-pass/foreach-put-structured.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n \n \n-fn pairs(it: fn((int, int))) {\n+fn pairs(it: &fn((int, int))) {\n     let mut i: int = 0;\n     let mut j: int = 0;\n     while i < 10 { it((i, j)); i += 1; j += i; }"}, {"sha": "1c0b28982dbe1795389cef784c292eff8c9bd5d7", "filename": "src/test/run-pass/foreach-simple-outer-slot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -20,7 +20,7 @@ pub fn main() {\n     fail_unless!((sum == 45));\n }\n \n-fn first_ten(it: fn(int)) {\n+fn first_ten(it: &fn(int)) {\n     let mut i: int = 0;\n     while i < 10 { debug!(\"first_ten\"); it(i); i = i + 1; }\n }"}, {"sha": "76ec34330d4b8f23fe8e2495e55781e60795aea3", "filename": "src/test/run-pass/issue-1458.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fissue-1458.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fissue-1458.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1458.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn plus_one(f: fn() -> int) -> int {\n+fn plus_one(f: &fn() -> int) -> int {\n   return f() + 1;\n }\n "}, {"sha": "ac680d3d12e417ec3e7f806740f910ede98dc0cb", "filename": "src/test/run-pass/issue-2185.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2185.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -15,15 +15,15 @@\n // warrant still having a test, so I inlined the old definitions.\n \n trait iterable<A> {\n-    fn iter(blk: fn(A));\n+    fn iter(blk: &fn(A));\n }\n \n impl<A> iterable<A> for @fn(&fn(A)) {\n-    fn iter(blk: fn(A)) { self(blk); }\n+    fn iter(blk: &fn(A)) { self(blk); }\n }\n \n impl iterable<uint> for @fn(&fn(uint)) {\n-    fn iter(blk: fn(&&v: uint)) { self( |i| blk(i) ) }\n+    fn iter(blk: &fn(&&v: uint)) { self( |i| blk(i) ) }\n }\n \n fn filter<A,IA:iterable<A>>(self: IA, prd: @fn(A) -> bool, blk: &fn(A)) {"}, {"sha": "138860ce72d1f6449f96d7ee748e1203733d779f", "filename": "src/test/run-pass/issue-2487-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fissue-2487-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fissue-2487-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2487-a.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -32,7 +32,7 @@ fn socket() -> socket {\n     }\n }\n \n-fn closure(f: fn()) { f() }\n+fn closure(f: &fn()) { f() }\n \n fn setsockopt_bytes(_sock: int) { }\n "}, {"sha": "af3e8e9c7a2b59340d44a89684c637461f61ff63", "filename": "src/test/run-pass/issue-2611.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2611.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -11,11 +11,11 @@\n use core::iter::BaseIter;\n \n trait FlatMapToVec<A> {\n-  fn flat_map_to_vec<B, IB:BaseIter<B>>(&self, op: fn(&A) -> IB) -> ~[B];\n+  fn flat_map_to_vec<B, IB:BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B];\n }\n \n impl<A:Copy> FlatMapToVec<A> for ~[A] {\n-   fn flat_map_to_vec<B, IB:BaseIter<B>>(&self, op: fn(&A) -> IB) -> ~[B] {\n+   fn flat_map_to_vec<B, IB:BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B] {\n      iter::flat_map_to_vec(self, op)\n    }\n }"}, {"sha": "8d62da9efad427991a4f56e8834821e088ff97a2", "filename": "src/test/run-pass/issue-3874.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fissue-3874.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fissue-3874.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3874.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -11,7 +11,7 @@\n // xfail-test\n enum PureCounter { PureCounter(uint) }\n \n-pure fn each(self: PureCounter, blk: fn(v: &uint)) {\n+pure fn each(self: PureCounter, blk: &fn(v: &uint)) {\n     let PureCounter(ref x) = self;\n     blk(x);\n }"}, {"sha": "16e8fa18c2a0247da7f013a3d608965a04f7c4e9", "filename": "src/test/run-pass/issue-868.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fissue-868.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fissue-868.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-868.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f<T>(g: fn() -> T) -> T { g() }\n+fn f<T>(g: &fn() -> T) -> T { g() }\n \n pub fn main() {\n   let _x = f( | | { 10 });"}, {"sha": "d2c51df2b8fb3e7bbde64436d3d82dc59eea59a7", "filename": "src/test/run-pass/issue-912.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fissue-912.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fissue-912.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-912.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // xfail-test\n-fn find<T>(_f: fn(@T) -> bool, _v: [@T]) {}\n+fn find<T>(_f: &fn(@T) -> bool, _v: [@T]) {}\n \n pub fn main() {\n     let x = 10, arr = [];"}, {"sha": "0ec8eea52365f2e07063e0c5bee054c85905dced", "filename": "src/test/run-pass/iter-range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fiter-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fiter-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-range.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n \n \n-fn range(a: int, b: int, it: fn(int)) {\n+fn range(a: int, b: int, it: &fn(int)) {\n     fail_unless!((a < b));\n     let mut i: int = a;\n     while i < b { it(i); i += 1; }"}, {"sha": "e2dbf7d29db1931aba8850a272009d378ddb4955", "filename": "src/test/run-pass/last-use-in-block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Flast-use-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Flast-use-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-in-block.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,16 +10,16 @@\n \n // Issue #1818\n \n-fn lp<T>(s: ~str, f: fn(~str) -> T) -> T {\n+fn lp<T>(s: ~str, f: &fn(~str) -> T) -> T {\n     while false {\n         let r = f(s);\n         return (r);\n     }\n     fail!();\n }\n \n-fn apply<T>(s: ~str, f: fn(~str) -> T) -> T {\n-    fn g<T>(s: ~str, f: fn(~str) -> T) -> T {f(s)}\n+fn apply<T>(s: ~str, f: &fn(~str) -> T) -> T {\n+    fn g<T>(s: ~str, f: &fn(~str) -> T) -> T {f(s)}\n     g(s, |v| { let r = f(v); r })\n }\n "}, {"sha": "b21b3b6c7fb26ed69499ee0d00a63f0a9d5ebea2", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -11,23 +11,23 @@\n // xfail-fast\n \n trait vec_monad<A> {\n-    fn bind<B:Copy>(f: fn(&A) -> ~[B]) -> ~[B];\n+    fn bind<B:Copy>(f: &fn(&A) -> ~[B]) -> ~[B];\n }\n \n impl<A> vec_monad<A> for ~[A] {\n-    fn bind<B:Copy>(f: fn(&A) -> ~[B]) -> ~[B] {\n+    fn bind<B:Copy>(f: &fn(&A) -> ~[B]) -> ~[B] {\n         let mut r = ~[];\n         for self.each |elt| { r += f(elt); }\n         r\n     }\n }\n \n trait option_monad<A> {\n-    fn bind<B>(f: fn(&A) -> Option<B>) -> Option<B>;\n+    fn bind<B>(f: &fn(&A) -> Option<B>) -> Option<B>;\n }\n \n impl<A> option_monad<A> for Option<A> {\n-    fn bind<B>(f: fn(&A) -> Option<B>) -> Option<B> {\n+    fn bind<B>(f: &fn(&A) -> Option<B>) -> Option<B> {\n         match self {\n           Some(ref a) => { f(a) }\n           None => { None }"}, {"sha": "f61ffc1bc3e0047c630f34cefd611b9c34f3eb8c", "filename": "src/test/run-pass/mut-function-arguments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fmut-function-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fmut-function-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmut-function-arguments.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -14,7 +14,7 @@ fn f(mut y: ~int) {\n }\n \n fn g() {\n-    let frob: fn(~int) = |mut q| { *q = 2; fail_unless!(*q == 2); };\n+    let frob: &fn(~int) = |mut q| { *q = 2; fail_unless!(*q == 2); };\n     let w = ~37;\n     frob(w);\n "}, {"sha": "076e019bab46d0dd8fe402a5e57a56de19982e6d", "filename": "src/test/run-pass/newlambdas.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fnewlambdas.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fnewlambdas.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewlambdas.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -12,7 +12,7 @@\n \n fn f(i: int, f: &fn(int) -> int) -> int { f(i) }\n \n-fn g(g: fn()) { }\n+fn g(g: &fn()) { }\n \n fn ff() -> @fn(int) -> int {\n     return |x| x + 1;"}, {"sha": "330a9b9de7b8f72a0074367d456c9ff73386c205", "filename": "src/test/run-pass/non-legacy-modes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fnon-legacy-modes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fnon-legacy-modes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-legacy-modes.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -12,7 +12,7 @@ struct X {\n     repr: int\n }\n \n-fn apply<T>(x: T, f: fn(T)) {\n+fn apply<T>(x: T, f: &fn(T)) {\n     f(x);\n }\n "}, {"sha": "20daa894bc1288661e69f68c631364d4c8c0039f", "filename": "src/test/run-pass/pipe-bank-proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -49,7 +49,7 @@ macro_rules! move_it (\n )\n \n fn switch<T:Owned,U>(+endp: pipes::RecvPacket<T>,\n-                      f: fn(+v: Option<T>) -> U) -> U {\n+                      f: &fn(+v: Option<T>) -> U) -> U {\n     f(pipes::try_recv(endp))\n }\n "}, {"sha": "d546909de8e1edaa5439dd7ee562210d2d16f435", "filename": "src/test/run-pass/purity-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fpurity-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fpurity-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpurity-infer.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-fn something(f: pure fn()) { f(); }\n+fn something(f: &pure fn()) { f(); }\n pub fn main() {\n     something(|| log(error, \"hi!\") );\n }"}, {"sha": "90aaafd247ba615e79d2fc806a61f2a5c0db9b56", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -19,7 +19,7 @@ use intrinsic::{TyDesc, get_tydesc, visit_tydesc, TyVisitor};\n \n /// Trait for visitor that wishes to reflect on data.\n trait movable_ptr {\n-    fn move_ptr(adjustment: fn(*c_void) -> *c_void);\n+    fn move_ptr(adjustment: &fn(*c_void) -> *c_void);\n }\n \n /// Helper function for alignment calculation.\n@@ -479,7 +479,7 @@ struct Stuff {\n }\n \n pub impl my_visitor {\n-    fn get<T>(f: fn(T)) {\n+    fn get<T>(f: &fn(T)) {\n         unsafe {\n             f(*(self.ptr1 as *T));\n         }\n@@ -498,7 +498,7 @@ pub impl my_visitor {\n struct Inner<V> { inner: V }\n \n impl movable_ptr for my_visitor {\n-    fn move_ptr(adjustment: fn(*c_void) -> *c_void) {\n+    fn move_ptr(adjustment: &fn(*c_void) -> *c_void) {\n         self.ptr1 = adjustment(self.ptr1);\n         self.ptr2 = adjustment(self.ptr2);\n     }"}, {"sha": "a995b3d96935204528131b14b3039809e3c4106d", "filename": "src/test/run-pass/regions-fn-subtyping-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fregions-fn-subtyping-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fregions-fn-subtyping-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-fn-subtyping-2.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -15,13 +15,13 @@\n // Here, `f` is a function that takes a pointer `x` and a function\n // `g`, where `g` requires its argument `y` to be in the same region\n // that `x` is in.\n-fn has_same_region(f: fn(x: &a.int, g: fn(y: &a.int))) {\n+fn has_same_region(f: &fn(x: &a.int, g: &fn(y: &a.int))) {\n     // `f` should be the type that `wants_same_region` wants, but\n     // right now the compiler complains that it isn't.\n     wants_same_region(f);\n }\n \n-fn wants_same_region(_f: fn(x: &b.int, g: fn(y: &b.int))) { \n+fn wants_same_region(_f: &fn(x: &b.int, g: &fn(y: &b.int))) { \n }\n \n pub fn main() {"}, {"sha": "dc38a7baacd21304f139491e970717786418f5ec", "filename": "src/test/run-pass/regions-infer-call-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fregions-infer-call-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fregions-infer-call-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-call-2.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n fn takes_two(x: &int, y: &int) -> int { *x + *y }\n \n-fn with<T>(f: fn(x: &int) -> T) -> T {\n+fn with<T>(f: &fn(x: &int) -> T) -> T {\n     f(&20)\n }\n "}, {"sha": "0049653dea9d3ac45f419ffc3ce413604a9b8e15", "filename": "src/test/run-pass/regions-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fregions-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fregions-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-params.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -12,7 +12,7 @@\n \n fn region_identity(x: &r/uint) -> &r/uint { x }\n \n-fn apply<T>(t: T, f: fn(T) -> T) -> T { f(t) }\n+fn apply<T>(t: T, f: &fn(T) -> T) -> T { f(t) }\n \n fn parameterized(x: &uint) -> uint {\n     let z = apply(x, ({|y|"}, {"sha": "6fe7575884249d976bfff89d8c992d01b111ce2e", "filename": "src/test/run-pass/ret-break-cont-in-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -12,7 +12,7 @@\n \n use core::cmp::Eq;\n \n-fn iter<T>(v: ~[T], it: fn(&T) -> bool) {\n+fn iter<T>(v: ~[T], it: &fn(&T) -> bool) {\n     let mut i = 0u, l = v.len();\n     while i < l {\n         if !it(&v[i]) { break; }"}, {"sha": "0d9d01f9e700fb1e5de0028950a788347d9c0f46", "filename": "src/test/run-pass/sendfn-is-a-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fsendfn-is-a-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fsendfn-is-a-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-is-a-block.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n \n-fn test(f: fn(uint) -> uint) -> uint {\n+fn test(f: &fn(uint) -> uint) -> uint {\n     return f(22u);\n }\n "}, {"sha": "2ee6f631ea5211baaa2bdd1545ca45bd4ce4222b", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -26,27 +26,27 @@ mod b {\n \n trait uint_utils {\n     fn str() -> ~str;\n-    fn multi(f: fn(uint));\n+    fn multi(f: &fn(uint));\n }\n \n impl uint_utils for uint {\n     fn str() -> ~str { uint::to_str(self) }\n-    fn multi(f: fn(uint)) {\n+    fn multi(f: &fn(uint)) {\n         let mut c = 0u;\n         while c < self { f(c); c += 1u; }\n     }\n }\n \n trait vec_utils<T> {\n     fn length_() -> uint;\n-    fn iter_(f: fn(&T));\n-    fn map_<U:Copy>(f: fn(&T) -> U) -> ~[U];\n+    fn iter_(f: &fn(&T));\n+    fn map_<U:Copy>(f: &fn(&T) -> U) -> ~[U];\n }\n \n impl<T> vec_utils<T> for ~[T] {\n     fn length_() -> uint { vec::len(self) }\n-    fn iter_(f: fn(&T)) { for self.each |x| { f(x); } }\n-    fn map_<U:Copy>(f: fn(&T) -> U) -> ~[U] {\n+    fn iter_(f: &fn(&T)) { for self.each |x| { f(x); } }\n+    fn map_<U:Copy>(f: &fn(&T) -> U) -> ~[U] {\n         let mut r = ~[];\n         for self.each |elt| { r += ~[f(elt)]; }\n         r"}, {"sha": "0c6359375d306e85ac29492b32dbfc6a7561031c", "filename": "src/test/run-pass/static-method-test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -36,33 +36,33 @@ impl bool_like for int {\n // A trait for sequences that can be constructed imperatively.\n trait buildable<A> {\n      static pure fn build_sized(size: uint,\n-                                builder: fn(push: pure fn(+v: A))) -> Self;\n+                                builder: &fn(push: &pure fn(+v: A))) -> Self;\n }\n \n \n impl<A> buildable<A> for @[A] {\n     #[inline(always)]\n      static pure fn build_sized(size: uint,\n-                                builder: fn(push: pure fn(+v: A))) -> @[A] {\n+                                builder: &fn(push: &pure fn(+v: A))) -> @[A] {\n          at_vec::build_sized(size, builder)\n      }\n }\n impl<A> buildable<A> for ~[A] {\n     #[inline(always)]\n      static pure fn build_sized(size: uint,\n-                                builder: fn(push: pure fn(+v: A))) -> ~[A] {\n+                                builder: &fn(push: &pure fn(+v: A))) -> ~[A] {\n          vec::build_sized(size, builder)\n      }\n }\n \n #[inline(always)]\n-pure fn build<A, B: buildable<A>>(builder: fn(push: pure fn(+v: A))) -> B {\n+pure fn build<A, B: buildable<A>>(builder: &fn(push: &pure fn(+v: A))) -> B {\n     buildable::build_sized(4, builder)\n }\n \n /// Apply a function to each element of an iterable and return the results\n fn map<T, IT: BaseIter<T>, U, BU: buildable<U>>\n-    (v: IT, f: fn(T) -> U) -> BU {\n+    (v: IT, f: &fn(T) -> U) -> BU {\n     do build |push| {\n         for v.each() |elem| {\n             push(f(*elem));"}, {"sha": "39651f86e227bad6ef20ada58d51b06121cd0e01", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -40,7 +40,7 @@ fn notify(ch: Chan<bool>, v: @mut bool) -> notify {\n }\n \n fn joinable(f: ~fn()) -> Port<bool> {\n-    fn wrapper(c: Chan<bool>, f: fn()) {\n+    fn wrapper(c: Chan<bool>, f: &fn()) {\n         let b = @mut false;\n         error!(\"wrapper: task=%? allocated v=%x\",\n                task::get_task(),"}, {"sha": "7b8ebe6d34cab21d5a4dab5527ef145d28afd506", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -24,10 +24,10 @@ impl to_str for () {\n }\n \n trait map<T> {\n-    fn map<U:Copy>(f: fn(&T) -> U) -> ~[U];\n+    fn map<U:Copy>(f: &fn(&T) -> U) -> ~[U];\n }\n impl<T> map<T> for ~[T] {\n-    fn map<U:Copy>(f: fn(&T) -> U) -> ~[U] {\n+    fn map<U:Copy>(f: &fn(&T) -> U) -> ~[U] {\n         let mut r = ~[];\n         for self.each |x| { r += ~[f(x)]; }\n         r"}, {"sha": "d600ff25f029873571ad984483323439343d385b", "filename": "src/test/run-pass/type-params-in-for-each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -13,7 +13,7 @@ struct S<T> {\n     b: uint,\n }\n \n-fn range(lo: uint, hi: uint, it: fn(uint)) {\n+fn range(lo: uint, hi: uint, it: &fn(uint)) {\n     let mut lo_ = lo;\n     while lo_ < hi { it(lo_); lo_ += 1u; }\n }"}, {"sha": "649f424ec36bea8afc4447f97ca19dcf11782f78", "filename": "src/test/run-pass/unnamed_argument_mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Funnamed_argument_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18f7854578e8c2e1d7dce90db6e3b5cf9befba9/src%2Ftest%2Frun-pass%2Funnamed_argument_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funnamed_argument_mode.rs?ref=d18f7854578e8c2e1d7dce90db6e3b5cf9befba9", "patch": "@@ -3,7 +3,7 @@ fn good(a: &int) {\n \n // unnamed argument &int is now parse x: &int\n \n-fn called(f: fn(&int)) {\n+fn called(f: &fn(&int)) {\n }\n \n pub fn main() {"}]}