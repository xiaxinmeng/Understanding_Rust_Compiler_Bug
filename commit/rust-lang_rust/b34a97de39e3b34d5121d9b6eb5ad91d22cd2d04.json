{"sha": "b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNGE5N2RlMzllM2IzNGQ1MTIxZDliNmViNWFkOTFkMjJjZDJkMDQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-09T16:56:35Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-09T18:37:52Z"}, "message": "Start to check expr_check and expr_call constraints in typestate\n\nStart writing the cases for expr_check and expr_call to take\npredicates into account, but this isn't working yet.", "tree": {"sha": "2f776347ae38f73017e19ac36f38edcda4a56994", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f776347ae38f73017e19ac36f38edcda4a56994"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04", "html_url": "https://github.com/rust-lang/rust/commit/b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17ff2a0d7960c58b12898cb0142917a0cffb7559", "url": "https://api.github.com/repos/rust-lang/rust/commits/17ff2a0d7960c58b12898cb0142917a0cffb7559", "html_url": "https://github.com/rust-lang/rust/commit/17ff2a0d7960c58b12898cb0142917a0cffb7559"}], "stats": {"total": 64, "additions": 61, "deletions": 3}, "files": [{"sha": "8bafd1f4bc0f0000542c18133625f4250b1d2b1b", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04", "patch": "@@ -89,6 +89,11 @@ fn pps_len(&pre_and_post p) -> uint {\n   ret p.precondition.nbits;\n }\n \n+fn require(uint i, &pre_and_post p) -> () {\n+  // sets the ith bit in p's pre\n+  bitv::set(p.precondition, i, true);\n+}\n+\n fn require_and_preserve(uint i, &pre_and_post p) -> () {\n   // sets the ith bit in p's pre and post\n   bitv::set(p.precondition, i, true);"}, {"sha": "23c820f565c1f67373281e538459d28a3fd79b25", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04", "patch": "@@ -144,7 +144,6 @@ fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n }\n \n fn gen(&fn_ctxt fcx, &ann a, &def_id id, &constr_occ o) -> bool {\n-  log \"gen\";\n   ret set_in_postcond(bit_num(fcx, id, o),\n                       (ann_to_ts_ann(fcx.ccx, a)).conditions);\n }"}, {"sha": "80d548d4c8b95176faf8f48958ffb66a362fb53c", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04", "patch": "@@ -4,12 +4,15 @@ import std::option;\n import std::option::none;\n import std::option::some;\n \n+// FIXME: needs to be tstate::ann because ann is also a type name...\n+// that's probably a bug.\n import tstate::ann::pre_and_post;\n import tstate::ann::get_post;\n import tstate::ann::postcond;\n import tstate::ann::true_precond;\n import tstate::ann::false_postcond;\n import tstate::ann::empty_poststate;\n+import tstate::ann::require;\n import tstate::ann::require_and_preserve;\n import tstate::ann::union;\n import tstate::ann::intersect;\n@@ -22,6 +25,7 @@ import aux::fn_ctxt;\n import aux::occ_init;\n import aux::num_constraints;\n import aux::constraint;\n+import aux::constr_occ;\n import aux::expr_pp;\n import aux::stmt_pp;\n import aux::block_pp;\n@@ -41,6 +45,11 @@ import aux::ann_to_def_strict;\n import aux::ann_to_ts_ann;\n import aux::set_postcond_false;\n import aux::controlflow_expr;\n+import aux::expr_to_constr;\n+import aux::constraint_info;\n+import aux::constr_to_constr_occ;\n+import aux::constraints_expr;\n+import aux::substitute_constr_args;\n \n import bitvectors::seq_preconds;\n import bitvectors::union_postconds;\n@@ -52,6 +61,7 @@ import bitvectors::gen;\n import front::ast::*;\n \n import middle::ty::expr_ann;\n+import middle::ty::lookup_fn_decl;\n \n import util::common::new_def_hash;\n import util::common::decl_lhs;\n@@ -210,6 +220,38 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             auto args = vec::clone[@expr](operands);\n             vec::push[@expr](args, operator);\n             find_pre_post_exprs(fcx, args, a);\n+            \n+            /* see if the call has any constraints on its in type */\n+            let option::t[tup(fn_decl, def_id)] decl_and_id =\n+                lookup_fn_decl(fcx.ccx.tcx, expr_ann(operator));\n+            alt (decl_and_id) {\n+                case (some(?p)) {\n+                    log(\"known function: \" );\n+                    log_expr(*operator);\n+                    let def_id f_id = p._1;\n+                    let fn_decl f_decl = p._0;\n+                    auto pp = expr_pp(fcx.ccx, e);\n+                    for (@constr c in constraints_expr(fcx.ccx, operator)) {\n+                        auto i = bit_num(fcx, f_id,\n+                           substitute_constr_args(fcx.ccx.tcx, operands,\n+                                                  f_decl.inputs, c));\n+                        require(i, pp);\n+                    }\n+                }\n+                // FIXME: Soundness? If a function is constrained...\n+                // shouldn't be able to pass it as an argument\n+                // But typechecking guarantees that. However, we could\n+                // have an unknown function w/ a constrained type =>\n+                // no decl... but need to know the argument names.\n+                // Fix that and then make a test w/ a higher-order\n+                // constrained function.\n+                case (_) { \n+                    log(\"unknown function: \" );\n+                    log_expr(*operator);\n+                    /* unknown function -- do nothing */ }\n+            }\n+            // FIXME: constraints on result type\n+            \n             /* if this is a failing call, its postcondition sets everything */\n             alt (controlflow_expr(fcx.ccx, operator)) {\n                 case (noreturn) {\n@@ -471,9 +513,14 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             copy_pre_post(fcx.ccx, a, p);\n         }\n         case (expr_check(?p, ?a)) {\n-            /* will need to change when we support arbitrary predicates... */\n+            /* FIXME: Can we bypass this by having a\n+             node-id-to-constr_occ table? */\n             find_pre_post_expr(fcx, p);\n             copy_pre_post(fcx.ccx, a, p);\n+            /* predicate p holds after this expression executes */\n+            let constraint_info c = expr_to_constr(fcx.ccx.tcx, p);\n+            let constr_occ o = constr_to_constr_occ(fcx.ccx.tcx, c.c.node);\n+            gen(fcx, a, c.id, o);\n         }\n         case(expr_bind(?operator, ?maybe_args, ?a)) {\n             auto args = vec::cat_options[@expr](maybe_args);"}, {"sha": "f47076cc3243175fd043129689fc973b86dcadea", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=b34a97de39e3b34d5121d9b6eb5ad91d22cd2d04", "patch": "@@ -49,6 +49,10 @@ import aux::block_states;\n import aux::controlflow_expr;\n import aux::ann_to_def;\n import aux::occ_init;\n+import aux::expr_to_constr;\n+import aux::constraint_info;\n+import aux::constr_to_constr_occ;\n+import aux::constr_occ;\n \n import bitvectors::seq_preconds;\n import bitvectors::union_postconds;\n@@ -521,8 +525,11 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n     case (expr_check(?p, ?a)) {\n         changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n         changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n-        /* FIXME: update the postcondition to reflect that p holds */\n         changed = extend_poststate_ann(fcx.ccx, a, pres) || changed;\n+        /* predicate p holds after this expression executes */\n+        let constraint_info c = expr_to_constr(fcx.ccx.tcx, p);\n+        let constr_occ o = constr_to_constr_occ(fcx.ccx.tcx, c.c.node);\n+        changed = gen_poststate(fcx, a, c.id, o) || changed;\n         ret changed;\n     }\n     case (expr_break(?a)) {"}]}