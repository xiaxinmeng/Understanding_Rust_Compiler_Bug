{"sha": "b82899ad764502eab0ee1410afb42888bbd5099e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4Mjg5OWFkNzY0NTAyZWFiMGVlMTQxMGFmYjQyODg4YmJkNTA5OWU=", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2020-07-20T16:23:32Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2020-07-20T16:30:47Z"}, "message": "Use expect in coercion tests", "tree": {"sha": "d52e74969ac7a710cbf29adf0591ed59edc18a4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d52e74969ac7a710cbf29adf0591ed59edc18a4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b82899ad764502eab0ee1410afb42888bbd5099e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b82899ad764502eab0ee1410afb42888bbd5099e", "html_url": "https://github.com/rust-lang/rust/commit/b82899ad764502eab0ee1410afb42888bbd5099e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b82899ad764502eab0ee1410afb42888bbd5099e/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "130e7632acef435caa9bf56e7333e4c28c7dffc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/130e7632acef435caa9bf56e7333e4c28c7dffc7", "html_url": "https://github.com/rust-lang/rust/commit/130e7632acef435caa9bf56e7333e4c28c7dffc7"}], "stats": {"total": 1358, "additions": 684, "deletions": 674}, "files": [{"sha": "7704774b724197449d87dc6eec749743eafa7379", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 684, "deletions": 674, "changes": 1358, "blob_url": "https://github.com/rust-lang/rust/blob/b82899ad764502eab0ee1410afb42888bbd5099e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b82899ad764502eab0ee1410afb42888bbd5099e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=b82899ad764502eab0ee1410afb42888bbd5099e", "patch": "@@ -1,10 +1,9 @@\n-use insta::assert_snapshot;\n use test_utils::mark;\n \n-use super::infer_with_mismatches;\n+use expect::{expect, Expect};\n \n // Infer with some common definitions and impls.\n-fn infer(source: &str) -> String {\n+fn check_infer(ra_fixture: &str, expect: Expect) {\n     let defs = r#\"\n         #[lang = \"sized\"]\n         pub trait Sized {}\n@@ -18,689 +17,700 @@ fn infer(source: &str) -> String {\n     \"#;\n \n     // Append to the end to keep positions unchanged.\n-    super::infer(&format!(\"{}{}\", source, defs))\n+    let mut actual = super::infer(&format!(\"{}{}\", ra_fixture, defs));\n+    actual.push('\\n');\n+    expect.assert_eq(&actual);\n+}\n+\n+fn check_infer_with_mismatches(ra_fixture: &str, expect: Expect) {\n+    let mut actual = super::infer_with_mismatches(ra_fixture, true);\n+    actual.push('\\n');\n+    expect.assert_eq(&actual);\n }\n \n #[test]\n fn infer_block_expr_type_mismatch() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn test() {\n-    let a: i32 = { 1i64 };\n-}\n-\"#),\n-        @r###\"\n-    10..40 '{     ...4 }; }': ()\n-    20..21 'a': i32\n-    29..37 '{ 1i64 }': i64\n-    31..35 '1i64': i64\n-    \"###);\n+    check_infer(\n+        r\"\n+        fn test() {\n+            let a: i32 = { 1i64 };\n+        }\n+        \",\n+        expect![[r\"\n+            10..40 '{     ...4 }; }': ()\n+            20..21 'a': i32\n+            29..37 '{ 1i64 }': i64\n+            31..35 '1i64': i64\n+        \"]],\n+    );\n }\n \n #[test]\n fn coerce_places() {\n-    assert_snapshot!(\n-        infer(r#\"\n-struct S<T> { a: T }\n+    check_infer(\n+        r\"\n+        struct S<T> { a: T }\n \n-fn f<T>(_: &[T]) -> T { loop {} }\n-fn g<T>(_: S<&[T]>) -> T { loop {} }\n+        fn f<T>(_: &[T]) -> T { loop {} }\n+        fn g<T>(_: S<&[T]>) -> T { loop {} }\n \n-fn gen<T>() -> *mut [T; 2] { loop {} }\n-fn test1<U>() -> *mut [U] {\n-    gen()\n-}\n+        fn gen<T>() -> *mut [T; 2] { loop {} }\n+        fn test1<U>() -> *mut [U] {\n+            gen()\n+        }\n \n-fn test2() {\n-    let arr: &[u8; 1] = &[1];\n+        fn test2() {\n+            let arr: &[u8; 1] = &[1];\n \n-    let a: &[_] = arr;\n-    let b = f(arr);\n-    let c: &[_] = { arr };\n-    let d = g(S { a: arr });\n-    let e: [&[_]; 1] = [arr];\n-    let f: [&[_]; 2] = [arr; 2];\n-    let g: (&[_], &[_]) = (arr, arr);\n-}\n-\"#),\n-        @r###\"\n-    30..31 '_': &[T]\n-    44..55 '{ loop {} }': T\n-    46..53 'loop {}': !\n-    51..53 '{}': ()\n-    64..65 '_': S<&[T]>\n-    81..92 '{ loop {} }': T\n-    83..90 'loop {}': !\n-    88..90 '{}': ()\n-    121..132 '{ loop {} }': *mut [T; _]\n-    123..130 'loop {}': !\n-    128..130 '{}': ()\n-    159..172 '{     gen() }': *mut [U]\n-    165..168 'gen': fn gen<U>() -> *mut [U; _]\n-    165..170 'gen()': *mut [U; _]\n-    185..419 '{     ...rr); }': ()\n-    195..198 'arr': &[u8; _]\n-    211..215 '&[1]': &[u8; _]\n-    212..215 '[1]': [u8; _]\n-    213..214 '1': u8\n-    226..227 'a': &[u8]\n-    236..239 'arr': &[u8; _]\n-    249..250 'b': u8\n-    253..254 'f': fn f<u8>(&[u8]) -> u8\n-    253..259 'f(arr)': u8\n-    255..258 'arr': &[u8; _]\n-    269..270 'c': &[u8]\n-    279..286 '{ arr }': &[u8]\n-    281..284 'arr': &[u8; _]\n-    296..297 'd': u8\n-    300..301 'g': fn g<u8>(S<&[u8]>) -> u8\n-    300..315 'g(S { a: arr })': u8\n-    302..314 'S { a: arr }': S<&[u8]>\n-    309..312 'arr': &[u8; _]\n-    325..326 'e': [&[u8]; _]\n-    340..345 '[arr]': [&[u8]; _]\n-    341..344 'arr': &[u8; _]\n-    355..356 'f': [&[u8]; _]\n-    370..378 '[arr; 2]': [&[u8]; _]\n-    371..374 'arr': &[u8; _]\n-    376..377 '2': usize\n-    388..389 'g': (&[u8], &[u8])\n-    406..416 '(arr, arr)': (&[u8], &[u8])\n-    407..410 'arr': &[u8; _]\n-    412..415 'arr': &[u8; _]\n-    \"###\n+            let a: &[_] = arr;\n+            let b = f(arr);\n+            let c: &[_] = { arr };\n+            let d = g(S { a: arr });\n+            let e: [&[_]; 1] = [arr];\n+            let f: [&[_]; 2] = [arr; 2];\n+            let g: (&[_], &[_]) = (arr, arr);\n+        }\n+        \",\n+        expect![[r\"\n+            30..31 '_': &[T]\n+            44..55 '{ loop {} }': T\n+            46..53 'loop {}': !\n+            51..53 '{}': ()\n+            64..65 '_': S<&[T]>\n+            81..92 '{ loop {} }': T\n+            83..90 'loop {}': !\n+            88..90 '{}': ()\n+            121..132 '{ loop {} }': *mut [T; _]\n+            123..130 'loop {}': !\n+            128..130 '{}': ()\n+            159..172 '{     gen() }': *mut [U]\n+            165..168 'gen': fn gen<U>() -> *mut [U; _]\n+            165..170 'gen()': *mut [U; _]\n+            185..419 '{     ...rr); }': ()\n+            195..198 'arr': &[u8; _]\n+            211..215 '&[1]': &[u8; _]\n+            212..215 '[1]': [u8; _]\n+            213..214 '1': u8\n+            226..227 'a': &[u8]\n+            236..239 'arr': &[u8; _]\n+            249..250 'b': u8\n+            253..254 'f': fn f<u8>(&[u8]) -> u8\n+            253..259 'f(arr)': u8\n+            255..258 'arr': &[u8; _]\n+            269..270 'c': &[u8]\n+            279..286 '{ arr }': &[u8]\n+            281..284 'arr': &[u8; _]\n+            296..297 'd': u8\n+            300..301 'g': fn g<u8>(S<&[u8]>) -> u8\n+            300..315 'g(S { a: arr })': u8\n+            302..314 'S { a: arr }': S<&[u8]>\n+            309..312 'arr': &[u8; _]\n+            325..326 'e': [&[u8]; _]\n+            340..345 '[arr]': [&[u8]; _]\n+            341..344 'arr': &[u8; _]\n+            355..356 'f': [&[u8]; _]\n+            370..378 '[arr; 2]': [&[u8]; _]\n+            371..374 'arr': &[u8; _]\n+            376..377 '2': usize\n+            388..389 'g': (&[u8], &[u8])\n+            406..416 '(arr, arr)': (&[u8], &[u8])\n+            407..410 'arr': &[u8; _]\n+            412..415 'arr': &[u8; _]\n+        \"]],\n     );\n }\n \n #[test]\n fn infer_let_stmt_coerce() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn test() {\n-    let x: &[isize] = &[1];\n-    let x: *const [isize] = &[1];\n-}\n-\"#),\n-        @r###\"\n-    10..75 '{     ...[1]; }': ()\n-    20..21 'x': &[isize]\n-    34..38 '&[1]': &[isize; _]\n-    35..38 '[1]': [isize; _]\n-    36..37 '1': isize\n-    48..49 'x': *const [isize]\n-    68..72 '&[1]': &[isize; _]\n-    69..72 '[1]': [isize; _]\n-    70..71 '1': isize\n-    \"###);\n+    check_infer(\n+        r\"\n+        fn test() {\n+            let x: &[isize] = &[1];\n+            let x: *const [isize] = &[1];\n+        }\n+        \",\n+        expect![[r\"\n+            10..75 '{     ...[1]; }': ()\n+            20..21 'x': &[isize]\n+            34..38 '&[1]': &[isize; _]\n+            35..38 '[1]': [isize; _]\n+            36..37 '1': isize\n+            48..49 'x': *const [isize]\n+            68..72 '&[1]': &[isize; _]\n+            69..72 '[1]': [isize; _]\n+            70..71 '1': isize\n+        \"]],\n+    );\n }\n \n #[test]\n fn infer_custom_coerce_unsized() {\n-    assert_snapshot!(\n-        infer(r#\"\n-struct A<T: ?Sized>(*const T);\n-struct B<T: ?Sized>(*const T);\n-struct C<T: ?Sized> { inner: *const T }\n-\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<B<U>> for B<T> {}\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<C<U>> for C<T> {}\n-\n-fn foo1<T>(x: A<[T]>) -> A<[T]> { x }\n-fn foo2<T>(x: B<[T]>) -> B<[T]> { x }\n-fn foo3<T>(x: C<[T]>) -> C<[T]> { x }\n-\n-fn test(a: A<[u8; 2]>, b: B<[u8; 2]>, c: C<[u8; 2]>) {\n-    let d = foo1(a);\n-    let e = foo2(b);\n-    let f = foo3(c);\n-}\n-\"#),\n-        @r###\"\n-    257..258 'x': A<[T]>\n-    278..283 '{ x }': A<[T]>\n-    280..281 'x': A<[T]>\n-    295..296 'x': B<[T]>\n-    316..321 '{ x }': B<[T]>\n-    318..319 'x': B<[T]>\n-    333..334 'x': C<[T]>\n-    354..359 '{ x }': C<[T]>\n-    356..357 'x': C<[T]>\n-    369..370 'a': A<[u8; _]>\n-    384..385 'b': B<[u8; _]>\n-    399..400 'c': C<[u8; _]>\n-    414..480 '{     ...(c); }': ()\n-    424..425 'd': A<[{unknown}]>\n-    428..432 'foo1': fn foo1<{unknown}>(A<[{unknown}]>) -> A<[{unknown}]>\n-    428..435 'foo1(a)': A<[{unknown}]>\n-    433..434 'a': A<[u8; _]>\n-    445..446 'e': B<[u8]>\n-    449..453 'foo2': fn foo2<u8>(B<[u8]>) -> B<[u8]>\n-    449..456 'foo2(b)': B<[u8]>\n-    454..455 'b': B<[u8; _]>\n-    466..467 'f': C<[u8]>\n-    470..474 'foo3': fn foo3<u8>(C<[u8]>) -> C<[u8]>\n-    470..477 'foo3(c)': C<[u8]>\n-    475..476 'c': C<[u8; _]>\n-    \"###\n+    check_infer(\n+        r\"\n+        struct A<T: ?Sized>(*const T);\n+        struct B<T: ?Sized>(*const T);\n+        struct C<T: ?Sized> { inner: *const T }\n+\n+        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<B<U>> for B<T> {}\n+        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<C<U>> for C<T> {}\n+\n+        fn foo1<T>(x: A<[T]>) -> A<[T]> { x }\n+        fn foo2<T>(x: B<[T]>) -> B<[T]> { x }\n+        fn foo3<T>(x: C<[T]>) -> C<[T]> { x }\n+\n+        fn test(a: A<[u8; 2]>, b: B<[u8; 2]>, c: C<[u8; 2]>) {\n+            let d = foo1(a);\n+            let e = foo2(b);\n+            let f = foo3(c);\n+        }\n+        \",\n+        expect![[r\"\n+            257..258 'x': A<[T]>\n+            278..283 '{ x }': A<[T]>\n+            280..281 'x': A<[T]>\n+            295..296 'x': B<[T]>\n+            316..321 '{ x }': B<[T]>\n+            318..319 'x': B<[T]>\n+            333..334 'x': C<[T]>\n+            354..359 '{ x }': C<[T]>\n+            356..357 'x': C<[T]>\n+            369..370 'a': A<[u8; _]>\n+            384..385 'b': B<[u8; _]>\n+            399..400 'c': C<[u8; _]>\n+            414..480 '{     ...(c); }': ()\n+            424..425 'd': A<[{unknown}]>\n+            428..432 'foo1': fn foo1<{unknown}>(A<[{unknown}]>) -> A<[{unknown}]>\n+            428..435 'foo1(a)': A<[{unknown}]>\n+            433..434 'a': A<[u8; _]>\n+            445..446 'e': B<[u8]>\n+            449..453 'foo2': fn foo2<u8>(B<[u8]>) -> B<[u8]>\n+            449..456 'foo2(b)': B<[u8]>\n+            454..455 'b': B<[u8; _]>\n+            466..467 'f': C<[u8]>\n+            470..474 'foo3': fn foo3<u8>(C<[u8]>) -> C<[u8]>\n+            470..477 'foo3(c)': C<[u8]>\n+            475..476 'c': C<[u8; _]>\n+        \"]],\n     );\n }\n \n #[test]\n fn infer_if_coerce() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-fn test() {\n-    let x = if true {\n-        foo(&[1])\n-    } else {\n-        &[1]\n-    };\n-}\n-\"#),\n-        @r###\"\n-    10..11 'x': &[T]\n-    27..38 '{ loop {} }': &[T]\n-    29..36 'loop {}': !\n-    34..36 '{}': ()\n-    49..125 '{     ...  }; }': ()\n-    59..60 'x': &[i32]\n-    63..122 'if tru...     }': &[i32]\n-    66..70 'true': bool\n-    71..96 '{     ...     }': &[i32]\n-    81..84 'foo': fn foo<i32>(&[i32]) -> &[i32]\n-    81..90 'foo(&[1])': &[i32]\n-    85..89 '&[1]': &[i32; _]\n-    86..89 '[1]': [i32; _]\n-    87..88 '1': i32\n-    102..122 '{     ...     }': &[i32; _]\n-    112..116 '&[1]': &[i32; _]\n-    113..116 '[1]': [i32; _]\n-    114..115 '1': i32\n-    \"###\n+    check_infer(\n+        r\"\n+        fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+        fn test() {\n+            let x = if true {\n+                foo(&[1])\n+            } else {\n+                &[1]\n+            };\n+        }\n+        \",\n+        expect![[r\"\n+            10..11 'x': &[T]\n+            27..38 '{ loop {} }': &[T]\n+            29..36 'loop {}': !\n+            34..36 '{}': ()\n+            49..125 '{     ...  }; }': ()\n+            59..60 'x': &[i32]\n+            63..122 'if tru...     }': &[i32]\n+            66..70 'true': bool\n+            71..96 '{     ...     }': &[i32]\n+            81..84 'foo': fn foo<i32>(&[i32]) -> &[i32]\n+            81..90 'foo(&[1])': &[i32]\n+            85..89 '&[1]': &[i32; _]\n+            86..89 '[1]': [i32; _]\n+            87..88 '1': i32\n+            102..122 '{     ...     }': &[i32; _]\n+            112..116 '&[1]': &[i32; _]\n+            113..116 '[1]': [i32; _]\n+            114..115 '1': i32\n+        \"]],\n     );\n }\n \n #[test]\n fn infer_if_else_coerce() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-fn test() {\n-    let x = if true {\n-        &[1]\n-    } else {\n-        foo(&[1])\n-    };\n-}\n-\"#),\n-        @r###\"\n-    10..11 'x': &[T]\n-    27..38 '{ loop {} }': &[T]\n-    29..36 'loop {}': !\n-    34..36 '{}': ()\n-    49..125 '{     ...  }; }': ()\n-    59..60 'x': &[i32]\n-    63..122 'if tru...     }': &[i32]\n-    66..70 'true': bool\n-    71..91 '{     ...     }': &[i32; _]\n-    81..85 '&[1]': &[i32; _]\n-    82..85 '[1]': [i32; _]\n-    83..84 '1': i32\n-    97..122 '{     ...     }': &[i32]\n-    107..110 'foo': fn foo<i32>(&[i32]) -> &[i32]\n-    107..116 'foo(&[1])': &[i32]\n-    111..115 '&[1]': &[i32; _]\n-    112..115 '[1]': [i32; _]\n-    113..114 '1': i32\n-    \"###\n-    );\n+    check_infer(\n+        r\"\n+        fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+        fn test() {\n+            let x = if true {\n+                &[1]\n+            } else {\n+                foo(&[1])\n+            };\n+        }\n+        \",\n+        expect![[r\"\n+            10..11 'x': &[T]\n+            27..38 '{ loop {} }': &[T]\n+            29..36 'loop {}': !\n+            34..36 '{}': ()\n+            49..125 '{     ...  }; }': ()\n+            59..60 'x': &[i32]\n+            63..122 'if tru...     }': &[i32]\n+            66..70 'true': bool\n+            71..91 '{     ...     }': &[i32; _]\n+            81..85 '&[1]': &[i32; _]\n+            82..85 '[1]': [i32; _]\n+            83..84 '1': i32\n+            97..122 '{     ...     }': &[i32]\n+            107..110 'foo': fn foo<i32>(&[i32]) -> &[i32]\n+            107..116 'foo(&[1])': &[i32]\n+            111..115 '&[1]': &[i32; _]\n+            112..115 '[1]': [i32; _]\n+            113..114 '1': i32\n+        \"]],\n+    )\n }\n \n #[test]\n fn infer_match_first_coerce() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-fn test(i: i32) {\n-    let x = match i {\n-        2 => foo(&[2]),\n-        1 => &[1],\n-        _ => &[3],\n-    };\n-}\n-\"#),\n-        @r###\"\n-    10..11 'x': &[T]\n-    27..38 '{ loop {} }': &[T]\n-    29..36 'loop {}': !\n-    34..36 '{}': ()\n-    47..48 'i': i32\n-    55..149 '{     ...  }; }': ()\n-    65..66 'x': &[i32]\n-    69..146 'match ...     }': &[i32]\n-    75..76 'i': i32\n-    87..88 '2': i32\n-    87..88 '2': i32\n-    92..95 'foo': fn foo<i32>(&[i32]) -> &[i32]\n-    92..101 'foo(&[2])': &[i32]\n-    96..100 '&[2]': &[i32; _]\n-    97..100 '[2]': [i32; _]\n-    98..99 '2': i32\n-    111..112 '1': i32\n-    111..112 '1': i32\n-    116..120 '&[1]': &[i32; _]\n-    117..120 '[1]': [i32; _]\n-    118..119 '1': i32\n-    130..131 '_': i32\n-    135..139 '&[3]': &[i32; _]\n-    136..139 '[3]': [i32; _]\n-    137..138 '3': i32\n-    \"###\n+    check_infer(\n+        r\"\n+        fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+        fn test(i: i32) {\n+            let x = match i {\n+                2 => foo(&[2]),\n+                1 => &[1],\n+                _ => &[3],\n+            };\n+        }\n+        \",\n+        expect![[r\"\n+            10..11 'x': &[T]\n+            27..38 '{ loop {} }': &[T]\n+            29..36 'loop {}': !\n+            34..36 '{}': ()\n+            47..48 'i': i32\n+            55..149 '{     ...  }; }': ()\n+            65..66 'x': &[i32]\n+            69..146 'match ...     }': &[i32]\n+            75..76 'i': i32\n+            87..88 '2': i32\n+            87..88 '2': i32\n+            92..95 'foo': fn foo<i32>(&[i32]) -> &[i32]\n+            92..101 'foo(&[2])': &[i32]\n+            96..100 '&[2]': &[i32; _]\n+            97..100 '[2]': [i32; _]\n+            98..99 '2': i32\n+            111..112 '1': i32\n+            111..112 '1': i32\n+            116..120 '&[1]': &[i32; _]\n+            117..120 '[1]': [i32; _]\n+            118..119 '1': i32\n+            130..131 '_': i32\n+            135..139 '&[3]': &[i32; _]\n+            136..139 '[3]': [i32; _]\n+            137..138 '3': i32\n+    \"]],\n     );\n }\n \n #[test]\n fn infer_match_second_coerce() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-fn test(i: i32) {\n-    let x = match i {\n-        1 => &[1],\n-        2 => foo(&[2]),\n-        _ => &[3],\n-    };\n-}\n-\"#),\n-        @r###\"\n-    10..11 'x': &[T]\n-    27..38 '{ loop {} }': &[T]\n-    29..36 'loop {}': !\n-    34..36 '{}': ()\n-    47..48 'i': i32\n-    55..149 '{     ...  }; }': ()\n-    65..66 'x': &[i32]\n-    69..146 'match ...     }': &[i32]\n-    75..76 'i': i32\n-    87..88 '1': i32\n-    87..88 '1': i32\n-    92..96 '&[1]': &[i32; _]\n-    93..96 '[1]': [i32; _]\n-    94..95 '1': i32\n-    106..107 '2': i32\n-    106..107 '2': i32\n-    111..114 'foo': fn foo<i32>(&[i32]) -> &[i32]\n-    111..120 'foo(&[2])': &[i32]\n-    115..119 '&[2]': &[i32; _]\n-    116..119 '[2]': [i32; _]\n-    117..118 '2': i32\n-    130..131 '_': i32\n-    135..139 '&[3]': &[i32; _]\n-    136..139 '[3]': [i32; _]\n-    137..138 '3': i32\n-    \"###\n+    check_infer(\n+        r\"\n+        fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+        fn test(i: i32) {\n+            let x = match i {\n+                1 => &[1],\n+                2 => foo(&[2]),\n+                _ => &[3],\n+            };\n+        }\n+        \",\n+        expect![[r\"\n+            10..11 'x': &[T]\n+            27..38 '{ loop {} }': &[T]\n+            29..36 'loop {}': !\n+            34..36 '{}': ()\n+            47..48 'i': i32\n+            55..149 '{     ...  }; }': ()\n+            65..66 'x': &[i32]\n+            69..146 'match ...     }': &[i32]\n+            75..76 'i': i32\n+            87..88 '1': i32\n+            87..88 '1': i32\n+            92..96 '&[1]': &[i32; _]\n+            93..96 '[1]': [i32; _]\n+            94..95 '1': i32\n+            106..107 '2': i32\n+            106..107 '2': i32\n+            111..114 'foo': fn foo<i32>(&[i32]) -> &[i32]\n+            111..120 'foo(&[2])': &[i32]\n+            115..119 '&[2]': &[i32; _]\n+            116..119 '[2]': [i32; _]\n+            117..118 '2': i32\n+            130..131 '_': i32\n+            135..139 '&[3]': &[i32; _]\n+            136..139 '[3]': [i32; _]\n+            137..138 '3': i32\n+    \"]],\n     );\n }\n \n #[test]\n fn coerce_merge_one_by_one1() {\n     mark::check!(coerce_merge_fail_fallback);\n \n-    assert_snapshot!(\n-        infer(r#\"\n-fn test() {\n-    let t = &mut 1;\n-    let x = match 1 {\n-        1 => t as *mut i32,\n-        2 => t as &i32,\n-        _ => t as *const i32,\n-    };\n-}\n-\"#),\n-        @r###\"\n-    10..144 '{     ...  }; }': ()\n-    20..21 't': &mut i32\n-    24..30 '&mut 1': &mut i32\n-    29..30 '1': i32\n-    40..41 'x': *const i32\n-    44..141 'match ...     }': *const i32\n-    50..51 '1': i32\n-    62..63 '1': i32\n-    62..63 '1': i32\n-    67..68 't': &mut i32\n-    67..80 't as *mut i32': *mut i32\n-    90..91 '2': i32\n-    90..91 '2': i32\n-    95..96 't': &mut i32\n-    95..104 't as &i32': &i32\n-    114..115 '_': i32\n-    119..120 't': &mut i32\n-    119..134 't as *const i32': *const i32\n-    \"###\n+    check_infer(\n+        r\"\n+        fn test() {\n+            let t = &mut 1;\n+            let x = match 1 {\n+                1 => t as *mut i32,\n+                2 => t as &i32,\n+                _ => t as *const i32,\n+            };\n+        }\n+        \",\n+        expect![[r\"\n+            10..144 '{     ...  }; }': ()\n+            20..21 't': &mut i32\n+            24..30 '&mut 1': &mut i32\n+            29..30 '1': i32\n+            40..41 'x': *const i32\n+            44..141 'match ...     }': *const i32\n+            50..51 '1': i32\n+            62..63 '1': i32\n+            62..63 '1': i32\n+            67..68 't': &mut i32\n+            67..80 't as *mut i32': *mut i32\n+            90..91 '2': i32\n+            90..91 '2': i32\n+            95..96 't': &mut i32\n+            95..104 't as &i32': &i32\n+            114..115 '_': i32\n+            119..120 't': &mut i32\n+            119..134 't as *const i32': *const i32\n+    \"]],\n     );\n }\n \n #[test]\n fn return_coerce_unknown() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-fn foo() -> u32 {\n-    return unknown;\n-}\n-\"#, true),\n-        @r###\"\n-    16..39 '{     ...own; }': u32\n-    22..36 'return unknown': !\n-    29..36 'unknown': u32\n-    \"###\n+    check_infer_with_mismatches(\n+        r\"\n+        fn foo() -> u32 {\n+            return unknown;\n+        }\n+        \",\n+        expect![[r\"\n+            16..39 '{     ...own; }': u32\n+            22..36 'return unknown': !\n+            29..36 'unknown': u32\n+        \"]],\n     );\n }\n \n #[test]\n fn coerce_autoderef() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-struct Foo;\n-fn takes_ref_foo(x: &Foo) {}\n-fn test() {\n-    takes_ref_foo(&Foo);\n-    takes_ref_foo(&&Foo);\n-    takes_ref_foo(&&&Foo);\n-}\n-\"#, true),\n-        @r###\"\n-    29..30 'x': &Foo\n-    38..40 '{}': ()\n-    51..132 '{     ...oo); }': ()\n-    57..70 'takes_ref_foo': fn takes_ref_foo(&Foo)\n-    57..76 'takes_...(&Foo)': ()\n-    71..75 '&Foo': &Foo\n-    72..75 'Foo': Foo\n-    82..95 'takes_ref_foo': fn takes_ref_foo(&Foo)\n-    82..102 'takes_...&&Foo)': ()\n-    96..101 '&&Foo': &&Foo\n-    97..101 '&Foo': &Foo\n-    98..101 'Foo': Foo\n-    108..121 'takes_ref_foo': fn takes_ref_foo(&Foo)\n-    108..129 'takes_...&&Foo)': ()\n-    122..128 '&&&Foo': &&&Foo\n-    123..128 '&&Foo': &&Foo\n-    124..128 '&Foo': &Foo\n-    125..128 'Foo': Foo\n-    \"###\n+    check_infer_with_mismatches(\n+        r\"\n+        struct Foo;\n+        fn takes_ref_foo(x: &Foo) {}\n+        fn test() {\n+            takes_ref_foo(&Foo);\n+            takes_ref_foo(&&Foo);\n+            takes_ref_foo(&&&Foo);\n+        }\n+        \",\n+        expect![[r\"\n+            29..30 'x': &Foo\n+            38..40 '{}': ()\n+            51..132 '{     ...oo); }': ()\n+            57..70 'takes_ref_foo': fn takes_ref_foo(&Foo)\n+            57..76 'takes_...(&Foo)': ()\n+            71..75 '&Foo': &Foo\n+            72..75 'Foo': Foo\n+            82..95 'takes_ref_foo': fn takes_ref_foo(&Foo)\n+            82..102 'takes_...&&Foo)': ()\n+            96..101 '&&Foo': &&Foo\n+            97..101 '&Foo': &Foo\n+            98..101 'Foo': Foo\n+            108..121 'takes_ref_foo': fn takes_ref_foo(&Foo)\n+            108..129 'takes_...&&Foo)': ()\n+            122..128 '&&&Foo': &&&Foo\n+            123..128 '&&Foo': &&Foo\n+            124..128 '&Foo': &Foo\n+            125..128 'Foo': Foo\n+        \"]],\n     );\n }\n \n #[test]\n fn coerce_autoderef_generic() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-struct Foo;\n-fn takes_ref<T>(x: &T) -> T { *x }\n-fn test() {\n-    takes_ref(&Foo);\n-    takes_ref(&&Foo);\n-    takes_ref(&&&Foo);\n-}\n-\"#, true),\n-        @r###\"\n-    28..29 'x': &T\n-    40..46 '{ *x }': T\n-    42..44 '*x': T\n-    43..44 'x': &T\n-    57..126 '{     ...oo); }': ()\n-    63..72 'takes_ref': fn takes_ref<Foo>(&Foo) -> Foo\n-    63..78 'takes_ref(&Foo)': Foo\n-    73..77 '&Foo': &Foo\n-    74..77 'Foo': Foo\n-    84..93 'takes_ref': fn takes_ref<&Foo>(&&Foo) -> &Foo\n-    84..100 'takes_...&&Foo)': &Foo\n-    94..99 '&&Foo': &&Foo\n-    95..99 '&Foo': &Foo\n-    96..99 'Foo': Foo\n-    106..115 'takes_ref': fn takes_ref<&&Foo>(&&&Foo) -> &&Foo\n-    106..123 'takes_...&&Foo)': &&Foo\n-    116..122 '&&&Foo': &&&Foo\n-    117..122 '&&Foo': &&Foo\n-    118..122 '&Foo': &Foo\n-    119..122 'Foo': Foo\n-    \"###\n+    check_infer_with_mismatches(\n+        r\"\n+        struct Foo;\n+        fn takes_ref<T>(x: &T) -> T { *x }\n+        fn test() {\n+            takes_ref(&Foo);\n+            takes_ref(&&Foo);\n+            takes_ref(&&&Foo);\n+        }\n+        \",\n+        expect![[r\"\n+            28..29 'x': &T\n+            40..46 '{ *x }': T\n+            42..44 '*x': T\n+            43..44 'x': &T\n+            57..126 '{     ...oo); }': ()\n+            63..72 'takes_ref': fn takes_ref<Foo>(&Foo) -> Foo\n+            63..78 'takes_ref(&Foo)': Foo\n+            73..77 '&Foo': &Foo\n+            74..77 'Foo': Foo\n+            84..93 'takes_ref': fn takes_ref<&Foo>(&&Foo) -> &Foo\n+            84..100 'takes_...&&Foo)': &Foo\n+            94..99 '&&Foo': &&Foo\n+            95..99 '&Foo': &Foo\n+            96..99 'Foo': Foo\n+            106..115 'takes_ref': fn takes_ref<&&Foo>(&&&Foo) -> &&Foo\n+            106..123 'takes_...&&Foo)': &&Foo\n+            116..122 '&&&Foo': &&&Foo\n+            117..122 '&&Foo': &&Foo\n+            118..122 '&Foo': &Foo\n+            119..122 'Foo': Foo\n+        \"]],\n     );\n }\n \n #[test]\n fn coerce_autoderef_block() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-struct String {}\n-#[lang = \"deref\"]\n-trait Deref { type Target; }\n-impl Deref for String { type Target = str; }\n-fn takes_ref_str(x: &str) {}\n-fn returns_string() -> String { loop {} }\n-fn test() {\n-    takes_ref_str(&{ returns_string() });\n-}\n-\"#, true),\n-        @r###\"\n-    126..127 'x': &str\n-    135..137 '{}': ()\n-    168..179 '{ loop {} }': String\n-    170..177 'loop {}': !\n-    175..177 '{}': ()\n-    190..235 '{     ... }); }': ()\n-    196..209 'takes_ref_str': fn takes_ref_str(&str)\n-    196..232 'takes_...g() })': ()\n-    210..231 '&{ ret...ng() }': &String\n-    211..231 '{ retu...ng() }': String\n-    213..227 'returns_string': fn returns_string() -> String\n-    213..229 'return...ring()': String\n-    \"###\n+    check_infer_with_mismatches(\n+        r#\"\n+        struct String {}\n+        #[lang = \"deref\"]\n+        trait Deref { type Target; }\n+        impl Deref for String { type Target = str; }\n+        fn takes_ref_str(x: &str) {}\n+        fn returns_string() -> String { loop {} }\n+        fn test() {\n+            takes_ref_str(&{ returns_string() });\n+        }\n+        \"#,\n+        expect![[r\"\n+            126..127 'x': &str\n+            135..137 '{}': ()\n+            168..179 '{ loop {} }': String\n+            170..177 'loop {}': !\n+            175..177 '{}': ()\n+            190..235 '{     ... }); }': ()\n+            196..209 'takes_ref_str': fn takes_ref_str(&str)\n+            196..232 'takes_...g() })': ()\n+            210..231 '&{ ret...ng() }': &String\n+            211..231 '{ retu...ng() }': String\n+            213..227 'returns_string': fn returns_string() -> String\n+            213..229 'return...ring()': String\n+        \"]],\n     );\n }\n \n #[test]\n fn closure_return_coerce() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-fn foo() {\n-    let x = || {\n-        if true {\n-            return &1u32;\n+    check_infer_with_mismatches(\n+        r\"\n+        fn foo() {\n+            let x = || {\n+                if true {\n+                    return &1u32;\n+                }\n+                &&1u32\n+            };\n         }\n-        &&1u32\n-    };\n-}\n-\"#, true),\n-        @r###\"\n-    9..105 '{     ...  }; }': ()\n-    19..20 'x': || -> &u32\n-    23..102 '|| {  ...     }': || -> &u32\n-    26..102 '{     ...     }': &u32\n-    36..81 'if tru...     }': ()\n-    39..43 'true': bool\n-    44..81 '{     ...     }': ()\n-    58..70 'return &1u32': !\n-    65..70 '&1u32': &u32\n-    66..70 '1u32': u32\n-    90..96 '&&1u32': &&u32\n-    91..96 '&1u32': &u32\n-    92..96 '1u32': u32\n-    \"###\n+        \",\n+        expect![[r\"\n+            9..105 '{     ...  }; }': ()\n+            19..20 'x': || -> &u32\n+            23..102 '|| {  ...     }': || -> &u32\n+            26..102 '{     ...     }': &u32\n+            36..81 'if tru...     }': ()\n+            39..43 'true': bool\n+            44..81 '{     ...     }': ()\n+            58..70 'return &1u32': !\n+            65..70 '&1u32': &u32\n+            66..70 '1u32': u32\n+            90..96 '&&1u32': &&u32\n+            91..96 '&1u32': &u32\n+            92..96 '1u32': u32\n+        \"]],\n     );\n }\n \n #[test]\n fn coerce_fn_item_to_fn_ptr() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-fn foo(x: u32) -> isize { 1 }\n-fn test() {\n-    let f: fn(u32) -> isize = foo;\n-}\n-\"#, true),\n-        @r###\"\n-    7..8 'x': u32\n-    24..29 '{ 1 }': isize\n-    26..27 '1': isize\n-    40..78 '{     ...foo; }': ()\n-    50..51 'f': fn(u32) -> isize\n-    72..75 'foo': fn foo(u32) -> isize\n-    \"###\n+    check_infer_with_mismatches(\n+        r\"\n+        fn foo(x: u32) -> isize { 1 }\n+        fn test() {\n+            let f: fn(u32) -> isize = foo;\n+        }\n+        \",\n+        expect![[r\"\n+            7..8 'x': u32\n+            24..29 '{ 1 }': isize\n+            26..27 '1': isize\n+            40..78 '{     ...foo; }': ()\n+            50..51 'f': fn(u32) -> isize\n+            72..75 'foo': fn foo(u32) -> isize\n+        \"]],\n     );\n }\n \n #[test]\n fn coerce_fn_items_in_match_arms() {\n     mark::check!(coerce_fn_reification);\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-fn foo1(x: u32) -> isize { 1 }\n-fn foo2(x: u32) -> isize { 2 }\n-fn foo3(x: u32) -> isize { 3 }\n-fn test() {\n-    let x = match 1 {\n-        1 => foo1,\n-        2 => foo2,\n-        _ => foo3,\n-    };\n-}\n-\"#, true),\n-        @r###\"\n-    8..9 'x': u32\n-    25..30 '{ 1 }': isize\n-    27..28 '1': isize\n-    39..40 'x': u32\n-    56..61 '{ 2 }': isize\n-    58..59 '2': isize\n-    70..71 'x': u32\n-    87..92 '{ 3 }': isize\n-    89..90 '3': isize\n-    103..192 '{     ...  }; }': ()\n-    113..114 'x': fn(u32) -> isize\n-    117..189 'match ...     }': fn(u32) -> isize\n-    123..124 '1': i32\n-    135..136 '1': i32\n-    135..136 '1': i32\n-    140..144 'foo1': fn foo1(u32) -> isize\n-    154..155 '2': i32\n-    154..155 '2': i32\n-    159..163 'foo2': fn foo2(u32) -> isize\n-    173..174 '_': i32\n-    178..182 'foo3': fn foo3(u32) -> isize\n-    \"###\n+\n+    check_infer_with_mismatches(\n+        r\"\n+        fn foo1(x: u32) -> isize { 1 }\n+        fn foo2(x: u32) -> isize { 2 }\n+        fn foo3(x: u32) -> isize { 3 }\n+        fn test() {\n+            let x = match 1 {\n+                1 => foo1,\n+                2 => foo2,\n+                _ => foo3,\n+            };\n+        }\n+        \",\n+        expect![[r\"\n+            8..9 'x': u32\n+            25..30 '{ 1 }': isize\n+            27..28 '1': isize\n+            39..40 'x': u32\n+            56..61 '{ 2 }': isize\n+            58..59 '2': isize\n+            70..71 'x': u32\n+            87..92 '{ 3 }': isize\n+            89..90 '3': isize\n+            103..192 '{     ...  }; }': ()\n+            113..114 'x': fn(u32) -> isize\n+            117..189 'match ...     }': fn(u32) -> isize\n+            123..124 '1': i32\n+            135..136 '1': i32\n+            135..136 '1': i32\n+            140..144 'foo1': fn foo1(u32) -> isize\n+            154..155 '2': i32\n+            154..155 '2': i32\n+            159..163 'foo2': fn foo2(u32) -> isize\n+            173..174 '_': i32\n+            178..182 'foo3': fn foo3(u32) -> isize\n+        \"]],\n     );\n }\n \n #[test]\n fn coerce_closure_to_fn_ptr() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-fn test() {\n-    let f: fn(u32) -> isize = |x| { 1 };\n-}\n-\"#, true),\n-        @r###\"\n-    10..54 '{     ...1 }; }': ()\n-    20..21 'f': fn(u32) -> isize\n-    42..51 '|x| { 1 }': |u32| -> isize\n-    43..44 'x': u32\n-    46..51 '{ 1 }': isize\n-    48..49 '1': isize\n-    \"###\n+    check_infer_with_mismatches(\n+        r\"\n+        fn test() {\n+            let f: fn(u32) -> isize = |x| { 1 };\n+        }\n+        \",\n+        expect![[r\"\n+            10..54 '{     ...1 }; }': ()\n+            20..21 'f': fn(u32) -> isize\n+            42..51 '|x| { 1 }': |u32| -> isize\n+            43..44 'x': u32\n+            46..51 '{ 1 }': isize\n+            48..49 '1': isize\n+        \"]],\n     );\n }\n \n #[test]\n fn coerce_placeholder_ref() {\n     // placeholders should unify, even behind references\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-struct S<T> { t: T }\n-impl<TT> S<TT> {\n-    fn get(&self) -> &TT {\n-        &self.t\n-    }\n-}\n-\"#, true),\n-        @r###\"\n-    50..54 'self': &S<TT>\n-    63..86 '{     ...     }': &TT\n-    73..80 '&self.t': &TT\n-    74..78 'self': &S<TT>\n-    74..80 'self.t': TT\n-    \"###\n+    check_infer_with_mismatches(\n+        r\"\n+        struct S<T> { t: T }\n+        impl<TT> S<TT> {\n+            fn get(&self) -> &TT {\n+                &self.t\n+            }\n+        }\n+        \",\n+        expect![[r\"\n+            50..54 'self': &S<TT>\n+            63..86 '{     ...     }': &TT\n+            73..80 '&self.t': &TT\n+            74..78 'self': &S<TT>\n+            74..80 'self.t': TT\n+        \"]],\n     );\n }\n \n #[test]\n fn coerce_unsize_array() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-#[lang = \"unsize\"]\n-pub trait Unsize<T> {}\n-#[lang = \"coerce_unsized\"]\n-pub trait CoerceUnsized<T> {}\n+    check_infer_with_mismatches(\n+        r#\"\n+        #[lang = \"unsize\"]\n+        pub trait Unsize<T> {}\n+        #[lang = \"coerce_unsized\"]\n+        pub trait CoerceUnsized<T> {}\n \n-impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+        impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n \n-fn test() {\n-    let f: &[usize] = &[1, 2, 3];\n-}\n-\"#, true),\n-        @r###\"\n-    161..198 '{     ... 3]; }': ()\n-    171..172 'f': &[usize]\n-    185..195 '&[1, 2, 3]': &[usize; _]\n-    186..195 '[1, 2, 3]': [usize; _]\n-    187..188 '1': usize\n-    190..191 '2': usize\n-    193..194 '3': usize\n-    \"###\n+        fn test() {\n+            let f: &[usize] = &[1, 2, 3];\n+        }\n+        \"#,\n+        expect![[r\"\n+            161..198 '{     ... 3]; }': ()\n+            171..172 'f': &[usize]\n+            185..195 '&[1, 2, 3]': &[usize; _]\n+            186..195 '[1, 2, 3]': [usize; _]\n+            187..188 '1': usize\n+            190..191 '2': usize\n+            193..194 '3': usize\n+        \"]],\n     );\n }\n \n #[test]\n fn coerce_unsize_trait_object_simple() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-#[lang = \"sized\"]\n-pub trait Sized {}\n-#[lang = \"unsize\"]\n-pub trait Unsize<T> {}\n-#[lang = \"coerce_unsized\"]\n-pub trait CoerceUnsized<T> {}\n-\n-impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n-trait Foo<T, U> {}\n-trait Bar<U, T, X>: Foo<T, U> {}\n-trait Baz<T, X>: Bar<usize, T, X> {}\n-\n-struct S<T, X>;\n-impl<T, X> Foo<T, usize> for S<T, X> {}\n-impl<T, X> Bar<usize, T, X> for S<T, X> {}\n-impl<T, X> Baz<T, X> for S<T, X> {}\n-\n-fn test() {\n-    let obj: &dyn Baz<i8, i16> = &S;\n-    let obj: &dyn Bar<_, i8, i16> = &S;\n-    let obj: &dyn Foo<i8, _> = &S;\n-}\n-\"#, true),\n-        @r###\"\n-    424..539 '{     ... &S; }': ()\n-    434..437 'obj': &dyn Baz<i8, i16>\n-    459..461 '&S': &S<i8, i16>\n-    460..461 'S': S<i8, i16>\n-    471..474 'obj': &dyn Bar<usize, i8, i16>\n-    499..501 '&S': &S<i8, i16>\n-    500..501 'S': S<i8, i16>\n-    511..514 'obj': &dyn Foo<i8, usize>\n-    534..536 '&S': &S<i8, {unknown}>\n-    535..536 'S': S<i8, {unknown}>\n-    \"###\n+    check_infer_with_mismatches(\n+        r#\"\n+        #[lang = \"sized\"]\n+        pub trait Sized {}\n+        #[lang = \"unsize\"]\n+        pub trait Unsize<T> {}\n+        #[lang = \"coerce_unsized\"]\n+        pub trait CoerceUnsized<T> {}\n+\n+        impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+\n+        trait Foo<T, U> {}\n+        trait Bar<U, T, X>: Foo<T, U> {}\n+        trait Baz<T, X>: Bar<usize, T, X> {}\n+\n+        struct S<T, X>;\n+        impl<T, X> Foo<T, usize> for S<T, X> {}\n+        impl<T, X> Bar<usize, T, X> for S<T, X> {}\n+        impl<T, X> Baz<T, X> for S<T, X> {}\n+\n+        fn test() {\n+            let obj: &dyn Baz<i8, i16> = &S;\n+            let obj: &dyn Bar<_, i8, i16> = &S;\n+            let obj: &dyn Foo<i8, _> = &S;\n+        }\n+        \"#,\n+        expect![[r\"\n+            424..539 '{     ... &S; }': ()\n+            434..437 'obj': &dyn Baz<i8, i16>\n+            459..461 '&S': &S<i8, i16>\n+            460..461 'S': S<i8, i16>\n+            471..474 'obj': &dyn Bar<usize, i8, i16>\n+            499..501 '&S': &S<i8, i16>\n+            500..501 'S': S<i8, i16>\n+            511..514 'obj': &dyn Foo<i8, usize>\n+            534..536 '&S': &S<i8, {unknown}>\n+            535..536 'S': S<i8, {unknown}>\n+        \"]],\n     );\n }\n \n@@ -709,90 +719,90 @@ fn test() {\n // it. We used to support it, but Chalk doesn't.\n #[ignore]\n fn coerce_unsize_trait_object_to_trait_object() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-#[lang = \"sized\"]\n-pub trait Sized {}\n-#[lang = \"unsize\"]\n-pub trait Unsize<T> {}\n-#[lang = \"coerce_unsized\"]\n-pub trait CoerceUnsized<T> {}\n-\n-impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n-trait Foo<T, U> {}\n-trait Bar<U, T, X>: Foo<T, U> {}\n-trait Baz<T, X>: Bar<usize, T, X> {}\n-\n-struct S<T, X>;\n-impl<T, X> Foo<T, usize> for S<T, X> {}\n-impl<T, X> Bar<usize, T, X> for S<T, X> {}\n-impl<T, X> Baz<T, X> for S<T, X> {}\n-\n-fn test() {\n-    let obj: &dyn Baz<i8, i16> = &S;\n-    let obj: &dyn Bar<_, _, _> = obj;\n-    let obj: &dyn Foo<_, _> = obj;\n-    let obj2: &dyn Baz<i8, i16> = &S;\n-    let _: &dyn Foo<_, _> = obj2;\n-}\n-\"#, true),\n-        @r###\"\n-    424..609 '{     ...bj2; }': ()\n-    434..437 'obj': &dyn Baz<i8, i16>\n-    459..461 '&S': &S<i8, i16>\n-    460..461 'S': S<i8, i16>\n-    471..474 'obj': &dyn Bar<usize, i8, i16>\n-    496..499 'obj': &dyn Baz<i8, i16>\n-    509..512 'obj': &dyn Foo<i8, usize>\n-    531..534 'obj': &dyn Bar<usize, i8, i16>\n-    544..548 'obj2': &dyn Baz<i8, i16>\n-    570..572 '&S': &S<i8, i16>\n-    571..572 'S': S<i8, i16>\n-    582..583 '_': &dyn Foo<i8, usize>\n-    602..606 'obj2': &dyn Baz<i8, i16>\n-    \"###\n+    check_infer_with_mismatches(\n+        r#\"\n+        #[lang = \"sized\"]\n+        pub trait Sized {}\n+        #[lang = \"unsize\"]\n+        pub trait Unsize<T> {}\n+        #[lang = \"coerce_unsized\"]\n+        pub trait CoerceUnsized<T> {}\n+\n+        impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+\n+        trait Foo<T, U> {}\n+        trait Bar<U, T, X>: Foo<T, U> {}\n+        trait Baz<T, X>: Bar<usize, T, X> {}\n+\n+        struct S<T, X>;\n+        impl<T, X> Foo<T, usize> for S<T, X> {}\n+        impl<T, X> Bar<usize, T, X> for S<T, X> {}\n+        impl<T, X> Baz<T, X> for S<T, X> {}\n+\n+        fn test() {\n+            let obj: &dyn Baz<i8, i16> = &S;\n+            let obj: &dyn Bar<_, _, _> = obj;\n+            let obj: &dyn Foo<_, _> = obj;\n+            let obj2: &dyn Baz<i8, i16> = &S;\n+            let _: &dyn Foo<_, _> = obj2;\n+        }\n+        \"#,\n+        expect![[r\"\n+            424..609 '{     ...bj2; }': ()\n+            434..437 'obj': &dyn Baz<i8, i16>\n+            459..461 '&S': &S<i8, i16>\n+            460..461 'S': S<i8, i16>\n+            471..474 'obj': &dyn Bar<usize, i8, i16>\n+            496..499 'obj': &dyn Baz<i8, i16>\n+            509..512 'obj': &dyn Foo<i8, usize>\n+            531..534 'obj': &dyn Bar<usize, i8, i16>\n+            544..548 'obj2': &dyn Baz<i8, i16>\n+            570..572 '&S': &S<i8, i16>\n+            571..572 'S': S<i8, i16>\n+            582..583 '_': &dyn Foo<i8, usize>\n+            602..606 'obj2': &dyn Baz<i8, i16>\n+        \"]],\n     );\n }\n \n #[test]\n fn coerce_unsize_super_trait_cycle() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-#[lang = \"sized\"]\n-pub trait Sized {}\n-#[lang = \"unsize\"]\n-pub trait Unsize<T> {}\n-#[lang = \"coerce_unsized\"]\n-pub trait CoerceUnsized<T> {}\n-\n-impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n-\n-trait A {}\n-trait B: C + A {}\n-trait C: B {}\n-trait D: C\n-\n-struct S;\n-impl A for S {}\n-impl B for S {}\n-impl C for S {}\n-impl D for S {}\n-\n-fn test() {\n-    let obj: &dyn D = &S;\n-    let obj: &dyn A = &S;\n-}\n-\"#, true),\n-        @r###\"\n-    328..383 '{     ... &S; }': ()\n-    338..341 'obj': &dyn D\n-    352..354 '&S': &S\n-    353..354 'S': S\n-    364..367 'obj': &dyn A\n-    378..380 '&S': &S\n-    379..380 'S': S\n-    \"###\n+    check_infer_with_mismatches(\n+        r#\"\n+        #[lang = \"sized\"]\n+        pub trait Sized {}\n+        #[lang = \"unsize\"]\n+        pub trait Unsize<T> {}\n+        #[lang = \"coerce_unsized\"]\n+        pub trait CoerceUnsized<T> {}\n+\n+        impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+\n+        trait A {}\n+        trait B: C + A {}\n+        trait C: B {}\n+        trait D: C\n+\n+        struct S;\n+        impl A for S {}\n+        impl B for S {}\n+        impl C for S {}\n+        impl D for S {}\n+\n+        fn test() {\n+            let obj: &dyn D = &S;\n+            let obj: &dyn A = &S;\n+        }\n+        \"#,\n+        expect![[r\"\n+            328..383 '{     ... &S; }': ()\n+            338..341 'obj': &dyn D\n+            352..354 '&S': &S\n+            353..354 'S': S\n+            364..367 'obj': &dyn A\n+            378..380 '&S': &S\n+            379..380 'S': S\n+        \"]],\n     );\n }\n \n@@ -801,24 +811,24 @@ fn test() {\n fn coerce_unsize_generic() {\n     // FIXME: Implement this\n     // https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-#[lang = \"unsize\"]\n-pub trait Unsize<T> {}\n-#[lang = \"coerce_unsized\"]\n-pub trait CoerceUnsized<T> {}\n+    check_infer_with_mismatches(\n+        r#\"\n+        #[lang = \"unsize\"]\n+        pub trait Unsize<T> {}\n+        #[lang = \"coerce_unsized\"]\n+        pub trait CoerceUnsized<T> {}\n \n-impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+        impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n \n-struct Foo<T> { t: T };\n-struct Bar<T>(Foo<T>);\n+        struct Foo<T> { t: T };\n+        struct Bar<T>(Foo<T>);\n \n-fn test() {\n-    let _: &Foo<[usize]> = &Foo { t: [1, 2, 3] };\n-    let _: &Bar<[usize]> = &Bar(Foo { t: [1, 2, 3] });\n-}\n-\"#, true),\n-        @r###\"\n-    \"###\n+        fn test() {\n+            let _: &Foo<[usize]> = &Foo { t: [1, 2, 3] };\n+            let _: &Bar<[usize]> = &Bar(Foo { t: [1, 2, 3] });\n+        }\n+        \"#,\n+        expect![[r\"\n+        \"]],\n     );\n }"}]}