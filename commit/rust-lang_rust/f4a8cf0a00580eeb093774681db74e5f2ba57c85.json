{"sha": "f4a8cf0a00580eeb093774681db74e5f2ba57c85", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YThjZjBhMDA1ODBlZWIwOTM3NzQ2ODFkYjc0ZTVmMmJhNTdjODU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-23T00:07:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-23T00:07:19Z"}, "message": "Auto merge of #78681 - m-ou-se:binary-heap-retain, r=Amanieu\n\nImprove rebuilding behaviour of BinaryHeap::retain.\n\nThis changes `BinaryHeap::retain` such that it doesn't always fully rebuild the heap, but only rebuilds the parts for which that's necessary.\n\nThis makes use of the fact that retain gives out `&T`s and not `&mut T`s.\n\nRetaining every element or removing only elements at the end results in no rebuilding at all. Retaining most elements results in only reordering the elements that got moved (those after the first removed element), using the same logic as was already used for `append`.\n\ncc `@KodrAus` `@sfackler` - We briefly discussed this possibility in the meeting last week while we talked about stabilization of this function (#71503).", "tree": {"sha": "7ac13342483a93312a5cf1e7f7e0929fbffbcae5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ac13342483a93312a5cf1e7f7e0929fbffbcae5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4a8cf0a00580eeb093774681db74e5f2ba57c85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4a8cf0a00580eeb093774681db74e5f2ba57c85", "html_url": "https://github.com/rust-lang/rust/commit/f4a8cf0a00580eeb093774681db74e5f2ba57c85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4a8cf0a00580eeb093774681db74e5f2ba57c85/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f4afdf0255600306bf67432da722c7b5d2cbf82", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f4afdf0255600306bf67432da722c7b5d2cbf82", "html_url": "https://github.com/rust-lang/rust/commit/7f4afdf0255600306bf67432da722c7b5d2cbf82"}, {"sha": "f5d72ab69b997a62dc5c240de1a180b8a96daf71", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5d72ab69b997a62dc5c240de1a180b8a96daf71", "html_url": "https://github.com/rust-lang/rust/commit/f5d72ab69b997a62dc5c240de1a180b8a96daf71"}], "stats": {"total": 104, "additions": 69, "deletions": 35}, "files": [{"sha": "a201af0103070afa544b539b16b50ceb5fd90353", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 53, "deletions": 32, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f4a8cf0a00580eeb093774681db74e5f2ba57c85/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a8cf0a00580eeb093774681db74e5f2ba57c85/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=f4a8cf0a00580eeb093774681db74e5f2ba57c85", "patch": "@@ -652,6 +652,43 @@ impl<T: Ord> BinaryHeap<T> {\n         unsafe { self.sift_up(start, pos) };\n     }\n \n+    /// Rebuild assuming data[0..start] is still a proper heap.\n+    fn rebuild_tail(&mut self, start: usize) {\n+        if start == self.len() {\n+            return;\n+        }\n+\n+        let tail_len = self.len() - start;\n+\n+        #[inline(always)]\n+        fn log2_fast(x: usize) -> usize {\n+            (usize::BITS - x.leading_zeros() - 1) as usize\n+        }\n+\n+        // `rebuild` takes O(self.len()) operations\n+        // and about 2 * self.len() comparisons in the worst case\n+        // while repeating `sift_up` takes O(tail_len * log(start)) operations\n+        // and about 1 * tail_len * log_2(start) comparisons in the worst case,\n+        // assuming start >= tail_len. For larger heaps, the crossover point\n+        // no longer follows this reasoning and was determined empirically.\n+        let better_to_rebuild = if start < tail_len {\n+            true\n+        } else if self.len() <= 2048 {\n+            2 * self.len() < tail_len * log2_fast(start)\n+        } else {\n+            2 * self.len() < tail_len * 11\n+        };\n+\n+        if better_to_rebuild {\n+            self.rebuild();\n+        } else {\n+            for i in start..self.len() {\n+                // SAFETY: The index `i` is always less than self.len().\n+                unsafe { self.sift_up(0, i) };\n+            }\n+        }\n+    }\n+\n     fn rebuild(&mut self) {\n         let mut n = self.len() / 2;\n         while n > 0 {\n@@ -689,37 +726,11 @@ impl<T: Ord> BinaryHeap<T> {\n             swap(self, other);\n         }\n \n-        if other.is_empty() {\n-            return;\n-        }\n-\n-        #[inline(always)]\n-        fn log2_fast(x: usize) -> usize {\n-            (usize::BITS - x.leading_zeros() - 1) as usize\n-        }\n+        let start = self.data.len();\n \n-        // `rebuild` takes O(len1 + len2) operations\n-        // and about 2 * (len1 + len2) comparisons in the worst case\n-        // while `extend` takes O(len2 * log(len1)) operations\n-        // and about 1 * len2 * log_2(len1) comparisons in the worst case,\n-        // assuming len1 >= len2. For larger heaps, the crossover point\n-        // no longer follows this reasoning and was determined empirically.\n-        #[inline]\n-        fn better_to_rebuild(len1: usize, len2: usize) -> bool {\n-            let tot_len = len1 + len2;\n-            if tot_len <= 2048 {\n-                2 * tot_len < len2 * log2_fast(len1)\n-            } else {\n-                2 * tot_len < len2 * 11\n-            }\n-        }\n+        self.data.append(&mut other.data);\n \n-        if better_to_rebuild(self.len(), other.len()) {\n-            self.data.append(&mut other.data);\n-            self.rebuild();\n-        } else {\n-            self.extend(other.drain());\n-        }\n+        self.rebuild_tail(start);\n     }\n \n     /// Returns an iterator which retrieves elements in heap order.\n@@ -770,12 +781,22 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.into_sorted_vec(), [-10, 2, 4])\n     /// ```\n     #[unstable(feature = \"binary_heap_retain\", issue = \"71503\")]\n-    pub fn retain<F>(&mut self, f: F)\n+    pub fn retain<F>(&mut self, mut f: F)\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        self.data.retain(f);\n-        self.rebuild();\n+        let mut first_removed = self.len();\n+        let mut i = 0;\n+        self.data.retain(|e| {\n+            let keep = f(e);\n+            if !keep && i < first_removed {\n+                first_removed = i;\n+            }\n+            i += 1;\n+            keep\n+        });\n+        // data[0..first_removed] is untouched, so we only need to rebuild the tail:\n+        self.rebuild_tail(first_removed);\n     }\n }\n "}, {"sha": "a7913dcd28740bb88f343909828f47e078b0a71d", "filename": "library/alloc/tests/binary_heap.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f4a8cf0a00580eeb093774681db74e5f2ba57c85/library%2Falloc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a8cf0a00580eeb093774681db74e5f2ba57c85/library%2Falloc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fbinary_heap.rs?ref=f4a8cf0a00580eeb093774681db74e5f2ba57c85", "patch": "@@ -386,10 +386,23 @@ fn assert_covariance() {\n \n #[test]\n fn test_retain() {\n-    let mut a = BinaryHeap::from(vec![-10, -5, 1, 2, 4, 13]);\n-    a.retain(|x| x % 2 == 0);\n+    let mut a = BinaryHeap::from(vec![100, 10, 50, 1, 2, 20, 30]);\n+    a.retain(|&x| x != 2);\n \n-    assert_eq!(a.into_sorted_vec(), [-10, 2, 4])\n+    // Check that 20 moved into 10's place.\n+    assert_eq!(a.clone().into_vec(), [100, 20, 50, 1, 10, 30]);\n+\n+    a.retain(|_| true);\n+\n+    assert_eq!(a.clone().into_vec(), [100, 20, 50, 1, 10, 30]);\n+\n+    a.retain(|&x| x < 50);\n+\n+    assert_eq!(a.clone().into_vec(), [30, 20, 10, 1]);\n+\n+    a.retain(|_| false);\n+\n+    assert!(a.is_empty());\n }\n \n // old binaryheap failed this test"}]}