{"sha": "2bc59c7ae2631863e947ccdba42b989feeec6b36", "node_id": "C_kwDOAAsO6NoAKDJiYzU5YzdhZTI2MzE4NjNlOTQ3Y2NkYmE0MmI5ODlmZWVlYzZiMzY", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-12T11:08:47Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-21T08:59:11Z"}, "message": "add some helper methods to ScalarInt", "tree": {"sha": "ba7de5aeacb2ee6e6f72404c4af8c04e0a7931c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba7de5aeacb2ee6e6f72404c4af8c04e0a7931c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bc59c7ae2631863e947ccdba42b989feeec6b36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bc59c7ae2631863e947ccdba42b989feeec6b36", "html_url": "https://github.com/rust-lang/rust/commit/2bc59c7ae2631863e947ccdba42b989feeec6b36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bc59c7ae2631863e947ccdba42b989feeec6b36/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5176945ad49005b82789be5700f5ae0e6efe5481", "url": "https://api.github.com/repos/rust-lang/rust/commits/5176945ad49005b82789be5700f5ae0e6efe5481", "html_url": "https://github.com/rust-lang/rust/commit/5176945ad49005b82789be5700f5ae0e6efe5481"}], "stats": {"total": 92, "additions": 92, "deletions": 0}, "files": [{"sha": "a3ce674c115241614060f95d118b14f6b313362e", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/2bc59c7ae2631863e947ccdba42b989feeec6b36/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bc59c7ae2631863e947ccdba42b989feeec6b36/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=2bc59c7ae2631863e947ccdba42b989feeec6b36", "patch": "@@ -237,6 +237,98 @@ impl ScalarInt {\n     pub fn try_to_machine_usize<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Result<u64, Size> {\n         Ok(self.to_bits(tcx.data_layout.pointer_size)? as u64)\n     }\n+\n+    /// Tries to convert the `ScalarInt` to an unsigned integer of the given size.\n+    /// Fails if the size of the `ScalarInt` is unequal to `size` and returns the\n+    /// `ScalarInt`s size in that case.\n+    #[inline]\n+    pub fn try_to_uint(self, size: Size) -> Result<u128, Size> {\n+        self.to_bits(size)\n+    }\n+\n+    // Tries to convert the `ScalarInt` to `u8`. Fails if the `size` of the `ScalarInt`\n+    // in not equal to `Size { raw: 1 }` and returns the `size` value of the `ScalarInt` in\n+    // that case.\n+    #[inline]\n+    pub fn try_to_u8(self) -> Result<u8, Size> {\n+        self.to_bits(Size::from_bits(8)).map(|v| u8::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to `u16`. Fails if the size of the `ScalarInt`\n+    /// in not equal to `Size { raw: 2 }` and returns the `size` value of the `ScalarInt` in\n+    /// that case.\n+    #[inline]\n+    pub fn try_to_u16(self) -> Result<u16, Size> {\n+        self.to_bits(Size::from_bits(16)).map(|v| u16::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to `u32`. Fails if the `size` of the `ScalarInt`\n+    /// in not equal to `Size { raw: 4 }` and returns the `size` value of the `ScalarInt` in\n+    /// that case.\n+    #[inline]\n+    pub fn try_to_u32(self) -> Result<u32, Size> {\n+        self.to_bits(Size::from_bits(32)).map(|v| u32::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to `u64`. Fails if the `size` of the `ScalarInt`\n+    /// in not equal to `Size { raw: 8 }` and returns the `size` value of the `ScalarInt` in\n+    /// that case.\n+    #[inline]\n+    pub fn try_to_u64(self) -> Result<u64, Size> {\n+        self.to_bits(Size::from_bits(64)).map(|v| u64::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to `u128`. Fails if the `size` of the `ScalarInt`\n+    /// in not equal to `Size { raw: 16 }` and returns the `size` value of the `ScalarInt` in\n+    /// that case.\n+    #[inline]\n+    pub fn try_to_u128(self) -> Result<u128, Size> {\n+        self.to_bits(Size::from_bits(128))\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to a signed integer of the given size.\n+    /// Fails if the size of the `ScalarInt` is unequal to `size` and returns the\n+    /// `ScalarInt`s size in that case.\n+    #[inline]\n+    pub fn try_to_int(self, size: Size) -> Result<i128, Size> {\n+        let b = self.to_bits(size)?;\n+        Ok(size.sign_extend(b) as i128)\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to i8.\n+    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 1 }`\n+    /// and returns the `ScalarInt`s size in that case.\n+    pub fn try_to_i8(self) -> Result<i8, Size> {\n+        self.try_to_int(Size::from_bits(8)).map(|v| i8::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to i16.\n+    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 2 }`\n+    /// and returns the `ScalarInt`s size in that case.\n+    pub fn try_to_i16(self) -> Result<i16, Size> {\n+        self.try_to_int(Size::from_bits(16)).map(|v| i16::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to i32.\n+    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 4 }`\n+    /// and returns the `ScalarInt`s size in that case.\n+    pub fn try_to_i32(self) -> Result<i32, Size> {\n+        self.try_to_int(Size::from_bits(32)).map(|v| i32::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to i64.\n+    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 8 }`\n+    /// and returns the `ScalarInt`s size in that case.\n+    pub fn try_to_i64(self) -> Result<i64, Size> {\n+        self.try_to_int(Size::from_bits(64)).map(|v| i64::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to i128.\n+    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 16 }`\n+    /// and returns the `ScalarInt`s size in that case.\n+    pub fn try_to_i128(self) -> Result<i128, Size> {\n+        self.try_to_int(Size::from_bits(128)).map(|v| i128::try_from(v).unwrap())\n+    }\n }\n \n macro_rules! from {"}]}