{"sha": "43c47db0b04627dbd0e16a1e7cad14a4a5a60d3a", "node_id": "C_kwDOAAsO6NoAKDQzYzQ3ZGIwYjA0NjI3ZGJkMGUxNmExZTdjYWQxNGE0YTVhNjBkM2E", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-17T15:10:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-17T15:10:04Z"}, "message": "Auto merge of #98097 - lqd:const-alloc-hash, r=oli-obk\n\nctfe: limit hashing of big const allocations when interning\n\nConst allocations are only hashed for interning. However, they can be large, making the hashing expensive especially since it uses `FxHash`: it's better suited to short keys, not potentially big buffers like the actual bytes of allocation and the associated 1/8th sized `InitMask`.\n\nWe can partially hash these fields when they're large, hashing the length, and head and tail of these buffers, to\nlimit possible collisions while avoiding most of the hashing work.\n\nr? `@ghost`", "tree": {"sha": "39e03aaf205309abd4b2a5f70f3ad0276af594b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39e03aaf205309abd4b2a5f70f3ad0276af594b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43c47db0b04627dbd0e16a1e7cad14a4a5a60d3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43c47db0b04627dbd0e16a1e7cad14a4a5a60d3a", "html_url": "https://github.com/rust-lang/rust/commit/43c47db0b04627dbd0e16a1e7cad14a4a5a60d3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43c47db0b04627dbd0e16a1e7cad14a4a5a60d3a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "949a64ab20b9d5d4516416c4735b134e0496855a", "url": "https://api.github.com/repos/rust-lang/rust/commits/949a64ab20b9d5d4516416c4735b134e0496855a", "html_url": "https://github.com/rust-lang/rust/commit/949a64ab20b9d5d4516416c4735b134e0496855a"}, {"sha": "61dc08037551330f3cdb9ca97736d661c9e939dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/61dc08037551330f3cdb9ca97736d661c9e939dc", "html_url": "https://github.com/rust-lang/rust/commit/61dc08037551330f3cdb9ca97736d661c9e939dc"}], "stats": {"total": 77, "additions": 75, "deletions": 2}, "files": [{"sha": "11a35109fde8b1193c2b1e714b60abfd8769b668", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 75, "deletions": 2, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/43c47db0b04627dbd0e16a1e7cad14a4a5a60d3a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c47db0b04627dbd0e16a1e7cad14a4a5a60d3a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=43c47db0b04627dbd0e16a1e7cad14a4a5a60d3a", "patch": "@@ -3,6 +3,7 @@\n use std::borrow::Cow;\n use std::convert::{TryFrom, TryInto};\n use std::fmt;\n+use std::hash;\n use std::iter;\n use std::ops::{Deref, Range};\n use std::ptr;\n@@ -25,7 +26,9 @@ use crate::ty;\n /// Its public API is rather low-level, working directly with allocation offsets and a custom error\n /// type to account for the lack of an AllocId on this level. The Miri/CTFE core engine `memory`\n /// module provides higher-level access.\n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n+// Note: for performance reasons when interning, some of the `Allocation` fields can be partially\n+// hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n+#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct Allocation<Tag = AllocId, Extra = ()> {\n     /// The actual bytes of the allocation.\n@@ -49,6 +52,46 @@ pub struct Allocation<Tag = AllocId, Extra = ()> {\n     pub extra: Extra,\n }\n \n+/// This is the maximum size we will hash at a time, when interning an `Allocation` and its\n+/// `InitMask`. Note, we hash that amount of bytes twice: at the start, and at the end of a buffer.\n+/// Used when these two structures are large: we only partially hash the larger fields in that\n+/// situation. See the comment at the top of their respective `Hash` impl for more details.\n+const MAX_BYTES_TO_HASH: usize = 64;\n+\n+/// This is the maximum size (in bytes) for which a buffer will be fully hashed, when interning.\n+/// Otherwise, it will be partially hashed in 2 slices, requiring at least 2 `MAX_BYTES_TO_HASH`\n+/// bytes.\n+const MAX_HASHED_BUFFER_LEN: usize = 2 * MAX_BYTES_TO_HASH;\n+\n+// Const allocations are only hashed for interning. However, they can be large, making the hashing\n+// expensive especially since it uses `FxHash`: it's better suited to short keys, not potentially\n+// big buffers like the actual bytes of allocation. We can partially hash some fields when they're\n+// large.\n+impl hash::Hash for Allocation {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        // Partially hash the `bytes` buffer when it is large. To limit collisions with common\n+        // prefixes and suffixes, we hash the length and some slices of the buffer.\n+        let byte_count = self.bytes.len();\n+        if byte_count > MAX_HASHED_BUFFER_LEN {\n+            // Hash the buffer's length.\n+            byte_count.hash(state);\n+\n+            // And its head and tail.\n+            self.bytes[..MAX_BYTES_TO_HASH].hash(state);\n+            self.bytes[byte_count - MAX_BYTES_TO_HASH..].hash(state);\n+        } else {\n+            self.bytes.hash(state);\n+        }\n+\n+        // Hash the other fields as usual.\n+        self.relocations.hash(state);\n+        self.init_mask.hash(state);\n+        self.align.hash(state);\n+        self.mutability.hash(state);\n+        self.extra.hash(state);\n+    }\n+}\n+\n /// Interned types generally have an `Outer` type and an `Inner` type, where\n /// `Outer` is a newtype around `Interned<Inner>`, and all the operations are\n /// done on `Outer`, because all occurrences are interned. E.g. `Ty` is an\n@@ -665,13 +708,43 @@ type Block = u64;\n \n /// A bitmask where each bit refers to the byte with the same index. If the bit is `true`, the byte\n /// is initialized. If it is `false` the byte is uninitialized.\n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n+// Note: for performance reasons when interning, some of the `InitMask` fields can be partially\n+// hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n+#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct InitMask {\n     blocks: Vec<Block>,\n     len: Size,\n }\n \n+// Const allocations are only hashed for interning. However, they can be large, making the hashing\n+// expensive especially since it uses `FxHash`: it's better suited to short keys, not potentially\n+// big buffers like the allocation's init mask. We can partially hash some fields when they're\n+// large.\n+impl hash::Hash for InitMask {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        const MAX_BLOCKS_TO_HASH: usize = MAX_BYTES_TO_HASH / std::mem::size_of::<Block>();\n+        const MAX_BLOCKS_LEN: usize = MAX_HASHED_BUFFER_LEN / std::mem::size_of::<Block>();\n+\n+        // Partially hash the `blocks` buffer when it is large. To limit collisions with common\n+        // prefixes and suffixes, we hash the length and some slices of the buffer.\n+        let block_count = self.blocks.len();\n+        if block_count > MAX_BLOCKS_LEN {\n+            // Hash the buffer's length.\n+            block_count.hash(state);\n+\n+            // And its head and tail.\n+            self.blocks[..MAX_BLOCKS_TO_HASH].hash(state);\n+            self.blocks[block_count - MAX_BLOCKS_TO_HASH..].hash(state);\n+        } else {\n+            self.blocks.hash(state);\n+        }\n+\n+        // Hash the other fields as usual.\n+        self.len.hash(state);\n+    }\n+}\n+\n impl InitMask {\n     pub const BLOCK_SIZE: u64 = 64;\n "}]}