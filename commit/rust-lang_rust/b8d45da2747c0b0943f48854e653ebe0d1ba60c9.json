{"sha": "b8d45da2747c0b0943f48854e653ebe0d1ba60c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ZDQ1ZGEyNzQ3YzBiMDk0M2Y0ODg1NGU2NTNlYmUwZDFiYTYwYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-10T07:48:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-10T07:48:45Z"}, "message": "Auto merge of #53565 - PramodBisht:issue/53359_b, r=estebank\n\n#53359: putting multiple unresolved import on single line\n\nr? @estebank\nHere is WIP implementation of #53359\nthis PR have clubbed multiple unresolved imports into a single line.\nI think still two things need to improve like giving specific `label message` for each span of multi_span(how we can do this?) and second we are getting a warning while compiling, stating something like `E0432` have been passed before.", "tree": {"sha": "a799d73e3d2b487dd8a4486f6dfc33c6fb558920", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a799d73e3d2b487dd8a4486f6dfc33c6fb558920"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8d45da2747c0b0943f48854e653ebe0d1ba60c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8d45da2747c0b0943f48854e653ebe0d1ba60c9", "html_url": "https://github.com/rust-lang/rust/commit/b8d45da2747c0b0943f48854e653ebe0d1ba60c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8d45da2747c0b0943f48854e653ebe0d1ba60c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb945f0ebba1a6d5d0f9d0b62dedacd6c828fff7", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb945f0ebba1a6d5d0f9d0b62dedacd6c828fff7", "html_url": "https://github.com/rust-lang/rust/commit/fb945f0ebba1a6d5d0f9d0b62dedacd6c828fff7"}, {"sha": "21ba03e2b910cf58dd5c21c8dd97d4f66b6518c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/21ba03e2b910cf58dd5c21c8dd97d4f66b6518c5", "html_url": "https://github.com/rust-lang/rust/commit/21ba03e2b910cf58dd5c21c8dd97d4f66b6518c5"}], "stats": {"total": 113, "additions": 86, "deletions": 27}, "files": [{"sha": "bfdf158bbbbf984b326c59bb3934c6e2820b0119", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8d45da2747c0b0943f48854e653ebe0d1ba60c9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d45da2747c0b0943f48854e653ebe0d1ba60c9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b8d45da2747c0b0943f48854e653ebe0d1ba60c9", "patch": "@@ -160,8 +160,6 @@ enum ResolutionError<'a> {\n     SelfImportCanOnlyAppearOnceInTheList,\n     /// error E0431: `self` import can only appear in an import list with a non-empty prefix\n     SelfImportOnlyInImportListWithNonEmptyPrefix,\n-    /// error E0432: unresolved import\n-    UnresolvedImport(Option<(Span, &'a str, &'a str)>),\n     /// error E0433: failed to resolve\n     FailedToResolve(&'a str),\n     /// error E0434: can't capture dynamic environment in a fn item\n@@ -370,17 +368,6 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             err.span_label(span, \"can only appear in an import list with a non-empty prefix\");\n             err\n         }\n-        ResolutionError::UnresolvedImport(name) => {\n-            let (span, msg) = match name {\n-                Some((sp, n, _)) => (sp, format!(\"unresolved import `{}`\", n)),\n-                None => (span, \"unresolved import\".to_owned()),\n-            };\n-            let mut err = struct_span_err!(resolver.session, span, E0432, \"{}\", msg);\n-            if let Some((_, _, p)) = name {\n-                err.span_label(span, p);\n-            }\n-            err\n-        }\n         ResolutionError::FailedToResolve(msg) => {\n             let mut err = struct_span_err!(resolver.session, span, E0433,\n                                            \"failed to resolve. {}\", msg);"}, {"sha": "e5e640b1492954cda90436d6b87a2e7a95c51cd8", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b8d45da2747c0b0943f48854e653ebe0d1ba60c9/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d45da2747c0b0943f48854e653ebe0d1ba60c9/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=b8d45da2747c0b0943f48854e653ebe0d1ba60c9", "patch": "@@ -31,7 +31,7 @@ use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::keywords;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax_pos::Span;\n+use syntax_pos::{MultiSpan, Span};\n \n use std::cell::{Cell, RefCell};\n use std::collections::BTreeMap;\n@@ -632,6 +632,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n         let mut errors = false;\n         let mut seen_spans = FxHashSet();\n+        let mut error_vec = Vec::new();\n+        let mut prev_root_id: NodeId = NodeId::new(0);\n         for i in 0 .. self.determined_imports.len() {\n             let import = self.determined_imports[i];\n             let error = self.finalize_import(import);\n@@ -694,13 +696,22 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 // If the error is a single failed import then create a \"fake\" import\n                 // resolution for it so that later resolve stages won't complain.\n                 self.import_dummy_binding(import);\n+                if prev_root_id.as_u32() != 0 &&\n+                    prev_root_id.as_u32() != import.root_id.as_u32() &&\n+                    !error_vec.is_empty(){\n+                    // in case of new import line, throw diagnostic message\n+                    // for previous line.\n+                    let mut empty_vec = vec![];\n+                    mem::swap(&mut empty_vec, &mut error_vec);\n+                    self.throw_unresolved_import_error(empty_vec, None);\n+                }\n                 if !seen_spans.contains(&span) {\n                     let path = import_path_to_string(&import.module_path[..],\n                                                      &import.subclass,\n                                                      span);\n-                    let error = ResolutionError::UnresolvedImport(Some((span, &path, &err)));\n-                    resolve_error(self.resolver, span, error);\n+                    error_vec.push((span, path, err));\n                     seen_spans.insert(span);\n+                    prev_root_id = import.root_id;\n                 }\n             }\n         }\n@@ -749,21 +760,48 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             });\n         }\n \n+        if !error_vec.is_empty() {\n+            self.throw_unresolved_import_error(error_vec.clone(), None);\n+        }\n+\n         // Report unresolved imports only if no hard error was already reported\n         // to avoid generating multiple errors on the same import.\n         if !errors {\n             for import in &self.indeterminate_imports {\n                 if import.is_uniform_paths_canary {\n                     continue;\n                 }\n-\n-                let error = ResolutionError::UnresolvedImport(None);\n-                resolve_error(self.resolver, import.span, error);\n+                self.throw_unresolved_import_error(error_vec, Some(MultiSpan::from(import.span)));\n                 break;\n             }\n         }\n     }\n \n+    fn throw_unresolved_import_error(&self, error_vec: Vec<(Span, String, String)>,\n+                                     span: Option<MultiSpan>) {\n+        let max_span_label_msg_count = 10;  // upper limit on number of span_label message.\n+        let (span,msg) = match error_vec.is_empty() {\n+            true => (span.unwrap(), \"unresolved import\".to_string()),\n+            false => {\n+                let span = MultiSpan::from_spans(error_vec.clone().into_iter()\n+                                    .map(|elem: (Span, String, String)| { elem.0 }\n+                                    ).collect());\n+                let path_vec: Vec<String> = error_vec.clone().into_iter()\n+                                .map(|elem: (Span, String, String)| { format!(\"`{}`\", elem.1) }\n+                                ).collect();\n+                let path = path_vec.join(\", \");\n+                let msg = format!(\"unresolved import{} {}\",\n+                                if path_vec.len() > 1 { \"s\" } else { \"\" },  path);\n+                (span, msg)\n+            }\n+        };\n+        let mut err = struct_span_err!(self.resolver.session, span, E0432, \"{}\", &msg);\n+        for span_error in error_vec.into_iter().take(max_span_label_msg_count) {\n+            err.span_label(span_error.0, span_error.2);\n+        }\n+        err.emit();\n+    }\n+\n     /// Attempts to resolve the given import, returning true if its resolution is determined.\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {"}, {"sha": "0a0b1d573dd04e9fcf64aa95d9a4644e71fbc5c5", "filename": "src/test/ui/dollar-crate/dollar-crate-is-keyword-2.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b8d45da2747c0b0943f48854e653ebe0d1ba60c9/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8d45da2747c0b0943f48854e653ebe0d1ba60c9/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword-2.stderr?ref=b8d45da2747c0b0943f48854e653ebe0d1ba60c9", "patch": "@@ -1,17 +1,17 @@\n-error[E0432]: unresolved import `a::$crate`\n-  --> $DIR/dollar-crate-is-keyword-2.rs:15:13\n+error[E0433]: failed to resolve. `$crate` in paths can only be used in start position\n+  --> $DIR/dollar-crate-is-keyword-2.rs:16:16\n    |\n-LL |         use a::$crate; //~ ERROR unresolved import `a::$crate`\n-   |             ^^^^^^^^^ no `$crate` in `a`\n+LL |         use a::$crate::b; //~ ERROR `$crate` in paths can only be used in start position\n+   |                ^^^^^^ `$crate` in paths can only be used in start position\n ...\n LL | m!();\n    | ----- in this macro invocation\n \n-error[E0433]: failed to resolve. `$crate` in paths can only be used in start position\n-  --> $DIR/dollar-crate-is-keyword-2.rs:16:16\n+error[E0432]: unresolved import `a::$crate`\n+  --> $DIR/dollar-crate-is-keyword-2.rs:15:13\n    |\n-LL |         use a::$crate::b; //~ ERROR `$crate` in paths can only be used in start position\n-   |                ^^^^^^ `$crate` in paths can only be used in start position\n+LL |         use a::$crate; //~ ERROR unresolved import `a::$crate`\n+   |             ^^^^^^^^^ no `$crate` in `a`\n ...\n LL | m!();\n    | ----- in this macro invocation"}, {"sha": "2bf38296f2687c4ccf8c50ee529e78482c977688", "filename": "src/test/ui/issue-53565.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8d45da2747c0b0943f48854e653ebe0d1ba60c9/src%2Ftest%2Fui%2Fissue-53565.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d45da2747c0b0943f48854e653ebe0d1ba60c9/src%2Ftest%2Fui%2Fissue-53565.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-53565.rs?ref=b8d45da2747c0b0943f48854e653ebe0d1ba60c9", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use std::time::{foo, bar, buzz};\n+use std::time::{abc, def};\n+fn main(){\n+   println!(\"Hello World!\");\n+}"}, {"sha": "945f5efe4a878103996f73487039d17be9a2a38a", "filename": "src/test/ui/issue-53565.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b8d45da2747c0b0943f48854e653ebe0d1ba60c9/src%2Ftest%2Fui%2Fissue-53565.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8d45da2747c0b0943f48854e653ebe0d1ba60c9/src%2Ftest%2Fui%2Fissue-53565.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-53565.stderr?ref=b8d45da2747c0b0943f48854e653ebe0d1ba60c9", "patch": "@@ -0,0 +1,20 @@\n+error[E0432]: unresolved imports `std::time::foo`, `std::time::bar`, `std::time::buzz`\n+  --> $DIR/issue-53565.rs:10:17\n+   |\n+LL | use std::time::{foo, bar, buzz};\n+   |                 ^^^  ^^^  ^^^^ no `buzz` in `time`\n+   |                 |    |\n+   |                 |    no `bar` in `time`\n+   |                 no `foo` in `time`\n+\n+error[E0432]: unresolved imports `std::time::abc`, `std::time::def`\n+  --> $DIR/issue-53565.rs:11:17\n+   |\n+LL | use std::time::{abc, def};\n+   |                 ^^^  ^^^ no `def` in `time`\n+   |                 |\n+   |                 no `abc` in `time`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0432`."}]}