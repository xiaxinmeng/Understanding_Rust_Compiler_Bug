{"sha": "95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZWY1ZWIzYWYyNGJmMGMwMGQ2OTcwZGM5M2ZkNzFhZWNmZjUxZDM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-03-28T07:43:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-28T07:43:36Z"}, "message": "Rollup merge of #59413 - Zoxc:hirid, r=oli-obk\n\nHirIdify hir::ItemId\n\nVersion of https://github.com/rust-lang/rust/pull/59092.\n\nr? @oli-obk", "tree": {"sha": "60aa7c3ed6ce2b436b1f123d63c082bea0d3de32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60aa7c3ed6ce2b436b1f123d63c082bea0d3de32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcnHsoCRBK7hj4Ov3rIwAAdHIIACoW0y5hdhoB/aXZYdD5R1g3\n42IrdPT+Ie/3tZ8+a70yR/QunwqmoVMtT8pfulH50hrSTquK25jHYQSxBi62XW4O\nu/tfmwEvKiPQQShzr3Sc4NOBclVxbNKpk8PkPOfGGUGlYm2xyuY9eltEfLCcEKyk\no3tCW+N7wwACQhfpNRfTv5/1Y4qyTmlxJ9xILf/24DkGVNEciDsVBf0fRzwd7IkC\n6XL/zyqx4dAHgJeqyiCOHIObG6+By+5W47IY09CTRV1YI38wDPNWaqtNG10CASAd\n5Yg/Gq83fgVwVwhdSEVF6a3vcBkPLjfrnBWuLwUj29x6yuTnDX2ZcOQ0vW4HtwU=\n=wuFX\n-----END PGP SIGNATURE-----\n", "payload": "tree 60aa7c3ed6ce2b436b1f123d63c082bea0d3de32\nparent e04b7b8f54e556d514e356f9086085b471637254\nparent f7c66fb625ad61bcac325c844180c1c32a04aa13\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1553759016 +0100\ncommitter GitHub <noreply@github.com> 1553759016 +0100\n\nRollup merge of #59413 - Zoxc:hirid, r=oli-obk\n\nHirIdify hir::ItemId\n\nVersion of https://github.com/rust-lang/rust/pull/59092.\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "html_url": "https://github.com/rust-lang/rust/commit/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e04b7b8f54e556d514e356f9086085b471637254", "url": "https://api.github.com/repos/rust-lang/rust/commits/e04b7b8f54e556d514e356f9086085b471637254", "html_url": "https://github.com/rust-lang/rust/commit/e04b7b8f54e556d514e356f9086085b471637254"}, {"sha": "f7c66fb625ad61bcac325c844180c1c32a04aa13", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7c66fb625ad61bcac325c844180c1c32a04aa13", "html_url": "https://github.com/rust-lang/rust/commit/f7c66fb625ad61bcac325c844180c1c32a04aa13"}], "stats": {"total": 187, "additions": 106, "deletions": 81}, "files": [{"sha": "39069b66f2904c32895709fb25f02e75f93d0b4d", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "patch": "@@ -163,7 +163,7 @@ pub trait Visitor<'v> : Sized {\n     /// but cannot supply a `Map`; see `nested_visit_map` for advice.\n     #[allow(unused_variables)]\n     fn visit_nested_item(&mut self, id: ItemId) {\n-        let opt_item = self.nested_visit_map().inter().map(|map| map.expect_item(id.id));\n+        let opt_item = self.nested_visit_map().inter().map(|map| map.expect_item_by_hir_id(id.id));\n         if let Some(item) = opt_item {\n             self.visit_item(item);\n         }"}, {"sha": "7dfb16602a3d44d911d9d05c451dc10f9053e3e4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 75, "deletions": 50, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "patch": "@@ -51,7 +51,6 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::sync::Lrc;\n \n use std::collections::{BTreeSet, BTreeMap};\n-use std::fmt::Debug;\n use std::mem;\n use smallvec::SmallVec;\n use syntax::attr;\n@@ -82,7 +81,7 @@ pub struct LoweringContext<'a> {\n     resolver: &'a mut dyn Resolver,\n \n     /// The items being lowered are collected here.\n-    items: BTreeMap<NodeId, hir::Item>,\n+    items: BTreeMap<hir::HirId, hir::Item>,\n \n     trait_items: BTreeMap<hir::TraitItemId, hir::TraitItem>,\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n@@ -321,7 +320,7 @@ enum AnonymousLifetimeMode {\n     PassThrough,\n }\n \n-struct ImplTraitTypeIdVisitor<'a> { ids: &'a mut SmallVec<[hir::ItemId; 1]> }\n+struct ImplTraitTypeIdVisitor<'a> { ids: &'a mut SmallVec<[NodeId; 1]> }\n \n impl<'a, 'b> Visitor<'a> for ImplTraitTypeIdVisitor<'b> {\n     fn visit_ty(&mut self, ty: &'a Ty) {\n@@ -330,7 +329,7 @@ impl<'a, 'b> Visitor<'a> for ImplTraitTypeIdVisitor<'b> {\n             | TyKind::BareFn(_)\n             => return,\n \n-            TyKind::ImplTrait(id, _) => self.ids.push(hir::ItemId { id }),\n+            TyKind::ImplTrait(id, _) => self.ids.push(id),\n             _ => {},\n         }\n         visit::walk_ty(self, ty);\n@@ -361,9 +360,40 @@ impl<'a> LoweringContext<'a> {\n             lctx: &'lcx mut LoweringContext<'interner>,\n         }\n \n+        impl MiscCollector<'_, '_> {\n+            fn allocate_use_tree_hir_id_counters(\n+                &mut self,\n+                tree: &UseTree,\n+                owner: DefIndex,\n+            ) {\n+                match tree.kind {\n+                    UseTreeKind::Simple(_, id1, id2) => {\n+                        for &id in &[id1, id2] {\n+                            self.lctx.resolver.definitions().create_def_with_parent(\n+                                owner,\n+                                id,\n+                                DefPathData::Misc,\n+                                DefIndexAddressSpace::High,\n+                                Mark::root(),\n+                                tree.prefix.span,\n+                            );\n+                            self.lctx.allocate_hir_id_counter(id);\n+                        }\n+                    }\n+                    UseTreeKind::Glob => (),\n+                    UseTreeKind::Nested(ref trees) => {\n+                        for &(ref use_tree, id) in trees {\n+                            let hir_id = self.lctx.allocate_hir_id_counter(id).hir_id;\n+                            self.allocate_use_tree_hir_id_counters(use_tree, hir_id.owner);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         impl<'lcx, 'interner> Visitor<'lcx> for MiscCollector<'lcx, 'interner> {\n             fn visit_item(&mut self, item: &'lcx Item) {\n-                self.lctx.allocate_hir_id_counter(item.id, item);\n+                let hir_id = self.lctx.allocate_hir_id_counter(item.id).hir_id;\n \n                 match item.node {\n                     ItemKind::Struct(_, ref generics)\n@@ -383,18 +413,21 @@ impl<'a> LoweringContext<'a> {\n                             .count();\n                         self.lctx.type_def_lifetime_params.insert(def_id, count);\n                     }\n+                    ItemKind::Use(ref use_tree) => {\n+                        self.allocate_use_tree_hir_id_counters(use_tree, hir_id.owner);\n+                    }\n                     _ => {}\n                 }\n                 visit::walk_item(self, item);\n             }\n \n             fn visit_trait_item(&mut self, item: &'lcx TraitItem) {\n-                self.lctx.allocate_hir_id_counter(item.id, item);\n+                self.lctx.allocate_hir_id_counter(item.id);\n                 visit::walk_trait_item(self, item);\n             }\n \n             fn visit_impl_item(&mut self, item: &'lcx ImplItem) {\n-                self.lctx.allocate_hir_id_counter(item.id, item);\n+                self.lctx.allocate_hir_id_counter(item.id);\n                 visit::walk_impl_item(self, item);\n             }\n         }\n@@ -434,17 +467,16 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             fn visit_item(&mut self, item: &'lcx Item) {\n-                let mut item_lowered = true;\n+                let mut item_hir_id = None;\n                 self.lctx.with_hir_id_owner(item.id, |lctx| {\n                     if let Some(hir_item) = lctx.lower_item(item) {\n-                        lctx.insert_item(item.id, hir_item);\n-                    } else {\n-                        item_lowered = false;\n+                        item_hir_id = Some(hir_item.hir_id);\n+                        lctx.insert_item(hir_item);\n                     }\n                 });\n \n-                if item_lowered {\n-                    let item_generics = match self.lctx.items.get(&item.id).unwrap().node {\n+                if let Some(hir_id) = item_hir_id {\n+                    let item_generics = match self.lctx.items.get(&hir_id).unwrap().node {\n                         hir::ItemKind::Impl(_, _, _, ref generics, ..)\n                         | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n                             generics.params.clone()\n@@ -516,20 +548,21 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn insert_item(&mut self, id: NodeId, item: hir::Item) {\n+    fn insert_item(&mut self, item: hir::Item) {\n+        let id = item.hir_id;\n+        // FIXME: Use debug_asset-rt\n+        assert_eq!(id.local_id, hir::ItemLocalId::from_u32(0));\n         self.items.insert(id, item);\n         self.modules.get_mut(&self.current_module).unwrap().items.insert(id);\n     }\n \n-    fn allocate_hir_id_counter<T: Debug>(&mut self, owner: NodeId, debug: &T) -> LoweredNodeId {\n-        if self.item_local_id_counters.insert(owner, 0).is_some() {\n-            bug!(\n-                \"Tried to allocate item_local_id_counter for {:?} twice\",\n-                debug\n-            );\n-        }\n+    fn allocate_hir_id_counter(&mut self, owner: NodeId) -> LoweredNodeId {\n+        // Setup the counter if needed\n+        self.item_local_id_counters.entry(owner).or_insert(0);\n         // Always allocate the first `HirId` for the owner itself.\n-        self.lower_node_id_with_owner(owner, owner)\n+        let lowered = self.lower_node_id_with_owner(owner, owner);\n+        debug_assert_eq!(lowered.hir_id.local_id.as_u32(), 0);\n+        lowered\n     }\n \n     fn lower_node_id_generic<F>(&mut self, ast_node_id: NodeId, alloc_hir_id: F) -> LoweredNodeId\n@@ -1381,7 +1414,7 @@ impl<'a> LoweringContext<'a> {\n             .opt_def_index(exist_ty_node_id)\n             .unwrap();\n \n-        self.allocate_hir_id_counter(exist_ty_node_id, &\"existential impl trait\");\n+        self.allocate_hir_id_counter(exist_ty_node_id);\n \n         let hir_bounds = self.with_hir_id_owner(exist_ty_node_id, lower_bounds);\n \n@@ -1422,10 +1455,10 @@ impl<'a> LoweringContext<'a> {\n             // Insert the item into the global list. This usually happens\n             // automatically for all AST items. But this existential type item\n             // does not actually exist in the AST.\n-            lctx.insert_item(exist_ty_id.node_id, exist_ty_item);\n+            lctx.insert_item(exist_ty_item);\n \n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n-            hir::TyKind::Def(hir::ItemId { id: exist_ty_id.node_id }, lifetimes)\n+            hir::TyKind::Def(hir::ItemId { id: exist_ty_id.hir_id }, lifetimes)\n         })\n     }\n \n@@ -2002,9 +2035,9 @@ impl<'a> LoweringContext<'a> {\n         )\n     }\n \n-    fn lower_local(&mut self, l: &Local) -> (hir::Local, SmallVec<[hir::ItemId; 1]>) {\n+    fn lower_local(&mut self, l: &Local) -> (hir::Local, SmallVec<[NodeId; 1]>) {\n         let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(l.id);\n-        let mut ids = SmallVec::<[hir::ItemId; 1]>::new();\n+        let mut ids = SmallVec::<[NodeId; 1]>::new();\n         if self.sess.features_untracked().impl_trait_in_bindings {\n             if let Some(ref ty) = l.ty {\n                 let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n@@ -3065,7 +3098,6 @@ impl<'a> LoweringContext<'a> {\n                     }\n                 }\n \n-                let parent_def_index = self.current_hir_id_owner.last().unwrap().0;\n                 let mut defs = self.expect_full_def_from_use(id);\n                 // We want to return *something* from this function, so hold onto the first item\n                 // for later.\n@@ -3084,14 +3116,6 @@ impl<'a> LoweringContext<'a> {\n                         seg.id = self.sess.next_node_id();\n                     }\n                     let span = path.span;\n-                    self.resolver.definitions().create_def_with_parent(\n-                        parent_def_index,\n-                        new_node_id,\n-                        DefPathData::Misc,\n-                        DefIndexAddressSpace::High,\n-                        Mark::root(),\n-                        span);\n-                    self.allocate_hir_id_counter(new_node_id, &path);\n \n                     self.with_hir_id_owner(new_node_id, |this| {\n                         let new_id = this.lower_node_id(new_node_id);\n@@ -3114,7 +3138,6 @@ impl<'a> LoweringContext<'a> {\n                         let vis = respan(vis.span, vis_kind);\n \n                         this.insert_item(\n-                            new_id.node_id,\n                             hir::Item {\n                                 hir_id: new_id.hir_id,\n                                 ident,\n@@ -3174,8 +3197,6 @@ impl<'a> LoweringContext<'a> {\n \n                 // Add all the nested `PathListItem`s to the HIR.\n                 for &(ref use_tree, id) in trees {\n-                    self.allocate_hir_id_counter(id, &use_tree);\n-\n                     let LoweredNodeId {\n                         node_id: new_id,\n                         hir_id: new_hir_id,\n@@ -3219,7 +3240,6 @@ impl<'a> LoweringContext<'a> {\n                         let vis = respan(vis.span, vis_kind);\n \n                         this.insert_item(\n-                            new_id,\n                             hir::Item {\n                                 hir_id: new_hir_id,\n                                 ident,\n@@ -3443,43 +3463,47 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_item_id(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n-        match i.node {\n+        let node_ids = match i.node {\n             ItemKind::Use(ref use_tree) => {\n-                let mut vec = smallvec![hir::ItemId { id: i.id }];\n+                let mut vec = smallvec![i.id];\n                 self.lower_item_id_use_tree(use_tree, i.id, &mut vec);\n                 vec\n             }\n             ItemKind::MacroDef(..) => SmallVec::new(),\n             ItemKind::Fn(..) |\n-            ItemKind::Impl(.., None, _, _) => smallvec![hir::ItemId { id: i.id }],\n+            ItemKind::Impl(.., None, _, _) => smallvec![i.id],\n             ItemKind::Static(ref ty, ..) => {\n-                let mut ids = smallvec![hir::ItemId { id: i.id }];\n+                let mut ids = smallvec![i.id];\n                 if self.sess.features_untracked().impl_trait_in_bindings {\n                     let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n                     visitor.visit_ty(ty);\n                 }\n                 ids\n             },\n             ItemKind::Const(ref ty, ..) => {\n-                let mut ids = smallvec![hir::ItemId { id: i.id }];\n+                let mut ids = smallvec![i.id];\n                 if self.sess.features_untracked().impl_trait_in_bindings {\n                     let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n                     visitor.visit_ty(ty);\n                 }\n                 ids\n             },\n-            _ => smallvec![hir::ItemId { id: i.id }],\n-        }\n+            _ => smallvec![i.id],\n+        };\n+\n+        node_ids.into_iter().map(|node_id| hir::ItemId {\n+            id: self.allocate_hir_id_counter(node_id).hir_id\n+        }).collect()\n     }\n \n     fn lower_item_id_use_tree(&mut self,\n                               tree: &UseTree,\n                               base_id: NodeId,\n-                              vec: &mut SmallVec<[hir::ItemId; 1]>)\n+                              vec: &mut SmallVec<[NodeId; 1]>)\n     {\n         match tree.kind {\n             UseTreeKind::Nested(ref nested_vec) => for &(ref nested, id) in nested_vec {\n-                vec.push(hir::ItemId { id });\n+                vec.push(id);\n                 self.lower_item_id_use_tree(nested, id, vec);\n             },\n             UseTreeKind::Glob => {}\n@@ -3488,7 +3512,7 @@ impl<'a> LoweringContext<'a> {\n                                     .skip(1)\n                                     .zip([id1, id2].iter())\n                 {\n-                    vec.push(hir::ItemId { id });\n+                    vec.push(id);\n                 }\n             },\n         }\n@@ -4604,6 +4628,7 @@ impl<'a> LoweringContext<'a> {\n                 let mut ids: SmallVec<[hir::Stmt; 1]> = item_ids\n                     .into_iter()\n                     .map(|item_id| {\n+                        let item_id = hir::ItemId { id: self.lower_node_id(item_id).hir_id };\n                         let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n                         hir::Stmt {"}, {"sha": "f906ff9963d9ac3157c595192a7bb8fb652d52bc", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "patch": "@@ -609,7 +609,7 @@ impl<'hir> Map<'hir> {\n         let module = &self.forest.krate.modules[&node_id];\n \n         for id in &module.items {\n-            visitor.visit_item(self.expect_item(*id));\n+            visitor.visit_item(self.expect_item_by_hir_id(*id));\n         }\n \n         for id in &module.trait_items {\n@@ -1293,7 +1293,7 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n impl<'hir> print::PpAnn for Map<'hir> {\n     fn nested(&self, state: &mut print::State<'_>, nested: print::Nested) -> io::Result<()> {\n         match nested {\n-            Nested::Item(id) => state.print_item(self.expect_item(id.id)),\n+            Nested::Item(id) => state.print_item(self.expect_item_by_hir_id(id.id)),\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::Body(id) => state.print_expr(&self.body(id).value),"}, {"sha": "8509ddaccf7b49e35914278a5ccec84d71a17a8a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "patch": "@@ -698,7 +698,7 @@ pub struct WhereEqPredicate {\n pub struct ModuleItems {\n     // Use BTreeSets here so items are in the same order as in the\n     // list of all items in Crate\n-    pub items: BTreeSet<NodeId>,\n+    pub items: BTreeSet<HirId>,\n     pub trait_items: BTreeSet<TraitItemId>,\n     pub impl_items: BTreeSet<ImplItemId>,\n }\n@@ -722,7 +722,7 @@ pub struct Crate {\n     // does, because it can affect the order in which errors are\n     // detected, which in turn can make compile-fail tests yield\n     // slightly different results.\n-    pub items: BTreeMap<NodeId, Item>,\n+    pub items: BTreeMap<HirId, Item>,\n \n     pub trait_items: BTreeMap<TraitItemId, TraitItem>,\n     pub impl_items: BTreeMap<ImplItemId, ImplItem>,\n@@ -741,7 +741,7 @@ pub struct Crate {\n }\n \n impl Crate {\n-    pub fn item(&self, id: NodeId) -> &Item {\n+    pub fn item(&self, id: HirId) -> &Item {\n         &self.items[&id]\n     }\n \n@@ -2215,7 +2215,7 @@ impl VariantData {\n // so it can fetched later.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ItemId {\n-    pub id: NodeId,\n+    pub id: HirId,\n }\n \n /// An item"}, {"sha": "0a65473de8ff1f8a5ab708f24dfe8adae79f32c5", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "patch": "@@ -48,7 +48,7 @@ pub trait PpAnn {\n     fn post(&self, _state: &mut State<'_>, _node: AnnNode<'_>) -> io::Result<()> {\n         Ok(())\n     }\n-    fn try_fetch_item(&self, _: ast::NodeId) -> Option<&hir::Item> {\n+    fn try_fetch_item(&self, _: hir::HirId) -> Option<&hir::Item> {\n         None\n     }\n }\n@@ -58,7 +58,7 @@ impl PpAnn for NoAnn {}\n pub const NO_ANN: &dyn PpAnn = &NoAnn;\n \n impl PpAnn for hir::Crate {\n-    fn try_fetch_item(&self, item: ast::NodeId) -> Option<&hir::Item> {\n+    fn try_fetch_item(&self, item: hir::HirId) -> Option<&hir::Item> {\n         Some(self.item(item))\n     }\n     fn nested(&self, state: &mut State<'_>, nested: Nested) -> io::Result<()> {"}, {"sha": "0a0a1dee7f07c52fdae3e01b46f8a0afc7fa505a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "patch": "@@ -292,7 +292,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         match ty.node {\n             TyKind::Def(item_id, _) => {\n-                let item = self.tcx.hir().expect_item(item_id.id);\n+                let item = self.tcx.hir().expect_item_by_hir_id(item_id.id);\n                 intravisit::walk_item(self, item);\n             }\n             _ => ()"}, {"sha": "73e232a6a4ff24a7007a4b39fcf25651c835319d", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "patch": "@@ -638,7 +638,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n                 //                          ^            ^ this gets resolved in the scope of\n                 //                                         the exist_ty generics\n-                let (generics, bounds) = match self.tcx.hir().expect_item(item_id.id).node {\n+                let (generics, bounds) = match self.tcx.hir().expect_item_by_hir_id(item_id.id).node\n+                {\n                     // named existential types are reached via TyKind::Path\n                     // this arm is for `impl Trait` in the types of statics, constants and locals\n                     hir::ItemKind::Existential(hir::ExistTy {\n@@ -678,8 +679,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 let parent_impl_id = hir::ImplItemId { hir_id: parent_id };\n                                 let parent_trait_id = hir::TraitItemId { hir_id: parent_id };\n                                 let krate = self.tcx.hir().forest.krate();\n-                                let parent_node_id = self.tcx.hir().hir_to_node_id(parent_id);\n-                                if !(krate.items.contains_key(&parent_node_id)\n+\n+                                if !(krate.items.contains_key(&parent_id)\n                                     || krate.impl_items.contains_key(&parent_impl_id)\n                                     || krate.trait_items.contains_key(&parent_trait_id))\n                                 {"}, {"sha": "9c908176a6d3af38564adbbdd15da24bdef1086e", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "patch": "@@ -693,7 +693,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: self.encode_attributes(attrs),\n             children: self.lazy_seq(md.item_ids.iter().map(|item_id| {\n-                tcx.hir().local_def_id(item_id.id).index\n+                tcx.hir().local_def_id_from_hir_id(item_id.id).index\n             })),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),"}, {"sha": "f155beaaff2205a766db07edfb20ecfc7b0d746e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "patch": "@@ -472,8 +472,8 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n              {\n                 if let hir::ItemKind::Mod(m) = &item.node {\n                     for item_id in m.item_ids.as_ref() {\n-                        let item = self.tcx.hir().expect_item(item_id.id);\n-                        let def_id = self.tcx.hir().local_def_id(item_id.id);\n+                        let item = self.tcx.hir().expect_item_by_hir_id(item_id.id);\n+                        let def_id = self.tcx.hir().local_def_id_from_hir_id(item_id.id);\n                         if !self.tcx.hygienic_eq(segment.ident, item.ident, def_id) { continue; }\n                         if let hir::ItemKind::Use(..) = item.node {\n                             self.update(item.hir_id, Some(AccessLevel::Exported));\n@@ -737,8 +737,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                 unreachable!()\n             };\n             for id in &module.item_ids {\n-                let hir_id = self.tcx.hir().node_to_hir_id(id.id);\n-                self.update(hir_id, level);\n+                self.update(id.id, level);\n             }\n             let def_id = self.tcx.hir().local_def_id_from_hir_id(module_id);\n             if let Some(exports) = self.tcx.module_exports(def_id) {"}, {"sha": "fba4414c1275c88237c39a8aa05f34ca33a76464", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "patch": "@@ -1817,7 +1817,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 self.def_to_ty(opt_self_ty, path, false)\n             }\n             hir::TyKind::Def(item_id, ref lifetimes) => {\n-                let did = tcx.hir().local_def_id(item_id.id);\n+                let did = tcx.hir().local_def_id_from_hir_id(item_id.id);\n                 self.impl_trait_ty_to_ty(did, lifetimes)\n             },\n             hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {"}, {"sha": "fde0e47650d8096a1cdec6574db9866329396a92", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "patch": "@@ -853,7 +853,7 @@ impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, '\n         }\n         // Find a `use` statement.\n         for item_id in &module.item_ids {\n-            let item = self.tcx.hir().expect_item(item_id.id);\n+            let item = self.tcx.hir().expect_item_by_hir_id(item_id.id);\n             match item.node {\n                 hir::ItemKind::Use(..) => {\n                     // Don't suggest placing a `use` before the prelude"}, {"sha": "396488c981dfdad7c3dd908409bd2dbbd7ee4408", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "patch": "@@ -278,16 +278,16 @@ impl Clean<ExternalCrate> for CrateNum {\n         };\n         let primitives = if root.is_local() {\n             cx.tcx.hir().krate().module.item_ids.iter().filter_map(|&id| {\n-                let item = cx.tcx.hir().expect_item(id.id);\n+                let item = cx.tcx.hir().expect_item_by_hir_id(id.id);\n                 match item.node {\n                     hir::ItemKind::Mod(_) => {\n-                        as_primitive(Def::Mod(cx.tcx.hir().local_def_id(id.id)))\n+                        as_primitive(Def::Mod(cx.tcx.hir().local_def_id_from_hir_id(id.id)))\n                     }\n                     hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n                         as_primitive(path.def).map(|(_, prim, attrs)| {\n                             // Pretend the primitive is local.\n-                            (cx.tcx.hir().local_def_id(id.id), prim, attrs)\n+                            (cx.tcx.hir().local_def_id_from_hir_id(id.id), prim, attrs)\n                         })\n                     }\n                     _ => None\n@@ -320,15 +320,15 @@ impl Clean<ExternalCrate> for CrateNum {\n         };\n         let keywords = if root.is_local() {\n             cx.tcx.hir().krate().module.item_ids.iter().filter_map(|&id| {\n-                let item = cx.tcx.hir().expect_item(id.id);\n+                let item = cx.tcx.hir().expect_item_by_hir_id(id.id);\n                 match item.node {\n                     hir::ItemKind::Mod(_) => {\n-                        as_keyword(Def::Mod(cx.tcx.hir().local_def_id(id.id)))\n+                        as_keyword(Def::Mod(cx.tcx.hir().local_def_id_from_hir_id(id.id)))\n                     }\n                     hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n                         as_keyword(path.def).map(|(_, prim, attrs)| {\n-                            (cx.tcx.hir().local_def_id(id.id), prim, attrs)\n+                            (cx.tcx.hir().local_def_id_from_hir_id(id.id), prim, attrs)\n                         })\n                     }\n                     _ => None\n@@ -2762,7 +2762,7 @@ impl Clean<Type> for hir::Ty {\n             },\n             TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),\n             TyKind::Def(item_id, _) => {\n-                let item = cx.tcx.hir().expect_item(item_id.id);\n+                let item = cx.tcx.hir().expect_item_by_hir_id(item_id.id);\n                 if let hir::ItemKind::Existential(ref ty) = item.node {\n                     ImplTrait(ty.bounds.clean(cx))\n                 } else {\n@@ -4393,10 +4393,10 @@ pub fn path_to_def_local(tcx: &TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefI\n         let segment = path_it.next()?;\n \n         for item_id in mem::replace(&mut items, HirVec::new()).iter() {\n-            let item = tcx.hir().expect_item(item_id.id);\n+            let item = tcx.hir().expect_item_by_hir_id(item_id.id);\n             if item.ident.name == *segment {\n                 if path_it.peek().is_none() {\n-                    return Some(tcx.hir().local_def_id(item_id.id))\n+                    return Some(tcx.hir().local_def_id_from_hir_id(item_id.id))\n                 }\n \n                 items = match &item.node {"}, {"sha": "4991c53ab4663797254f54d35b8dbfc02b7cb471", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ef5eb3af24bf0c00d6970dc93fd71aecff51d3/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=95ef5eb3af24bf0c00d6970dc93fd71aecff51d3", "patch": "@@ -247,7 +247,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let orig_inside_public_path = self.inside_public_path;\n         self.inside_public_path &= vis.node.is_pub();\n         for i in &m.item_ids {\n-            let item = self.cx.tcx.hir().expect_item(i.id);\n+            let item = self.cx.tcx.hir().expect_item_by_hir_id(i.id);\n             self.visit_item(item, None, &mut om);\n         }\n         self.inside_public_path = orig_inside_public_path;\n@@ -344,7 +344,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Node::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n-                    let i = self.cx.tcx.hir().expect_item(i.id);\n+                    let i = self.cx.tcx.hir().expect_item_by_hir_id(i.id);\n                     self.visit_item(i, None, om);\n                 }\n                 self.inlining = prev;"}]}