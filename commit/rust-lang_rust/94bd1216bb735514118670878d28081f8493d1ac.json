{"sha": "94bd1216bb735514118670878d28081f8493d1ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0YmQxMjE2YmI3MzU1MTQxMTg2NzA4NzhkMjgwODFmODQ5M2QxYWM=", "commit": {"author": {"name": "Gilad Naaman", "email": "gilad.naaman@gmail.com", "date": "2017-12-15T15:25:44Z"}, "committer": {"name": "Gilad Naaman", "email": "gilad.naaman@gmail.com", "date": "2018-01-26T17:46:04Z"}, "message": "libtest: Fixed pretty-printing of test names in single-threaded code.", "tree": {"sha": "6d1027a8425a720aa527592fb3591ce718b1ab04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d1027a8425a720aa527592fb3591ce718b1ab04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94bd1216bb735514118670878d28081f8493d1ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94bd1216bb735514118670878d28081f8493d1ac", "html_url": "https://github.com/rust-lang/rust/commit/94bd1216bb735514118670878d28081f8493d1ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94bd1216bb735514118670878d28081f8493d1ac/comments", "author": null, "committer": null, "parents": [{"sha": "e570e9e79aa4ebfa5c1f9f9b2345dfb3525e42e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e570e9e79aa4ebfa5c1f9f9b2345dfb3525e42e7", "html_url": "https://github.com/rust-lang/rust/commit/e570e9e79aa4ebfa5c1f9f9b2345dfb3525e42e7"}], "stats": {"total": 105, "additions": 69, "deletions": 36}, "files": [{"sha": "f45ae3a7c2cc1a1b7c05f6afe2c4684773d6b766", "filename": "src/libtest/formatters.rs", "status": "modified", "additions": 56, "deletions": 27, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/94bd1216bb735514118670878d28081f8493d1ac/src%2Flibtest%2Fformatters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bd1216bb735514118670878d28081f8493d1ac/src%2Flibtest%2Fformatters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters.rs?ref=94bd1216bb735514118670878d28081f8493d1ac", "patch": "@@ -11,8 +11,8 @@\n use super::*;\n \n pub(crate) trait OutputFormatter {\n-    fn write_run_start(&mut self, len: usize) -> io::Result<()>;\n-    fn write_test_start(&mut self, test: &TestDesc) -> io::Result<()>;\n+    fn write_run_start(&mut self, test_count: usize) -> io::Result<()>;\n+    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()>;\n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()>;\n     fn write_result(&mut self,\n                     desc: &TestDesc,\n@@ -26,17 +26,26 @@ pub(crate) struct HumanFormatter<T> {\n     terse: bool,\n     use_color: bool,\n     test_count: usize,\n-    max_name_len: usize, // number of columns to fill when aligning names\n+\n+    /// Number of columns to fill when aligning names\n+    max_name_len: usize,\n+\n+    is_multithreaded: bool,\n }\n \n impl<T: Write> HumanFormatter<T> {\n-    pub fn new(out: OutputLocation<T>, use_color: bool, terse: bool, max_name_len: usize) -> Self {\n+    pub fn new(out: OutputLocation<T>,\n+                use_color: bool,\n+                terse: bool,\n+                max_name_len: usize,\n+                is_multithreaded: bool) -> Self {\n         HumanFormatter {\n             out,\n             terse,\n             use_color,\n             test_count: 0,\n             max_name_len,\n+            is_multithreaded,\n         }\n     }\n \n@@ -160,28 +169,42 @@ impl<T: Write> HumanFormatter<T> {\n         }\n         Ok(())\n     }\n+\n+    fn write_test_name(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        if !(self.terse && desc.name.padding() != PadOnRight) {\n+            let name = desc.padded_name(self.max_name_len, desc.name.padding());\n+            self.write_plain(&format!(\"test {} ... \", name))?;\n+        }\n+\n+        Ok(())\n+    }\n }\n \n impl<T: Write> OutputFormatter for HumanFormatter<T> {\n-    fn write_run_start(&mut self, len: usize) -> io::Result<()> {\n-        let noun = if len != 1 {\n+    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n+        let noun = if test_count != 1 {\n             \"tests\"\n         } else {\n             \"test\"\n         };\n-        self.write_plain(&format!(\"\\nrunning {} {}\\n\", len, noun))\n+        self.write_plain(&format!(\"\\nrunning {} {}\\n\", test_count, noun))\n     }\n \n-    fn write_test_start(&mut self, _desc: &TestDesc) -> io::Result<()> {\n-        // Do not print header, as priting it at this point will result in\n-        // an unreadable output when running tests concurrently.\n+    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        // When running tests concurrently, we should not print\n+        // the test's name as the result will be mis-aligned.\n+        // When running the tests serially, we print the name here so\n+        // that the user can see which test hangs.\n+        if !self.is_multithreaded {\n+            self.write_test_name(desc)?;\n+        }\n+\n         Ok(())\n     }\n \n     fn write_result(&mut self, desc: &TestDesc, result: &TestResult, _: &[u8]) -> io::Result<()> {\n-        if !(self.terse && desc.name.padding() != PadOnRight) {\n-            let name = desc.padded_name(self.max_name_len, desc.name.padding());\n-            self.write_plain(&format!(\"test {} ... \", name))?;\n+        if self.is_multithreaded {\n+            self.write_test_name(desc)?;\n         }\n \n         match *result {\n@@ -197,6 +220,10 @@ impl<T: Write> OutputFormatter for HumanFormatter<T> {\n     }\n \n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        if self.is_multithreaded {\n+            self.write_test_name(desc)?;\n+        }\n+\n         self.write_plain(&format!(\"test {} has been running for over {} seconds\\n\",\n                                   desc.name,\n                                   TEST_WARN_TIMEOUT_S))\n@@ -251,13 +278,14 @@ pub(crate) struct JsonFormatter<T> {\n \n impl<T: Write> JsonFormatter<T> {\n     pub fn new(out: OutputLocation<T>) -> Self {\n-        Self {\n-            out,        }\n+        Self { out }\n     }\n \n-    fn write_str<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n-        self.out.write_all(s.as_ref().as_ref())?;\n-        self.out.write_all(\"\\n\".as_ref())\n+    fn write_message(&mut self, s: &str) -> io::Result<()> {\n+        assert!(!s.contains('\\n'));\n+\n+        self.out.write_all(s.as_ref())?;\n+        self.out.write_all(b\"\\n\")\n     }\n \n     fn write_event(&mut self,\n@@ -266,14 +294,14 @@ impl<T: Write> JsonFormatter<T> {\n                     evt: &str,\n                     extra: Option<String>) -> io::Result<()> {\n         if let Some(extras) = extra {\n-            self.write_str(&*format!(r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\", {} }}\"#,\n+            self.write_message(&*format!(r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\", {} }}\"#,\n                                     ty,\n                                     name,\n                                     evt,\n                                     extras))\n         }\n         else {\n-            self.write_str(&*format!(r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\" }}\"#,\n+            self.write_message(&*format!(r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\" }}\"#,\n                                     ty,\n                                     name,\n                                     evt))\n@@ -282,13 +310,14 @@ impl<T: Write> JsonFormatter<T> {\n }\n \n impl<T: Write> OutputFormatter for JsonFormatter<T> {\n-    fn write_run_start(&mut self, len: usize) -> io::Result<()> {\n-        self.write_str(\n-            &*format!(r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": \"{}\" }}\"#, len))\n+    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n+        self.write_message(\n+            &*format!(r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": \"{}\" }}\"#,\n+                        test_count))\n     }\n \n     fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        self.write_str(&*format!(r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n+        self.write_message(&*format!(r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n                                 desc.name))\n     }\n \n@@ -348,19 +377,19 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n                         deviation,\n                         mbps);\n \n-                self.write_str(&*line)\n+                self.write_message(&*line)\n             },\n         }\n     }\n \n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        self.write_str(&*format!(r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n+        self.write_message(&*format!(r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n                         desc.name))\n     }\n \n     fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n \n-        self.write_str(&*format!(\"{{ \\\"type\\\": \\\"suite\\\", \\\n+        self.write_message(&*format!(\"{{ \\\"type\\\": \\\"suite\\\", \\\n             \\\"event\\\": \\\"{}\\\", \\\n             \\\"passed\\\": {}, \\\n             \\\"failed\\\": {}, \\"}, {"sha": "04c0734b5241b6b2bbc1763652fce62f6e452fcd", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/94bd1216bb735514118670878d28081f8493d1ac/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bd1216bb735514118670878d28081f8493d1ac/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=94bd1216bb735514118670878d28081f8493d1ac", "patch": "@@ -719,7 +719,7 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n     };\n \n     let quiet = opts.format == OutputFormat::Terse;\n-    let mut out = HumanFormatter::new(output, use_color(opts), quiet, 0);\n+    let mut out = HumanFormatter::new(output, use_color(opts), quiet, 0, false);\n     let mut st = ConsoleTestState::new(opts)?;\n \n     let mut ntest = 0;\n@@ -820,23 +820,27 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         Some(t) => Pretty(t),\n     };\n \n-    let max_name_len = if let Some(t) = tests.iter().max_by_key(|t| len_if_padded(*t)) {\n-        let n = t.desc.name.as_slice();\n-        n.len()\n-    }\n-    else {\n-        0\n+    let max_name_len = tests.iter()\n+                        .max_by_key(|t| len_if_padded(*t))\n+                        .map(|t| t.desc.name.as_slice().len())\n+                        .unwrap_or(0);\n+\n+    let is_multithreaded = match opts.test_threads {\n+        Some(n) => n > 1,\n+        None => get_concurrency() > 1,\n     };\n \n     let mut out: Box<OutputFormatter> = match opts.format {\n         OutputFormat::Pretty => Box::new(HumanFormatter::new(output,\n                                                                 use_color(opts),\n                                                                 false,\n-                                                                max_name_len)),\n+                                                                max_name_len,\n+                                                                is_multithreaded)),\n         OutputFormat::Terse => Box::new(HumanFormatter::new(output,\n                                                                 use_color(opts),\n                                                                 true,\n-                                                                max_name_len)),\n+                                                                max_name_len,\n+                                                                is_multithreaded)),\n         OutputFormat::Json => Box::new(JsonFormatter::new(output)),\n     };\n     let mut st = ConsoleTestState::new(opts)?;"}]}