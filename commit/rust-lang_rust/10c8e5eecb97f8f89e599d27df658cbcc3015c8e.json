{"sha": "10c8e5eecb97f8f89e599d27df658cbcc3015c8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYzhlNWVlY2I5N2Y4Zjg5ZTU5OWQyN2RmNjU4Y2JjYzMwMTVjOGU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-29T19:34:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-29T19:34:02Z"}, "message": "Merge #2445\n\n2445: Infer range types r=flodiebold a=oxalica\n\n\n\nCo-authored-by: oxalica <oxalicc@pm.me>", "tree": {"sha": "f93ef014cc82793949e8567634cec341ffc58d62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f93ef014cc82793949e8567634cec341ffc58d62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10c8e5eecb97f8f89e599d27df658cbcc3015c8e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd4XKqCRBK7hj4Ov3rIwAAdHIIAH+tSFMowZWKzwjbM7pvusse\nzCVgoZBEJ0shMKmV4aoB8joDzBBkrwuv81D+hF/PpVniGRlRQ1nE/VDL+N+CJfdF\nIH6sYU70n7wabYdbx4Xg0W/pnoyPwA6tp+gBX3dR662qsJV77Lk3oNCu+NGDM0kz\nd/jyEPyI/dcNFDrDI6Um/idq5DM+ci+bH48X3i6yhGzBIh8Tla5ufjAyPcWkcXY4\nURiwhuj9W2/xlkVdzQvjXcNeOds4E4gPRwKQTbq2Hn/3Q8hE4s1jNByiobtvj4Nt\nZ6KCGxPrmHzdilthMCITuIUAaFhkdmEqMdjWHkHt8xv7Ao+5zIKZNYB/0MwPrQw=\n=LjSj\n-----END PGP SIGNATURE-----\n", "payload": "tree f93ef014cc82793949e8567634cec341ffc58d62\nparent 8b278b1ab660df0728508e45e88ac769a2e03a58\nparent 2cb684bbce1c487b2efb5a8154afe66e4907ceac\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1575056042 +0000\ncommitter GitHub <noreply@github.com> 1575056042 +0000\n\nMerge #2445\n\n2445: Infer range types r=flodiebold a=oxalica\n\n\n\nCo-authored-by: oxalica <oxalicc@pm.me>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10c8e5eecb97f8f89e599d27df658cbcc3015c8e", "html_url": "https://github.com/rust-lang/rust/commit/10c8e5eecb97f8f89e599d27df658cbcc3015c8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10c8e5eecb97f8f89e599d27df658cbcc3015c8e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b278b1ab660df0728508e45e88ac769a2e03a58", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b278b1ab660df0728508e45e88ac769a2e03a58", "html_url": "https://github.com/rust-lang/rust/commit/8b278b1ab660df0728508e45e88ac769a2e03a58"}, {"sha": "2cb684bbce1c487b2efb5a8154afe66e4907ceac", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cb684bbce1c487b2efb5a8154afe66e4907ceac", "html_url": "https://github.com/rust-lang/rust/commit/2cb684bbce1c487b2efb5a8154afe66e4907ceac"}], "stats": {"total": 186, "additions": 185, "deletions": 1}, "files": [{"sha": "be1eaa52344dac699a527a81cea5e433caa2745d", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10c8e5eecb97f8f89e599d27df658cbcc3015c8e/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10c8e5eecb97f8f89e599d27df658cbcc3015c8e/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=10c8e5eecb97f8f89e599d27df658cbcc3015c8e", "patch": "@@ -429,10 +429,19 @@ where\n                 let index = self.collect_expr_opt(e.index());\n                 self.alloc_expr(Expr::Index { base, index }, syntax_ptr)\n             }\n+            ast::Expr::RangeExpr(e) => {\n+                let lhs = e.start().map(|lhs| self.collect_expr(lhs));\n+                let rhs = e.end().map(|rhs| self.collect_expr(rhs));\n+                match e.op_kind() {\n+                    Some(range_type) => {\n+                        self.alloc_expr(Expr::Range { lhs, rhs, range_type }, syntax_ptr)\n+                    }\n+                    None => self.alloc_expr(Expr::Missing, syntax_ptr),\n+                }\n+            }\n \n             // FIXME implement HIR for these:\n             ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::MacroCall(e) => match self.expander.enter_expand(self.db, e) {\n                 Some((mark, expansion)) => {\n                     let id = self.collect_expr(expansion);"}, {"sha": "6fad80a8d488cb9410ba94d84bc4795fef3dbf6d", "filename": "crates/ra_hir_def/src/expr.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10c8e5eecb97f8f89e599d27df658cbcc3015c8e/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10c8e5eecb97f8f89e599d27df658cbcc3015c8e/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=10c8e5eecb97f8f89e599d27df658cbcc3015c8e", "patch": "@@ -14,6 +14,7 @@\n \n use hir_expand::name::Name;\n use ra_arena::{impl_arena_id, RawId};\n+use ra_syntax::ast::RangeOp;\n \n use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt},\n@@ -130,6 +131,11 @@ pub enum Expr {\n         rhs: ExprId,\n         op: Option<BinaryOp>,\n     },\n+    Range {\n+        lhs: Option<ExprId>,\n+        rhs: Option<ExprId>,\n+        range_type: RangeOp,\n+    },\n     Index {\n         base: ExprId,\n         index: ExprId,\n@@ -288,6 +294,14 @@ impl Expr {\n                 f(*lhs);\n                 f(*rhs);\n             }\n+            Expr::Range { lhs, rhs, .. } => {\n+                if let Some(lhs) = rhs {\n+                    f(*lhs);\n+                }\n+                if let Some(rhs) = lhs {\n+                    f(*rhs);\n+                }\n+            }\n             Expr::Index { base, index } => {\n                 f(*base);\n                 f(*index);"}, {"sha": "ff252fe442d4b733eefcf9b942084b13a1a63a87", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/10c8e5eecb97f8f89e599d27df658cbcc3015c8e/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10c8e5eecb97f8f89e599d27df658cbcc3015c8e/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=10c8e5eecb97f8f89e599d27df658cbcc3015c8e", "patch": "@@ -409,6 +409,36 @@ pub mod known {\n         Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::TRY_TYPE])\n     }\n \n+    pub fn std_ops_range() -> Path {\n+        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::RANGE_TYPE])\n+    }\n+\n+    pub fn std_ops_range_from() -> Path {\n+        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::RANGE_FROM_TYPE])\n+    }\n+\n+    pub fn std_ops_range_full() -> Path {\n+        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::RANGE_FULL_TYPE])\n+    }\n+\n+    pub fn std_ops_range_inclusive() -> Path {\n+        Path::from_simple_segments(\n+            PathKind::Abs,\n+            vec![name::STD, name::OPS, name::RANGE_INCLUSIVE_TYPE],\n+        )\n+    }\n+\n+    pub fn std_ops_range_to() -> Path {\n+        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::RANGE_TO_TYPE])\n+    }\n+\n+    pub fn std_ops_range_to_inclusive() -> Path {\n+        Path::from_simple_segments(\n+            PathKind::Abs,\n+            vec![name::STD, name::OPS, name::RANGE_TO_INCLUSIVE_TYPE],\n+        )\n+    }\n+\n     pub fn std_result_result() -> Path {\n         Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::RESULT, name::RESULT_TYPE])\n     }"}, {"sha": "05ba370706449aed22c9c628b917a40e000e1144", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10c8e5eecb97f8f89e599d27df658cbcc3015c8e/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10c8e5eecb97f8f89e599d27df658cbcc3015c8e/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=10c8e5eecb97f8f89e599d27df658cbcc3015c8e", "patch": "@@ -140,6 +140,12 @@ pub const RESULT_TYPE: Name = Name::new_inline_ascii(6, b\"Result\");\n pub const OUTPUT_TYPE: Name = Name::new_inline_ascii(6, b\"Output\");\n pub const TARGET_TYPE: Name = Name::new_inline_ascii(6, b\"Target\");\n pub const BOX_TYPE: Name = Name::new_inline_ascii(3, b\"Box\");\n+pub const RANGE_FROM_TYPE: Name = Name::new_inline_ascii(9, b\"RangeFrom\");\n+pub const RANGE_FULL_TYPE: Name = Name::new_inline_ascii(9, b\"RangeFull\");\n+pub const RANGE_INCLUSIVE_TYPE: Name = Name::new_inline_ascii(14, b\"RangeInclusive\");\n+pub const RANGE_TO_INCLUSIVE_TYPE: Name = Name::new_inline_ascii(16, b\"RangeToInclusive\");\n+pub const RANGE_TO_TYPE: Name = Name::new_inline_ascii(7, b\"RangeTo\");\n+pub const RANGE_TYPE: Name = Name::new_inline_ascii(5, b\"Range\");\n \n // Builtin Macros\n pub const FILE_MACRO: Name = Name::new_inline_ascii(4, b\"file\");"}, {"sha": "fe259371f5f9fbc54c48ba6acb74ba34b4cb03aa", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/10c8e5eecb97f8f89e599d27df658cbcc3015c8e/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10c8e5eecb97f8f89e599d27df658cbcc3015c8e/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=10c8e5eecb97f8f89e599d27df658cbcc3015c8e", "patch": "@@ -577,6 +577,42 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }\n+\n+    fn resolve_range_full(&self) -> Option<AdtId> {\n+        let path = known::std_ops_range_full();\n+        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        Some(struct_.into())\n+    }\n+\n+    fn resolve_range(&self) -> Option<AdtId> {\n+        let path = known::std_ops_range();\n+        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        Some(struct_.into())\n+    }\n+\n+    fn resolve_range_inclusive(&self) -> Option<AdtId> {\n+        let path = known::std_ops_range_inclusive();\n+        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        Some(struct_.into())\n+    }\n+\n+    fn resolve_range_from(&self) -> Option<AdtId> {\n+        let path = known::std_ops_range_from();\n+        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        Some(struct_.into())\n+    }\n+\n+    fn resolve_range_to(&self) -> Option<AdtId> {\n+        let path = known::std_ops_range_to();\n+        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        Some(struct_.into())\n+    }\n+\n+    fn resolve_range_to_inclusive(&self) -> Option<AdtId> {\n+        let path = known::std_ops_range_to_inclusive();\n+        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        Some(struct_.into())\n+    }\n }\n \n /// The ID of a type variable."}, {"sha": "4014f4732d483bb07a88a541f9cd34ed0c2034d4", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/10c8e5eecb97f8f89e599d27df658cbcc3015c8e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10c8e5eecb97f8f89e599d27df658cbcc3015c8e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=10c8e5eecb97f8f89e599d27df658cbcc3015c8e", "patch": "@@ -12,6 +12,7 @@ use hir_def::{\n     AdtId, ContainerId, Lookup, StructFieldId,\n };\n use hir_expand::name::{self, Name};\n+use ra_syntax::ast::RangeOp;\n \n use crate::{\n     autoderef, db::HirDatabase, method_resolution, op, traits::InEnvironment, utils::variant_data,\n@@ -415,6 +416,44 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n                 _ => Ty::Unknown,\n             },\n+            Expr::Range { lhs, rhs, range_type } => {\n+                let lhs_ty = lhs.map(|e| self.infer_expr(e, &Expectation::none()));\n+                let rhs_expect = lhs_ty\n+                    .as_ref()\n+                    .map_or_else(Expectation::none, |ty| Expectation::has_type(ty.clone()));\n+                let rhs_ty = rhs.map(|e| self.infer_expr(e, &rhs_expect));\n+                match (range_type, lhs_ty, rhs_ty) {\n+                    (RangeOp::Exclusive, None, None) => match self.resolve_range_full() {\n+                        Some(adt) => Ty::simple(TypeCtor::Adt(adt)),\n+                        None => Ty::Unknown,\n+                    },\n+                    (RangeOp::Exclusive, None, Some(ty)) => match self.resolve_range_to() {\n+                        Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                        None => Ty::Unknown,\n+                    },\n+                    (RangeOp::Inclusive, None, Some(ty)) => {\n+                        match self.resolve_range_to_inclusive() {\n+                            Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                            None => Ty::Unknown,\n+                        }\n+                    }\n+                    (RangeOp::Exclusive, Some(_), Some(ty)) => match self.resolve_range() {\n+                        Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                        None => Ty::Unknown,\n+                    },\n+                    (RangeOp::Inclusive, Some(_), Some(ty)) => {\n+                        match self.resolve_range_inclusive() {\n+                            Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                            None => Ty::Unknown,\n+                        }\n+                    }\n+                    (RangeOp::Exclusive, Some(ty), None) => match self.resolve_range_from() {\n+                        Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                        None => Ty::Unknown,\n+                    },\n+                    (RangeOp::Inclusive, _, None) => Ty::Unknown,\n+                }\n+            }\n             Expr::Index { base, index } => {\n                 let _base_ty = self.infer_expr(*base, &Expectation::none());\n                 let _index_ty = self.infer_expr(*index, &Expectation::none());"}, {"sha": "4ba87e667ad6f4a5d81c2cee5af26a2fdabdbe58", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/10c8e5eecb97f8f89e599d27df658cbcc3015c8e/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10c8e5eecb97f8f89e599d27df658cbcc3015c8e/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=10c8e5eecb97f8f89e599d27df658cbcc3015c8e", "patch": "@@ -221,6 +221,56 @@ mod collections {\n     assert_eq!(\"&str\", type_at_pos(&db, pos));\n }\n \n+#[test]\n+fn infer_ranges() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+fn test() {\n+    let a = ..;\n+    let b = 1..;\n+    let c = ..2u32;\n+    let d = 1..2usize;\n+    let e = ..=10;\n+    let f = 'a'..='z';\n+\n+    let t = (a, b, c, d, e, f);\n+    t<|>;\n+}\n+\n+//- /std.rs crate:std\n+#[prelude_import] use prelude::*;\n+mod prelude {}\n+\n+pub mod ops {\n+    pub struct Range<Idx> {\n+        pub start: Idx,\n+        pub end: Idx,\n+    }\n+    pub struct RangeFrom<Idx> {\n+        pub start: Idx,\n+    }\n+    struct RangeFull;\n+    pub struct RangeInclusive<Idx> {\n+        start: Idx,\n+        end: Idx,\n+        is_empty: u8,\n+    }\n+    pub struct RangeTo<Idx> {\n+        pub end: Idx,\n+    }\n+    pub struct RangeToInclusive<Idx> {\n+        pub end: Idx,\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\n+        \"(RangeFull, RangeFrom<i32>, RangeTo<u32>, Range<usize>, RangeToInclusive<i32>, RangeInclusive<char>)\",\n+        type_at_pos(&db, pos),\n+    );\n+}\n+\n #[test]\n fn infer_while_let() {\n     let (db, pos) = TestDB::with_position("}]}