{"sha": "3afec247cb41e528607c181fd7c278132b6f3c2a", "node_id": "C_kwDOAAsO6NoAKDNhZmVjMjQ3Y2I0MWU1Mjg2MDdjMTgxZmQ3YzI3ODEzMmI2ZjNjMmE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-11-14T18:20:49Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-11-14T18:20:49Z"}, "message": "Deduplicate visitor.", "tree": {"sha": "2eda760e20f8b0e9b12ff023260de42c204658de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2eda760e20f8b0e9b12ff023260de42c204658de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3afec247cb41e528607c181fd7c278132b6f3c2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3afec247cb41e528607c181fd7c278132b6f3c2a", "html_url": "https://github.com/rust-lang/rust/commit/3afec247cb41e528607c181fd7c278132b6f3c2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3afec247cb41e528607c181fd7c278132b6f3c2a/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d470ac93347e8bc7da6af2f2dd1bddf430fc8500", "url": "https://api.github.com/repos/rust-lang/rust/commits/d470ac93347e8bc7da6af2f2dd1bddf430fc8500", "html_url": "https://github.com/rust-lang/rust/commit/d470ac93347e8bc7da6af2f2dd1bddf430fc8500"}], "stats": {"total": 121, "additions": 22, "deletions": 99}, "files": [{"sha": "e494aef1a744af7cb42735aad6122285ee30435d", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 19, "deletions": 96, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/3afec247cb41e528607c181fd7c278132b6f3c2a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3afec247cb41e528607c181fd7c278132b6f3c2a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=3afec247cb41e528607c181fd7c278132b6f3c2a", "patch": "@@ -10,6 +10,7 @@ use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{ItemKind, Node, PathSegment};\n+use rustc_infer::infer::opaque_types::ConstrainOpaqueTypeRegionVisitor;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{DefiningAnchor, RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n@@ -254,100 +255,11 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n     let item = tcx.hir().expect_item(def_id);\n     debug!(?item, ?span);\n \n-    #[derive(Debug)]\n-    struct FoundParentLifetime;\n-    struct FindParentLifetimeVisitor<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-        parent_count: u32,\n-    }\n-    impl<'tcx> ty::visit::TypeVisitor<'tcx> for FindParentLifetimeVisitor<'tcx> {\n-        type BreakTy = FoundParentLifetime;\n-\n-        #[instrument(level = \"trace\", skip(self), ret)]\n-        fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            if let ty::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = *r {\n-                if index < self.parent_count {\n-                    return ControlFlow::Break(FoundParentLifetime);\n-                } else {\n-                    return ControlFlow::CONTINUE;\n-                }\n-            }\n-\n-            r.super_visit_with(self)\n-        }\n-\n-        #[instrument(level = \"trace\", skip(self), ret)]\n-        fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            // We're only interested in types involving regions\n-            if !ty.flags().intersects(ty::TypeFlags::HAS_FREE_REGIONS) {\n-                return ControlFlow::CONTINUE;\n-            }\n-\n-            match ty.kind() {\n-                ty::Closure(_, ref substs) => {\n-                    // Skip lifetime parameters of the enclosing item(s)\n-\n-                    substs.as_closure().tupled_upvars_ty().visit_with(self)?;\n-                    substs.as_closure().sig_as_fn_ptr_ty().visit_with(self)?;\n-                }\n-\n-                ty::Generator(_, ref substs, _) => {\n-                    // Skip lifetime parameters of the enclosing item(s)\n-                    // Also skip the witness type, because that has no free regions.\n-\n-                    substs.as_generator().tupled_upvars_ty().visit_with(self)?;\n-                    substs.as_generator().return_ty().visit_with(self)?;\n-                    substs.as_generator().yield_ty().visit_with(self)?;\n-                    substs.as_generator().resume_ty().visit_with(self)?;\n-                }\n-\n-                ty::Opaque(def_id, ref substs) => {\n-                    // Skip lifetime paramters that are not captures.\n-                    let variances = self.tcx.variances_of(*def_id);\n-\n-                    for (v, s) in std::iter::zip(variances, substs.iter()) {\n-                        if *v != ty::Variance::Bivariant {\n-                            s.visit_with(self)?;\n-                        }\n-                    }\n-                }\n-\n-                ty::Projection(proj)\n-                    if self.tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder =>\n-                {\n-                    // Skip lifetime paramters that are not captures.\n-                    let variances = self.tcx.variances_of(proj.item_def_id);\n-\n-                    for (v, s) in std::iter::zip(variances, proj.substs.iter()) {\n-                        if *v != ty::Variance::Bivariant {\n-                            s.visit_with(self)?;\n-                        }\n-                    }\n-                }\n-\n-                _ => {\n-                    ty.super_visit_with(self)?;\n-                }\n-            }\n-\n-            ControlFlow::CONTINUE\n-        }\n-\n-        fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            if let ty::ConstKind::Unevaluated(..) = c.kind() {\n-                // FIXME(#72219) We currently don't detect lifetimes within substs\n-                // which would violate this check. Even though the particular substitution is not used\n-                // within the const, this should still be fixed.\n-                return ControlFlow::CONTINUE;\n-            }\n-            c.super_visit_with(self)\n-        }\n-    }\n-\n     struct ProhibitOpaqueVisitor<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         opaque_identity_ty: Ty<'tcx>,\n-        generics: &'tcx ty::Generics,\n+        parent_count: u32,\n+        references_parent_regions: bool,\n         selftys: Vec<(Span, Option<String>)>,\n     }\n \n@@ -359,11 +271,21 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n             if t == self.opaque_identity_ty {\n                 ControlFlow::CONTINUE\n             } else {\n-                t.visit_with(&mut FindParentLifetimeVisitor {\n+                t.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n                     tcx: self.tcx,\n-                    parent_count: self.generics.parent_count as u32,\n-                })\n-                .map_break(|FoundParentLifetime| t)\n+                    op: |region| {\n+                        if let ty::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = *region\n+                            && index < self.parent_count\n+                        {\n+                            self.references_parent_regions= true;\n+                        }\n+                    },\n+                });\n+                if self.references_parent_regions {\n+                    ControlFlow::Break(t)\n+                } else {\n+                    ControlFlow::CONTINUE\n+                }\n             }\n         }\n     }\n@@ -408,7 +330,8 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n         };\n         let mut visitor = ProhibitOpaqueVisitor {\n             opaque_identity_ty,\n-            generics: tcx.generics_of(def_id),\n+            parent_count: tcx.generics_of(def_id).parent_count as u32,\n+            references_parent_regions: false,\n             tcx,\n             selftys: vec![],\n         };"}, {"sha": "d3e216d693fb279fedb7a44b56f0628801748fd2", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3afec247cb41e528607c181fd7c278132b6f3c2a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3afec247cb41e528607c181fd7c278132b6f3c2a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=3afec247cb41e528607c181fd7c278132b6f3c2a", "patch": "@@ -423,9 +423,9 @@ impl<'tcx> InferCtxt<'tcx> {\n //\n // We ignore any type parameters because impl trait values are assumed to\n // capture all the in-scope type parameters.\n-struct ConstrainOpaqueTypeRegionVisitor<'tcx, OP> {\n-    tcx: TyCtxt<'tcx>,\n-    op: OP,\n+pub struct ConstrainOpaqueTypeRegionVisitor<'tcx, OP: FnMut(ty::Region<'tcx>)> {\n+    pub tcx: TyCtxt<'tcx>,\n+    pub op: OP,\n }\n \n impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<'tcx, OP>"}]}