{"sha": "d4c40b519b080a08a37d27e015083fd250fdd197", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0YzQwYjUxOWIwODBhMDhhMzdkMjdlMDE1MDgzZmQyNTBmZGQxOTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-30T21:26:46Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-02T19:10:40Z"}, "message": "Bring the linkage documentation up-to-date\n\nThis includes documentation for all the previous changes done to linking\nin #10582. Additionally, this brings the list of feature-gates up-to-date with\nthe currently recognized list of features.", "tree": {"sha": "8e073ea4f79de0dc6616e50f215dfd512273badf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e073ea4f79de0dc6616e50f215dfd512273badf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4c40b519b080a08a37d27e015083fd250fdd197", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4c40b519b080a08a37d27e015083fd250fdd197", "html_url": "https://github.com/rust-lang/rust/commit/d4c40b519b080a08a37d27e015083fd250fdd197", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4c40b519b080a08a37d27e015083fd250fdd197/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9d6fd20a515d677e923686f2fbf4e9f2307aab1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9d6fd20a515d677e923686f2fbf4e9f2307aab1", "html_url": "https://github.com/rust-lang/rust/commit/f9d6fd20a515d677e923686f2fbf4e9f2307aab1"}], "stats": {"total": 242, "additions": 223, "deletions": 19}, "files": [{"sha": "92d9cb3ae38fcdea8c143fce8f5ffbc5484b7c6b", "filename": "doc/rust.md", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/d4c40b519b080a08a37d27e015083fd250fdd197/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4c40b519b080a08a37d27e015083fd250fdd197/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=d4c40b519b080a08a37d27e015083fd250fdd197", "patch": "@@ -2070,6 +2070,38 @@ The currently implemented features of the compiler are:\n                closure as `once` is unlikely to be supported going forward. So\n                they are hidden behind this feature until they are to be removed.\n \n+* `managed_boxes` - Usage of `@` pointers is gated due to many\n+                    planned changes to this feature. In the past, this has meant\n+                    \"a GC pointer\", but the current implementation uses\n+                    reference counting and will likely change drastically over\n+                    time. Additionally, the `@` syntax will no longer be used to\n+                    create GC boxes.\n+\n+* `asm` - The `asm!` macro provides a means for inline assembly. This is often\n+          useful, but the exact syntax for this feature along with its semantics\n+          are likely to change, so this macro usage must be opted into.\n+\n+* `non_ascii_idents` - The compiler supports the use of non-ascii identifiers,\n+                       but the implementation is a little rough around the\n+                       edges, so this can be seen as an experimental feature for\n+                       now until the specification of identifiers is fully\n+                       fleshed out.\n+\n+* `thread_local` - The usage of the `#[thread_local]` attribute is experimental\n+                   and should be seen as unstable. This attribute is used to\n+                   declare a `static` as being unique per-thread leveraging\n+                   LLVM's implementation which works in concert with the kernel\n+                   loader and dynamic linker. This is not necessarily available\n+                   on all platforms, and usage of it is discouraged (rust\n+                   focuses more on task-local data instead of thread-local\n+                   data).\n+\n+* `link_args` - This attribute is used to specify custom flags to the linker,\n+                but usage is strongly discouraged. The compiler's usage of the\n+                system linker is not guaranteed to continue in the future, and\n+                if the system linker is not used then specifying custom flags\n+                doesn't have much meaning.\n+\n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about #[feature] directives which enabled\n the new feature (because the directive is no longer necessary). However, if\n@@ -3611,6 +3643,111 @@ queues, as well as code to copy values between queues and their recipients and\n to serialize values for transmission over operating-system inter-process\n communication facilities.\n \n+### Linkage\n+\n+The Rust compiler supports various methods to link crates together both\n+statically and dynamically. This section will explore the various methods to\n+link Rust crates together, and more information about native libraries can be\n+found in the [ffi tutorial][ffi].\n+\n+In one session of compilation, the compiler can generate multiple artifacts\n+through the usage of command line flags and the `crate_type` attribute.\n+\n+* `--bin`, `#[crate_type = \"bin\"]` - A runnable executable will be produced.\n+  This requires that there is a `main` function in the crate which will be run\n+  when the program begins executing. This will link in all Rust and native\n+  dependencies, producing a distributable binary.\n+\n+* `--lib`, `#[crate_type = \"lib\"]` - A Rust library will be produced. This is\n+  an ambiguous concept as to what exactly is produced because a library can\n+  manifest itself in several forms. The purpose of this generic `lib` option is\n+  to generate the \"compiler recommended\" style of library. The output library\n+  will always be usable by rustc, but the actual type of library may change\n+  from time-to-time. The remaining output types are all different flavors of\n+  libraries, and the `lib` type can be seen as an alias for one of them (but\n+  the actual one is compiler-defined).\n+\n+* `--dylib`, `#[crate_type = \"dylib\"]` - A dynamic Rust library will be\n+  produced. This is different from the `lib` output type in that this forces\n+  dynamic library generation. The resulting dynamic library can be used as a\n+  dependency for other libraries and/or executables.  This output type will\n+  create `*.so` files on linux, `*.dylib` files on osx, and `*.dll` files on\n+  windows.\n+\n+* `--staticlib`, `#[crate_type = \"staticlib\"]` - A static system library will\n+  be produced. This is different from other library outputs in that the Rust\n+  compiler will never attempt to link to `staticlib` outputs. The purpose of\n+  this output type is to create a static library containing all of the local\n+  crate's code along with all upstream dependencies. The static library is\n+  actually a `*.a` archive on linux and osx and a `*.lib` file on windows. This\n+  format is recommended for use in situtations such as linking Rust code into an\n+  existing non-Rust application because it will not have dynamic dependencies on\n+  other Rust code.\n+\n+* `--rlib`, `#[crate_type = \"rlib\"]` - A \"Rust library\" file will be produced.\n+  This is used as an intermediate artifact and can be thought of as a \"static\n+  Rust library\". These `rlib` files, unlike `staticlib` files, are interpreted\n+  by the Rust compiler in future linkage. This essentially means that `rustc`\n+  will look for metadata in `rlib` files like it looks for metadata in dynamic\n+  libraries. This form of output is used to produce statically linked\n+  executables as well as `staticlib` outputs.\n+\n+Note that these outputs are stackable in the sense that if multiple are\n+specified, then the compiler will produce each form of output at once without\n+having to recompile.\n+\n+With all these different kinds of outputs, if crate A depends on crate B, then\n+the compiler could find B in various different forms throughout the system. The\n+only forms looked for by the compiler, however, are the `rlib` format and the\n+dynamic library format. With these two options for a dependent library, the\n+compiler must at some point make a choice between these two formats. With this\n+in mind, the compiler follows these rules when determining what format of\n+dependencies will be used:\n+\n+1. If a dynamic library is being produced, then it is required for all upstream\n+   Rust dependencies to also be dynamic. This is a limitation of the current\n+   implementation of the linkage model.  The reason behind this limitation is to\n+   prevent multiple copies of the same upstream library from showing up, and in\n+   the future it is planned to support a mixture of dynamic and static linking.\n+\n+   When producing a dynamic library, the compiler will generate an error if an\n+   upstream dependency could not be found, and also if an upstream dependency\n+   could only be found in an `rlib` format. Remember that `staticlib` formats\n+   are always ignored by `rustc` for crate-linking purposes.\n+\n+2. If a static library is being produced, all upstream dependecies are\n+   required to be available in `rlib` formats. This requirement stems from the\n+   same reasons that a dynamic library must have all dynamic dependencies.\n+\n+   Note that it is impossible to link in native dynamic dependencies to a static\n+   library, and in this case warnings will be printed about all unlinked native\n+   dynamic dependencies.\n+\n+3. If an `rlib` file is being produced, then there are no restrictions on what\n+   format the upstream dependencies are available in. It is simply required that\n+   all upstream dependencies be available for reading metadata from.\n+\n+   The reason for this is that `rlib` files do not contain any of their upstream\n+   dependencies. It wouldn't be very efficient for all `rlib` files to contain a\n+   copy of `libstd.rlib`!\n+\n+4. If an executable is being produced, then things get a little interesting. As\n+   with the above limitations in dynamic and static libraries, it is required\n+   for all upstream dependencies to be in the same format. The next question is\n+   whether to prefer a dynamic or a static format. The compiler currently favors\n+   static linking over dynamic linking, but this can be inverted with the `-Z\n+   prefer-dynamic` flag to the compiler.\n+\n+   What this means is that first the compiler will attempt to find all upstream\n+   dependencies as `rlib` files, and if successful, it will create a statically\n+   linked executable. If an upstream dependency is missing as an `rlib` file,\n+   then the compiler will force all dependencies to be dynamic and will generate\n+   errors if dynamic versions could not be found.\n+\n+In general, `--bin` or `--lib` should be sufficient for all compilation needs,\n+and the other options are just available if more fine-grained control is desired\n+over the output format of a Rust crate.\n+\n ### Logging system\n \n The runtime contains a system for directing [logging\n@@ -3762,3 +3899,5 @@ Additional specific influences can be seen from the following languages:\n * The typeclass system of Haskell.\n * The lexical identifier rule of Python.\n * The block syntax of Ruby.\n+\n+[ffi]: tutorial-ffi.html"}, {"sha": "f3a72971007ef569152dd2f7d0b544d73ca7785a", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 84, "deletions": 19, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/d4c40b519b080a08a37d27e015083fd250fdd197/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4c40b519b080a08a37d27e015083fd250fdd197/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=d4c40b519b080a08a37d27e015083fd250fdd197", "patch": "@@ -8,13 +8,13 @@ foreign code. Rust is currently unable to call directly into a C++ library, but\n snappy includes a C interface (documented in\n [`snappy-c.h`](https://code.google.com/p/snappy/source/browse/trunk/snappy-c.h)).\n \n-The following is a minimal example of calling a foreign function which will compile if snappy is\n-installed:\n+The following is a minimal example of calling a foreign function which will\n+compile if snappy is installed:\n \n ~~~~ {.xfail-test}\n use std::libc::size_t;\n \n-#[link_args = \"-lsnappy\"]\n+#[link(name = \"snappy\")]\n extern {\n     fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n }\n@@ -25,26 +25,28 @@ fn main() {\n }\n ~~~~\n \n-The `extern` block is a list of function signatures in a foreign library, in this case with the\n-platform's C ABI. The `#[link_args]` attribute is used to instruct the linker to link against the\n-snappy library so the symbols are resolved.\n+The `extern` block is a list of function signatures in a foreign library, in\n+this case with the platform's C ABI. The `#[link(...)]` attribute is used to\n+instruct the linker to link against the snappy library so the symbols are\n+resolved.\n \n-Foreign functions are assumed to be unsafe so calls to them need to be wrapped with `unsafe {}` as a\n-promise to the compiler that everything contained within truly is safe. C libraries often expose\n-interfaces that aren't thread-safe, and almost any function that takes a pointer argument isn't\n-valid for all possible inputs since the pointer could be dangling, and raw pointers fall outside of\n+Foreign functions are assumed to be unsafe so calls to them need to be wrapped\n+with `unsafe {}` as a promise to the compiler that everything contained within\n+truly is safe. C libraries often expose interfaces that aren't thread-safe, and\n+almost any function that takes a pointer argument isn't valid for all possible\n+inputs since the pointer could be dangling, and raw pointers fall outside of\n Rust's safe memory model.\n \n-When declaring the argument types to a foreign function, the Rust compiler will not check if the\n-declaration is correct, so specifying it correctly is part of keeping the binding correct at\n-runtime.\n+When declaring the argument types to a foreign function, the Rust compiler can\n+not check if the declaration is correct, so specifying it correctly is part of\n+keeping the binding correct at runtime.\n \n The `extern` block can be extended to cover the entire snappy API:\n \n ~~~~ {.xfail-test}\n use std::libc::{c_int, size_t};\n \n-#[link_args = \"-lsnappy\"]\n+#[link(name = \"snappy\")]\n extern {\n     fn snappy_compress(input: *u8,\n                        input_length: size_t,\n@@ -232,9 +234,72 @@ fn main() {\n \n # Linking\n \n-In addition to the `#[link_args]` attribute for explicitly passing arguments to the linker, an\n-`extern mod` block will pass `-lmodname` to the linker by default unless it has a `#[nolink]`\n-attribute applied.\n+The `link` attribute on `extern` blocks provides the basic building block for\n+instructing rustc how it will link to native libraries. There are two accepted\n+forms of the link attribute today:\n+\n+* `#[link(name = \"foo\")]`\n+* `#[link(name = \"foo\", kind = \"bar\")]`\n+\n+In both of these cases, `foo` is the name of the native library that we're\n+linking to, and in the second case `bar` is the type of native library that the\n+compiler is linking to. There are currently three known types of native\n+libraries:\n+\n+* Dynamic - `#[link(name = \"readline\")]\n+* Static - `#[link(name = \"my_build_dependency\", kind = \"static\")]\n+* Frameworks - `#[link(name = \"CoreFoundation\", kind = \"framework\")]\n+\n+Note that frameworks are only available on OSX targets.\n+\n+The different `kind` values are meant to differentiate how the native library\n+participates in linkage. From a linkage perspective, the rust compiler creates\n+two flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary).\n+Native dynamic libraries and frameworks are propagated to the final artifact\n+boundary, while static libraries are not propagated at all.\n+\n+A few examples of how this model can be used are:\n+\n+* A native build dependency. Sometimes some C/C++ glue is needed when writing\n+  some rust code, but distribution of the C/C++ code in a library format is just\n+  a burden. In this case, the code will be archived into `libfoo.a` and then the\n+  rust crate would declare a dependency via `#[link(name = \"foo\", kind =\n+  \"static\")]`.\n+\n+  Regardless of the flavor of output for the crate, the native static library\n+  will be included in the output, meaning that distribution of the native static\n+  library is not necessary.\n+\n+* A normal dynamic dependency. Common system libraries (like `readline`) are\n+  available on a large number of systems, and often a static copy of these\n+  libraries cannot be found. When this dependency is included in a rust crate,\n+  partial targets (like rlibs) will not link to the library, but when the rlib\n+  is included in a final target (like a binary), the native library will be\n+  linked in.\n+\n+On OSX, frameworks behave with the same semantics as a dynamic library.\n+\n+## The `link_args` attribute\n+\n+There is one other way to tell rustc how to customize linking, and that is via\n+the `link_args` attribute. This attribute is applied to `extern` blocks and\n+specifies raw flags which need to get passed to the linker when producing an\n+artifact. An example usage would be:\n+\n+~~~ {.xfail-test}\n+#[link_args = \"-foo -bar -baz\"]\n+extern {}\n+~~~\n+\n+Note that this feature is currently hidden behind the `feature(link_args)` gate\n+because this is not a sanctioned way of performing linking. Right now rustc\n+shells out to the system linker, so it makes sense to provide extra command line\n+arguments, but this will not always be the case. In the future rustc may use\n+LLVM directly to link native libraries in which case `link_args` will have no\n+meaning.\n+\n+It is highly recommended to *not* use this attribute, and rather use the more\n+formal `#[link(...)]` attribute on `extern` blocks instead.\n \n # Unsafe blocks\n \n@@ -260,7 +325,7 @@ blocks with the `static` keyword:\n ~~~{.xfail-test}\n use std::libc;\n \n-#[link_args = \"-lreadline\"]\n+#[link(name = \"readline\")]\n extern {\n     static rl_readline_version: libc::c_int;\n }\n@@ -279,7 +344,7 @@ them.\n use std::libc;\n use std::ptr;\n \n-#[link_args = \"-lreadline\"]\n+#[link(name = \"readline\")]\n extern {\n     static mut rl_prompt: *libc::c_char;\n }"}]}