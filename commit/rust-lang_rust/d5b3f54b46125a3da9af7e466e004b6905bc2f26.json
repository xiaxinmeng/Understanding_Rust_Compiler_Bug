{"sha": "d5b3f54b46125a3da9af7e466e004b6905bc2f26", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YjNmNTRiNDYxMjVhM2RhOWFmN2U0NjZlMDA0YjY5MDViYzJmMjY=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-02T19:59:11Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-02T19:59:11Z"}, "message": "Use force_ptr in futex implementation.", "tree": {"sha": "9b47bfccd2f7c3d2b0729248a9d308f994e55151", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b47bfccd2f7c3d2b0729248a9d308f994e55151"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5b3f54b46125a3da9af7e466e004b6905bc2f26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5b3f54b46125a3da9af7e466e004b6905bc2f26", "html_url": "https://github.com/rust-lang/rust/commit/d5b3f54b46125a3da9af7e466e004b6905bc2f26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5b3f54b46125a3da9af7e466e004b6905bc2f26/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "422b5053a9a8730de46b6c22997a04afdd2d4d08", "url": "https://api.github.com/repos/rust-lang/rust/commits/422b5053a9a8730de46b6c22997a04afdd2d4d08", "html_url": "https://github.com/rust-lang/rust/commit/422b5053a9a8730de46b6c22997a04afdd2d4d08"}], "stats": {"total": 25, "additions": 14, "deletions": 11}, "files": [{"sha": "1cfcb65bdc1910cb6521cfccd72526de23e9dab2", "filename": "src/shims/posix/linux/sync.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d5b3f54b46125a3da9af7e466e004b6905bc2f26/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b3f54b46125a3da9af7e466e004b6905bc2f26/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=d5b3f54b46125a3da9af7e466e004b6905bc2f26", "patch": "@@ -22,15 +22,17 @@ pub fn futex<'tcx>(\n     // The first three arguments (after the syscall number itself) are the same to all futex operations:\n     //     (int *addr, int op, int val).\n     // We checked above that these definitely exist.\n-    // Although note that the first one is often passed as a different pointer type, e.g. `*const AtomicU32` or `*mut u32`.\n-    let addr = this.deref_operand(args[1])?;\n+    //\n+    // `addr` is used to identify the mutex, but note that not all futex\n+    // operations actually read from this addres or even require this address\n+    // to exist. Also, the type of `addr` is not consistent. The API requires\n+    // it to be a 4-byte aligned pointer, and will use the 4 bytes at the given\n+    // address as an (atomic) i32. It's not uncommon for `addr` to be passed as\n+    // another type than `*mut i32`, such as `*const AtomicI32`.\n+    let addr = this.force_ptr(this.read_scalar(args[1])?.check_init()?)?;\n     let op = this.read_scalar(args[2])?.to_i32()?;\n     let val = this.read_scalar(args[3])?.to_i32()?;\n \n-    // The raw pointer value is used to identify the mutex.\n-    // Not all mutex operations actually read from this address or even require this address to exist.\n-    let futex_ptr = addr.ptr.assert_ptr();\n-\n     let thread = this.get_active_thread();\n \n     let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\")?;\n@@ -53,14 +55,15 @@ pub fn futex<'tcx>(\n                 // Note that a triggered timeout should have this syscall return with -1 and errno set to ETIMEOUT.\n                 throw_ub_format!(\"miri does not support timeouts for futex operations\");\n             }\n-            // Check the pointer for alignment. Atomic operations are only available for fully aligned values.\n-            this.memory.check_ptr_access(addr.ptr.into(), Size::from_bytes(4), Align::from_bytes(4).unwrap())?;\n+            // Check the pointer for alignment and validity.\n+            // Atomic operations are only available for fully aligned values.\n+            this.memory.check_ptr_access(addr.into(), Size::from_bytes(4), Align::from_bytes(4).unwrap())?;\n             // Read an `i32` through the pointer, regardless of any wrapper types (e.g. `AtomicI32`).\n-            let futex_val = this.read_scalar(addr.offset(Size::ZERO, MemPlaceMeta::None, this.machine.layouts.i32, this)?.into())?.to_i32()?;\n+            let futex_val = this.memory.get_raw(addr.alloc_id)?.read_scalar(this, addr, Size::from_bytes(4))?.to_i32()?;\n             if val == futex_val {\n                 // The value still matches, so we block the trait make it wait for FUTEX_WAKE.\n                 this.block_thread(thread);\n-                this.futex_wait(futex_ptr, thread);\n+                this.futex_wait(addr, thread);\n                 // Succesfully waking up from FUTEX_WAIT always returns zero.\n                 this.write_scalar(Scalar::from_i32(0), dest)?;\n             } else {\n@@ -78,7 +81,7 @@ pub fn futex<'tcx>(\n         op if op == futex_wake => {\n             let mut n = 0;\n             for _ in 0..val {\n-                if let Some(thread) = this.futex_wake(futex_ptr) {\n+                if let Some(thread) = this.futex_wake(addr) {\n                     this.unblock_thread(thread);\n                     n += 1;\n                 } else {"}]}