{"sha": "d3e116a94582e64600a245f1ca3f5a47315cacd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZTExNmE5NDU4MmU2NDYwMGEyNDVmMWNhM2Y1YTQ3MzE1Y2FjZDU=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-06-20T20:28:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-20T20:28:30Z"}, "message": "Rollup merge of #42749 - frewsxcv:frewsxcxv/doc-examples, r=QuietMisdreavus\n\nAdditions/improvements for doc examples.\n\nNone", "tree": {"sha": "1f9f443e75173f3a7a4605787a855d4aa41fbc36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f9f443e75173f3a7a4605787a855d4aa41fbc36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3e116a94582e64600a245f1ca3f5a47315cacd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3e116a94582e64600a245f1ca3f5a47315cacd5", "html_url": "https://github.com/rust-lang/rust/commit/d3e116a94582e64600a245f1ca3f5a47315cacd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3e116a94582e64600a245f1ca3f5a47315cacd5/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d92edacf8ede9b5a63f42423850fa8ae7f5e44a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d92edacf8ede9b5a63f42423850fa8ae7f5e44a5", "html_url": "https://github.com/rust-lang/rust/commit/d92edacf8ede9b5a63f42423850fa8ae7f5e44a5"}, {"sha": "58bbe1d68cddacfd8dca792adb40a6dd04e6d319", "url": "https://api.github.com/repos/rust-lang/rust/commits/58bbe1d68cddacfd8dca792adb40a6dd04e6d319", "html_url": "https://github.com/rust-lang/rust/commit/58bbe1d68cddacfd8dca792adb40a6dd04e6d319"}], "stats": {"total": 172, "additions": 172, "deletions": 0}, "files": [{"sha": "770bca7524c2411147b5cc50087238a5cfdc5964", "filename": "src/libstd/env.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d3e116a94582e64600a245f1ca3f5a47315cacd5/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e116a94582e64600a245f1ca3f5a47315cacd5/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=d3e116a94582e64600a245f1ca3f5a47315cacd5", "patch": "@@ -438,6 +438,35 @@ pub struct JoinPathsError {\n ///\n /// # Examples\n ///\n+/// Joining paths on a Unix-like platform:\n+///\n+/// ```\n+/// # if cfg!(unix) {\n+/// use std::env;\n+/// use std::ffi::OsString;\n+/// use std::path::Path;\n+///\n+/// let paths = [Path::new(\"/bin\"), Path::new(\"/usr/bin\")];\n+/// let path_os_string = env::join_paths(paths.iter()).unwrap();\n+/// assert_eq!(path_os_string, OsString::from(\"/bin:/usr/bin\"));\n+/// # }\n+/// ```\n+///\n+/// Joining a path containing a colon on a Unix-like platform results in an error:\n+///\n+/// ```\n+/// # if cfg!(unix) {\n+/// use std::env;\n+/// use std::path::Path;\n+///\n+/// let paths = [Path::new(\"/bin\"), Path::new(\"/usr/bi:n\")];\n+/// assert!(env::join_paths(paths.iter()).is_err());\n+/// # }\n+/// ```\n+///\n+/// Using `env::join_paths` with `env::spit_paths` to append an item to the `PATH` environment\n+/// variable:\n+///\n /// ```\n /// use std::env;\n /// use std::path::PathBuf;"}, {"sha": "1a91417ca0e92dcdcb623a5e840e668affb9fd4a", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/d3e116a94582e64600a245f1ca3f5a47315cacd5/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e116a94582e64600a245f1ca3f5a47315cacd5/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=d3e116a94582e64600a245f1ca3f5a47315cacd5", "patch": "@@ -152,6 +152,14 @@ pub struct CStr {\n /// in the vector provided.\n ///\n /// [`CString::new`]: struct.CString.html#method.new\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::ffi::{CString, NulError};\n+///\n+/// let _: NulError = CString::new(b\"f\\0oo\".to_vec()).unwrap_err();\n+/// ```\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct NulError(usize, Vec<u8>);\n@@ -160,6 +168,14 @@ pub struct NulError(usize, Vec<u8>);\n /// byte was found too early in the slice provided or one wasn't found at all.\n ///\n /// [`CStr::from_bytes_with_nul`]: struct.CStr.html#method.from_bytes_with_nul\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::ffi::{CStr, FromBytesWithNulError};\n+///\n+/// let _: FromBytesWithNulError = CStr::from_bytes_with_nul(b\"f\\0oo\").unwrap_err();\n+/// ```\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n pub struct FromBytesWithNulError {\n@@ -271,6 +287,27 @@ impl CString {\n     /// to undefined behavior or allocator corruption.\n     ///\n     /// [`into_raw`]: #method.into_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// Create a `CString`, pass ownership to an `extern` function (via raw pointer), then retake\n+    /// ownership with `from_raw`:\n+    ///\n+    /// ```no_run\n+    /// use std::ffi::CString;\n+    /// use std::os::raw::c_char;\n+    ///\n+    /// extern {\n+    ///     fn some_extern_function(s: *mut c_char);\n+    /// }\n+    ///\n+    /// let c_string = CString::new(\"Hello!\").unwrap();\n+    /// let raw = c_string.into_raw();\n+    /// unsafe {\n+    ///     some_extern_function(raw);\n+    ///     let c_string = CString::from_raw(raw);\n+    /// }\n+    /// ```\n     #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n     pub unsafe fn from_raw(ptr: *mut c_char) -> CString {\n         let len = libc::strlen(ptr) + 1; // Including the NUL byte\n@@ -412,6 +449,18 @@ impl CString {\n     /// Extracts a [`CStr`] slice containing the entire string.\n     ///\n     /// [`CStr`]: struct.CStr.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(as_c_str)]\n+    ///\n+    /// use std::ffi::{CString, CStr};\n+    ///\n+    /// let c_string = CString::new(b\"foo\".to_vec()).unwrap();\n+    /// let c_str = c_string.as_c_str();\n+    /// assert_eq!(c_str, CStr::from_bytes_with_nul(b\"foo\\0\").unwrap());\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"as_c_str\", issue = \"40380\")]\n     pub fn as_c_str(&self) -> &CStr {\n@@ -421,6 +470,18 @@ impl CString {\n     /// Converts this `CString` into a boxed [`CStr`].\n     ///\n     /// [`CStr`]: struct.CStr.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(into_boxed_c_str)]\n+    ///\n+    /// use std::ffi::{CString, CStr};\n+    ///\n+    /// let c_string = CString::new(b\"foo\".to_vec()).unwrap();\n+    /// let boxed = c_string.into_boxed_c_str();\n+    /// assert_eq!(&*boxed, CStr::from_bytes_with_nul(b\"foo\\0\").unwrap());\n+    /// ```\n     #[unstable(feature = \"into_boxed_c_str\", issue = \"40380\")]\n     pub fn into_boxed_c_str(self) -> Box<CStr> {\n         unsafe { mem::transmute(self.into_inner()) }\n@@ -708,6 +769,24 @@ impl CStr {\n     /// let cstr = CStr::from_bytes_with_nul(b\"hello\\0\");\n     /// assert!(cstr.is_ok());\n     /// ```\n+    ///\n+    /// Creating a `CStr` without a trailing nul byte is an error:\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let c_str = CStr::from_bytes_with_nul(b\"hello\");\n+    /// assert!(c_str.is_err());\n+    /// ```\n+    ///\n+    /// Creating a `CStr` with an interior nul byte is an error:\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let c_str = CStr::from_bytes_with_nul(b\"he\\0llo\\0\");\n+    /// assert!(c_str.is_err());\n+    /// ```\n     #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n     pub fn from_bytes_with_nul(bytes: &[u8])\n                                -> Result<&CStr, FromBytesWithNulError> {\n@@ -800,6 +879,15 @@ impl CStr {\n     /// > **Note**: This method is currently implemented as a 0-cost cast, but\n     /// > it is planned to alter its definition in the future to perform the\n     /// > length calculation whenever this method is called.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").unwrap();\n+    /// assert_eq!(c_str.to_bytes(), b\"foo\");\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_bytes(&self) -> &[u8] {\n@@ -817,6 +905,15 @@ impl CStr {\n     /// > length calculation whenever this method is called.\n     ///\n     /// [`to_bytes`]: #method.to_bytes\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").unwrap();\n+    /// assert_eq!(c_str.to_bytes_with_nul(), b\"foo\\0\");\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_bytes_with_nul(&self) -> &[u8] {\n@@ -834,6 +931,15 @@ impl CStr {\n     /// > check whenever this method is called.\n     ///\n     /// [`&str`]: ../primitive.str.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").unwrap();\n+    /// assert_eq!(c_str.to_str(), Ok(\"foo\"));\n+    /// ```\n     #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n     pub fn to_str(&self) -> Result<&str, str::Utf8Error> {\n         // NB: When CStr is changed to perform the length check in .to_bytes()\n@@ -857,6 +963,31 @@ impl CStr {\n     ///\n     /// [`Cow`]: ../borrow/enum.Cow.html\n     /// [`str`]: ../primitive.str.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Calling `to_string_lossy` on a `CStr` containing valid UTF-8:\n+    ///\n+    /// ```\n+    /// use std::borrow::Cow;\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let c_str = CStr::from_bytes_with_nul(b\"Hello World\\0\").unwrap();\n+    /// assert_eq!(c_str.to_string_lossy(), Cow::Borrowed(\"Hello World\"));\n+    /// ```\n+    ///\n+    /// Calling `to_string_lossy` on a `CStr` containing invalid UTF-8:\n+    ///\n+    /// ```\n+    /// use std::borrow::Cow;\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let c_str = CStr::from_bytes_with_nul(b\"Hello \\xF0\\x90\\x80World\\0\").unwrap();\n+    /// assert_eq!(\n+    ///     c_str.to_string_lossy(),\n+    ///     Cow::Owned(String::from(\"Hello \ufffdWorld\")) as Cow<str>\n+    /// );\n+    /// ```\n     #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n     pub fn to_string_lossy(&self) -> Cow<str> {\n         String::from_utf8_lossy(self.to_bytes())\n@@ -866,6 +997,18 @@ impl CStr {\n     ///\n     /// [`Box`]: ../boxed/struct.Box.html\n     /// [`CString`]: struct.CString.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(into_boxed_c_str)]\n+    ///\n+    /// use std::ffi::CString;\n+    ///\n+    /// let c_string = CString::new(b\"foo\".to_vec()).unwrap();\n+    /// let boxed = c_string.into_boxed_c_str();\n+    /// assert_eq!(boxed.into_c_string(), CString::new(\"foo\").unwrap());\n+    /// ```\n     #[unstable(feature = \"into_boxed_c_str\", issue = \"40380\")]\n     pub fn into_c_string(self: Box<CStr>) -> CString {\n         unsafe { mem::transmute(self) }"}]}