{"sha": "9a612b2348212d84fa0b839a4c18e4a13fafaf05", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNjEyYjIzNDgyMTJkODRmYTBiODM5YTRjMThlNGExM2ZhZmFmMDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-12T14:38:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-12T14:38:15Z"}, "message": "Auto merge of #59651 - tmandry:discr-index, r=eddyb\n\n Add discr_index to multi-variant layouts\n\nWe remove the assumption that the discriminant is always field 0, in\npreparations for layouts like generators where this is not (always) going to be\nthe case.\n\nSpecifically, upvars are going to go before the discriminant. In theory, it's possible to remove _that_ assumption instead and keep the discriminant at field index 0, but one assumption or the other had to go :)\n\nThere is one place I know of in the debuginfo code where we'll still need to remove assumptions that the discriminant is the _only_ field. I was planning on doing this along with the upcoming generator change, which will also include tests that exercise the code changing in this PR.\n\nr? @eddyb\ncc @oli-obk\ncc @cramertj", "tree": {"sha": "6d7923180ba1e75c157313db24e9ab8354c8be01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d7923180ba1e75c157313db24e9ab8354c8be01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a612b2348212d84fa0b839a4c18e4a13fafaf05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a612b2348212d84fa0b839a4c18e4a13fafaf05", "html_url": "https://github.com/rust-lang/rust/commit/9a612b2348212d84fa0b839a4c18e4a13fafaf05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a612b2348212d84fa0b839a4c18e4a13fafaf05/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b96425699476ccfc4c56185067d80cb792044a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b96425699476ccfc4c56185067d80cb792044a3", "html_url": "https://github.com/rust-lang/rust/commit/5b96425699476ccfc4c56185067d80cb792044a3"}, {"sha": "7c626a67ba02bc7b7bcb5a7e7809e9d54e099d2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c626a67ba02bc7b7bcb5a7e7809e9d54e099d2c", "html_url": "https://github.com/rust-lang/rust/commit/7c626a67ba02bc7b7bcb5a7e7809e9d54e099d2c"}], "stats": {"total": 136, "additions": 77, "deletions": 59}, "files": [{"sha": "fd1d3a91ede1f01930d93973265178912daa25dc", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9a612b2348212d84fa0b839a4c18e4a13fafaf05", "patch": "@@ -920,6 +920,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                                         niche_variants,\n                                         niche_start,\n                                     },\n+                                    discr_index: 0,\n                                     variants: st,\n                                 },\n                                 fields: FieldPlacement::Arbitrary {\n@@ -1142,6 +1143,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     variants: Variants::Multiple {\n                         discr: tag,\n                         discr_kind: DiscriminantKind::Tag,\n+                        discr_index: 0,\n                         variants: layout_variants,\n                     },\n                     fields: FieldPlacement::Arbitrary {\n@@ -1884,10 +1886,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n             Multiple {\n                 ref discr,\n                 ref discr_kind,\n+                discr_index,\n                 ref variants,\n             } => {\n                 discr.hash_stable(hcx, hasher);\n                 discr_kind.hash_stable(hcx, hasher);\n+                discr_index.hash_stable(hcx, hasher);\n                 variants.hash_stable(hcx, hasher);\n             }\n         }"}, {"sha": "6560ed0a8e68656f9582c80b112c80ae83c68222", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=9a612b2348212d84fa0b839a4c18e4a13fafaf05", "patch": "@@ -22,6 +22,7 @@ use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ich::NodeIdHashingMode;\n+use rustc::mir::Field;\n use rustc::mir::interpret::truncate;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::ty::Instance;\n@@ -1306,12 +1307,15 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n             }\n             layout::Variants::Multiple {\n                 discr_kind: layout::DiscriminantKind::Tag,\n+                discr_index,\n                 ref variants,\n                 ..\n             } => {\n                 let discriminant_info = if fallback {\n-                    RegularDiscriminant(self.discriminant_type_metadata\n-                                        .expect(\"\"))\n+                    RegularDiscriminant {\n+                        discr_field: Field::from(discr_index),\n+                        discr_type_metadata: self.discriminant_type_metadata.unwrap()\n+                    }\n                 } else {\n                     // This doesn't matter in this case.\n                     NoDiscriminant\n@@ -1358,6 +1362,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 },\n                 ref discr,\n                 ref variants,\n+                discr_index,\n             } => {\n                 if fallback {\n                     let variant = self.layout.for_variant(cx, dataful_variant);\n@@ -1403,8 +1408,8 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     }\n                     compute_field_path(cx, &mut name,\n                                        self.layout,\n-                                       self.layout.fields.offset(0),\n-                                       self.layout.field(cx, 0).size);\n+                                       self.layout.fields.offset(discr_index),\n+                                       self.layout.field(cx, discr_index).size);\n                     name.push_str(&adt.variants[*niche_variants.start()].ident.as_str());\n \n                     // Create the (singleton) list of descriptions of union members.\n@@ -1486,6 +1491,8 @@ impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n                 name: name.to_string(),\n                 type_metadata: if use_enum_fallback(cx) {\n                     match self.discriminant_type_metadata {\n+                        // Discriminant is always the first field of our variant\n+                        // when using the enum fallback.\n                         Some(metadata) if i == 0 => metadata,\n                         _ => type_metadata(cx, ty, self.span)\n                     }\n@@ -1504,7 +1511,7 @@ impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n \n #[derive(Copy, Clone)]\n enum EnumDiscriminantInfo<'ll> {\n-    RegularDiscriminant(&'ll DIType),\n+    RegularDiscriminant{ discr_field: Field, discr_type_metadata: &'ll DIType },\n     OptimizedDiscriminant,\n     NoDiscriminant\n }\n@@ -1535,15 +1542,26 @@ fn describe_enum_variant(\n                                            unique_type_id,\n                                            Some(containing_scope));\n \n+    let arg_name = |i: usize| {\n+        if variant.ctor_kind == CtorKind::Fn {\n+            format!(\"__{}\", i)\n+        } else {\n+            variant.fields[i].ident.to_string()\n+        }\n+    };\n+\n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n     let (offsets, args) = if use_enum_fallback(cx) {\n         // If this is not a univariant enum, there is also the discriminant field.\n         let (discr_offset, discr_arg) = match discriminant_info {\n-            RegularDiscriminant(_) => {\n+            RegularDiscriminant { discr_field, .. } => {\n                 // We have the layout of an enum variant, we need the layout of the outer enum\n                 let enum_layout = cx.layout_of(layout.ty);\n-                (Some(enum_layout.fields.offset(0)),\n-                 Some((\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, 0).ty)))\n+                let offset = enum_layout.fields.offset(discr_field.as_usize());\n+                let args = (\n+                    \"RUST$ENUM$DISR\".to_owned(),\n+                    enum_layout.field(cx, discr_field.as_usize()).ty);\n+                (Some(offset), Some(args))\n             }\n             _ => (None, None),\n         };\n@@ -1552,12 +1570,7 @@ fn describe_enum_variant(\n                 layout.fields.offset(i)\n             })).collect(),\n             discr_arg.into_iter().chain((0..layout.fields.count()).map(|i| {\n-                let name = if variant.ctor_kind == CtorKind::Fn {\n-                    format!(\"__{}\", i)\n-                } else {\n-                    variant.fields[i].ident.to_string()\n-                };\n-                (name, layout.field(cx, i).ty)\n+                (arg_name(i), layout.field(cx, i).ty)\n             })).collect()\n         )\n     } else {\n@@ -1566,12 +1579,7 @@ fn describe_enum_variant(\n                 layout.fields.offset(i)\n             }).collect(),\n             (0..layout.fields.count()).map(|i| {\n-                let name = if variant.ctor_kind == CtorKind::Fn {\n-                    format!(\"__{}\", i)\n-                } else {\n-                    variant.fields[i].ident.to_string()\n-                };\n-                (name, layout.field(cx, i).ty)\n+                (arg_name(i), layout.field(cx, i).ty)\n             }).collect()\n         )\n     };\n@@ -1581,8 +1589,8 @@ fn describe_enum_variant(\n             offsets,\n             args,\n             discriminant_type_metadata: match discriminant_info {\n-                RegularDiscriminant(discriminant_type_metadata) => {\n-                    Some(discriminant_type_metadata)\n+                RegularDiscriminant { discr_type_metadata, .. } => {\n+                    Some(discr_type_metadata)\n                 }\n                 _ => None\n             },\n@@ -1732,6 +1740,7 @@ fn prepare_enum_metadata(\n         layout::Variants::Multiple {\n             discr_kind: layout::DiscriminantKind::Niche { .. },\n             ref discr,\n+            discr_index,\n             ..\n         } => {\n             // Find the integer type of the correct size.\n@@ -1755,7 +1764,7 @@ fn prepare_enum_metadata(\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n                     align.abi.bits() as u32,\n-                    layout.fields.offset(0).bits(),\n+                    layout.fields.offset(discr_index).bits(),\n                     DIFlags::FlagArtificial,\n                     discr_metadata))\n             }\n@@ -1764,6 +1773,7 @@ fn prepare_enum_metadata(\n         layout::Variants::Multiple {\n             discr_kind: layout::DiscriminantKind::Tag,\n             ref discr,\n+            discr_index,\n             ..\n         } => {\n             let discr_type = discr.value.to_ty(cx.tcx);\n@@ -1779,7 +1789,7 @@ fn prepare_enum_metadata(\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n                     align.bits() as u32,\n-                    layout.fields.offset(0).bits(),\n+                    layout.fields.offset(discr_index).bits(),\n                     DIFlags::FlagArtificial,\n                     discr_metadata))\n             }"}, {"sha": "d42fa8291618c405b8e42179e44f1bec552709b4", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=9a612b2348212d84fa0b839a4c18e4a13fafaf05", "patch": "@@ -452,31 +452,27 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n             _ => {\n                 let mut data_variant = match self.variants {\n+                    // Within the discriminant field, only the niche itself is\n+                    // always initialized, so we only check for a pointer at its\n+                    // offset.\n+                    //\n+                    // If the niche is a pointer, it's either valid (according\n+                    // to its type), or null (which the niche field's scalar\n+                    // validity range encodes).  This allows using\n+                    // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n+                    // this will continue to work as long as we don't start\n+                    // using more niches than just null (e.g., the first page of\n+                    // the address space, or unaligned pointers).\n                     layout::Variants::Multiple {\n                         discr_kind: layout::DiscriminantKind::Niche {\n                             dataful_variant,\n                             ..\n                         },\n+                        discr_index,\n                         ..\n-                    } => {\n-                        // Only the niche itself is always initialized,\n-                        // so only check for a pointer at its offset.\n-                        //\n-                        // If the niche is a pointer, it's either valid\n-                        // (according to its type), or null (which the\n-                        // niche field's scalar validity range encodes).\n-                        // This allows using `dereferenceable_or_null`\n-                        // for e.g., `Option<&T>`, and this will continue\n-                        // to work as long as we don't start using more\n-                        // niches than just null (e.g., the first page\n-                        // of the address space, or unaligned pointers).\n-                        if self.fields.offset(0) == offset {\n-                            Some(self.for_variant(cx, dataful_variant))\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                    _ => Some(*self)\n+                    } if self.fields.offset(discr_index) == offset =>\n+                        Some(self.for_variant(cx, dataful_variant)),\n+                    _ => Some(*self),\n                 };\n \n                 if let Some(variant) = data_variant {"}, {"sha": "1134707f96c9243293cb7fa85a1175412c09c09d", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=9a612b2348212d84fa0b839a4c18e4a13fafaf05", "patch": "@@ -216,19 +216,19 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n         if self.layout.abi.is_uninhabited() {\n             return bx.cx().const_undef(cast_to);\n         }\n-        let (discr_scalar, discr_kind) = match self.layout.variants {\n+        let (discr_scalar, discr_kind, discr_index) = match self.layout.variants {\n             layout::Variants::Single { index } => {\n                 let discr_val = self.layout.ty.ty_adt_def().map_or(\n                     index.as_u32() as u128,\n                     |def| def.discriminant_for_variant(bx.cx().tcx(), index).val);\n                 return bx.cx().const_uint_big(cast_to, discr_val);\n             }\n-            layout::Variants::Multiple { ref discr, ref discr_kind, .. } => {\n-                (discr, discr_kind)\n+            layout::Variants::Multiple { ref discr, ref discr_kind, discr_index, .. } => {\n+                (discr, discr_kind, discr_index)\n             }\n         };\n \n-        let discr = self.project_field(bx, 0);\n+        let discr = self.project_field(bx, discr_index);\n         let lldiscr = bx.load_operand(discr).immediate();\n         match *discr_kind {\n             layout::DiscriminantKind::Tag => {\n@@ -292,9 +292,10 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n             }\n             layout::Variants::Multiple {\n                 discr_kind: layout::DiscriminantKind::Tag,\n+                discr_index,\n                 ..\n             } => {\n-                let ptr = self.project_field(bx, 0);\n+                let ptr = self.project_field(bx, discr_index);\n                 let to = self.layout.ty.ty_adt_def().unwrap()\n                     .discriminant_for_variant(bx.tcx(), variant_index)\n                     .val;\n@@ -309,6 +310,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                     ref niche_variants,\n                     niche_start,\n                 },\n+                discr_index,\n                 ..\n             } => {\n                 if variant_index != dataful_variant {\n@@ -321,7 +323,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                         bx.memset(self.llval, fill_byte, size, self.align, MemFlags::empty());\n                     }\n \n-                    let niche = self.project_field(bx, 0);\n+                    let niche = self.project_field(bx, discr_index);\n                     let niche_llty = bx.cx().immediate_backend_type(niche.layout);\n                     let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n                     let niche_value = (niche_value as u128)"}, {"sha": "d3223c6edb809f46e60d5018d184656286507b6e", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=9a612b2348212d84fa0b839a4c18e4a13fafaf05", "patch": "@@ -820,6 +820,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                     discr_kind: layout::DiscriminantKind::Tag,\n                     ref discr,\n                     ref variants,\n+                    ..\n                 } => (variants, discr),\n                 _ => return,\n             };"}, {"sha": "1ce6d09d7a4e047256724900eb01b546d97a8f89", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=9a612b2348212d84fa0b839a4c18e4a13fafaf05", "patch": "@@ -588,18 +588,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n     ) -> EvalResult<'tcx, (u128, VariantIdx)> {\n         trace!(\"read_discriminant_value {:#?}\", rval.layout);\n \n-        let discr_kind = match rval.layout.variants {\n+        let (discr_kind, discr_index) = match rval.layout.variants {\n             layout::Variants::Single { index } => {\n                 let discr_val = rval.layout.ty.ty_adt_def().map_or(\n                     index.as_u32() as u128,\n                     |def| def.discriminant_for_variant(*self.tcx, index).val);\n                 return Ok((discr_val, index));\n             }\n-            layout::Variants::Multiple { ref discr_kind, .. } => discr_kind,\n+            layout::Variants::Multiple { ref discr_kind, discr_index, .. } =>\n+                (discr_kind, discr_index),\n         };\n \n         // read raw discriminant value\n-        let discr_op = self.operand_field(rval, 0)?;\n+        let discr_op = self.operand_field(rval, discr_index as u64)?;\n         let discr_val = self.read_immediate(discr_op)?;\n         let raw_discr = discr_val.to_scalar_or_undef();\n         trace!(\"discr value: {:?}\", raw_discr);"}, {"sha": "32ad52746896fc4694efd758d3006ca6d29f8942", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=9a612b2348212d84fa0b839a4c18e4a13fafaf05", "patch": "@@ -997,6 +997,7 @@ where\n             layout::Variants::Multiple {\n                 discr_kind: layout::DiscriminantKind::Tag,\n                 ref discr,\n+                discr_index,\n                 ..\n             } => {\n                 let adt_def = dest.layout.ty.ty_adt_def().unwrap();\n@@ -1011,7 +1012,7 @@ where\n                 let size = discr.value.size(self);\n                 let discr_val = truncate(discr_val, size);\n \n-                let discr_dest = self.place_field(dest, 0)?;\n+                let discr_dest = self.place_field(dest, discr_index as u64)?;\n                 self.write_scalar(Scalar::from_uint(discr_val, size), discr_dest)?;\n             }\n             layout::Variants::Multiple {\n@@ -1020,14 +1021,15 @@ where\n                     ref niche_variants,\n                     niche_start,\n                 },\n+                discr_index,\n                 ..\n             } => {\n                 assert!(\n                     variant_index.as_usize() < dest.layout.ty.ty_adt_def().unwrap().variants.len(),\n                 );\n                 if variant_index != dataful_variant {\n                     let niche_dest =\n-                        self.place_field(dest, 0)?;\n+                        self.place_field(dest, discr_index as u64)?;\n                     let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n                     let niche_value = (niche_value as u128)\n                         .wrapping_add(niche_start);"}, {"sha": "59eda97a2f9f5e2c7931376e83e91359ac615682", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a612b2348212d84fa0b839a4c18e4a13fafaf05/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=9a612b2348212d84fa0b839a4c18e4a13fafaf05", "patch": "@@ -828,12 +828,13 @@ pub enum Variants {\n         index: VariantIdx,\n     },\n \n-    /// Enums with more than one inhabited variant: for each case there is\n-    /// a struct, and they all have space reserved for the discriminant,\n-    /// which is the sole field of the enum layout.\n+    /// Enum-likes with more than one inhabited variant: for each case there is\n+    /// a struct, and they all have space reserved for the discriminant.\n+    /// For enums this is the sole field of the layout.\n     Multiple {\n         discr: Scalar,\n         discr_kind: DiscriminantKind,\n+        discr_index: usize,\n         variants: IndexVec<VariantIdx, LayoutDetails>,\n     },\n }\n@@ -845,8 +846,9 @@ pub enum DiscriminantKind {\n \n     /// Niche (values invalid for a type) encoding the discriminant:\n     /// the variant `dataful_variant` contains a niche at an arbitrary\n-    /// offset (field 0 of the enum), which for a variant with discriminant\n-    /// `d` is set to `(d - niche_variants.start).wrapping_add(niche_start)`.\n+    /// offset (field `discr_index` of the enum), which for a variant with\n+    /// discriminant `d` is set to\n+    /// `(d - niche_variants.start).wrapping_add(niche_start)`.\n     ///\n     /// For example, `Option<(usize, &T)>`  is represented such that\n     /// `None` has a null pointer for the second tuple field, and"}]}