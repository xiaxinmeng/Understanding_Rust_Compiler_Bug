{"sha": "a9b1abe6ea96f77ea7fc1761b3cd39c309eb7fcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YjFhYmU2ZWE5NmY3N2VhN2ZjMTc2MWIzY2QzOWMzMDllYjdmY2Q=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-03T20:49:01Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-06T15:05:03Z"}, "message": "Remove `IsNotPromotable` and `IsNotImplicitlyPromotable`\n\nThe former was cleared from `qualifs_in_return_place`, and the latter\nwas never checked. `QUALIF_ERROR_BIT` no longer corresponds to a real\n`Qualif`, however.", "tree": {"sha": "43fe2c32e8ddcbcf7633303d372fa072c8492cae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43fe2c32e8ddcbcf7633303d372fa072c8492cae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9b1abe6ea96f77ea7fc1761b3cd39c309eb7fcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9b1abe6ea96f77ea7fc1761b3cd39c309eb7fcd", "html_url": "https://github.com/rust-lang/rust/commit/a9b1abe6ea96f77ea7fc1761b3cd39c309eb7fcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9b1abe6ea96f77ea7fc1761b3cd39c309eb7fcd/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "383eb01593ff6361e246bbbba90703ba70530763", "url": "https://api.github.com/repos/rust-lang/rust/commits/383eb01593ff6361e246bbbba90703ba70530763", "html_url": "https://github.com/rust-lang/rust/commit/383eb01593ff6361e246bbbba90703ba70530763"}], "stats": {"total": 246, "additions": 11, "deletions": 235}, "files": [{"sha": "600d4735370abfdb1a8318fbc211ca51ca4b6257", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 11, "deletions": 235, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/a9b1abe6ea96f77ea7fc1761b3cd39c309eb7fcd/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b1abe6ea96f77ea7fc1761b3cd39c309eb7fcd/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=a9b1abe6ea96f77ea7fc1761b3cd39c309eb7fcd", "patch": "@@ -69,7 +69,7 @@ impl fmt::Display for Mode {\n     }\n }\n \n-const QUALIF_COUNT: usize = 4;\n+const QUALIF_COUNT: usize = 2;\n \n // FIXME(eddyb) once we can use const generics, replace this array with\n // something like `IndexVec` but for fixed-size arrays (`IndexArray`?).\n@@ -78,20 +78,20 @@ struct PerQualif<T>([T; QUALIF_COUNT]);\n \n impl<T: Clone> PerQualif<T> {\n     fn new(x: T) -> Self {\n-        PerQualif([x.clone(), x.clone(), x.clone(), x])\n+        PerQualif([x.clone(), x])\n     }\n }\n \n impl<T> PerQualif<T> {\n     fn as_mut(&mut self) -> PerQualif<&mut T> {\n-        let [x0, x1, x2, x3] = &mut self.0;\n-        PerQualif([x0, x1, x2, x3])\n+        let [x0, x1] = &mut self.0;\n+        PerQualif([x0, x1])\n     }\n \n     fn zip<U>(self, other: PerQualif<U>) -> PerQualif<(T, U)> {\n-        let [x0, x1, x2, x3] = self.0;\n-        let [y0, y1, y2, y3] = other.0;\n-        PerQualif([(x0, y0), (x1, y1), (x2, y2), (x3, y3)])\n+        let [x0, x1] = self.0;\n+        let [y0, y1] = other.0;\n+        PerQualif([(x0, y0), (x1, y1)])\n     }\n }\n \n@@ -427,195 +427,6 @@ impl Qualif for NeedsDrop {\n     }\n }\n \n-/// Not promotable at all - non-`const fn` calls, `asm!`,\n-/// pointer comparisons, ptr-to-int casts, etc.\n-/// Inside a const context all constness rules apply, so promotion simply has to follow the regular\n-/// constant rules (modulo interior mutability or `Drop` rules which are handled `HasMutInterior`\n-/// and `NeedsDrop` respectively). Basically this duplicates the checks that the const-checking\n-/// visitor enforces by emitting errors when working in const context.\n-struct IsNotPromotable;\n-\n-impl Qualif for IsNotPromotable {\n-    const IDX: usize = 2;\n-\n-    fn in_static(cx: &ConstCx<'_, 'tcx>, static_: &Static<'tcx>) -> bool {\n-        match static_.kind {\n-            StaticKind::Promoted(_, _) => unreachable!(),\n-            StaticKind::Static => {\n-                // Only allow statics (not consts) to refer to other statics.\n-                // FIXME(eddyb) does this matter at all for promotion?\n-                let allowed = cx.mode == Mode::Static || cx.mode == Mode::StaticMut;\n-\n-                !allowed ||\n-                    cx.tcx.get_attrs(static_.def_id).iter().any(\n-                        |attr| attr.check_name(sym::thread_local)\n-                    )\n-            }\n-        }\n-    }\n-\n-    fn in_projection(\n-        cx: &ConstCx<'_, 'tcx>,\n-        place: PlaceRef<'_, 'tcx>,\n-    ) -> bool {\n-        if let [proj_base @ .., elem] = place.projection {\n-            match elem {\n-                ProjectionElem::Deref |\n-                ProjectionElem::Downcast(..) => return true,\n-\n-                ProjectionElem::ConstantIndex {..} |\n-                ProjectionElem::Subslice {..} |\n-                ProjectionElem::Index(_) => {}\n-\n-                ProjectionElem::Field(..) => {\n-                    if cx.mode == Mode::NonConstFn {\n-                        let base_ty = Place::ty_from(place.base, proj_base, cx.body, cx.tcx).ty;\n-                        if let Some(def) = base_ty.ty_adt_def() {\n-                            // No promotion of union field accesses.\n-                            if def.is_union() {\n-                                return true;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            Self::in_projection_structurally(cx, place)\n-        } else {\n-            bug!(\"This should be called if projection is not empty\");\n-        }\n-    }\n-\n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n-        match *rvalue {\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if cx.mode == Mode::NonConstFn => {\n-                let operand_ty = operand.ty(cx.body, cx.tcx);\n-                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n-                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                match (cast_in, cast_out) {\n-                    (CastTy::Ptr(_), CastTy::Int(_)) |\n-                    (CastTy::FnPtr, CastTy::Int(_)) => {\n-                        // in normal functions, mark such casts as not promotable\n-                        return true;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            Rvalue::BinaryOp(op, ref lhs, _) if cx.mode == Mode::NonConstFn => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(cx.body, cx.tcx).kind {\n-                    assert!(op == BinOp::Eq || op == BinOp::Ne ||\n-                            op == BinOp::Le || op == BinOp::Lt ||\n-                            op == BinOp::Ge || op == BinOp::Gt ||\n-                            op == BinOp::Offset);\n-\n-                    // raw pointer operations are not allowed inside promoteds\n-                    return true;\n-                }\n-            }\n-\n-            Rvalue::NullaryOp(NullOp::Box, _) => return true,\n-\n-            _ => {}\n-        }\n-\n-        Self::in_rvalue_structurally(cx, rvalue)\n-    }\n-\n-    fn in_call(\n-        cx: &ConstCx<'_, 'tcx>,\n-        callee: &Operand<'tcx>,\n-        args: &[Operand<'tcx>],\n-        _return_ty: Ty<'tcx>,\n-    ) -> bool {\n-        let fn_ty = callee.ty(cx.body, cx.tcx);\n-        match fn_ty.kind {\n-            ty::FnDef(def_id, _) => {\n-                match cx.tcx.fn_sig(def_id).abi() {\n-                    Abi::RustIntrinsic |\n-                    Abi::PlatformIntrinsic => {\n-                        assert!(!cx.tcx.is_const_fn(def_id));\n-                        match &*cx.tcx.item_name(def_id).as_str() {\n-                            | \"size_of\"\n-                            | \"min_align_of\"\n-                            | \"needs_drop\"\n-                            | \"type_id\"\n-                            | \"bswap\"\n-                            | \"bitreverse\"\n-                            | \"ctpop\"\n-                            | \"cttz\"\n-                            | \"cttz_nonzero\"\n-                            | \"ctlz\"\n-                            | \"ctlz_nonzero\"\n-                            | \"wrapping_add\"\n-                            | \"wrapping_sub\"\n-                            | \"wrapping_mul\"\n-                            | \"unchecked_shl\"\n-                            | \"unchecked_shr\"\n-                            | \"rotate_left\"\n-                            | \"rotate_right\"\n-                            | \"add_with_overflow\"\n-                            | \"sub_with_overflow\"\n-                            | \"mul_with_overflow\"\n-                            | \"saturating_add\"\n-                            | \"saturating_sub\"\n-                            | \"transmute\"\n-                            | \"simd_insert\"\n-                            | \"simd_extract\"\n-                            | \"ptr_offset_from\"\n-                            => return true,\n-\n-                            _ => {}\n-                        }\n-                    }\n-                    _ => {\n-                        let is_const_fn =\n-                            cx.tcx.is_const_fn(def_id) ||\n-                            cx.tcx.is_unstable_const_fn(def_id).is_some() ||\n-                            cx.is_const_panic_fn(def_id);\n-                        if !is_const_fn {\n-                            return true;\n-                        }\n-                    }\n-                }\n-            }\n-            _ => return true,\n-        }\n-\n-        Self::in_operand(cx, callee) || args.iter().any(|arg| Self::in_operand(cx, arg))\n-    }\n-}\n-\n-/// Refers to temporaries which cannot be promoted *implicitly*.\n-/// Explicit promotion happens e.g. for constant arguments declared via `rustc_args_required_const`.\n-/// Implicit promotion has almost the same rules, except that disallows `const fn` except for\n-/// those marked `#[rustc_promotable]`. This is to avoid changing a legitimate run-time operation\n-/// into a failing compile-time operation e.g. due to addresses being compared inside the function.\n-struct IsNotImplicitlyPromotable;\n-\n-impl Qualif for IsNotImplicitlyPromotable {\n-    const IDX: usize = 3;\n-\n-    fn in_call(\n-        cx: &ConstCx<'_, 'tcx>,\n-        callee: &Operand<'tcx>,\n-        args: &[Operand<'tcx>],\n-        _return_ty: Ty<'tcx>,\n-    ) -> bool {\n-        if cx.mode == Mode::NonConstFn {\n-            if let ty::FnDef(def_id, _) = callee.ty(cx.body, cx.tcx).kind {\n-                // Never promote runtime `const fn` calls of\n-                // functions without `#[rustc_promotable]`.\n-                if !cx.tcx.is_promotable_const_fn(def_id) {\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        Self::in_operand(cx, callee) || args.iter().any(|arg| Self::in_operand(cx, arg))\n-    }\n-}\n-\n // Ensure the `IDX` values are sequential (`0..QUALIF_COUNT`).\n macro_rules! static_assert_seq_qualifs {\n     ($i:expr => $first:ident $(, $rest:ident)*) => {\n@@ -630,35 +441,28 @@ macro_rules! static_assert_seq_qualifs {\n     };\n }\n static_assert_seq_qualifs!(\n-    0 => HasMutInterior, NeedsDrop, IsNotPromotable, IsNotImplicitlyPromotable\n+    0 => HasMutInterior, NeedsDrop\n );\n \n impl ConstCx<'_, 'tcx> {\n     fn qualifs_in_any_value_of_ty(&self, ty: Ty<'tcx>) -> PerQualif<bool> {\n         let mut qualifs = PerQualif::default();\n         qualifs[HasMutInterior] = HasMutInterior::in_any_value_of_ty(self, ty).unwrap_or(false);\n         qualifs[NeedsDrop] = NeedsDrop::in_any_value_of_ty(self, ty).unwrap_or(false);\n-        qualifs[IsNotPromotable] = IsNotPromotable::in_any_value_of_ty(self, ty).unwrap_or(false);\n-        qualifs[IsNotImplicitlyPromotable] =\n-            IsNotImplicitlyPromotable::in_any_value_of_ty(self, ty).unwrap_or(false);\n         qualifs\n     }\n \n     fn qualifs_in_local(&self, local: Local) -> PerQualif<bool> {\n         let mut qualifs = PerQualif::default();\n         qualifs[HasMutInterior] = HasMutInterior::in_local(self, local);\n         qualifs[NeedsDrop] = NeedsDrop::in_local(self, local);\n-        qualifs[IsNotPromotable] = IsNotPromotable::in_local(self, local);\n-        qualifs[IsNotImplicitlyPromotable] = IsNotImplicitlyPromotable::in_local(self, local);\n         qualifs\n     }\n \n     fn qualifs_in_value(&self, source: ValueSource<'_, 'tcx>) -> PerQualif<bool> {\n         let mut qualifs = PerQualif::default();\n         qualifs[HasMutInterior] = HasMutInterior::in_value(self, source);\n         qualifs[NeedsDrop] = NeedsDrop::in_value(self, source);\n-        qualifs[IsNotPromotable] = IsNotPromotable::in_value(self, source);\n-        qualifs[IsNotImplicitlyPromotable] = IsNotImplicitlyPromotable::in_value(self, source);\n         qualifs\n     }\n }\n@@ -729,14 +533,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     }\n                 }\n             }\n-            if !temps[local].is_promotable() {\n-                cx.per_local[IsNotPromotable].insert(local);\n-            }\n-            if let LocalKind::Var = body.local_kind(local) {\n-                // Sanity check to prevent implicit and explicit promotion of\n-                // named locals\n-                assert!(cx.per_local[IsNotPromotable].contains(local));\n-            }\n         }\n \n         Checker {\n@@ -795,11 +591,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 // the borrowed place is disallowed from being borrowed,\n                 // due to either a mutable borrow (with some exceptions),\n                 // or an shared borrow of a value with interior mutability.\n-                // Then `HasMutInterior` is replaced with `IsNotPromotable`,\n+                // Then `HasMutInterior` is cleared\n                 // to avoid duplicate errors (e.g. from reborrowing).\n                 if qualifs[HasMutInterior] {\n                     qualifs[HasMutInterior] = false;\n-                    qualifs[IsNotPromotable] = true;\n \n                     debug!(\"suppress_errors: {}\", self.suppress_errors);\n                     if self.mode.requires_const_checking() && !self.suppress_errors {\n@@ -884,18 +679,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 per_local.insert(index);\n             }\n         }\n-\n-        // Ensure the `IsNotPromotable` qualification is preserved.\n-        // NOTE(eddyb) this is actually unnecessary right now, as\n-        // we never replace the local's qualif, but we might in\n-        // the future, and so it serves to catch changes that unset\n-        // important bits (in which case, asserting `contains` could\n-        // be replaced with calling `insert` to re-set the bit).\n-        if kind == LocalKind::Temp {\n-            if !self.temp_promotion_state[index].is_promotable() {\n-                assert!(self.cx.per_local[IsNotPromotable].contains(index));\n-            }\n-        }\n     }\n \n     /// Check a whole const, static initializer or const fn.\n@@ -1041,14 +824,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             }\n         }\n \n-        let mut qualifs = self.qualifs_in_local(RETURN_PLACE);\n-\n-        // Account for errors in consts by using the\n-        // conservative type qualification instead.\n-        if qualifs[IsNotPromotable] {\n-            qualifs = self.qualifs_in_any_value_of_ty(body.return_ty());\n-        }\n-\n+        let qualifs = self.qualifs_in_local(RETURN_PLACE);\n         (qualifs.encode_to_bits(), self.tcx.arena.alloc(promoted_temps))\n     }\n }\n@@ -1577,7 +1353,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n \n // FIXME(eddyb) this is only left around for the validation logic\n // in `promote_consts`, see the comment in `validate_operand`.\n-pub(super) const QUALIF_ERROR_BIT: u8 = 1 << IsNotPromotable::IDX;\n+pub(super) const QUALIF_ERROR_BIT: u8 = 1 << 2;\n \n fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> (u8, &BitSet<Local>) {\n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value"}]}