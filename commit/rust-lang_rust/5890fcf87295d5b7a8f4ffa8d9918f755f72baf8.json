{"sha": "5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4OTBmY2Y4NzI5NWQ1YjdhOGY0ZmZhOGQ5OTE4Zjc1NWY3MmJhZjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-02T01:01:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-02T01:01:42Z"}, "message": "auto merge of #8116 : toddaaro/rust/tls-tk-pr-pre, r=brson\n\nMerged with task killing code this time around.", "tree": {"sha": "6bdd10dda4a962843c3dce5dee33e509152e95cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bdd10dda4a962843c3dce5dee33e509152e95cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "html_url": "https://github.com/rust-lang/rust/commit/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d346f1a40e0d0ebe24e60d418f304641fc26f9b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d346f1a40e0d0ebe24e60d418f304641fc26f9b0", "html_url": "https://github.com/rust-lang/rust/commit/d346f1a40e0d0ebe24e60d418f304641fc26f9b0"}, {"sha": "ce761f4980e6cdc6115608e6db551bdf1c49387f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce761f4980e6cdc6115608e6db551bdf1c49387f", "html_url": "https://github.com/rust-lang/rust/commit/ce761f4980e6cdc6115608e6db551bdf1c49387f"}], "stats": {"total": 2269, "additions": 1135, "deletions": 1134}, "files": [{"sha": "04058887970d03e96ef6487681cde545acb1ec1a", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -23,9 +23,14 @@ macro_rules! rtdebug_ (\n     } )\n )\n \n-// An alternate version with no output, for turning off logging\n+// An alternate version with no output, for turning off logging. An\n+// earlier attempt that did not call the fmt! macro was insufficient,\n+// as a case of the \"let bind each variable\" approach eventually\n+// failed without an error message describing the invocation site.\n macro_rules! rtdebug (\n-    ($( $arg:expr),+) => ( $(let _ = $arg)*; )\n+    ($( $arg:expr),+) => ( {\n+        let _x = fmt!( $($arg),+ );\n+    })\n )\n \n macro_rules! rtassert ("}, {"sha": "5a671d877d2ecf1ad8cbe0d06ac3dae40312ca24", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -24,6 +24,7 @@ use util::Void;\n use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n use cell::Cell;\n use clone::Clone;\n+use rt::{context, SchedulerContext};\n \n /// A combined refcount / BlockedTask-as-uint pointer.\n ///\n@@ -90,6 +91,9 @@ impl<T> ChanOne<T> {\n     }\n \n     pub fn try_send(self, val: T) -> bool {\n+\n+        rtassert!(context() != SchedulerContext);\n+\n         let mut this = self;\n         let mut recvr_active = true;\n         let packet = this.packet();\n@@ -127,10 +131,7 @@ impl<T> ChanOne<T> {\n                     // Port is blocked. Wake it up.\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n                     do recvr.wake().map_consume |woken_task| {\n-                        let mut sched = Local::take::<Scheduler>();\n-                        rtdebug!(\"rendezvous send\");\n-                        sched.metrics.rendezvous_sends += 1;\n-                        sched.schedule_task(woken_task);\n+                        Scheduler::run_task(woken_task);\n                     };\n                 }\n             }\n@@ -346,8 +347,7 @@ impl<T> Drop for ChanOne<T> {\n                     assert!((*this.packet()).payload.is_none());\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n                     do recvr.wake().map_consume |woken_task| {\n-                        let sched = Local::take::<Scheduler>();\n-                        sched.schedule_task(woken_task);\n+                        Scheduler::run_task(woken_task);\n                     };\n                 }\n             }\n@@ -743,7 +743,7 @@ mod test {\n         do run_in_newsched_task {\n             let (port, chan) = oneshot::<~int>();\n             let port_cell = Cell::new(port);\n-            do spawntask_immediately {\n+            do spawntask {\n                 assert!(port_cell.take().recv() == ~10);\n             }\n \n@@ -1019,5 +1019,4 @@ mod test {\n             }\n         }\n     }\n-\n }"}, {"sha": "890ad061a68066eee1e24ea0880e63223f77c626", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -49,12 +49,11 @@ impl Context {\n         let argp: *c_void = unsafe { transmute::<&~fn(), *c_void>(&*start) };\n         let sp: *uint = stack.end();\n         let sp: *mut uint = unsafe { transmute_mut_unsafe(sp) };\n-\n         // Save and then immediately load the current context,\n         // which we will then modify to call the given function when restored\n         let mut regs = new_regs();\n         unsafe {\n-            swap_registers(transmute_mut_region(&mut *regs), transmute_region(&*regs))\n+            swap_registers(transmute_mut_region(&mut *regs), transmute_region(&*regs));\n         };\n \n         initialize_call_frame(&mut *regs, fp, argp, sp);\n@@ -72,13 +71,14 @@ impl Context {\n     then loading the registers from a previously saved Context.\n     */\n     pub fn swap(out_context: &mut Context, in_context: &Context) {\n+        rtdebug!(\"swapping contexts\");\n         let out_regs: &mut Registers = match out_context {\n             &Context { regs: ~ref mut r, _ } => r\n         };\n         let in_regs: &Registers = match in_context {\n             &Context { regs: ~ref r, _ } => r\n         };\n-\n+        rtdebug!(\"doing raw swap\");\n         unsafe { swap_registers(out_regs, in_regs) };\n     }\n }"}, {"sha": "2daa64e808530c4298eb2b7378395557672abc2e", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -186,15 +186,15 @@ mod test {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n                 let mut stream = listener.accept();\n                 let mut buf = [0];\n                 stream.read(buf);\n                 assert!(buf[0] == 99);\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]);\n             }\n@@ -206,15 +206,15 @@ mod test {\n         do run_in_newsched_task {\n             let addr = next_test_ip6();\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n                 let mut stream = listener.accept();\n                 let mut buf = [0];\n                 stream.read(buf);\n                 assert!(buf[0] == 99);\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]);\n             }\n@@ -226,15 +226,15 @@ mod test {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n                 let mut stream = listener.accept();\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n                 assert!(nread.is_none());\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -246,15 +246,15 @@ mod test {\n         do run_in_newsched_task {\n             let addr = next_test_ip6();\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n                 let mut stream = listener.accept();\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n                 assert!(nread.is_none());\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -266,7 +266,7 @@ mod test {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n                 let mut stream = listener.accept();\n                 let mut buf = [0];\n@@ -276,7 +276,7 @@ mod test {\n                 assert!(nread.is_none());\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -288,7 +288,7 @@ mod test {\n         do run_in_newsched_task {\n             let addr = next_test_ip6();\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n                 let mut stream = listener.accept();\n                 let mut buf = [0];\n@@ -298,7 +298,7 @@ mod test {\n                 assert!(nread.is_none());\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -310,7 +310,7 @@ mod test {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n                 let mut stream = listener.accept();\n                 let buf = [0];\n@@ -327,7 +327,7 @@ mod test {\n                 }\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -339,7 +339,7 @@ mod test {\n         do run_in_newsched_task {\n             let addr = next_test_ip6();\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n                 let mut stream = listener.accept();\n                 let buf = [0];\n@@ -356,7 +356,7 @@ mod test {\n                 }\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -369,7 +369,7 @@ mod test {\n             let addr = next_test_ip4();\n             let max = 10;\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n                 do max.times {\n                     let mut stream = listener.accept();\n@@ -379,7 +379,7 @@ mod test {\n                 }\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 do max.times {\n                     let mut stream = TcpStream::connect(addr);\n                     stream.write([99]);\n@@ -394,7 +394,7 @@ mod test {\n             let addr = next_test_ip6();\n             let max = 10;\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n                 do max.times {\n                     let mut stream = listener.accept();\n@@ -404,7 +404,7 @@ mod test {\n                 }\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 do max.times {\n                     let mut stream = TcpStream::connect(addr);\n                     stream.write([99]);\n@@ -419,13 +419,13 @@ mod test {\n             let addr = next_test_ip4();\n             static MAX: int = 10;\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n                 for int::range(0, MAX) |i| {\n                     let stream = Cell::new(listener.accept());\n                     rtdebug!(\"accepted\");\n                     // Start another task to handle the connection\n-                    do spawntask_immediately {\n+                    do spawntask {\n                         let mut stream = stream.take();\n                         let mut buf = [0];\n                         stream.read(buf);\n@@ -440,7 +440,7 @@ mod test {\n             fn connect(i: int, addr: IpAddr) {\n                 if i == MAX { return }\n \n-                do spawntask_immediately {\n+                do spawntask {\n                     rtdebug!(\"connecting\");\n                     let mut stream = TcpStream::connect(addr);\n                     // Connect again before writing\n@@ -458,13 +458,13 @@ mod test {\n             let addr = next_test_ip6();\n             static MAX: int = 10;\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n                 for int::range(0, MAX) |i| {\n                     let stream = Cell::new(listener.accept());\n                     rtdebug!(\"accepted\");\n                     // Start another task to handle the connection\n-                    do spawntask_immediately {\n+                    do spawntask {\n                         let mut stream = stream.take();\n                         let mut buf = [0];\n                         stream.read(buf);\n@@ -479,7 +479,7 @@ mod test {\n             fn connect(i: int, addr: IpAddr) {\n                 if i == MAX { return }\n \n-                do spawntask_immediately {\n+                do spawntask {\n                     rtdebug!(\"connecting\");\n                     let mut stream = TcpStream::connect(addr);\n                     // Connect again before writing\n@@ -497,7 +497,7 @@ mod test {\n             let addr = next_test_ip4();\n             static MAX: int = 10;\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n                 for int::range(0, MAX) |_| {\n                     let stream = Cell::new(listener.accept());\n@@ -535,7 +535,7 @@ mod test {\n             let addr = next_test_ip6();\n             static MAX: int = 10;\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n                 for int::range(0, MAX) |_| {\n                     let stream = Cell::new(listener.accept());\n@@ -571,7 +571,7 @@ mod test {\n     #[cfg(test)]\n     fn socket_name(addr: IpAddr) {\n         do run_in_newsched_task {\n-            do spawntask_immediately {\n+            do spawntask {\n                 let listener = TcpListener::bind(addr);\n \n                 assert!(listener.is_some());\n@@ -590,13 +590,13 @@ mod test {\n     #[cfg(test)]\n     fn peer_name(addr: IpAddr) {\n         do run_in_newsched_task {\n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n \n                 listener.accept();\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let stream = TcpStream::connect(addr);\n \n                 assert!(stream.is_some());"}, {"sha": "c04abfa899b1a484be767af6cd7e1062c7895871", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -132,7 +132,7 @@ mod test {\n             let server_ip = next_test_ip4();\n             let client_ip = next_test_ip4();\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 match UdpSocket::bind(server_ip) {\n                     Some(ref mut server) => {\n                         let mut buf = [0];\n@@ -149,7 +149,7 @@ mod test {\n                 }\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 match UdpSocket::bind(client_ip) {\n                     Some(ref mut client) => client.sendto([99], server_ip),\n                     None => fail!()\n@@ -164,7 +164,7 @@ mod test {\n             let server_ip = next_test_ip6();\n             let client_ip = next_test_ip6();\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 match UdpSocket::bind(server_ip) {\n                     Some(ref mut server) => {\n                         let mut buf = [0];\n@@ -181,7 +181,7 @@ mod test {\n                 }\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 match UdpSocket::bind(client_ip) {\n                     Some(ref mut client) => client.sendto([99], server_ip),\n                     None => fail!()\n@@ -196,7 +196,7 @@ mod test {\n             let server_ip = next_test_ip4();\n             let client_ip = next_test_ip4();\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 match UdpSocket::bind(server_ip) {\n                     Some(server) => {\n                         let server = ~server;\n@@ -214,7 +214,7 @@ mod test {\n                 }\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 match UdpSocket::bind(client_ip) {\n                     Some(client) => {\n                         let client = ~client;\n@@ -233,7 +233,7 @@ mod test {\n             let server_ip = next_test_ip6();\n             let client_ip = next_test_ip6();\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 match UdpSocket::bind(server_ip) {\n                     Some(server) => {\n                         let server = ~server;\n@@ -251,7 +251,7 @@ mod test {\n                 }\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 match UdpSocket::bind(client_ip) {\n                     Some(client) => {\n                         let client = ~client;\n@@ -267,7 +267,7 @@ mod test {\n     #[cfg(test)]\n     fn socket_name(addr: IpAddr) {\n         do run_in_newsched_task {\n-            do spawntask_immediately {\n+            do spawntask {\n                 let server = UdpSocket::bind(addr);\n \n                 assert!(server.is_some());"}, {"sha": "7ab63233cff2f62694152eca6964ecc9e1c7435a", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 91, "deletions": 59, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -14,6 +14,7 @@ use rt::task::Task;\n use rt::local_ptr;\n use rt::rtio::{EventLoop, IoFactoryObject};\n //use borrow::to_uint;\n+use cell::Cell;\n \n pub trait Local {\n     fn put(value: ~Self);\n@@ -24,40 +25,62 @@ pub trait Local {\n     unsafe fn try_unsafe_borrow() -> Option<*mut Self>;\n }\n \n-impl Local for Scheduler {\n-    fn put(value: ~Scheduler) { unsafe { local_ptr::put(value) }}\n-    fn take() -> ~Scheduler { unsafe { local_ptr::take() } }\n+impl Local for Task {\n+    fn put(value: ~Task) { unsafe { local_ptr::put(value) } }\n+    fn take() -> ~Task { unsafe { local_ptr::take() } }\n     fn exists() -> bool { local_ptr::exists() }\n-    fn borrow<T>(f: &fn(&mut Scheduler) -> T) -> T {\n+    fn borrow<T>(f: &fn(&mut Task) -> T) -> T {\n         let mut res: Option<T> = None;\n         let res_ptr: *mut Option<T> = &mut res;\n         unsafe {\n-            do local_ptr::borrow |sched| {\n-//                rtdebug!(\"successfully unsafe borrowed sched pointer\");\n-                let result = f(sched);\n+            do local_ptr::borrow |task| {\n+                let result = f(task);\n                 *res_ptr = Some(result);\n             }\n         }\n         match res {\n             Some(r) => { r }\n-            None => rtabort!(\"function failed!\")\n+            None => { rtabort!(\"function failed in local_borrow\") }\n+        }\n+    }\n+    unsafe fn unsafe_borrow() -> *mut Task { local_ptr::unsafe_borrow() }\n+    unsafe fn try_unsafe_borrow() -> Option<*mut Task> {\n+        if Local::exists::<Task>() {\n+            Some(Local::unsafe_borrow())\n+        } else {\n+            None\n         }\n     }\n-    unsafe fn unsafe_borrow() -> *mut Scheduler { local_ptr::unsafe_borrow() }\n-    unsafe fn try_unsafe_borrow() -> Option<*mut Scheduler> { rtabort!(\"unimpl\") }\n }\n \n-impl Local for Task {\n-    fn put(_value: ~Task) { rtabort!(\"unimpl\") }\n-    fn take() -> ~Task { rtabort!(\"unimpl\") }\n-    fn exists() -> bool { rtabort!(\"unimpl\") }\n-    fn borrow<T>(f: &fn(&mut Task) -> T) -> T {\n-        do Local::borrow::<Scheduler, T> |sched| {\n-//            rtdebug!(\"sched about to grab current_task\");\n-            match sched.current_task {\n+impl Local for Scheduler {\n+    fn put(value: ~Scheduler) {\n+        let value = Cell::new(value);\n+        do Local::borrow::<Task,()> |task| {\n+            let task = task;\n+            task.sched = Some(value.take());\n+        };\n+    }\n+    fn take() -> ~Scheduler {\n+        do Local::borrow::<Task,~Scheduler> |task| {\n+            let sched = task.sched.take_unwrap();\n+            let task = task;\n+            task.sched = None;\n+            sched\n+        }\n+    }\n+    fn exists() -> bool {\n+        do Local::borrow::<Task,bool> |task| {\n+            match task.sched {\n+                Some(ref _task) => true,\n+                None => false\n+            }\n+        }\n+    }\n+    fn borrow<T>(f: &fn(&mut Scheduler) -> T) -> T {\n+        do Local::borrow::<Task, T> |task| {\n+            match task.sched {\n                 Some(~ref mut task) => {\n-//                    rtdebug!(\"current task pointer: %x\", to_uint(task));\n-//                    rtdebug!(\"current task heap pointer: %x\", to_uint(&task.heap));\n                     f(task)\n                 }\n                 None => {\n@@ -66,19 +89,18 @@ impl Local for Task {\n             }\n         }\n     }\n-    unsafe fn unsafe_borrow() -> *mut Task {\n-        match (*Local::unsafe_borrow::<Scheduler>()).current_task {\n-            Some(~ref mut task) => {\n-                let s: *mut Task = &mut *task;\n+    unsafe fn unsafe_borrow() -> *mut Scheduler {\n+        match (*Local::unsafe_borrow::<Task>()).sched {\n+            Some(~ref mut sched) => {\n+                let s: *mut Scheduler = &mut *sched;\n                 return s;\n             }\n             None => {\n-                // Don't fail. Infinite recursion\n                 rtabort!(\"no scheduler\")\n             }\n         }\n     }\n-    unsafe fn try_unsafe_borrow() -> Option<*mut Task> {\n+    unsafe fn try_unsafe_borrow() -> Option<*mut Scheduler> {\n         if Local::exists::<Scheduler>() {\n             Some(Local::unsafe_borrow())\n         } else {\n@@ -101,57 +123,67 @@ impl Local for IoFactoryObject {\n     unsafe fn try_unsafe_borrow() -> Option<*mut IoFactoryObject> { rtabort!(\"unimpl\") }\n }\n \n+\n #[cfg(test)]\n mod test {\n-    use unstable::run_in_bare_thread;\n     use rt::test::*;\n-    use rt::sched::Scheduler;\n     use super::*;\n+    use rt::task::Task;\n+    use rt::local_ptr;\n \n     #[test]\n-    fn thread_local_scheduler_smoke_test() {\n-        do run_in_bare_thread {\n-            let scheduler = ~new_test_uv_sched();\n-            Local::put(scheduler);\n-            let _scheduler: ~Scheduler = Local::take();\n-        }\n+    fn thread_local_task_smoke_test() {\n+        local_ptr::init_tls_key();\n+        let mut sched = ~new_test_uv_sched();\n+        let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+        Local::put(task);\n+        let task: ~Task = Local::take();\n+        cleanup_task(task);\n     }\n \n     #[test]\n-    fn thread_local_scheduler_two_instances() {\n-        do run_in_bare_thread {\n-            let scheduler = ~new_test_uv_sched();\n-            Local::put(scheduler);\n-            let _scheduler: ~Scheduler = Local::take();\n-            let scheduler = ~new_test_uv_sched();\n-            Local::put(scheduler);\n-            let _scheduler: ~Scheduler = Local::take();\n-        }\n+    fn thread_local_task_two_instances() {\n+        local_ptr::init_tls_key();\n+        let mut sched = ~new_test_uv_sched();\n+        let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+        Local::put(task);\n+        let task: ~Task = Local::take();\n+        cleanup_task(task);\n+        let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+        Local::put(task);\n+        let task: ~Task = Local::take();\n+        cleanup_task(task);\n+\n     }\n \n     #[test]\n     fn borrow_smoke_test() {\n-        do run_in_bare_thread {\n-            let scheduler = ~new_test_uv_sched();\n-            Local::put(scheduler);\n-            unsafe {\n-                let _scheduler: *mut Scheduler = Local::unsafe_borrow();\n-            }\n-            let _scheduler: ~Scheduler = Local::take();\n+        local_ptr::init_tls_key();\n+        let mut sched = ~new_test_uv_sched();\n+        let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+        Local::put(task);\n+\n+        unsafe {\n+            let _task: *mut Task = Local::unsafe_borrow();\n         }\n+        let task: ~Task = Local::take();\n+        cleanup_task(task);\n     }\n \n     #[test]\n     fn borrow_with_return() {\n-        do run_in_bare_thread {\n-            let scheduler = ~new_test_uv_sched();\n-            Local::put(scheduler);\n-            let res = do Local::borrow::<Scheduler,bool> |_sched| {\n-                true\n-            };\n-            assert!(res);\n-            let _scheduler: ~Scheduler = Local::take();\n-        }\n+        local_ptr::init_tls_key();\n+        let mut sched = ~new_test_uv_sched();\n+        let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+        Local::put(task);\n+\n+        let res = do Local::borrow::<Task,bool> |_task| {\n+            true\n+        };\n+        assert!(res)\n+        let task: ~Task = Local::take();\n+        cleanup_task(task);\n     }\n \n }\n+"}, {"sha": "f0f4b646103996fdfcbbb2c58e23c7657f0dd89a", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 72, "deletions": 60, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -67,9 +67,10 @@ use iter::Times;\n use iterator::{Iterator, IteratorUtil};\n use option::{Some, None};\n use ptr::RawPtr;\n+use rt::local::Local;\n use rt::sched::{Scheduler, Shutdown};\n use rt::sleeper_list::SleeperList;\n-use rt::task::{Task, Sched};\n+use rt::task::{Task, SchedTask, GreenTask, Sched};\n use rt::thread::Thread;\n use rt::work_queue::WorkQueue;\n use rt::uv::uvio::UvEventLoop;\n@@ -243,6 +244,8 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n \n     let nscheds = util::default_sched_threads();\n \n+    let main = Cell::new(main);\n+\n     // The shared list of sleeping schedulers. Schedulers wake each other\n     // occassionally to do new work.\n     let sleepers = SleeperList::new();\n@@ -256,6 +259,8 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n     let mut handles = ~[];\n \n     do nscheds.times {\n+        rtdebug!(\"inserting a regular scheduler\");\n+\n         // Every scheduler is driven by an I/O event loop.\n         let loop_ = ~UvEventLoop::new();\n         let mut sched = ~Scheduler::new(loop_, work_queue.clone(), sleepers.clone());\n@@ -267,12 +272,19 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n \n     // If we need a main-thread task then create a main thread scheduler\n     // that will reject any task that isn't pinned to it\n-    let mut main_sched = if use_main_sched {\n+    let main_sched = if use_main_sched {\n+\n+        // Create a friend handle.\n+        let mut friend_sched = scheds.pop();\n+        let friend_handle = friend_sched.make_handle();\n+        scheds.push(friend_sched);\n+\n         let main_loop = ~UvEventLoop::new();\n         let mut main_sched = ~Scheduler::new_special(main_loop,\n                                                      work_queue.clone(),\n                                                      sleepers.clone(),\n-                                                     false);\n+                                                     false,\n+                                                     Some(friend_handle));\n         let main_handle = main_sched.make_handle();\n         handles.push(main_handle);\n         Some(main_sched)\n@@ -309,44 +321,63 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n         }\n     };\n \n-    // Build the main task and queue it up\n-    match main_sched {\n-        None => {\n-            // The default case where we don't need a scheduler on the main thread.\n-            // Just put an unpinned task onto one of the default schedulers.\n-            let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool, main);\n-            main_task.death.on_exit = Some(on_exit);\n-            main_task.name = Some(~\"main\");\n-            scheds[0].enqueue_task(main_task);\n-        }\n-        Some(ref mut main_sched) => {\n-            let home = Sched(main_sched.make_handle());\n-            let mut main_task = ~Task::new_root_homed(&mut scheds[0].stack_pool, home, main);\n-            main_task.death.on_exit = Some(on_exit);\n-            main_task.name = Some(~\"main\");\n-            main_sched.enqueue_task(main_task);\n-        }\n-    };\n-\n-    // Run each scheduler in a thread.\n     let mut threads = ~[];\n-    while !scheds.is_empty() {\n+\n+    let on_exit = Cell::new(on_exit);\n+\n+    if !use_main_sched {\n+\n+        // In the case where we do not use a main_thread scheduler we\n+        // run the main task in one of our threads.\n+\n+        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n+                                            main.take());\n+        main_task.death.on_exit = Some(on_exit.take());\n+        let main_task_cell = Cell::new(main_task);\n+\n         let sched = scheds.pop();\n         let sched_cell = Cell::new(sched);\n         let thread = do Thread::start {\n             let sched = sched_cell.take();\n-            sched.run();\n+            sched.bootstrap(main_task_cell.take());\n         };\n+        threads.push(thread);\n+    }\n \n+    // Run each remaining scheduler in a thread.\n+    while !scheds.is_empty() {\n+        rtdebug!(\"creating regular schedulers\");\n+        let sched = scheds.pop();\n+        let sched_cell = Cell::new(sched);\n+        let thread = do Thread::start {\n+            let mut sched = sched_cell.take();\n+            let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool) || {\n+                rtdebug!(\"boostraping a non-primary scheduler\");\n+            };\n+            sched.bootstrap(bootstrap_task);\n+        };\n         threads.push(thread);\n     }\n \n-    // Run the main-thread scheduler\n-    match main_sched {\n-        Some(sched) => { let _ = sched.run(); },\n-        None => ()\n+    // If we do have a main thread scheduler, run it now.\n+\n+    if use_main_sched {\n+\n+        rtdebug!(\"about to create the main scheduler task\");\n+\n+        let mut main_sched = main_sched.get();\n+\n+        let home = Sched(main_sched.make_handle());\n+        let mut main_task = ~Task::new_root_homed(&mut main_sched.stack_pool,\n+                                                  home, main.take());\n+        main_task.death.on_exit = Some(on_exit.take());\n+        rtdebug!(\"boostrapping main_task\");\n+\n+        main_sched.bootstrap(main_task);\n     }\n \n+    rtdebug!(\"waiting for threads\");\n+\n     // Wait for schedulers\n     foreach thread in threads.consume_iter() {\n         thread.join();\n@@ -378,27 +409,22 @@ pub enum RuntimeContext {\n pub fn context() -> RuntimeContext {\n \n     use task::rt::rust_task;\n-    use self::local::Local;\n-    use self::sched::Scheduler;\n \n-    // XXX: Hitting TLS twice to check if the scheduler exists\n-    // then to check for the task is not good for perf\n     if unsafe { rust_try_get_task().is_not_null() } {\n         return OldTaskContext;\n-    } else {\n-        if Local::exists::<Scheduler>() {\n-            let context = Cell::new_empty();\n-            do Local::borrow::<Scheduler, ()> |sched| {\n-                if sched.in_task_context() {\n-                    context.put_back(TaskContext);\n-                } else {\n-                    context.put_back(SchedulerContext);\n-                }\n+    } else if Local::exists::<Task>() {\n+        // In this case we know it is a new runtime context, but we\n+        // need to check which one. Going to try borrowing task to\n+        // check. Task should always be in TLS, so hopefully this\n+        // doesn't conflict with other ops that borrow.\n+        return do Local::borrow::<Task,RuntimeContext> |task| {\n+            match task.task_type {\n+                SchedTask => SchedulerContext,\n+                GreenTask(_) => TaskContext\n             }\n-            return context.take();\n-        } else {\n-            return GlobalContext;\n-        }\n+        };\n+    } else {\n+        return GlobalContext;\n     }\n \n     extern {\n@@ -410,23 +436,9 @@ pub fn context() -> RuntimeContext {\n #[test]\n fn test_context() {\n     use unstable::run_in_bare_thread;\n-    use self::sched::{Scheduler};\n-    use rt::local::Local;\n-    use rt::test::new_test_uv_sched;\n \n     assert_eq!(context(), OldTaskContext);\n     do run_in_bare_thread {\n         assert_eq!(context(), GlobalContext);\n-        let mut sched = ~new_test_uv_sched();\n-        let task = ~do Task::new_root(&mut sched.stack_pool) {\n-            assert_eq!(context(), TaskContext);\n-            let sched = Local::take::<Scheduler>();\n-            do sched.deschedule_running_task_and_then() |sched, task| {\n-                assert_eq!(context(), SchedulerContext);\n-                sched.enqueue_blocked_task(task);\n-            }\n-        };\n-        sched.enqueue_task(task);\n-        sched.run();\n     }\n }"}, {"sha": "4abe69a7d134b821d660c6a31ecdf9d776504b22", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 507, "deletions": 588, "changes": 1095, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -10,7 +10,7 @@\n \n use either::{Left, Right};\n use option::{Option, Some, None};\n-use cast::transmute;\n+use cast::{transmute, transmute_mut_region, transmute_mut_unsafe};\n use clone::Clone;\n use unstable::raw;\n \n@@ -27,6 +27,7 @@ use rt::local::Local;\n use rt::rtio::RemoteCallback;\n use rt::metrics::SchedMetrics;\n use borrow::{to_uint};\n+use cell::Cell;\n \n /// The Scheduler is responsible for coordinating execution of Coroutines\n /// on a single thread. When the scheduler is running it is owned by\n@@ -59,17 +60,17 @@ pub struct Scheduler {\n     stack_pool: StackPool,\n     /// The event loop used to drive the scheduler and perform I/O\n     event_loop: ~EventLoopObject,\n-    /// The scheduler's saved context.\n-    /// Always valid when a task is executing, otherwise not\n-    priv saved_context: Context,\n-    /// The currently executing task\n-    current_task: Option<~Task>,\n+    /// The scheduler runs on a special task.\n+    sched_task: Option<~Task>,\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n     priv cleanup_job: Option<CleanupJob>,\n     metrics: SchedMetrics,\n     /// Should this scheduler run any task, or only pinned tasks?\n-    run_anything: bool\n+    run_anything: bool,\n+    /// If the scheduler shouldn't run some tasks, a friend to send\n+    /// them to.\n+    friend_handle: Option<SchedHandle>\n }\n \n pub struct SchedHandle {\n@@ -81,7 +82,8 @@ pub struct SchedHandle {\n pub enum SchedMessage {\n     Wake,\n     Shutdown,\n-    PinnedTask(~Task)\n+    PinnedTask(~Task),\n+    TaskFromFriend(~Task)\n }\n \n enum CleanupJob {\n@@ -90,7 +92,6 @@ enum CleanupJob {\n }\n \n impl Scheduler {\n-    pub fn in_task_context(&self) -> bool { self.current_task.is_some() }\n \n     pub fn sched_id(&self) -> uint { to_uint(self) }\n \n@@ -99,19 +100,19 @@ impl Scheduler {\n                sleeper_list: SleeperList)\n         -> Scheduler {\n \n-        Scheduler::new_special(event_loop, work_queue, sleeper_list, true)\n+        Scheduler::new_special(event_loop, work_queue, sleeper_list, true, None)\n \n     }\n \n+    // When you create a scheduler it isn't yet \"in\" a task, so the\n+    // task field is None.\n     pub fn new_special(event_loop: ~EventLoopObject,\n                        work_queue: WorkQueue<~Task>,\n                        sleeper_list: SleeperList,\n-                       run_anything: bool)\n+                       run_anything: bool,\n+                       friend: Option<SchedHandle>)\n         -> Scheduler {\n \n-        // Lazily initialize the runtime TLS key\n-        local_ptr::init_tls_key();\n-\n         Scheduler {\n             sleeper_list: sleeper_list,\n             message_queue: MessageQueue::new(),\n@@ -120,20 +121,57 @@ impl Scheduler {\n             event_loop: event_loop,\n             work_queue: work_queue,\n             stack_pool: StackPool::new(),\n-            saved_context: Context::empty(),\n-            current_task: None,\n+            sched_task: None,\n             cleanup_job: None,\n             metrics: SchedMetrics::new(),\n-            run_anything: run_anything\n+            run_anything: run_anything,\n+            friend_handle: friend\n         }\n     }\n \n     // XXX: This may eventually need to be refactored so that\n     // the scheduler itself doesn't have to call event_loop.run.\n     // That will be important for embedding the runtime into external\n     // event loops.\n-    pub fn run(~self) -> ~Scheduler {\n-        assert!(!self.in_task_context());\n+\n+    // Take a main task to run, and a scheduler to run it in. Create a\n+    // scheduler task and bootstrap into it.\n+    pub fn bootstrap(~self, task: ~Task) {\n+\n+        // Initialize the TLS key.\n+        local_ptr::init_tls_key();\n+\n+        // Create a task for the scheduler with an empty context.\n+        let sched_task = ~Task::new_sched_task();\n+\n+        // Now that we have an empty task struct for the scheduler\n+        // task, put it in TLS.\n+        Local::put::(sched_task);\n+\n+        // Now, as far as all the scheduler state is concerned, we are\n+        // inside the \"scheduler\" context. So we can act like the\n+        // scheduler and resume the provided task.\n+        self.resume_task_immediately(task);\n+\n+        // Now we are back in the scheduler context, having\n+        // successfully run the input task. Start by running the\n+        // scheduler. Grab it out of TLS - performing the scheduler\n+        // action will have given it away.\n+        let sched = Local::take::<Scheduler>();\n+        sched.run();\n+\n+        // Now that we are done with the scheduler, clean up the\n+        // scheduler task. Do so by removing it from TLS and manually\n+        // cleaning up the memory it uses. As we didn't actually call\n+        // task.run() on the scheduler task we never get through all\n+        // the cleanup code it runs.\n+        let mut stask = Local::take::<Task>();\n+        stask.destroyed = true;\n+    }\n+\n+    // This does not return a scheduler, as the scheduler is placed\n+    // inside the task.\n+    pub fn run(~self) {\n \n         let mut self_sched = self;\n \n@@ -142,79 +180,92 @@ impl Scheduler {\n         // schedulers.\n         self_sched.event_loop.callback(Scheduler::run_sched_once);\n \n+        // This is unsafe because we need to place the scheduler, with\n+        // the event_loop inside, inside our task. But we still need a\n+        // mutable reference to the event_loop to give it the \"run\"\n+        // command.\n         unsafe {\n-            let event_loop: *mut ~EventLoopObject = {\n-                let event_loop: *mut ~EventLoopObject = &mut self_sched.event_loop;\n-                event_loop\n-            };\n+            let event_loop: *mut ~EventLoopObject = &mut self_sched.event_loop;\n \n-            // Give ownership of the scheduler (self) to the thread\n-            Local::put(self_sched);\n+            // Our scheduler must be in the task before the event loop\n+            // is started.\n+            let self_sched = Cell::new(self_sched);\n+            do Local::borrow::<Task,()> |stask| {\n+                stask.sched = Some(self_sched.take());\n+            };\n \n             (*event_loop).run();\n         }\n-\n-        rtdebug!(\"run taking sched\");\n-        let sched = Local::take::<Scheduler>();\n-        // XXX: Reenable this once we're using a per-scheduler queue. With a shared\n-        // queue this is not true\n-        //assert!(sched.work_queue.is_empty());\n-        rtdebug!(\"scheduler metrics: %s\\n\", {\n-            use to_str::ToStr;\n-            sched.metrics.to_str()\n-        });\n-        return sched;\n     }\n \n-    fn run_sched_once() {\n+    // One iteration of the scheduler loop, always run at least once.\n \n-        let mut sched = Local::take::<Scheduler>();\n-        sched.metrics.turns += 1;\n-\n-        // First, check the message queue for instructions.\n-        // XXX: perf. Check for messages without atomics.\n-        // It's ok if we miss messages occasionally, as long as\n-        // we sync and check again before sleeping.\n-        if sched.interpret_message_queue() {\n-            // We performed a scheduling action. There may be other work\n-            // to do yet, so let's try again later.\n-            rtdebug!(\"run_sched_once, interpret_message_queue taking sched\");\n-            let mut sched = Local::take::<Scheduler>();\n-            sched.metrics.messages_received += 1;\n-            sched.event_loop.callback(Scheduler::run_sched_once);\n-            Local::put(sched);\n-            return;\n-        }\n+    // The model for this function is that you continue through it\n+    // until you either use the scheduler while performing a schedule\n+    // action, in which case you give it away and do not return, or\n+    // you reach the end and sleep. In the case that a scheduler\n+    // action is performed the loop is evented such that this function\n+    // is called again.\n+    fn run_sched_once() {\n \n-        // Now, look in the work queue for tasks to run\n-        rtdebug!(\"run_sched_once taking\");\n+        // When we reach the scheduler context via the event loop we\n+        // already have a scheduler stored in our local task, so we\n+        // start off by taking it. This is the only path through the\n+        // scheduler where we get the scheduler this way.\n         let sched = Local::take::<Scheduler>();\n-        if sched.resume_task_from_queue() {\n-            // We performed a scheduling action. There may be other work\n-            // to do yet, so let's try again later.\n-            do Local::borrow::<Scheduler, ()> |sched| {\n-                sched.metrics.tasks_resumed_from_queue += 1;\n-                sched.event_loop.callback(Scheduler::run_sched_once);\n+\n+        // Our first task is to read mail to see if we have important\n+        // messages.\n+\n+        // 1) A wake message is easy, mutate sched struct and return\n+        //    it.\n+        // 2) A shutdown is also easy, shutdown.\n+        // 3) A pinned task - we resume immediately and do not return\n+        //    here.\n+        // 4) A message from another scheduler with a non-homed task\n+        //    to run here.\n+\n+        let result = sched.interpret_message_queue();\n+        let sched = match result {\n+            Some(sched) => {\n+                // We did not resume a task, so we returned.\n+                sched\n             }\n-            return;\n-        }\n+            None => {\n+                return;\n+            }\n+        };\n+\n+        // Second activity is to try resuming a task from the queue.\n+\n+        let result = sched.resume_task_from_queue();\n+        let mut sched = match result {\n+            Some(sched) => {\n+                // Failed to dequeue a task, so we return.\n+                sched\n+            }\n+            None => {\n+                return;\n+            }\n+        };\n \n         // If we got here then there was no work to do.\n         // Generate a SchedHandle and push it to the sleeper list so\n         // somebody can wake us up later.\n-        rtdebug!(\"no work to do\");\n-        do Local::borrow::<Scheduler, ()> |sched| {\n-            sched.metrics.wasted_turns += 1;\n-            if !sched.sleepy && !sched.no_sleep {\n-                rtdebug!(\"sleeping\");\n-                sched.metrics.sleepy_times += 1;\n-                sched.sleepy = true;\n-                let handle = sched.make_handle();\n-                sched.sleeper_list.push(handle);\n-            } else {\n-                rtdebug!(\"not sleeping\");\n-            }\n+        sched.metrics.wasted_turns += 1;\n+        if !sched.sleepy && !sched.no_sleep {\n+            rtdebug!(\"scheduler has no work to do, going to sleep\");\n+            sched.metrics.sleepy_times += 1;\n+            sched.sleepy = true;\n+            let handle = sched.make_handle();\n+            sched.sleeper_list.push(handle);\n+        } else {\n+            rtdebug!(\"not sleeping, already doing so or no_sleep set\");\n         }\n+\n+        // Finished a cycle without using the Scheduler. Place it back\n+        // in TLS.\n+        Local::put(sched);\n     }\n \n     pub fn make_handle(&mut self) -> SchedHandle {\n@@ -234,18 +285,6 @@ impl Scheduler {\n     /// to the work queue directly.\n     pub fn enqueue_task(&mut self, task: ~Task) {\n \n-        // We don't want to queue tasks that belong on other threads,\n-        // so we send them home at enqueue time.\n-\n-        // The borrow checker doesn't like our disassembly of the\n-        // Coroutine struct and partial use and mutation of the\n-        // fields. So completely disassemble here and stop using?\n-\n-        // XXX perf: I think we might be able to shuffle this code to\n-        // only destruct when we need to.\n-\n-        rtdebug!(\"a task was queued on: %u\", self.sched_id());\n-\n         let this = self;\n \n         // We push the task onto our local queue clone.\n@@ -283,30 +322,26 @@ impl Scheduler {\n \n     // * Scheduler-context operations\n \n-    fn interpret_message_queue(~self) -> bool {\n-        assert!(!self.in_task_context());\n-\n-        rtdebug!(\"looking for scheduler messages\");\n+    // This function returns None if the scheduler is \"used\", or it\n+    // returns the still-available scheduler.\n+    fn interpret_message_queue(~self) -> Option<~Scheduler> {\n \n         let mut this = self;\n         match this.message_queue.pop() {\n             Some(PinnedTask(task)) => {\n-                rtdebug!(\"recv BiasedTask message in sched: %u\",\n-                         this.sched_id());\n                 let mut task = task;\n-                task.home = Some(Sched(this.make_handle()));\n+                task.give_home(Sched(this.make_handle()));\n                 this.resume_task_immediately(task);\n-                return true;\n+                return None;\n+            }\n+            Some(TaskFromFriend(task)) => {\n+                return this.sched_schedule_task(task);\n             }\n-\n             Some(Wake) => {\n-                rtdebug!(\"recv Wake message\");\n                 this.sleepy = false;\n-                Local::put(this);\n-                return true;\n+                return Some(this);\n             }\n             Some(Shutdown) => {\n-                rtdebug!(\"recv Shutdown message\");\n                 if this.sleepy {\n                     // There may be an outstanding handle on the\n                     // sleeper list.  Pop them all to make sure that's\n@@ -325,20 +360,22 @@ impl Scheduler {\n                 // event loop references we will shut down.\n                 this.no_sleep = true;\n                 this.sleepy = false;\n-                Local::put(this);\n-                return true;\n+                // YYY: Does a shutdown count as a \"use\" of the\n+                // scheduler? This seems to work - so I'm leaving it\n+                // this way despite not having a solid rational for\n+                // why I should return the scheduler here.\n+                return Some(this);\n             }\n             None => {\n-                Local::put(this);\n-                return false;\n+                return Some(this);\n             }\n         }\n     }\n \n     /// Given an input Coroutine sends it back to its home scheduler.\n     fn send_task_home(task: ~Task) {\n         let mut task = task;\n-        let mut home = task.home.take_unwrap();\n+        let mut home = task.take_unwrap_home();\n         match home {\n             Sched(ref mut home_handle) => {\n                 home_handle.send(PinnedTask(task));\n@@ -349,106 +386,87 @@ impl Scheduler {\n         }\n     }\n \n+    /// Take a non-homed task we aren't allowed to run here and send\n+    /// it to the designated friend scheduler to execute.\n+    fn send_to_friend(&mut self, task: ~Task) {\n+        match self.friend_handle {\n+            Some(ref mut handle) => {\n+                handle.send(TaskFromFriend(task));\n+            }\n+            None => {\n+                rtabort!(\"tried to send task to a friend but scheduler has no friends\");\n+            }\n+        }\n+    }\n+\n     // Resume a task from the queue - but also take into account that\n     // it might not belong here.\n-    fn resume_task_from_queue(~self) -> bool {\n-        assert!(!self.in_task_context());\n \n-        rtdebug!(\"looking in work queue for task to schedule\");\n+    // If we perform a scheduler action we give away the scheduler ~\n+    // pointer, if it is still available we return it.\n+\n+    fn resume_task_from_queue(~self) -> Option<~Scheduler> {\n+\n         let mut this = self;\n \n-        // The borrow checker imposes the possibly absurd requirement\n-        // that we split this into two match expressions. This is due\n-        // to the inspection of the internal bits of task, as that\n-        // can't be in scope when we act on task.\n         match this.work_queue.pop() {\n             Some(task) => {\n-                let action_id = {\n-                    let home = &task.home;\n-                    match home {\n-                        &Some(Sched(ref home_handle))\n-                        if home_handle.sched_id != this.sched_id() => {\n-                            SendHome\n-                        }\n-                        &Some(AnySched) if this.run_anything => {\n-                            ResumeNow\n-                        }\n-                        &Some(AnySched) => {\n-                            Requeue\n-                        }\n-                        &Some(Sched(_)) => {\n-                            ResumeNow\n-                        }\n-                        &None => {\n-                            Homeless\n+                let mut task = task;\n+                let home = task.take_unwrap_home();\n+                match home {\n+                    Sched(home_handle) => {\n+                        if home_handle.sched_id != this.sched_id() {\n+                            task.give_home(Sched(home_handle));\n+                            Scheduler::send_task_home(task);\n+                            return Some(this);\n+                        } else {\n+                            task.give_home(Sched(home_handle));\n+                            this.resume_task_immediately(task);\n+                            return None;\n                         }\n                     }\n-                };\n-\n-                match action_id {\n-                    SendHome => {\n-                        rtdebug!(\"sending task home\");\n-                        Scheduler::send_task_home(task);\n-                        Local::put(this);\n-                        return false;\n-                    }\n-                    ResumeNow => {\n-                        rtdebug!(\"resuming now\");\n+                    AnySched if this.run_anything => {\n+                        task.give_home(AnySched);\n                         this.resume_task_immediately(task);\n-                        return true;\n+                        return None;\n                     }\n-                    Requeue => {\n-                        rtdebug!(\"re-queueing\")\n-                        this.enqueue_task(task);\n-                        Local::put(this);\n-                        return false;\n-                    }\n-                    Homeless => {\n-                        rtabort!(\"task home was None!\");\n+                    AnySched => {\n+                        task.give_home(AnySched);\n+                        this.send_to_friend(task);\n+                        return Some(this);\n                     }\n                 }\n             }\n-\n             None => {\n-               rtdebug!(\"no tasks in queue\");\n-               Local::put(this);\n-               return false;\n-           }\n+                return Some(this);\n+            }\n         }\n     }\n \n-    // * Task-context operations\n-\n     /// Called by a running task to end execution, after which it will\n     /// be recycled by the scheduler for reuse in a new task.\n     pub fn terminate_current_task(~self) {\n+        // Similar to deschedule running task and then, but cannot go through\n+        // the task-blocking path. The task is already dying.\n         let mut this = self;\n-        assert!(this.in_task_context());\n-\n-        rtdebug!(\"ending running task\");\n-\n-        // This task is post-cleanup, so it must be unkillable. This sequence\n-        // of descheduling and recycling must not get interrupted by a kill.\n-        // FIXME(#7544): Make this use an inner descheduler, like yield should.\n-        this.current_task.get_mut_ref().death.unkillable += 1;\n-\n-        do this.deschedule_running_task_and_then |sched, dead_task| {\n-            match dead_task.wake() {\n-                Some(dead_task) => {\n-                    let mut dead_task = dead_task;\n-                    dead_task.death.unkillable -= 1; // FIXME(#7544) ugh\n-                    let coroutine = dead_task.coroutine.take_unwrap();\n-                    coroutine.recycle(&mut sched.stack_pool);\n-                }\n-                None => rtabort!(\"dead task killed before recycle\"),\n-            }\n+        let stask = this.sched_task.take_unwrap();\n+        do this.change_task_context(stask) |sched, mut dead_task| {\n+            let coroutine = dead_task.coroutine.take_unwrap();\n+            coroutine.recycle(&mut sched.stack_pool);\n         }\n-\n-        rtabort!(\"control reached end of task\");\n     }\n \n-    pub fn schedule_task(~self, task: ~Task) {\n-        assert!(self.in_task_context());\n+    // Scheduling a task requires a few checks to make sure the task\n+    // ends up in the appropriate location. The run_anything flag on\n+    // the scheduler and the home on the task need to be checked. This\n+    // helper performs that check. It takes a function that specifies\n+    // how to queue the the provided task if that is the correct\n+    // action. This is a \"core\" function that requires handling the\n+    // returned Option correctly.\n+\n+    pub fn schedule_task(~self, task: ~Task,\n+                         schedule_fn: ~fn(sched: ~Scheduler, task: ~Task))\n+        -> Option<~Scheduler> {\n \n         // is the task home?\n         let is_home = task.is_home_no_tls(&self);\n@@ -461,55 +479,131 @@ impl Scheduler {\n         if is_home || (!homed && this.run_anything) {\n             // here we know we are home, execute now OR we know we\n             // aren't homed, and that this sched doesn't care\n-            do this.switch_running_tasks_and_then(task) |sched, last_task| {\n-                sched.enqueue_blocked_task(last_task);\n-            }\n+            rtdebug!(\"task: %u is on ok sched, executing\", to_uint(task));\n+            schedule_fn(this, task);\n+            return None;\n         } else if !homed && !this.run_anything {\n             // the task isn't homed, but it can't be run here\n             this.enqueue_task(task);\n-            Local::put(this);\n+            return Some(this);\n         } else {\n             // task isn't home, so don't run it here, send it home\n             Scheduler::send_task_home(task);\n-            Local::put(this);\n+            return Some(this);\n         }\n     }\n \n-    // Core scheduling ops\n+    // There are two contexts in which schedule_task can be called:\n+    // inside the scheduler, and inside a task. These contexts handle\n+    // executing the task slightly differently. In the scheduler\n+    // context case we want to receive the scheduler as an input, and\n+    // manually deal with the option. In the task context case we want\n+    // to use TLS to find the scheduler, and deal with the option\n+    // inside the helper.\n+\n+    pub fn sched_schedule_task(~self, task: ~Task) -> Option<~Scheduler> {\n+        do self.schedule_task(task) |sched, next_task| {\n+            sched.resume_task_immediately(next_task);\n+        }\n+    }\n \n-    pub fn resume_task_immediately(~self, task: ~Task) {\n+    // Task context case - use TLS.\n+    pub fn run_task(task: ~Task) {\n+        let sched = Local::take::<Scheduler>();\n+        let opt = do sched.schedule_task(task) |sched, next_task| {\n+            do sched.switch_running_tasks_and_then(next_task) |sched, last_task| {\n+                sched.enqueue_blocked_task(last_task);\n+            }\n+        };\n+        opt.map_consume(Local::put);\n+    }\n+\n+    // The primary function for changing contexts. In the current\n+    // design the scheduler is just a slightly modified GreenTask, so\n+    // all context swaps are from Task to Task. The only difference\n+    // between the various cases is where the inputs come from, and\n+    // what is done with the resulting task. That is specified by the\n+    // cleanup function f, which takes the scheduler and the\n+    // old task as inputs.\n+\n+    pub fn change_task_context(~self,\n+                               next_task: ~Task,\n+                               f: &fn(&mut Scheduler, ~Task)) {\n         let mut this = self;\n-        assert!(!this.in_task_context());\n \n-        rtdebug!(\"scheduling a task\");\n-        this.metrics.context_switches_sched_to_task += 1;\n+        // The current task is grabbed from TLS, not taken as an input.\n+        let current_task: ~Task = Local::take::<Task>();\n+\n+        // These transmutes do something fishy with a closure.\n+        let f_fake_region = unsafe {\n+            transmute::<&fn(&mut Scheduler, ~Task),\n+                        &fn(&mut Scheduler, ~Task)>(f)\n+        };\n+        let f_opaque = ClosureConverter::from_fn(f_fake_region);\n \n-        // Store the task in the scheduler so it can be grabbed later\n-        this.current_task = Some(task);\n-        this.enqueue_cleanup_job(DoNothing);\n+        // The current task is placed inside an enum with the cleanup\n+        // function. This enum is then placed inside the scheduler.\n+        this.enqueue_cleanup_job(GiveTask(current_task, f_opaque));\n \n-        Local::put(this);\n+        // The scheduler is then placed inside the next task.\n+        let mut next_task = next_task;\n+        next_task.sched = Some(this);\n \n-        // Take pointers to both the task and scheduler's saved registers.\n+        // However we still need an internal mutable pointer to the\n+        // original task. The strategy here was \"arrange memory, then\n+        // get pointers\", so we crawl back up the chain using\n+        // transmute to eliminate borrowck errors.\n         unsafe {\n-            let sched = Local::unsafe_borrow::<Scheduler>();\n-            let (sched_context, _, next_task_context) = (*sched).get_contexts();\n-            let next_task_context = next_task_context.unwrap();\n-            // Context switch to the task, restoring it's registers\n-            // and saving the scheduler's\n-            Context::swap(sched_context, next_task_context);\n \n-            let sched = Local::unsafe_borrow::<Scheduler>();\n-            // The running task should have passed ownership elsewhere\n-            assert!((*sched).current_task.is_none());\n+            let sched: &mut Scheduler =\n+                transmute_mut_region(*next_task.sched.get_mut_ref());\n+\n+            let current_task: &mut Task = match sched.cleanup_job {\n+                Some(GiveTask(ref task, _)) => {\n+                    transmute_mut_region(*transmute_mut_unsafe(task))\n+                }\n+                Some(DoNothing) => {\n+                    rtabort!(\"no next task\");\n+                }\n+                None => {\n+                    rtabort!(\"no cleanup job\");\n+                }\n+            };\n+\n+            let (current_task_context, next_task_context) =\n+                Scheduler::get_contexts(current_task, next_task);\n \n-            // Running tasks may have asked us to do some cleanup\n+            // Done with everything - put the next task in TLS. This\n+            // works because due to transmute the borrow checker\n+            // believes that we have no internal pointers to\n+            // next_task.\n+            Local::put(next_task);\n+\n+            // The raw context swap operation. The next action taken\n+            // will be running the cleanup job from the context of the\n+            // next task.\n+            Context::swap(current_task_context, next_task_context);\n+        }\n+\n+        // When the context swaps back to this task we immediately\n+        // run the cleanup job, as expected by the previously called\n+        // swap_contexts function.\n+        unsafe {\n+            let sched = Local::unsafe_borrow::<Scheduler>();\n             (*sched).run_cleanup_job();\n \n             // Must happen after running the cleanup job (of course).\n-            // Might not be running in task context; if not, a later call to\n-            // resume_task_immediately will take care of this.\n-            (*sched).current_task.map(|t| t.death.check_killed());\n+            let task = Local::unsafe_borrow::<Task>();\n+            (*task).death.check_killed();\n+        }\n+    }\n+\n+    // Old API for task manipulation implemented over the new core\n+    // function.\n+\n+    pub fn resume_task_immediately(~self, task: ~Task) {\n+        do self.change_task_context(task) |sched, stask| {\n+            sched.sched_task = Some(stask);\n         }\n     }\n \n@@ -533,152 +627,69 @@ impl Scheduler {\n     /// in order to prevent that fn from performing further scheduling operations.\n     /// Doing further scheduling could easily result in infinite recursion.\n     pub fn deschedule_running_task_and_then(~self, f: &fn(&mut Scheduler, BlockedTask)) {\n+        // Trickier - we need to get the scheduler task out of self\n+        // and use it as the destination.\n         let mut this = self;\n-        assert!(this.in_task_context());\n-\n-        rtdebug!(\"blocking task\");\n-        this.metrics.context_switches_task_to_sched += 1;\n-\n-        unsafe {\n-            let blocked_task = this.current_task.take_unwrap();\n-            let f_fake_region = transmute::<&fn(&mut Scheduler, BlockedTask),\n-                                            &fn(&mut Scheduler, BlockedTask)>(f);\n-            let f_opaque = ClosureConverter::from_fn(f_fake_region);\n-            this.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n-        }\n-\n-        Local::put(this);\n-\n-        unsafe {\n-            let sched = Local::unsafe_borrow::<Scheduler>();\n-            let (sched_context, last_task_context, _) = (*sched).get_contexts();\n-            let last_task_context = last_task_context.unwrap();\n-            Context::swap(last_task_context, sched_context);\n-\n-            // We could be executing in a different thread now\n-            let sched = Local::unsafe_borrow::<Scheduler>();\n-            (*sched).run_cleanup_job();\n-\n-            // As above, must happen after running the cleanup job.\n-            (*sched).current_task.map(|t| t.death.check_killed());\n-        }\n+        let stask = this.sched_task.take_unwrap();\n+        // Otherwise this is the same as below.\n+        this.switch_running_tasks_and_then(stask, f);\n     }\n \n-    /// Switch directly to another task, without going through the scheduler.\n-    /// You would want to think hard about doing this, e.g. if there are\n-    /// pending I/O events it would be a bad idea.\n     pub fn switch_running_tasks_and_then(~self, next_task: ~Task,\n                                          f: &fn(&mut Scheduler, BlockedTask)) {\n-        let mut this = self;\n-        assert!(this.in_task_context());\n-\n-        rtdebug!(\"switching tasks\");\n-        this.metrics.context_switches_task_to_task += 1;\n+        // This is where we convert the BlockedTask-taking closure into one\n+        // that takes just a Task, and is aware of the block-or-killed protocol.\n+        do self.change_task_context(next_task) |sched, task| {\n+            // Task might need to receive a kill signal instead of blocking.\n+            // We can call the \"and_then\" only if it blocks successfully.\n+            match BlockedTask::try_block(task) {\n+                Left(killed_task) => sched.enqueue_task(killed_task),\n+                Right(blocked_task) => f(sched, blocked_task),\n+            }\n+        }\n+    }\n \n-        let old_running_task = this.current_task.take_unwrap();\n-        let f_fake_region = unsafe {\n-            transmute::<&fn(&mut Scheduler, BlockedTask),\n-                        &fn(&mut Scheduler, BlockedTask)>(f)\n+    // A helper that looks up the scheduler and runs a task later by\n+    // enqueuing it.\n+    pub fn run_task_later(next_task: ~Task) {\n+        // We aren't performing a scheduler operation, so we want to\n+        // put the Scheduler back when we finish.\n+        let next_task = Cell::new(next_task);\n+        do Local::borrow::<Scheduler,()> |sched| {\n+            sched.enqueue_task(next_task.take());\n         };\n-        let f_opaque = ClosureConverter::from_fn(f_fake_region);\n-        this.enqueue_cleanup_job(GiveTask(old_running_task, f_opaque));\n-        this.current_task = Some(next_task);\n-\n-        Local::put(this);\n+    }\n \n+    // Returns a mutable reference to both contexts involved in this\n+    // swap. This is unsafe - we are getting mutable internal\n+    // references to keep even when we don't own the tasks. It looks\n+    // kinda safe because we are doing transmutes before passing in\n+    // the arguments.\n+    pub fn get_contexts<'a>(current_task: &mut Task, next_task: &mut Task) ->\n+        (&'a mut Context, &'a mut Context) {\n+        let current_task_context =\n+            &mut current_task.coroutine.get_mut_ref().saved_context;\n+        let next_task_context =\n+            &mut next_task.coroutine.get_mut_ref().saved_context;\n         unsafe {\n-            let sched = Local::unsafe_borrow::<Scheduler>();\n-            let (_, last_task_context, next_task_context) = (*sched).get_contexts();\n-            let last_task_context = last_task_context.unwrap();\n-            let next_task_context = next_task_context.unwrap();\n-            Context::swap(last_task_context, next_task_context);\n-\n-            // We could be executing in a different thread now\n-            let sched = Local::unsafe_borrow::<Scheduler>();\n-            (*sched).run_cleanup_job();\n-\n-            // As above, must happen after running the cleanup job.\n-            (*sched).current_task.map(|t| t.death.check_killed());\n+            (transmute_mut_region(current_task_context),\n+             transmute_mut_region(next_task_context))\n         }\n     }\n \n-\n-\n-    // * Other stuff\n-\n     pub fn enqueue_cleanup_job(&mut self, job: CleanupJob) {\n-        assert!(self.cleanup_job.is_none());\n         self.cleanup_job = Some(job);\n     }\n \n     pub fn run_cleanup_job(&mut self) {\n         rtdebug!(\"running cleanup job\");\n-\n-        assert!(self.cleanup_job.is_some());\n-\n         let cleanup_job = self.cleanup_job.take_unwrap();\n         match cleanup_job {\n             DoNothing => { }\n-            GiveTask(task, f) => {\n-                let f = f.to_fn();\n-                // Task might need to receive a kill signal instead of blocking.\n-                // We can call the \"and_then\" only if it blocks successfully.\n-                match BlockedTask::try_block(task) {\n-                    Left(killed_task) => self.enqueue_task(killed_task),\n-                    Right(blocked_task) => f(self, blocked_task),\n-                }\n-            }\n+            GiveTask(task, f) => f.to_fn()(self, task)\n         }\n     }\n \n-    /// Get mutable references to all the contexts that may be involved in a\n-    /// context switch.\n-    ///\n-    /// Returns (the scheduler context, the optional context of the\n-    /// task in the cleanup list, the optional context of the task in\n-    /// the current task slot).  When context switching to a task,\n-    /// callers should first arrange for that task to be located in the\n-    /// Scheduler's current_task slot and set up the\n-    /// post-context-switch cleanup job.\n-    pub fn get_contexts<'a>(&'a mut self) -> (&'a mut Context,\n-                                              Option<&'a mut Context>,\n-                                              Option<&'a mut Context>) {\n-        let last_task = match self.cleanup_job {\n-            Some(GiveTask(~ref task, _)) => {\n-                Some(task)\n-            }\n-            Some(DoNothing) => {\n-                None\n-            }\n-            None => fail!(\"all context switches should have a cleanup job\")\n-        };\n-        // XXX: Pattern matching mutable pointers above doesn't work\n-        // because borrowck thinks the three patterns are conflicting\n-        // borrows\n-        unsafe {\n-            let last_task = transmute::<Option<&Task>, Option<&mut Task>>(last_task);\n-            let last_task_context = match last_task {\n-                Some(t) => {\n-                    Some(&mut t.coroutine.get_mut_ref().saved_context)\n-                }\n-                None => {\n-                    None\n-                }\n-            };\n-            let next_task_context = match self.current_task {\n-                Some(ref mut t) => {\n-                    Some(&mut t.coroutine.get_mut_ref().saved_context)\n-                }\n-                None => {\n-                    None\n-                }\n-            };\n-            // XXX: These transmutes can be removed after snapshot\n-            return (transmute(&mut self.saved_context),\n-                    last_task_context,\n-                    transmute(next_task_context));\n-        }\n-    }\n }\n \n // The cases for the below function.\n@@ -700,29 +711,73 @@ impl SchedHandle {\n // complaining\n type UnsafeTaskReceiver = raw::Closure;\n trait ClosureConverter {\n-    fn from_fn(&fn(&mut Scheduler, BlockedTask)) -> Self;\n-    fn to_fn(self) -> &fn(&mut Scheduler, BlockedTask);\n+    fn from_fn(&fn(&mut Scheduler, ~Task)) -> Self;\n+    fn to_fn(self) -> &fn(&mut Scheduler, ~Task);\n }\n impl ClosureConverter for UnsafeTaskReceiver {\n-    fn from_fn(f: &fn(&mut Scheduler, BlockedTask)) -> UnsafeTaskReceiver {\n+    fn from_fn(f: &fn(&mut Scheduler, ~Task)) -> UnsafeTaskReceiver {\n         unsafe { transmute(f) }\n     }\n-    fn to_fn(self) -> &fn(&mut Scheduler, BlockedTask) { unsafe { transmute(self) } }\n+    fn to_fn(self) -> &fn(&mut Scheduler, ~Task) { unsafe { transmute(self) } }\n }\n \n-\n #[cfg(test)]\n mod test {\n+    use rt::test::*;\n+    use unstable::run_in_bare_thread;\n+    use borrow::to_uint;\n+    use rt::local::*;\n+    use rt::sched::{Scheduler};\n+    use uint;\n     use int;\n     use cell::Cell;\n-    use unstable::run_in_bare_thread;\n-    use task::spawn;\n-    use rt::local::Local;\n-    use rt::test::*;\n-    use super::*;\n     use rt::thread::Thread;\n-    use borrow::to_uint;\n-    use rt::task::{Task,Sched};\n+    use rt::task::{Task, Sched};\n+    use option::{Some};\n+\n+    #[test]\n+    fn trivial_run_in_newsched_task_test() {\n+        let mut task_ran = false;\n+        let task_ran_ptr: *mut bool = &mut task_ran;\n+        do run_in_newsched_task || {\n+            unsafe { *task_ran_ptr = true };\n+            rtdebug!(\"executed from the new scheduler\")\n+        }\n+        assert!(task_ran);\n+    }\n+\n+    #[test]\n+    fn multiple_task_test() {\n+        let total = 10;\n+        let mut task_run_count = 0;\n+        let task_run_count_ptr: *mut uint = &mut task_run_count;\n+        do run_in_newsched_task || {\n+            for uint::range(0,total) |_| {\n+                do spawntask || {\n+                    unsafe { *task_run_count_ptr = *task_run_count_ptr + 1};\n+                }\n+            }\n+        }\n+        assert!(task_run_count == total);\n+    }\n+\n+    #[test]\n+    fn multiple_task_nested_test() {\n+        let mut task_run_count = 0;\n+        let task_run_count_ptr: *mut uint = &mut task_run_count;\n+        do run_in_newsched_task || {\n+            do spawntask || {\n+                unsafe { *task_run_count_ptr = *task_run_count_ptr + 1 };\n+                do spawntask || {\n+                    unsafe { *task_run_count_ptr = *task_run_count_ptr + 1 };\n+                    do spawntask || {\n+                        unsafe { *task_run_count_ptr = *task_run_count_ptr + 1 };\n+                    }\n+                }\n+            }\n+        }\n+        assert!(task_run_count == 3);\n+    }\n \n     // Confirm that a sched_id actually is the uint form of the\n     // pointer to the scheduler struct.\n@@ -745,168 +800,154 @@ mod test {\n         }\n     }\n \n-    // A simple test to check if a homed task run on a single\n-    // scheduler ends up executing while home.\n+\n+    // A very simple test that confirms that a task executing on the\n+    // home scheduler notices that it is home.\n     #[test]\n     fn test_home_sched() {\n         do run_in_bare_thread {\n             let mut task_ran = false;\n             let task_ran_ptr: *mut bool = &mut task_ran;\n-            let mut sched = ~new_test_uv_sched();\n \n+            let mut sched = ~new_test_uv_sched();\n             let sched_handle = sched.make_handle();\n-            let sched_id = sched.sched_id();\n \n-            let task = ~do Task::new_root_homed(&mut sched.stack_pool,\n-                                                 Sched(sched_handle)) {\n+            let mut task = ~do Task::new_root_homed(&mut sched.stack_pool,\n+                                                Sched(sched_handle)) {\n                 unsafe { *task_ran_ptr = true };\n-                let sched = Local::take::<Scheduler>();\n-                assert!(sched.sched_id() == sched_id);\n-                Local::put::<Scheduler>(sched);\n+                assert!(Task::on_appropriate_sched());\n             };\n-            sched.enqueue_task(task);\n-            sched.run();\n-            assert!(task_ran);\n+\n+            let on_exit: ~fn(bool) = |exit_status| rtassert!(exit_status);\n+            task.death.on_exit = Some(on_exit);\n+\n+            sched.bootstrap(task);\n         }\n     }\n \n-    // A test for each state of schedule_task\n+    // An advanced test that checks all four possible states that a\n+    // (task,sched) can be in regarding homes.\n+\n     #[test]\n     fn test_schedule_home_states() {\n \n         use rt::uv::uvio::UvEventLoop;\n-        use rt::sched::Shutdown;\n         use rt::sleeper_list::SleeperList;\n         use rt::work_queue::WorkQueue;\n+        use rt::sched::Shutdown;\n+        use borrow;\n+        use rt::comm::*;\n \n         do run_in_bare_thread {\n \n             let sleepers = SleeperList::new();\n             let work_queue = WorkQueue::new();\n \n-            // our normal scheduler\n+            // Our normal scheduler\n             let mut normal_sched = ~Scheduler::new(\n                 ~UvEventLoop::new(),\n                 work_queue.clone(),\n                 sleepers.clone());\n \n             let normal_handle = Cell::new(normal_sched.make_handle());\n \n-            // our special scheduler\n+            let friend_handle = normal_sched.make_handle();\n+\n+            // Our special scheduler\n             let mut special_sched = ~Scheduler::new_special(\n                 ~UvEventLoop::new(),\n                 work_queue.clone(),\n                 sleepers.clone(),\n-                true);\n+                false,\n+                Some(friend_handle));\n \n             let special_handle = Cell::new(special_sched.make_handle());\n-            let special_handle2 = Cell::new(special_sched.make_handle());\n-            let special_id = special_sched.sched_id();\n+\n             let t1_handle = special_sched.make_handle();\n             let t4_handle = special_sched.make_handle();\n \n-            let t1f = ~do Task::new_root_homed(&mut special_sched.stack_pool,\n-                                               Sched(t1_handle)) || {\n-                let is_home = Task::is_home_using_id(special_id);\n-                rtdebug!(\"t1 should be home: %b\", is_home);\n-                assert!(is_home);\n-            };\n-            let t1f = Cell::new(t1f);\n+            // Four test tasks:\n+            //   1) task is home on special\n+            //   2) task not homed, sched doesn't care\n+            //   3) task not homed, sched requeues\n+            //   4) task not home, send home\n \n-            let t2f = ~do Task::new_root(&mut normal_sched.stack_pool) {\n-                let on_special = Task::on_special();\n-                rtdebug!(\"t2 should not be on special: %b\", on_special);\n-                assert!(!on_special);\n+            let task1 = ~do Task::new_root_homed(&mut special_sched.stack_pool,\n+                                                 Sched(t1_handle)) || {\n+                rtassert!(Task::on_appropriate_sched());\n             };\n-            let t2f = Cell::new(t2f);\n+            rtdebug!(\"task1 id: **%u**\", borrow::to_uint(task1));\n \n-            let t3f = ~do Task::new_root(&mut normal_sched.stack_pool) {\n-                // not on special\n-                let on_special = Task::on_special();\n-                rtdebug!(\"t3 should not be on special: %b\", on_special);\n-                assert!(!on_special);\n-            };\n-            let t3f = Cell::new(t3f);\n-\n-            let t4f = ~do Task::new_root_homed(&mut special_sched.stack_pool,\n-                                          Sched(t4_handle)) {\n-                // is home\n-                let home = Task::is_home_using_id(special_id);\n-                rtdebug!(\"t4 should be home: %b\", home);\n-                assert!(home);\n+            let task2 = ~do Task::new_root(&mut normal_sched.stack_pool) {\n+                rtassert!(Task::on_appropriate_sched());\n             };\n-            let t4f = Cell::new(t4f);\n \n-            // we have four tests, make them as closures\n-            let t1: ~fn() = || {\n-                // task is home on special\n-                let task = t1f.take();\n-                let sched = Local::take::<Scheduler>();\n-                sched.schedule_task(task);\n-            };\n-            let t2: ~fn() = || {\n-                // not homed, task doesn't care\n-                let task = t2f.take();\n-                let sched = Local::take::<Scheduler>();\n-                sched.schedule_task(task);\n-            };\n-            let t3: ~fn() = || {\n-                // task not homed, must leave\n-                let task = t3f.take();\n-                let sched = Local::take::<Scheduler>();\n-                sched.schedule_task(task);\n+            let task3 = ~do Task::new_root(&mut normal_sched.stack_pool) {\n+                rtassert!(Task::on_appropriate_sched());\n             };\n-            let t4: ~fn() = || {\n-                // task not home, send home\n-                let task = t4f.take();\n-                let sched = Local::take::<Scheduler>();\n-                sched.schedule_task(task);\n+\n+            let task4 = ~do Task::new_root_homed(&mut special_sched.stack_pool,\n+                                                 Sched(t4_handle)) {\n+                rtassert!(Task::on_appropriate_sched());\n             };\n+            rtdebug!(\"task4 id: **%u**\", borrow::to_uint(task4));\n+\n+            let task1 = Cell::new(task1);\n+            let task2 = Cell::new(task2);\n+            let task3 = Cell::new(task3);\n+            let task4 = Cell::new(task4);\n \n-            let t1 = Cell::new(t1);\n-            let t2 = Cell::new(t2);\n-            let t3 = Cell::new(t3);\n-            let t4 = Cell::new(t4);\n-\n-            // build a main task that runs our four tests\n-            let main_task = ~do Task::new_root(&mut normal_sched.stack_pool) {\n-                // the two tasks that require a normal start location\n-                t2.take()();\n-                t4.take()();\n-                normal_handle.take().send(Shutdown);\n-                special_handle.take().send(Shutdown);\n+            // Signal from the special task that we are done.\n+            let (port, chan) = oneshot::<()>();\n+            let port = Cell::new(port);\n+            let chan = Cell::new(chan);\n+\n+            let normal_task = ~do Task::new_root(&mut normal_sched.stack_pool) {\n+                rtdebug!(\"*about to submit task2*\");\n+                Scheduler::run_task(task2.take());\n+                rtdebug!(\"*about to submit task4*\");\n+                Scheduler::run_task(task4.take());\n+                rtdebug!(\"*normal_task done*\");\n+                port.take().recv();\n+                let mut nh = normal_handle.take();\n+                nh.send(Shutdown);\n+                let mut sh = special_handle.take();\n+                sh.send(Shutdown);\n             };\n \n-            // task to run the two \"special start\" tests\n-            let special_task = ~do Task::new_root_homed(\n-                &mut special_sched.stack_pool,\n-                Sched(special_handle2.take())) {\n-                t1.take()();\n-                t3.take()();\n+            rtdebug!(\"normal task: %u\", borrow::to_uint(normal_task));\n+\n+            let special_task = ~do Task::new_root(&mut special_sched.stack_pool) {\n+                rtdebug!(\"*about to submit task1*\");\n+                Scheduler::run_task(task1.take());\n+                rtdebug!(\"*about to submit task3*\");\n+                Scheduler::run_task(task3.take());\n+                rtdebug!(\"*done with special_task*\");\n+                chan.take().send(());\n             };\n \n-            // enqueue the main tasks\n-            normal_sched.enqueue_task(special_task);\n-            normal_sched.enqueue_task(main_task);\n+            rtdebug!(\"special task: %u\", borrow::to_uint(special_task));\n+\n+            let special_sched = Cell::new(special_sched);\n+            let normal_sched = Cell::new(normal_sched);\n+            let special_task = Cell::new(special_task);\n+            let normal_task = Cell::new(normal_task);\n \n-            let nsched_cell = Cell::new(normal_sched);\n             let normal_thread = do Thread::start {\n-                let sched = nsched_cell.take();\n-                sched.run();\n+                normal_sched.take().bootstrap(normal_task.take());\n+                rtdebug!(\"finished with normal_thread\");\n             };\n \n-            let ssched_cell = Cell::new(special_sched);\n             let special_thread = do Thread::start {\n-                let sched = ssched_cell.take();\n-                sched.run();\n+                special_sched.take().bootstrap(special_task.take());\n+                rtdebug!(\"finished with special_sched\");\n             };\n \n             normal_thread.join();\n             special_thread.join();\n         }\n     }\n \n-    // Do it a lot\n     #[test]\n     fn test_stress_schedule_task_states() {\n         let n = stress_factor() * 120;\n@@ -915,124 +956,14 @@ mod test {\n         }\n     }\n \n-    #[test]\n-    fn test_simple_scheduling() {\n-        do run_in_bare_thread {\n-            let mut task_ran = false;\n-            let task_ran_ptr: *mut bool = &mut task_ran;\n-\n-            let mut sched = ~new_test_uv_sched();\n-            let task = ~do Task::new_root(&mut sched.stack_pool) {\n-                unsafe { *task_ran_ptr = true; }\n-            };\n-            sched.enqueue_task(task);\n-            sched.run();\n-            assert!(task_ran);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_several_tasks() {\n-        do run_in_bare_thread {\n-            let total = 10;\n-            let mut task_count = 0;\n-            let task_count_ptr: *mut int = &mut task_count;\n-\n-            let mut sched = ~new_test_uv_sched();\n-            for int::range(0, total) |_| {\n-                let task = ~do Task::new_root(&mut sched.stack_pool) {\n-                    unsafe { *task_count_ptr = *task_count_ptr + 1; }\n-                };\n-                sched.enqueue_task(task);\n-            }\n-            sched.run();\n-            assert_eq!(task_count, total);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_swap_tasks_then() {\n-        do run_in_bare_thread {\n-            let mut count = 0;\n-            let count_ptr: *mut int = &mut count;\n-\n-            let mut sched = ~new_test_uv_sched();\n-            let task1 = ~do Task::new_root(&mut sched.stack_pool) {\n-                unsafe { *count_ptr = *count_ptr + 1; }\n-                let mut sched = Local::take::<Scheduler>();\n-                let task2 = ~do Task::new_root(&mut sched.stack_pool) {\n-                    unsafe { *count_ptr = *count_ptr + 1; }\n-                };\n-                // Context switch directly to the new task\n-                do sched.switch_running_tasks_and_then(task2) |sched, task1| {\n-                    sched.enqueue_blocked_task(task1);\n-                }\n-                unsafe { *count_ptr = *count_ptr + 1; }\n-            };\n-            sched.enqueue_task(task1);\n-            sched.run();\n-            assert_eq!(count, 3);\n-        }\n-    }\n-\n-    #[bench] #[test] #[ignore(reason = \"long test\")]\n-    fn test_run_a_lot_of_tasks_queued() {\n-        do run_in_bare_thread {\n-            static MAX: int = 1000000;\n-            let mut count = 0;\n-            let count_ptr: *mut int = &mut count;\n-\n-            let mut sched = ~new_test_uv_sched();\n-\n-            let start_task = ~do Task::new_root(&mut sched.stack_pool) {\n-                run_task(count_ptr);\n-            };\n-            sched.enqueue_task(start_task);\n-            sched.run();\n-\n-            assert_eq!(count, MAX);\n-\n-            fn run_task(count_ptr: *mut int) {\n-                do Local::borrow::<Scheduler, ()> |sched| {\n-                    let task = ~do Task::new_root(&mut sched.stack_pool) {\n-                        unsafe {\n-                            *count_ptr = *count_ptr + 1;\n-                            if *count_ptr != MAX {\n-                                run_task(count_ptr);\n-                            }\n-                        }\n-                    };\n-                    sched.enqueue_task(task);\n-                }\n-            };\n-        }\n-    }\n-\n-    #[test]\n-    fn test_block_task() {\n-        do run_in_bare_thread {\n-            let mut sched = ~new_test_uv_sched();\n-            let task = ~do Task::new_root(&mut sched.stack_pool) {\n-                let sched = Local::take::<Scheduler>();\n-                assert!(sched.in_task_context());\n-                do sched.deschedule_running_task_and_then() |sched, task| {\n-                    assert!(!sched.in_task_context());\n-                    sched.enqueue_blocked_task(task);\n-                }\n-            };\n-            sched.enqueue_task(task);\n-            sched.run();\n-        }\n-    }\n-\n     #[test]\n     fn test_io_callback() {\n         // This is a regression test that when there are no schedulable tasks\n         // in the work queue, but we are performing I/O, that once we do put\n         // something in the work queue again the scheduler picks it up and doesn't\n         // exit before emptying the work queue\n         do run_in_newsched_task {\n-            do spawn {\n+            do spawntask {\n                 let sched = Local::take::<Scheduler>();\n                 do sched.deschedule_running_task_and_then |sched, task| {\n                     let task = Cell::new(task);\n@@ -1053,38 +984,25 @@ mod test {\n \n         do run_in_bare_thread {\n             let (port, chan) = oneshot::<()>();\n-            let port_cell = Cell::new(port);\n-            let chan_cell = Cell::new(chan);\n-            let mut sched1 = ~new_test_uv_sched();\n-            let handle1 = sched1.make_handle();\n-            let handle1_cell = Cell::new(handle1);\n-            let task1 = ~do Task::new_root(&mut sched1.stack_pool) {\n-                chan_cell.take().send(());\n-            };\n-            sched1.enqueue_task(task1);\n-\n-            let mut sched2 = ~new_test_uv_sched();\n-            let task2 = ~do Task::new_root(&mut sched2.stack_pool) {\n-                port_cell.take().recv();\n-                // Release the other scheduler's handle so it can exit\n-                handle1_cell.take();\n-            };\n-            sched2.enqueue_task(task2);\n+            let port = Cell::new(port);\n+            let chan = Cell::new(chan);\n \n-            let sched1_cell = Cell::new(sched1);\n-            let thread1 = do Thread::start {\n-                let sched1 = sched1_cell.take();\n-                sched1.run();\n+            let thread_one = do Thread::start {\n+                let chan = Cell::new(chan.take());\n+                do run_in_newsched_task_core {\n+                    chan.take().send(());\n+                }\n             };\n \n-            let sched2_cell = Cell::new(sched2);\n-            let thread2 = do Thread::start {\n-                let sched2 = sched2_cell.take();\n-                sched2.run();\n+            let thread_two = do Thread::start {\n+                let port = Cell::new(port.take());\n+                do run_in_newsched_task_core {\n+                    port.take().recv();\n+                }\n             };\n \n-            thread1.join();\n-            thread2.join();\n+            thread_two.join();\n+            thread_one.join();\n         }\n     }\n \n@@ -1112,21 +1030,21 @@ mod test {\n         }\n     }\n \n-    #[test]\n+     #[test]\n     fn thread_ring() {\n         use rt::comm::*;\n         use comm::{GenericPort, GenericChan};\n \n         do run_in_mt_newsched_task {\n-            let (end_port, end_chan) = oneshot();\n+                let (end_port, end_chan) = oneshot();\n \n             let n_tasks = 10;\n             let token = 2000;\n \n-            let (p, ch1) = stream();\n+                let (p, ch1) = stream();\n             let mut p = p;\n-            ch1.send((token, end_chan));\n-            let mut i = 2;\n+                ch1.send((token, end_chan));\n+                let mut i = 2;\n             while i <= n_tasks {\n                 let (next_p, ch) = stream();\n                 let imm_i = i;\n@@ -1151,9 +1069,9 @@ mod test {\n             while (true) {\n                 match p.recv() {\n                     (1, end_chan) => {\n-                        debug!(\"%d\\n\", id);\n-                        end_chan.send(());\n-                        return;\n+                                        debug!(\"%d\\n\", id);\n+                                end_chan.send(());\n+                                return;\n                     }\n                     (token, end_chan) => {\n                         debug!(\"thread: %d   got token: %d\", id, token);\n@@ -1178,15 +1096,16 @@ mod test {\n \n             impl Drop for S {\n                 fn drop(&self) {\n-                    let _foo = @0;\n+                        let _foo = @0;\n                 }\n             }\n \n             let s = S { field: () };\n \n             do spawntask {\n-                let _ss = &s;\n+                        let _ss = &s;\n             }\n         }\n     }\n+\n }"}, {"sha": "23a0d28e45777ff1f89d0f5d5f646807d58d3c16", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 167, "deletions": 59, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -30,21 +30,34 @@ use rt::context::Context;\n use task::spawn::Taskgroup;\n use cell::Cell;\n \n+// The Task struct represents all state associated with a rust\n+// task. There are at this point two primary \"subtypes\" of task,\n+// however instead of using a subtype we just have a \"task_type\" field\n+// in the struct. This contains a pointer to another struct that holds\n+// the type-specific state.\n+\n pub struct Task {\n     heap: LocalHeap,\n     gc: GarbageCollector,\n     storage: LocalStorage,\n     logger: StdErrLogger,\n     unwinder: Unwinder,\n-    home: Option<SchedHome>,\n     taskgroup: Option<Taskgroup>,\n     death: Death,\n     destroyed: bool,\n-    coroutine: Option<~Coroutine>,\n     // FIXME(#6874/#7599) use StringRef to save on allocations\n     name: Option<~str>,\n+    coroutine: Option<Coroutine>,\n+    sched: Option<~Scheduler>,\n+    task_type: TaskType\n+}\n+\n+pub enum TaskType {\n+    GreenTask(Option<~SchedHome>),\n+    SchedTask\n }\n \n+/// A coroutine is nothing more than a (register context, stack) pair.\n pub struct Coroutine {\n     /// The segment of stack on which the task is currently running or\n     /// if the task is blocked, on which the task will resume\n@@ -54,6 +67,7 @@ pub struct Coroutine {\n     saved_context: Context\n }\n \n+/// Some tasks have a deciated home scheduler that they must run on.\n pub enum SchedHome {\n     AnySched,\n     Sched(SchedHandle)\n@@ -68,6 +82,59 @@ pub struct Unwinder {\n \n impl Task {\n \n+    // A helper to build a new task using the dynamically found\n+    // scheduler and task. Only works in GreenTask context.\n+    pub fn build_homed_child(f: ~fn(), home: SchedHome) -> ~Task {\n+        let f = Cell::new(f);\n+        let home = Cell::new(home);\n+        do Local::borrow::<Task, ~Task> |running_task| {\n+            let mut sched = running_task.sched.take_unwrap();\n+            let new_task = ~running_task.new_child_homed(&mut sched.stack_pool,\n+                                                         home.take(),\n+                                                         f.take());\n+            running_task.sched = Some(sched);\n+            new_task\n+        }\n+    }\n+\n+    pub fn build_child(f: ~fn()) -> ~Task {\n+        Task::build_homed_child(f, AnySched)\n+    }\n+\n+    pub fn build_homed_root(f: ~fn(), home: SchedHome) -> ~Task {\n+        let f = Cell::new(f);\n+        let home = Cell::new(home);\n+        do Local::borrow::<Task, ~Task> |running_task| {\n+            let mut sched = running_task.sched.take_unwrap();\n+            let new_task = ~Task::new_root_homed(&mut sched.stack_pool,\n+                                                    home.take(),\n+                                                    f.take());\n+            running_task.sched = Some(sched);\n+            new_task\n+        }\n+    }\n+\n+    pub fn build_root(f: ~fn()) -> ~Task {\n+        Task::build_homed_root(f, AnySched)\n+    }\n+\n+    pub fn new_sched_task() -> Task {\n+        Task {\n+            heap: LocalHeap::new(),\n+            gc: GarbageCollector,\n+            storage: LocalStorage(ptr::null(), None),\n+            logger: StdErrLogger,\n+            unwinder: Unwinder { unwinding: false },\n+            taskgroup: None,\n+            death: Death::new(),\n+            destroyed: false,\n+            coroutine: Some(Coroutine::empty()),\n+            name: None,\n+            sched: None,\n+            task_type: SchedTask\n+        }\n+    }\n+\n     pub fn new_root(stack_pool: &mut StackPool,\n                     start: ~fn()) -> Task {\n         Task::new_root_homed(stack_pool, AnySched, start)\n@@ -88,12 +155,13 @@ impl Task {\n             storage: LocalStorage(ptr::null(), None),\n             logger: StdErrLogger,\n             unwinder: Unwinder { unwinding: false },\n-            home: Some(home),\n             taskgroup: None,\n             death: Death::new(),\n             destroyed: false,\n-            coroutine: Some(~Coroutine::new(stack_pool, start)),\n             name: None,\n+            coroutine: Some(Coroutine::new(stack_pool, start)),\n+            sched: None,\n+            task_type: GreenTask(Some(~home))\n         }\n     }\n \n@@ -106,28 +174,43 @@ impl Task {\n             gc: GarbageCollector,\n             storage: LocalStorage(ptr::null(), None),\n             logger: StdErrLogger,\n-            home: Some(home),\n             unwinder: Unwinder { unwinding: false },\n             taskgroup: None,\n             // FIXME(#7544) make watching optional\n             death: self.death.new_child(),\n             destroyed: false,\n-            coroutine: Some(~Coroutine::new(stack_pool, start)),\n             name: None,\n+            coroutine: Some(Coroutine::new(stack_pool, start)),\n+            sched: None,\n+            task_type: GreenTask(Some(~home))\n         }\n     }\n \n     pub fn give_home(&mut self, new_home: SchedHome) {\n-        self.home = Some(new_home);\n+        match self.task_type {\n+            GreenTask(ref mut home) => {\n+                *home = Some(~new_home);\n+            }\n+            SchedTask => {\n+                rtabort!(\"type error: used SchedTask as GreenTask\");\n+            }\n+        }\n     }\n \n-    pub fn run(&mut self, f: &fn()) {\n-        // This is just an assertion that `run` was called unsafely\n-        // and this instance of Task is still accessible.\n-        do Local::borrow::<Task, ()> |task| {\n-            assert!(borrow::ref_eq(task, self));\n+    pub fn take_unwrap_home(&mut self) -> SchedHome {\n+        match self.task_type {\n+            GreenTask(ref mut home) => {\n+                let out = home.take_unwrap();\n+                return *out;\n+            }\n+            SchedTask => {\n+                rtabort!(\"type error: used SchedTask as GreenTask\");\n+            }\n         }\n+    }\n \n+    pub fn run(&mut self, f: &fn()) {\n+        rtdebug!(\"run called on task: %u\", borrow::to_uint(self));\n         self.unwinder.try(f);\n         { let _ = self.taskgroup.take(); }\n         self.death.collect_failure(!self.unwinder.unwinding);\n@@ -141,6 +224,8 @@ impl Task {\n     /// thread-local-storage.\n     fn destroy(&mut self) {\n \n+        rtdebug!(\"DESTROYING TASK: %u\", borrow::to_uint(self));\n+\n         do Local::borrow::<Task, ()> |task| {\n             assert!(borrow::ref_eq(task, self));\n         }\n@@ -158,63 +243,68 @@ impl Task {\n         self.destroyed = true;\n     }\n \n-    /// Check if *task* is currently home.\n-    pub fn is_home(&self) -> bool {\n-        do Local::borrow::<Scheduler,bool> |sched| {\n-            match self.home {\n-                Some(AnySched) => { false }\n-                Some(Sched(SchedHandle { sched_id: ref id, _ })) => {\n-                    *id == sched.sched_id()\n-                }\n-                None => { rtabort!(\"task home of None\") }\n-            }\n-        }\n-    }\n+    // New utility functions for homes.\n \n     pub fn is_home_no_tls(&self, sched: &~Scheduler) -> bool {\n-        match self.home {\n-            Some(AnySched) => { false }\n-            Some(Sched(SchedHandle { sched_id: ref id, _ })) => {\n+        match self.task_type {\n+            GreenTask(Some(~AnySched)) => { false }\n+            GreenTask(Some(~Sched(SchedHandle { sched_id: ref id, _}))) => {\n                 *id == sched.sched_id()\n             }\n-            None => {rtabort!(\"task home of None\") }\n-        }\n-    }\n-\n-    pub fn is_home_using_id(sched_id: uint) -> bool {\n-        do Local::borrow::<Task,bool> |task| {\n-            match task.home {\n-                Some(Sched(SchedHandle { sched_id: ref id, _ })) => {\n-                    *id == sched_id\n-                }\n-                Some(AnySched) => { false }\n-                None => { rtabort!(\"task home of None\") }\n+            GreenTask(None) => {\n+                rtabort!(\"task without home\");\n+            }\n+            SchedTask => {\n+                // Awe yea\n+                rtabort!(\"type error: expected: GreenTask, found: SchedTask\");\n             }\n         }\n     }\n \n-    /// Check if this *task* has a home.\n     pub fn homed(&self) -> bool {\n-        match self.home {\n-            Some(AnySched) => { false }\n-            Some(Sched(_)) => { true }\n-            None => {\n-                rtabort!(\"task home of None\")\n+        match self.task_type {\n+            GreenTask(Some(~AnySched)) => { false }\n+            GreenTask(Some(~Sched(SchedHandle { _ }))) => { true }\n+            GreenTask(None) => {\n+                rtabort!(\"task without home\");\n+            }\n+            SchedTask => {\n+                rtabort!(\"type error: expected: GreenTask, found: SchedTask\");\n             }\n         }\n     }\n \n-    /// On a special scheduler?\n-    pub fn on_special() -> bool {\n-        do Local::borrow::<Scheduler,bool> |sched| {\n-            !sched.run_anything\n+    // Grab both the scheduler and the task from TLS and check if the\n+    // task is executing on an appropriate scheduler.\n+    pub fn on_appropriate_sched() -> bool {\n+        do Local::borrow::<Task,bool> |task| {\n+            let sched_id = task.sched.get_ref().sched_id();\n+            let sched_run_anything = task.sched.get_ref().run_anything;\n+            match task.task_type {\n+                GreenTask(Some(~AnySched)) => {\n+                    rtdebug!(\"anysched task in sched check ****\");\n+                    sched_run_anything\n+                }\n+                GreenTask(Some(~Sched(SchedHandle { sched_id: ref id, _ }))) => {\n+                    rtdebug!(\"homed task in sched check ****\");\n+                    *id == sched_id\n+                }\n+                GreenTask(None) => {\n+                    rtabort!(\"task without home\");\n+                }\n+                SchedTask => {\n+                    rtabort!(\"type error: expected: GreenTask, found: SchedTask\");\n+                }\n+            }\n         }\n     }\n-\n }\n \n impl Drop for Task {\n-    fn drop(&self) { assert!(self.destroyed) }\n+    fn drop(&self) {\n+        rtdebug!(\"called drop for a task: %u\", borrow::to_uint(self));\n+        assert!(self.destroyed)\n+    }\n }\n \n // Coroutines represent nothing more than a context and a stack\n@@ -234,19 +324,33 @@ impl Coroutine {\n         }\n     }\n \n+    pub fn empty() -> Coroutine {\n+        Coroutine {\n+            current_stack_segment: StackSegment::new(0),\n+            saved_context: Context::empty()\n+        }\n+    }\n+\n     fn build_start_wrapper(start: ~fn()) -> ~fn() {\n         let start_cell = Cell::new(start);\n         let wrapper: ~fn() = || {\n             // First code after swap to this new context. Run our\n             // cleanup job.\n             unsafe {\n-                let sched = Local::unsafe_borrow::<Scheduler>();\n-                (*sched).run_cleanup_job();\n \n-                let sched = Local::unsafe_borrow::<Scheduler>();\n-                let task = (*sched).current_task.get_mut_ref();\n+                // Again - might work while safe, or it might not.\n+                do Local::borrow::<Scheduler,()> |sched| {\n+                    (sched).run_cleanup_job();\n+                }\n+\n+                // To call the run method on a task we need a direct\n+                // reference to it. The task is in TLS, so we can\n+                // simply unsafe_borrow it to get this reference. We\n+                // need to still have the task in TLS though, so we\n+                // need to unsafe_borrow.\n+                let task = Local::unsafe_borrow::<Task>();\n \n-                do task.run {\n+                do (*task).run {\n                     // N.B. Removing `start` from the start wrapper\n                     // closure by emptying a cell is critical for\n                     // correctness. The ~Task pointer, and in turn the\n@@ -262,16 +366,19 @@ impl Coroutine {\n                 };\n             }\n \n+            // We remove the sched from the Task in TLS right now.\n             let sched = Local::take::<Scheduler>();\n-            sched.terminate_current_task();\n+            // ... allowing us to give it away when performing a\n+            // scheduling operation.\n+            sched.terminate_current_task()\n         };\n         return wrapper;\n     }\n \n     /// Destroy coroutine and try to reuse stack segment.\n-    pub fn recycle(~self, stack_pool: &mut StackPool) {\n+    pub fn recycle(self, stack_pool: &mut StackPool) {\n         match self {\n-            ~Coroutine { current_stack_segment, _ } => {\n+            Coroutine { current_stack_segment, _ } => {\n                 stack_pool.give_segment(current_stack_segment);\n             }\n         }\n@@ -465,3 +572,4 @@ mod test {\n         }\n     }\n }\n+"}, {"sha": "22eb42e2ee828f888761ee9998119410a2a39056", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 55, "deletions": 168, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -18,14 +18,12 @@ use iterator::Iterator;\n use vec::{OwnedVector, MutableVector};\n use super::io::net::ip::{IpAddr, Ipv4, Ipv6};\n use rt::sched::Scheduler;\n-use rt::local::Local;\n use unstable::run_in_bare_thread;\n use rt::thread::Thread;\n use rt::task::Task;\n use rt::uv::uvio::UvEventLoop;\n use rt::work_queue::WorkQueue;\n use rt::sleeper_list::SleeperList;\n-use rt::task::{Sched};\n use rt::comm::oneshot;\n use result::{Result, Ok, Err};\n \n@@ -34,29 +32,37 @@ pub fn new_test_uv_sched() -> Scheduler {\n     let mut sched = Scheduler::new(~UvEventLoop::new(),\n                                    WorkQueue::new(),\n                                    SleeperList::new());\n+\n     // Don't wait for the Shutdown message\n     sched.no_sleep = true;\n     return sched;\n+\n }\n \n-/// Creates a new scheduler in a new thread and runs a task in it,\n-/// then waits for the scheduler to exit. Failure of the task\n-/// will abort the process.\n pub fn run_in_newsched_task(f: ~fn()) {\n     let f = Cell::new(f);\n-\n     do run_in_bare_thread {\n-        let mut sched = ~new_test_uv_sched();\n-        let on_exit: ~fn(bool) = |exit_status| rtassert!(exit_status);\n-        let mut task = ~Task::new_root(&mut sched.stack_pool,\n-                                       f.take());\n-        rtdebug!(\"newsched_task: %x\", ::borrow::to_uint(task));\n-        task.death.on_exit = Some(on_exit);\n-        sched.enqueue_task(task);\n-        sched.run();\n+        run_in_newsched_task_core(f.take());\n     }\n }\n \n+pub fn run_in_newsched_task_core(f: ~fn()) {\n+\n+    use rt::sched::Shutdown;\n+\n+    let mut sched = ~new_test_uv_sched();\n+    let exit_handle = Cell::new(sched.make_handle());\n+\n+    let on_exit: ~fn(bool) = |exit_status| {\n+        exit_handle.take().send(Shutdown);\n+        rtassert!(exit_status);\n+    };\n+    let mut task = ~Task::new_root(&mut sched.stack_pool, f);\n+    task.death.on_exit = Some(on_exit);\n+\n+    sched.bootstrap(task);\n+}\n+\n /// Create more than one scheduler and run a function in a task\n /// in one of the schedulers. The schedulers will stay alive\n /// until the function `f` returns.\n@@ -65,7 +71,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n     use from_str::FromStr;\n     use rt::sched::Shutdown;\n \n-    let f_cell = Cell::new(f);\n+    let f = Cell::new(f);\n \n     do run_in_bare_thread {\n         let nthreads = match os::getenv(\"RUST_RT_TEST_THREADS\") {\n@@ -95,7 +101,6 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n             scheds.push(sched);\n         }\n \n-        let f_cell = Cell::new(f_cell.take());\n         let handles = Cell::new(handles);\n         let on_exit: ~fn(bool) = |exit_status| {\n             let mut handles = handles.take();\n@@ -107,18 +112,32 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n             rtassert!(exit_status);\n         };\n         let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n-                                        f_cell.take());\n+                                        f.take());\n         main_task.death.on_exit = Some(on_exit);\n-        scheds[0].enqueue_task(main_task);\n \n         let mut threads = ~[];\n+        let main_task = Cell::new(main_task);\n \n-        while !scheds.is_empty() {\n+        let main_thread = {\n             let sched = scheds.pop();\n             let sched_cell = Cell::new(sched);\n+            do Thread::start {\n+                let sched = sched_cell.take();\n+                sched.bootstrap(main_task.take());\n+            }\n+        };\n+        threads.push(main_thread);\n+\n+        while !scheds.is_empty() {\n+            let mut sched = scheds.pop();\n+            let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool) || {\n+                rtdebug!(\"bootstrapping non-primary scheduler\");\n+            };\n+            let bootstrap_task_cell = Cell::new(bootstrap_task);\n+            let sched_cell = Cell::new(sched);\n             let thread = do Thread::start {\n                 let sched = sched_cell.take();\n-                sched.run();\n+                sched.bootstrap(bootstrap_task_cell.take());\n             };\n \n             threads.push(thread);\n@@ -134,187 +153,52 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n \n /// Test tasks will abort on failure instead of unwinding\n pub fn spawntask(f: ~fn()) {\n-    use super::sched::*;\n-    let f = Cell::new(f);\n-\n-    let task = unsafe {\n-        let sched = Local::unsafe_borrow::<Scheduler>();\n-        rtdebug!(\"spawntask taking the scheduler from TLS\");\n-\n-\n-        do Local::borrow::<Task, ~Task>() |running_task| {\n-            ~running_task.new_child(&mut (*sched).stack_pool, f.take())\n-        }\n-    };\n-\n-    rtdebug!(\"new task pointer: %x\", ::borrow::to_uint(task));\n-\n-    let sched = Local::take::<Scheduler>();\n-    rtdebug!(\"spawntask scheduling the new task\");\n-    sched.schedule_task(task);\n-}\n-\n-\n-/// Create a new task and run it right now. Aborts on failure\n-pub fn spawntask_immediately(f: ~fn()) {\n-    use super::sched::*;\n-\n-    let f = Cell::new(f);\n-\n-    let task = unsafe {\n-        let sched = Local::unsafe_borrow::<Scheduler>();\n-        do Local::borrow::<Task, ~Task>() |running_task| {\n-            ~running_task.new_child(&mut (*sched).stack_pool,\n-                                    f.take())\n-        }\n-    };\n-\n-    let sched = Local::take::<Scheduler>();\n-    do sched.switch_running_tasks_and_then(task) |sched, task| {\n-        sched.enqueue_blocked_task(task);\n-    }\n+    Scheduler::run_task(Task::build_child(f));\n }\n \n /// Create a new task and run it right now. Aborts on failure\n pub fn spawntask_later(f: ~fn()) {\n-    use super::sched::*;\n-    let f = Cell::new(f);\n-\n-    let task = unsafe {\n-        let sched = Local::unsafe_borrow::<Scheduler>();\n-        do Local::borrow::<Task, ~Task>() |running_task| {\n-            ~running_task.new_child(&mut (*sched).stack_pool, f.take())\n-        }\n-    };\n-\n-    let mut sched = Local::take::<Scheduler>();\n-    sched.enqueue_task(task);\n-    Local::put(sched);\n+    Scheduler::run_task_later(Task::build_child(f));\n }\n \n-/// Spawn a task and either run it immediately or run it later\n pub fn spawntask_random(f: ~fn()) {\n-    use super::sched::*;\n     use rand::{Rand, rng};\n \n-    let f = Cell::new(f);\n-\n-    let task = unsafe {\n-        let sched = Local::unsafe_borrow::<Scheduler>();\n-        do Local::borrow::<Task, ~Task>() |running_task| {\n-            ~running_task.new_child(&mut (*sched).stack_pool,\n-                                    f.take())\n-\n-        }\n-    };\n-\n-    let mut sched = Local::take::<Scheduler>();\n-\n     let mut rng = rng();\n     let run_now: bool = Rand::rand(&mut rng);\n \n     if run_now {\n-        do sched.switch_running_tasks_and_then(task) |sched, task| {\n-            sched.enqueue_blocked_task(task);\n-        }\n+        spawntask(f)\n     } else {\n-        sched.enqueue_task(task);\n-        Local::put(sched);\n+        spawntask_later(f)\n     }\n }\n \n-/// Spawn a task, with the current scheduler as home, and queue it to\n-/// run later.\n-pub fn spawntask_homed(scheds: &mut ~[~Scheduler], f: ~fn()) {\n-    use super::sched::*;\n-    use rand::{rng, RngUtil};\n-    let mut rng = rng();\n-\n-    let task = {\n-        let sched = &mut scheds[rng.gen_int_range(0,scheds.len() as int)];\n-        let handle = sched.make_handle();\n-        let home_id = handle.sched_id;\n-\n-        // now that we know where this is going, build a new function\n-        // that can assert it is in the right place\n-        let af: ~fn() = || {\n-            do Local::borrow::<Scheduler,()>() |sched| {\n-                rtdebug!(\"home_id: %u, runtime loc: %u\",\n-                         home_id,\n-                         sched.sched_id());\n-                assert!(home_id == sched.sched_id());\n-            };\n-            f()\n-        };\n-\n-        ~Task::new_root_homed(&mut sched.stack_pool,\n-                              Sched(handle),\n-                              af)\n-    };\n-    let dest_sched = &mut scheds[rng.gen_int_range(0,scheds.len() as int)];\n-    // enqueue it for future execution\n-    dest_sched.enqueue_task(task);\n-}\n-\n-/// Spawn a task and wait for it to finish, returning whether it\n-/// completed successfully or failed\n-pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n-    use cell::Cell;\n-    use super::sched::*;\n-\n-    let f = Cell::new(f);\n+pub fn spawntask_try(f: ~fn()) -> Result<(),()> {\n \n     let (port, chan) = oneshot();\n     let chan = Cell::new(chan);\n     let on_exit: ~fn(bool) = |exit_status| chan.take().send(exit_status);\n-    let mut new_task = unsafe {\n-        let sched = Local::unsafe_borrow::<Scheduler>();\n-        do Local::borrow::<Task, ~Task> |_running_task| {\n-\n-            // I don't understand why using a child task here fails. I\n-            // think the fail status is propogating back up the task\n-            // tree and triggering a fail for the parent, which we\n-            // aren't correctly expecting.\n-\n-            // ~running_task.new_child(&mut (*sched).stack_pool,\n-            ~Task::new_root(&mut (*sched).stack_pool,\n-                           f.take())\n-        }\n-    };\n-    new_task.death.on_exit = Some(on_exit);\n \n-    let sched = Local::take::<Scheduler>();\n-    do sched.switch_running_tasks_and_then(new_task) |sched, old_task| {\n-        sched.enqueue_blocked_task(old_task);\n-    }\n+    let mut new_task = Task::build_root(f);\n+    new_task.death.on_exit = Some(on_exit);\n \n-    rtdebug!(\"enqueued the new task, now waiting on exit_status\");\n+    Scheduler::run_task(new_task);\n \n     let exit_status = port.recv();\n     if exit_status { Ok(()) } else { Err(()) }\n+\n }\n \n /// Spawn a new task in a new scheduler and return a thread handle.\n pub fn spawntask_thread(f: ~fn()) -> Thread {\n-    use rt::sched::*;\n \n     let f = Cell::new(f);\n \n-    let task = unsafe {\n-        let sched = Local::unsafe_borrow::<Scheduler>();\n-        do Local::borrow::<Task, ~Task>() |running_task| {\n-            ~running_task.new_child(&mut (*sched).stack_pool,\n-                                    f.take())\n-        }\n-    };\n-\n-    let task = Cell::new(task);\n-\n     let thread = do Thread::start {\n-        let mut sched = ~new_test_uv_sched();\n-        sched.enqueue_task(task.take());\n-        sched.run();\n+        run_in_newsched_task_core(f.take());\n     };\n+\n     return thread;\n }\n \n@@ -323,11 +207,14 @@ pub fn with_test_task(blk: ~fn(~Task) -> ~Task) {\n     do run_in_bare_thread {\n         let mut sched = ~new_test_uv_sched();\n         let task = blk(~Task::new_root(&mut sched.stack_pool, ||{}));\n-        sched.enqueue_task(task);\n-        sched.run();\n+        cleanup_task(task);\n     }\n }\n \n+/// Use to cleanup tasks created for testing but not \"run\".\n+pub fn cleanup_task(mut task: ~Task) {\n+    task.destroyed = true;\n+}\n \n /// Get a port number, starting at 9600, for use in tests\n pub fn next_test_port() -> u16 {"}, {"sha": "ae455a6ad04e323ff2a8f01ab5f6de700dfe6bbf", "filename": "src/libstd/rt/tube.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftube.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -17,7 +17,6 @@ use option::*;\n use clone::Clone;\n use super::rc::RC;\n use rt::sched::Scheduler;\n-use rt::{context, TaskContext, SchedulerContext};\n use rt::kill::BlockedTask;\n use rt::local::Local;\n use vec::OwnedVector;\n@@ -44,8 +43,6 @@ impl<T> Tube<T> {\n \n     pub fn send(&mut self, val: T) {\n         rtdebug!(\"tube send\");\n-        assert!(context() == SchedulerContext);\n-\n         unsafe {\n             let state = self.p.unsafe_borrow_mut();\n             (*state).buf.push(val);\n@@ -61,8 +58,6 @@ impl<T> Tube<T> {\n     }\n \n     pub fn recv(&mut self) -> T {\n-        assert!(context() == TaskContext);\n-\n         unsafe {\n             let state = self.p.unsafe_borrow_mut();\n             if !(*state).buf.is_empty() {"}, {"sha": "fa5c497a8776d8759d2f6c1a679a17913ce67cb2", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -51,7 +51,7 @@ use rt::io::net::ip::IpAddr;\n \n use rt::io::IoError;\n \n-#[cfg(test)] use unstable::run_in_bare_thread;\n+//#[cfg(test)] use unstable::run_in_bare_thread;\n \n pub use self::file::FsRequest;\n pub use self::net::{StreamWatcher, TcpWatcher, UdpWatcher};\n@@ -333,7 +333,7 @@ pub fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n         return None;\n     }\n }\n-\n+/*\n #[test]\n fn test_slice_to_uv_buf() {\n     let slice = [0, .. 20];\n@@ -360,3 +360,4 @@ fn loop_smoke_test() {\n         loop_.close();\n     }\n }\n+*/"}, {"sha": "5be197521523439691c26a5d74b3453b62e7b39c", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -33,7 +33,7 @@ use unstable::sync::Exclusive;\n #[cfg(test)] use container::Container;\n #[cfg(test)] use uint;\n #[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use rt::test::{spawntask_immediately,\n+#[cfg(test)] use rt::test::{spawntask,\n                             next_test_ip4,\n                             run_in_newsched_task};\n \n@@ -251,13 +251,11 @@ impl IoFactory for UvIoFactory {\n         let result_cell_ptr: *Cell<Result<~RtioTcpStreamObject, IoError>> = &result_cell;\n \n         let scheduler = Local::take::<Scheduler>();\n-        assert!(scheduler.in_task_context());\n \n         // Block this task and take ownership, switch to scheduler context\n-        do scheduler.deschedule_running_task_and_then |sched, task| {\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n \n             rtdebug!(\"connect: entered scheduler context\");\n-            assert!(!sched.in_task_context());\n             let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n             let task_cell = Cell::new(task);\n \n@@ -458,11 +456,9 @@ impl RtioTcpStream for UvTcpStream {\n         let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n \n         let scheduler = Local::take::<Scheduler>();\n-        assert!(scheduler.in_task_context());\n         let buf_ptr: *&mut [u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |sched, task| {\n+        do scheduler.deschedule_running_task_and_then |_sched, task| {\n             rtdebug!(\"read: entered scheduler context\");\n-            assert!(!sched.in_task_context());\n             let task_cell = Cell::new(task);\n             // XXX: We shouldn't reallocate these callbacks every\n             // call to read\n@@ -500,7 +496,6 @@ impl RtioTcpStream for UvTcpStream {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let scheduler = Local::take::<Scheduler>();\n-        assert!(scheduler.in_task_context());\n         let buf_ptr: *&[u8] = &buf;\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n@@ -602,11 +597,9 @@ impl RtioUdpSocket for UvUdpSocket {\n         let result_cell_ptr: *Cell<Result<(uint, IpAddr), IoError>> = &result_cell;\n \n         let scheduler = Local::take::<Scheduler>();\n-        assert!(scheduler.in_task_context());\n         let buf_ptr: *&mut [u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |sched, task| {\n+        do scheduler.deschedule_running_task_and_then |_sched, task| {\n             rtdebug!(\"recvfrom: entered scheduler context\");\n-            assert!(!sched.in_task_context());\n             let task_cell = Cell::new(task);\n             let alloc: AllocCallback = |_| unsafe { slice_to_uv_buf(*buf_ptr) };\n             do self.recv_start(alloc) |mut watcher, nread, _buf, addr, flags, status| {\n@@ -637,7 +630,6 @@ impl RtioUdpSocket for UvUdpSocket {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let scheduler = Local::take::<Scheduler>();\n-        assert!(scheduler.in_task_context());\n         let buf_ptr: *&[u8] = &buf;\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n@@ -798,10 +790,8 @@ impl Drop for UvTimer {\n impl RtioTimer for UvTimer {\n     fn sleep(&self, msecs: u64) {\n         let scheduler = Local::take::<Scheduler>();\n-        assert!(scheduler.in_task_context());\n-        do scheduler.deschedule_running_task_and_then |sched, task| {\n+        do scheduler.deschedule_running_task_and_then |_sched, task| {\n             rtdebug!(\"sleep: entered scheduler context\");\n-            assert!(!sched.in_task_context());\n             let task_cell = Cell::new(task);\n             let mut watcher = **self;\n             do watcher.start(msecs, 0) |_, status| {\n@@ -845,7 +835,7 @@ fn test_simple_tcp_server_and_client() {\n         let addr = next_test_ip4();\n \n         // Start the server first so it's listening when we connect\n-        do spawntask_immediately {\n+        do spawntask {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n@@ -860,7 +850,7 @@ fn test_simple_tcp_server_and_client() {\n             }\n         }\n \n-        do spawntask_immediately {\n+        do spawntask {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut stream = (*io).tcp_connect(addr).unwrap();\n@@ -876,7 +866,7 @@ fn test_simple_udp_server_and_client() {\n         let server_addr = next_test_ip4();\n         let client_addr = next_test_ip4();\n \n-        do spawntask_immediately {\n+        do spawntask {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut server_socket = (*io).udp_bind(server_addr).unwrap();\n@@ -891,7 +881,7 @@ fn test_simple_udp_server_and_client() {\n             }\n         }\n \n-        do spawntask_immediately {\n+        do spawntask {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut client_socket = (*io).udp_bind(client_addr).unwrap();\n@@ -906,7 +896,7 @@ fn test_read_and_block() {\n     do run_in_newsched_task {\n         let addr = next_test_ip4();\n \n-        do spawntask_immediately {\n+        do spawntask {\n             let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n             let mut listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n             let mut stream = listener.accept().unwrap();\n@@ -939,7 +929,7 @@ fn test_read_and_block() {\n             assert!(reads > 1);\n         }\n \n-        do spawntask_immediately {\n+        do spawntask {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut stream = (*io).tcp_connect(addr).unwrap();\n@@ -959,7 +949,7 @@ fn test_read_read_read() {\n         let addr = next_test_ip4();\n         static MAX: uint = 500000;\n \n-        do spawntask_immediately {\n+        do spawntask {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n@@ -973,7 +963,7 @@ fn test_read_read_read() {\n             }\n         }\n \n-        do spawntask_immediately {\n+        do spawntask {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut stream = (*io).tcp_connect(addr).unwrap();\n@@ -999,7 +989,7 @@ fn test_udp_twice() {\n         let server_addr = next_test_ip4();\n         let client_addr = next_test_ip4();\n \n-        do spawntask_immediately {\n+        do spawntask {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut client = (*io).udp_bind(client_addr).unwrap();\n@@ -1008,7 +998,7 @@ fn test_udp_twice() {\n             }\n         }\n \n-        do spawntask_immediately {\n+        do spawntask {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut server = (*io).udp_bind(server_addr).unwrap();\n@@ -1036,7 +1026,7 @@ fn test_udp_many_read() {\n         let client_in_addr = next_test_ip4();\n         static MAX: uint = 500_000;\n \n-        do spawntask_immediately {\n+        do spawntask {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut server_out = (*io).udp_bind(server_out_addr).unwrap();\n@@ -1059,7 +1049,7 @@ fn test_udp_many_read() {\n             }\n         }\n \n-        do spawntask_immediately {\n+        do spawntask {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut client_out = (*io).udp_bind(client_out_addr).unwrap();"}, {"sha": "7a864ecb8679d67a7b51f65ae6a96d561e4a41d1", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 152, "deletions": 79, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -677,121 +677,190 @@ fn block_forever() { let (po, _ch) = stream::<()>(); po.recv(); }\n \n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n-    let (po, ch) = stream();\n-    let ch = SharedChan::new(ch);\n-    do spawn_unlinked {\n-        let ch = ch.clone();\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let (po, ch) = stream();\n+        let ch = SharedChan::new(ch);\n         do spawn_unlinked {\n-            // Give middle task a chance to fail-but-not-kill-us.\n-            do 16.times { task::yield(); }\n-            ch.send(()); // If killed first, grandparent hangs.\n+            let ch = ch.clone();\n+            do spawn_unlinked {\n+                // Give middle task a chance to fail-but-not-kill-us.\n+                do 16.times { task::yield(); }\n+                ch.send(()); // If killed first, grandparent hangs.\n+            }\n+            fail!(); // Shouldn't kill either (grand)parent or (grand)child.\n         }\n-        fail!(); // Shouldn't kill either (grand)parent or (grand)child.\n+        po.recv();\n     }\n-    po.recv();\n }\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n-    do spawn_unlinked { fail!(); }\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        do spawn_unlinked { fail!(); }\n+    }\n }\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n-    do spawn_supervised { fail!(); }\n-    // Give child a chance to fail-but-not-kill-us.\n-    do 16.times { task::yield(); }\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        do spawn_supervised { fail!(); }\n+        // Give child a chance to fail-but-not-kill-us.\n+        do 16.times { task::yield(); }\n+    }\n }\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_sup_fail_down() {\n-    do spawn_supervised { block_forever(); }\n-    fail!(); // Shouldn't leave a child hanging around.\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            do spawn_supervised { block_forever(); }\n+            fail!(); // Shouldn't leave a child hanging around.\n+        };\n+        assert!(result.is_err());\n+    }\n }\n \n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n-    // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n-    // We have to cheat with opts - the interface doesn't support them because\n-    // they don't make sense (redundant with task().supervised()).\n-    let mut b0 = task();\n-    b0.opts.linked = true;\n-    b0.opts.supervised = true;\n-\n-    do b0.spawn {\n-        fail!();\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n+            // We have to cheat with opts - the interface doesn't support them because\n+            // they don't make sense (redundant with task().supervised()).\n+            let mut b0 = task();\n+            b0.opts.linked = true;\n+            b0.opts.supervised = true;\n+\n+            do b0.spawn {\n+                fail!();\n+            }\n+            block_forever(); // We should get punted awake\n+        };\n+        assert!(result.is_err());\n     }\n-    block_forever(); // We should get punted awake\n }\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n-    // We have to cheat with opts - the interface doesn't support them because\n-    // they don't make sense (redundant with task().supervised()).\n-    let mut b0 = task();\n-    b0.opts.linked = true;\n-    b0.opts.supervised = true;\n-    do b0.spawn { block_forever(); }\n-    fail!(); // *both* mechanisms would be wrong if this didn't kill the child\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // We have to cheat with opts - the interface doesn't support them because\n+            // they don't make sense (redundant with task().supervised()).\n+            let mut b0 = task();\n+            b0.opts.linked = true;\n+            b0.opts.supervised = true;\n+            do b0.spawn { block_forever(); }\n+            fail!(); // *both* mechanisms would be wrong if this didn't kill the child\n+        };\n+        assert!(result.is_err());\n+    }\n }\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n-    // Default options are to spawn linked & unsupervised.\n-    do spawn { fail!(); }\n-    block_forever(); // We should get punted awake\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // Default options are to spawn linked & unsupervised.\n+            do spawn { fail!(); }\n+            block_forever(); // We should get punted awake\n+        };\n+        assert!(result.is_err());\n+    }\n }\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n-    // Default options are to spawn linked & unsupervised.\n-    do spawn { block_forever(); }\n-    fail!();\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // Default options are to spawn linked & unsupervised.\n+            do spawn { block_forever(); }\n+            fail!();\n+        };\n+        assert!(result.is_err());\n+    }\n }\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n-    // Make sure the above test is the same as this one.\n-    let mut builder = task();\n-    builder.linked();\n-    do builder.spawn { block_forever(); }\n-    fail!();\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // Make sure the above test is the same as this one.\n+            let mut builder = task();\n+            builder.linked();\n+            do builder.spawn { block_forever(); }\n+            fail!();\n+        };\n+        assert!(result.is_err());\n+    }\n }\n \n // A couple bonus linked failure tests - testing for failure propagation even\n // when the middle task exits successfully early before kill signals are sent.\n \n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_failure_propagate_grandchild() {\n-    // Middle task exits; does grandparent's failure propagate across the gap?\n-    do spawn_supervised {\n-        do spawn_supervised { block_forever(); }\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // Middle task exits; does grandparent's failure propagate across the gap?\n+            do spawn_supervised {\n+                do spawn_supervised { block_forever(); }\n+            }\n+            do 16.times { task::yield(); }\n+            fail!();\n+        };\n+        assert!(result.is_err());\n     }\n-    do 16.times { task::yield(); }\n-    fail!();\n }\n \n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_failure_propagate_secondborn() {\n-    // First-born child exits; does parent's failure propagate to sibling?\n-    do spawn_supervised {\n-        do spawn { block_forever(); } // linked\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // First-born child exits; does parent's failure propagate to sibling?\n+            do spawn_supervised {\n+                do spawn { block_forever(); } // linked\n+            }\n+            do 16.times { task::yield(); }\n+            fail!();\n+        };\n+        assert!(result.is_err());\n     }\n-    do 16.times { task::yield(); }\n-    fail!();\n }\n \n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_failure_propagate_nephew_or_niece() {\n-    // Our sibling exits; does our failure propagate to sibling's child?\n-    do spawn { // linked\n-        do spawn_supervised { block_forever(); }\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // Our sibling exits; does our failure propagate to sibling's child?\n+            do spawn { // linked\n+                do spawn_supervised { block_forever(); }\n+            }\n+            do 16.times { task::yield(); }\n+            fail!();\n+        };\n+        assert!(result.is_err());\n     }\n-    do 16.times { task::yield(); }\n-    fail!();\n }\n \n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_propagate_sibling() {\n-    // Middle sibling exits - does eldest's failure propagate to youngest?\n-    do spawn { // linked\n-        do spawn { block_forever(); } // linked\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // Middle sibling exits - does eldest's failure propagate to youngest?\n+            do spawn { // linked\n+                do spawn { block_forever(); } // linked\n+            }\n+            do 16.times { task::yield(); }\n+            fail!();\n+        };\n+        assert!(result.is_err());\n     }\n-    do 16.times { task::yield(); }\n-    fail!();\n }\n \n #[test]\n@@ -1149,11 +1218,15 @@ fn test_child_doesnt_ref_parent() {\n     fn child_no(x: uint) -> ~fn() {\n         return || {\n             if x < generations {\n-                task::spawn(child_no(x+1));\n+                let mut t = task();\n+                t.unwatched();\n+                t.spawn(child_no(x+1));\n             }\n         }\n     }\n-    task::spawn(child_no(0));\n+    let mut t = task();\n+    t.unwatched();\n+    t.spawn(child_no(0));\n }\n \n #[test]\n@@ -1167,9 +1240,9 @@ fn test_simple_newsched_spawn() {\n \n #[test] #[ignore(cfg(windows))]\n fn test_spawn_watched() {\n-    use rt::test::{run_in_newsched_task, spawntask_try};\n+    use rt::test::run_in_newsched_task;\n     do run_in_newsched_task {\n-        let result = do spawntask_try {\n+        let result = do try {\n             let mut t = task();\n             t.unlinked();\n             t.watched();\n@@ -1189,9 +1262,9 @@ fn test_spawn_watched() {\n \n #[test] #[ignore(cfg(windows))]\n fn test_indestructible() {\n-    use rt::test::{run_in_newsched_task, spawntask_try};\n+    use rt::test::run_in_newsched_task;\n     do run_in_newsched_task {\n-        let result = do spawntask_try {\n+        let result = do try {\n             let mut t = task();\n             t.watched();\n             t.supervised();"}, {"sha": "88f214ef4c0749f1d1e55687b67670d022e2f162", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -653,22 +653,16 @@ fn enlist_many(child: TaskHandle, child_arc: &TaskGroupArc,\n \n pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n     match context() {\n-        OldTaskContext => {\n-            spawn_raw_oldsched(opts, f)\n-        }\n-        TaskContext => {\n-            spawn_raw_newsched(opts, f)\n-        }\n-        SchedulerContext => {\n-            fail!(\"can't spawn from scheduler context\")\n-        }\n-        GlobalContext => {\n-            fail!(\"can't spawn from global context\")\n-        }\n+        OldTaskContext   => spawn_raw_oldsched(opts, f),\n+        TaskContext      => spawn_raw_newsched(opts, f),\n+        SchedulerContext => fail!(\"can't spawn from scheduler context\"),\n+        GlobalContext    => fail!(\"can't spawn from global context\"),\n     }\n }\n \n fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n+    use rt::sched::*;\n+\n     let child_data = Cell::new(gen_child_taskgroup(opts.linked, opts.supervised));\n     let indestructible = opts.indestructible;\n \n@@ -700,19 +694,11 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n         }\n     };\n \n-    let mut task = unsafe {\n-        let sched = Local::unsafe_borrow::<Scheduler>();\n-        rtdebug!(\"unsafe borrowed sched\");\n-\n-        if opts.watched {\n-            let child_wrapper = Cell::new(child_wrapper);\n-            do Local::borrow::<Task, ~Task>() |running_task| {\n-                ~running_task.new_child(&mut (*sched).stack_pool, child_wrapper.take())\n-            }\n-        } else {\n-            // An unwatched task is a new root in the exit-code propagation tree\n-            ~Task::new_root(&mut (*sched).stack_pool, child_wrapper)\n-        }\n+    let mut task = if opts.watched {\n+        Task::build_child(child_wrapper)\n+    } else {\n+        // An unwatched task is a new root in the exit-code propagation tree\n+        Task::build_root(child_wrapper)\n     };\n \n     if opts.notify_chan.is_some() {\n@@ -727,12 +713,9 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n     }\n \n     task.name = opts.name.take();\n+    rtdebug!(\"spawn calling run_task\");\n+    Scheduler::run_task(task);\n \n-    rtdebug!(\"spawn about to take scheduler\");\n-\n-    let sched = Local::take::<Scheduler>();\n-    rtdebug!(\"took sched in spawn\");\n-    sched.schedule_task(task);\n }\n \n fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {"}, {"sha": "74604b4ea1777db564aefba9b842ede6ec80749e", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -70,9 +70,6 @@ pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n         _ => {\n             let mut alloc = ::ptr::null();\n             do Local::borrow::<Task,()> |task| {\n-                rtdebug!(\"task pointer: %x, heap pointer: %x\",\n-                         ::borrow::to_uint(task),\n-                         ::borrow::to_uint(&task.heap));\n                 alloc = task.heap.alloc(td as *c_void, size as uint) as *c_char;\n             }\n             return alloc;"}, {"sha": "a36be079b43434e9e2cbe2eaf927704f6e74aff9", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5890fcf87295d5b7a8f4ffa8d9918f755f72baf8/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=5890fcf87295d5b7a8f4ffa8d9918f755f72baf8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-win32\n+// xfail-test\n extern mod extra;\n \n use std::comm::*;"}]}