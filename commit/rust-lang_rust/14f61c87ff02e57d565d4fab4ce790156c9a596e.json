{"sha": "14f61c87ff02e57d565d4fab4ce790156c9a596e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZjYxYzg3ZmYwMmU1N2Q1NjVkNGZhYjRjZTc5MDE1NmM5YTU5NmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-19T04:05:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-19T04:05:58Z"}, "message": "Auto merge of #32866 - davidhewitt:master, r=apasel422\n\nImplement `From<Vec<T>>` and `Into<Vec<T>>` for `VecDeque<T>`", "tree": {"sha": "14f4d25f69464bbbd66ec1f81d9ca7896d023dfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14f4d25f69464bbbd66ec1f81d9ca7896d023dfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14f61c87ff02e57d565d4fab4ce790156c9a596e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14f61c87ff02e57d565d4fab4ce790156c9a596e", "html_url": "https://github.com/rust-lang/rust/commit/14f61c87ff02e57d565d4fab4ce790156c9a596e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14f61c87ff02e57d565d4fab4ce790156c9a596e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d36ad55aa5176eeec0da6d2a7b1689c263195e8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d36ad55aa5176eeec0da6d2a7b1689c263195e8a", "html_url": "https://github.com/rust-lang/rust/commit/d36ad55aa5176eeec0da6d2a7b1689c263195e8a"}, {"sha": "1861951fd99260acc7513881c5105d65ec4599b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1861951fd99260acc7513881c5105d65ec4599b4", "html_url": "https://github.com/rust-lang/rust/commit/1861951fd99260acc7513881c5105d65ec4599b4"}], "stats": {"total": 179, "additions": 179, "deletions": 0}, "files": [{"sha": "6e8f4391eeb4f7a97be588242a281d76e15ebbd8", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/14f61c87ff02e57d565d4fab4ce790156c9a596e/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f61c87ff02e57d565d4fab4ce790156c9a596e/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=14f61c87ff02e57d565d4fab4ce790156c9a596e", "patch": "@@ -32,6 +32,7 @@ use core::cmp;\n use alloc::raw_vec::RawVec;\n \n use super::range::RangeArgument;\n+use super::vec::Vec;\n \n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n@@ -2121,6 +2122,106 @@ impl<T: fmt::Debug> fmt::Debug for VecDeque<T> {\n     }\n }\n \n+#[stable(feature = \"vecdeque_vec_conversions\", since = \"1.10.0\")]\n+impl<T> From<Vec<T>> for VecDeque<T> {\n+    fn from(mut other: Vec<T>) -> Self {\n+        unsafe {\n+            let other_buf = other.as_mut_ptr();\n+            let mut buf = RawVec::from_raw_parts(other_buf, other.capacity());\n+            let len = other.len();\n+            mem::forget(other);\n+\n+            // We need to extend the buf if it's not a power of two, too small\n+            // or doesn't have at least one free space\n+            if !buf.cap().is_power_of_two()\n+                || (buf.cap() < (MINIMUM_CAPACITY + 1))\n+                || (buf.cap() == len)\n+            {\n+                let cap = cmp::max(buf.cap() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n+                buf.reserve_exact(len, cap - len);\n+            }\n+\n+            VecDeque {\n+                tail: 0,\n+                head: len,\n+                buf: buf\n+            }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"vecdeque_vec_conversions\", since = \"1.10.0\")]\n+impl<T> From<VecDeque<T>> for Vec<T> {\n+    fn from(other: VecDeque<T>) -> Self {\n+        unsafe {\n+            let buf = other.buf.ptr();\n+            let len = other.len();\n+            let tail = other.tail;\n+            let head = other.head;\n+            let cap = other.cap();\n+\n+            // Need to move the ring to the front of the buffer, as vec will expect this.\n+            if other.is_contiguous() {\n+                ptr::copy(buf.offset(tail as isize), buf, len);\n+            } else {\n+                if (tail - head) >= cmp::min((cap - tail), head) {\n+                    // There is enough free space in the centre for the shortest block so we can\n+                    // do this in at most three copy moves.\n+                    if (cap - tail) > head {\n+                        // right hand block is the long one; move that enough for the left\n+                        ptr::copy(\n+                            buf.offset(tail as isize),\n+                            buf.offset((tail - head) as isize),\n+                            cap - tail);\n+                        // copy left in the end\n+                        ptr::copy(buf, buf.offset((cap - head) as isize), head);\n+                        // shift the new thing to the start\n+                        ptr::copy(buf.offset((tail-head) as isize), buf, len);\n+                    } else {\n+                        // left hand block is the long one, we can do it in two!\n+                        ptr::copy(buf, buf.offset((cap-tail) as isize), head);\n+                        ptr::copy(buf.offset(tail as isize), buf, cap-tail);\n+                    }\n+                } else {\n+                    // Need to use N swaps to move the ring\n+                    // We can use the space at the end of the ring as a temp store\n+\n+                    let mut left_edge: usize = 0;\n+                    let mut right_edge: usize = tail;\n+\n+                    // The general problem looks like this\n+                    // GHIJKLM...ABCDEF - before any swaps\n+                    // ABCDEFM...GHIJKL - after 1 pass of swaps\n+                    // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n+                    //                  - then restart the algorithm with a new (smaller) store\n+                    // Sometimes the temp store is reached when the right edge is at the end\n+                    // of the buffer - this means we've hit the right order with fewer swaps!\n+                    // E.g\n+                    // EF..ABCD\n+                    // ABCDEF.. - after four only swaps we've finished\n+\n+                    while left_edge < len && right_edge != cap {\n+                        let mut right_offset = 0;\n+                        for i in left_edge..right_edge {\n+                            right_offset = (i - left_edge) % (cap - right_edge);\n+                            let src: isize = (right_edge + right_offset) as isize;\n+                            ptr::swap(buf.offset(i as isize), buf.offset(src));\n+                        }\n+                        let n_ops = right_edge - left_edge;\n+                        left_edge += n_ops;\n+                        right_edge += right_offset + 1;\n+\n+                    }\n+                }\n+\n+            }\n+            let out = Vec::from_raw_parts(buf, len, cap);\n+            mem::forget(other);\n+            out\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use core::iter::Iterator;\n@@ -2401,4 +2502,82 @@ mod tests {\n             }\n         }\n     }\n+\n+    #[test]\n+    fn test_from_vec() {\n+        use super::super::vec::Vec;\n+        for cap in 0..35 {\n+            for len in 0..cap + 1 {\n+                let mut vec = Vec::with_capacity(cap);\n+                vec.extend(0..len);\n+\n+                let vd = VecDeque::from(vec.clone());\n+                assert!(vd.cap().is_power_of_two());\n+                assert_eq!(vd.len(), vec.len());\n+                assert!(vd.into_iter().eq(vec));\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_vec_from_vecdeque() {\n+        use super::super::vec::Vec;\n+\n+        fn create_vec_and_test_convert(cap: usize, offset: usize, len: usize) {\n+            let mut vd = VecDeque::with_capacity(cap);\n+            for _ in 0..offset {\n+                vd.push_back(0);\n+                vd.pop_front();\n+            }\n+            vd.extend(0..len);\n+\n+            let vec: Vec<_> = Vec::from(vd.clone());\n+            assert_eq!(vec.len(), vd.len());\n+            assert!(vec.into_iter().eq(vd));\n+        }\n+\n+        for cap_pwr in 0..7 {\n+            // Make capacity as a (2^x)-1, so that the ring size is 2^x\n+            let cap = (2i32.pow(cap_pwr) - 1) as usize;\n+\n+            // In these cases there is enough free space to solve it with copies\n+            for len in 0..((cap+1)/2) {\n+                // Test contiguous cases\n+                for offset in 0..(cap-len) {\n+                    create_vec_and_test_convert(cap, offset, len)\n+                }\n+\n+                // Test cases where block at end of buffer is bigger than block at start\n+                for offset in (cap-len)..(cap-(len/2)) {\n+                    create_vec_and_test_convert(cap, offset, len)\n+                }\n+\n+                // Test cases where block at start of buffer is bigger than block at end\n+                for offset in (cap-(len/2))..cap {\n+                    create_vec_and_test_convert(cap, offset, len)\n+                }\n+            }\n+\n+            // Now there's not (necessarily) space to straighten the ring with simple copies,\n+            // the ring will use swapping when:\n+            // (cap + 1 - offset) > (cap + 1 - len) && (len - (cap + 1 - offset)) > (cap + 1 - len))\n+            //  right block size  >   free space    &&      left block size       >    free space\n+            for len in ((cap+1)/2)..cap {\n+                // Test contiguous cases\n+                for offset in 0..(cap-len) {\n+                    create_vec_and_test_convert(cap, offset, len)\n+                }\n+\n+                // Test cases where block at end of buffer is bigger than block at start\n+                for offset in (cap-len)..(cap-(len/2)) {\n+                    create_vec_and_test_convert(cap, offset, len)\n+                }\n+\n+                // Test cases where block at start of buffer is bigger than block at end\n+                for offset in (cap-(len/2))..cap {\n+                    create_vec_and_test_convert(cap, offset, len)\n+                }\n+            }\n+        }\n+    }\n }"}]}