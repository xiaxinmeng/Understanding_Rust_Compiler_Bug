{"sha": "1d6f291335c58aac95c1124f55d7fb0834baff2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNmYyOTEzMzVjNThhYWM5NWMxMTI0ZjU1ZDdmYjA4MzRiYWZmMmE=", "commit": {"author": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-06-13T10:34:59Z"}, "committer": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-06-30T08:07:08Z"}, "message": "Move resolver into impls, work on tests", "tree": {"sha": "f0d64776e584bf40ba8edb638596a5a03bf04002", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0d64776e584bf40ba8edb638596a5a03bf04002"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d6f291335c58aac95c1124f55d7fb0834baff2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d6f291335c58aac95c1124f55d7fb0834baff2a", "html_url": "https://github.com/rust-lang/rust/commit/1d6f291335c58aac95c1124f55d7fb0834baff2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d6f291335c58aac95c1124f55d7fb0834baff2a/comments", "author": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "108b953254e46851130e427b41cd143eee07fd02", "url": "https://api.github.com/repos/rust-lang/rust/commits/108b953254e46851130e427b41cd143eee07fd02", "html_url": "https://github.com/rust-lang/rust/commit/108b953254e46851130e427b41cd143eee07fd02"}], "stats": {"total": 209, "additions": 138, "deletions": 71}, "files": [{"sha": "0c1d2e8b9fe2a2cd35385e894fa63e5fb8ba5cfc", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d6f291335c58aac95c1124f55d7fb0834baff2a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1d6f291335c58aac95c1124f55d7fb0834baff2a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1d6f291335c58aac95c1124f55d7fb0834baff2a", "patch": "@@ -1303,6 +1303,7 @@ dependencies = [\n  \"once_cell\",\n  \"ra_db\",\n  \"ra_hir\",\n+ \"ra_hir_def\",\n  \"ra_prof\",\n  \"ra_syntax\",\n  \"ra_text_edit\","}, {"sha": "5766cc3b81637bfa7b10eaced15c28a7c9e3c917", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1d6f291335c58aac95c1124f55d7fb0834baff2a/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6f291335c58aac95c1124f55d7fb0834baff2a/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=1d6f291335c58aac95c1124f55d7fb0834baff2a", "patch": "@@ -186,21 +186,34 @@ impl ModuleDef {\n         module.visibility_of(db, self)\n     }\n \n-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n+    pub fn name(&self, db: &dyn HirDatabase) -> Option<Name> {\n         match self {\n-            ModuleDef::Adt(it) => Some(it.name(db)),\n-            ModuleDef::Trait(it) => Some(it.name(db)),\n-            ModuleDef::Function(it) => Some(it.name(db)),\n-            ModuleDef::EnumVariant(it) => Some(it.name(db)),\n-            ModuleDef::TypeAlias(it) => Some(it.name(db)),\n-\n-            ModuleDef::Module(it) => it.name(db),\n-            ModuleDef::Const(it) => it.name(db),\n-            ModuleDef::Static(it) => it.name(db),\n-\n-            ModuleDef::BuiltinType(it) => Some(it.as_name()),\n+            ModuleDef::Module(m) => m.name(db),\n+            ModuleDef::Function(m) => Some(m.name(db)),\n+            ModuleDef::Adt(m) => Some(m.name(db)),\n+            ModuleDef::EnumVariant(m) => Some(m.name(db)),\n+            ModuleDef::Const(m) => {m.name(db)},\n+            ModuleDef::Static(m) => {m.name(db)},\n+            ModuleDef::Trait(m) => {Some(m.name(db))},\n+            ModuleDef::TypeAlias(m) => {Some(m.name(db))},\n+            ModuleDef::BuiltinType(m) => {Some(m.as_name())}\n         }\n     }\n+\n+    pub fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n+        Some(match self {\n+            ModuleDef::Module(m) => Into::<ModuleId>::into(m.clone()).resolver(db),\n+            ModuleDef::Function(f) => Into::<FunctionId>::into(f.clone()).resolver(db),\n+            ModuleDef::Adt(adt) => Into::<AdtId>::into(adt.clone()).resolver(db),\n+            ModuleDef::EnumVariant(ev) => Into::<GenericDefId>::into(Into::<GenericDef>::into(ev.clone())).resolver(db),\n+            ModuleDef::Const(c) => Into::<GenericDefId>::into(Into::<GenericDef>::into(c.clone())).resolver(db),\n+            ModuleDef::Static(s) => Into::<StaticId>::into(s.clone()).resolver(db),\n+            ModuleDef::Trait(t) => Into::<TraitId>::into(t.clone()).resolver(db),\n+            ModuleDef::TypeAlias(t) => Into::<ModuleId>::into(t.module(db)).resolver(db),\n+            // TODO: This should be a resolver relative to `std`\n+            ModuleDef::BuiltinType(_t) => None?\n+        })\n+    }\n }\n \n pub use hir_def::{"}, {"sha": "34fc36a1fcdd1e99986e20c8a5ab7b61910114ba", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 93, "deletions": 55, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/1d6f291335c58aac95c1124f55d7fb0834baff2a/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6f291335c58aac95c1124f55d7fb0834baff2a/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=1d6f291335c58aac95c1124f55d7fb0834baff2a", "patch": "@@ -146,7 +146,8 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         }\n     } {\n         let range = sema.original_range(&node).range;\n-        let text = hover_text_from_name_kind(db, name_kind.clone()).map(|text| rewrite_links(db, &text, &name_kind).unwrap_or(text));\n+        let text = hover_text_from_name_kind(db, name_kind.clone());\n+        let text = text.map(|text| rewrite_links(db, &text, &name_kind).unwrap_or(text));\n         res.extend(text);\n \n         if !res.is_empty() {\n@@ -405,8 +406,8 @@ fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) ->\n                     Err(_) => {\n                         let link_str = String::from_utf8(link.url.clone()).unwrap();\n                         let link_text = String::from_utf8(link.title.clone()).unwrap();\n-                        let resolved = try_resolve_path(db, definition, &link_str)\n-                            .or_else(|| try_resolve_intra(db, definition, &link_text, &link_str));\n+                        let resolved = try_resolve_intra(db, definition, &link_text, &link_str)\n+                            .or_else(|| try_resolve_path(db, definition, &link_str));\n \n                         if let Some(resolved) = resolved {\n                             link.url = resolved.as_bytes().to_vec();\n@@ -420,7 +421,7 @@ fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) ->\n     });\n     let mut out = Vec::new();\n     format_commonmark(doc, &ComrakOptions::default(), &mut out).ok()?;\n-    Some(String::from_utf8(out).unwrap())\n+    Some(String::from_utf8(out).unwrap().trim().to_string())\n }\n \n #[derive(PartialEq, Eq, Hash, Copy, Clone, Debug)]\n@@ -470,32 +471,7 @@ fn try_resolve_intra(db: &RootDatabase, definition: &Definition, link_text: &str\n     let modpath = ModPath::from_src(path, &Hygiene::new_unhygienic()).unwrap();\n \n     // Resolve it relative to symbol's location (according to the RFC this should consider small scopes\n-    let resolver = {\n-        use ra_hir_def::*;\n-        use hir::*;\n-\n-        // TODO: This should be replaced by implementing HasResolver/TryHasResolver on ModuleDef and Definition.\n-        match definition {\n-            Definition::ModuleDef(def) => match def {\n-                ModuleDef::Module(m) => Into::<ModuleId>::into(m.clone()).resolver(db),\n-                ModuleDef::Function(f) => Into::<FunctionId>::into(f.clone()).resolver(db),\n-                ModuleDef::Adt(adt) => Into::<AdtId>::into(adt.clone()).resolver(db),\n-                ModuleDef::EnumVariant(ev) => Into::<GenericDefId>::into(Into::<GenericDef>::into(ev.clone())).resolver(db),\n-                ModuleDef::Const(c) => Into::<GenericDefId>::into(Into::<GenericDef>::into(c.clone())).resolver(db),\n-                ModuleDef::Static(s) => Into::<StaticId>::into(s.clone()).resolver(db),\n-                ModuleDef::Trait(t) => Into::<TraitId>::into(t.clone()).resolver(db),\n-                ModuleDef::TypeAlias(t) => Into::<ModuleId>::into(t.module(db)).resolver(db),\n-                // TODO: This should be a resolver relative to `std`\n-                ModuleDef::BuiltinType(_t) => Into::<ModuleId>::into(definition.module(db)?).resolver(db)\n-            },\n-            Definition::Field(field) => Into::<VariantId>::into(Into::<VariantDef>::into(field.parent_def(db))).resolver(db),\n-            Definition::Macro(m) => Into::<ModuleId>::into(m.module(db)?).resolver(db),\n-            Definition::SelfType(imp) => Into::<ImplId>::into(imp.clone()).resolver(db),\n-            // it's possible, read probable, that other arms of this are also unreachable\n-            Definition::Local(_local) => unreachable!(),\n-            Definition::TypeParam(tp) => Into::<ModuleId>::into(tp.module(db)).resolver(db)\n-        }\n-    };\n+    let resolver = definition.resolver(db)?;\n \n     // Namespace disambiguation\n     let namespace = Namespace::from_intra_spec(link_target);\n@@ -527,7 +503,7 @@ fn try_resolve_intra(db: &RootDatabase, definition: &Definition, link_text: &str\n         get_doc_url(db, &krate)?\n             .join(&format!(\"{}/\", krate.display_name(db)?)).ok()?\n             .join(&path.segments.iter().map(|name| format!(\"{}\", name)).join(\"/\")).ok()?\n-            .join(&get_symbol_filename(db, definition)?).ok()?\n+            .join(&get_symbol_filename(db, &Definition::ModuleDef(def))?).ok()?\n             .into_string()\n     )\n }\n@@ -637,11 +613,20 @@ mod tests {\n \n     use crate::mock_analysis::analysis_and_position;\n \n-    fn trim_markup(s: &str) -> &str {\n-        s.trim_start_matches(\"```rust\\n\").trim_end_matches(\"\\n```\")\n+    fn trim_markup(s: &str) -> String {\n+        s\n+            .replace(\"``` rust\", \"```rust\")\n+            .replace(\"-----\", \"___\")\n+            .replace(\"\\n\\n___\\n\\n\", \"\\n___\\n\\n\")\n+            .replace(\"\\\\<-\", \"<-\")\n+            .trim_start_matches(\"test\\n```\\n\\n\")\n+            .trim_start_matches(\"```rust\\n\")\n+            .trim_start_matches(\"test\\n```\\n\\n```rust\\n\")\n+            .trim_end_matches(\"\\n```\")\n+            .to_string()\n     }\n \n-    fn trim_markup_opt(s: Option<&str>) -> Option<&str> {\n+    fn trim_markup_opt(s: Option<&str>) -> Option<String> {\n         s.map(trim_markup)\n     }\n \n@@ -689,7 +674,7 @@ fn main() {\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n         assert_eq!(hover.range, TextRange::new(58.into(), 63.into()));\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"u32\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()).as_deref(), Some(\"u32\"));\n     }\n \n     #[test]\n@@ -818,7 +803,7 @@ fn main() {\n                 };\n             }\n         \"#,\n-            &[\"Foo\\n```\\n\\n```rust\\nfield_a: u32\"],\n+            &[\"test::Foo\\n```\\n\\n```rust\\nfield_a: u32\"],\n         );\n \n         // Hovering over the field in the definition\n@@ -835,7 +820,7 @@ fn main() {\n                 };\n             }\n         \"#,\n-            &[\"Foo\\n```\\n\\n```rust\\nfield_a: u32\"],\n+            &[\"test::Foo\\n```\\n\\n```rust\\nfield_a: u32\"],\n         );\n     }\n \n@@ -888,7 +873,7 @@ fn main() {\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"Option\\n```\\n\\n```rust\\nSome\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()).as_deref(), Some(\"test::Option\\n```\\n\\n```rust\\nSome\"));\n \n         let (analysis, position) = analysis_and_position(\n             \"\n@@ -901,7 +886,7 @@ fn main() {\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"Option<i32>\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()).as_deref(), Some(\"Option<i32>\"));\n     }\n \n     #[test]\n@@ -915,7 +900,7 @@ fn main() {\n             }\n         \"#,\n             &[\"\n-Option\n+test::Option\n ```\n \n ```rust\n@@ -940,7 +925,7 @@ The None variant\n             }\n         \"#,\n             &[\"\n-Option\n+test::Option\n ```\n \n ```rust\n@@ -958,14 +943,14 @@ The Some variant\n     fn hover_for_local_variable() {\n         let (analysis, position) = analysis_and_position(\"fn func(foo: i32) { fo<|>o; }\");\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"i32\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()).as_deref(), Some(\"i32\"));\n     }\n \n     #[test]\n     fn hover_for_local_variable_pat() {\n         let (analysis, position) = analysis_and_position(\"fn func(fo<|>o: i32) {}\");\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"i32\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()).as_deref(), Some(\"i32\"));\n     }\n \n     #[test]\n@@ -976,14 +961,14 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"i32\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()).as_deref(), Some(\"i32\"));\n     }\n \n     #[test]\n     fn hover_for_param_edge() {\n         let (analysis, position) = analysis_and_position(\"fn func(<|>foo: i32) {}\");\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"i32\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()).as_deref(), Some(\"i32\"));\n     }\n \n     #[test]\n@@ -1004,7 +989,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"Thing\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()).as_deref(), Some(\"Thing\"));\n     }\n \n     #[test]\n@@ -1028,8 +1013,8 @@ fn func(foo: i32) { if true { <|>foo; }; }\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n         assert_eq!(\n-            trim_markup_opt(hover.info.first()),\n-            Some(\"wrapper::Thing\\n```\\n\\n```rust\\nfn new() -> Thing\")\n+            trim_markup_opt(hover.info.first()).as_deref(),\n+            Some(\"test::wrapper::Thing\\n```\\n\\n```rust\\nfn new() -> Thing\")\n         );\n     }\n \n@@ -1052,7 +1037,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"const C: u32\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()).as_deref(), Some(\"const C: u32\"));\n     }\n \n     #[test]\n@@ -1068,7 +1053,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n         \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"Thing\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()).as_deref(), Some(\"Thing\"));\n \n         /* FIXME: revive these tests\n                 let (analysis, position) = analysis_and_position(\n@@ -1125,7 +1110,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"i32\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()).as_deref(), Some(\"i32\"));\n     }\n \n     #[test]\n@@ -1142,7 +1127,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"macro_rules! foo\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()).as_deref(), Some(\"macro_rules! foo\"));\n     }\n \n     #[test]\n@@ -1153,7 +1138,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"i32\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()).as_deref(), Some(\"i32\"));\n     }\n \n     #[test]\n@@ -1414,6 +1399,59 @@ fn func(foo: i32) { if true { <|>foo; }; }\n         );\n     }\n \n+    #[test]\n+    fn test_hover_path_link() {\n+        check_hover_result(\n+            r\"\n+            //- /lib.rs\n+            pub struct Foo;\n+            /// [Foo](struct.Foo.html)\n+            pub struct B<|>ar\n+            \",\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[Foo](https://docs.rs/test/*/test/struct.Foo.html)\"]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_intra_link() {\n+        check_hover_result(\n+            r\"\n+            //- /lib.rs\n+            pub struct Foo;\n+            /// [Foo](Foo)\n+            pub struct B<|>ar\n+            \",\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[Foo](https://docs.rs/test/*/test/struct.Foo.html)\"]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_intra_link_shortlink() {\n+        check_hover_result(\n+            r\"\n+            //- /lib.rs\n+            pub struct Foo;\n+            /// [Foo]\n+            pub struct B<|>ar\n+            \",\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[Foo](https://docs.rs/test/*/test/struct.Foo.html)\"]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_intra_link_namespaced() {\n+        check_hover_result(\n+            r\"\n+            //- /lib.rs\n+            pub struct Foo;\n+            fn Foo() {}\n+            /// [Foo()]\n+            pub struct B<|>ar\n+            \",\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[Foo](https://docs.rs/test/*/test/struct.Foo.html)\"]\n+        );\n+    }\n+\n     #[test]\n     fn test_hover_macro_generated_struct_fn_doc_comment() {\n         mark::check!(hover_macro_generated_struct_fn_doc_comment);\n@@ -1438,7 +1476,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n                 bar.fo<|>o();\n             }\n             \"#,\n-            &[\"Bar\\n```\\n\\n```rust\\nfn foo(&self)\\n```\\n___\\n\\n Do the foo\"],\n+            &[\"test::Bar\\n```\\n\\n```rust\\nfn foo(&self)\\n```\\n___\\n\\nDo the foo\"],\n         );\n     }\n \n@@ -1466,7 +1504,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n                 bar.fo<|>o();\n             }\n             \"#,\n-            &[\"Bar\\n```\\n\\n```rust\\nfn foo(&self)\\n```\\n___\\n\\nDo the foo\"],\n+            &[\"test::Bar\\n```\\n\\n```rust\\nfn foo(&self)\\n```\\n___\\n\\nDo the foo\"],\n         );\n     }\n "}, {"sha": "490ee0dc35d5853d9349d505fc5d81b54f8c4a12", "filename": "crates/ra_ide/src/mock_analysis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d6f291335c58aac95c1124f55d7fb0834baff2a/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6f291335c58aac95c1124f55d7fb0834baff2a/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs?ref=1d6f291335c58aac95c1124f55d7fb0834baff2a", "patch": "@@ -99,7 +99,7 @@ impl MockAnalysis {\n                 root_crate = Some(crate_graph.add_crate_root(\n                     file_id,\n                     edition,\n-                    None,\n+                    Some(CrateName::new(\"test\").unwrap()),\n                     cfg,\n                     env,\n                     Default::default(),"}, {"sha": "b14206c9b35b7e10c9b70f7b13ae60533facc931", "filename": "crates/ra_ide_db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d6f291335c58aac95c1124f55d7fb0834baff2a/crates%2Fra_ide_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1d6f291335c58aac95c1124f55d7fb0834baff2a/crates%2Fra_ide_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2FCargo.toml?ref=1d6f291335c58aac95c1124f55d7fb0834baff2a", "patch": "@@ -24,6 +24,7 @@ ra_text_edit = { path = \"../ra_text_edit\" }\n ra_db = { path = \"../ra_db\" }\n ra_prof = { path = \"../ra_prof\" }\n test_utils = { path = \"../test_utils\" }\n+ra_hir_def = { path = \"../ra_hir_def\" }\n \n # ra_ide should depend only on the top-level `hir` package. if you need\n # something from some `hir_xxx` subpackage, reexport the API via `hir`."}, {"sha": "a158169e39c44217af0120a89ae892f370a2e34f", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1d6f291335c58aac95c1124f55d7fb0834baff2a/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6f291335c58aac95c1124f55d7fb0834baff2a/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=1d6f291335c58aac95c1124f55d7fb0834baff2a", "patch": "@@ -7,7 +7,7 @@\n \n use hir::{\n     Field, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, Name, PathResolution,\n-    Semantics, TypeParam, Visibility,\n+    Semantics, TypeParam, Visibility, db::{DefDatabase, HirDatabase},\n };\n use ra_prof::profile;\n use ra_syntax::{\n@@ -16,6 +16,7 @@ use ra_syntax::{\n };\n \n use crate::RootDatabase;\n+use ra_hir_def::resolver::{Resolver, HasResolver};\n \n // FIXME: a more precise name would probably be `Symbol`?\n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n@@ -76,6 +77,20 @@ impl Definition {\n         };\n         Some(name)\n     }\n+\n+    pub fn resolver<D: HirDatabase + DefDatabase>(&self, db: &D) -> Option<Resolver> {\n+        use hir::VariantDef;\n+        use ra_hir_def::*;\n+        Some(match self {\n+            Definition::ModuleDef(def) => def.resolver(db)?,\n+            Definition::Field(field) => Into::<VariantId>::into(Into::<VariantDef>::into(field.parent_def(db))).resolver(db),\n+            Definition::Macro(m) => Into::<ModuleId>::into(m.module(db)?).resolver(db),\n+            Definition::SelfType(imp) => Into::<ImplId>::into(imp.clone()).resolver(db),\n+            // it's possible, read probable, that other arms of this are also unreachable\n+            Definition::Local(_local) => unreachable!(),\n+            Definition::TypeParam(tp) => Into::<ModuleId>::into(tp.module(db)).resolver(db)\n+        })\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "6c0d3e19cfec5c6162da2a06ba3bc074159e7cb3", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d6f291335c58aac95c1124f55d7fb0834baff2a/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6f291335c58aac95c1124f55d7fb0834baff2a/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=1d6f291335c58aac95c1124f55d7fb0834baff2a", "patch": "@@ -4,8 +4,7 @@\n \n use std::{\n     io::Write as _,\n-    process::{self, Stdio},\n-    sync::Arc\n+    process::{self, Stdio}\n };\n \n use lsp_server::ErrorCode;"}]}