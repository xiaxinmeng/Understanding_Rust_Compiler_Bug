{"sha": "7d211e5b1287f9140418c4e46461c451d1da42e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMjExZTViMTI4N2Y5MTQwNDE4YzRlNDY0NjFjNDUxZDFkYTQyZTE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-12-09T19:05:22Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T07:26:13Z"}, "message": "rustc: rewrite ty::item_path to be more functional than mutation-oriented.", "tree": {"sha": "5a53bfa8e39173433fe526b289c48d1c1abe327c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a53bfa8e39173433fe526b289c48d1c1abe327c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d211e5b1287f9140418c4e46461c451d1da42e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d211e5b1287f9140418c4e46461c451d1da42e1", "html_url": "https://github.com/rust-lang/rust/commit/7d211e5b1287f9140418c4e46461c451d1da42e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d211e5b1287f9140418c4e46461c451d1da42e1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7505bb6bbb7d66f445d7df7afc7c397dadea26f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7505bb6bbb7d66f445d7df7afc7c397dadea26f8", "html_url": "https://github.com/rust-lang/rust/commit/7505bb6bbb7d66f445d7df7afc7c397dadea26f8"}], "stats": {"total": 301, "additions": 172, "deletions": 129}, "files": [{"sha": "1eb3952032a6de4044f08fc3a3210ed664d0e614", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 130, "deletions": 106, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/7d211e5b1287f9140418c4e46461c451d1da42e1/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d211e5b1287f9140418c4e46461c451d1da42e1/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=7d211e5b1287f9140418c4e46461c451d1da42e1", "patch": "@@ -65,10 +65,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 RootMode::Local\n             }\n         });\n-        let mut buffer = LocalPathBuffer::new(mode);\n-        debug!(\"item_path_str: buffer={:?} def_id={:?}\", buffer, def_id);\n-        self.push_item_path(&mut buffer, def_id);\n-        buffer.into_string()\n+        let mut printer = LocalPathPrinter::new(mode);\n+        debug!(\"item_path_str: printer={:?} def_id={:?}\", printer, def_id);\n+        self.print_item_path(&mut printer, def_id)\n     }\n \n     /// Returns a string identifying this local node-id.\n@@ -79,23 +78,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It always begins with a crate identifier.\n     pub fn absolute_item_path_str(self, def_id: DefId) -> String {\n-        let mut buffer = LocalPathBuffer::new(RootMode::Absolute);\n-        debug!(\"absolute_item_path_str: buffer={:?} def_id={:?}\", buffer, def_id);\n-        self.push_item_path(&mut buffer, def_id);\n-        buffer.into_string()\n+        let mut printer = LocalPathPrinter::new(RootMode::Absolute);\n+        debug!(\"absolute_item_path_str: printer={:?} def_id={:?}\", printer, def_id);\n+        self.print_item_path(&mut printer, def_id)\n     }\n \n     /// Returns the \"path\" to a particular crate. This can proceed in\n-    /// various ways, depending on the `root_mode` of the `buffer`.\n+    /// various ways, depending on the `root_mode` of the `printer`.\n     /// (See `RootMode` enum for more details.)\n-    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: CrateNum)\n-        where T: ItemPathBuffer + Debug\n+    fn print_krate_path<P>(\n+        self,\n+        printer: &mut P,\n+        cnum: CrateNum,\n+    ) -> P::Path\n+        where P: ItemPathPrinter + Debug\n     {\n         debug!(\n-            \"push_krate_path: buffer={:?} cnum={:?} LOCAL_CRATE={:?}\",\n-            buffer, cnum, LOCAL_CRATE\n+            \"print_krate_path: printer={:?} cnum={:?} LOCAL_CRATE={:?}\",\n+            printer, cnum, LOCAL_CRATE\n         );\n-        match *buffer.root_mode() {\n+        match printer.root_mode() {\n             RootMode::Local => {\n                 // In local mode, when we encounter a crate other than\n                 // LOCAL_CRATE, execution proceeds in one of two ways:\n@@ -117,56 +119,60 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                             span,\n                             ..\n                         }) if !span.is_dummy() => {\n-                            debug!(\"push_krate_path: def_id={:?}\", def_id);\n-                            self.push_item_path(buffer, def_id);\n+                            debug!(\"print_krate_path: def_id={:?}\", def_id);\n+                            self.print_item_path(printer, def_id)\n                         }\n                         _ => {\n                             let name = self.crate_name(cnum).as_str();\n-                            debug!(\"push_krate_path: name={:?}\", name);\n-                            buffer.push(&name);\n+                            debug!(\"print_krate_path: name={:?}\", name);\n+                            printer.path_crate(Some(&name))\n                         }\n                     }\n                 } else if self.sess.rust_2018() {\n                     // We add the `crate::` keyword on Rust 2018, only when desired.\n                     if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n-                        buffer.push(&keywords::Crate.name().as_str())\n+                        printer.path_crate(Some(&keywords::Crate.name().as_str()))\n+                    } else {\n+                        printer.path_crate(None)\n                     }\n+                } else {\n+                    printer.path_crate(None)\n                 }\n             }\n             RootMode::Absolute => {\n                 // In absolute mode, just write the crate name\n                 // unconditionally.\n                 let name = self.original_crate_name(cnum).as_str();\n-                debug!(\"push_krate_path: original_name={:?}\", name);\n-                buffer.push(&name);\n+                debug!(\"print_krate_path: original_name={:?}\", name);\n+                printer.path_crate(Some(&name))\n             }\n         }\n     }\n \n-    /// If possible, this pushes a global path resolving to `external_def_id` that is visible\n+    /// If possible, this returns a global path resolving to `external_def_id` that is visible\n     /// from at least one local module and returns true. If the crate defining `external_def_id` is\n     /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n-    pub fn try_push_visible_item_path<T>(\n+    fn try_print_visible_item_path<P>(\n         self,\n-        buffer: &mut T,\n+        printer: &mut P,\n         external_def_id: DefId,\n-    ) -> bool\n-        where T: ItemPathBuffer + Debug\n+    ) -> Option<P::Path>\n+        where P: ItemPathPrinter + Debug\n     {\n         debug!(\n-            \"try_push_visible_item_path: buffer={:?} external_def_id={:?}\",\n-            buffer, external_def_id\n+            \"try_print_visible_item_path: printer={:?} external_def_id={:?}\",\n+            printer, external_def_id\n         );\n         let visible_parent_map = self.visible_parent_map(LOCAL_CRATE);\n \n         let (mut cur_def, mut cur_path) = (external_def_id, Vec::<LocalInternedString>::new());\n         loop {\n             debug!(\n-                \"try_push_visible_item_path: cur_def={:?} cur_path={:?} CRATE_DEF_INDEX={:?}\",\n+                \"try_print_visible_item_path: cur_def={:?} cur_path={:?} CRATE_DEF_INDEX={:?}\",\n                 cur_def, cur_path, CRATE_DEF_INDEX,\n             );\n-            // If `cur_def` is a direct or injected extern crate, push the path to the crate\n-            // followed by the path to the item within the crate and return.\n+            // If `cur_def` is a direct or injected extern crate, return the path to the crate\n+            // followed by the path to the item within the crate.\n             if cur_def.index == CRATE_DEF_INDEX {\n                 match *self.extern_crate(cur_def) {\n                     Some(ExternCrate {\n@@ -175,26 +181,32 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         span,\n                         ..\n                     }) => {\n-                        debug!(\"try_push_visible_item_path: def_id={:?}\", def_id);\n-                        if !span.is_dummy() {\n-                            self.push_item_path(buffer, def_id);\n+                        debug!(\"try_print_visible_item_path: def_id={:?}\", def_id);\n+                        let path = if !span.is_dummy() {\n+                            self.print_item_path(printer, def_id)\n                         } else {\n-                            buffer.push(&self.crate_name(cur_def.krate).as_str());\n-                        }\n-                        cur_path.iter().rev().for_each(|segment| buffer.push(&segment));\n-                        return true;\n+                            printer.path_crate(Some(\n+                                &self.crate_name(cur_def.krate).as_str(),\n+                            ))\n+                        };\n+                        return Some(cur_path.iter().rev().fold(path, |path, segment| {\n+                            printer.path_append(path, &segment)\n+                        }));\n                     }\n                     None => {\n-                        buffer.push(&self.crate_name(cur_def.krate).as_str());\n-                        cur_path.iter().rev().for_each(|segment| buffer.push(&segment));\n-                        return true;\n+                        let path = printer.path_crate(Some(\n+                            &self.crate_name(cur_def.krate).as_str(),\n+                        ));\n+                        return Some(cur_path.iter().rev().fold(path, |path, segment| {\n+                            printer.path_append(path, &segment)\n+                        }));\n                     }\n                     _ => {},\n                 }\n             }\n \n             let mut cur_def_key = self.def_key(cur_def);\n-            debug!(\"try_push_visible_item_path: cur_def_key={:?}\", cur_def_key);\n+            debug!(\"try_print_visible_item_path: cur_def_key={:?}\", cur_def_key);\n \n             // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n             if let DefPathData::StructCtor = cur_def_key.disambiguated_data.data {\n@@ -211,7 +223,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             let data = cur_def_key.disambiguated_data.data;\n             debug!(\n-                \"try_push_visible_item_path: data={:?} visible_parent={:?} actual_parent={:?}\",\n+                \"try_print_visible_item_path: data={:?} visible_parent={:?} actual_parent={:?}\",\n                 data, visible_parent, actual_parent,\n             );\n             let symbol = match data {\n@@ -268,39 +280,44 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     })\n                 },\n             };\n-            debug!(\"try_push_visible_item_path: symbol={:?}\", symbol);\n+            debug!(\"try_print_visible_item_path: symbol={:?}\", symbol);\n             cur_path.push(symbol);\n \n-            match visible_parent {\n-                Some(def) => cur_def = def,\n-                None => return false,\n-            };\n+            cur_def = visible_parent?;\n         }\n     }\n \n-    pub fn push_item_path<T>(self, buffer: &mut T, def_id: DefId)\n-        where T: ItemPathBuffer + Debug\n+    pub fn print_item_path<P>(\n+        self,\n+        printer: &mut P,\n+        def_id: DefId,\n+    ) -> P::Path\n+        where P: ItemPathPrinter + Debug\n     {\n         debug!(\n-            \"push_item_path: buffer={:?} def_id={:?}\",\n-            buffer, def_id\n+            \"print_item_path: printer={:?} def_id={:?}\",\n+            printer, def_id\n         );\n-        match *buffer.root_mode() {\n-            RootMode::Local if !def_id.is_local() =>\n-                if self.try_push_visible_item_path(buffer, def_id) { return },\n+        match printer.root_mode() {\n+            RootMode::Local if !def_id.is_local() => {\n+                match self.try_print_visible_item_path(printer, def_id) {\n+                    Some(path) => return path,\n+                    None => {}\n+                }\n+            }\n             _ => {}\n         }\n \n         let key = self.def_key(def_id);\n-        debug!(\"push_item_path: key={:?}\", key);\n+        debug!(\"print_item_path: key={:?}\", key);\n         match key.disambiguated_data.data {\n             DefPathData::CrateRoot => {\n                 assert!(key.parent.is_none());\n-                self.push_krate_path(buffer, def_id.krate);\n+                self.print_krate_path(printer, def_id.krate)\n             }\n \n             DefPathData::Impl => {\n-                self.push_impl_path(buffer, def_id);\n+                self.print_impl_path(printer, def_id)\n             }\n \n             // Unclear if there is any value in distinguishing these.\n@@ -325,26 +342,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::ClosureExpr |\n             data @ DefPathData::ImplTrait |\n             data @ DefPathData::GlobalMetaData(..) => {\n-                let parent_def_id = self.parent_def_id(def_id).unwrap();\n-                self.push_item_path(buffer, parent_def_id);\n-                buffer.push(&data.as_interned_str().as_symbol().as_str());\n+                let parent_did = self.parent_def_id(def_id).unwrap();\n+                let path = self.print_item_path(printer, parent_did);\n+                printer.path_append(path, &data.as_interned_str().as_symbol().as_str())\n             },\n \n             DefPathData::StructCtor => { // present `X` instead of `X::{{constructor}}`\n                 let parent_def_id = self.parent_def_id(def_id).unwrap();\n-                self.push_item_path(buffer, parent_def_id);\n+                self.print_item_path(printer, parent_def_id)\n             }\n         }\n     }\n \n-    fn push_impl_path<T>(\n+    fn print_impl_path<P>(\n         self,\n-        buffer: &mut T,\n+        printer: &mut P,\n         impl_def_id: DefId,\n-    )\n-        where T: ItemPathBuffer + Debug\n+    ) -> P::Path\n+        where P: ItemPathPrinter + Debug\n     {\n-        debug!(\"push_impl_path: buffer={:?} impl_def_id={:?}\", buffer, impl_def_id);\n+        debug!(\"print_impl_path: printer={:?} impl_def_id={:?}\", printer, impl_def_id);\n         let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n \n         // Always use types for non-local impls, where types are always\n@@ -356,7 +373,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         if !use_types {\n-            return self.push_impl_path_fallback(buffer, impl_def_id);\n+            return self.print_impl_path_fallback(printer, impl_def_id);\n         }\n \n         // Decide whether to print the parent path for the impl.\n@@ -380,69 +397,68 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // If the impl is not co-located with either self-type or\n             // trait-type, then fallback to a format that identifies\n             // the module more clearly.\n-            self.push_item_path(buffer, parent_def_id);\n+            let path = self.print_item_path(printer, parent_def_id);\n             if let Some(trait_ref) = impl_trait_ref {\n-                buffer.push(&format!(\"<impl {} for {}>\", trait_ref, self_ty));\n+                return printer.path_append(path, &format!(\"<impl {} for {}>\", trait_ref, self_ty));\n             } else {\n-                buffer.push(&format!(\"<impl {}>\", self_ty));\n+                return printer.path_append(path, &format!(\"<impl {}>\", self_ty));\n             }\n-            return;\n         }\n \n         // Otherwise, try to give a good form that would be valid language\n         // syntax. Preferably using associated item notation.\n \n         if let Some(trait_ref) = impl_trait_ref {\n             // Trait impls.\n-            buffer.push(&format!(\"<{} as {}>\", self_ty, trait_ref));\n-            return;\n+            return printer.path_impl(&format!(\"<{} as {}>\", self_ty, trait_ref));\n         }\n \n         // Inherent impls. Try to print `Foo::bar` for an inherent\n         // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n         // anything other than a simple path.\n         match self_ty.sty {\n             ty::Adt(adt_def, substs) => {\n+                // FIXME(eddyb) always print without <> here.\n                 if substs.types().next().is_none() { // ignore regions\n-                    self.push_item_path(buffer, adt_def.did);\n+                    self.print_item_path(printer, adt_def.did)\n                 } else {\n-                    buffer.push(&format!(\"<{}>\", self_ty));\n+                    printer.path_impl(&format!(\"<{}>\", self_ty))\n                 }\n             }\n \n-            ty::Foreign(did) => self.push_item_path(buffer, did),\n+            ty::Foreign(did) => self.print_item_path(printer, did),\n \n             ty::Bool |\n             ty::Char |\n             ty::Int(_) |\n             ty::Uint(_) |\n             ty::Float(_) |\n             ty::Str => {\n-                buffer.push(&self_ty.to_string());\n+                printer.path_impl(&self_ty.to_string())\n             }\n \n             _ => {\n-                buffer.push(&format!(\"<{}>\", self_ty));\n+                printer.path_impl(&format!(\"<{}>\", self_ty))\n             }\n         }\n     }\n \n-    fn push_impl_path_fallback<T>(\n+    fn print_impl_path_fallback<P>(\n         self,\n-        buffer: &mut T,\n+        printer: &mut P,\n         impl_def_id: DefId,\n-    )\n-        where T: ItemPathBuffer + Debug\n+    ) -> P::Path\n+        where P: ItemPathPrinter + Debug\n     {\n         // If no type info is available, fall back to\n         // pretty printing some span information. This should\n         // only occur very early in the compiler pipeline.\n         let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n-        self.push_item_path(buffer, parent_def_id);\n+        let path = self.print_item_path(printer, parent_def_id);\n         let hir_id = self.hir().as_local_hir_id(impl_def_id).unwrap();\n         let item = self.hir().expect_item_by_hir_id(hir_id);\n         let span_str = self.sess.source_map().span_to_string(item.span);\n-        buffer.push(&format!(\"<impl at {}>\", span_str));\n+        printer.path_append(path, &format!(\"<impl at {}>\", span_str))\n     }\n \n     /// Returns the `DefId` of `def_id`'s parent in the def tree. If\n@@ -505,12 +521,17 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n /// Unifying Trait for different kinds of item paths we might\n /// construct. The basic interface is that components get pushed: the\n /// instance can also customize how we handle the root of a crate.\n-pub trait ItemPathBuffer {\n-    fn root_mode(&self) -> &RootMode;\n-    fn push(&mut self, text: &str);\n+pub trait ItemPathPrinter {\n+    type Path;\n+\n+    fn root_mode(&self) -> RootMode;\n+\n+    fn path_crate(&self, name: Option<&str>) -> Self::Path;\n+    fn path_impl(&self, text: &str) -> Self::Path;\n+    fn path_append(&self, path: Self::Path, text: &str) -> Self::Path;\n }\n \n-#[derive(Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum RootMode {\n     /// Try to make a path relative to the local crate. In\n     /// particular, local paths have no prefix, and if the path comes\n@@ -524,33 +545,36 @@ pub enum RootMode {\n }\n \n #[derive(Debug)]\n-struct LocalPathBuffer {\n+struct LocalPathPrinter {\n     root_mode: RootMode,\n-    str: String,\n }\n \n-impl LocalPathBuffer {\n-    fn new(root_mode: RootMode) -> LocalPathBuffer {\n-        LocalPathBuffer {\n+impl LocalPathPrinter {\n+    fn new(root_mode: RootMode) -> LocalPathPrinter {\n+        LocalPathPrinter {\n             root_mode,\n-            str: String::new(),\n         }\n     }\n-\n-    fn into_string(self) -> String {\n-        self.str\n-    }\n }\n \n-impl ItemPathBuffer for LocalPathBuffer {\n-    fn root_mode(&self) -> &RootMode {\n-        &self.root_mode\n+impl ItemPathPrinter for LocalPathPrinter {\n+    type Path = String;\n+\n+    fn root_mode(&self) -> RootMode {\n+        self.root_mode\n     }\n \n-    fn push(&mut self, text: &str) {\n-        if !self.str.is_empty() {\n-            self.str.push_str(\"::\");\n+    fn path_crate(&self, name: Option<&str>) -> Self::Path {\n+        name.unwrap_or(\"\").to_string()\n+    }\n+    fn path_impl(&self, text: &str) -> Self::Path {\n+        text.to_string()\n+    }\n+    fn path_append(&self, mut path: Self::Path, text: &str) -> Self::Path {\n+        if !path.is_empty() {\n+            path.push_str(\"::\");\n         }\n-        self.str.push_str(text);\n+        path.push_str(text);\n+        path\n     }\n }"}, {"sha": "13f8e13c3288d163a1d6a605cf53ef69da0c57be", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 42, "deletions": 23, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7d211e5b1287f9140418c4e46461c451d1da42e1/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d211e5b1287f9140418c4e46461c451d1da42e1/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=7d211e5b1287f9140418c4e46461c451d1da42e1", "patch": "@@ -92,7 +92,7 @@ use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::ich::NodeIdHashingMode;\n-use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n+use rustc::ty::item_path::{self, ItemPathPrinter, RootMode};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -223,11 +223,9 @@ fn get_symbol_hash<'a, 'tcx>(\n }\n \n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n-    let mut buffer = SymbolPathBuffer::new(tcx);\n     item_path::with_forced_absolute_paths(|| {\n-        tcx.push_item_path(&mut buffer, def_id);\n-    });\n-    buffer.into_interned()\n+        tcx.push_item_path(&mut SymbolPath::new(tcx), def_id).into_interned()\n+    })\n }\n \n fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>) -> ty::SymbolName {\n@@ -319,7 +317,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n \n     let hash = get_symbol_hash(tcx, def_id, instance, instance_ty, substs);\n \n-    let mut buf = SymbolPathBuffer::from_interned(tcx.def_symbol_name(def_id), tcx);\n+    let mut buf = SymbolPath::from_interned(tcx.def_symbol_name(def_id), tcx);\n \n     if instance.is_vtable_shim() {\n         buf.push(\"{{vtable-shim}}\");\n@@ -342,15 +340,15 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n // To be able to work on all platforms and get *some* reasonable output, we\n // use C++ name-mangling.\n #[derive(Debug)]\n-struct SymbolPathBuffer {\n+struct SymbolPath {\n     result: String,\n     temp_buf: String,\n     strict_naming: bool,\n }\n \n-impl SymbolPathBuffer {\n+impl SymbolPath {\n     fn new(tcx: TyCtxt<'_, '_, '_>) -> Self {\n-        let mut result = SymbolPathBuffer {\n+        let mut result = SymbolPath {\n             result: String::with_capacity(64),\n             temp_buf: String::with_capacity(16),\n             strict_naming: tcx.has_strict_asm_symbol_naming(),\n@@ -360,7 +358,7 @@ impl SymbolPathBuffer {\n     }\n \n     fn from_interned(symbol: ty::SymbolName, tcx: TyCtxt<'_, '_, '_>) -> Self {\n-        let mut result = SymbolPathBuffer {\n+        let mut result = SymbolPath {\n             result: String::with_capacity(64),\n             temp_buf: String::with_capacity(16),\n             strict_naming: tcx.has_strict_asm_symbol_naming(),\n@@ -375,19 +373,6 @@ impl SymbolPathBuffer {\n         }\n     }\n \n-    fn finish(mut self, hash: u64) -> String {\n-        // E = end name-sequence\n-        let _ = write!(self.result, \"17h{:016x}E\", hash);\n-        self.result\n-    }\n-}\n-\n-impl ItemPathBuffer for SymbolPathBuffer {\n-    fn root_mode(&self) -> &RootMode {\n-        const ABSOLUTE: &RootMode = &RootMode::Absolute;\n-        ABSOLUTE\n-    }\n-\n     fn push(&mut self, text: &str) {\n         self.temp_buf.clear();\n         let need_underscore = sanitize(&mut self.temp_buf, text, self.strict_naming);\n@@ -401,6 +386,40 @@ impl ItemPathBuffer for SymbolPathBuffer {\n         }\n         self.result.push_str(&self.temp_buf);\n     }\n+\n+    fn finish(mut self, hash: u64) -> String {\n+        // E = end name-sequence\n+        let _ = write!(self.result, \"17h{:016x}E\", hash);\n+        self.result\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct SymbolPathPrinter;\n+\n+impl ItemPathPrinter for SymbolPathPrinter {\n+    type Path = SymbolPath;\n+\n+    fn root_mode(&self) ->RootMode {\n+        RootMode::Absolute\n+    }\n+\n+    fn path_crate(&self, name: Option<&str>) -> Self::Path {\n+        let mut path = SymbolPath::new();\n+        if let Some(name) = name {\n+            path.push(name);\n+        }\n+        path\n+    }\n+    fn path_impl(&self, text: &str) -> Self::Path {\n+        let mut path = SymbolPath::new();\n+        path.push(text);\n+        path\n+    }\n+    fn path_append(&self, mut path: Self::Path, text: &str) -> Self::Path {\n+        path.push(text);\n+        path\n+    }\n }\n \n // Name sanitation. LLVM will happily accept identifiers with weird names, but"}]}