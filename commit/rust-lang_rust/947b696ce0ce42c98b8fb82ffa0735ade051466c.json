{"sha": "947b696ce0ce42c98b8fb82ffa0735ade051466c", "node_id": "C_kwDOAAsO6NoAKDk0N2I2OTZjZTBjZTQyYzk4YjhmYjgyZmZhMDczNWFkZTA1MTQ2NmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-16T22:10:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-16T22:10:10Z"}, "message": "Auto merge of #107833 - Zoxc:arena-query-clean, r=cjgillot\n\nFactor query arena allocation out from query caches\n\nThis moves the logic for arena allocation out from the query caches into conditional code in the query system. The specialized arena caches are removed. A new `QuerySystem` type is added in `rustc_middle` which contains the arenas, providers and query caches.\n\nPerformance seems to be slightly regressed:\n<table><tr><td rowspan=\"2\">Benchmark</td><td colspan=\"1\"><b>Before</b></th><td colspan=\"2\"><b>After</b></th></tr><tr><td align=\"right\">Time</td><td align=\"right\">Time</td><td align=\"right\">%</th></tr><tr><td>\ud83d\udfe3 <b>clap</b>:check</td><td align=\"right\">1.8053s</td><td align=\"right\">1.8109s</td><td align=\"right\"> 0.31%</td></tr><tr><td>\ud83d\udfe3 <b>hyper</b>:check</td><td align=\"right\">0.2600s</td><td align=\"right\">0.2597s</td><td align=\"right\"> -0.10%</td></tr><tr><td>\ud83d\udfe3 <b>regex</b>:check</td><td align=\"right\">0.9973s</td><td align=\"right\">1.0006s</td><td align=\"right\"> 0.34%</td></tr><tr><td>\ud83d\udfe3 <b>syn</b>:check</td><td align=\"right\">1.6048s</td><td align=\"right\">1.6051s</td><td align=\"right\"> 0.02%</td></tr><tr><td>\ud83d\udfe3 <b>syntex_syntax</b>:check</td><td align=\"right\">6.2992s</td><td align=\"right\">6.3159s</td><td align=\"right\"> 0.26%</td></tr><tr><td>Total</td><td align=\"right\">10.9664s</td><td align=\"right\">10.9922s</td><td align=\"right\"> 0.23%</td></tr><tr><td>Summary</td><td align=\"right\">1.0000s</td><td align=\"right\">1.0017s</td><td align=\"right\"> 0.17%</td></tr></table>\n\nIncremental performance is a bit worse:\n<table><tr><td rowspan=\"2\">Benchmark</td><td colspan=\"1\"><b>Before</b></th><td colspan=\"2\"><b>After</b></th></tr><tr><td align=\"right\">Time</td><td align=\"right\">Time</td><td align=\"right\">%</th></tr><tr><td>\ud83d\udfe3 <b>clap</b>:check:initial</td><td align=\"right\">2.2103s</td><td align=\"right\">2.2247s</td><td align=\"right\"> 0.65%</td></tr><tr><td>\ud83d\udfe3 <b>hyper</b>:check:initial</td><td align=\"right\">0.3335s</td><td align=\"right\">0.3349s</td><td align=\"right\"> 0.41%</td></tr><tr><td>\ud83d\udfe3 <b>regex</b>:check:initial</td><td align=\"right\">1.2597s</td><td align=\"right\">1.2650s</td><td align=\"right\"> 0.42%</td></tr><tr><td>\ud83d\udfe3 <b>syn</b>:check:initial</td><td align=\"right\">2.0521s</td><td align=\"right\">2.0613s</td><td align=\"right\"> 0.45%</td></tr><tr><td>\ud83d\udfe3 <b>syntex_syntax</b>:check:initial</td><td align=\"right\">7.8275s</td><td align=\"right\">7.8583s</td><td align=\"right\"> 0.39%</td></tr><tr><td>Total</td><td align=\"right\">13.6832s</td><td align=\"right\">13.7442s</td><td align=\"right\"> 0.45%</td></tr><tr><td>Summary</td><td align=\"right\">1.0000s</td><td align=\"right\">1.0046s</td><td align=\"right\"> 0.46%</td></tr></table>\n\nIt does seem like LLVM optimizers struggle a bit with the current state of the query system.\n\nBased on top of https://github.com/rust-lang/rust/pull/107782 and https://github.com/rust-lang/rust/pull/107802.\n\nr? `@cjgillot`", "tree": {"sha": "35768557e506f47a11e729260131ab417143b1c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35768557e506f47a11e729260131ab417143b1c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/947b696ce0ce42c98b8fb82ffa0735ade051466c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/947b696ce0ce42c98b8fb82ffa0735ade051466c", "html_url": "https://github.com/rust-lang/rust/commit/947b696ce0ce42c98b8fb82ffa0735ade051466c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/947b696ce0ce42c98b8fb82ffa0735ade051466c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a7cc6c32f1a690f86827e4724bcda85e506ef35", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a7cc6c32f1a690f86827e4724bcda85e506ef35", "html_url": "https://github.com/rust-lang/rust/commit/9a7cc6c32f1a690f86827e4724bcda85e506ef35"}, {"sha": "caf29b27277fd4fca4b372938e2fecf12dd12c78", "url": "https://api.github.com/repos/rust-lang/rust/commits/caf29b27277fd4fca4b372938e2fecf12dd12c78", "html_url": "https://github.com/rust-lang/rust/commit/caf29b27277fd4fca4b372938e2fecf12dd12c78"}], "stats": {"total": 386, "additions": 147, "deletions": 239}, "files": [{"sha": "0bacf51e9119a9daa449faeaf5a34146b7a591db", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=947b696ce0ce42c98b8fb82ffa0735ade051466c", "patch": "@@ -114,7 +114,7 @@ macro_rules! provide_one {\n         fn $name<'tcx>(\n             $tcx: TyCtxt<'tcx>,\n             def_id_arg: ty::query::query_keys::$name<'tcx>,\n-        ) -> ty::query::query_values::$name<'tcx> {\n+        ) -> ty::query::query_provided::$name<'tcx> {\n             let _prof_timer =\n                 $tcx.prof.generic_activity(concat!(\"metadata_decode_entry_\", stringify!($name)));\n "}, {"sha": "b37c3e5cf2cbce62c1d215654aa0040d4fac728b", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=947b696ce0ce42c98b8fb82ffa0735ade051466c", "patch": "@@ -520,7 +520,7 @@ pub struct GlobalCtxt<'tcx> {\n     pub on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n \n     pub queries: &'tcx dyn query::QueryEngine<'tcx>,\n-    pub query_caches: query::QueryCaches<'tcx>,\n+    pub query_system: query::QuerySystem<'tcx>,\n     pub(crate) query_kinds: &'tcx [DepKindStruct<'tcx>],\n \n     // Internal caches for metadata decoding. No need to track deps on this.\n@@ -705,7 +705,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             untracked,\n             on_disk_cache,\n             queries,\n-            query_caches: query::QueryCaches::default(),\n+            query_system: Default::default(),\n             query_kinds,\n             ty_rcache: Default::default(),\n             pred_rcache: Default::default(),"}, {"sha": "5c45cc389ee64ecb1e0604e9f329e9b1925dbbbe", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 80, "deletions": 20, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=947b696ce0ce42c98b8fb82ffa0735ade051466c", "patch": "@@ -1,3 +1,5 @@\n+#![allow(unused_parens)]\n+\n use crate::dep_graph;\n use crate::infer::canonical::{self, Canonical};\n use crate::lint::LintExpectation;\n@@ -34,13 +36,15 @@ use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::GeneratorDiagnosticData;\n use crate::ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt, UnusedGenericParams};\n+use rustc_arena::TypedArena;\n use rustc_ast as ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::WorkerLocal;\n use rustc_data_structures::unord::UnordSet;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n@@ -59,13 +63,20 @@ use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi;\n use rustc_target::spec::PanicStrategy;\n+use std::mem;\n use std::ops::Deref;\n use std::path::PathBuf;\n use std::sync::Arc;\n \n pub(crate) use rustc_query_system::query::QueryJobId;\n use rustc_query_system::query::*;\n \n+#[derive(Default)]\n+pub struct QuerySystem<'tcx> {\n+    pub arenas: QueryArenas<'tcx>,\n+    pub caches: QueryCaches<'tcx>,\n+}\n+\n #[derive(Copy, Clone)]\n pub struct TyCtxtAt<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n@@ -112,10 +123,10 @@ macro_rules! query_helper_param_ty {\n }\n \n macro_rules! query_if_arena {\n-    ([] $arena:ty, $no_arena:ty) => {\n+    ([] $arena:tt $no_arena:tt) => {\n         $no_arena\n     };\n-    ([(arena_cache) $($rest:tt)*] $arena:ty, $no_arena:ty) => {\n+    ([(arena_cache) $($rest:tt)*] $arena:tt $no_arena:tt) => {\n         $arena\n     };\n     ([$other:tt $($modifiers:tt)*]$($args:tt)*) => {\n@@ -131,7 +142,7 @@ macro_rules! separate_provide_extern_decl {\n         for<'tcx> fn(\n             TyCtxt<'tcx>,\n             query_keys::$name<'tcx>,\n-        ) -> query_values::$name<'tcx>\n+        ) -> query_provided::$name<'tcx>\n     };\n     ([$other:tt $($modifiers:tt)*][$($args:tt)*]) => {\n         separate_provide_extern_decl!([$($modifiers)*][$($args)*])\n@@ -183,30 +194,77 @@ macro_rules! define_callbacks {\n \n             $(pub type $name<'tcx> = $($K)*;)*\n         }\n-        #[allow(nonstandard_style, unused_lifetimes, unused_parens)]\n+        #[allow(nonstandard_style, unused_lifetimes)]\n         pub mod query_values {\n             use super::*;\n \n-            $(pub type $name<'tcx> = query_if_arena!([$($modifiers)*] <$V as Deref>::Target, $V);)*\n+            $(pub type $name<'tcx> = $V;)*\n         }\n-        #[allow(nonstandard_style, unused_lifetimes, unused_parens)]\n-        pub mod query_storage {\n+\n+        /// This module specifies the type returned from query providers and the type used for\n+        /// decoding. For regular queries this is the declared returned type `V`, but\n+        /// `arena_cache` will use `<V as Deref>::Target` instead.\n+        #[allow(nonstandard_style, unused_lifetimes)]\n+        pub mod query_provided {\n             use super::*;\n \n             $(\n-                pub type $name<'tcx> = query_if_arena!([$($modifiers)*]\n-                    <<$($K)* as Key>::CacheSelector\n-                        as CacheSelector<'tcx, <$V as Deref>::Target>>::ArenaCache,\n-                    <<$($K)* as Key>::CacheSelector as CacheSelector<'tcx, $V>>::Cache\n-                );\n+                pub type $name<'tcx> = query_if_arena!([$($modifiers)*] (<$V as Deref>::Target) ($V));\n             )*\n         }\n \n+        /// This module has a function per query which takes a `query_provided` value and coverts\n+        /// it to a regular `V` value by allocating it on an arena if the query has the\n+        /// `arena_cache` modifier. This will happen when computing the query using a provider or\n+        /// decoding a stored result.\n         #[allow(nonstandard_style, unused_lifetimes)]\n-        pub mod query_stored {\n+        pub mod query_provided_to_value {\n             use super::*;\n \n-            $(pub type $name<'tcx> = $V;)*\n+            $(\n+                #[inline(always)]\n+                pub fn $name<'tcx>(\n+                    _tcx: TyCtxt<'tcx>,\n+                    value: query_provided::$name<'tcx>,\n+                ) -> query_values::$name<'tcx> {\n+                    query_if_arena!([$($modifiers)*]\n+                        {\n+                            if mem::needs_drop::<query_provided::$name<'tcx>>() {\n+                                &*_tcx.query_system.arenas.$name.alloc(value)\n+                            } else {\n+                                &*_tcx.arena.dropless.alloc(value)\n+                            }\n+                        }\n+                        (value)\n+                    )\n+                }\n+            )*\n+        }\n+        #[allow(nonstandard_style, unused_lifetimes)]\n+        pub mod query_storage {\n+            use super::*;\n+\n+            $(\n+                pub type $name<'tcx> = <<$($K)* as Key>::CacheSelector as CacheSelector<'tcx, $V>>::Cache;\n+            )*\n+        }\n+\n+        pub struct QueryArenas<'tcx> {\n+            $($(#[$attr])* pub $name: query_if_arena!([$($modifiers)*]\n+                (WorkerLocal<TypedArena<<$V as Deref>::Target>>)\n+                ()\n+            ),)*\n+        }\n+\n+        impl Default for QueryArenas<'_> {\n+            fn default() -> Self {\n+                Self {\n+                    $($name: query_if_arena!([$($modifiers)*]\n+                        (WorkerLocal::new(|_| Default::default()))\n+                        ()\n+                    ),)*\n+                }\n+            }\n         }\n \n         #[derive(Default)]\n@@ -221,7 +279,7 @@ macro_rules! define_callbacks {\n                 let key = key.into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n-                match try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key) {\n+                match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n                     Some(_) => return,\n                     None => self.tcx.queries.$name(self.tcx, DUMMY_SP, key, QueryMode::Ensure),\n                 };\n@@ -246,7 +304,7 @@ macro_rules! define_callbacks {\n                 let key = key.into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n-                match try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key) {\n+                match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n                     Some(value) => value,\n                     None => self.tcx.queries.$name(self.tcx, self.span, key, QueryMode::Get).unwrap(),\n                 }\n@@ -257,7 +315,7 @@ macro_rules! define_callbacks {\n             $(pub $name: for<'tcx> fn(\n                 TyCtxt<'tcx>,\n                 query_keys::$name<'tcx>,\n-            ) -> query_values::$name<'tcx>,)*\n+            ) -> query_provided::$name<'tcx>,)*\n         }\n \n         pub struct ExternProviders {\n@@ -334,12 +392,13 @@ macro_rules! define_feedable {\n         $(impl<'tcx, K: IntoQueryParam<$($K)*> + Copy> TyCtxtFeed<'tcx, K> {\n             $(#[$attr])*\n             #[inline(always)]\n-            pub fn $name(self, value: query_values::$name<'tcx>) -> $V {\n+            pub fn $name(self, value: query_provided::$name<'tcx>) -> $V {\n                 let key = self.key().into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n                 let tcx = self.tcx;\n-                let cache = &tcx.query_caches.$name;\n+                let value = query_provided_to_value::$name(tcx, value);\n+                let cache = &tcx.query_system.caches.$name;\n \n                 match try_get_cached(tcx, cache, &key) {\n                     Some(old) => {\n@@ -357,7 +416,8 @@ macro_rules! define_feedable {\n                             &value,\n                             hash_result!([$($modifiers)*]),\n                         );\n-                        cache.complete(key, value, dep_node_index)\n+                        cache.complete(key, value, dep_node_index);\n+                        value\n                     }\n                 }\n             }"}, {"sha": "d7708a3bc3f42a59147006b024fbc0b7f56f5bb1", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=947b696ce0ce42c98b8fb82ffa0735ade051466c", "patch": "@@ -21,7 +21,9 @@ use rustc_data_structures::sync::AtomicU64;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::{self, DepKindStruct};\n use rustc_middle::query::Key;\n-use rustc_middle::ty::query::{query_keys, query_storage, query_stored, query_values};\n+use rustc_middle::ty::query::{\n+    query_keys, query_provided, query_provided_to_value, query_storage, query_values,\n+};\n use rustc_middle::ty::query::{ExternProviders, Providers, QueryEngine};\n use rustc_middle::ty::TyCtxt;\n use rustc_span::Span;"}, {"sha": "532c1b52f53567173d8d0af819d9bbf4a2edf14a", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=947b696ce0ce42c98b8fb82ffa0735ade051466c", "patch": "@@ -293,14 +293,14 @@ macro_rules! get_provider {\n }\n \n macro_rules! should_ever_cache_on_disk {\n-    ([]) => {{\n-        None\n+    ([]$yes:tt $no:tt) => {{\n+        $no\n     }};\n-    ([(cache) $($rest:tt)*]) => {{\n-        Some($crate::plumbing::try_load_from_disk::<Self::Value>)\n+    ([(cache) $($rest:tt)*]$yes:tt $no:tt) => {{\n+        $yes\n     }};\n-    ([$other:tt $($modifiers:tt)*]) => {\n-        should_ever_cache_on_disk!([$($modifiers)*])\n+    ([$other:tt $($modifiers:tt)*]$yes:tt $no:tt) => {\n+        should_ever_cache_on_disk!([$($modifiers)*]$yes $no)\n     };\n }\n \n@@ -472,7 +472,6 @@ macro_rules! define_queries {\n         $(impl<'tcx> QueryConfig<QueryCtxt<'tcx>> for queries::$name<'tcx> {\n             type Key = query_keys::$name<'tcx>;\n             type Value = query_values::$name<'tcx>;\n-            type Stored = query_stored::$name<'tcx>;\n             const NAME: &'static str = stringify!($name);\n \n             #[inline]\n@@ -493,24 +492,39 @@ macro_rules! define_queries {\n             fn query_cache<'a>(tcx: QueryCtxt<'tcx>) -> &'a Self::Cache\n                 where 'tcx:'a\n             {\n-                &tcx.query_caches.$name\n+                &tcx.query_system.caches.$name\n             }\n \n-            fn execute_query(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Stored {\n+            fn execute_query(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n                 tcx.$name(key)\n             }\n \n             #[inline]\n-            // key is only sometimes used\n             #[allow(unused_variables)]\n-            fn compute(qcx: QueryCtxt<'tcx>, key: &Self::Key) -> fn(TyCtxt<'tcx>, Self::Key) -> Self::Value {\n-                get_provider!([$($modifiers)*][qcx, $name, key])\n+            fn compute(qcx: QueryCtxt<'tcx>, key: Self::Key) -> Self::Value {\n+                query_provided_to_value::$name(\n+                    qcx.tcx,\n+                    get_provider!([$($modifiers)*][qcx, $name, key])(qcx.tcx, key)\n+                )\n             }\n \n             #[inline]\n-            fn try_load_from_disk(qcx: QueryCtxt<'tcx>, key: &Self::Key) -> rustc_query_system::query::TryLoadFromDisk<QueryCtxt<'tcx>, Self> {\n-                let cache_on_disk = Self::cache_on_disk(qcx.tcx, key);\n-                if cache_on_disk { should_ever_cache_on_disk!([$($modifiers)*]) } else { None }\n+            fn try_load_from_disk(_qcx: QueryCtxt<'tcx>, _key: &Self::Key) -> rustc_query_system::query::TryLoadFromDisk<QueryCtxt<'tcx>, Self> {\n+                should_ever_cache_on_disk!([$($modifiers)*] {\n+                    if Self::cache_on_disk(_qcx.tcx, _key) {\n+                        Some(|qcx: QueryCtxt<'tcx>, dep_node| {\n+                            let value = $crate::plumbing::try_load_from_disk::<query_provided::$name<'tcx>>(\n+                                qcx,\n+                                dep_node\n+                            );\n+                            value.map(|value| query_provided_to_value::$name(qcx.tcx, value))\n+                        })\n+                    } else {\n+                        None\n+                    }\n+                } {\n+                    None\n+                })\n             }\n \n             const ANON: bool = is_anon!([$($modifiers)*]);\n@@ -633,7 +647,7 @@ macro_rules! define_queries {\n                     $crate::profiling_support::alloc_self_profile_query_strings_for_query_cache(\n                         tcx,\n                         stringify!($name),\n-                        &tcx.query_caches.$name,\n+                        &tcx.query_system.caches.$name,\n                         string_cache,\n                     )\n                 },\n@@ -725,7 +739,7 @@ macro_rules! define_queries_struct {\n                 span: Span,\n                 key: <queries::$name<'tcx> as QueryConfig<QueryCtxt<'tcx>>>::Key,\n                 mode: QueryMode,\n-            ) -> Option<query_stored::$name<'tcx>> {\n+            ) -> Option<query_values::$name<'tcx>> {\n                 let qcx = QueryCtxt { tcx, queries: self };\n                 get_query::<queries::$name<'tcx>, _, rustc_middle::dep_graph::DepKind>(qcx, span, key, mode)\n             })*"}, {"sha": "e840108bdd86925979115f3a2a11a098dd4a9ef4", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 6, "deletions": 165, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=947b696ce0ce42c98b8fb82ffa0735ade051466c", "patch": "@@ -1,12 +1,10 @@\n use crate::dep_graph::DepNodeIndex;\n \n-use rustc_arena::TypedArena;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sharded;\n #[cfg(parallel_compiler)]\n use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::sync::Lock;\n-use rustc_data_structures::sync::WorkerLocal;\n use rustc_index::vec::{Idx, IndexVec};\n use std::fmt::Debug;\n use std::hash::Hash;\n@@ -16,12 +14,10 @@ pub trait CacheSelector<'tcx, V> {\n     type Cache\n     where\n         V: Copy;\n-    type ArenaCache;\n }\n \n pub trait QueryStorage {\n-    type Value: Debug;\n-    type Stored: Copy;\n+    type Value: Copy;\n }\n \n pub trait QueryCache: QueryStorage + Sized {\n@@ -31,9 +27,9 @@ pub trait QueryCache: QueryStorage + Sized {\n     /// It returns the shard index and a lock guard to the shard,\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n-    fn lookup(&self, key: &Self::Key) -> Option<(Self::Stored, DepNodeIndex)>;\n+    fn lookup(&self, key: &Self::Key) -> Option<(Self::Value, DepNodeIndex)>;\n \n-    fn complete(&self, key: Self::Key, value: Self::Value, index: DepNodeIndex) -> Self::Stored;\n+    fn complete(&self, key: Self::Key, value: Self::Value, index: DepNodeIndex);\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex));\n }\n@@ -44,7 +40,6 @@ impl<'tcx, K: Eq + Hash, V: 'tcx> CacheSelector<'tcx, V> for DefaultCacheSelecto\n     type Cache = DefaultCache<K, V>\n     where\n         V: Copy;\n-    type ArenaCache = ArenaCache<'tcx, K, V>;\n }\n \n pub struct DefaultCache<K, V> {\n@@ -62,7 +57,6 @@ impl<K, V> Default for DefaultCache<K, V> {\n \n impl<K: Eq + Hash, V: Copy + Debug> QueryStorage for DefaultCache<K, V> {\n     type Value = V;\n-    type Stored = V;\n }\n \n impl<K, V> QueryCache for DefaultCache<K, V>\n@@ -85,15 +79,14 @@ where\n     }\n \n     #[inline]\n-    fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n+    fn complete(&self, key: K, value: V, index: DepNodeIndex) {\n         #[cfg(parallel_compiler)]\n         let mut lock = self.cache.get_shard_by_value(&key).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n         // We may be overwriting another value. This is all right, since the dep-graph\n         // will check that the fingerprint matches.\n         lock.insert(key, (value, index));\n-        value\n     }\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n@@ -122,7 +115,6 @@ impl<'tcx, V: 'tcx> CacheSelector<'tcx, V> for SingleCacheSelector {\n     type Cache = SingleCache<V>\n     where\n         V: Copy;\n-    type ArenaCache = ArenaCache<'tcx, (), V>;\n }\n \n pub struct SingleCache<V> {\n@@ -137,7 +129,6 @@ impl<V> Default for SingleCache<V> {\n \n impl<V: Copy + Debug> QueryStorage for SingleCache<V> {\n     type Value = V;\n-    type Stored = V;\n }\n \n impl<V> QueryCache for SingleCache<V>\n@@ -152,95 +143,21 @@ where\n     }\n \n     #[inline]\n-    fn complete(&self, _key: (), value: V, index: DepNodeIndex) -> Self::Stored {\n+    fn complete(&self, _key: (), value: V, index: DepNodeIndex) {\n         *self.cache.lock() = Some((value, index));\n-        value\n     }\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n         self.cache.lock().as_ref().map(|value| f(&(), &value.0, value.1));\n     }\n }\n \n-pub struct ArenaCache<'tcx, K, V> {\n-    arena: WorkerLocal<TypedArena<(V, DepNodeIndex)>>,\n-    #[cfg(parallel_compiler)]\n-    cache: Sharded<FxHashMap<K, &'tcx (V, DepNodeIndex)>>,\n-    #[cfg(not(parallel_compiler))]\n-    cache: Lock<FxHashMap<K, &'tcx (V, DepNodeIndex)>>,\n-}\n-\n-impl<'tcx, K, V> Default for ArenaCache<'tcx, K, V> {\n-    fn default() -> Self {\n-        ArenaCache { arena: WorkerLocal::new(|_| TypedArena::default()), cache: Default::default() }\n-    }\n-}\n-\n-impl<'tcx, K: Eq + Hash, V: Debug + 'tcx> QueryStorage for ArenaCache<'tcx, K, V> {\n-    type Value = V;\n-    type Stored = &'tcx V;\n-}\n-\n-impl<'tcx, K, V: 'tcx> QueryCache for ArenaCache<'tcx, K, V>\n-where\n-    K: Eq + Hash + Clone + Debug,\n-    V: Debug,\n-{\n-    type Key = K;\n-\n-    #[inline(always)]\n-    fn lookup(&self, key: &K) -> Option<(&'tcx V, DepNodeIndex)> {\n-        let key_hash = sharded::make_hash(key);\n-        #[cfg(parallel_compiler)]\n-        let lock = self.cache.get_shard_by_hash(key_hash).lock();\n-        #[cfg(not(parallel_compiler))]\n-        let lock = self.cache.lock();\n-        let result = lock.raw_entry().from_key_hashed_nocheck(key_hash, key);\n-\n-        if let Some((_, value)) = result { Some((&value.0, value.1)) } else { None }\n-    }\n-\n-    #[inline]\n-    fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n-        let value = self.arena.alloc((value, index));\n-        let value = unsafe { &*(value as *const _) };\n-        #[cfg(parallel_compiler)]\n-        let mut lock = self.cache.get_shard_by_value(&key).lock();\n-        #[cfg(not(parallel_compiler))]\n-        let mut lock = self.cache.lock();\n-        // We may be overwriting another value. This is all right, since the dep-graph\n-        // will check that the fingerprint matches.\n-        lock.insert(key, value);\n-        &value.0\n-    }\n-\n-    fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n-        #[cfg(parallel_compiler)]\n-        {\n-            let shards = self.cache.lock_shards();\n-            for shard in shards.iter() {\n-                for (k, v) in shard.iter() {\n-                    f(k, &v.0, v.1);\n-                }\n-            }\n-        }\n-        #[cfg(not(parallel_compiler))]\n-        {\n-            let map = self.cache.lock();\n-            for (k, v) in map.iter() {\n-                f(k, &v.0, v.1);\n-            }\n-        }\n-    }\n-}\n-\n pub struct VecCacheSelector<K>(PhantomData<K>);\n \n impl<'tcx, K: Idx, V: 'tcx> CacheSelector<'tcx, V> for VecCacheSelector<K> {\n     type Cache = VecCache<K, V>\n     where\n         V: Copy;\n-    type ArenaCache = VecArenaCache<'tcx, K, V>;\n }\n \n pub struct VecCache<K: Idx, V> {\n@@ -258,7 +175,6 @@ impl<K: Idx, V> Default for VecCache<K, V> {\n \n impl<K: Eq + Idx, V: Copy + Debug> QueryStorage for VecCache<K, V> {\n     type Value = V;\n-    type Stored = V;\n }\n \n impl<K, V> QueryCache for VecCache<K, V>\n@@ -278,87 +194,12 @@ where\n     }\n \n     #[inline]\n-    fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n+    fn complete(&self, key: K, value: V, index: DepNodeIndex) {\n         #[cfg(parallel_compiler)]\n         let mut lock = self.cache.get_shard_by_hash(key.index() as u64).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n         lock.insert(key, (value, index));\n-        value\n-    }\n-\n-    fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n-        #[cfg(parallel_compiler)]\n-        {\n-            let shards = self.cache.lock_shards();\n-            for shard in shards.iter() {\n-                for (k, v) in shard.iter_enumerated() {\n-                    if let Some(v) = v {\n-                        f(&k, &v.0, v.1);\n-                    }\n-                }\n-            }\n-        }\n-        #[cfg(not(parallel_compiler))]\n-        {\n-            let map = self.cache.lock();\n-            for (k, v) in map.iter_enumerated() {\n-                if let Some(v) = v {\n-                    f(&k, &v.0, v.1);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub struct VecArenaCache<'tcx, K: Idx, V> {\n-    arena: WorkerLocal<TypedArena<(V, DepNodeIndex)>>,\n-    #[cfg(parallel_compiler)]\n-    cache: Sharded<IndexVec<K, Option<&'tcx (V, DepNodeIndex)>>>,\n-    #[cfg(not(parallel_compiler))]\n-    cache: Lock<IndexVec<K, Option<&'tcx (V, DepNodeIndex)>>>,\n-}\n-\n-impl<'tcx, K: Idx, V> Default for VecArenaCache<'tcx, K, V> {\n-    fn default() -> Self {\n-        VecArenaCache {\n-            arena: WorkerLocal::new(|_| TypedArena::default()),\n-            cache: Default::default(),\n-        }\n-    }\n-}\n-\n-impl<'tcx, K: Eq + Idx, V: Debug + 'tcx> QueryStorage for VecArenaCache<'tcx, K, V> {\n-    type Value = V;\n-    type Stored = &'tcx V;\n-}\n-\n-impl<'tcx, K, V: 'tcx> QueryCache for VecArenaCache<'tcx, K, V>\n-where\n-    K: Eq + Idx + Clone + Debug,\n-    V: Debug,\n-{\n-    type Key = K;\n-\n-    #[inline(always)]\n-    fn lookup(&self, key: &K) -> Option<(&'tcx V, DepNodeIndex)> {\n-        #[cfg(parallel_compiler)]\n-        let lock = self.cache.get_shard_by_hash(key.index() as u64).lock();\n-        #[cfg(not(parallel_compiler))]\n-        let lock = self.cache.lock();\n-        if let Some(Some(value)) = lock.get(*key) { Some((&value.0, value.1)) } else { None }\n-    }\n-\n-    #[inline]\n-    fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n-        let value = self.arena.alloc((value, index));\n-        let value = unsafe { &*(value as *const _) };\n-        #[cfg(parallel_compiler)]\n-        let mut lock = self.cache.get_shard_by_hash(key.index() as u64).lock();\n-        #[cfg(not(parallel_compiler))]\n-        let mut lock = self.cache.lock();\n-        lock.insert(key, value);\n-        &value.0\n     }\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {"}, {"sha": "56247e827a2da25ae3ef8abcca70b54bb72f3bbc", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=947b696ce0ce42c98b8fb82ffa0735ade051466c", "patch": "@@ -20,10 +20,9 @@ pub trait QueryConfig<Qcx: QueryContext> {\n     const NAME: &'static str;\n \n     type Key: DepNodeParams<Qcx::DepContext> + Eq + Hash + Clone + Debug;\n-    type Value: Debug;\n-    type Stored: Debug + Copy + std::borrow::Borrow<Self::Value>;\n+    type Value: Debug + Copy;\n \n-    type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n+    type Cache: QueryCache<Key = Self::Key, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n     fn query_state<'a>(tcx: Qcx) -> &'a QueryState<Self::Key, Qcx::DepKind>\n@@ -38,9 +37,9 @@ pub trait QueryConfig<Qcx: QueryContext> {\n     fn cache_on_disk(tcx: Qcx::DepContext, key: &Self::Key) -> bool;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn execute_query(tcx: Qcx::DepContext, k: Self::Key) -> Self::Stored;\n+    fn execute_query(tcx: Qcx::DepContext, k: Self::Key) -> Self::Value;\n \n-    fn compute(tcx: Qcx, key: &Self::Key) -> fn(Qcx::DepContext, Self::Key) -> Self::Value;\n+    fn compute(tcx: Qcx, key: Self::Key) -> Self::Value;\n \n     fn try_load_from_disk(qcx: Qcx, idx: &Self::Key) -> TryLoadFromDisk<Qcx, Self>;\n "}, {"sha": "57217fb681a97211a94d3185d8914366a4d310d2", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/947b696ce0ce42c98b8fb82ffa0735ade051466c/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=947b696ce0ce42c98b8fb82ffa0735ade051466c", "patch": "@@ -246,7 +246,7 @@ where\n \n     /// Completes the query by updating the query cache with the `result`,\n     /// signals the waiter and forgets the JobOwner, so it won't poison the query\n-    fn complete<C>(self, cache: &C, result: C::Value, dep_node_index: DepNodeIndex) -> C::Stored\n+    fn complete<C>(self, cache: &C, result: C::Value, dep_node_index: DepNodeIndex)\n     where\n         C: QueryCache<Key = K>,\n     {\n@@ -257,23 +257,19 @@ where\n         // Forget ourself so our destructor won't poison the query\n         mem::forget(self);\n \n-        let (job, result) = {\n-            let job = {\n-                #[cfg(parallel_compiler)]\n-                let mut lock = state.active.get_shard_by_value(&key).lock();\n-                #[cfg(not(parallel_compiler))]\n-                let mut lock = state.active.lock();\n-                match lock.remove(&key).unwrap() {\n-                    QueryResult::Started(job) => job,\n-                    QueryResult::Poisoned => panic!(),\n-                }\n-            };\n-            let result = cache.complete(key, result, dep_node_index);\n-            (job, result)\n+        let job = {\n+            #[cfg(parallel_compiler)]\n+            let mut lock = state.active.get_shard_by_value(&key).lock();\n+            #[cfg(not(parallel_compiler))]\n+            let mut lock = state.active.lock();\n+            match lock.remove(&key).unwrap() {\n+                QueryResult::Started(job) => job,\n+                QueryResult::Poisoned => panic!(),\n+            }\n         };\n+        cache.complete(key, result, dep_node_index);\n \n         job.signal_complete();\n-        result\n     }\n }\n \n@@ -336,7 +332,7 @@ where\n /// which will be used if the query is not in the cache and we need\n /// to compute it.\n #[inline]\n-pub fn try_get_cached<Tcx, C>(tcx: Tcx, cache: &C, key: &C::Key) -> Option<C::Stored>\n+pub fn try_get_cached<Tcx, C>(tcx: Tcx, cache: &C, key: &C::Key) -> Option<C::Value>\n where\n     C: QueryCache,\n     Tcx: DepContext,\n@@ -358,7 +354,7 @@ fn try_execute_query<Q, Qcx>(\n     span: Span,\n     key: Q::Key,\n     dep_node: Option<DepNode<Qcx::DepKind>>,\n-) -> (Q::Stored, Option<DepNodeIndex>)\n+) -> (Q::Value, Option<DepNodeIndex>)\n where\n     Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n@@ -390,7 +386,7 @@ where\n                     );\n                 }\n             }\n-            let result = job.complete(cache, result, dep_node_index);\n+            job.complete(cache, result, dep_node_index);\n             (result, Some(dep_node_index))\n         }\n         TryGetJob::Cycle(error) => {\n@@ -426,9 +422,7 @@ where\n     // Fast path for when incr. comp. is off.\n     if !dep_graph.is_fully_enabled() {\n         let prof_timer = qcx.dep_context().profiler().query_provider();\n-        let result = qcx.start_query(job_id, Q::DEPTH_LIMIT, None, || {\n-            Q::compute(qcx, &key)(*qcx.dep_context(), key)\n-        });\n+        let result = qcx.start_query(job_id, Q::DEPTH_LIMIT, None, || Q::compute(qcx, key));\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n         return (result, dep_node_index);\n@@ -454,17 +448,15 @@ where\n     let (result, dep_node_index) =\n         qcx.start_query(job_id, Q::DEPTH_LIMIT, Some(&diagnostics), || {\n             if Q::ANON {\n-                return dep_graph.with_anon_task(*qcx.dep_context(), Q::DEP_KIND, || {\n-                    Q::compute(qcx, &key)(*qcx.dep_context(), key)\n-                });\n+                return dep_graph\n+                    .with_anon_task(*qcx.dep_context(), Q::DEP_KIND, || Q::compute(qcx, key));\n             }\n \n             // `to_dep_node` is expensive for some `DepKind`s.\n             let dep_node =\n                 dep_node_opt.unwrap_or_else(|| Q::construct_dep_node(*qcx.dep_context(), &key));\n \n-            let task = Q::compute(qcx, &key);\n-            dep_graph.with_task(dep_node, *qcx.dep_context(), key, task, Q::HASH_RESULT)\n+            dep_graph.with_task(dep_node, qcx, key, Q::compute, Q::HASH_RESULT)\n         });\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n@@ -555,7 +547,7 @@ where\n     let prof_timer = qcx.dep_context().profiler().query_provider();\n \n     // The dep-graph for this computation is already in-place.\n-    let result = dep_graph.with_ignore(|| Q::compute(qcx, key)(*qcx.dep_context(), key.clone()));\n+    let result = dep_graph.with_ignore(|| Q::compute(qcx, key.clone()));\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -727,7 +719,7 @@ pub enum QueryMode {\n     Ensure,\n }\n \n-pub fn get_query<Q, Qcx, D>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Stored>\n+pub fn get_query<Q, Qcx, D>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Value>\n where\n     D: DepKind,\n     Q: QueryConfig<Qcx>,"}]}