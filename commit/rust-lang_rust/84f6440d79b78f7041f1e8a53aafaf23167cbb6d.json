{"sha": "84f6440d79b78f7041f1e8a53aafaf23167cbb6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ZjY0NDBkNzliNzhmNzA0MWYxZThhNTNhYWZhZjIzMTY3Y2JiNmQ=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-04-05T08:51:25Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-04-05T10:37:28Z"}, "message": "Rollup merge of #49654 - davidtwco:issue-29893, r=alexcrichton\n\nHost compiler documentation: Include private items\n\nFixes #29893. Now that compiler documentation is being hosted, including private items seems sensible as these types are going to be being used by contributors working on the compiler.\n\nHowever, including this means that doc comments that contain codeblocks with invalid Rust and can fail the documenting of a given crate (as evidenced by the changes in the second commit included in this PR). We'd need some way of ensuring that this cannot happen so that these failures don't cause documenting to fail. I'm unsure whether this change to documentation steps will cause this to happen already or if something new will be required.\n\nr? @alexcrichton", "tree": {"sha": "fd275fdf35694c99ab38cb3a50389564645f6193", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd275fdf35694c99ab38cb3a50389564645f6193"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84f6440d79b78f7041f1e8a53aafaf23167cbb6d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlrF/GgACgkQ/vbIBR0O\nATxIBxAApQZu3sX2ylqGoR0DwCQd+88mILzpFlOyQ9shAevw0DtEcXyGJXaoU9cz\neN4UHGB2wE2nO27rx8i9whEfE427XWjlRGMBGXV6s6D5gc2qdzW85sRl7S1R04JH\nJDIVcQSrika2KXe3CQ+6z9iTzTdCkOmd1KiLTkHT5yNVwkxl/aBo+GszFZqgwygW\n5amSpzWa7cQl4Y708/Z0J9UOQ27/Hg7QPHiiNG5dzPjQn90QWrSIAFbCy79v1VRP\nlLo/yMRP2jNchQ9elS54ZofyL82OefzIpWRzhJnzwOUbGSOzU1g6T5x/o2vSgeEm\ndLB96ljRIIQCVOWv0dXpgUGzD3e3v93H/YRQAhq7YhtA6mbQZLv8msP+8FXsa3RK\njn/l4nxB29QPTO11wgxPzgeL9VQeH1qpi2pXCckc3IGPwsepIpFupg51+S15uHWw\nQjvPWM0O3isfYvtyWFJp82nMVJTF+BzWaggid6uLy7ni4A8qeTFaqhpdZQuorjkb\n1errKBW3EJEBuLji5L+lrSXqPsOc645AsJnF7J6sZQoTjmRRTRxe7mTntQsqo/32\nMDsG3EuUjZ3DF9gpseWRTlWVi2XPuN9YjX94dpj3eeWfiFmRwv8kZ23HObxMAqf/\ngPwcuvyro+6OLcdmt/YhhLPpycBujR+7l4JKZO6voXAuG1OdGQo=\n=ESrP\n-----END PGP SIGNATURE-----", "payload": "tree fd275fdf35694c99ab38cb3a50389564645f6193\nparent b146e335180e00db10d729837cd0507b4a945be5\nparent 809d01c62ef25814abf8e490eb80128989985014\nauthor kennytm <kennytm@gmail.com> 1522918285 +0800\ncommitter kennytm <kennytm@gmail.com> 1522924648 +0800\n\nRollup merge of #49654 - davidtwco:issue-29893, r=alexcrichton\n\nHost compiler documentation: Include private items\n\nFixes #29893. Now that compiler documentation is being hosted, including private items seems sensible as these types are going to be being used by contributors working on the compiler.\n\nHowever, including this means that doc comments that contain codeblocks with invalid Rust and can fail the documenting of a given crate (as evidenced by the changes in the second commit included in this PR). We'd need some way of ensuring that this cannot happen so that these failures don't cause documenting to fail. I'm unsure whether this change to documentation steps will cause this to happen already or if something new will be required.\n\nr? @alexcrichton\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84f6440d79b78f7041f1e8a53aafaf23167cbb6d", "html_url": "https://github.com/rust-lang/rust/commit/84f6440d79b78f7041f1e8a53aafaf23167cbb6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84f6440d79b78f7041f1e8a53aafaf23167cbb6d/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b146e335180e00db10d729837cd0507b4a945be5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b146e335180e00db10d729837cd0507b4a945be5", "html_url": "https://github.com/rust-lang/rust/commit/b146e335180e00db10d729837cd0507b4a945be5"}, {"sha": "809d01c62ef25814abf8e490eb80128989985014", "url": "https://api.github.com/repos/rust-lang/rust/commits/809d01c62ef25814abf8e490eb80128989985014", "html_url": "https://github.com/rust-lang/rust/commit/809d01c62ef25814abf8e490eb80128989985014"}], "stats": {"total": 27, "additions": 16, "deletions": 11}, "files": [{"sha": "4237ded2215c218e4fd8ed16e4d7d4a795fecc4b", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84f6440d79b78f7041f1e8a53aafaf23167cbb6d/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f6440d79b78f7041f1e8a53aafaf23167cbb6d/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=84f6440d79b78f7041f1e8a53aafaf23167cbb6d", "patch": "@@ -698,6 +698,7 @@ impl Step for Rustc {\n         t!(symlink_dir_force(&builder.config, &out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n+        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n         compile::rustc_cargo(build, &mut cargo);\n \n         // Only include compiler crates, no dependencies of those, such as `libc`."}, {"sha": "7e1b7c08c3dad99fc22c4566c84cf15a3e78082e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84f6440d79b78f7041f1e8a53aafaf23167cbb6d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f6440d79b78f7041f1e8a53aafaf23167cbb6d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=84f6440d79b78f7041f1e8a53aafaf23167cbb6d", "patch": "@@ -353,8 +353,8 @@ pub struct ScopeTree {\n     /// the result of `g()` occurs after the yield (and therefore\n     /// doesn't). If we want to infer that, we can look at the\n     /// postorder traversal:\n-    /// ```\n-    /// `foo` `f` Call#1 `y` Yield `bar` `g` Call#3 Call#2 Call#0\n+    /// ```plain,ignore\n+    ///     `foo` `f` Call#1 `y` Yield `bar` `g` Call#3 Call#2 Call#0\n     /// ```\n     ///\n     /// In which we can easily see that `Call#1` occurs before the yield,"}, {"sha": "b1649686323f8750e09e47f33be76fdf28a7f839", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84f6440d79b78f7041f1e8a53aafaf23167cbb6d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f6440d79b78f7041f1e8a53aafaf23167cbb6d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=84f6440d79b78f7041f1e8a53aafaf23167cbb6d", "patch": "@@ -362,7 +362,9 @@ enum EvaluationResult {\n     /// When checking `foo`, we have to prove `T: Trait`. This basically\n     /// translates into this:\n     ///\n+    /// ```plain,ignore\n     ///     (T: Trait + Sized \u2192_\\impl T: Trait), T: Trait \u22a2 T: Trait\n+    /// ```\n     ///\n     /// When we try to prove it, we first go the first option, which\n     /// recurses. This shows us that the impl is \"useless\" - it won't"}, {"sha": "3a97d2767444bc065f75555a8c9c4e468bcf1ed5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84f6440d79b78f7041f1e8a53aafaf23167cbb6d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f6440d79b78f7041f1e8a53aafaf23167cbb6d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=84f6440d79b78f7041f1e8a53aafaf23167cbb6d", "patch": "@@ -427,14 +427,14 @@ fn generate_fn_name_span(cm: &CodeMap, span: Span) -> Option<Span> {\n /// a new local type parameter.\n ///\n /// For instance:\n-/// ```\n+/// ```rust,ignore (pseudo-Rust)\n /// // Given span\n /// fn my_function(param: T)\n-///                       ^ Original span\n+/// //                    ^ Original span\n ///\n /// // Result\n /// fn my_function(param: T)\n-///    ^^^^^^^^^^^ Generated span with snippet `my_function<T>`\n+/// // ^^^^^^^^^^^ Generated span with snippet `my_function<T>`\n /// ```\n ///\n /// Attention: The method used is very fragile since it essentially duplicates the work of the"}, {"sha": "b5e862fac958a027089e068924fffdf6440e3a31", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84f6440d79b78f7041f1e8a53aafaf23167cbb6d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f6440d79b78f7041f1e8a53aafaf23167cbb6d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=84f6440d79b78f7041f1e8a53aafaf23167cbb6d", "patch": "@@ -1164,10 +1164,12 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// constraint that `'z <= 'a`. Given this setup, let's clarify the\n     /// parameters in (roughly) terms of the example:\n     ///\n+    /// ```plain,ignore (pseudo-Rust)\n     ///     A borrow of: `& 'z bk * r` where `r` has type `& 'a bk T`\n     ///     borrow_region   ^~                 ref_region    ^~\n     ///     borrow_kind        ^~               ref_kind        ^~\n     ///     ref_cmt                 ^\n+    /// ```\n     ///\n     /// Here `bk` stands for some borrow-kind (e.g., `mut`, `uniq`, etc).\n     ///"}, {"sha": "faf3ccb1133adcb89c9a18a168d0120f8aa5a228", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84f6440d79b78f7041f1e8a53aafaf23167cbb6d/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f6440d79b78f7041f1e8a53aafaf23167cbb6d/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=84f6440d79b78f7041f1e8a53aafaf23167cbb6d", "patch": "@@ -42,21 +42,21 @@ use syntax_pos::Span;\n ///\n /// Example:\n ///\n-/// ```\n+/// ```rust,ignore (pseudo-Rust)\n /// impl<T> Trait<Foo> for Bar { ... }\n-///      ^ T does not appear in `Foo` or `Bar`, error!\n+/// //   ^ T does not appear in `Foo` or `Bar`, error!\n ///\n /// impl<T> Trait<Foo<T>> for Bar { ... }\n-///      ^ T appears in `Foo<T>`, ok.\n+/// //   ^ T appears in `Foo<T>`, ok.\n ///\n /// impl<T> Trait<Foo> for Bar where Bar: Iterator<Item=T> { ... }\n-///      ^ T is bound to `<Bar as Iterator>::Item`, ok.\n+/// //   ^ T is bound to `<Bar as Iterator>::Item`, ok.\n ///\n /// impl<'a> Trait<Foo> for Bar { }\n-///      ^ 'a is unused, but for back-compat we allow it\n+/// //   ^ 'a is unused, but for back-compat we allow it\n ///\n /// impl<'a> Trait<Foo> for Bar { type X = &'a i32; }\n-///      ^ 'a is unused and appears in assoc type, error\n+/// //   ^ 'a is unused and appears in assoc type, error\n /// ```\n pub fn impl_wf_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // We will tag this as part of the WF check -- logically, it is,"}]}