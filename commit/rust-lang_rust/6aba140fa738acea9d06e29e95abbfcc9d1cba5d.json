{"sha": "6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYmExNDBmYTczOGFjZWE5ZDA2ZTI5ZTk1YWJiZmNjOWQxY2JhNWQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-23T22:35:09Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-25T21:27:41Z"}, "message": "rustdoc: Add sundown to src/rt/\n\nThis also starts compiling it in the same manner as linenoise, it's just bundled\nwith librustrt directly, and we export just a few symbols out of it.", "tree": {"sha": "d5b6dd07428938dd8851002e9e374bae537895be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5b6dd07428938dd8851002e9e374bae537895be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "html_url": "https://github.com/rust-lang/rust/commit/6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af25f58ac3da45899ed65b3af965150c8a90dcda", "url": "https://api.github.com/repos/rust-lang/rust/commits/af25f58ac3da45899ed65b3af965150c8a90dcda", "html_url": "https://github.com/rust-lang/rust/commit/af25f58ac3da45899ed65b3af965150c8a90dcda"}], "stats": {"total": 5476, "additions": 5472, "deletions": 4}, "files": [{"sha": "70b2bb75a38fc57d34e5a3bd9d035aef483ffe9d", "filename": "configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/configure", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -684,7 +684,7 @@ do\n       isaac linenoise sync test \\\n       arch/i386 arch/x86_64 arch/arm arch/mips  \\\n       libuv libuv/src/ares libuv/src/eio libuv/src/ev \\\n-      jemalloc\n+      jemalloc sundown/src sundown/html\n     do\n       make_dir $t/rt/stage$s/$i\n     done"}, {"sha": "fb4d8f7c734e84d7c39d152178a1a7f5abbcf345", "filename": "mk/rt.mk", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -82,7 +82,16 @@ RUNTIME_CXXS_$(1)_$(2) := \\\n               rt/rust_android_dummy.cpp \\\n               rt/rust_test_helpers.cpp\n \n-RUNTIME_CS_$(1)_$(2) := rt/linenoise/linenoise.c rt/linenoise/utf8.c\n+RUNTIME_CS_$(1)_$(2) := rt/linenoise/linenoise.c \\\n+\t\t\trt/linenoise/utf8.c \\\n+\t\t\trt/sundown/src/autolink.c \\\n+\t\t\trt/sundown/src/buffer.c \\\n+\t\t\trt/sundown/src/stack.c \\\n+\t\t\trt/sundown/src/markdown.c \\\n+\t\t\trt/sundown/html/houdini_href_e.c \\\n+\t\t\trt/sundown/html/houdini_html_e.c \\\n+\t\t\trt/sundown/html/html_smartypants.c \\\n+\t\t\trt/sundown/html/html.c\n \n RUNTIME_S_$(1)_$(2) := rt/arch/$$(HOST_$(1))/_context.S \\\n \t\t\trt/arch/$$(HOST_$(1))/ccall.S \\\n@@ -117,6 +126,8 @@ RUNTIME_DEF_$(1)_$(2) := $$(RT_OUTPUT_DIR_$(1))/rustrt$$(CFG_DEF_SUFFIX_$(1))\n RUNTIME_INCS_$(1)_$(2) := -I $$(S)src/rt -I $$(S)src/rt/isaac -I $$(S)src/rt/uthash \\\n                      -I $$(S)src/rt/arch/$$(HOST_$(1)) \\\n                      -I $$(S)src/rt/linenoise \\\n+                     -I $$(S)src/rt/sundown/src \\\n+                     -I $$(S)src/rt/sundown/html \\\n                      -I $$(S)src/libuv/include\n RUNTIME_OBJS_$(1)_$(2) := $$(RUNTIME_CXXS_$(1)_$(2):rt/%.cpp=$$(RT_BUILD_DIR_$(1)_$(2))/%.o) \\\n                      $$(RUNTIME_CS_$(1)_$(2):rt/%.c=$$(RT_BUILD_DIR_$(1)_$(2))/%.o) \\"}, {"sha": "be1d3ac057cd7bca6491c1561ab5a3c8c0473d67", "filename": "mk/tests.mk", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -227,8 +227,9 @@ ALL_CS := $(wildcard $(S)src/rt/*.cpp \\\n                      $(S)src/rt/*/*/*.cpp \\\n                      $(S)src/rustllvm/*.cpp)\n ALL_CS := $(filter-out $(S)src/rt/miniz.cpp \\\n-                       $(S)src/rt/linenoise/linenoise.c \\\n-                       $(S)src/rt/linenoise/utf8.c \\\n+\t\t       $(wildcard $(S)src/rt/linenoise/*.c) \\\n+\t\t       $(wildcard $(S)src/rt/sundown/src/*.c) \\\n+\t\t       $(wildcard $(S)src/rt/sundown/html/*.c) \\\n \t,$(ALL_CS))\n ALL_HS := $(wildcard $(S)src/rt/*.h \\\n                      $(S)src/rt/*/*.h \\\n@@ -241,6 +242,8 @@ ALL_HS := $(filter-out $(S)src/rt/vg/valgrind.h \\\n                        $(S)src/rt/msvc/inttypes.h \\\n                        $(S)src/rt/linenoise/linenoise.h \\\n                        $(S)src/rt/linenoise/utf8.h \\\n+\t\t       $(wildcard $(S)src/rt/sundown/src/*.h) \\\n+\t\t       $(wildcard $(S)src/rt/sundown/html/*.h) \\\n \t,$(ALL_HS))\n \n # Run the tidy script in multiple parts to avoid huge 'echo' commands"}, {"sha": "b87afab84eb1051832ed5e17fe08e8f234153f58", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -200,3 +200,9 @@ rust_set_stdio_container_fd\n rust_set_stdio_container_stream\n rust_uv_process_pid\n rust_uv_pipe_init\n+sdhtml_renderer\n+sd_markdown_new\n+sd_markdown_render\n+sd_markdown_free\n+bufrelease\n+bufnew"}, {"sha": "4415b7917358c302f23df42ea2f268b284f87d7f", "filename": "src/rt/sundown/.gitignore", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2F.gitignore?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,5 @@\n+*.o\n+libsundown.so*\n+sundown\n+smartypants\n+*.exe"}, {"sha": "7178d8cc99387962d36db46e6917943841c32241", "filename": "src/rt/sundown/CONTRIBUTING.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2FCONTRIBUTING.md?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,10 @@\n+Contributing to Sundown\n+=======================\n+\n+Do not.\n+\n+Unfortunately, Sundown is currently frozen as we're working with the Reddit, StackOverflow and Meteor developers to design a formal Markdown standard and parser that will supersede Sundown in all these websites (and in GitHub, of course). Our goal is to deprecate Sundown altogether before the end of the year.\n+\n+The new parser will be smaller, faster, safer and most importantly, more consistent.\n+\n+Please stay tuned.\n\\ No newline at end of file"}, {"sha": "baca6875a20a8704d6defd6dddde39ad49d22725", "filename": "src/rt/sundown/Makefile", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2FMakefile?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,83 @@\n+# Makefile\n+\n+# Copyright (c) 2009, Natacha Port\u00e9\n+#\n+# Permission to use, copy, modify, and distribute this software for any\n+# purpose with or without fee is hereby granted, provided that the above\n+# copyright notice and this permission notice appear in all copies.\n+#\n+# THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+\n+DEPDIR=depends\n+\n+# \"Machine-dependant\" options\n+#MFLAGS=-fPIC\n+\n+CFLAGS=-c -g -O3 -fPIC -Wall -Werror -Wsign-compare -Isrc -Ihtml\n+LDFLAGS=-g -O3 -Wall -Werror \n+CC=gcc\n+\n+\n+SUNDOWN_SRC=\\\n+\tsrc/markdown.o \\\n+\tsrc/stack.o \\\n+\tsrc/buffer.o \\\n+\tsrc/autolink.o \\\n+\thtml/html.o \\\n+\thtml/html_smartypants.o \\\n+\thtml/houdini_html_e.o \\\n+\thtml/houdini_href_e.o\n+\n+all:\t\tlibsundown.so sundown smartypants html_blocks\n+\n+.PHONY:\t\tall clean\n+\n+# libraries\n+\n+libsundown.so:\tlibsundown.so.1\n+\tln -f -s $^ $@\n+\n+libsundown.so.1: $(SUNDOWN_SRC)\n+\t$(CC) $(LDFLAGS) -shared -Wl $^ -o $@\n+\n+# executables\n+\n+sundown:\texamples/sundown.o $(SUNDOWN_SRC)\n+\t$(CC) $(LDFLAGS) $^ -o $@\n+\n+smartypants: examples/smartypants.o $(SUNDOWN_SRC)\n+\t$(CC) $(LDFLAGS) $^ -o $@\n+\n+# perfect hashing\n+html_blocks: src/html_blocks.h\n+\n+src/html_blocks.h: html_block_names.txt\n+\tgperf -N find_block_tag -H hash_block_tag -C -c -E --ignore-case $^ > $@\n+\n+\n+# housekeeping\n+clean:\n+\trm -f src/*.o html/*.o examples/*.o\n+\trm -f libsundown.so libsundown.so.1 sundown smartypants\n+\trm -f sundown.exe smartypants.exe\n+\trm -rf $(DEPDIR)\n+\n+\n+# dependencies\n+\n+include $(wildcard $(DEPDIR)/*.d)\n+\n+\n+# generic object compilations\n+\n+%.o:\tsrc/%.c examples/%.c html/%.c\n+\t@mkdir -p $(DEPDIR)\n+\t@$(CC) -MM $< > $(DEPDIR)/$*.d\n+\t$(CC) $(CFLAGS) -o $@ $<\n+"}, {"sha": "ea668b2cdc1ecdd3ac95ec8e35192271a32cd8f0", "filename": "src/rt/sundown/Makefile.win", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2FMakefile.win", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2FMakefile.win", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2FMakefile.win?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,33 @@\n+\n+CFLAGS=/O2 /EHsc /I\"src/\" /I\"examples\"/ /I\"html\"/\n+CC=cl\n+\n+SUNDOWN_SRC=\\\n+\tsrc\\markdown.obj \\\n+\tsrc\\stack.obj \\\n+\tsrc\\buffer.obj \\\n+\tsrc\\autolink.obj \\\n+\thtml\\html.obj \\\n+\thtml\\html_smartypants.obj \\\n+\thtml\\houdini_html_e.obj \\\n+\thtml\\houdini_href_e.obj\n+\n+all: sundown.dll sundown.exe\n+\n+sundown.dll: $(SUNDOWN_SRC) sundown.def\n+\t$(CC) $(SUNDOWN_SRC) sundown.def /link /DLL $(LDFLAGS) /out:$@\n+\n+sundown.exe: examples\\sundown.obj $(SUNDOWN_SRC)\n+\t$(CC) examples\\sundown.obj $(SUNDOWN_SRC) /link $(LDFLAGS) /out:$@\n+\n+# housekeeping\n+clean:\n+\tdel $(SUNDOWN_SRC)\n+\tdel sundown.dll sundown.exe\n+\tdel sundown.exp sundown.lib\n+\n+# generic object compilations\n+\n+.c.obj:\n+\t$(CC) $(CFLAGS) /c $< /Fo$@\n+"}, {"sha": "61736025ca92904488aea861725a56531d89edf7", "filename": "src/rt/sundown/README.markdown", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2FREADME.markdown", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2FREADME.markdown", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2FREADME.markdown?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,131 @@\n+\ufeffSundown\n+=======\n+\n+`Sundown` is a Markdown parser based on the original code of the\n+[Upskirt library](http://fossil.instinctive.eu/libupskirt/index) by Natacha Port\u00e9.\n+\n+Features\n+--------\n+\n+*\t**Fully standards compliant**\n+\n+\t`Sundown` passes out of the box the official Markdown v1.0.0 and v1.0.3\n+\ttest suites, and has been extensively tested with additional corner cases\n+\tto make sure its output is as sane as possible at all times.\n+\n+*\t**Massive extension support**\n+\n+\t`Sundown` has optional support for several (unofficial) Markdown extensions,\n+\tsuch as non-strict emphasis, fenced code blocks, tables, autolinks,\n+\tstrikethrough and more.\n+\n+*\t**UTF-8 aware**\n+\n+\t`Sundown` is fully UTF-8 aware, both when parsing the source document and when\n+\tgenerating the resulting (X)HTML code.\n+\n+*\t**Tested & Ready to be used on production**\n+\n+\t`Sundown` has been extensively security audited, and includes protection against\n+\tall possible DOS attacks (stack overflows, out of memory situations, malformed\n+\tMarkdown syntax...) and against client attacks through malicious embedded HTML.\n+\n+\tWe've worked very hard to make `Sundown` never crash or run out of memory\n+\tunder *any* input. `Sundown` renders all the Markdown content in GitHub and so\n+\tfar hasn't crashed a single time.\n+\n+*\t**Customizable renderers**\n+\n+\t`Sundown` is not stuck with XHTML output: the Markdown parser of the library\n+\tis decoupled from the renderer, so it's trivial to extend the library with\n+\tcustom renderers. A fully functional (X)HTML renderer is included.\n+\n+*\t**Optimized for speed**\n+\n+\t`Sundown` is written in C, with a special emphasis on performance. When wrapped\n+\ton a dynamic language such as Python or Ruby, it has shown to be up to 40\n+\ttimes faster than other native alternatives.\n+\n+*\t**Zero-dependency**\n+\n+\t`Sundown` is a zero-dependency library composed of 3 `.c` files and their headers.\n+\tNo dependencies, no bullshit. Only standard C99 that builds everywhere.\n+\n+Credits\n+-------\n+\n+`Sundown` is based on the original Upskirt parser by Natacha Port\u00e9, with many additions\n+by Vicent Marti (@vmg) and contributions from the following authors:\n+\n+\tBen Noordhuis, Bruno Michel, Joseph Koshy, Krzysztof Kowalczyk, Samuel Bronson,\n+\tShuhei Tanuma\n+\n+Bindings\n+--------\n+\n+`Sundown` is available from other programming languages thanks to these bindings developed\n+by our awesome contributors.\n+\n+- [Redcarpet](https://github.com/vmg/redcarpet) (Ruby)\n+- [RobotSkirt](https://github.com/benmills/robotskirt) (Node.js)\n+- [Misaka](https://github.com/FSX/misaka) (Python)\n+- [ffi-sundown](https://github.com/postmodern/ffi-sundown) (Ruby FFI)\n+- [Sundown HS](https://github.com/bitonic/sundown) (Haskell)\n+- [Goskirt](https://github.com/madari/goskirt) (Go)\n+- [Upskirt.go](https://github.com/buu700/upskirt.go) (Go)\n+- [MoonShine](https://github.com/brandonc/moonshine) (.NET)\n+- [PHP-Sundown](https://github.com/chobie/php-sundown) (PHP)\n+- [Sundown.net](https://github.com/txdv/sundown.net) (.NET)\n+\n+Help us\n+-------\n+\n+`Sundown` is all about security. If you find a (potential) security vulnerability in the\n+library, or a way to make it crash through malicious input, please report it to us,\n+either directly via email or by opening an Issue on GitHub, and help make the web safer\n+for everybody.\n+\n+Unicode character handling\n+--------------------------\n+\n+Given that the Markdown spec makes no provision for Unicode character handling, `Sundown`\n+takes a conservative approach towards deciding which extended characters trigger Markdown\n+features:\n+\n+*\tPunctuation characters outside of the U+007F codepoint are not handled as punctuation.\n+\tThey are considered as normal, in-word characters for word-boundary checks.\n+\n+*\tWhitespace characters outside of the U+007F codepoint are not considered as\n+\twhitespace. They are considered as normal, in-word characters for word-boundary checks.\n+\n+Install\n+-------\n+\n+There is nothing to install. `Sundown` is composed of 3 `.c` files (`markdown.c`,\n+`buffer.c` and `array.c`), so just throw them in your project. Zero-dependency means\n+zero-dependency. You might want to include `render/html.c` if you want to use the\n+included XHTML renderer, or write your own renderer. Either way, it's all fun and joy.\n+\n+If you are hardcore, you can use the included `Makefile` to build `Sundown` into a dynamic\n+library, or to build the sample `sundown` executable, which is just a commandline\n+Markdown to XHTML parser. (If gcc gives you grief about `-fPIC`, e.g. with MinGW, try\n+`make MFLAGS=` instead of just `make`.)\n+\n+License\n+-------\n+\n+Permission to use, copy, modify, and distribute this software for any\n+purpose with or without fee is hereby granted, provided that the above\n+copyright notice and this permission notice appear in all copies.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+\n+<!-- Local Variables: -->\n+<!-- fill-column: 89 -->\n+<!-- End: -->"}, {"sha": "4840703bb12ecc67bc213b69d76268c1149bbf9c", "filename": "src/rt/sundown/examples/smartypants.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fexamples%2Fsmartypants.c", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fexamples%2Fsmartypants.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fexamples%2Fsmartypants.c?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#include \"markdown.h\"\n+#include \"html.h\"\n+#include \"buffer.h\"\n+\n+#include <errno.h>\n+#include <getopt.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#define READ_UNIT 1024\n+#define OUTPUT_UNIT 64\n+\n+int\n+main(int argc, char **argv)\n+{\n+\tstruct buf *ib, *ob;\n+\tsize_t ret;\n+\tFILE *in = stdin;\n+\n+\t/* opening the file if given from the command line */\n+\tif (argc > 1) {\n+\t\tin = fopen(argv[1], \"r\");\n+\t\tif (!in) {\n+\t\t\tfprintf(stderr, \"Unable to open input file \\\"%s\\\": %s\\n\", argv[0], strerror(errno));\n+\t\t\treturn 1;\n+\t\t}\n+\t}\n+\n+\t/* reading everything */\n+\tib = bufnew(READ_UNIT);\n+\tbufgrow(ib, READ_UNIT);\n+\twhile ((ret = fread(ib->data + ib->size, 1, ib->asize - ib->size, in)) > 0) {\n+\t\tib->size += ret;\n+\t\tbufgrow(ib, ib->size + READ_UNIT);\n+\t}\n+\n+\tif (in != stdin)\n+\t\tfclose(in);\n+\n+\t/* performing markdown parsing */\n+\tob = bufnew(OUTPUT_UNIT);\n+\n+\tsdhtml_smartypants(ob, ib->data, ib->size);\n+\n+\t/* writing the result to stdout */\n+\t(void)fwrite(ob->data, 1, ob->size, stdout);\n+\n+\t/* cleanup */\n+\tbufrelease(ib);\n+\tbufrelease(ob);\n+\n+\treturn 0;\n+}\n+\n+/* vim: set filetype=c: */"}, {"sha": "8a475dcaa3d79ce117bc17b910ec975e57e680df", "filename": "src/rt/sundown/examples/sundown.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fexamples%2Fsundown.c", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fexamples%2Fsundown.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fexamples%2Fsundown.c?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#include \"markdown.h\"\n+#include \"html.h\"\n+#include \"buffer.h\"\n+\n+#include <errno.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#define READ_UNIT 1024\n+#define OUTPUT_UNIT 64\n+\n+/* main \u2022 main function, interfacing STDIO with the parser */\n+int\n+main(int argc, char **argv)\n+{\n+\tstruct buf *ib, *ob;\n+\tint ret;\n+\tFILE *in = stdin;\n+\n+\tstruct sd_callbacks callbacks;\n+\tstruct html_renderopt options;\n+\tstruct sd_markdown *markdown;\n+\n+\t/* opening the file if given from the command line */\n+\tif (argc > 1) {\n+\t\tin = fopen(argv[1], \"r\");\n+\t\tif (!in) {\n+\t\t\tfprintf(stderr,\"Unable to open input file \\\"%s\\\": %s\\n\", argv[1], strerror(errno));\n+\t\t\treturn 1;\n+\t\t}\n+\t}\n+\n+\t/* reading everything */\n+\tib = bufnew(READ_UNIT);\n+\tbufgrow(ib, READ_UNIT);\n+\twhile ((ret = fread(ib->data + ib->size, 1, ib->asize - ib->size, in)) > 0) {\n+\t\tib->size += ret;\n+\t\tbufgrow(ib, ib->size + READ_UNIT);\n+\t}\n+\n+\tif (in != stdin)\n+\t\tfclose(in);\n+\n+\t/* performing markdown parsing */\n+\tob = bufnew(OUTPUT_UNIT);\n+\n+\tsdhtml_renderer(&callbacks, &options, 0);\n+\tmarkdown = sd_markdown_new(0, 16, &callbacks, &options);\n+\n+\tsd_markdown_render(ob, ib->data, ib->size, markdown);\n+\tsd_markdown_free(markdown);\n+\n+\t/* writing the result to stdout */\n+\tret = fwrite(ob->data, 1, ob->size, stdout);\n+\n+\t/* cleanup */\n+\tbufrelease(ib);\n+\tbufrelease(ob);\n+\n+\treturn (ret < 0) ? -1 : 0;\n+}\n+\n+/* vim: set filetype=c: */"}, {"sha": "b4954c02f67909ea3b57b73c56d5844981068000", "filename": "src/rt/sundown/html/houdini.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fhtml%2Fhoudini.h", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fhtml%2Fhoudini.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fhtml%2Fhoudini.h?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,37 @@\n+#ifndef HOUDINI_H__\n+#define HOUDINI_H__\n+\n+#include \"buffer.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#ifdef HOUDINI_USE_LOCALE\n+#\tdefine _isxdigit(c) isxdigit(c)\n+#\tdefine _isdigit(c) isdigit(c)\n+#else\n+/*\n+ * Helper _isdigit methods -- do not trust the current locale\n+ * */\n+#\tdefine _isxdigit(c) (strchr(\"0123456789ABCDEFabcdef\", (c)) != NULL)\n+#\tdefine _isdigit(c) ((c) >= '0' && (c) <= '9')\n+#endif\n+\n+extern void houdini_escape_html(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_escape_html0(struct buf *ob, const uint8_t *src, size_t size, int secure);\n+extern void houdini_unescape_html(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_escape_xml(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_escape_uri(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_escape_url(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_escape_href(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_unescape_uri(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_unescape_url(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_escape_js(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_unescape_js(struct buf *ob, const uint8_t *src, size_t size);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"}, {"sha": "981b3b17e4153dce7cccaa7672471bb26280bde4", "filename": "src/rt/sundown/html/houdini_href_e.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fhtml%2Fhoudini_href_e.c", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fhtml%2Fhoudini_href_e.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fhtml%2Fhoudini_href_e.c?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,108 @@\n+#include <assert.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"houdini.h\"\n+\n+#define ESCAPE_GROW_FACTOR(x) (((x) * 12) / 10)\n+\n+/*\n+ * The following characters will not be escaped:\n+ *\n+ *\t\t-_.+!*'(),%#@?=;:/,+&$ alphanum\n+ *\n+ * Note that this character set is the addition of:\n+ *\n+ *\t- The characters which are safe to be in an URL\n+ *\t- The characters which are *not* safe to be in\n+ *\tan URL because they are RESERVED characters.\n+ *\n+ * We asume (lazily) that any RESERVED char that\n+ * appears inside an URL is actually meant to\n+ * have its native function (i.e. as an URL \n+ * component/separator) and hence needs no escaping.\n+ *\n+ * There are two exceptions: the chacters & (amp)\n+ * and ' (single quote) do not appear in the table.\n+ * They are meant to appear in the URL as components,\n+ * yet they require special HTML-entity escaping\n+ * to generate valid HTML markup.\n+ *\n+ * All other characters will be escaped to %XX.\n+ *\n+ */\n+static const char HREF_SAFE[] = {\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, \n+\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, \n+\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n+\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, \n+\t0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n+\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+};\n+\n+void\n+houdini_escape_href(struct buf *ob, const uint8_t *src, size_t size)\n+{\n+\tstatic const char hex_chars[] = \"0123456789ABCDEF\";\n+\tsize_t  i = 0, org;\n+\tchar hex_str[3];\n+\n+\tbufgrow(ob, ESCAPE_GROW_FACTOR(size));\n+\thex_str[0] = '%';\n+\n+\twhile (i < size) {\n+\t\torg = i;\n+\t\twhile (i < size && HREF_SAFE[src[i]] != 0)\n+\t\t\ti++;\n+\n+\t\tif (i > org)\n+\t\t\tbufput(ob, src + org, i - org);\n+\n+\t\t/* escaping */\n+\t\tif (i >= size)\n+\t\t\tbreak;\n+\n+\t\tswitch (src[i]) {\n+\t\t/* amp appears all the time in URLs, but needs\n+\t\t * HTML-entity escaping to be inside an href */\n+\t\tcase '&': \n+\t\t\tBUFPUTSL(ob, \"&amp;\");\n+\t\t\tbreak;\n+\n+\t\t/* the single quote is a valid URL character\n+\t\t * according to the standard; it needs HTML\n+\t\t * entity escaping too */\n+\t\tcase '\\'':\n+\t\t\tBUFPUTSL(ob, \"&#x27;\");\n+\t\t\tbreak;\n+\t\t\n+\t\t/* the space can be escaped to %20 or a plus\n+\t\t * sign. we're going with the generic escape\n+\t\t * for now. the plus thing is more commonly seen\n+\t\t * when building GET strings */\n+#if 0\n+\t\tcase ' ':\n+\t\t\tbufputc(ob, '+');\n+\t\t\tbreak;\n+#endif\n+\n+\t\t/* every other character goes with a %XX escaping */\n+\t\tdefault:\n+\t\t\thex_str[1] = hex_chars[(src[i] >> 4) & 0xF];\n+\t\t\thex_str[2] = hex_chars[src[i] & 0xF];\n+\t\t\tbufput(ob, hex_str, 3);\n+\t\t}\n+\n+\t\ti++;\n+\t}\n+}"}, {"sha": "d9bbf187d825cec7e1d339dbb2f5b01956359545", "filename": "src/rt/sundown/html/houdini_html_e.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fhtml%2Fhoudini_html_e.c", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fhtml%2Fhoudini_html_e.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fhtml%2Fhoudini_html_e.c?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,84 @@\n+#include <assert.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"houdini.h\"\n+\n+#define ESCAPE_GROW_FACTOR(x) (((x) * 12) / 10) /* this is very scientific, yes */\n+\n+/**\n+ * According to the OWASP rules:\n+ *\n+ * & --> &amp;\n+ * < --> &lt;\n+ * > --> &gt;\n+ * \" --> &quot;\n+ * ' --> &#x27;     &apos; is not recommended\n+ * / --> &#x2F;     forward slash is included as it helps end an HTML entity\n+ *\n+ */\n+static const char HTML_ESCAPE_TABLE[] = {\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 1, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0, 4, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+};\n+\n+static const char *HTML_ESCAPES[] = {\n+        \"\",\n+        \"&quot;\",\n+        \"&amp;\",\n+        \"&#39;\",\n+        \"&#47;\",\n+        \"&lt;\",\n+        \"&gt;\"\n+};\n+\n+void\n+houdini_escape_html0(struct buf *ob, const uint8_t *src, size_t size, int secure)\n+{\n+\tsize_t i = 0, org, esc = 0;\n+\n+\tbufgrow(ob, ESCAPE_GROW_FACTOR(size));\n+\n+\twhile (i < size) {\n+\t\torg = i;\n+\t\twhile (i < size && (esc = HTML_ESCAPE_TABLE[src[i]]) == 0)\n+\t\t\ti++;\n+\n+\t\tif (i > org)\n+\t\t\tbufput(ob, src + org, i - org);\n+\n+\t\t/* escaping */\n+\t\tif (i >= size)\n+\t\t\tbreak;\n+\n+\t\t/* The forward slash is only escaped in secure mode */\n+\t\tif (src[i] == '/' && !secure) {\n+\t\t\tbufputc(ob, '/');\n+\t\t} else {\n+\t\t\tbufputs(ob, HTML_ESCAPES[esc]);\n+\t\t}\n+\n+\t\ti++;\n+\t}\n+}\n+\n+void\n+houdini_escape_html(struct buf *ob, const uint8_t *src, size_t size)\n+{\n+\thoudini_escape_html0(ob, src, size, 1);\n+}\n+"}, {"sha": "7f08ee8ef1b97387ab96ab9a66b11d57d62cd1c9", "filename": "src/rt/sundown/html/html.c", "status": "added", "additions": 635, "deletions": 0, "changes": 635, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fhtml%2Fhtml.c", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fhtml%2Fhtml.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fhtml%2Fhtml.c?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,635 @@\n+/*\n+ * Copyright (c) 2009, Natacha Port\u00e9\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#include \"markdown.h\"\n+#include \"html.h\"\n+\n+#include <string.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <ctype.h>\n+\n+#include \"houdini.h\"\n+\n+#define USE_XHTML(opt) (opt->flags & HTML_USE_XHTML)\n+\n+int\n+sdhtml_is_tag(const uint8_t *tag_data, size_t tag_size, const char *tagname)\n+{\n+\tsize_t i;\n+\tint closed = 0;\n+\n+\tif (tag_size < 3 || tag_data[0] != '<')\n+\t\treturn HTML_TAG_NONE;\n+\n+\ti = 1;\n+\n+\tif (tag_data[i] == '/') {\n+\t\tclosed = 1;\n+\t\ti++;\n+\t}\n+\n+\tfor (; i < tag_size; ++i, ++tagname) {\n+\t\tif (*tagname == 0)\n+\t\t\tbreak;\n+\n+\t\tif (tag_data[i] != *tagname)\n+\t\t\treturn HTML_TAG_NONE;\n+\t}\n+\n+\tif (i == tag_size)\n+\t\treturn HTML_TAG_NONE;\n+\n+\tif (isspace(tag_data[i]) || tag_data[i] == '>')\n+\t\treturn closed ? HTML_TAG_CLOSE : HTML_TAG_OPEN;\n+\n+\treturn HTML_TAG_NONE;\n+}\n+\n+static inline void escape_html(struct buf *ob, const uint8_t *source, size_t length)\n+{\n+\thoudini_escape_html0(ob, source, length, 0);\n+}\n+\n+static inline void escape_href(struct buf *ob, const uint8_t *source, size_t length)\n+{\n+\thoudini_escape_href(ob, source, length);\n+}\n+\n+/********************\n+ * GENERIC RENDERER *\n+ ********************/\n+static int\n+rndr_autolink(struct buf *ob, const struct buf *link, enum mkd_autolink type, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\n+\tif (!link || !link->size)\n+\t\treturn 0;\n+\n+\tif ((options->flags & HTML_SAFELINK) != 0 &&\n+\t\t!sd_autolink_issafe(link->data, link->size) &&\n+\t\ttype != MKDA_EMAIL)\n+\t\treturn 0;\n+\n+\tBUFPUTSL(ob, \"<a href=\\\"\");\n+\tif (type == MKDA_EMAIL)\n+\t\tBUFPUTSL(ob, \"mailto:\");\n+\tescape_href(ob, link->data, link->size);\n+\n+\tif (options->link_attributes) {\n+\t\tbufputc(ob, '\\\"');\n+\t\toptions->link_attributes(ob, link, opaque);\n+\t\tbufputc(ob, '>');\n+\t} else {\n+\t\tBUFPUTSL(ob, \"\\\">\");\n+\t}\n+\n+\t/*\n+\t * Pretty printing: if we get an email address as\n+\t * an actual URI, e.g. `mailto:foo@bar.com`, we don't\n+\t * want to print the `mailto:` prefix\n+\t */\n+\tif (bufprefix(link, \"mailto:\") == 0) {\n+\t\tescape_html(ob, link->data + 7, link->size - 7);\n+\t} else {\n+\t\tescape_html(ob, link->data, link->size);\n+\t}\n+\n+\tBUFPUTSL(ob, \"</a>\");\n+\n+\treturn 1;\n+}\n+\n+static void\n+rndr_blockcode(struct buf *ob, const struct buf *text, const struct buf *lang, void *opaque)\n+{\n+\tif (ob->size) bufputc(ob, '\\n');\n+\n+\tif (lang && lang->size) {\n+\t\tsize_t i, cls;\n+\t\tBUFPUTSL(ob, \"<pre><code class=\\\"\");\n+\n+\t\tfor (i = 0, cls = 0; i < lang->size; ++i, ++cls) {\n+\t\t\twhile (i < lang->size && isspace(lang->data[i]))\n+\t\t\t\ti++;\n+\n+\t\t\tif (i < lang->size) {\n+\t\t\t\tsize_t org = i;\n+\t\t\t\twhile (i < lang->size && !isspace(lang->data[i]))\n+\t\t\t\t\ti++;\n+\n+\t\t\t\tif (lang->data[org] == '.')\n+\t\t\t\t\torg++;\n+\n+\t\t\t\tif (cls) bufputc(ob, ' ');\n+\t\t\t\tescape_html(ob, lang->data + org, i - org);\n+\t\t\t}\n+\t\t}\n+\n+\t\tBUFPUTSL(ob, \"\\\">\");\n+\t} else\n+\t\tBUFPUTSL(ob, \"<pre><code>\");\n+\n+\tif (text)\n+\t\tescape_html(ob, text->data, text->size);\n+\n+\tBUFPUTSL(ob, \"</code></pre>\\n\");\n+}\n+\n+static void\n+rndr_blockquote(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tif (ob->size) bufputc(ob, '\\n');\n+\tBUFPUTSL(ob, \"<blockquote>\\n\");\n+\tif (text) bufput(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</blockquote>\\n\");\n+}\n+\n+static int\n+rndr_codespan(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tBUFPUTSL(ob, \"<code>\");\n+\tif (text) escape_html(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</code>\");\n+\treturn 1;\n+}\n+\n+static int\n+rndr_strikethrough(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tif (!text || !text->size)\n+\t\treturn 0;\n+\n+\tBUFPUTSL(ob, \"<del>\");\n+\tbufput(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</del>\");\n+\treturn 1;\n+}\n+\n+static int\n+rndr_double_emphasis(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tif (!text || !text->size)\n+\t\treturn 0;\n+\n+\tBUFPUTSL(ob, \"<strong>\");\n+\tbufput(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</strong>\");\n+\n+\treturn 1;\n+}\n+\n+static int\n+rndr_emphasis(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tif (!text || !text->size) return 0;\n+\tBUFPUTSL(ob, \"<em>\");\n+\tif (text) bufput(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</em>\");\n+\treturn 1;\n+}\n+\n+static int\n+rndr_linebreak(struct buf *ob, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\tbufputs(ob, USE_XHTML(options) ? \"<br/>\\n\" : \"<br>\\n\");\n+\treturn 1;\n+}\n+\n+static void\n+rndr_header(struct buf *ob, const struct buf *text, int level, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\n+\tif (ob->size)\n+\t\tbufputc(ob, '\\n');\n+\n+\tif (options->flags & HTML_TOC)\n+\t\tbufprintf(ob, \"<h%d id=\\\"toc_%d\\\">\", level, options->toc_data.header_count++);\n+\telse\n+\t\tbufprintf(ob, \"<h%d>\", level);\n+\n+\tif (text) bufput(ob, text->data, text->size);\n+\tbufprintf(ob, \"</h%d>\\n\", level);\n+}\n+\n+static int\n+rndr_link(struct buf *ob, const struct buf *link, const struct buf *title, const struct buf *content, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\n+\tif (link != NULL && (options->flags & HTML_SAFELINK) != 0 && !sd_autolink_issafe(link->data, link->size))\n+\t\treturn 0;\n+\n+\tBUFPUTSL(ob, \"<a href=\\\"\");\n+\n+\tif (link && link->size)\n+\t\tescape_href(ob, link->data, link->size);\n+\n+\tif (title && title->size) {\n+\t\tBUFPUTSL(ob, \"\\\" title=\\\"\");\n+\t\tescape_html(ob, title->data, title->size);\n+\t}\n+\n+\tif (options->link_attributes) {\n+\t\tbufputc(ob, '\\\"');\n+\t\toptions->link_attributes(ob, link, opaque);\n+\t\tbufputc(ob, '>');\n+\t} else {\n+\t\tBUFPUTSL(ob, \"\\\">\");\n+\t}\n+\n+\tif (content && content->size) bufput(ob, content->data, content->size);\n+\tBUFPUTSL(ob, \"</a>\");\n+\treturn 1;\n+}\n+\n+static void\n+rndr_list(struct buf *ob, const struct buf *text, int flags, void *opaque)\n+{\n+\tif (ob->size) bufputc(ob, '\\n');\n+\tbufput(ob, flags & MKD_LIST_ORDERED ? \"<ol>\\n\" : \"<ul>\\n\", 5);\n+\tif (text) bufput(ob, text->data, text->size);\n+\tbufput(ob, flags & MKD_LIST_ORDERED ? \"</ol>\\n\" : \"</ul>\\n\", 6);\n+}\n+\n+static void\n+rndr_listitem(struct buf *ob, const struct buf *text, int flags, void *opaque)\n+{\n+\tBUFPUTSL(ob, \"<li>\");\n+\tif (text) {\n+\t\tsize_t size = text->size;\n+\t\twhile (size && text->data[size - 1] == '\\n')\n+\t\t\tsize--;\n+\n+\t\tbufput(ob, text->data, size);\n+\t}\n+\tBUFPUTSL(ob, \"</li>\\n\");\n+}\n+\n+static void\n+rndr_paragraph(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\tsize_t i = 0;\n+\n+\tif (ob->size) bufputc(ob, '\\n');\n+\n+\tif (!text || !text->size)\n+\t\treturn;\n+\n+\twhile (i < text->size && isspace(text->data[i])) i++;\n+\n+\tif (i == text->size)\n+\t\treturn;\n+\n+\tBUFPUTSL(ob, \"<p>\");\n+\tif (options->flags & HTML_HARD_WRAP) {\n+\t\tsize_t org;\n+\t\twhile (i < text->size) {\n+\t\t\torg = i;\n+\t\t\twhile (i < text->size && text->data[i] != '\\n')\n+\t\t\t\ti++;\n+\n+\t\t\tif (i > org)\n+\t\t\t\tbufput(ob, text->data + org, i - org);\n+\n+\t\t\t/*\n+\t\t\t * do not insert a line break if this newline\n+\t\t\t * is the last character on the paragraph\n+\t\t\t */\n+\t\t\tif (i >= text->size - 1)\n+\t\t\t\tbreak;\n+\n+\t\t\trndr_linebreak(ob, opaque);\n+\t\t\ti++;\n+\t\t}\n+\t} else {\n+\t\tbufput(ob, &text->data[i], text->size - i);\n+\t}\n+\tBUFPUTSL(ob, \"</p>\\n\");\n+}\n+\n+static void\n+rndr_raw_block(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tsize_t org, sz;\n+\tif (!text) return;\n+\tsz = text->size;\n+\twhile (sz > 0 && text->data[sz - 1] == '\\n') sz--;\n+\torg = 0;\n+\twhile (org < sz && text->data[org] == '\\n') org++;\n+\tif (org >= sz) return;\n+\tif (ob->size) bufputc(ob, '\\n');\n+\tbufput(ob, text->data + org, sz - org);\n+\tbufputc(ob, '\\n');\n+}\n+\n+static int\n+rndr_triple_emphasis(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tif (!text || !text->size) return 0;\n+\tBUFPUTSL(ob, \"<strong><em>\");\n+\tbufput(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</em></strong>\");\n+\treturn 1;\n+}\n+\n+static void\n+rndr_hrule(struct buf *ob, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\tif (ob->size) bufputc(ob, '\\n');\n+\tbufputs(ob, USE_XHTML(options) ? \"<hr/>\\n\" : \"<hr>\\n\");\n+}\n+\n+static int\n+rndr_image(struct buf *ob, const struct buf *link, const struct buf *title, const struct buf *alt, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\tif (!link || !link->size) return 0;\n+\n+\tBUFPUTSL(ob, \"<img src=\\\"\");\n+\tescape_href(ob, link->data, link->size);\n+\tBUFPUTSL(ob, \"\\\" alt=\\\"\");\n+\n+\tif (alt && alt->size)\n+\t\tescape_html(ob, alt->data, alt->size);\n+\n+\tif (title && title->size) {\n+\t\tBUFPUTSL(ob, \"\\\" title=\\\"\");\n+\t\tescape_html(ob, title->data, title->size); }\n+\n+\tbufputs(ob, USE_XHTML(options) ? \"\\\"/>\" : \"\\\">\");\n+\treturn 1;\n+}\n+\n+static int\n+rndr_raw_html(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\n+\t/* HTML_ESCAPE overrides SKIP_HTML, SKIP_STYLE, SKIP_LINKS and SKIP_IMAGES\n+\t* It doens't see if there are any valid tags, just escape all of them. */\n+\tif((options->flags & HTML_ESCAPE) != 0) {\n+\t\tescape_html(ob, text->data, text->size);\n+\t\treturn 1;\n+\t}\n+\n+\tif ((options->flags & HTML_SKIP_HTML) != 0)\n+\t\treturn 1;\n+\n+\tif ((options->flags & HTML_SKIP_STYLE) != 0 &&\n+\t\tsdhtml_is_tag(text->data, text->size, \"style\"))\n+\t\treturn 1;\n+\n+\tif ((options->flags & HTML_SKIP_LINKS) != 0 &&\n+\t\tsdhtml_is_tag(text->data, text->size, \"a\"))\n+\t\treturn 1;\n+\n+\tif ((options->flags & HTML_SKIP_IMAGES) != 0 &&\n+\t\tsdhtml_is_tag(text->data, text->size, \"img\"))\n+\t\treturn 1;\n+\n+\tbufput(ob, text->data, text->size);\n+\treturn 1;\n+}\n+\n+static void\n+rndr_table(struct buf *ob, const struct buf *header, const struct buf *body, void *opaque)\n+{\n+\tif (ob->size) bufputc(ob, '\\n');\n+\tBUFPUTSL(ob, \"<table><thead>\\n\");\n+\tif (header)\n+\t\tbufput(ob, header->data, header->size);\n+\tBUFPUTSL(ob, \"</thead><tbody>\\n\");\n+\tif (body)\n+\t\tbufput(ob, body->data, body->size);\n+\tBUFPUTSL(ob, \"</tbody></table>\\n\");\n+}\n+\n+static void\n+rndr_tablerow(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tBUFPUTSL(ob, \"<tr>\\n\");\n+\tif (text)\n+\t\tbufput(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</tr>\\n\");\n+}\n+\n+static void\n+rndr_tablecell(struct buf *ob, const struct buf *text, int flags, void *opaque)\n+{\n+\tif (flags & MKD_TABLE_HEADER) {\n+\t\tBUFPUTSL(ob, \"<th\");\n+\t} else {\n+\t\tBUFPUTSL(ob, \"<td\");\n+\t}\n+\n+\tswitch (flags & MKD_TABLE_ALIGNMASK) {\n+\tcase MKD_TABLE_ALIGN_CENTER:\n+\t\tBUFPUTSL(ob, \" align=\\\"center\\\">\");\n+\t\tbreak;\n+\n+\tcase MKD_TABLE_ALIGN_L:\n+\t\tBUFPUTSL(ob, \" align=\\\"left\\\">\");\n+\t\tbreak;\n+\n+\tcase MKD_TABLE_ALIGN_R:\n+\t\tBUFPUTSL(ob, \" align=\\\"right\\\">\");\n+\t\tbreak;\n+\n+\tdefault:\n+\t\tBUFPUTSL(ob, \">\");\n+\t}\n+\n+\tif (text)\n+\t\tbufput(ob, text->data, text->size);\n+\n+\tif (flags & MKD_TABLE_HEADER) {\n+\t\tBUFPUTSL(ob, \"</th>\\n\");\n+\t} else {\n+\t\tBUFPUTSL(ob, \"</td>\\n\");\n+\t}\n+}\n+\n+static int\n+rndr_superscript(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tif (!text || !text->size) return 0;\n+\tBUFPUTSL(ob, \"<sup>\");\n+\tbufput(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</sup>\");\n+\treturn 1;\n+}\n+\n+static void\n+rndr_normal_text(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tif (text)\n+\t\tescape_html(ob, text->data, text->size);\n+}\n+\n+static void\n+toc_header(struct buf *ob, const struct buf *text, int level, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\n+\t/* set the level offset if this is the first header\n+\t * we're parsing for the document */\n+\tif (options->toc_data.current_level == 0) {\n+\t\toptions->toc_data.level_offset = level - 1;\n+\t}\n+\tlevel -= options->toc_data.level_offset;\n+\n+\tif (level > options->toc_data.current_level) {\n+\t\twhile (level > options->toc_data.current_level) {\n+\t\t\tBUFPUTSL(ob, \"<ul>\\n<li>\\n\");\n+\t\t\toptions->toc_data.current_level++;\n+\t\t}\n+\t} else if (level < options->toc_data.current_level) {\n+\t\tBUFPUTSL(ob, \"</li>\\n\");\n+\t\twhile (level < options->toc_data.current_level) {\n+\t\t\tBUFPUTSL(ob, \"</ul>\\n</li>\\n\");\n+\t\t\toptions->toc_data.current_level--;\n+\t\t}\n+\t\tBUFPUTSL(ob,\"<li>\\n\");\n+\t} else {\n+\t\tBUFPUTSL(ob,\"</li>\\n<li>\\n\");\n+\t}\n+\n+\tbufprintf(ob, \"<a href=\\\"#toc_%d\\\">\", options->toc_data.header_count++);\n+\tif (text)\n+\t\tescape_html(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</a>\\n\");\n+}\n+\n+static int\n+toc_link(struct buf *ob, const struct buf *link, const struct buf *title, const struct buf *content, void *opaque)\n+{\n+\tif (content && content->size)\n+\t\tbufput(ob, content->data, content->size);\n+\treturn 1;\n+}\n+\n+static void\n+toc_finalize(struct buf *ob, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\n+\twhile (options->toc_data.current_level > 0) {\n+\t\tBUFPUTSL(ob, \"</li>\\n</ul>\\n\");\n+\t\toptions->toc_data.current_level--;\n+\t}\n+}\n+\n+void\n+sdhtml_toc_renderer(struct sd_callbacks *callbacks, struct html_renderopt *options)\n+{\n+\tstatic const struct sd_callbacks cb_default = {\n+\t\tNULL,\n+\t\tNULL,\n+\t\tNULL,\n+\t\ttoc_header,\n+\t\tNULL,\n+\t\tNULL,\n+\t\tNULL,\n+\t\tNULL,\n+\t\tNULL,\n+\t\tNULL,\n+\t\tNULL,\n+\n+\t\tNULL,\n+\t\trndr_codespan,\n+\t\trndr_double_emphasis,\n+\t\trndr_emphasis,\n+\t\tNULL,\n+\t\tNULL,\n+\t\ttoc_link,\n+\t\tNULL,\n+\t\trndr_triple_emphasis,\n+\t\trndr_strikethrough,\n+\t\trndr_superscript,\n+\n+\t\tNULL,\n+\t\tNULL,\n+\n+\t\tNULL,\n+\t\ttoc_finalize,\n+\t};\n+\n+\tmemset(options, 0x0, sizeof(struct html_renderopt));\n+\toptions->flags = HTML_TOC;\n+\n+\tmemcpy(callbacks, &cb_default, sizeof(struct sd_callbacks));\n+}\n+\n+void\n+sdhtml_renderer(struct sd_callbacks *callbacks, struct html_renderopt *options, unsigned int render_flags)\n+{\n+\tstatic const struct sd_callbacks cb_default = {\n+\t\trndr_blockcode,\n+\t\trndr_blockquote,\n+\t\trndr_raw_block,\n+\t\trndr_header,\n+\t\trndr_hrule,\n+\t\trndr_list,\n+\t\trndr_listitem,\n+\t\trndr_paragraph,\n+\t\trndr_table,\n+\t\trndr_tablerow,\n+\t\trndr_tablecell,\n+\n+\t\trndr_autolink,\n+\t\trndr_codespan,\n+\t\trndr_double_emphasis,\n+\t\trndr_emphasis,\n+\t\trndr_image,\n+\t\trndr_linebreak,\n+\t\trndr_link,\n+\t\trndr_raw_html,\n+\t\trndr_triple_emphasis,\n+\t\trndr_strikethrough,\n+\t\trndr_superscript,\n+\n+\t\tNULL,\n+\t\trndr_normal_text,\n+\n+\t\tNULL,\n+\t\tNULL,\n+\t};\n+\n+\t/* Prepare the options pointer */\n+\tmemset(options, 0x0, sizeof(struct html_renderopt));\n+\toptions->flags = render_flags;\n+\n+\t/* Prepare the callbacks */\n+\tmemcpy(callbacks, &cb_default, sizeof(struct sd_callbacks));\n+\n+\tif (render_flags & HTML_SKIP_IMAGES)\n+\t\tcallbacks->image = NULL;\n+\n+\tif (render_flags & HTML_SKIP_LINKS) {\n+\t\tcallbacks->link = NULL;\n+\t\tcallbacks->autolink = NULL;\n+\t}\n+\n+\tif (render_flags & HTML_SKIP_HTML || render_flags & HTML_ESCAPE)\n+\t\tcallbacks->blockhtml = NULL;\n+}"}, {"sha": "4c8810d471c92b7edb592398a6b9bcaa99508f92", "filename": "src/rt/sundown/html/html.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fhtml%2Fhtml.h", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fhtml%2Fhtml.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fhtml%2Fhtml.h?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#ifndef UPSKIRT_HTML_H\n+#define UPSKIRT_HTML_H\n+\n+#include \"markdown.h\"\n+#include \"buffer.h\"\n+#include <stdlib.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+struct html_renderopt {\n+\tstruct {\n+\t\tint header_count;\n+\t\tint current_level;\n+\t\tint level_offset;\n+\t} toc_data;\n+\n+\tunsigned int flags;\n+\n+\t/* extra callbacks */\n+\tvoid (*link_attributes)(struct buf *ob, const struct buf *url, void *self);\n+};\n+\n+typedef enum {\n+\tHTML_SKIP_HTML = (1 << 0),\n+\tHTML_SKIP_STYLE = (1 << 1),\n+\tHTML_SKIP_IMAGES = (1 << 2),\n+\tHTML_SKIP_LINKS = (1 << 3),\n+\tHTML_EXPAND_TABS = (1 << 4),\n+\tHTML_SAFELINK = (1 << 5),\n+\tHTML_TOC = (1 << 6),\n+\tHTML_HARD_WRAP = (1 << 7),\n+\tHTML_USE_XHTML = (1 << 8),\n+\tHTML_ESCAPE = (1 << 9),\n+} html_render_mode;\n+\n+typedef enum {\n+\tHTML_TAG_NONE = 0,\n+\tHTML_TAG_OPEN,\n+\tHTML_TAG_CLOSE,\n+} html_tag;\n+\n+int\n+sdhtml_is_tag(const uint8_t *tag_data, size_t tag_size, const char *tagname);\n+\n+extern void\n+sdhtml_renderer(struct sd_callbacks *callbacks, struct html_renderopt *options_ptr, unsigned int render_flags);\n+\n+extern void\n+sdhtml_toc_renderer(struct sd_callbacks *callbacks, struct html_renderopt *options_ptr);\n+\n+extern void\n+sdhtml_smartypants(struct buf *ob, const uint8_t *text, size_t size);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n+"}, {"sha": "367c26aeb9cc9840f32bc0b1591224a4667c0544", "filename": "src/rt/sundown/html/html_smartypants.c", "status": "added", "additions": 389, "deletions": 0, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fhtml%2Fhtml_smartypants.c", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fhtml%2Fhtml_smartypants.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fhtml%2Fhtml_smartypants.c?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,389 @@\n+/*\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#include \"buffer.h\"\n+#include \"html.h\"\n+\n+#include <string.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <ctype.h>\n+\n+#if defined(_WIN32)\n+#define snprintf\t_snprintf\t\t\n+#endif\n+\n+struct smartypants_data {\n+\tint in_squote;\n+\tint in_dquote;\n+};\n+\n+static size_t smartypants_cb__ltag(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__dquote(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__amp(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__period(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__number(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__dash(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__parens(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__squote(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__backtick(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__escape(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+\n+static size_t (*smartypants_cb_ptrs[])\n+\t(struct buf *, struct smartypants_data *, uint8_t, const uint8_t *, size_t) =\n+{\n+\tNULL,\t\t\t\t\t/* 0 */\n+\tsmartypants_cb__dash,\t/* 1 */\n+\tsmartypants_cb__parens,\t/* 2 */\n+\tsmartypants_cb__squote, /* 3 */\n+\tsmartypants_cb__dquote, /* 4 */\n+\tsmartypants_cb__amp,\t/* 5 */\n+\tsmartypants_cb__period,\t/* 6 */\n+\tsmartypants_cb__number,\t/* 7 */\n+\tsmartypants_cb__ltag,\t/* 8 */\n+\tsmartypants_cb__backtick, /* 9 */\n+\tsmartypants_cb__escape, /* 10 */\n+};\n+\n+static const uint8_t smartypants_cb_chars[] = {\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 4, 0, 0, 0, 5, 3, 2, 0, 0, 0, 0, 1, 6, 0,\n+\t0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0,\n+\t9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+};\n+\n+static inline int\n+word_boundary(uint8_t c)\n+{\n+\treturn c == 0 || isspace(c) || ispunct(c);\n+}\n+\n+static int\n+smartypants_quotes(struct buf *ob, uint8_t previous_char, uint8_t next_char, uint8_t quote, int *is_open)\n+{\n+\tchar ent[8];\n+\n+\tif (*is_open && !word_boundary(next_char))\n+\t\treturn 0;\n+\n+\tif (!(*is_open) && !word_boundary(previous_char))\n+\t\treturn 0;\n+\n+\tsnprintf(ent, sizeof(ent), \"&%c%cquo;\", (*is_open) ? 'r' : 'l', quote);\n+\t*is_open = !(*is_open);\n+\tbufputs(ob, ent);\n+\treturn 1;\n+}\n+\n+static size_t\n+smartypants_cb__squote(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (size >= 2) {\n+\t\tuint8_t t1 = tolower(text[1]);\n+\n+\t\tif (t1 == '\\'') {\n+\t\t\tif (smartypants_quotes(ob, previous_char, size >= 3 ? text[2] : 0, 'd', &smrt->in_dquote))\n+\t\t\t\treturn 1;\n+\t\t}\n+\n+\t\tif ((t1 == 's' || t1 == 't' || t1 == 'm' || t1 == 'd') &&\n+\t\t\t(size == 3 || word_boundary(text[2]))) {\n+\t\t\tBUFPUTSL(ob, \"&rsquo;\");\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tif (size >= 3) {\n+\t\t\tuint8_t t2 = tolower(text[2]);\n+\n+\t\t\tif (((t1 == 'r' && t2 == 'e') ||\n+\t\t\t\t(t1 == 'l' && t2 == 'l') ||\n+\t\t\t\t(t1 == 'v' && t2 == 'e')) &&\n+\t\t\t\t(size == 4 || word_boundary(text[3]))) {\n+\t\t\t\tBUFPUTSL(ob, \"&rsquo;\");\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif (smartypants_quotes(ob, previous_char, size > 0 ? text[1] : 0, 's', &smrt->in_squote))\n+\t\treturn 0;\n+\n+\tbufputc(ob, text[0]);\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__parens(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (size >= 3) {\n+\t\tuint8_t t1 = tolower(text[1]);\n+\t\tuint8_t t2 = tolower(text[2]);\n+\n+\t\tif (t1 == 'c' && t2 == ')') {\n+\t\t\tBUFPUTSL(ob, \"&copy;\");\n+\t\t\treturn 2;\n+\t\t}\n+\n+\t\tif (t1 == 'r' && t2 == ')') {\n+\t\t\tBUFPUTSL(ob, \"&reg;\");\n+\t\t\treturn 2;\n+\t\t}\n+\n+\t\tif (size >= 4 && t1 == 't' && t2 == 'm' && text[3] == ')') {\n+\t\t\tBUFPUTSL(ob, \"&trade;\");\n+\t\t\treturn 3;\n+\t\t}\n+\t}\n+\n+\tbufputc(ob, text[0]);\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__dash(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (size >= 3 && text[1] == '-' && text[2] == '-') {\n+\t\tBUFPUTSL(ob, \"&mdash;\");\n+\t\treturn 2;\n+\t}\n+\n+\tif (size >= 2 && text[1] == '-') {\n+\t\tBUFPUTSL(ob, \"&ndash;\");\n+\t\treturn 1;\n+\t}\n+\n+\tbufputc(ob, text[0]);\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__amp(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (size >= 6 && memcmp(text, \"&quot;\", 6) == 0) {\n+\t\tif (smartypants_quotes(ob, previous_char, size >= 7 ? text[6] : 0, 'd', &smrt->in_dquote))\n+\t\t\treturn 5;\n+\t}\n+\n+\tif (size >= 4 && memcmp(text, \"&#0;\", 4) == 0)\n+\t\treturn 3;\n+\n+\tbufputc(ob, '&');\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__period(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (size >= 3 && text[1] == '.' && text[2] == '.') {\n+\t\tBUFPUTSL(ob, \"&hellip;\");\n+\t\treturn 2;\n+\t}\n+\n+\tif (size >= 5 && text[1] == ' ' && text[2] == '.' && text[3] == ' ' && text[4] == '.') {\n+\t\tBUFPUTSL(ob, \"&hellip;\");\n+\t\treturn 4;\n+\t}\n+\n+\tbufputc(ob, text[0]);\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__backtick(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (size >= 2 && text[1] == '`') {\n+\t\tif (smartypants_quotes(ob, previous_char, size >= 3 ? text[2] : 0, 'd', &smrt->in_dquote))\n+\t\t\treturn 1;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__number(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (word_boundary(previous_char) && size >= 3) {\n+\t\tif (text[0] == '1' && text[1] == '/' && text[2] == '2') {\n+\t\t\tif (size == 3 || word_boundary(text[3])) {\n+\t\t\t\tBUFPUTSL(ob, \"&frac12;\");\n+\t\t\t\treturn 2;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (text[0] == '1' && text[1] == '/' && text[2] == '4') {\n+\t\t\tif (size == 3 || word_boundary(text[3]) ||\n+\t\t\t\t(size >= 5 && tolower(text[3]) == 't' && tolower(text[4]) == 'h')) {\n+\t\t\t\tBUFPUTSL(ob, \"&frac14;\");\n+\t\t\t\treturn 2;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (text[0] == '3' && text[1] == '/' && text[2] == '4') {\n+\t\t\tif (size == 3 || word_boundary(text[3]) ||\n+\t\t\t\t(size >= 6 && tolower(text[3]) == 't' && tolower(text[4]) == 'h' && tolower(text[5]) == 's')) {\n+\t\t\t\tBUFPUTSL(ob, \"&frac34;\");\n+\t\t\t\treturn 2;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tbufputc(ob, text[0]);\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__dquote(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (!smartypants_quotes(ob, previous_char, size > 0 ? text[1] : 0, 'd', &smrt->in_dquote))\n+\t\tBUFPUTSL(ob, \"&quot;\");\n+\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__ltag(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tstatic const char *skip_tags[] = {\n+\t  \"pre\", \"code\", \"var\", \"samp\", \"kbd\", \"math\", \"script\", \"style\"\n+\t};\n+\tstatic const size_t skip_tags_count = 8;\n+\n+\tsize_t tag, i = 0;\n+\n+\twhile (i < size && text[i] != '>')\n+\t\ti++;\n+\n+\tfor (tag = 0; tag < skip_tags_count; ++tag) {\n+\t\tif (sdhtml_is_tag(text, size, skip_tags[tag]) == HTML_TAG_OPEN)\n+\t\t\tbreak;\n+\t}\n+\n+\tif (tag < skip_tags_count) {\n+\t\tfor (;;) {\n+\t\t\twhile (i < size && text[i] != '<')\n+\t\t\t\ti++;\n+\n+\t\t\tif (i == size)\n+\t\t\t\tbreak;\n+\n+\t\t\tif (sdhtml_is_tag(text + i, size - i, skip_tags[tag]) == HTML_TAG_CLOSE)\n+\t\t\t\tbreak;\n+\n+\t\t\ti++;\n+\t\t}\n+\n+\t\twhile (i < size && text[i] != '>')\n+\t\t\ti++;\n+\t}\n+\n+\tbufput(ob, text, i + 1);\n+\treturn i;\n+}\n+\n+static size_t\n+smartypants_cb__escape(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (size < 2)\n+\t\treturn 0;\n+\n+\tswitch (text[1]) {\n+\tcase '\\\\':\n+\tcase '\"':\n+\tcase '\\'':\n+\tcase '.':\n+\tcase '-':\n+\tcase '`':\n+\t\tbufputc(ob, text[1]);\n+\t\treturn 1;\n+\n+\tdefault:\n+\t\tbufputc(ob, '\\\\');\n+\t\treturn 0;\n+\t}\n+}\n+\n+#if 0\n+static struct {\n+    uint8_t c0;\n+    const uint8_t *pattern;\n+    const uint8_t *entity;\n+    int skip;\n+} smartypants_subs[] = {\n+    { '\\'', \"'s>\",      \"&rsquo;\",  0 },\n+    { '\\'', \"'t>\",      \"&rsquo;\",  0 },\n+    { '\\'', \"'re>\",     \"&rsquo;\",  0 },\n+    { '\\'', \"'ll>\",     \"&rsquo;\",  0 },\n+    { '\\'', \"'ve>\",     \"&rsquo;\",  0 },\n+    { '\\'', \"'m>\",      \"&rsquo;\",  0 },\n+    { '\\'', \"'d>\",      \"&rsquo;\",  0 },\n+    { '-',  \"--\",       \"&mdash;\",  1 },\n+    { '-',  \"<->\",      \"&ndash;\",  0 },\n+    { '.',  \"...\",      \"&hellip;\", 2 },\n+    { '.',  \". . .\",    \"&hellip;\", 4 },\n+    { '(',  \"(c)\",      \"&copy;\",   2 },\n+    { '(',  \"(r)\",      \"&reg;\",    2 },\n+    { '(',  \"(tm)\",     \"&trade;\",  3 },\n+    { '3',  \"<3/4>\",    \"&frac34;\", 2 },\n+    { '3',  \"<3/4ths>\", \"&frac34;\", 2 },\n+    { '1',  \"<1/2>\",    \"&frac12;\", 2 },\n+    { '1',  \"<1/4>\",    \"&frac14;\", 2 },\n+    { '1',  \"<1/4th>\",  \"&frac14;\", 2 },\n+    { '&',  \"&#0;\",      0,       3 },\n+};\n+#endif\n+\n+void\n+sdhtml_smartypants(struct buf *ob, const uint8_t *text, size_t size)\n+{\n+\tsize_t i;\n+\tstruct smartypants_data smrt = {0, 0};\n+\n+\tif (!text)\n+\t\treturn;\n+\n+\tbufgrow(ob, size);\n+\n+\tfor (i = 0; i < size; ++i) {\n+\t\tsize_t org;\n+\t\tuint8_t action = 0;\n+\n+\t\torg = i;\n+\t\twhile (i < size && (action = smartypants_cb_chars[text[i]]) == 0)\n+\t\t\ti++;\n+\n+\t\tif (i > org)\n+\t\t\tbufput(ob, text + org, i - org);\n+\n+\t\tif (i < size) {\n+\t\t\ti += smartypants_cb_ptrs[(int)action]\n+\t\t\t\t(ob, &smrt, i ? text[i - 1] : 0, text + i, size - i);\n+\t\t}\n+\t}\n+}\n+\n+"}, {"sha": "a41d7d1b335025bc65a56526f04ca42050e297ec", "filename": "src/rt/sundown/html_block_names.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fhtml_block_names.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fhtml_block_names.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fhtml_block_names.txt?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,25 @@\n+##\n+p\n+dl\n+h1\n+h2\n+h3\n+h4\n+h5\n+h6\n+ol\n+ul\n+del\n+div\n+ins\n+pre\n+form\n+math\n+table\n+figure\n+iframe\n+script\n+style\n+fieldset\n+noscript\n+blockquote"}, {"sha": "6f8d6ab9902b597f3acd68d8f11749f88689bd8c", "filename": "src/rt/sundown/src/autolink.c", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fautolink.c", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fautolink.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fautolink.c?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#include \"buffer.h\"\n+#include \"autolink.h\"\n+\n+#include <string.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <ctype.h>\n+\n+#if defined(_WIN32)\n+#define strncasecmp\t_strnicmp\n+#endif\n+\n+int\n+sd_autolink_issafe(const uint8_t *link, size_t link_len)\n+{\n+\tstatic const size_t valid_uris_count = 5;\n+\tstatic const char *valid_uris[] = {\n+\t\t\"/\", \"http://\", \"https://\", \"ftp://\", \"mailto:\"\n+\t};\n+\n+\tsize_t i;\n+\n+\tfor (i = 0; i < valid_uris_count; ++i) {\n+\t\tsize_t len = strlen(valid_uris[i]);\n+\n+\t\tif (link_len > len &&\n+\t\t\tstrncasecmp((char *)link, valid_uris[i], len) == 0 &&\n+\t\t\tisalnum(link[len]))\n+\t\t\treturn 1;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+static size_t\n+autolink_delim(uint8_t *data, size_t link_end, size_t max_rewind, size_t size)\n+{\n+\tuint8_t cclose, copen = 0;\n+\tsize_t i;\n+\n+\tfor (i = 0; i < link_end; ++i)\n+\t\tif (data[i] == '<') {\n+\t\t\tlink_end = i;\n+\t\t\tbreak;\n+\t\t}\n+\n+\twhile (link_end > 0) {\n+\t\tif (strchr(\"?!.,\", data[link_end - 1]) != NULL)\n+\t\t\tlink_end--;\n+\n+\t\telse if (data[link_end - 1] == ';') {\n+\t\t\tsize_t new_end = link_end - 2;\n+\n+\t\t\twhile (new_end > 0 && isalpha(data[new_end]))\n+\t\t\t\tnew_end--;\n+\n+\t\t\tif (new_end < link_end - 2 && data[new_end] == '&')\n+\t\t\t\tlink_end = new_end;\n+\t\t\telse\n+\t\t\t\tlink_end--;\n+\t\t}\n+\t\telse break;\n+\t}\n+\n+\tif (link_end == 0)\n+\t\treturn 0;\n+\n+\tcclose = data[link_end - 1];\n+\n+\tswitch (cclose) {\n+\tcase '\"':\tcopen = '\"'; break;\n+\tcase '\\'':\tcopen = '\\''; break;\n+\tcase ')':\tcopen = '('; break;\n+\tcase ']':\tcopen = '['; break;\n+\tcase '}':\tcopen = '{'; break;\n+\t}\n+\n+\tif (copen != 0) {\n+\t\tsize_t closing = 0;\n+\t\tsize_t opening = 0;\n+\t\tsize_t i = 0;\n+\n+\t\t/* Try to close the final punctuation sign in this same line;\n+\t\t * if we managed to close it outside of the URL, that means that it's\n+\t\t * not part of the URL. If it closes inside the URL, that means it\n+\t\t * is part of the URL.\n+\t\t *\n+\t\t * Examples:\n+\t\t *\n+\t\t *\tfoo http://www.pokemon.com/Pikachu_(Electric) bar\n+\t\t *\t\t=> http://www.pokemon.com/Pikachu_(Electric)\n+\t\t *\n+\t\t *\tfoo (http://www.pokemon.com/Pikachu_(Electric)) bar\n+\t\t *\t\t=> http://www.pokemon.com/Pikachu_(Electric)\n+\t\t *\n+\t\t *\tfoo http://www.pokemon.com/Pikachu_(Electric)) bar\n+\t\t *\t\t=> http://www.pokemon.com/Pikachu_(Electric))\n+\t\t *\n+\t\t *\t(foo http://www.pokemon.com/Pikachu_(Electric)) bar\n+\t\t *\t\t=> foo http://www.pokemon.com/Pikachu_(Electric)\n+\t\t */\n+\n+\t\twhile (i < link_end) {\n+\t\t\tif (data[i] == copen)\n+\t\t\t\topening++;\n+\t\t\telse if (data[i] == cclose)\n+\t\t\t\tclosing++;\n+\n+\t\t\ti++;\n+\t\t}\n+\n+\t\tif (closing != opening)\n+\t\t\tlink_end--;\n+\t}\n+\n+\treturn link_end;\n+}\n+\n+static size_t\n+check_domain(uint8_t *data, size_t size, int allow_short)\n+{\n+\tsize_t i, np = 0;\n+\n+\tif (!isalnum(data[0]))\n+\t\treturn 0;\n+\n+\tfor (i = 1; i < size - 1; ++i) {\n+\t\tif (data[i] == '.') np++;\n+\t\telse if (!isalnum(data[i]) && data[i] != '-') break;\n+\t}\n+\n+\tif (allow_short) {\n+\t\t/* We don't need a valid domain in the strict sense (with\n+\t\t * least one dot; so just make sure it's composed of valid\n+\t\t * domain characters and return the length of the the valid\n+\t\t * sequence. */\n+\t\treturn i;\n+\t} else {\n+\t\t/* a valid domain needs to have at least a dot.\n+\t\t * that's as far as we get */\n+\t\treturn np ? i : 0;\n+\t}\n+}\n+\n+size_t\n+sd_autolink__www(\n+\tsize_t *rewind_p,\n+\tstruct buf *link,\n+\tuint8_t *data,\n+\tsize_t max_rewind,\n+\tsize_t size,\n+\tunsigned int flags)\n+{\n+\tsize_t link_end;\n+\n+\tif (max_rewind > 0 && !ispunct(data[-1]) && !isspace(data[-1]))\n+\t\treturn 0;\n+\n+\tif (size < 4 || memcmp(data, \"www.\", strlen(\"www.\")) != 0)\n+\t\treturn 0;\n+\n+\tlink_end = check_domain(data, size, 0);\n+\n+\tif (link_end == 0)\n+\t\treturn 0;\n+\n+\twhile (link_end < size && !isspace(data[link_end]))\n+\t\tlink_end++;\n+\n+\tlink_end = autolink_delim(data, link_end, max_rewind, size);\n+\n+\tif (link_end == 0)\n+\t\treturn 0;\n+\n+\tbufput(link, data, link_end);\n+\t*rewind_p = 0;\n+\n+\treturn (int)link_end;\n+}\n+\n+size_t\n+sd_autolink__email(\n+\tsize_t *rewind_p,\n+\tstruct buf *link,\n+\tuint8_t *data,\n+\tsize_t max_rewind,\n+\tsize_t size,\n+\tunsigned int flags)\n+{\n+\tsize_t link_end, rewind;\n+\tint nb = 0, np = 0;\n+\n+\tfor (rewind = 0; rewind < max_rewind; ++rewind) {\n+\t\tuint8_t c = data[-rewind - 1];\n+\n+\t\tif (isalnum(c))\n+\t\t\tcontinue;\n+\n+\t\tif (strchr(\".+-_\", c) != NULL)\n+\t\t\tcontinue;\n+\n+\t\tbreak;\n+\t}\n+\n+\tif (rewind == 0)\n+\t\treturn 0;\n+\n+\tfor (link_end = 0; link_end < size; ++link_end) {\n+\t\tuint8_t c = data[link_end];\n+\n+\t\tif (isalnum(c))\n+\t\t\tcontinue;\n+\n+\t\tif (c == '@')\n+\t\t\tnb++;\n+\t\telse if (c == '.' && link_end < size - 1)\n+\t\t\tnp++;\n+\t\telse if (c != '-' && c != '_')\n+\t\t\tbreak;\n+\t}\n+\n+\tif (link_end < 2 || nb != 1 || np == 0 ||\n+\t\t!isalpha(data[link_end - 1]))\n+\t\treturn 0;\n+\n+\tlink_end = autolink_delim(data, link_end, max_rewind, size);\n+\n+\tif (link_end == 0)\n+\t\treturn 0;\n+\n+\tbufput(link, data - rewind, link_end + rewind);\n+\t*rewind_p = rewind;\n+\n+\treturn link_end;\n+}\n+\n+size_t\n+sd_autolink__url(\n+\tsize_t *rewind_p,\n+\tstruct buf *link,\n+\tuint8_t *data,\n+\tsize_t max_rewind,\n+\tsize_t size,\n+\tunsigned int flags)\n+{\n+\tsize_t link_end, rewind = 0, domain_len;\n+\n+\tif (size < 4 || data[1] != '/' || data[2] != '/')\n+\t\treturn 0;\n+\n+\twhile (rewind < max_rewind && isalpha(data[-rewind - 1]))\n+\t\trewind++;\n+\n+\tif (!sd_autolink_issafe(data - rewind, size + rewind))\n+\t\treturn 0;\n+\n+\tlink_end = strlen(\"://\");\n+\n+\tdomain_len = check_domain(\n+\t\tdata + link_end,\n+\t\tsize - link_end,\n+\t\tflags & SD_AUTOLINK_SHORT_DOMAINS);\n+\n+\tif (domain_len == 0)\n+\t\treturn 0;\n+\n+\tlink_end += domain_len;\n+\twhile (link_end < size && !isspace(data[link_end]))\n+\t\tlink_end++;\n+\n+\tlink_end = autolink_delim(data, link_end, max_rewind, size);\n+\n+\tif (link_end == 0)\n+\t\treturn 0;\n+\n+\tbufput(link, data - rewind, link_end + rewind);\n+\t*rewind_p = rewind;\n+\n+\treturn link_end;\n+}\n+"}, {"sha": "65e0fe6f14489ae62085933d58ea6bec86f06e93", "filename": "src/rt/sundown/src/autolink.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fautolink.h", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fautolink.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fautolink.h?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#ifndef UPSKIRT_AUTOLINK_H\n+#define UPSKIRT_AUTOLINK_H\n+\n+#include \"buffer.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+enum {\n+\tSD_AUTOLINK_SHORT_DOMAINS = (1 << 0),\n+};\n+\n+int\n+sd_autolink_issafe(const uint8_t *link, size_t link_len);\n+\n+size_t\n+sd_autolink__www(size_t *rewind_p, struct buf *link,\n+\tuint8_t *data, size_t offset, size_t size, unsigned int flags);\n+\n+size_t\n+sd_autolink__email(size_t *rewind_p, struct buf *link,\n+\tuint8_t *data, size_t offset, size_t size, unsigned int flags);\n+\n+size_t\n+sd_autolink__url(size_t *rewind_p, struct buf *link,\n+\tuint8_t *data, size_t offset, size_t size, unsigned int flags);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n+\n+/* vim: set filetype=c: */"}, {"sha": "47b40ce2f75e75d42756a386d29431b6de674b7a", "filename": "src/rt/sundown/src/buffer.c", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fbuffer.c", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fbuffer.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fbuffer.c?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2008, Natacha Port\u00e9\n+ * Copyright (c) 2011, Vicent Mart\u00ed\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#define BUFFER_MAX_ALLOC_SIZE (1024 * 1024 * 16) //16mb\n+\n+#include \"buffer.h\"\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+\n+/* MSVC compat */\n+#if defined(_MSC_VER)\n+#\tdefine _buf_vsnprintf _vsnprintf\n+#else\n+#\tdefine _buf_vsnprintf vsnprintf\n+#endif\n+\n+int\n+bufprefix(const struct buf *buf, const char *prefix)\n+{\n+\tsize_t i;\n+\tassert(buf && buf->unit);\n+\n+\tfor (i = 0; i < buf->size; ++i) {\n+\t\tif (prefix[i] == 0)\n+\t\t\treturn 0;\n+\n+\t\tif (buf->data[i] != prefix[i])\n+\t\t\treturn buf->data[i] - prefix[i];\n+\t}\n+\n+\treturn 0;\n+}\n+\n+/* bufgrow: increasing the allocated size to the given value */\n+int\n+bufgrow(struct buf *buf, size_t neosz)\n+{\n+\tsize_t neoasz;\n+\tvoid *neodata;\n+\n+\tassert(buf && buf->unit);\n+\n+\tif (neosz > BUFFER_MAX_ALLOC_SIZE)\n+\t\treturn BUF_ENOMEM;\n+\n+\tif (buf->asize >= neosz)\n+\t\treturn BUF_OK;\n+\n+\tneoasz = buf->asize + buf->unit;\n+\twhile (neoasz < neosz)\n+\t\tneoasz += buf->unit;\n+\n+\tneodata = realloc(buf->data, neoasz);\n+\tif (!neodata)\n+\t\treturn BUF_ENOMEM;\n+\n+\tbuf->data = neodata;\n+\tbuf->asize = neoasz;\n+\treturn BUF_OK;\n+}\n+\n+\n+/* bufnew: allocation of a new buffer */\n+struct buf *\n+bufnew(size_t unit)\n+{\n+\tstruct buf *ret;\n+\tret = malloc(sizeof (struct buf));\n+\n+\tif (ret) {\n+\t\tret->data = 0;\n+\t\tret->size = ret->asize = 0;\n+\t\tret->unit = unit;\n+\t}\n+\treturn ret;\n+}\n+\n+/* bufnullterm: NULL-termination of the string array */\n+const char *\n+bufcstr(struct buf *buf)\n+{\n+\tassert(buf && buf->unit);\n+\n+\tif (buf->size < buf->asize && buf->data[buf->size] == 0)\n+\t\treturn (char *)buf->data;\n+\n+\tif (buf->size + 1 <= buf->asize || bufgrow(buf, buf->size + 1) == 0) {\n+\t\tbuf->data[buf->size] = 0;\n+\t\treturn (char *)buf->data;\n+\t}\n+\n+\treturn NULL;\n+}\n+\n+/* bufprintf: formatted printing to a buffer */\n+void\n+bufprintf(struct buf *buf, const char *fmt, ...)\n+{\n+\tva_list ap;\n+\tint n;\n+\n+\tassert(buf && buf->unit);\n+\n+\tif (buf->size >= buf->asize && bufgrow(buf, buf->size + 1) < 0)\n+\t\treturn;\n+\t\n+\tva_start(ap, fmt);\n+\tn = _buf_vsnprintf((char *)buf->data + buf->size, buf->asize - buf->size, fmt, ap);\n+\tva_end(ap);\n+\n+\tif (n < 0) {\n+#ifdef _MSC_VER\n+\t\tva_start(ap, fmt);\n+\t\tn = _vscprintf(fmt, ap);\n+\t\tva_end(ap);\n+#else\n+\t\treturn;\n+#endif\n+\t}\n+\n+\tif ((size_t)n >= buf->asize - buf->size) {\n+\t\tif (bufgrow(buf, buf->size + n + 1) < 0)\n+\t\t\treturn;\n+\n+\t\tva_start(ap, fmt);\n+\t\tn = _buf_vsnprintf((char *)buf->data + buf->size, buf->asize - buf->size, fmt, ap);\n+\t\tva_end(ap);\n+\t}\n+\n+\tif (n < 0)\n+\t\treturn;\n+\n+\tbuf->size += n;\n+}\n+\n+/* bufput: appends raw data to a buffer */\n+void\n+bufput(struct buf *buf, const void *data, size_t len)\n+{\n+\tassert(buf && buf->unit);\n+\n+\tif (buf->size + len > buf->asize && bufgrow(buf, buf->size + len) < 0)\n+\t\treturn;\n+\n+\tmemcpy(buf->data + buf->size, data, len);\n+\tbuf->size += len;\n+}\n+\n+/* bufputs: appends a NUL-terminated string to a buffer */\n+void\n+bufputs(struct buf *buf, const char *str)\n+{\n+\tbufput(buf, str, strlen(str));\n+}\n+\n+\n+/* bufputc: appends a single uint8_t to a buffer */\n+void\n+bufputc(struct buf *buf, int c)\n+{\n+\tassert(buf && buf->unit);\n+\n+\tif (buf->size + 1 > buf->asize && bufgrow(buf, buf->size + 1) < 0)\n+\t\treturn;\n+\n+\tbuf->data[buf->size] = c;\n+\tbuf->size += 1;\n+}\n+\n+/* bufrelease: decrease the reference count and free the buffer if needed */\n+void\n+bufrelease(struct buf *buf)\n+{\n+\tif (!buf)\n+\t\treturn;\n+\n+\tfree(buf->data);\n+\tfree(buf);\n+}\n+\n+\n+/* bufreset: frees internal data of the buffer */\n+void\n+bufreset(struct buf *buf)\n+{\n+\tif (!buf)\n+\t\treturn;\n+\n+\tfree(buf->data);\n+\tbuf->data = NULL;\n+\tbuf->size = buf->asize = 0;\n+}\n+\n+/* bufslurp: removes a given number of bytes from the head of the array */\n+void\n+bufslurp(struct buf *buf, size_t len)\n+{\n+\tassert(buf && buf->unit);\n+\n+\tif (len >= buf->size) {\n+\t\tbuf->size = 0;\n+\t\treturn;\n+\t}\n+\n+\tbuf->size -= len;\n+\tmemmove(buf->data, buf->data + len, buf->size);\n+}\n+"}, {"sha": "221d142eda337547db55266e1705021964cdd4c9", "filename": "src/rt/sundown/src/buffer.h", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fbuffer.h", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fbuffer.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fbuffer.h?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) 2008, Natacha Port\u00e9\n+ * Copyright (c) 2011, Vicent Mart\u00ed\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#ifndef BUFFER_H__\n+#define BUFFER_H__\n+\n+#include <stddef.h>\n+#include <stdarg.h>\n+#include <stdint.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#if defined(_MSC_VER)\n+#define __attribute__(x)\n+#define inline\n+#endif\n+\n+typedef enum {\n+\tBUF_OK = 0,\n+\tBUF_ENOMEM = -1,\n+} buferror_t;\n+\n+/* struct buf: character array buffer */\n+struct buf {\n+\tuint8_t *data;\t\t/* actual character data */\n+\tsize_t size;\t/* size of the string */\n+\tsize_t asize;\t/* allocated size (0 = volatile buffer) */\n+\tsize_t unit;\t/* reallocation unit size (0 = read-only buffer) */\n+};\n+\n+/* CONST_BUF: global buffer from a string litteral */\n+#define BUF_STATIC(string) \\\n+\t{ (uint8_t *)string, sizeof string -1, sizeof string, 0, 0 }\n+\n+/* VOLATILE_BUF: macro for creating a volatile buffer on the stack */\n+#define BUF_VOLATILE(strname) \\\n+\t{ (uint8_t *)strname, strlen(strname), 0, 0, 0 }\n+\n+/* BUFPUTSL: optimized bufputs of a string litteral */\n+#define BUFPUTSL(output, literal) \\\n+\tbufput(output, literal, sizeof literal - 1)\n+\n+/* bufgrow: increasing the allocated size to the given value */\n+int bufgrow(struct buf *, size_t);\n+\n+/* bufnew: allocation of a new buffer */\n+struct buf *bufnew(size_t) __attribute__ ((malloc));\n+\n+/* bufnullterm: NUL-termination of the string array (making a C-string) */\n+const char *bufcstr(struct buf *);\n+\n+/* bufprefix: compare the beginning of a buffer with a string */\n+int bufprefix(const struct buf *buf, const char *prefix);\n+\n+/* bufput: appends raw data to a buffer */\n+void bufput(struct buf *, const void *, size_t);\n+\n+/* bufputs: appends a NUL-terminated string to a buffer */\n+void bufputs(struct buf *, const char *);\n+\n+/* bufputc: appends a single char to a buffer */\n+void bufputc(struct buf *, int);\n+\n+/* bufrelease: decrease the reference count and free the buffer if needed */\n+void bufrelease(struct buf *);\n+\n+/* bufreset: frees internal data of the buffer */\n+void bufreset(struct buf *);\n+\n+/* bufslurp: removes a given number of bytes from the head of the array */\n+void bufslurp(struct buf *, size_t);\n+\n+/* bufprintf: formatted printing to a buffer */\n+void bufprintf(struct buf *, const char *, ...) __attribute__ ((format (printf, 2, 3)));\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"}, {"sha": "09a758fe275f701010582a44bbc01a1905554a98", "filename": "src/rt/sundown/src/html_blocks.h", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fhtml_blocks.h", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fhtml_blocks.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fhtml_blocks.h?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,206 @@\n+/* C code produced by gperf version 3.0.3 */\n+/* Command-line: gperf -N find_block_tag -H hash_block_tag -C -c -E --ignore-case html_block_names.txt  */\n+/* Computed positions: -k'1-2' */\n+\n+#if !((' ' == 32) && ('!' == 33) && ('\"' == 34) && ('#' == 35) \\\n+      && ('%' == 37) && ('&' == 38) && ('\\'' == 39) && ('(' == 40) \\\n+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \\\n+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \\\n+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \\\n+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \\\n+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \\\n+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \\\n+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \\\n+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \\\n+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \\\n+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \\\n+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \\\n+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \\\n+      && ('Z' == 90) && ('[' == 91) && ('\\\\' == 92) && (']' == 93) \\\n+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \\\n+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \\\n+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \\\n+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \\\n+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \\\n+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \\\n+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \\\n+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))\n+/* The character set is not based on ISO-646.  */\n+error \"gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>.\"\n+#endif\n+\n+/* maximum key range = 37, duplicates = 0 */\n+\n+#ifndef GPERF_DOWNCASE\n+#define GPERF_DOWNCASE 1\n+static unsigned char gperf_downcase[256] =\n+  {\n+      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,\n+     15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,\n+     30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,\n+     45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,\n+     60,  61,  62,  63,  64,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106,\n+    107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,\n+    122,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104,\n+    105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n+    120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134,\n+    135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,\n+    150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,\n+    165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,\n+    180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194,\n+    195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,\n+    210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224,\n+    225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,\n+    240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,\n+    255\n+  };\n+#endif\n+\n+#ifndef GPERF_CASE_STRNCMP\n+#define GPERF_CASE_STRNCMP 1\n+static int\n+gperf_case_strncmp (s1, s2, n)\n+     register const char *s1;\n+     register const char *s2;\n+     register unsigned int n;\n+{\n+  for (; n > 0;)\n+    {\n+      unsigned char c1 = gperf_downcase[(unsigned char)*s1++];\n+      unsigned char c2 = gperf_downcase[(unsigned char)*s2++];\n+      if (c1 != 0 && c1 == c2)\n+        {\n+          n--;\n+          continue;\n+        }\n+      return (int)c1 - (int)c2;\n+    }\n+  return 0;\n+}\n+#endif\n+\n+#ifdef __GNUC__\n+__inline\n+#else\n+#ifdef __cplusplus\n+inline\n+#endif\n+#endif\n+static unsigned int\n+hash_block_tag (str, len)\n+     register const char *str;\n+     register unsigned int len;\n+{\n+  static const unsigned char asso_values[] =\n+    {\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+       8, 30, 25, 20, 15, 10, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38,  0, 38,  0, 38,\n+       5,  5,  5, 15,  0, 38, 38,  0, 15, 10,\n+       0, 38, 38, 15,  0,  5, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38,  0, 38,\n+       0, 38,  5,  5,  5, 15,  0, 38, 38,  0,\n+      15, 10,  0, 38, 38, 15,  0,  5, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38\n+    };\n+  register int hval = len;\n+\n+  switch (hval)\n+    {\n+      default:\n+        hval += asso_values[(unsigned char)str[1]+1];\n+      /*FALLTHROUGH*/\n+      case 1:\n+        hval += asso_values[(unsigned char)str[0]];\n+        break;\n+    }\n+  return hval;\n+}\n+\n+#ifdef __GNUC__\n+__inline\n+#ifdef __GNUC_STDC_INLINE__\n+__attribute__ ((__gnu_inline__))\n+#endif\n+#endif\n+const char *\n+find_block_tag (str, len)\n+     register const char *str;\n+     register unsigned int len;\n+{\n+  enum\n+    {\n+      TOTAL_KEYWORDS = 24,\n+      MIN_WORD_LENGTH = 1,\n+      MAX_WORD_LENGTH = 10,\n+      MIN_HASH_VALUE = 1,\n+      MAX_HASH_VALUE = 37\n+    };\n+\n+  static const char * const wordlist[] =\n+    {\n+      \"\",\n+      \"p\",\n+      \"dl\",\n+      \"div\",\n+      \"math\",\n+      \"table\",\n+      \"\",\n+      \"ul\",\n+      \"del\",\n+      \"form\",\n+      \"blockquote\",\n+      \"figure\",\n+      \"ol\",\n+      \"fieldset\",\n+      \"\",\n+      \"h1\",\n+      \"\",\n+      \"h6\",\n+      \"pre\",\n+      \"\", \"\",\n+      \"script\",\n+      \"h5\",\n+      \"noscript\",\n+      \"\",\n+      \"style\",\n+      \"iframe\",\n+      \"h4\",\n+      \"ins\",\n+      \"\", \"\", \"\",\n+      \"h3\",\n+      \"\", \"\", \"\", \"\",\n+      \"h2\"\n+    };\n+\n+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n+    {\n+      register int key = hash_block_tag (str, len);\n+\n+      if (key <= MAX_HASH_VALUE && key >= 0)\n+        {\n+          register const char *s = wordlist[key];\n+\n+          if ((((unsigned char)*str ^ (unsigned char)*s) & ~32) == 0 && !gperf_case_strncmp (str, s, len) && s[len] == '\\0')\n+            return s;\n+        }\n+    }\n+  return 0;\n+}"}, {"sha": "ea3cf23253ad3fe07af31a047db75e4e4a1c017d", "filename": "src/rt/sundown/src/markdown.c", "status": "added", "additions": 2556, "deletions": 0, "changes": 2556, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fmarkdown.c", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fmarkdown.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fmarkdown.c?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,2556 @@\n+/* markdown.c - generic markdown parser */\n+\n+/*\n+ * Copyright (c) 2009, Natacha Port\u00e9\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#include \"markdown.h\"\n+#include \"stack.h\"\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <ctype.h>\n+#include <stdio.h>\n+\n+#if defined(_WIN32)\n+#define strncasecmp\t_strnicmp\n+#endif\n+\n+#define REF_TABLE_SIZE 8\n+\n+#define BUFFER_BLOCK 0\n+#define BUFFER_SPAN 1\n+\n+#define MKD_LI_END 8\t/* internal list flag */\n+\n+#define gperf_case_strncmp(s1, s2, n) strncasecmp(s1, s2, n)\n+#define GPERF_DOWNCASE 1\n+#define GPERF_CASE_STRNCMP 1\n+#include \"html_blocks.h\"\n+\n+/***************\n+ * LOCAL TYPES *\n+ ***************/\n+\n+/* link_ref: reference to a link */\n+struct link_ref {\n+\tunsigned int id;\n+\n+\tstruct buf *link;\n+\tstruct buf *title;\n+\n+\tstruct link_ref *next;\n+};\n+\n+/* char_trigger: function pointer to render active chars */\n+/*   returns the number of chars taken care of */\n+/*   data is the pointer of the beginning of the span */\n+/*   offset is the number of valid chars before data */\n+struct sd_markdown;\n+typedef size_t\n+(*char_trigger)(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+\n+static size_t char_emphasis(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_linebreak(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_codespan(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_escape(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_entity(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_langle_tag(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_autolink_url(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_autolink_email(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_autolink_www(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_link(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_superscript(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+\n+enum markdown_char_t {\n+\tMD_CHAR_NONE = 0,\n+\tMD_CHAR_EMPHASIS,\n+\tMD_CHAR_CODESPAN,\n+\tMD_CHAR_LINEBREAK,\n+\tMD_CHAR_LINK,\n+\tMD_CHAR_LANGLE,\n+\tMD_CHAR_ESCAPE,\n+\tMD_CHAR_ENTITITY,\n+\tMD_CHAR_AUTOLINK_URL,\n+\tMD_CHAR_AUTOLINK_EMAIL,\n+\tMD_CHAR_AUTOLINK_WWW,\n+\tMD_CHAR_SUPERSCRIPT,\n+};\n+\n+static char_trigger markdown_char_ptrs[] = {\n+\tNULL,\n+\t&char_emphasis,\n+\t&char_codespan,\n+\t&char_linebreak,\n+\t&char_link,\n+\t&char_langle_tag,\n+\t&char_escape,\n+\t&char_entity,\n+\t&char_autolink_url,\n+\t&char_autolink_email,\n+\t&char_autolink_www,\n+\t&char_superscript,\n+};\n+\n+/* render \u2022 structure containing one particular render */\n+struct sd_markdown {\n+\tstruct sd_callbacks\tcb;\n+\tvoid *opaque;\n+\n+\tstruct link_ref *refs[REF_TABLE_SIZE];\n+\tuint8_t active_char[256];\n+\tstruct stack work_bufs[2];\n+\tunsigned int ext_flags;\n+\tsize_t max_nesting;\n+\tint in_link_body;\n+};\n+\n+/***************************\n+ * HELPER FUNCTIONS *\n+ ***************************/\n+\n+static inline struct buf *\n+rndr_newbuf(struct sd_markdown *rndr, int type)\n+{\n+\tstatic const size_t buf_size[2] = {256, 64};\n+\tstruct buf *work = NULL;\n+\tstruct stack *pool = &rndr->work_bufs[type];\n+\n+\tif (pool->size < pool->asize &&\n+\t\tpool->item[pool->size] != NULL) {\n+\t\twork = pool->item[pool->size++];\n+\t\twork->size = 0;\n+\t} else {\n+\t\twork = bufnew(buf_size[type]);\n+\t\tstack_push(pool, work);\n+\t}\n+\n+\treturn work;\n+}\n+\n+static inline void\n+rndr_popbuf(struct sd_markdown *rndr, int type)\n+{\n+\trndr->work_bufs[type].size--;\n+}\n+\n+static void\n+unscape_text(struct buf *ob, struct buf *src)\n+{\n+\tsize_t i = 0, org;\n+\twhile (i < src->size) {\n+\t\torg = i;\n+\t\twhile (i < src->size && src->data[i] != '\\\\')\n+\t\t\ti++;\n+\n+\t\tif (i > org)\n+\t\t\tbufput(ob, src->data + org, i - org);\n+\n+\t\tif (i + 1 >= src->size)\n+\t\t\tbreak;\n+\n+\t\tbufputc(ob, src->data[i + 1]);\n+\t\ti += 2;\n+\t}\n+}\n+\n+static unsigned int\n+hash_link_ref(const uint8_t *link_ref, size_t length)\n+{\n+\tsize_t i;\n+\tunsigned int hash = 0;\n+\n+\tfor (i = 0; i < length; ++i)\n+\t\thash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;\n+\n+\treturn hash;\n+}\n+\n+static struct link_ref *\n+add_link_ref(\n+\tstruct link_ref **references,\n+\tconst uint8_t *name, size_t name_size)\n+{\n+\tstruct link_ref *ref = calloc(1, sizeof(struct link_ref));\n+\n+\tif (!ref)\n+\t\treturn NULL;\n+\n+\tref->id = hash_link_ref(name, name_size);\n+\tref->next = references[ref->id % REF_TABLE_SIZE];\n+\n+\treferences[ref->id % REF_TABLE_SIZE] = ref;\n+\treturn ref;\n+}\n+\n+static struct link_ref *\n+find_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n+{\n+\tunsigned int hash = hash_link_ref(name, length);\n+\tstruct link_ref *ref = NULL;\n+\n+\tref = references[hash % REF_TABLE_SIZE];\n+\n+\twhile (ref != NULL) {\n+\t\tif (ref->id == hash)\n+\t\t\treturn ref;\n+\n+\t\tref = ref->next;\n+\t}\n+\n+\treturn NULL;\n+}\n+\n+static void\n+free_link_refs(struct link_ref **references)\n+{\n+\tsize_t i;\n+\n+\tfor (i = 0; i < REF_TABLE_SIZE; ++i) {\n+\t\tstruct link_ref *r = references[i];\n+\t\tstruct link_ref *next;\n+\n+\t\twhile (r) {\n+\t\t\tnext = r->next;\n+\t\t\tbufrelease(r->link);\n+\t\t\tbufrelease(r->title);\n+\t\t\tfree(r);\n+\t\t\tr = next;\n+\t\t}\n+\t}\n+}\n+\n+/*\n+ * Check whether a char is a Markdown space.\n+\n+ * Right now we only consider spaces the actual\n+ * space and a newline: tabs and carriage returns\n+ * are filtered out during the preprocessing phase.\n+ *\n+ * If we wanted to actually be UTF-8 compliant, we\n+ * should instead extract an Unicode codepoint from\n+ * this character and check for space properties.\n+ */\n+static inline int\n+_isspace(int c)\n+{\n+\treturn c == ' ' || c == '\\n';\n+}\n+\n+/****************************\n+ * INLINE PARSING FUNCTIONS *\n+ ****************************/\n+\n+/* is_mail_autolink \u2022 looks for the address part of a mail autolink and '>' */\n+/* this is less strict than the original markdown e-mail address matching */\n+static size_t\n+is_mail_autolink(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0, nb = 0;\n+\n+\t/* address is assumed to be: [-@._a-zA-Z0-9]+ with exactly one '@' */\n+\tfor (i = 0; i < size; ++i) {\n+\t\tif (isalnum(data[i]))\n+\t\t\tcontinue;\n+\n+\t\tswitch (data[i]) {\n+\t\t\tcase '@':\n+\t\t\t\tnb++;\n+\n+\t\t\tcase '-':\n+\t\t\tcase '.':\n+\t\t\tcase '_':\n+\t\t\t\tbreak;\n+\n+\t\t\tcase '>':\n+\t\t\t\treturn (nb == 1) ? i + 1 : 0;\n+\n+\t\t\tdefault:\n+\t\t\t\treturn 0;\n+\t\t}\n+\t}\n+\n+\treturn 0;\n+}\n+\n+/* tag_length \u2022 returns the length of the given tag, or 0 is it's not valid */\n+static size_t\n+tag_length(uint8_t *data, size_t size, enum mkd_autolink *autolink)\n+{\n+\tsize_t i, j;\n+\n+\t/* a valid tag can't be shorter than 3 chars */\n+\tif (size < 3) return 0;\n+\n+\t/* begins with a '<' optionally followed by '/', followed by letter or number */\n+\tif (data[0] != '<') return 0;\n+\ti = (data[1] == '/') ? 2 : 1;\n+\n+\tif (!isalnum(data[i]))\n+\t\treturn 0;\n+\n+\t/* scheme test */\n+\t*autolink = MKDA_NOT_AUTOLINK;\n+\n+\t/* try to find the beginning of an URI */\n+\twhile (i < size && (isalnum(data[i]) || data[i] == '.' || data[i] == '+' || data[i] == '-'))\n+\t\ti++;\n+\n+\tif (i > 1 && data[i] == '@') {\n+\t\tif ((j = is_mail_autolink(data + i, size - i)) != 0) {\n+\t\t\t*autolink = MKDA_EMAIL;\n+\t\t\treturn i + j;\n+\t\t}\n+\t}\n+\n+\tif (i > 2 && data[i] == ':') {\n+\t\t*autolink = MKDA_NORMAL;\n+\t\ti++;\n+\t}\n+\n+\t/* completing autolink test: no whitespace or ' or \" */\n+\tif (i >= size)\n+\t\t*autolink = MKDA_NOT_AUTOLINK;\n+\n+\telse if (*autolink) {\n+\t\tj = i;\n+\n+\t\twhile (i < size) {\n+\t\t\tif (data[i] == '\\\\') i += 2;\n+\t\t\telse if (data[i] == '>' || data[i] == '\\'' ||\n+\t\t\t\t\tdata[i] == '\"' || data[i] == ' ' || data[i] == '\\n')\n+\t\t\t\t\tbreak;\n+\t\t\telse i++;\n+\t\t}\n+\n+\t\tif (i >= size) return 0;\n+\t\tif (i > j && data[i] == '>') return i + 1;\n+\t\t/* one of the forbidden chars has been found */\n+\t\t*autolink = MKDA_NOT_AUTOLINK;\n+\t}\n+\n+\t/* looking for sometinhg looking like a tag end */\n+\twhile (i < size && data[i] != '>') i++;\n+\tif (i >= size) return 0;\n+\treturn i + 1;\n+}\n+\n+/* parse_inline \u2022 parses inline markdown elements */\n+static void\n+parse_inline(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0, end = 0;\n+\tuint8_t action = 0;\n+\tstruct buf work = { 0, 0, 0, 0 };\n+\n+\tif (rndr->work_bufs[BUFFER_SPAN].size +\n+\t\trndr->work_bufs[BUFFER_BLOCK].size > rndr->max_nesting)\n+\t\treturn;\n+\n+\twhile (i < size) {\n+\t\t/* copying inactive chars into the output */\n+\t\twhile (end < size && (action = rndr->active_char[data[end]]) == 0) {\n+\t\t\tend++;\n+\t\t}\n+\n+\t\tif (rndr->cb.normal_text) {\n+\t\t\twork.data = data + i;\n+\t\t\twork.size = end - i;\n+\t\t\trndr->cb.normal_text(ob, &work, rndr->opaque);\n+\t\t}\n+\t\telse\n+\t\t\tbufput(ob, data + i, end - i);\n+\n+\t\tif (end >= size) break;\n+\t\ti = end;\n+\n+\t\tend = markdown_char_ptrs[(int)action](ob, rndr, data + i, i, size - i);\n+\t\tif (!end) /* no action from the callback */\n+\t\t\tend = i + 1;\n+\t\telse {\n+\t\t\ti += end;\n+\t\t\tend = i;\n+\t\t}\n+\t}\n+}\n+\n+/* find_emph_char \u2022 looks for the next emph uint8_t, skipping other constructs */\n+static size_t\n+find_emph_char(uint8_t *data, size_t size, uint8_t c)\n+{\n+\tsize_t i = 1;\n+\n+\twhile (i < size) {\n+\t\twhile (i < size && data[i] != c && data[i] != '`' && data[i] != '[')\n+\t\t\ti++;\n+\n+\t\tif (i == size)\n+\t\t\treturn 0;\n+\n+\t\tif (data[i] == c)\n+\t\t\treturn i;\n+\n+\t\t/* not counting escaped chars */\n+\t\tif (i && data[i - 1] == '\\\\') {\n+\t\t\ti++; continue;\n+\t\t}\n+\n+\t\tif (data[i] == '`') {\n+\t\t\tsize_t span_nb = 0, bt;\n+\t\t\tsize_t tmp_i = 0;\n+\n+\t\t\t/* counting the number of opening backticks */\n+\t\t\twhile (i < size && data[i] == '`') {\n+\t\t\t\ti++; span_nb++;\n+\t\t\t}\n+\n+\t\t\tif (i >= size) return 0;\n+\n+\t\t\t/* finding the matching closing sequence */\n+\t\t\tbt = 0;\n+\t\t\twhile (i < size && bt < span_nb) {\n+\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n+\t\t\t\tif (data[i] == '`') bt++;\n+\t\t\t\telse bt = 0;\n+\t\t\t\ti++;\n+\t\t\t}\n+\n+\t\t\tif (i >= size) return tmp_i;\n+\t\t}\n+\t\t/* skipping a link */\n+\t\telse if (data[i] == '[') {\n+\t\t\tsize_t tmp_i = 0;\n+\t\t\tuint8_t cc;\n+\n+\t\t\ti++;\n+\t\t\twhile (i < size && data[i] != ']') {\n+\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n+\t\t\t\ti++;\n+\t\t\t}\n+\n+\t\t\ti++;\n+\t\t\twhile (i < size && (data[i] == ' ' || data[i] == '\\n'))\n+\t\t\t\ti++;\n+\n+\t\t\tif (i >= size)\n+\t\t\t\treturn tmp_i;\n+\n+\t\t\tswitch (data[i]) {\n+\t\t\tcase '[':\n+\t\t\t\tcc = ']'; break;\n+\n+\t\t\tcase '(':\n+\t\t\t\tcc = ')'; break;\n+\n+\t\t\tdefault:\n+\t\t\t\tif (tmp_i)\n+\t\t\t\t\treturn tmp_i;\n+\t\t\t\telse\n+\t\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\ti++;\n+\t\t\twhile (i < size && data[i] != cc) {\n+\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n+\t\t\t\ti++;\n+\t\t\t}\n+\n+\t\t\tif (i >= size)\n+\t\t\t\treturn tmp_i;\n+\n+\t\t\ti++;\n+\t\t}\n+\t}\n+\n+\treturn 0;\n+}\n+\n+/* parse_emph1 \u2022 parsing single emphase */\n+/* closed by a symbol not preceded by whitespace and not followed by symbol */\n+static size_t\n+parse_emph1(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n+{\n+\tsize_t i = 0, len;\n+\tstruct buf *work = 0;\n+\tint r;\n+\n+\tif (!rndr->cb.emphasis) return 0;\n+\n+\t/* skipping one symbol if coming from emph3 */\n+\tif (size > 1 && data[0] == c && data[1] == c) i = 1;\n+\n+\twhile (i < size) {\n+\t\tlen = find_emph_char(data + i, size - i, c);\n+\t\tif (!len) return 0;\n+\t\ti += len;\n+\t\tif (i >= size) return 0;\n+\n+\t\tif (data[i] == c && !_isspace(data[i - 1])) {\n+\n+\t\t\tif (rndr->ext_flags & MKDEXT_NO_INTRA_EMPHASIS) {\n+\t\t\t\tif (i + 1 < size && isalnum(data[i + 1]))\n+\t\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\tparse_inline(work, rndr, data, i);\n+\t\t\tr = rndr->cb.emphasis(ob, work, rndr->opaque);\n+\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t\t\treturn r ? i + 1 : 0;\n+\t\t}\n+\t}\n+\n+\treturn 0;\n+}\n+\n+/* parse_emph2 \u2022 parsing single emphase */\n+static size_t\n+parse_emph2(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n+{\n+\tint (*render_method)(struct buf *ob, const struct buf *text, void *opaque);\n+\tsize_t i = 0, len;\n+\tstruct buf *work = 0;\n+\tint r;\n+\n+\trender_method = (c == '~') ? rndr->cb.strikethrough : rndr->cb.double_emphasis;\n+\n+\tif (!render_method)\n+\t\treturn 0;\n+\n+\twhile (i < size) {\n+\t\tlen = find_emph_char(data + i, size - i, c);\n+\t\tif (!len) return 0;\n+\t\ti += len;\n+\n+\t\tif (i + 1 < size && data[i] == c && data[i + 1] == c && i && !_isspace(data[i - 1])) {\n+\t\t\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\tparse_inline(work, rndr, data, i);\n+\t\t\tr = render_method(ob, work, rndr->opaque);\n+\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t\t\treturn r ? i + 2 : 0;\n+\t\t}\n+\t\ti++;\n+\t}\n+\treturn 0;\n+}\n+\n+/* parse_emph3 \u2022 parsing single emphase */\n+/* finds the first closing tag, and delegates to the other emph */\n+static size_t\n+parse_emph3(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n+{\n+\tsize_t i = 0, len;\n+\tint r;\n+\n+\twhile (i < size) {\n+\t\tlen = find_emph_char(data + i, size - i, c);\n+\t\tif (!len) return 0;\n+\t\ti += len;\n+\n+\t\t/* skip whitespace preceded symbols */\n+\t\tif (data[i] != c || _isspace(data[i - 1]))\n+\t\t\tcontinue;\n+\n+\t\tif (i + 2 < size && data[i + 1] == c && data[i + 2] == c && rndr->cb.triple_emphasis) {\n+\t\t\t/* triple symbol found */\n+\t\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\t\t\tparse_inline(work, rndr, data, i);\n+\t\t\tr = rndr->cb.triple_emphasis(ob, work, rndr->opaque);\n+\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t\t\treturn r ? i + 3 : 0;\n+\n+\t\t} else if (i + 1 < size && data[i + 1] == c) {\n+\t\t\t/* double symbol found, handing over to emph1 */\n+\t\t\tlen = parse_emph1(ob, rndr, data - 2, size + 2, c);\n+\t\t\tif (!len) return 0;\n+\t\t\telse return len - 2;\n+\n+\t\t} else {\n+\t\t\t/* single symbol found, handing over to emph2 */\n+\t\t\tlen = parse_emph2(ob, rndr, data - 1, size + 1, c);\n+\t\t\tif (!len) return 0;\n+\t\t\telse return len - 1;\n+\t\t}\n+\t}\n+\treturn 0;\n+}\n+\n+/* char_emphasis \u2022 single and double emphasis parsing */\n+static size_t\n+char_emphasis(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tuint8_t c = data[0];\n+\tsize_t ret;\n+\n+\tif (rndr->ext_flags & MKDEXT_NO_INTRA_EMPHASIS) {\n+\t\tif (offset > 0 && !_isspace(data[-1]) && data[-1] != '>')\n+\t\t\treturn 0;\n+\t}\n+\n+\tif (size > 2 && data[1] != c) {\n+\t\t/* whitespace cannot follow an opening emphasis;\n+\t\t * strikethrough only takes two characters '~~' */\n+\t\tif (c == '~' || _isspace(data[1]) || (ret = parse_emph1(ob, rndr, data + 1, size - 1, c)) == 0)\n+\t\t\treturn 0;\n+\n+\t\treturn ret + 1;\n+\t}\n+\n+\tif (size > 3 && data[1] == c && data[2] != c) {\n+\t\tif (_isspace(data[2]) || (ret = parse_emph2(ob, rndr, data + 2, size - 2, c)) == 0)\n+\t\t\treturn 0;\n+\n+\t\treturn ret + 2;\n+\t}\n+\n+\tif (size > 4 && data[1] == c && data[2] == c && data[3] != c) {\n+\t\tif (c == '~' || _isspace(data[3]) || (ret = parse_emph3(ob, rndr, data + 3, size - 3, c)) == 0)\n+\t\t\treturn 0;\n+\n+\t\treturn ret + 3;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+\n+/* char_linebreak \u2022 '\\n' preceded by two spaces (assuming linebreak != 0) */\n+static size_t\n+char_linebreak(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tif (offset < 2 || data[-1] != ' ' || data[-2] != ' ')\n+\t\treturn 0;\n+\n+\t/* removing the last space from ob and rendering */\n+\twhile (ob->size && ob->data[ob->size - 1] == ' ')\n+\t\tob->size--;\n+\n+\treturn rndr->cb.linebreak(ob, rndr->opaque) ? 1 : 0;\n+}\n+\n+\n+/* char_codespan \u2022 '`' parsing a code span (assuming codespan != 0) */\n+static size_t\n+char_codespan(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tsize_t end, nb = 0, i, f_begin, f_end;\n+\n+\t/* counting the number of backticks in the delimiter */\n+\twhile (nb < size && data[nb] == '`')\n+\t\tnb++;\n+\n+\t/* finding the next delimiter */\n+\ti = 0;\n+\tfor (end = nb; end < size && i < nb; end++) {\n+\t\tif (data[end] == '`') i++;\n+\t\telse i = 0;\n+\t}\n+\n+\tif (i < nb && end >= size)\n+\t\treturn 0; /* no matching delimiter */\n+\n+\t/* trimming outside whitespaces */\n+\tf_begin = nb;\n+\twhile (f_begin < end && data[f_begin] == ' ')\n+\t\tf_begin++;\n+\n+\tf_end = end - nb;\n+\twhile (f_end > nb && data[f_end-1] == ' ')\n+\t\tf_end--;\n+\n+\t/* real code span */\n+\tif (f_begin < f_end) {\n+\t\tstruct buf work = { data + f_begin, f_end - f_begin, 0, 0 };\n+\t\tif (!rndr->cb.codespan(ob, &work, rndr->opaque))\n+\t\t\tend = 0;\n+\t} else {\n+\t\tif (!rndr->cb.codespan(ob, 0, rndr->opaque))\n+\t\t\tend = 0;\n+\t}\n+\n+\treturn end;\n+}\n+\n+\n+/* char_escape \u2022 '\\\\' backslash escape */\n+static size_t\n+char_escape(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tstatic const char *escape_chars = \"\\\\`*_{}[]()#+-.!:|&<>^~\";\n+\tstruct buf work = { 0, 0, 0, 0 };\n+\n+\tif (size > 1) {\n+\t\tif (strchr(escape_chars, data[1]) == NULL)\n+\t\t\treturn 0;\n+\n+\t\tif (rndr->cb.normal_text) {\n+\t\t\twork.data = data + 1;\n+\t\t\twork.size = 1;\n+\t\t\trndr->cb.normal_text(ob, &work, rndr->opaque);\n+\t\t}\n+\t\telse bufputc(ob, data[1]);\n+\t} else if (size == 1) {\n+\t\tbufputc(ob, data[0]);\n+\t}\n+\n+\treturn 2;\n+}\n+\n+/* char_entity \u2022 '&' escaped when it doesn't belong to an entity */\n+/* valid entities are assumed to be anything matching &#?[A-Za-z0-9]+; */\n+static size_t\n+char_entity(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tsize_t end = 1;\n+\tstruct buf work = { 0, 0, 0, 0 };\n+\n+\tif (end < size && data[end] == '#')\n+\t\tend++;\n+\n+\twhile (end < size && isalnum(data[end]))\n+\t\tend++;\n+\n+\tif (end < size && data[end] == ';')\n+\t\tend++; /* real entity */\n+\telse\n+\t\treturn 0; /* lone '&' */\n+\n+\tif (rndr->cb.entity) {\n+\t\twork.data = data;\n+\t\twork.size = end;\n+\t\trndr->cb.entity(ob, &work, rndr->opaque);\n+\t}\n+\telse bufput(ob, data, end);\n+\n+\treturn end;\n+}\n+\n+/* char_langle_tag \u2022 '<' when tags or autolinks are allowed */\n+static size_t\n+char_langle_tag(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tenum mkd_autolink altype = MKDA_NOT_AUTOLINK;\n+\tsize_t end = tag_length(data, size, &altype);\n+\tstruct buf work = { data, end, 0, 0 };\n+\tint ret = 0;\n+\n+\tif (end > 2) {\n+\t\tif (rndr->cb.autolink && altype != MKDA_NOT_AUTOLINK) {\n+\t\t\tstruct buf *u_link = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\twork.data = data + 1;\n+\t\t\twork.size = end - 2;\n+\t\t\tunscape_text(u_link, &work);\n+\t\t\tret = rndr->cb.autolink(ob, u_link, altype, rndr->opaque);\n+\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t\t}\n+\t\telse if (rndr->cb.raw_html_tag)\n+\t\t\tret = rndr->cb.raw_html_tag(ob, &work, rndr->opaque);\n+\t}\n+\n+\tif (!ret) return 0;\n+\telse return end;\n+}\n+\n+static size_t\n+char_autolink_www(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tstruct buf *link, *link_url, *link_text;\n+\tsize_t link_len, rewind;\n+\n+\tif (!rndr->cb.link || rndr->in_link_body)\n+\t\treturn 0;\n+\n+\tlink = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\tif ((link_len = sd_autolink__www(&rewind, link, data, offset, size, 0)) > 0) {\n+\t\tlink_url = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\tBUFPUTSL(link_url, \"http://\");\n+\t\tbufput(link_url, link->data, link->size);\n+\n+\t\tob->size -= rewind;\n+\t\tif (rndr->cb.normal_text) {\n+\t\t\tlink_text = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\trndr->cb.normal_text(link_text, link, rndr->opaque);\n+\t\t\trndr->cb.link(ob, link_url, NULL, link_text, rndr->opaque);\n+\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t\t} else {\n+\t\t\trndr->cb.link(ob, link_url, NULL, link, rndr->opaque);\n+\t\t}\n+\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t}\n+\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+\treturn link_len;\n+}\n+\n+static size_t\n+char_autolink_email(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tstruct buf *link;\n+\tsize_t link_len, rewind;\n+\n+\tif (!rndr->cb.autolink || rndr->in_link_body)\n+\t\treturn 0;\n+\n+\tlink = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\tif ((link_len = sd_autolink__email(&rewind, link, data, offset, size, 0)) > 0) {\n+\t\tob->size -= rewind;\n+\t\trndr->cb.autolink(ob, link, MKDA_EMAIL, rndr->opaque);\n+\t}\n+\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+\treturn link_len;\n+}\n+\n+static size_t\n+char_autolink_url(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tstruct buf *link;\n+\tsize_t link_len, rewind;\n+\n+\tif (!rndr->cb.autolink || rndr->in_link_body)\n+\t\treturn 0;\n+\n+\tlink = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\tif ((link_len = sd_autolink__url(&rewind, link, data, offset, size, 0)) > 0) {\n+\t\tob->size -= rewind;\n+\t\trndr->cb.autolink(ob, link, MKDA_NORMAL, rndr->opaque);\n+\t}\n+\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+\treturn link_len;\n+}\n+\n+/* char_link \u2022 '[': parsing a link or an image */\n+static size_t\n+char_link(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tint is_img = (offset && data[-1] == '!'), level;\n+\tsize_t i = 1, txt_e, link_b = 0, link_e = 0, title_b = 0, title_e = 0;\n+\tstruct buf *content = 0;\n+\tstruct buf *link = 0;\n+\tstruct buf *title = 0;\n+\tstruct buf *u_link = 0;\n+\tsize_t org_work_size = rndr->work_bufs[BUFFER_SPAN].size;\n+\tint text_has_nl = 0, ret = 0;\n+\tint in_title = 0, qtype = 0;\n+\n+\t/* checking whether the correct renderer exists */\n+\tif ((is_img && !rndr->cb.image) || (!is_img && !rndr->cb.link))\n+\t\tgoto cleanup;\n+\n+\t/* looking for the matching closing bracket */\n+\tfor (level = 1; i < size; i++) {\n+\t\tif (data[i] == '\\n')\n+\t\t\ttext_has_nl = 1;\n+\n+\t\telse if (data[i - 1] == '\\\\')\n+\t\t\tcontinue;\n+\n+\t\telse if (data[i] == '[')\n+\t\t\tlevel++;\n+\n+\t\telse if (data[i] == ']') {\n+\t\t\tlevel--;\n+\t\t\tif (level <= 0)\n+\t\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tif (i >= size)\n+\t\tgoto cleanup;\n+\n+\ttxt_e = i;\n+\ti++;\n+\n+\t/* skip any amount of whitespace or newline */\n+\t/* (this is much more laxist than original markdown syntax) */\n+\twhile (i < size && _isspace(data[i]))\n+\t\ti++;\n+\n+\t/* inline style link */\n+\tif (i < size && data[i] == '(') {\n+\t\t/* skipping initial whitespace */\n+\t\ti++;\n+\n+\t\twhile (i < size && _isspace(data[i]))\n+\t\t\ti++;\n+\n+\t\tlink_b = i;\n+\n+\t\t/* looking for link end: ' \" ) */\n+\t\twhile (i < size) {\n+\t\t\tif (data[i] == '\\\\') i += 2;\n+\t\t\telse if (data[i] == ')') break;\n+\t\t\telse if (i >= 1 && _isspace(data[i-1]) && (data[i] == '\\'' || data[i] == '\"')) break;\n+\t\t\telse i++;\n+\t\t}\n+\n+\t\tif (i >= size) goto cleanup;\n+\t\tlink_e = i;\n+\n+\t\t/* looking for title end if present */\n+\t\tif (data[i] == '\\'' || data[i] == '\"') {\n+\t\t\tqtype = data[i];\n+\t\t\tin_title = 1;\n+\t\t\ti++;\n+\t\t\ttitle_b = i;\n+\n+\t\t\twhile (i < size) {\n+\t\t\t\tif (data[i] == '\\\\') i += 2;\n+\t\t\t\telse if (data[i] == qtype) {in_title = 0; i++;}\n+\t\t\t\telse if ((data[i] == ')') && !in_title) break;\n+\t\t\t\telse i++;\n+\t\t\t}\n+\n+\t\t\tif (i >= size) goto cleanup;\n+\n+\t\t\t/* skipping whitespaces after title */\n+\t\t\ttitle_e = i - 1;\n+\t\t\twhile (title_e > title_b && _isspace(data[title_e]))\n+\t\t\t\ttitle_e--;\n+\n+\t\t\t/* checking for closing quote presence */\n+\t\t\tif (data[title_e] != '\\'' &&  data[title_e] != '\"') {\n+\t\t\t\ttitle_b = title_e = 0;\n+\t\t\t\tlink_e = i;\n+\t\t\t}\n+\t\t}\n+\n+\t\t/* remove whitespace at the end of the link */\n+\t\twhile (link_e > link_b && _isspace(data[link_e - 1]))\n+\t\t\tlink_e--;\n+\n+\t\t/* remove optional angle brackets around the link */\n+\t\tif (data[link_b] == '<') link_b++;\n+\t\tif (data[link_e - 1] == '>') link_e--;\n+\n+\t\t/* building escaped link and title */\n+\t\tif (link_e > link_b) {\n+\t\t\tlink = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\tbufput(link, data + link_b, link_e - link_b);\n+\t\t}\n+\n+\t\tif (title_e > title_b) {\n+\t\t\ttitle = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\tbufput(title, data + title_b, title_e - title_b);\n+\t\t}\n+\n+\t\ti++;\n+\t}\n+\n+\t/* reference style link */\n+\telse if (i < size && data[i] == '[') {\n+\t\tstruct buf id = { 0, 0, 0, 0 };\n+\t\tstruct link_ref *lr;\n+\n+\t\t/* looking for the id */\n+\t\ti++;\n+\t\tlink_b = i;\n+\t\twhile (i < size && data[i] != ']') i++;\n+\t\tif (i >= size) goto cleanup;\n+\t\tlink_e = i;\n+\n+\t\t/* finding the link_ref */\n+\t\tif (link_b == link_e) {\n+\t\t\tif (text_has_nl) {\n+\t\t\t\tstruct buf *b = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\t\tsize_t j;\n+\n+\t\t\t\tfor (j = 1; j < txt_e; j++) {\n+\t\t\t\t\tif (data[j] != '\\n')\n+\t\t\t\t\t\tbufputc(b, data[j]);\n+\t\t\t\t\telse if (data[j - 1] != ' ')\n+\t\t\t\t\t\tbufputc(b, ' ');\n+\t\t\t\t}\n+\n+\t\t\t\tid.data = b->data;\n+\t\t\t\tid.size = b->size;\n+\t\t\t} else {\n+\t\t\t\tid.data = data + 1;\n+\t\t\t\tid.size = txt_e - 1;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tid.data = data + link_b;\n+\t\t\tid.size = link_e - link_b;\n+\t\t}\n+\n+\t\tlr = find_link_ref(rndr->refs, id.data, id.size);\n+\t\tif (!lr)\n+\t\t\tgoto cleanup;\n+\n+\t\t/* keeping link and title from link_ref */\n+\t\tlink = lr->link;\n+\t\ttitle = lr->title;\n+\t\ti++;\n+\t}\n+\n+\t/* shortcut reference style link */\n+\telse {\n+\t\tstruct buf id = { 0, 0, 0, 0 };\n+\t\tstruct link_ref *lr;\n+\n+\t\t/* crafting the id */\n+\t\tif (text_has_nl) {\n+\t\t\tstruct buf *b = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\tsize_t j;\n+\n+\t\t\tfor (j = 1; j < txt_e; j++) {\n+\t\t\t\tif (data[j] != '\\n')\n+\t\t\t\t\tbufputc(b, data[j]);\n+\t\t\t\telse if (data[j - 1] != ' ')\n+\t\t\t\t\tbufputc(b, ' ');\n+\t\t\t}\n+\n+\t\t\tid.data = b->data;\n+\t\t\tid.size = b->size;\n+\t\t} else {\n+\t\t\tid.data = data + 1;\n+\t\t\tid.size = txt_e - 1;\n+\t\t}\n+\n+\t\t/* finding the link_ref */\n+\t\tlr = find_link_ref(rndr->refs, id.data, id.size);\n+\t\tif (!lr)\n+\t\t\tgoto cleanup;\n+\n+\t\t/* keeping link and title from link_ref */\n+\t\tlink = lr->link;\n+\t\ttitle = lr->title;\n+\n+\t\t/* rewinding the whitespace */\n+\t\ti = txt_e + 1;\n+\t}\n+\n+\t/* building content: img alt is escaped, link content is parsed */\n+\tif (txt_e > 1) {\n+\t\tcontent = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\tif (is_img) {\n+\t\t\tbufput(content, data + 1, txt_e - 1);\n+\t\t} else {\n+\t\t\t/* disable autolinking when parsing inline the\n+\t\t\t * content of a link */\n+\t\t\trndr->in_link_body = 1;\n+\t\t\tparse_inline(content, rndr, data + 1, txt_e - 1);\n+\t\t\trndr->in_link_body = 0;\n+\t\t}\n+\t}\n+\n+\tif (link) {\n+\t\tu_link = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\tunscape_text(u_link, link);\n+\t}\n+\n+\t/* calling the relevant rendering function */\n+\tif (is_img) {\n+\t\tif (ob->size && ob->data[ob->size - 1] == '!')\n+\t\t\tob->size -= 1;\n+\n+\t\tret = rndr->cb.image(ob, u_link, title, content, rndr->opaque);\n+\t} else {\n+\t\tret = rndr->cb.link(ob, u_link, title, content, rndr->opaque);\n+\t}\n+\n+\t/* cleanup */\n+cleanup:\n+\trndr->work_bufs[BUFFER_SPAN].size = (int)org_work_size;\n+\treturn ret ? i : 0;\n+}\n+\n+static size_t\n+char_superscript(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tsize_t sup_start, sup_len;\n+\tstruct buf *sup;\n+\n+\tif (!rndr->cb.superscript)\n+\t\treturn 0;\n+\n+\tif (size < 2)\n+\t\treturn 0;\n+\n+\tif (data[1] == '(') {\n+\t\tsup_start = sup_len = 2;\n+\n+\t\twhile (sup_len < size && data[sup_len] != ')' && data[sup_len - 1] != '\\\\')\n+\t\t\tsup_len++;\n+\n+\t\tif (sup_len == size)\n+\t\t\treturn 0;\n+\t} else {\n+\t\tsup_start = sup_len = 1;\n+\n+\t\twhile (sup_len < size && !_isspace(data[sup_len]))\n+\t\t\tsup_len++;\n+\t}\n+\n+\tif (sup_len - sup_start == 0)\n+\t\treturn (sup_start == 2) ? 3 : 0;\n+\n+\tsup = rndr_newbuf(rndr, BUFFER_SPAN);\n+\tparse_inline(sup, rndr, data + sup_start, sup_len - sup_start);\n+\trndr->cb.superscript(ob, sup, rndr->opaque);\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+\n+\treturn (sup_start == 2) ? sup_len + 1 : sup_len;\n+}\n+\n+/*********************************\n+ * BLOCK-LEVEL PARSING FUNCTIONS *\n+ *********************************/\n+\n+/* is_empty \u2022 returns the line length when it is empty, 0 otherwise */\n+static size_t\n+is_empty(uint8_t *data, size_t size)\n+{\n+\tsize_t i;\n+\n+\tfor (i = 0; i < size && data[i] != '\\n'; i++)\n+\t\tif (data[i] != ' ')\n+\t\t\treturn 0;\n+\n+\treturn i + 1;\n+}\n+\n+/* is_hrule \u2022 returns whether a line is a horizontal rule */\n+static int\n+is_hrule(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0, n = 0;\n+\tuint8_t c;\n+\n+\t/* skipping initial spaces */\n+\tif (size < 3) return 0;\n+\tif (data[0] == ' ') { i++;\n+\tif (data[1] == ' ') { i++;\n+\tif (data[2] == ' ') { i++; } } }\n+\n+\t/* looking at the hrule uint8_t */\n+\tif (i + 2 >= size\n+\t|| (data[i] != '*' && data[i] != '-' && data[i] != '_'))\n+\t\treturn 0;\n+\tc = data[i];\n+\n+\t/* the whole line must be the char or whitespace */\n+\twhile (i < size && data[i] != '\\n') {\n+\t\tif (data[i] == c) n++;\n+\t\telse if (data[i] != ' ')\n+\t\t\treturn 0;\n+\n+\t\ti++;\n+\t}\n+\n+\treturn n >= 3;\n+}\n+\n+/* check if a line begins with a code fence; return the\n+ * width of the code fence */\n+static size_t\n+prefix_codefence(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0, n = 0;\n+\tuint8_t c;\n+\n+\t/* skipping initial spaces */\n+\tif (size < 3) return 0;\n+\tif (data[0] == ' ') { i++;\n+\tif (data[1] == ' ') { i++;\n+\tif (data[2] == ' ') { i++; } } }\n+\n+\t/* looking at the hrule uint8_t */\n+\tif (i + 2 >= size || !(data[i] == '~' || data[i] == '`'))\n+\t\treturn 0;\n+\n+\tc = data[i];\n+\n+\t/* the whole line must be the uint8_t or whitespace */\n+\twhile (i < size && data[i] == c) {\n+\t\tn++; i++;\n+\t}\n+\n+\tif (n < 3)\n+\t\treturn 0;\n+\n+\treturn i;\n+}\n+\n+/* check if a line is a code fence; return its size if it is */\n+static size_t\n+is_codefence(uint8_t *data, size_t size, struct buf *syntax)\n+{\n+\tsize_t i = 0, syn_len = 0;\n+\tuint8_t *syn_start;\n+\n+\ti = prefix_codefence(data, size);\n+\tif (i == 0)\n+\t\treturn 0;\n+\n+\twhile (i < size && data[i] == ' ')\n+\t\ti++;\n+\n+\tsyn_start = data + i;\n+\n+\tif (i < size && data[i] == '{') {\n+\t\ti++; syn_start++;\n+\n+\t\twhile (i < size && data[i] != '}' && data[i] != '\\n') {\n+\t\t\tsyn_len++; i++;\n+\t\t}\n+\n+\t\tif (i == size || data[i] != '}')\n+\t\t\treturn 0;\n+\n+\t\t/* strip all whitespace at the beginning and the end\n+\t\t * of the {} block */\n+\t\twhile (syn_len > 0 && _isspace(syn_start[0])) {\n+\t\t\tsyn_start++; syn_len--;\n+\t\t}\n+\n+\t\twhile (syn_len > 0 && _isspace(syn_start[syn_len - 1]))\n+\t\t\tsyn_len--;\n+\n+\t\ti++;\n+\t} else {\n+\t\twhile (i < size && !_isspace(data[i])) {\n+\t\t\tsyn_len++; i++;\n+\t\t}\n+\t}\n+\n+\tif (syntax) {\n+\t\tsyntax->data = syn_start;\n+\t\tsyntax->size = syn_len;\n+\t}\n+\n+\twhile (i < size && data[i] != '\\n') {\n+\t\tif (!_isspace(data[i]))\n+\t\t\treturn 0;\n+\n+\t\ti++;\n+\t}\n+\n+\treturn i + 1;\n+}\n+\n+/* is_atxheader \u2022 returns whether the line is a hash-prefixed header */\n+static int\n+is_atxheader(struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tif (data[0] != '#')\n+\t\treturn 0;\n+\n+\tif (rndr->ext_flags & MKDEXT_SPACE_HEADERS) {\n+\t\tsize_t level = 0;\n+\n+\t\twhile (level < size && level < 6 && data[level] == '#')\n+\t\t\tlevel++;\n+\n+\t\tif (level < size && data[level] != ' ')\n+\t\t\treturn 0;\n+\t}\n+\n+\treturn 1;\n+}\n+\n+/* is_headerline \u2022 returns whether the line is a setext-style hdr underline */\n+static int\n+is_headerline(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0;\n+\n+\t/* test of level 1 header */\n+\tif (data[i] == '=') {\n+\t\tfor (i = 1; i < size && data[i] == '='; i++);\n+\t\twhile (i < size && data[i] == ' ') i++;\n+\t\treturn (i >= size || data[i] == '\\n') ? 1 : 0; }\n+\n+\t/* test of level 2 header */\n+\tif (data[i] == '-') {\n+\t\tfor (i = 1; i < size && data[i] == '-'; i++);\n+\t\twhile (i < size && data[i] == ' ') i++;\n+\t\treturn (i >= size || data[i] == '\\n') ? 2 : 0; }\n+\n+\treturn 0;\n+}\n+\n+static int\n+is_next_headerline(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0;\n+\n+\twhile (i < size && data[i] != '\\n')\n+\t\ti++;\n+\n+\tif (++i >= size)\n+\t\treturn 0;\n+\n+\treturn is_headerline(data + i, size - i);\n+}\n+\n+/* prefix_quote \u2022 returns blockquote prefix length */\n+static size_t\n+prefix_quote(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0;\n+\tif (i < size && data[i] == ' ') i++;\n+\tif (i < size && data[i] == ' ') i++;\n+\tif (i < size && data[i] == ' ') i++;\n+\n+\tif (i < size && data[i] == '>') {\n+\t\tif (i + 1 < size && data[i + 1] == ' ')\n+\t\t\treturn i + 2;\n+\n+\t\treturn i + 1;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+/* prefix_code \u2022 returns prefix length for block code*/\n+static size_t\n+prefix_code(uint8_t *data, size_t size)\n+{\n+\tif (size > 3 && data[0] == ' ' && data[1] == ' '\n+\t\t&& data[2] == ' ' && data[3] == ' ') return 4;\n+\n+\treturn 0;\n+}\n+\n+/* prefix_oli \u2022 returns ordered list item prefix */\n+static size_t\n+prefix_oli(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0;\n+\n+\tif (i < size && data[i] == ' ') i++;\n+\tif (i < size && data[i] == ' ') i++;\n+\tif (i < size && data[i] == ' ') i++;\n+\n+\tif (i >= size || data[i] < '0' || data[i] > '9')\n+\t\treturn 0;\n+\n+\twhile (i < size && data[i] >= '0' && data[i] <= '9')\n+\t\ti++;\n+\n+\tif (i + 1 >= size || data[i] != '.' || data[i + 1] != ' ')\n+\t\treturn 0;\n+\n+\tif (is_next_headerline(data + i, size - i))\n+\t\treturn 0;\n+\n+\treturn i + 2;\n+}\n+\n+/* prefix_uli \u2022 returns ordered list item prefix */\n+static size_t\n+prefix_uli(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0;\n+\n+\tif (i < size && data[i] == ' ') i++;\n+\tif (i < size && data[i] == ' ') i++;\n+\tif (i < size && data[i] == ' ') i++;\n+\n+\tif (i + 1 >= size ||\n+\t\t(data[i] != '*' && data[i] != '+' && data[i] != '-') ||\n+\t\tdata[i + 1] != ' ')\n+\t\treturn 0;\n+\n+\tif (is_next_headerline(data + i, size - i))\n+\t\treturn 0;\n+\n+\treturn i + 2;\n+}\n+\n+\n+/* parse_block \u2022 parsing of one block, returning next uint8_t to parse */\n+static void parse_block(struct buf *ob, struct sd_markdown *rndr,\n+\t\t\tuint8_t *data, size_t size);\n+\n+\n+/* parse_blockquote \u2022 handles parsing of a blockquote fragment */\n+static size_t\n+parse_blockquote(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tsize_t beg, end = 0, pre, work_size = 0;\n+\tuint8_t *work_data = 0;\n+\tstruct buf *out = 0;\n+\n+\tout = rndr_newbuf(rndr, BUFFER_BLOCK);\n+\tbeg = 0;\n+\twhile (beg < size) {\n+\t\tfor (end = beg + 1; end < size && data[end - 1] != '\\n'; end++);\n+\n+\t\tpre = prefix_quote(data + beg, end - beg);\n+\n+\t\tif (pre)\n+\t\t\tbeg += pre; /* skipping prefix */\n+\n+\t\t/* empty line followed by non-quote line */\n+\t\telse if (is_empty(data + beg, end - beg) &&\n+\t\t\t\t(end >= size || (prefix_quote(data + end, size - end) == 0 &&\n+\t\t\t\t!is_empty(data + end, size - end))))\n+\t\t\tbreak;\n+\n+\t\tif (beg < end) { /* copy into the in-place working buffer */\n+\t\t\t/* bufput(work, data + beg, end - beg); */\n+\t\t\tif (!work_data)\n+\t\t\t\twork_data = data + beg;\n+\t\t\telse if (data + beg != work_data + work_size)\n+\t\t\t\tmemmove(work_data + work_size, data + beg, end - beg);\n+\t\t\twork_size += end - beg;\n+\t\t}\n+\t\tbeg = end;\n+\t}\n+\n+\tparse_block(out, rndr, work_data, work_size);\n+\tif (rndr->cb.blockquote)\n+\t\trndr->cb.blockquote(ob, out, rndr->opaque);\n+\trndr_popbuf(rndr, BUFFER_BLOCK);\n+\treturn end;\n+}\n+\n+static size_t\n+parse_htmlblock(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, int do_render);\n+\n+/* parse_blockquote \u2022 handles parsing of a regular paragraph */\n+static size_t\n+parse_paragraph(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0, end = 0;\n+\tint level = 0;\n+\tstruct buf work = { data, 0, 0, 0 };\n+\n+\twhile (i < size) {\n+\t\tfor (end = i + 1; end < size && data[end - 1] != '\\n'; end++) /* empty */;\n+\n+\t\tif (is_empty(data + i, size - i))\n+\t\t\tbreak;\n+\n+\t\tif ((level = is_headerline(data + i, size - i)) != 0)\n+\t\t\tbreak;\n+\n+\t\tif (is_atxheader(rndr, data + i, size - i) ||\n+\t\t\tis_hrule(data + i, size - i) ||\n+\t\t\tprefix_quote(data + i, size - i)) {\n+\t\t\tend = i;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\t/*\n+\t\t * Early termination of a paragraph with the same logic\n+\t\t * as Markdown 1.0.0. If this logic is applied, the\n+\t\t * Markdown 1.0.3 test suite won't pass cleanly\n+\t\t *\n+\t\t * :: If the first character in a new line is not a letter,\n+\t\t * let's check to see if there's some kind of block starting\n+\t\t * here\n+\t\t */\n+\t\tif ((rndr->ext_flags & MKDEXT_LAX_SPACING) && !isalnum(data[i])) {\n+\t\t\tif (prefix_oli(data + i, size - i) ||\n+\t\t\t\tprefix_uli(data + i, size - i)) {\n+\t\t\t\tend = i;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\t/* see if an html block starts here */\n+\t\t\tif (data[i] == '<' && rndr->cb.blockhtml &&\n+\t\t\t\tparse_htmlblock(ob, rndr, data + i, size - i, 0)) {\n+\t\t\t\tend = i;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\t/* see if a code fence starts here */\n+\t\t\tif ((rndr->ext_flags & MKDEXT_FENCED_CODE) != 0 &&\n+\t\t\t\tis_codefence(data + i, size - i, NULL) != 0) {\n+\t\t\t\tend = i;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\ti = end;\n+\t}\n+\n+\twork.size = i;\n+\twhile (work.size && data[work.size - 1] == '\\n')\n+\t\twork.size--;\n+\n+\tif (!level) {\n+\t\tstruct buf *tmp = rndr_newbuf(rndr, BUFFER_BLOCK);\n+\t\tparse_inline(tmp, rndr, work.data, work.size);\n+\t\tif (rndr->cb.paragraph)\n+\t\t\trndr->cb.paragraph(ob, tmp, rndr->opaque);\n+\t\trndr_popbuf(rndr, BUFFER_BLOCK);\n+\t} else {\n+\t\tstruct buf *header_work;\n+\n+\t\tif (work.size) {\n+\t\t\tsize_t beg;\n+\t\t\ti = work.size;\n+\t\t\twork.size -= 1;\n+\n+\t\t\twhile (work.size && data[work.size] != '\\n')\n+\t\t\t\twork.size -= 1;\n+\n+\t\t\tbeg = work.size + 1;\n+\t\t\twhile (work.size && data[work.size - 1] == '\\n')\n+\t\t\t\twork.size -= 1;\n+\n+\t\t\tif (work.size > 0) {\n+\t\t\t\tstruct buf *tmp = rndr_newbuf(rndr, BUFFER_BLOCK);\n+\t\t\t\tparse_inline(tmp, rndr, work.data, work.size);\n+\n+\t\t\t\tif (rndr->cb.paragraph)\n+\t\t\t\t\trndr->cb.paragraph(ob, tmp, rndr->opaque);\n+\n+\t\t\t\trndr_popbuf(rndr, BUFFER_BLOCK);\n+\t\t\t\twork.data += beg;\n+\t\t\t\twork.size = i - beg;\n+\t\t\t}\n+\t\t\telse work.size = i;\n+\t\t}\n+\n+\t\theader_work = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\tparse_inline(header_work, rndr, work.data, work.size);\n+\n+\t\tif (rndr->cb.header)\n+\t\t\trndr->cb.header(ob, header_work, (int)level, rndr->opaque);\n+\n+\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t}\n+\n+\treturn end;\n+}\n+\n+/* parse_fencedcode \u2022 handles parsing of a block-level code fragment */\n+static size_t\n+parse_fencedcode(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tsize_t beg, end;\n+\tstruct buf *work = 0;\n+\tstruct buf lang = { 0, 0, 0, 0 };\n+\n+\tbeg = is_codefence(data, size, &lang);\n+\tif (beg == 0) return 0;\n+\n+\twork = rndr_newbuf(rndr, BUFFER_BLOCK);\n+\n+\twhile (beg < size) {\n+\t\tsize_t fence_end;\n+\t\tstruct buf fence_trail = { 0, 0, 0, 0 };\n+\n+\t\tfence_end = is_codefence(data + beg, size - beg, &fence_trail);\n+\t\tif (fence_end != 0 && fence_trail.size == 0) {\n+\t\t\tbeg += fence_end;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tfor (end = beg + 1; end < size && data[end - 1] != '\\n'; end++);\n+\n+\t\tif (beg < end) {\n+\t\t\t/* verbatim copy to the working buffer,\n+\t\t\t\tescaping entities */\n+\t\t\tif (is_empty(data + beg, end - beg))\n+\t\t\t\tbufputc(work, '\\n');\n+\t\t\telse bufput(work, data + beg, end - beg);\n+\t\t}\n+\t\tbeg = end;\n+\t}\n+\n+\tif (work->size && work->data[work->size - 1] != '\\n')\n+\t\tbufputc(work, '\\n');\n+\n+\tif (rndr->cb.blockcode)\n+\t\trndr->cb.blockcode(ob, work, lang.size ? &lang : NULL, rndr->opaque);\n+\n+\trndr_popbuf(rndr, BUFFER_BLOCK);\n+\treturn beg;\n+}\n+\n+static size_t\n+parse_blockcode(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tsize_t beg, end, pre;\n+\tstruct buf *work = 0;\n+\n+\twork = rndr_newbuf(rndr, BUFFER_BLOCK);\n+\n+\tbeg = 0;\n+\twhile (beg < size) {\n+\t\tfor (end = beg + 1; end < size && data[end - 1] != '\\n'; end++) {};\n+\t\tpre = prefix_code(data + beg, end - beg);\n+\n+\t\tif (pre)\n+\t\t\tbeg += pre; /* skipping prefix */\n+\t\telse if (!is_empty(data + beg, end - beg))\n+\t\t\t/* non-empty non-prefixed line breaks the pre */\n+\t\t\tbreak;\n+\n+\t\tif (beg < end) {\n+\t\t\t/* verbatim copy to the working buffer,\n+\t\t\t\tescaping entities */\n+\t\t\tif (is_empty(data + beg, end - beg))\n+\t\t\t\tbufputc(work, '\\n');\n+\t\t\telse bufput(work, data + beg, end - beg);\n+\t\t}\n+\t\tbeg = end;\n+\t}\n+\n+\twhile (work->size && work->data[work->size - 1] == '\\n')\n+\t\twork->size -= 1;\n+\n+\tbufputc(work, '\\n');\n+\n+\tif (rndr->cb.blockcode)\n+\t\trndr->cb.blockcode(ob, work, NULL, rndr->opaque);\n+\n+\trndr_popbuf(rndr, BUFFER_BLOCK);\n+\treturn beg;\n+}\n+\n+/* parse_listitem \u2022 parsing of a single list item */\n+/*\tassuming initial prefix is already removed */\n+static size_t\n+parse_listitem(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, int *flags)\n+{\n+\tstruct buf *work = 0, *inter = 0;\n+\tsize_t beg = 0, end, pre, sublist = 0, orgpre = 0, i;\n+\tint in_empty = 0, has_inside_empty = 0, in_fence = 0;\n+\n+\t/* keeping track of the first indentation prefix */\n+\twhile (orgpre < 3 && orgpre < size && data[orgpre] == ' ')\n+\t\torgpre++;\n+\n+\tbeg = prefix_uli(data, size);\n+\tif (!beg)\n+\t\tbeg = prefix_oli(data, size);\n+\n+\tif (!beg)\n+\t\treturn 0;\n+\n+\t/* skipping to the beginning of the following line */\n+\tend = beg;\n+\twhile (end < size && data[end - 1] != '\\n')\n+\t\tend++;\n+\n+\t/* getting working buffers */\n+\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n+\tinter = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\t/* putting the first line into the working buffer */\n+\tbufput(work, data + beg, end - beg);\n+\tbeg = end;\n+\n+\t/* process the following lines */\n+\twhile (beg < size) {\n+\t\tsize_t has_next_uli = 0, has_next_oli = 0;\n+\n+\t\tend++;\n+\n+\t\twhile (end < size && data[end - 1] != '\\n')\n+\t\t\tend++;\n+\n+\t\t/* process an empty line */\n+\t\tif (is_empty(data + beg, end - beg)) {\n+\t\t\tin_empty = 1;\n+\t\t\tbeg = end;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\t/* calculating the indentation */\n+\t\ti = 0;\n+\t\twhile (i < 4 && beg + i < end && data[beg + i] == ' ')\n+\t\t\ti++;\n+\n+\t\tpre = i;\n+\n+\t\tif (rndr->ext_flags & MKDEXT_FENCED_CODE) {\n+\t\t\tif (is_codefence(data + beg + i, end - beg - i, NULL) != 0)\n+\t\t\t\tin_fence = !in_fence;\n+\t\t}\n+\n+\t\t/* Only check for new list items if we are **not** inside\n+\t\t * a fenced code block */\n+\t\tif (!in_fence) {\n+\t\t\thas_next_uli = prefix_uli(data + beg + i, end - beg - i);\n+\t\t\thas_next_oli = prefix_oli(data + beg + i, end - beg - i);\n+\t\t}\n+\n+\t\t/* checking for ul/ol switch */\n+\t\tif (in_empty && (\n+\t\t\t((*flags & MKD_LIST_ORDERED) && has_next_uli) ||\n+\t\t\t(!(*flags & MKD_LIST_ORDERED) && has_next_oli))){\n+\t\t\t*flags |= MKD_LI_END;\n+\t\t\tbreak; /* the following item must have same list type */\n+\t\t}\n+\n+\t\t/* checking for a new item */\n+\t\tif ((has_next_uli && !is_hrule(data + beg + i, end - beg - i)) || has_next_oli) {\n+\t\t\tif (in_empty)\n+\t\t\t\thas_inside_empty = 1;\n+\n+\t\t\tif (pre == orgpre) /* the following item must have */\n+\t\t\t\tbreak;             /* the same indentation */\n+\n+\t\t\tif (!sublist)\n+\t\t\t\tsublist = work->size;\n+\t\t}\n+\t\t/* joining only indented stuff after empty lines;\n+\t\t * note that now we only require 1 space of indentation\n+\t\t * to continue a list */\n+\t\telse if (in_empty && pre == 0) {\n+\t\t\t*flags |= MKD_LI_END;\n+\t\t\tbreak;\n+\t\t}\n+\t\telse if (in_empty) {\n+\t\t\tbufputc(work, '\\n');\n+\t\t\thas_inside_empty = 1;\n+\t\t}\n+\n+\t\tin_empty = 0;\n+\n+\t\t/* adding the line without prefix into the working buffer */\n+\t\tbufput(work, data + beg + i, end - beg - i);\n+\t\tbeg = end;\n+\t}\n+\n+\t/* render of li contents */\n+\tif (has_inside_empty)\n+\t\t*flags |= MKD_LI_BLOCK;\n+\n+\tif (*flags & MKD_LI_BLOCK) {\n+\t\t/* intermediate render of block li */\n+\t\tif (sublist && sublist < work->size) {\n+\t\t\tparse_block(inter, rndr, work->data, sublist);\n+\t\t\tparse_block(inter, rndr, work->data + sublist, work->size - sublist);\n+\t\t}\n+\t\telse\n+\t\t\tparse_block(inter, rndr, work->data, work->size);\n+\t} else {\n+\t\t/* intermediate render of inline li */\n+\t\tif (sublist && sublist < work->size) {\n+\t\t\tparse_inline(inter, rndr, work->data, sublist);\n+\t\t\tparse_block(inter, rndr, work->data + sublist, work->size - sublist);\n+\t\t}\n+\t\telse\n+\t\t\tparse_inline(inter, rndr, work->data, work->size);\n+\t}\n+\n+\t/* render of li itself */\n+\tif (rndr->cb.listitem)\n+\t\trndr->cb.listitem(ob, inter, *flags, rndr->opaque);\n+\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+\treturn beg;\n+}\n+\n+\n+/* parse_list \u2022 parsing ordered or unordered list block */\n+static size_t\n+parse_list(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, int flags)\n+{\n+\tstruct buf *work = 0;\n+\tsize_t i = 0, j;\n+\n+\twork = rndr_newbuf(rndr, BUFFER_BLOCK);\n+\n+\twhile (i < size) {\n+\t\tj = parse_listitem(work, rndr, data + i, size - i, &flags);\n+\t\ti += j;\n+\n+\t\tif (!j || (flags & MKD_LI_END))\n+\t\t\tbreak;\n+\t}\n+\n+\tif (rndr->cb.list)\n+\t\trndr->cb.list(ob, work, flags, rndr->opaque);\n+\trndr_popbuf(rndr, BUFFER_BLOCK);\n+\treturn i;\n+}\n+\n+/* parse_atxheader \u2022 parsing of atx-style headers */\n+static size_t\n+parse_atxheader(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tsize_t level = 0;\n+\tsize_t i, end, skip;\n+\n+\twhile (level < size && level < 6 && data[level] == '#')\n+\t\tlevel++;\n+\n+\tfor (i = level; i < size && data[i] == ' '; i++);\n+\n+\tfor (end = i; end < size && data[end] != '\\n'; end++);\n+\tskip = end;\n+\n+\twhile (end && data[end - 1] == '#')\n+\t\tend--;\n+\n+\twhile (end && data[end - 1] == ' ')\n+\t\tend--;\n+\n+\tif (end > i) {\n+\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\t\tparse_inline(work, rndr, data + i, end - i);\n+\n+\t\tif (rndr->cb.header)\n+\t\t\trndr->cb.header(ob, work, (int)level, rndr->opaque);\n+\n+\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t}\n+\n+\treturn skip;\n+}\n+\n+\n+/* htmlblock_end \u2022 checking end of HTML block : </tag>[ \\t]*\\n[ \\t*]\\n */\n+/*\treturns the length on match, 0 otherwise */\n+static size_t\n+htmlblock_end_tag(\n+\tconst char *tag,\n+\tsize_t tag_len,\n+\tstruct sd_markdown *rndr,\n+\tuint8_t *data,\n+\tsize_t size)\n+{\n+\tsize_t i, w;\n+\n+\t/* checking if tag is a match */\n+\tif (tag_len + 3 >= size ||\n+\t\tstrncasecmp((char *)data + 2, tag, tag_len) != 0 ||\n+\t\tdata[tag_len + 2] != '>')\n+\t\treturn 0;\n+\n+\t/* checking white lines */\n+\ti = tag_len + 3;\n+\tw = 0;\n+\tif (i < size && (w = is_empty(data + i, size - i)) == 0)\n+\t\treturn 0; /* non-blank after tag */\n+\ti += w;\n+\tw = 0;\n+\n+\tif (i < size)\n+\t\tw = is_empty(data + i, size - i);\n+\n+\treturn i + w;\n+}\n+\n+static size_t\n+htmlblock_end(const char *curtag,\n+\tstruct sd_markdown *rndr,\n+\tuint8_t *data,\n+\tsize_t size,\n+\tint start_of_line)\n+{\n+\tsize_t tag_size = strlen(curtag);\n+\tsize_t i = 1, end_tag;\n+\tint block_lines = 0;\n+\n+\twhile (i < size) {\n+\t\ti++;\n+\t\twhile (i < size && !(data[i - 1] == '<' && data[i] == '/')) {\n+\t\t\tif (data[i] == '\\n')\n+\t\t\t\tblock_lines++;\n+\n+\t\t\ti++;\n+\t\t}\n+\n+\t\t/* If we are only looking for unindented tags, skip the tag\n+\t\t * if it doesn't follow a newline.\n+\t\t *\n+\t\t * The only exception to this is if the tag is still on the\n+\t\t * initial line; in that case it still counts as a closing\n+\t\t * tag\n+\t\t */\n+\t\tif (start_of_line && block_lines > 0 && data[i - 2] != '\\n')\n+\t\t\tcontinue;\n+\n+\t\tif (i + 2 + tag_size >= size)\n+\t\t\tbreak;\n+\n+\t\tend_tag = htmlblock_end_tag(curtag, tag_size, rndr, data + i - 1, size - i + 1);\n+\t\tif (end_tag)\n+\t\t\treturn i + end_tag - 1;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+\n+/* parse_htmlblock \u2022 parsing of inline HTML block */\n+static size_t\n+parse_htmlblock(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, int do_render)\n+{\n+\tsize_t i, j = 0, tag_end;\n+\tconst char *curtag = NULL;\n+\tstruct buf work = { data, 0, 0, 0 };\n+\n+\t/* identification of the opening tag */\n+\tif (size < 2 || data[0] != '<')\n+\t\treturn 0;\n+\n+\ti = 1;\n+\twhile (i < size && data[i] != '>' && data[i] != ' ')\n+\t\ti++;\n+\n+\tif (i < size)\n+\t\tcurtag = find_block_tag((char *)data + 1, (int)i - 1);\n+\n+\t/* handling of special cases */\n+\tif (!curtag) {\n+\n+\t\t/* HTML comment, laxist form */\n+\t\tif (size > 5 && data[1] == '!' && data[2] == '-' && data[3] == '-') {\n+\t\t\ti = 5;\n+\n+\t\t\twhile (i < size && !(data[i - 2] == '-' && data[i - 1] == '-' && data[i] == '>'))\n+\t\t\t\ti++;\n+\n+\t\t\ti++;\n+\n+\t\t\tif (i < size)\n+\t\t\t\tj = is_empty(data + i, size - i);\n+\n+\t\t\tif (j) {\n+\t\t\t\twork.size = i + j;\n+\t\t\t\tif (do_render && rndr->cb.blockhtml)\n+\t\t\t\t\trndr->cb.blockhtml(ob, &work, rndr->opaque);\n+\t\t\t\treturn work.size;\n+\t\t\t}\n+\t\t}\n+\n+\t\t/* HR, which is the only self-closing block tag considered */\n+\t\tif (size > 4 && (data[1] == 'h' || data[1] == 'H') && (data[2] == 'r' || data[2] == 'R')) {\n+\t\t\ti = 3;\n+\t\t\twhile (i < size && data[i] != '>')\n+\t\t\t\ti++;\n+\n+\t\t\tif (i + 1 < size) {\n+\t\t\t\ti++;\n+\t\t\t\tj = is_empty(data + i, size - i);\n+\t\t\t\tif (j) {\n+\t\t\t\t\twork.size = i + j;\n+\t\t\t\t\tif (do_render && rndr->cb.blockhtml)\n+\t\t\t\t\t\trndr->cb.blockhtml(ob, &work, rndr->opaque);\n+\t\t\t\t\treturn work.size;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t/* no special case recognised */\n+\t\treturn 0;\n+\t}\n+\n+\t/* looking for an unindented matching closing tag */\n+\t/*\tfollowed by a blank line */\n+\ttag_end = htmlblock_end(curtag, rndr, data, size, 1);\n+\n+\t/* if not found, trying a second pass looking for indented match */\n+\t/* but not if tag is \"ins\" or \"del\" (following original Markdown.pl) */\n+\tif (!tag_end && strcmp(curtag, \"ins\") != 0 && strcmp(curtag, \"del\") != 0) {\n+\t\ttag_end = htmlblock_end(curtag, rndr, data, size, 0);\n+\t}\n+\n+\tif (!tag_end)\n+\t\treturn 0;\n+\n+\t/* the end of the block has been found */\n+\twork.size = tag_end;\n+\tif (do_render && rndr->cb.blockhtml)\n+\t\trndr->cb.blockhtml(ob, &work, rndr->opaque);\n+\n+\treturn tag_end;\n+}\n+\n+static void\n+parse_table_row(\n+\tstruct buf *ob,\n+\tstruct sd_markdown *rndr,\n+\tuint8_t *data,\n+\tsize_t size,\n+\tsize_t columns,\n+\tint *col_data,\n+\tint header_flag)\n+{\n+\tsize_t i = 0, col;\n+\tstruct buf *row_work = 0;\n+\n+\tif (!rndr->cb.table_cell || !rndr->cb.table_row)\n+\t\treturn;\n+\n+\trow_work = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\tif (i < size && data[i] == '|')\n+\t\ti++;\n+\n+\tfor (col = 0; col < columns && i < size; ++col) {\n+\t\tsize_t cell_start, cell_end;\n+\t\tstruct buf *cell_work;\n+\n+\t\tcell_work = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\t\twhile (i < size && _isspace(data[i]))\n+\t\t\ti++;\n+\n+\t\tcell_start = i;\n+\n+\t\twhile (i < size && data[i] != '|')\n+\t\t\ti++;\n+\n+\t\tcell_end = i - 1;\n+\n+\t\twhile (cell_end > cell_start && _isspace(data[cell_end]))\n+\t\t\tcell_end--;\n+\n+\t\tparse_inline(cell_work, rndr, data + cell_start, 1 + cell_end - cell_start);\n+\t\trndr->cb.table_cell(row_work, cell_work, col_data[col] | header_flag, rndr->opaque);\n+\n+\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t\ti++;\n+\t}\n+\n+\tfor (; col < columns; ++col) {\n+\t\tstruct buf empty_cell = { 0, 0, 0, 0 };\n+\t\trndr->cb.table_cell(row_work, &empty_cell, col_data[col] | header_flag, rndr->opaque);\n+\t}\n+\n+\trndr->cb.table_row(ob, row_work, rndr->opaque);\n+\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+}\n+\n+static size_t\n+parse_table_header(\n+\tstruct buf *ob,\n+\tstruct sd_markdown *rndr,\n+\tuint8_t *data,\n+\tsize_t size,\n+\tsize_t *columns,\n+\tint **column_data)\n+{\n+\tint pipes;\n+\tsize_t i = 0, col, header_end, under_end;\n+\n+\tpipes = 0;\n+\twhile (i < size && data[i] != '\\n')\n+\t\tif (data[i++] == '|')\n+\t\t\tpipes++;\n+\n+\tif (i == size || pipes == 0)\n+\t\treturn 0;\n+\n+\theader_end = i;\n+\n+\twhile (header_end > 0 && _isspace(data[header_end - 1]))\n+\t\theader_end--;\n+\n+\tif (data[0] == '|')\n+\t\tpipes--;\n+\n+\tif (header_end && data[header_end - 1] == '|')\n+\t\tpipes--;\n+\n+\t*columns = pipes + 1;\n+\t*column_data = calloc(*columns, sizeof(int));\n+\n+\t/* Parse the header underline */\n+\ti++;\n+\tif (i < size && data[i] == '|')\n+\t\ti++;\n+\n+\tunder_end = i;\n+\twhile (under_end < size && data[under_end] != '\\n')\n+\t\tunder_end++;\n+\n+\tfor (col = 0; col < *columns && i < under_end; ++col) {\n+\t\tsize_t dashes = 0;\n+\n+\t\twhile (i < under_end && data[i] == ' ')\n+\t\t\ti++;\n+\n+\t\tif (data[i] == ':') {\n+\t\t\ti++; (*column_data)[col] |= MKD_TABLE_ALIGN_L;\n+\t\t\tdashes++;\n+\t\t}\n+\n+\t\twhile (i < under_end && data[i] == '-') {\n+\t\t\ti++; dashes++;\n+\t\t}\n+\n+\t\tif (i < under_end && data[i] == ':') {\n+\t\t\ti++; (*column_data)[col] |= MKD_TABLE_ALIGN_R;\n+\t\t\tdashes++;\n+\t\t}\n+\n+\t\twhile (i < under_end && data[i] == ' ')\n+\t\t\ti++;\n+\n+\t\tif (i < under_end && data[i] != '|')\n+\t\t\tbreak;\n+\n+\t\tif (dashes < 3)\n+\t\t\tbreak;\n+\n+\t\ti++;\n+\t}\n+\n+\tif (col < *columns)\n+\t\treturn 0;\n+\n+\tparse_table_row(\n+\t\tob, rndr, data,\n+\t\theader_end,\n+\t\t*columns,\n+\t\t*column_data,\n+\t\tMKD_TABLE_HEADER\n+\t);\n+\n+\treturn under_end + 1;\n+}\n+\n+static size_t\n+parse_table(\n+\tstruct buf *ob,\n+\tstruct sd_markdown *rndr,\n+\tuint8_t *data,\n+\tsize_t size)\n+{\n+\tsize_t i;\n+\n+\tstruct buf *header_work = 0;\n+\tstruct buf *body_work = 0;\n+\n+\tsize_t columns;\n+\tint *col_data = NULL;\n+\n+\theader_work = rndr_newbuf(rndr, BUFFER_SPAN);\n+\tbody_work = rndr_newbuf(rndr, BUFFER_BLOCK);\n+\n+\ti = parse_table_header(header_work, rndr, data, size, &columns, &col_data);\n+\tif (i > 0) {\n+\n+\t\twhile (i < size) {\n+\t\t\tsize_t row_start;\n+\t\t\tint pipes = 0;\n+\n+\t\t\trow_start = i;\n+\n+\t\t\twhile (i < size && data[i] != '\\n')\n+\t\t\t\tif (data[i++] == '|')\n+\t\t\t\t\tpipes++;\n+\n+\t\t\tif (pipes == 0 || i == size) {\n+\t\t\t\ti = row_start;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\tparse_table_row(\n+\t\t\t\tbody_work,\n+\t\t\t\trndr,\n+\t\t\t\tdata + row_start,\n+\t\t\t\ti - row_start,\n+\t\t\t\tcolumns,\n+\t\t\t\tcol_data, 0\n+\t\t\t);\n+\n+\t\t\ti++;\n+\t\t}\n+\n+\t\tif (rndr->cb.table)\n+\t\t\trndr->cb.table(ob, header_work, body_work, rndr->opaque);\n+\t}\n+\n+\tfree(col_data);\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+\trndr_popbuf(rndr, BUFFER_BLOCK);\n+\treturn i;\n+}\n+\n+/* parse_block \u2022 parsing of one block, returning next uint8_t to parse */\n+static void\n+parse_block(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tsize_t beg, end, i;\n+\tuint8_t *txt_data;\n+\tbeg = 0;\n+\n+\tif (rndr->work_bufs[BUFFER_SPAN].size +\n+\t\trndr->work_bufs[BUFFER_BLOCK].size > rndr->max_nesting)\n+\t\treturn;\n+\n+\twhile (beg < size) {\n+\t\ttxt_data = data + beg;\n+\t\tend = size - beg;\n+\n+\t\tif (is_atxheader(rndr, txt_data, end))\n+\t\t\tbeg += parse_atxheader(ob, rndr, txt_data, end);\n+\n+\t\telse if (data[beg] == '<' && rndr->cb.blockhtml &&\n+\t\t\t\t(i = parse_htmlblock(ob, rndr, txt_data, end, 1)) != 0)\n+\t\t\tbeg += i;\n+\n+\t\telse if ((i = is_empty(txt_data, end)) != 0)\n+\t\t\tbeg += i;\n+\n+\t\telse if (is_hrule(txt_data, end)) {\n+\t\t\tif (rndr->cb.hrule)\n+\t\t\t\trndr->cb.hrule(ob, rndr->opaque);\n+\n+\t\t\twhile (beg < size && data[beg] != '\\n')\n+\t\t\t\tbeg++;\n+\n+\t\t\tbeg++;\n+\t\t}\n+\n+\t\telse if ((rndr->ext_flags & MKDEXT_FENCED_CODE) != 0 &&\n+\t\t\t(i = parse_fencedcode(ob, rndr, txt_data, end)) != 0)\n+\t\t\tbeg += i;\n+\n+\t\telse if ((rndr->ext_flags & MKDEXT_TABLES) != 0 &&\n+\t\t\t(i = parse_table(ob, rndr, txt_data, end)) != 0)\n+\t\t\tbeg += i;\n+\n+\t\telse if (prefix_quote(txt_data, end))\n+\t\t\tbeg += parse_blockquote(ob, rndr, txt_data, end);\n+\n+\t\telse if (prefix_code(txt_data, end))\n+\t\t\tbeg += parse_blockcode(ob, rndr, txt_data, end);\n+\n+\t\telse if (prefix_uli(txt_data, end))\n+\t\t\tbeg += parse_list(ob, rndr, txt_data, end, 0);\n+\n+\t\telse if (prefix_oli(txt_data, end))\n+\t\t\tbeg += parse_list(ob, rndr, txt_data, end, MKD_LIST_ORDERED);\n+\n+\t\telse\n+\t\t\tbeg += parse_paragraph(ob, rndr, txt_data, end);\n+\t}\n+}\n+\n+\n+\n+/*********************\n+ * REFERENCE PARSING *\n+ *********************/\n+\n+/* is_ref \u2022 returns whether a line is a reference or not */\n+static int\n+is_ref(const uint8_t *data, size_t beg, size_t end, size_t *last, struct link_ref **refs)\n+{\n+/*\tint n; */\n+\tsize_t i = 0;\n+\tsize_t id_offset, id_end;\n+\tsize_t link_offset, link_end;\n+\tsize_t title_offset, title_end;\n+\tsize_t line_end;\n+\n+\t/* up to 3 optional leading spaces */\n+\tif (beg + 3 >= end) return 0;\n+\tif (data[beg] == ' ') { i = 1;\n+\tif (data[beg + 1] == ' ') { i = 2;\n+\tif (data[beg + 2] == ' ') { i = 3;\n+\tif (data[beg + 3] == ' ') return 0; } } }\n+\ti += beg;\n+\n+\t/* id part: anything but a newline between brackets */\n+\tif (data[i] != '[') return 0;\n+\ti++;\n+\tid_offset = i;\n+\twhile (i < end && data[i] != '\\n' && data[i] != '\\r' && data[i] != ']')\n+\t\ti++;\n+\tif (i >= end || data[i] != ']') return 0;\n+\tid_end = i;\n+\n+\t/* spacer: colon (space | tab)* newline? (space | tab)* */\n+\ti++;\n+\tif (i >= end || data[i] != ':') return 0;\n+\ti++;\n+\twhile (i < end && data[i] == ' ') i++;\n+\tif (i < end && (data[i] == '\\n' || data[i] == '\\r')) {\n+\t\ti++;\n+\t\tif (i < end && data[i] == '\\r' && data[i - 1] == '\\n') i++; }\n+\twhile (i < end && data[i] == ' ') i++;\n+\tif (i >= end) return 0;\n+\n+\t/* link: whitespace-free sequence, optionally between angle brackets */\n+\tif (data[i] == '<')\n+\t\ti++;\n+\n+\tlink_offset = i;\n+\n+\twhile (i < end && data[i] != ' ' && data[i] != '\\n' && data[i] != '\\r')\n+\t\ti++;\n+\n+\tif (data[i - 1] == '>') link_end = i - 1;\n+\telse link_end = i;\n+\n+\t/* optional spacer: (space | tab)* (newline | '\\'' | '\"' | '(' ) */\n+\twhile (i < end && data[i] == ' ') i++;\n+\tif (i < end && data[i] != '\\n' && data[i] != '\\r'\n+\t\t\t&& data[i] != '\\'' && data[i] != '\"' && data[i] != '(')\n+\t\treturn 0;\n+\tline_end = 0;\n+\t/* computing end-of-line */\n+\tif (i >= end || data[i] == '\\r' || data[i] == '\\n') line_end = i;\n+\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n+\t\tline_end = i + 1;\n+\n+\t/* optional (space|tab)* spacer after a newline */\n+\tif (line_end) {\n+\t\ti = line_end + 1;\n+\t\twhile (i < end && data[i] == ' ') i++; }\n+\n+\t/* optional title: any non-newline sequence enclosed in '\"()\n+\t\t\t\t\talone on its line */\n+\ttitle_offset = title_end = 0;\n+\tif (i + 1 < end\n+\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == '(')) {\n+\t\ti++;\n+\t\ttitle_offset = i;\n+\t\t/* looking for EOL */\n+\t\twhile (i < end && data[i] != '\\n' && data[i] != '\\r') i++;\n+\t\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n+\t\t\ttitle_end = i + 1;\n+\t\telse\ttitle_end = i;\n+\t\t/* stepping back */\n+\t\ti -= 1;\n+\t\twhile (i > title_offset && data[i] == ' ')\n+\t\t\ti -= 1;\n+\t\tif (i > title_offset\n+\t\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == ')')) {\n+\t\t\tline_end = title_end;\n+\t\t\ttitle_end = i; } }\n+\n+\tif (!line_end || link_end == link_offset)\n+\t\treturn 0; /* garbage after the link empty link */\n+\n+\t/* a valid ref has been found, filling-in return structures */\n+\tif (last)\n+\t\t*last = line_end;\n+\n+\tif (refs) {\n+\t\tstruct link_ref *ref;\n+\n+\t\tref = add_link_ref(refs, data + id_offset, id_end - id_offset);\n+\t\tif (!ref)\n+\t\t\treturn 0;\n+\n+\t\tref->link = bufnew(link_end - link_offset);\n+\t\tbufput(ref->link, data + link_offset, link_end - link_offset);\n+\n+\t\tif (title_end > title_offset) {\n+\t\t\tref->title = bufnew(title_end - title_offset);\n+\t\t\tbufput(ref->title, data + title_offset, title_end - title_offset);\n+\t\t}\n+\t}\n+\n+\treturn 1;\n+}\n+\n+static void expand_tabs(struct buf *ob, const uint8_t *line, size_t size)\n+{\n+\tsize_t  i = 0, tab = 0;\n+\n+\twhile (i < size) {\n+\t\tsize_t org = i;\n+\n+\t\twhile (i < size && line[i] != '\\t') {\n+\t\t\ti++; tab++;\n+\t\t}\n+\n+\t\tif (i > org)\n+\t\t\tbufput(ob, line + org, i - org);\n+\n+\t\tif (i >= size)\n+\t\t\tbreak;\n+\n+\t\tdo {\n+\t\t\tbufputc(ob, ' '); tab++;\n+\t\t} while (tab % 4);\n+\n+\t\ti++;\n+\t}\n+}\n+\n+/**********************\n+ * EXPORTED FUNCTIONS *\n+ **********************/\n+\n+struct sd_markdown *\n+sd_markdown_new(\n+\tunsigned int extensions,\n+\tsize_t max_nesting,\n+\tconst struct sd_callbacks *callbacks,\n+\tvoid *opaque)\n+{\n+\tstruct sd_markdown *md = NULL;\n+\n+\tassert(max_nesting > 0 && callbacks);\n+\n+\tmd = malloc(sizeof(struct sd_markdown));\n+\tif (!md)\n+\t\treturn NULL;\n+\n+\tmemcpy(&md->cb, callbacks, sizeof(struct sd_callbacks));\n+\n+\tstack_init(&md->work_bufs[BUFFER_BLOCK], 4);\n+\tstack_init(&md->work_bufs[BUFFER_SPAN], 8);\n+\n+\tmemset(md->active_char, 0x0, 256);\n+\n+\tif (md->cb.emphasis || md->cb.double_emphasis || md->cb.triple_emphasis) {\n+\t\tmd->active_char['*'] = MD_CHAR_EMPHASIS;\n+\t\tmd->active_char['_'] = MD_CHAR_EMPHASIS;\n+\t\tif (extensions & MKDEXT_STRIKETHROUGH)\n+\t\t\tmd->active_char['~'] = MD_CHAR_EMPHASIS;\n+\t}\n+\n+\tif (md->cb.codespan)\n+\t\tmd->active_char['`'] = MD_CHAR_CODESPAN;\n+\n+\tif (md->cb.linebreak)\n+\t\tmd->active_char['\\n'] = MD_CHAR_LINEBREAK;\n+\n+\tif (md->cb.image || md->cb.link)\n+\t\tmd->active_char['['] = MD_CHAR_LINK;\n+\n+\tmd->active_char['<'] = MD_CHAR_LANGLE;\n+\tmd->active_char['\\\\'] = MD_CHAR_ESCAPE;\n+\tmd->active_char['&'] = MD_CHAR_ENTITITY;\n+\n+\tif (extensions & MKDEXT_AUTOLINK) {\n+\t\tmd->active_char[':'] = MD_CHAR_AUTOLINK_URL;\n+\t\tmd->active_char['@'] = MD_CHAR_AUTOLINK_EMAIL;\n+\t\tmd->active_char['w'] = MD_CHAR_AUTOLINK_WWW;\n+\t}\n+\n+\tif (extensions & MKDEXT_SUPERSCRIPT)\n+\t\tmd->active_char['^'] = MD_CHAR_SUPERSCRIPT;\n+\n+\t/* Extension data */\n+\tmd->ext_flags = extensions;\n+\tmd->opaque = opaque;\n+\tmd->max_nesting = max_nesting;\n+\tmd->in_link_body = 0;\n+\n+\treturn md;\n+}\n+\n+void\n+sd_markdown_render(struct buf *ob, const uint8_t *document, size_t doc_size, struct sd_markdown *md)\n+{\n+#define MARKDOWN_GROW(x) ((x) + ((x) >> 1))\n+\tstatic const char UTF8_BOM[] = {0xEF, 0xBB, 0xBF};\n+\n+\tstruct buf *text;\n+\tsize_t beg, end;\n+\n+\ttext = bufnew(64);\n+\tif (!text)\n+\t\treturn;\n+\n+\t/* Preallocate enough space for our buffer to avoid expanding while copying */\n+\tbufgrow(text, doc_size);\n+\n+\t/* reset the references table */\n+\tmemset(&md->refs, 0x0, REF_TABLE_SIZE * sizeof(void *));\n+\n+\t/* first pass: looking for references, copying everything else */\n+\tbeg = 0;\n+\n+\t/* Skip a possible UTF-8 BOM, even though the Unicode standard\n+\t * discourages having these in UTF-8 documents */\n+\tif (doc_size >= 3 && memcmp(document, UTF8_BOM, 3) == 0)\n+\t\tbeg += 3;\n+\n+\twhile (beg < doc_size) /* iterating over lines */\n+\t\tif (is_ref(document, beg, doc_size, &end, md->refs))\n+\t\t\tbeg = end;\n+\t\telse { /* skipping to the next line */\n+\t\t\tend = beg;\n+\t\t\twhile (end < doc_size && document[end] != '\\n' && document[end] != '\\r')\n+\t\t\t\tend++;\n+\n+\t\t\t/* adding the line body if present */\n+\t\t\tif (end > beg)\n+\t\t\t\texpand_tabs(text, document + beg, end - beg);\n+\n+\t\t\twhile (end < doc_size && (document[end] == '\\n' || document[end] == '\\r')) {\n+\t\t\t\t/* add one \\n per newline */\n+\t\t\t\tif (document[end] == '\\n' || (end + 1 < doc_size && document[end + 1] != '\\n'))\n+\t\t\t\t\tbufputc(text, '\\n');\n+\t\t\t\tend++;\n+\t\t\t}\n+\n+\t\t\tbeg = end;\n+\t\t}\n+\n+\t/* pre-grow the output buffer to minimize allocations */\n+\tbufgrow(ob, MARKDOWN_GROW(text->size));\n+\n+\t/* second pass: actual rendering */\n+\tif (md->cb.doc_header)\n+\t\tmd->cb.doc_header(ob, md->opaque);\n+\n+\tif (text->size) {\n+\t\t/* adding a final newline if not already present */\n+\t\tif (text->data[text->size - 1] != '\\n' &&  text->data[text->size - 1] != '\\r')\n+\t\t\tbufputc(text, '\\n');\n+\n+\t\tparse_block(ob, md, text->data, text->size);\n+\t}\n+\n+\tif (md->cb.doc_footer)\n+\t\tmd->cb.doc_footer(ob, md->opaque);\n+\n+\t/* clean-up */\n+\tbufrelease(text);\n+\tfree_link_refs(md->refs);\n+\n+\tassert(md->work_bufs[BUFFER_SPAN].size == 0);\n+\tassert(md->work_bufs[BUFFER_BLOCK].size == 0);\n+}\n+\n+void\n+sd_markdown_free(struct sd_markdown *md)\n+{\n+\tsize_t i;\n+\n+\tfor (i = 0; i < (size_t)md->work_bufs[BUFFER_SPAN].asize; ++i)\n+\t\tbufrelease(md->work_bufs[BUFFER_SPAN].item[i]);\n+\n+\tfor (i = 0; i < (size_t)md->work_bufs[BUFFER_BLOCK].asize; ++i)\n+\t\tbufrelease(md->work_bufs[BUFFER_BLOCK].item[i]);\n+\n+\tstack_free(&md->work_bufs[BUFFER_SPAN]);\n+\tstack_free(&md->work_bufs[BUFFER_BLOCK]);\n+\n+\tfree(md);\n+}\n+\n+void\n+sd_version(int *ver_major, int *ver_minor, int *ver_revision)\n+{\n+\t*ver_major = SUNDOWN_VER_MAJOR;\n+\t*ver_minor = SUNDOWN_VER_MINOR;\n+\t*ver_revision = SUNDOWN_VER_REVISION;\n+}\n+\n+/* vim: set filetype=c: */"}, {"sha": "6f6553ec87df5ce680f476fce70db3ee5faeabac", "filename": "src/rt/sundown/src/markdown.h", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fmarkdown.h", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fmarkdown.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fmarkdown.h?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,138 @@\n+/* markdown.h - generic markdown parser */\n+\n+/*\n+ * Copyright (c) 2009, Natacha Port\u00e9\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#ifndef UPSKIRT_MARKDOWN_H\n+#define UPSKIRT_MARKDOWN_H\n+\n+#include \"buffer.h\"\n+#include \"autolink.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define SUNDOWN_VERSION \"1.16.0\"\n+#define SUNDOWN_VER_MAJOR 1\n+#define SUNDOWN_VER_MINOR 16\n+#define SUNDOWN_VER_REVISION 0\n+\n+/********************\n+ * TYPE DEFINITIONS *\n+ ********************/\n+\n+/* mkd_autolink - type of autolink */\n+enum mkd_autolink {\n+\tMKDA_NOT_AUTOLINK,\t/* used internally when it is not an autolink*/\n+\tMKDA_NORMAL,\t\t/* normal http/http/ftp/mailto/etc link */\n+\tMKDA_EMAIL,\t\t\t/* e-mail link without explit mailto: */\n+};\n+\n+enum mkd_tableflags {\n+\tMKD_TABLE_ALIGN_L = 1,\n+\tMKD_TABLE_ALIGN_R = 2,\n+\tMKD_TABLE_ALIGN_CENTER = 3,\n+\tMKD_TABLE_ALIGNMASK = 3,\n+\tMKD_TABLE_HEADER = 4\n+};\n+\n+enum mkd_extensions {\n+\tMKDEXT_NO_INTRA_EMPHASIS = (1 << 0),\n+\tMKDEXT_TABLES = (1 << 1),\n+\tMKDEXT_FENCED_CODE = (1 << 2),\n+\tMKDEXT_AUTOLINK = (1 << 3),\n+\tMKDEXT_STRIKETHROUGH = (1 << 4),\n+\tMKDEXT_SPACE_HEADERS = (1 << 6),\n+\tMKDEXT_SUPERSCRIPT = (1 << 7),\n+\tMKDEXT_LAX_SPACING = (1 << 8),\n+};\n+\n+/* sd_callbacks - functions for rendering parsed data */\n+struct sd_callbacks {\n+\t/* block level callbacks - NULL skips the block */\n+\tvoid (*blockcode)(struct buf *ob, const struct buf *text, const struct buf *lang, void *opaque);\n+\tvoid (*blockquote)(struct buf *ob, const struct buf *text, void *opaque);\n+\tvoid (*blockhtml)(struct buf *ob,const  struct buf *text, void *opaque);\n+\tvoid (*header)(struct buf *ob, const struct buf *text, int level, void *opaque);\n+\tvoid (*hrule)(struct buf *ob, void *opaque);\n+\tvoid (*list)(struct buf *ob, const struct buf *text, int flags, void *opaque);\n+\tvoid (*listitem)(struct buf *ob, const struct buf *text, int flags, void *opaque);\n+\tvoid (*paragraph)(struct buf *ob, const struct buf *text, void *opaque);\n+\tvoid (*table)(struct buf *ob, const struct buf *header, const struct buf *body, void *opaque);\n+\tvoid (*table_row)(struct buf *ob, const struct buf *text, void *opaque);\n+\tvoid (*table_cell)(struct buf *ob, const struct buf *text, int flags, void *opaque);\n+\n+\n+\t/* span level callbacks - NULL or return 0 prints the span verbatim */\n+\tint (*autolink)(struct buf *ob, const struct buf *link, enum mkd_autolink type, void *opaque);\n+\tint (*codespan)(struct buf *ob, const struct buf *text, void *opaque);\n+\tint (*double_emphasis)(struct buf *ob, const struct buf *text, void *opaque);\n+\tint (*emphasis)(struct buf *ob, const struct buf *text, void *opaque);\n+\tint (*image)(struct buf *ob, const struct buf *link, const struct buf *title, const struct buf *alt, void *opaque);\n+\tint (*linebreak)(struct buf *ob, void *opaque);\n+\tint (*link)(struct buf *ob, const struct buf *link, const struct buf *title, const struct buf *content, void *opaque);\n+\tint (*raw_html_tag)(struct buf *ob, const struct buf *tag, void *opaque);\n+\tint (*triple_emphasis)(struct buf *ob, const struct buf *text, void *opaque);\n+\tint (*strikethrough)(struct buf *ob, const struct buf *text, void *opaque);\n+\tint (*superscript)(struct buf *ob, const struct buf *text, void *opaque);\n+\n+\t/* low level callbacks - NULL copies input directly into the output */\n+\tvoid (*entity)(struct buf *ob, const struct buf *entity, void *opaque);\n+\tvoid (*normal_text)(struct buf *ob, const struct buf *text, void *opaque);\n+\n+\t/* header and footer */\n+\tvoid (*doc_header)(struct buf *ob, void *opaque);\n+\tvoid (*doc_footer)(struct buf *ob, void *opaque);\n+};\n+\n+struct sd_markdown;\n+\n+/*********\n+ * FLAGS *\n+ *********/\n+\n+/* list/listitem flags */\n+#define MKD_LIST_ORDERED\t1\n+#define MKD_LI_BLOCK\t\t2  /* <li> containing block data */\n+\n+/**********************\n+ * EXPORTED FUNCTIONS *\n+ **********************/\n+\n+extern struct sd_markdown *\n+sd_markdown_new(\n+\tunsigned int extensions,\n+\tsize_t max_nesting,\n+\tconst struct sd_callbacks *callbacks,\n+\tvoid *opaque);\n+\n+extern void\n+sd_markdown_render(struct buf *ob, const uint8_t *document, size_t doc_size, struct sd_markdown *md);\n+\n+extern void\n+sd_markdown_free(struct sd_markdown *md);\n+\n+extern void\n+sd_version(int *major, int *minor, int *revision);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n+\n+/* vim: set filetype=c: */"}, {"sha": "ce069ff3b9d09c2d56ffc88b10b9d1effb541221", "filename": "src/rt/sundown/src/stack.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fstack.c", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fstack.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fstack.c?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,81 @@\n+#include \"stack.h\"\n+#include <string.h>\n+\n+int\n+stack_grow(struct stack *st, size_t new_size)\n+{\n+\tvoid **new_st;\n+\n+\tif (st->asize >= new_size)\n+\t\treturn 0;\n+\n+\tnew_st = realloc(st->item, new_size * sizeof(void *));\n+\tif (new_st == NULL)\n+\t\treturn -1;\n+\n+\tmemset(new_st + st->asize, 0x0,\n+\t\t(new_size - st->asize) * sizeof(void *));\n+\n+\tst->item = new_st;\n+\tst->asize = new_size;\n+\n+\tif (st->size > new_size)\n+\t\tst->size = new_size;\n+\n+\treturn 0;\n+}\n+\n+void\n+stack_free(struct stack *st)\n+{\n+\tif (!st)\n+\t\treturn;\n+\n+\tfree(st->item);\n+\n+\tst->item = NULL;\n+\tst->size = 0;\n+\tst->asize = 0;\n+}\n+\n+int\n+stack_init(struct stack *st, size_t initial_size)\n+{\n+\tst->item = NULL;\n+\tst->size = 0;\n+\tst->asize = 0;\n+\n+\tif (!initial_size)\n+\t\tinitial_size = 8;\n+\n+\treturn stack_grow(st, initial_size);\n+}\n+\n+void *\n+stack_pop(struct stack *st)\n+{\n+\tif (!st->size)\n+\t\treturn NULL;\n+\n+\treturn st->item[--st->size];\n+}\n+\n+int\n+stack_push(struct stack *st, void *item)\n+{\n+\tif (stack_grow(st, st->size * 2) < 0)\n+\t\treturn -1;\n+\n+\tst->item[st->size++] = item;\n+\treturn 0;\n+}\n+\n+void *\n+stack_top(struct stack *st)\n+{\n+\tif (!st->size)\n+\t\treturn NULL;\n+\n+\treturn st->item[st->size - 1];\n+}\n+"}, {"sha": "08ff030a33b0fba0743509307ec12676215ad729", "filename": "src/rt/sundown/src/stack.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fstack.h", "raw_url": "https://github.com/rust-lang/rust/raw/6aba140fa738acea9d06e29e95abbfcc9d1cba5d/src%2Frt%2Fsundown%2Fsrc%2Fstack.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fstack.h?ref=6aba140fa738acea9d06e29e95abbfcc9d1cba5d", "patch": "@@ -0,0 +1,29 @@\n+#ifndef STACK_H__\n+#define STACK_H__\n+\n+#include <stdlib.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+struct stack {\n+\tvoid **item;\n+\tsize_t size;\n+\tsize_t asize;\n+};\n+\n+void stack_free(struct stack *);\n+int stack_grow(struct stack *, size_t);\n+int stack_init(struct stack *, size_t);\n+\n+int stack_push(struct stack *, void *);\n+\n+void *stack_pop(struct stack *);\n+void *stack_top(struct stack *);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"}]}