{"sha": "9dc7abe06d2b2771b09b6dac6eef5ac83b58573f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkYzdhYmUwNmQyYjI3NzFiMDliNmRhYzZlZWY1YWM4M2I1ODU3M2Y=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-10-22T16:19:30Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-11-04T00:39:16Z"}, "message": "Detect `=` -> `:` typo in let bindings\n\nWhen encountering a let binding type error, attempt to parse as\ninitializer instead. If successful, it is likely just a typo:\n\n```rust\nfn main() {\n    let x: Vec::with_capacity(10);\n}\n```\n\n```\nerror: expected type, found `10`\n --> file.rs:3:31\n  |\n3 |     let x: Vec::with_capacity(10, 20);\n  |         --                    ^^\n  |         ||\n  |         |help: did you mean assign here?: `=`\n  |         while parsing the type for `x`\n```", "tree": {"sha": "b18ca574a970e3f54b58f73f5330a7429fe99298", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b18ca574a970e3f54b58f73f5330a7429fe99298"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f", "html_url": "https://github.com/rust-lang/rust/commit/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ce3d482e2313fe6795e6d688e62a092af424da8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ce3d482e2313fe6795e6d688e62a092af424da8", "html_url": "https://github.com/rust-lang/rust/commit/5ce3d482e2313fe6795e6d688e62a092af424da8"}], "stats": {"total": 197, "additions": 121, "deletions": 76}, "files": [{"sha": "4b7f1cbe0ad7f1daa3b52587925b751b88c0a13b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9dc7abe06d2b2771b09b6dac6eef5ac83b58573f", "patch": "@@ -2597,7 +2597,7 @@ impl<'a> Resolver<'a> {\n                             }\n                         }\n                         err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\",\n-                                                       path_str));\n+                                                     path_str));\n                         return (err, candidates);\n                     }\n                     _ => {}"}, {"sha": "52593ada71ec38adf3de7654081fe90b0f2cf68e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 88, "deletions": 44, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9dc7abe06d2b2771b09b6dac6eef5ac83b58573f", "patch": "@@ -974,11 +974,12 @@ impl<'a> Parser<'a> {\n     pub fn eat_to_tokens(&mut self, kets: &[&token::Token]) {\n         let handler = self.diagnostic();\n \n-        self.parse_seq_to_before_tokens(kets,\n-                                        SeqSep::none(),\n-                                        TokenExpectType::Expect,\n-                                        |p| Ok(p.parse_token_tree()),\n-                                        |mut e| handler.cancel(&mut e));\n+        if let Err(ref mut err) = self.parse_seq_to_before_tokens(kets,\n+                                                                  SeqSep::none(),\n+                                                                  TokenExpectType::Expect,\n+                                                                  |p| Ok(p.parse_token_tree())) {\n+            handler.cancel(err);\n+        }\n     }\n \n     /// Parse a sequence, including the closing delimiter. The function\n@@ -991,7 +992,7 @@ impl<'a> Parser<'a> {\n                                   -> PResult<'a, Vec<T>> where\n         F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n     {\n-        let val = self.parse_seq_to_before_end(ket, sep, f);\n+        let val = self.parse_seq_to_before_end(ket, sep, f)?;\n         self.bump();\n         Ok(val)\n     }\n@@ -1003,22 +1004,19 @@ impl<'a> Parser<'a> {\n                                          ket: &token::Token,\n                                          sep: SeqSep,\n                                          f: F)\n-                                         -> Vec<T>\n-        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>\n+                                         -> PResult<'a, Vec<T>>\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a, T>\n     {\n-        self.parse_seq_to_before_tokens(&[ket], sep, TokenExpectType::Expect, f, |mut e| e.emit())\n+        self.parse_seq_to_before_tokens(&[ket], sep, TokenExpectType::Expect, f)\n     }\n \n-    // `fe` is an error handler.\n-    fn parse_seq_to_before_tokens<T, F, Fe>(&mut self,\n+    fn parse_seq_to_before_tokens<T, F>(&mut self,\n                                             kets: &[&token::Token],\n                                             sep: SeqSep,\n                                             expect: TokenExpectType,\n-                                            mut f: F,\n-                                            mut fe: Fe)\n-                                            -> Vec<T>\n-        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n-              Fe: FnMut(DiagnosticBuilder)\n+                                            mut f: F)\n+                                            -> PResult<'a, Vec<T>>\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a, T>\n     {\n         let mut first: bool = true;\n         let mut v = vec![];\n@@ -1031,14 +1029,14 @@ impl<'a> Parser<'a> {\n                 if first {\n                     first = false;\n                 } else {\n-                    if let Err(e) = self.expect(t) {\n-                        fe(e);\n+                    if let Err(mut e) = self.expect(t) {\n                         // Attempt to keep parsing if it was a similar separator\n                         if let Some(ref tokens) = t.similar_tokens() {\n                             if tokens.contains(&self.token) {\n                                 self.bump();\n                             }\n                         }\n+                        e.emit();\n                         // Attempt to keep parsing if it was an omitted separator\n                         match f(self) {\n                             Ok(t) => {\n@@ -1062,16 +1060,11 @@ impl<'a> Parser<'a> {\n                 break;\n             }\n \n-            match f(self) {\n-                Ok(t) => v.push(t),\n-                Err(e) => {\n-                    fe(e);\n-                    break;\n-                }\n-            }\n+            let t = f(self)?;\n+            v.push(t);\n         }\n \n-        v\n+        Ok(v)\n     }\n \n     /// Parse a sequence, including the closing delimiter. The function\n@@ -1086,7 +1079,7 @@ impl<'a> Parser<'a> {\n         F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n     {\n         self.expect(bra)?;\n-        let result = self.parse_seq_to_before_end(ket, sep, f);\n+        let result = self.parse_seq_to_before_end(ket, sep, f)?;\n         if self.token == *ket {\n             self.bump();\n         }\n@@ -1105,7 +1098,7 @@ impl<'a> Parser<'a> {\n     {\n         let lo = self.span;\n         self.expect(bra)?;\n-        let result = self.parse_seq_to_before_end(ket, sep, f);\n+        let result = self.parse_seq_to_before_end(ket, sep, f)?;\n         let hi = self.span;\n         self.bump();\n         Ok(respan(lo.to(hi), result))\n@@ -1551,7 +1544,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let span = lo.to(self.prev_span);\n-        let ty = Ty { node: node, span: span, id: ast::DUMMY_NODE_ID };\n+        let ty = Ty { node, span, id: ast::DUMMY_NODE_ID };\n \n         // Try to recover from use of `+` with incorrect priority.\n         self.maybe_recover_from_bad_type_plus(allow_plus, &ty)?;\n@@ -1868,8 +1861,11 @@ impl<'a> Parser<'a> {\n         self.parse_path(style)\n     }\n \n-    fn parse_path_segments(&mut self, segments: &mut Vec<PathSegment>, style: PathStyle,\n-                           enable_warning: bool) -> PResult<'a, ()> {\n+    fn parse_path_segments(&mut self,\n+                           segments: &mut Vec<PathSegment>,\n+                           style: PathStyle,\n+                           enable_warning: bool)\n+                           -> PResult<'a, ()> {\n         loop {\n             segments.push(self.parse_path_segment(style, enable_warning)?);\n \n@@ -1914,9 +1910,12 @@ impl<'a> Parser<'a> {\n             } else {\n                 // `(T, U) -> R`\n                 self.bump(); // `(`\n-                let inputs = self.parse_seq_to_end(&token::CloseDelim(token::Paren),\n-                                                   SeqSep::trailing_allowed(token::Comma),\n-                                                   |p| p.parse_ty())?;\n+                let inputs = self.parse_seq_to_before_tokens(\n+                    &[&token::CloseDelim(token::Paren)],\n+                    SeqSep::trailing_allowed(token::Comma),\n+                    TokenExpectType::Expect,\n+                    |p| p.parse_ty())?;\n+                self.bump(); // `)`\n                 let output = if self.eat(&token::RArrow) {\n                     Some(self.parse_ty_no_plus()?)\n                 } else {\n@@ -3309,10 +3308,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the RHS of a local variable declaration (e.g. '= 14;')\n-    fn parse_initializer(&mut self) -> PResult<'a, Option<P<Expr>>> {\n+    fn parse_initializer(&mut self, skip_eq: bool) -> PResult<'a, Option<P<Expr>>> {\n         if self.check(&token::Eq) {\n             self.bump();\n             Ok(Some(self.parse_expr()?))\n+        } else if skip_eq {\n+            Ok(Some(self.parse_expr()?))\n         } else {\n             Ok(None)\n         }\n@@ -3719,12 +3720,56 @@ impl<'a> Parser<'a> {\n         let lo = self.prev_span;\n         let pat = self.parse_pat()?;\n \n-        let ty = if self.eat(&token::Colon) {\n-            Some(self.parse_ty()?)\n+        let (err, ty) = if self.eat(&token::Colon) {\n+            // Save the state of the parser before parsing type normally, in case there is a `:`\n+            // instead of an `=` typo.\n+            let parser_snapshot_before_type = self.clone();\n+            let colon_sp = self.prev_span;\n+            match self.parse_ty() {\n+                Ok(ty) => (None, Some(ty)),\n+                Err(mut err) => {\n+                    // Rewind to before attempting to parse the type and continue parsing\n+                    let parser_snapshot_after_type = self.clone();\n+                    mem::replace(self, parser_snapshot_before_type);\n+\n+                    let snippet = self.sess.codemap().span_to_snippet(pat.span).unwrap();\n+                    err.span_label(pat.span, format!(\"while parsing the type for `{}`\", snippet));\n+                    (Some((parser_snapshot_after_type, colon_sp, err)), None)\n+                }\n+            }\n         } else {\n-            None\n+            (None, None)\n+        };\n+        let init = match (self.parse_initializer(err.is_some()), err) {\n+            (Ok(init), None) => {  // init parsed, ty parsed\n+                init\n+            }\n+            (Ok(init), Some((_, colon_sp, mut err))) => {  // init parsed, ty error\n+                // Could parse the type as if it were the initializer, it is likely there was a\n+                // typo in the code: `:` instead of `=`. Add suggestion and emit the error.\n+                err.span_suggestion_short(colon_sp,\n+                                          \"use `=` if you meant to assign\",\n+                                          \"=\".to_string());\n+                err.emit();\n+                // As this was parsed successfuly, continue as if the code has been fixed for the\n+                // rest of the file. It will still fail due to the emitted error, but we avoid\n+                // extra noise.\n+                init\n+            }\n+            (Err(mut init_err), Some((snapshot, _, ty_err))) => {  // init error, ty error\n+                init_err.cancel();\n+                // Couldn't parse the type nor the initializer, only raise the type error and\n+                // return to the parser state before parsing the type as the initializer.\n+                // let x: <parse_error>;\n+                mem::replace(self, snapshot);\n+                return Err(ty_err);\n+            }\n+            (Err(err), None) => {  // init error, ty parsed\n+                // Couldn't parse the initializer and we're not attempting to recover a failed\n+                // parse of the type, return the error.\n+                return Err(err);\n+            }\n         };\n-        let init = self.parse_initializer()?;\n         let hi = if self.token == token::Semi {\n             self.span\n         } else {\n@@ -4781,14 +4826,14 @@ impl<'a> Parser<'a> {\n             } else if self.eat(&token::Comma) {\n                 let mut fn_inputs = vec![self_arg];\n                 fn_inputs.append(&mut self.parse_seq_to_before_end(\n-                    &token::CloseDelim(token::Paren), sep, parse_arg_fn)\n+                    &token::CloseDelim(token::Paren), sep, parse_arg_fn)?\n                 );\n                 fn_inputs\n             } else {\n                 return self.unexpected();\n             }\n         } else {\n-            self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)\n+            self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)?\n         };\n \n         // Parse closing paren and return type.\n@@ -4811,9 +4856,8 @@ impl<'a> Parser<'a> {\n                     &[&token::BinOp(token::Or), &token::OrOr],\n                     SeqSep::trailing_allowed(token::Comma),\n                     TokenExpectType::NoExpect,\n-                    |p| p.parse_fn_block_arg(),\n-                    |mut e| e.emit()\n-                );\n+                    |p| p.parse_fn_block_arg()\n+                )?;\n                 self.expect_or()?;\n                 args\n             }"}, {"sha": "b2dba3bd61b36301dfb73b81f6c183cf7b84fde5", "filename": "src/test/compile-fail/self-vs-path-ambiguity.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Ftest%2Fcompile-fail%2Fself-vs-path-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Ftest%2Fcompile-fail%2Fself-vs-path-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself-vs-path-ambiguity.rs?ref=9dc7abe06d2b2771b09b6dac6eef5ac83b58573f", "patch": "@@ -17,7 +17,6 @@ impl S {\n     fn g(&self::S: &S) {}\n     fn h(&mut self::S: &mut S) {}\n     fn i(&'a self::S: &S) {} //~ ERROR unexpected lifetime `'a` in pattern\n-                             //~^ ERROR expected one of `)` or `mut`, found `'a`\n }\n \n fn main() {}"}, {"sha": "25ae7b4c55a2b306e055810179f80643967eeeb2", "filename": "src/test/parse-fail/issue-33413.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Ftest%2Fparse-fail%2Fissue-33413.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Ftest%2Fparse-fail%2Fissue-33413.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-33413.rs?ref=9dc7abe06d2b2771b09b6dac6eef5ac83b58573f", "patch": "@@ -12,5 +12,4 @@\n \n impl S {\n     fn f(*, a: u8) -> u8 {} //~ ERROR expected pattern, found `*`\n-    //~^ ERROR expected one of `)`, `-`, `box`, `false`, `mut`, `ref`, or `true`, found `*`\n }"}, {"sha": "e7afbb574efd7d4705ec3859d407be566d5de9f7", "filename": "src/test/ui/issue-44406.stderr", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Ftest%2Fui%2Fissue-44406.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Ftest%2Fui%2Fissue-44406.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-44406.stderr?ref=9dc7abe06d2b2771b09b6dac6eef5ac83b58573f", "patch": "@@ -13,14 +13,5 @@ error: expected type, found keyword `true`\n 18 |     foo!(true);\n    |          ^^^^ expecting a type here because of type ascription\n \n-error: expected one of `!`, `&&`, `&`, `(`, `*`, `.`, `;`, `<`, `?`, `[`, `_`, `dyn`, `extern`, `fn`, `for`, `impl`, `unsafe`, `}`, an operator, or lifetime, found `true`\n-  --> $DIR/issue-44406.rs:18:10\n-   |\n-13 |         bar(baz: $rest)\n-   |                 - expected one of 20 possible tokens here\n-...\n-18 |     foo!(true);\n-   |          ^^^^ unexpected token\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "6bd63f4fbbb899b43a55139376f281a079d6529b", "filename": "src/test/ui/resolve/token-error-correct.stderr", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr?ref=9dc7abe06d2b2771b09b6dac6eef5ac83b58573f", "patch": "@@ -28,29 +28,11 @@ error: expected expression, found `;`\n 14 |     foo(bar(;\n    |             ^\n \n-error: expected one of `)`, `,`, `.`, `<`, `?`, `break`, `continue`, `false`, `for`, `if`, `loop`, `match`, `move`, `return`, `true`, `unsafe`, `while`, `yield`, or an operator, found `;`\n-  --> $DIR/token-error-correct.rs:14:13\n-   |\n-14 |     foo(bar(;\n-   |             ^ expected one of 19 possible tokens here\n-\n error: expected expression, found `)`\n   --> $DIR/token-error-correct.rs:23:1\n    |\n 23 | }\n    | ^\n \n-error[E0425]: cannot find function `foo` in this scope\n-  --> $DIR/token-error-correct.rs:14:5\n-   |\n-14 |     foo(bar(;\n-   |     ^^^ not found in this scope\n-\n-error[E0425]: cannot find function `bar` in this scope\n-  --> $DIR/token-error-correct.rs:14:9\n-   |\n-14 |     foo(bar(;\n-   |         ^^^ not found in this scope\n-\n-error: aborting due to 7 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "bcd965f10fabb644651cc7c5c80ed8c8c3b54ebe", "filename": "src/test/ui/suggestions/type-ascription-instead-of-initializer.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-initializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-initializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-initializer.rs?ref=9dc7abe06d2b2771b09b6dac6eef5ac83b58573f", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x: Vec::with_capacity(10, 20);\n+}"}, {"sha": "647e3f84685f1dc2fbcdf80eefed8ad6b9532121", "filename": "src/test/ui/suggestions/type-ascription-instead-of-initializer.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-initializer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9dc7abe06d2b2771b09b6dac6eef5ac83b58573f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-initializer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-initializer.stderr?ref=9dc7abe06d2b2771b09b6dac6eef5ac83b58573f", "patch": "@@ -0,0 +1,17 @@\n+error: expected type, found `10`\n+  --> $DIR/type-ascription-instead-of-initializer.rs:12:31\n+   |\n+12 |     let x: Vec::with_capacity(10, 20);\n+   |         --                    ^^\n+   |         ||\n+   |         |help: use `=` if you meant to assign\n+   |         while parsing the type for `x`\n+\n+error[E0061]: this function takes 1 parameter but 2 parameters were supplied\n+  --> $DIR/type-ascription-instead-of-initializer.rs:12:31\n+   |\n+12 |     let x: Vec::with_capacity(10, 20);\n+   |                               ^^^^^^ expected 1 parameter\n+\n+error: aborting due to 2 previous errors\n+"}]}