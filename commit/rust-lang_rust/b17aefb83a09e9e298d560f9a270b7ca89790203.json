{"sha": "b17aefb83a09e9e298d560f9a270b7ca89790203", "node_id": "C_kwDOAAsO6NoAKGIxN2FlZmI4M2EwOWU5ZTI5OGQ1NjBmOWEyNzBiN2NhODk3OTAyMDM", "commit": {"author": {"name": "iDawer", "email": "ilnur.iskhakov.oss@outlook.com", "date": "2021-11-27T13:13:47Z"}, "committer": {"name": "iDawer", "email": "ilnur.iskhakov.oss@outlook.com", "date": "2021-12-19T19:14:39Z"}, "message": "internal: Normalize field type after substituting", "tree": {"sha": "25b024100b05596cd56f2d848c07c55d84d24ab9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25b024100b05596cd56f2d848c07c55d84d24ab9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b17aefb83a09e9e298d560f9a270b7ca89790203", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b17aefb83a09e9e298d560f9a270b7ca89790203", "html_url": "https://github.com/rust-lang/rust/commit/b17aefb83a09e9e298d560f9a270b7ca89790203", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b17aefb83a09e9e298d560f9a270b7ca89790203/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1280961b51fb0b80867758dc5062bca3b9f0f6fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/1280961b51fb0b80867758dc5062bca3b9f0f6fe", "html_url": "https://github.com/rust-lang/rust/commit/1280961b51fb0b80867758dc5062bca3b9f0f6fe"}], "stats": {"total": 54, "additions": 50, "deletions": 4}, "files": [{"sha": "a8c4026e31f3b1a2a7fe9a449ce404dfdce8a430", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b17aefb83a09e9e298d560f9a270b7ca89790203/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b17aefb83a09e9e298d560f9a270b7ca89790203/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=b17aefb83a09e9e298d560f9a270b7ca89790203", "patch": "@@ -285,6 +285,7 @@ impl ExprValidator {\n         let pattern_arena = Arena::new();\n         let cx = MatchCheckCtx {\n             module: self.owner.module(db.upcast()),\n+            body: self.owner,\n             db,\n             pattern_arena: &pattern_arena,\n         };"}, {"sha": "84ded517ba7ad2cc25943f0805fdb2aff64020df", "filename": "crates/hir_ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b17aefb83a09e9e298d560f9a270b7ca89790203/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b17aefb83a09e9e298d560f9a270b7ca89790203/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=b17aefb83a09e9e298d560f9a270b7ca89790203", "patch": "@@ -53,7 +53,7 @@ use smallvec::{smallvec, SmallVec};\n use stdx::never;\n use syntax::SmolStr;\n \n-use crate::{AdtId, Interner, Scalar, Ty, TyExt, TyKind};\n+use crate::{infer::normalize, AdtId, Interner, Scalar, Ty, TyExt, TyKind};\n \n use super::{\n     usefulness::{helper::Captures, MatchCheckCtx, PatCtxt},\n@@ -753,8 +753,8 @@ impl<'p> Fields<'p> {\n         let fields_len = variant.variant_data(cx.db.upcast()).fields().len() as u32;\n \n         (0..fields_len).map(|idx| LocalFieldId::from_raw(idx.into())).filter_map(move |fid| {\n-            // TODO check ty has been normalized\n             let ty = field_ty[fid].clone().substitute(Interner, substs);\n+            let ty = normalize(cx.db, cx.body, ty);\n             let is_visible = matches!(adt, hir_def::AdtId::EnumId(..))\n                 || visibility[fid].is_visible_from(cx.db.upcast(), cx.module);\n             let is_uninhabited = cx.is_uninhabited(&ty);"}, {"sha": "e8a13955d21c6711a8e76be6bd3c8f13eafde694", "filename": "crates/hir_ty/src/diagnostics/match_check/usefulness.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b17aefb83a09e9e298d560f9a270b7ca89790203/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b17aefb83a09e9e298d560f9a270b7ca89790203/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs?ref=b17aefb83a09e9e298d560f9a270b7ca89790203", "patch": "@@ -273,7 +273,7 @@\n \n use std::iter::once;\n \n-use hir_def::{AdtId, HasModule, ModuleId};\n+use hir_def::{AdtId, DefWithBodyId, HasModule, ModuleId};\n use smallvec::{smallvec, SmallVec};\n use typed_arena::Arena;\n \n@@ -285,6 +285,7 @@ use self::{helper::Captures, ArmType::*, Usefulness::*};\n \n pub(crate) struct MatchCheckCtx<'a, 'p> {\n     pub(crate) module: ModuleId,\n+    pub(crate) body: DefWithBodyId,\n     pub(crate) db: &'a dyn HirDatabase,\n     /// Lowered patterns from arms plus generated by the check.\n     pub(crate) pattern_arena: &'p Arena<DeconstructedPat<'p>>,"}, {"sha": "95d9a6735a34f5836cf77771d8a93362bb9c2683", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b17aefb83a09e9e298d560f9a270b7ca89790203/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b17aefb83a09e9e298d560f9a270b7ca89790203/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=b17aefb83a09e9e298d560f9a270b7ca89790203", "patch": "@@ -16,7 +16,7 @@\n use std::ops::Index;\n use std::sync::Arc;\n \n-use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety, Scalar};\n+use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n use hir_def::{\n     body::Body,\n     data::{ConstData, FunctionData, StaticData},\n@@ -70,6 +70,26 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n     Arc::new(ctx.resolve_all())\n }\n \n+/// Fully normalize all the types found within `ty` in context of `owner` body definition.\n+///\n+/// This is appropriate to use only after type-check: it assumes\n+/// that normalization will succeed, for example.\n+pub(crate) fn normalize(db: &dyn HirDatabase, owner: DefWithBodyId, ty: Ty) -> Ty {\n+    if !ty.data(Interner).flags.intersects(TypeFlags::HAS_PROJECTION) {\n+        return ty;\n+    }\n+    let krate = owner.module(db.upcast()).krate();\n+    let trait_env = owner\n+        .as_generic_def_id()\n+        .map_or_else(|| Arc::new(TraitEnvironment::empty(krate)), |d| db.trait_environment(d));\n+    let mut table = unify::InferenceTable::new(db, trait_env.clone());\n+\n+    let ty_with_vars = table.normalize_associated_types_in(ty);\n+    table.resolve_obligations_as_possible();\n+    table.propagate_diverging_flag();\n+    table.resolve_completely(ty_with_vars)\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n enum ExprOrPatId {\n     ExprId(ExprId),"}, {"sha": "5ef4d2a2266635cec1e2417b3e6c867c1bcd77b3", "filename": "crates/ide_diagnostics/src/handlers/missing_match_arms.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b17aefb83a09e9e298d560f9a270b7ca89790203/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b17aefb83a09e9e298d560f9a270b7ca89790203/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=b17aefb83a09e9e298d560f9a270b7ca89790203", "patch": "@@ -863,6 +863,30 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn normalize_field_ty() {\n+        check_diagnostics_no_bails(\n+            r\"\n+trait Trait { type Projection; }\n+enum E {Foo, Bar}\n+struct A;\n+impl Trait for A { type Projection = E; }\n+struct Next<T: Trait>(T::Projection);\n+static __: () = {\n+    let n: Next<A> = Next(E::Foo);\n+    match n { Next(E::Foo) => {} }\n+    //    ^ error: missing match arm\n+    match n { Next(E::Foo | E::Bar) => {} }\n+    match n { Next(E::Foo | _     ) => {} }\n+    match n { Next(_      | E::Bar) => {} }\n+    match n {      _ | Next(E::Bar) => {} }\n+    match &n { Next(E::Foo | E::Bar) => {} }\n+    match &n {      _ | Next(E::Bar) => {} }\n+};\",\n+\n+        );\n+    }\n+\n     mod false_negatives {\n         //! The implementation of match checking here is a work in progress. As we roll this out, we\n         //! prefer false negatives to false positives (ideally there would be no false positives). This"}]}