{"sha": "66ccf36f161f67b121290e2af2517ead7e695d3b", "node_id": "C_kwDOAAsO6NoAKDY2Y2NmMzZmMTYxZjY3YjEyMTI5MGUyYWYyNTE3ZWFkN2U2OTVkM2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-22T13:18:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-22T13:18:45Z"}, "message": "Auto merge of #104711 - Dylan-DPC:rollup-gkw1qr8, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #104295 (Check generics parity before collecting return-position `impl Trait`s in trait)\n - #104464 (Reduce exceptions overallocation on non Windows x86_64)\n - #104615 (Create def_id for async fns during lowering)\n - #104669 (Only declare bindings for if-let guards once per arm)\n - #104701 (Remove a lifetime resolution hack from `compare_predicate_entailment`)\n - #104710 (disable strict-provenance-violating doctests in Miri)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c02c6f5385f260775fd27d0321650d132207aca5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c02c6f5385f260775fd27d0321650d132207aca5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66ccf36f161f67b121290e2af2517ead7e695d3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66ccf36f161f67b121290e2af2517ead7e695d3b", "html_url": "https://github.com/rust-lang/rust/commit/66ccf36f161f67b121290e2af2517ead7e695d3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66ccf36f161f67b121290e2af2517ead7e695d3b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7463e8bdb7b039e75241dcc4ea65bbd24d5c608", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7463e8bdb7b039e75241dcc4ea65bbd24d5c608", "html_url": "https://github.com/rust-lang/rust/commit/b7463e8bdb7b039e75241dcc4ea65bbd24d5c608"}, {"sha": "a40659ded3ae4dde742261ded4da69ecb1ca3c1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a40659ded3ae4dde742261ded4da69ecb1ca3c1c", "html_url": "https://github.com/rust-lang/rust/commit/a40659ded3ae4dde742261ded4da69ecb1ca3c1c"}], "stats": {"total": 183, "additions": 114, "deletions": 69}, "files": [{"sha": "bd1876d428475ffe267b86ffd0c91a8407ae0374", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66ccf36f161f67b121290e2af2517ead7e695d3b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ccf36f161f67b121290e2af2517ead7e695d3b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=66ccf36f161f67b121290e2af2517ead7e695d3b", "patch": "@@ -1817,9 +1817,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n-        let opaque_ty_def_id = self.local_def_id(opaque_ty_node_id);\n         let fn_def_id = self.local_def_id(fn_node_id);\n \n+        let opaque_ty_def_id =\n+            self.create_def(fn_def_id, opaque_ty_node_id, DefPathData::ImplTrait);\n+\n         // When we create the opaque type for this async fn, it is going to have\n         // to capture all the lifetimes involved in the signature (including in the\n         // return type). This is done by introducing lifetime parameters for:"}, {"sha": "bf4e5126bfa100fc0cb9654f550fcc357572094c", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/66ccf36f161f67b121290e2af2517ead7e695d3b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ccf36f161f67b121290e2af2517ead7e695d3b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=66ccf36f161f67b121290e2af2517ead7e695d3b", "patch": "@@ -14,10 +14,8 @@ use rustc_infer::traits::util;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::util::ExplicitSelf;\n use rustc_middle::ty::{\n-    self, AssocItem, DefIdTree, TraitRef, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable,\n-    TypeVisitable,\n+    self, DefIdTree, InternalSubsts, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n };\n-use rustc_middle::ty::{FnSig, InternalSubsts};\n use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n@@ -51,11 +49,11 @@ pub(crate) fn compare_impl_method<'tcx>(\n         return;\n     }\n \n-    if let Err(_) = compare_number_of_generics(tcx, impl_m, impl_m_span, trait_m, trait_item_span) {\n+    if let Err(_) = compare_number_of_generics(tcx, impl_m, trait_m, trait_item_span, false) {\n         return;\n     }\n \n-    if let Err(_) = compare_generic_param_kinds(tcx, impl_m, trait_m) {\n+    if let Err(_) = compare_generic_param_kinds(tcx, impl_m, trait_m, false) {\n         return;\n     }\n \n@@ -144,9 +142,9 @@ pub(crate) fn compare_impl_method<'tcx>(\n #[instrument(level = \"debug\", skip(tcx, impl_m_span, impl_trait_ref))]\n fn compare_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &AssocItem,\n+    impl_m: &ty::AssocItem,\n     impl_m_span: Span,\n-    trait_m: &AssocItem,\n+    trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_to_impl_substs = impl_trait_ref.substs;\n@@ -157,8 +155,7 @@ fn compare_predicate_entailment<'tcx>(\n     // FIXME(@lcnr): remove that after removing `cause.body_id` from\n     // obligations.\n     let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n-    // We sometimes modify the span further down.\n-    let mut cause = ObligationCause::new(\n+    let cause = ObligationCause::new(\n         impl_m_span,\n         impl_m_hir_id,\n         ObligationCauseCode::CompareImplItemObligation {\n@@ -291,30 +288,19 @@ fn compare_predicate_entailment<'tcx>(\n     // type would be more appropriate. In other places we have a `Vec<Span>`\n     // corresponding to their `Vec<Predicate>`, but we don't have that here.\n     // Fixing this would improve the output of test `issue-83765.rs`.\n-    let mut result = ocx.sup(&cause, param_env, trait_fty, impl_fty);\n-\n-    // HACK(RPITIT): #101614. When we are trying to infer the hidden types for\n-    // RPITITs, we need to equate the output tys instead of just subtyping. If\n-    // we just use `sup` above, we'll end up `&'static str <: _#1t`, which causes\n-    // us to infer `_#1t = #'_#2r str`, where `'_#2r` is unconstrained, which gets\n-    // fixed up to `ReEmpty`, and which is certainly not what we want.\n-    if trait_fty.has_infer_types() {\n-        result =\n-            result.and_then(|()| ocx.eq(&cause, param_env, trait_sig.output(), impl_sig.output()));\n-    }\n+    let result = ocx.sup(&cause, param_env, trait_fty, impl_fty);\n \n     if let Err(terr) = result {\n         debug!(?terr, \"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n \n         let emitted = report_trait_method_mismatch(\n-            tcx,\n-            &mut cause,\n             &infcx,\n+            cause,\n             terr,\n             (trait_m, trait_fty),\n             (impl_m, impl_fty),\n-            &trait_sig,\n-            &impl_trait_ref,\n+            trait_sig,\n+            impl_trait_ref,\n         );\n         return Err(emitted);\n     }\n@@ -352,11 +338,15 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     let impl_trait_ref = tcx.impl_trait_ref(impl_m.impl_container(tcx).unwrap()).unwrap();\n     let param_env = tcx.param_env(def_id);\n \n+    // First, check a few of the same thing as `compare_impl_method`, just so we don't ICE during substitutions later.\n+    compare_number_of_generics(tcx, impl_m, trait_m, tcx.hir().span_if_local(impl_m.def_id), true)?;\n+    compare_generic_param_kinds(tcx, impl_m, trait_m, true)?;\n+\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n     let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n     let return_span = tcx.hir().fn_decl_by_hir_id(impl_m_hir_id).unwrap().output.span();\n-    let mut cause = ObligationCause::new(\n+    let cause = ObligationCause::new(\n         return_span,\n         impl_m_hir_id,\n         ObligationCauseCode::CompareImplItemObligation {\n@@ -376,6 +366,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     let infcx = &tcx.infer_ctxt().build();\n     let ocx = ObligationCtxt::new(infcx);\n \n+    // Normalize the impl signature with fresh variables for lifetime inference.\n     let norm_cause = ObligationCause::misc(return_span, impl_m_hir_id);\n     let impl_sig = ocx.normalize(\n         norm_cause.clone(),\n@@ -388,6 +379,10 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     );\n     let impl_return_ty = impl_sig.output();\n \n+    // Normalize the trait signature with liberated bound vars, passing it through\n+    // the ImplTraitInTraitCollector, which gathers all of the RPITITs and replaces\n+    // them with inference variables.\n+    // We will use these inference variables to collect the hidden types of RPITITs.\n     let mut collector = ImplTraitInTraitCollector::new(&ocx, return_span, param_env, impl_m_hir_id);\n     let unnormalized_trait_sig = tcx\n         .liberate_late_bound_regions(\n@@ -448,14 +443,13 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n             // emit an error now because `compare_predicate_entailment` will not report the error\n             // when normalization fails.\n             let emitted = report_trait_method_mismatch(\n-                tcx,\n-                &mut cause,\n                 infcx,\n+                cause,\n                 terr,\n                 (trait_m, trait_fty),\n                 (impl_m, impl_fty),\n-                &trait_sig,\n-                &impl_trait_ref,\n+                trait_sig,\n+                impl_trait_ref,\n             );\n             return Err(emitted);\n         }\n@@ -625,23 +619,21 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n }\n \n fn report_trait_method_mismatch<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    cause: &mut ObligationCause<'tcx>,\n     infcx: &InferCtxt<'tcx>,\n+    mut cause: ObligationCause<'tcx>,\n     terr: TypeError<'tcx>,\n-    (trait_m, trait_fty): (&AssocItem, Ty<'tcx>),\n-    (impl_m, impl_fty): (&AssocItem, Ty<'tcx>),\n-    trait_sig: &FnSig<'tcx>,\n-    impl_trait_ref: &TraitRef<'tcx>,\n+    (trait_m, trait_fty): (&ty::AssocItem, Ty<'tcx>),\n+    (impl_m, impl_fty): (&ty::AssocItem, Ty<'tcx>),\n+    trait_sig: ty::FnSig<'tcx>,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> ErrorGuaranteed {\n+    let tcx = infcx.tcx;\n     let (impl_err_span, trait_err_span) =\n         extract_spans_for_error_reporting(&infcx, terr, &cause, impl_m, trait_m);\n \n-    cause.span = impl_err_span;\n-\n     let mut diag = struct_span_err!(\n         tcx.sess,\n-        cause.span(),\n+        impl_err_span,\n         E0053,\n         \"method `{}` has an incompatible type for trait\",\n         trait_m.name\n@@ -712,6 +704,7 @@ fn report_trait_method_mismatch<'tcx>(\n         _ => {}\n     }\n \n+    cause.span = impl_err_span;\n     infcx.err_ctxt().note_type_err(\n         &mut diag,\n         &cause,\n@@ -922,9 +915,9 @@ fn compare_self_type<'tcx>(\n fn compare_number_of_generics<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_: &ty::AssocItem,\n-    _impl_span: Span,\n     trait_: &ty::AssocItem,\n     trait_span: Option<Span>,\n+    delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_own_counts = tcx.generics_of(trait_.def_id).own_counts();\n     let impl_own_counts = tcx.generics_of(impl_.def_id).own_counts();\n@@ -1054,7 +1047,7 @@ fn compare_number_of_generics<'tcx>(\n                 err.span_label(*span, \"`impl Trait` introduces an implicit type parameter\");\n             }\n \n-            let reported = err.emit();\n+            let reported = err.emit_unless(delay);\n             err_occurred = Some(reported);\n         }\n     }\n@@ -1306,6 +1299,7 @@ fn compare_generic_param_kinds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_item: &ty::AssocItem,\n     trait_item: &ty::AssocItem,\n+    delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     assert_eq!(impl_item.kind, trait_item.kind);\n \n@@ -1363,7 +1357,7 @@ fn compare_generic_param_kinds<'tcx>(\n             err.span_label(impl_header_span, \"\");\n             err.span_label(param_impl_span, make_param_message(\"found\", param_impl));\n \n-            let reported = err.emit();\n+            let reported = err.emit_unless(delay);\n             return Err(reported);\n         }\n     }\n@@ -1489,9 +1483,9 @@ pub(crate) fn compare_ty_impl<'tcx>(\n     debug!(\"compare_impl_type(impl_trait_ref={:?})\", impl_trait_ref);\n \n     let _: Result<(), ErrorGuaranteed> = (|| {\n-        compare_number_of_generics(tcx, impl_ty, impl_ty_span, trait_ty, trait_item_span)?;\n+        compare_number_of_generics(tcx, impl_ty, trait_ty, trait_item_span, false)?;\n \n-        compare_generic_param_kinds(tcx, impl_ty, trait_ty)?;\n+        compare_generic_param_kinds(tcx, impl_ty, trait_ty, false)?;\n \n         let sp = tcx.def_span(impl_ty.def_id);\n         compare_type_predicate_entailment(tcx, impl_ty, sp, trait_ty, impl_trait_ref)?;"}, {"sha": "49d7136a2f1ffd26faff815c99bfbf1467149acd", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66ccf36f161f67b121290e2af2517ead7e695d3b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ccf36f161f67b121290e2af2517ead7e695d3b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=66ccf36f161f67b121290e2af2517ead7e695d3b", "patch": "@@ -1,4 +1,3 @@\n-use crate::build::matches::ArmHasGuard;\n use crate::build::ForGuard::OutsideGuard;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use rustc_middle::middle::region::Scope;\n@@ -231,7 +230,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                         visibility_scope,\n                                         remainder_span,\n                                         pattern,\n-                                        ArmHasGuard(false),\n+                                        None,\n                                         Some((None, initializer_span)),\n                                     );\n                                     this.visit_primary_bindings(\n@@ -308,7 +307,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                             visibility_scope,\n                                             remainder_span,\n                                             pattern,\n-                                            ArmHasGuard(false),\n+                                            None,\n                                             Some((None, initializer_span)),\n                                         );\n                                         this.expr_into_pattern(block, &pattern, init)\n@@ -324,7 +323,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 visibility_scope,\n                                 remainder_span,\n                                 pattern,\n-                                ArmHasGuard(false),\n+                                None,\n                                 None,\n                             );\n                             block.unit()"}, {"sha": "33e4fa58399e2e235e3e0d8290345d99b73c7787", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ccf36f161f67b121290e2af2517ead7e695d3b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ccf36f161f67b121290e2af2517ead7e695d3b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=66ccf36f161f67b121290e2af2517ead7e695d3b", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ExprKind::Let { expr, ref pat } => {\n                 let scope = this.local_scope();\n                 let (true_block, false_block) = this.in_if_then_scope(scope, expr_span, |this| {\n-                    this.lower_let_expr(block, &this.thir[expr], pat, scope, None, expr_span)\n+                    this.lower_let_expr(block, &this.thir[expr], pat, scope, None, expr_span, true)\n                 });\n \n                 this.cfg.push_assign_constant("}, {"sha": "802704d6ca77da75ff9db4fcf1cb45969eccfdf1", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/66ccf36f161f67b121290e2af2517ead7e695d3b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ccf36f161f67b121290e2af2517ead7e695d3b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=66ccf36f161f67b121290e2af2517ead7e695d3b", "patch": "@@ -84,6 +84,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 break_scope,\n                 Some(variable_source_info.scope),\n                 variable_source_info.span,\n+                true,\n             ),\n             _ => {\n                 let temp_scope = temp_scope_override.unwrap_or_else(|| this.local_scope());\n@@ -357,7 +358,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         None,\n                         arm.span,\n                         &arm.pattern,\n-                        ArmHasGuard(arm.guard.is_some()),\n+                        arm.guard.as_ref(),\n                         opt_scrutinee_place,\n                     );\n \n@@ -645,7 +646,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         mut visibility_scope: Option<SourceScope>,\n         scope_span: Span,\n         pattern: &Pat<'tcx>,\n-        has_guard: ArmHasGuard,\n+        guard: Option<&Guard<'tcx>>,\n         opt_match_place: Option<(Option<&Place<'tcx>>, Span)>,\n     ) -> Option<SourceScope> {\n         self.visit_primary_bindings(\n@@ -667,12 +668,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     var,\n                     ty,\n                     user_ty,\n-                    has_guard,\n+                    ArmHasGuard(guard.is_some()),\n                     opt_match_place.map(|(x, y)| (x.cloned(), y)),\n                     pattern.span,\n                 );\n             },\n         );\n+        if let Some(Guard::IfLet(guard_pat, _)) = guard {\n+            // FIXME: pass a proper `opt_match_place`\n+            self.declare_bindings(visibility_scope, scope_span, guard_pat, None, None);\n+        }\n         visibility_scope\n     }\n \n@@ -1766,6 +1771,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n // Pat binding - used for `let` and function parameters as well.\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n+    /// If the bindings have already been declared, set `declare_bindings` to\n+    /// `false` to avoid duplicated bindings declaration. Used for if-let guards.\n     pub(crate) fn lower_let_expr(\n         &mut self,\n         mut block: BasicBlock,\n@@ -1774,6 +1781,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         else_target: region::Scope,\n         source_scope: Option<SourceScope>,\n         span: Span,\n+        declare_bindings: bool,\n     ) -> BlockAnd<()> {\n         let expr_span = expr.span;\n         let expr_place_builder = unpack!(block = self.lower_scrutinee(block, expr, expr_span));\n@@ -1797,13 +1805,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let otherwise_post_guard_block = otherwise_candidate.pre_binding_block.unwrap();\n         self.break_for_else(otherwise_post_guard_block, else_target, self.source_info(expr_span));\n \n-        self.declare_bindings(\n-            source_scope,\n-            pat.span.to(span),\n-            pat,\n-            ArmHasGuard(false),\n-            opt_expr_place,\n-        );\n+        if declare_bindings {\n+            self.declare_bindings(source_scope, pat.span.to(span), pat, None, opt_expr_place);\n+        }\n \n         let post_guard_block = self.bind_pattern(\n             self.source_info(pat.span),\n@@ -1984,7 +1988,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Guard::IfLet(ref pat, scrutinee) => {\n                         let s = &this.thir[scrutinee];\n                         guard_span = s.span;\n-                        this.lower_let_expr(block, s, pat, match_scope, None, arm.span)\n+                        this.lower_let_expr(block, s, pat, match_scope, None, arm.span, false)\n                     }\n                 });\n "}, {"sha": "0b76122913ebe35899cc52004e3afa55193e60b9", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ccf36f161f67b121290e2af2517ead7e695d3b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ccf36f161f67b121290e2af2517ead7e695d3b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=66ccf36f161f67b121290e2af2517ead7e695d3b", "patch": "@@ -924,7 +924,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         scope,\n                         expr.span,\n                         &pat,\n-                        matches::ArmHasGuard(false),\n+                        None,\n                         Some((Some(&place), span)),\n                     );\n                     let place_builder = PlaceBuilder::from(local);"}, {"sha": "bf2428e1731a6aa8b886094d584f0a8c8dfc6053", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66ccf36f161f67b121290e2af2517ead7e695d3b/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ccf36f161f67b121290e2af2517ead7e695d3b/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=66ccf36f161f67b121290e2af2517ead7e695d3b", "patch": "@@ -131,22 +131,17 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n \n     fn visit_fn(&mut self, fn_kind: FnKind<'a>, span: Span, _: NodeId) {\n         if let FnKind::Fn(_, _, sig, _, generics, body) = fn_kind {\n-            if let Async::Yes { closure_id, return_impl_trait_id, .. } = sig.header.asyncness {\n+            if let Async::Yes { closure_id, .. } = sig.header.asyncness {\n                 self.visit_generics(generics);\n \n-                let return_impl_trait_id =\n-                    self.create_def(return_impl_trait_id, DefPathData::ImplTrait, span);\n-\n                 // For async functions, we need to create their inner defs inside of a\n                 // closure to match their desugared representation. Besides that,\n                 // we must mirror everything that `visit::walk_fn` below does.\n                 self.visit_fn_header(&sig.header);\n                 for param in &sig.decl.inputs {\n                     self.visit_param(param);\n                 }\n-                self.with_parent(return_impl_trait_id, |this| {\n-                    this.visit_fn_ret_ty(&sig.decl.output)\n-                });\n+                self.visit_fn_ret_ty(&sig.decl.output);\n                 // If this async fn has no body (i.e. it's an async fn signature in a trait)\n                 // then the closure_def will never be used, and we should avoid generating a\n                 // def-id for it."}, {"sha": "d6e9da187e80a2f61bf2f3cbf16742610cfe580d", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ccf36f161f67b121290e2af2517ead7e695d3b/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ccf36f161f67b121290e2af2517ead7e695d3b/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=66ccf36f161f67b121290e2af2517ead7e695d3b", "patch": "@@ -1493,11 +1493,13 @@ mod prim_ref {}\n /// However, a direct cast back is not possible. You need to use `transmute`:\n ///\n /// ```rust\n+/// # #[cfg(not(miri))] { // FIXME: use strict provenance APIs once they are stable, then remove this `cfg`\n /// # let fnptr: fn(i32) -> i32 = |x| x+2;\n /// # let fnptr_addr = fnptr as usize;\n /// let fnptr = fnptr_addr as *const ();\n /// let fnptr: fn(i32) -> i32 = unsafe { std::mem::transmute(fnptr) };\n /// assert_eq!(fnptr(40), 42);\n+/// # }\n /// ```\n ///\n /// Crucially, we `as`-cast to a raw pointer before `transmute`ing to a function pointer."}, {"sha": "76603e1018d19409951e6603d8c8e12fff6ed591", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66ccf36f161f67b121290e2af2517ead7e695d3b/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ccf36f161f67b121290e2af2517ead7e695d3b/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=66ccf36f161f67b121290e2af2517ead7e695d3b", "patch": "@@ -112,11 +112,13 @@ impl<T: ?Sized> *const T {\n     ///\n     /// ```\n     /// #![feature(ptr_to_from_bits)]\n+    /// # #[cfg(not(miri))] { // doctest does not work with strict provenance\n     /// let array = [13, 42];\n     /// let p0: *const i32 = &array[0];\n     /// assert_eq!(<*const _>::from_bits(p0.to_bits()), p0);\n     /// let p1: *const i32 = &array[1];\n     /// assert_eq!(p1.to_bits() - p0.to_bits(), 4);\n+    /// # }\n     /// ```\n     #[unstable(feature = \"ptr_to_from_bits\", issue = \"91126\")]\n     #[deprecated(\n@@ -140,9 +142,11 @@ impl<T: ?Sized> *const T {\n     ///\n     /// ```\n     /// #![feature(ptr_to_from_bits)]\n+    /// # #[cfg(not(miri))] { // doctest does not work with strict provenance\n     /// use std::ptr::NonNull;\n     /// let dangling: *const u8 = NonNull::dangling().as_ptr();\n     /// assert_eq!(<*const u8>::from_bits(1), dangling);\n+    /// # }\n     /// ```\n     #[unstable(feature = \"ptr_to_from_bits\", issue = \"91126\")]\n     #[deprecated("}, {"sha": "b03cad18e4aedf81e89d19f8edd1329d0f5b4097", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66ccf36f161f67b121290e2af2517ead7e695d3b/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ccf36f161f67b121290e2af2517ead7e695d3b/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=66ccf36f161f67b121290e2af2517ead7e695d3b", "patch": "@@ -117,12 +117,14 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// ```\n     /// #![feature(ptr_to_from_bits)]\n+    /// # #[cfg(not(miri))] { // doctest does not work with strict provenance\n     /// let mut array = [13, 42];\n     /// let mut it = array.iter_mut();\n     /// let p0: *mut i32 = it.next().unwrap();\n     /// assert_eq!(<*mut _>::from_bits(p0.to_bits()), p0);\n     /// let p1: *mut i32 = it.next().unwrap();\n     /// assert_eq!(p1.to_bits() - p0.to_bits(), 4);\n+    /// }\n     /// ```\n     #[unstable(feature = \"ptr_to_from_bits\", issue = \"91126\")]\n     #[deprecated(\n@@ -146,9 +148,11 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// ```\n     /// #![feature(ptr_to_from_bits)]\n+    /// # #[cfg(not(miri))] { // doctest does not work with strict provenance\n     /// use std::ptr::NonNull;\n     /// let dangling: *mut u8 = NonNull::dangling().as_ptr();\n     /// assert_eq!(<*mut u8>::from_bits(1), dangling);\n+    /// }\n     /// ```\n     #[unstable(feature = \"ptr_to_from_bits\", issue = \"91126\")]\n     #[deprecated("}, {"sha": "d6e9da187e80a2f61bf2f3cbf16742610cfe580d", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ccf36f161f67b121290e2af2517ead7e695d3b/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ccf36f161f67b121290e2af2517ead7e695d3b/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=66ccf36f161f67b121290e2af2517ead7e695d3b", "patch": "@@ -1493,11 +1493,13 @@ mod prim_ref {}\n /// However, a direct cast back is not possible. You need to use `transmute`:\n ///\n /// ```rust\n+/// # #[cfg(not(miri))] { // FIXME: use strict provenance APIs once they are stable, then remove this `cfg`\n /// # let fnptr: fn(i32) -> i32 = |x| x+2;\n /// # let fnptr_addr = fnptr as usize;\n /// let fnptr = fnptr_addr as *const ();\n /// let fnptr: fn(i32) -> i32 = unsafe { std::mem::transmute(fnptr) };\n /// assert_eq!(fnptr(40), 42);\n+/// # }\n /// ```\n ///\n /// Crucially, we `as`-cast to a raw pointer before `transmute`ing to a function pointer."}, {"sha": "0fa11f3761ad79328b462f68537487ee99838cfb", "filename": "library/unwind/src/libunwind.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66ccf36f161f67b121290e2af2517ead7e695d3b/library%2Funwind%2Fsrc%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ccf36f161f67b121290e2af2517ead7e695d3b/library%2Funwind%2Fsrc%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flibunwind.rs?ref=66ccf36f161f67b121290e2af2517ead7e695d3b", "patch": "@@ -27,7 +27,10 @@ pub type _Unwind_Trace_Fn =\n #[cfg(target_arch = \"x86\")]\n pub const unwinder_private_data_size: usize = 5;\n \n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", not(target_os = \"windows\")))]\n+pub const unwinder_private_data_size: usize = 2;\n+\n+#[cfg(all(target_arch = \"x86_64\", target_os = \"windows\"))]\n pub const unwinder_private_data_size: usize = 6;\n \n #[cfg(all(target_arch = \"arm\", not(any(target_os = \"ios\", target_os = \"watchos\"))))]"}, {"sha": "0bbe50ea6fd37a14b94992b6a9ed6bc104544da5", "filename": "src/test/ui/impl-trait/in-trait/trait-more-generics-than-impl.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/66ccf36f161f67b121290e2af2517ead7e695d3b/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ccf36f161f67b121290e2af2517ead7e695d3b/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.rs?ref=66ccf36f161f67b121290e2af2517ead7e695d3b", "patch": "@@ -0,0 +1,17 @@\n+#![feature(return_position_impl_trait_in_trait)]\n+#![allow(incomplete_features)]\n+\n+struct S;\n+\n+trait Foo {\n+    fn bar<T>() -> impl Sized;\n+}\n+\n+impl Foo for S {\n+    fn bar() -> impl Sized {}\n+    //~^ ERROR method `bar` has 0 type parameters but its trait declaration has 1 type parameter\n+}\n+\n+fn main() {\n+    S::bar();\n+}"}, {"sha": "8ff54cad95139377497df069ac926709e01192a8", "filename": "src/test/ui/impl-trait/in-trait/trait-more-generics-than-impl.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66ccf36f161f67b121290e2af2517ead7e695d3b/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ccf36f161f67b121290e2af2517ead7e695d3b/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.stderr?ref=66ccf36f161f67b121290e2af2517ead7e695d3b", "patch": "@@ -0,0 +1,12 @@\n+error[E0049]: method `bar` has 0 type parameters but its trait declaration has 1 type parameter\n+  --> $DIR/trait-more-generics-than-impl.rs:11:11\n+   |\n+LL |     fn bar<T>() -> impl Sized;\n+   |            - expected 1 type parameter\n+...\n+LL |     fn bar() -> impl Sized {}\n+   |           ^ found 0 type parameters\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0049`."}, {"sha": "a303a0d1fcee3052a2b05133da5e70c540b9a9de", "filename": "src/test/ui/rfc-2294-if-let-guard/run-pass.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66ccf36f161f67b121290e2af2517ead7e695d3b/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Frun-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ccf36f161f67b121290e2af2517ead7e695d3b/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Frun-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Frun-pass.rs?ref=66ccf36f161f67b121290e2af2517ead7e695d3b", "patch": "@@ -30,4 +30,11 @@ fn main() {\n         Some(x) if let Foo::Qux(y) = qux(x) => assert_eq!(y, 84),\n         _ => panic!(),\n     }\n+\n+    // issue #88015\n+    #[allow(irrefutable_let_patterns)]\n+    match () {\n+        () | () if let x = 42 => assert_eq!(x, 42),\n+        _ => panic!()\n+    }\n }"}]}