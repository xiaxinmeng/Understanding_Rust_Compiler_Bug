{"sha": "0197f982b2c2d4dbf7d95fc28e0e47bce39ea944", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxOTdmOTgyYjJjMmQ0ZGJmN2Q5NWZjMjhlMGU0N2JjZTM5ZWE5NDQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-09-29T20:17:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-05T01:19:33Z"}, "message": "change how we declare bindings so that unreachable arms don't\ncause panics", "tree": {"sha": "e9e04434a46d886895ecb4e39d049924e57f15aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9e04434a46d886895ecb4e39d049924e57f15aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0197f982b2c2d4dbf7d95fc28e0e47bce39ea944", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0197f982b2c2d4dbf7d95fc28e0e47bce39ea944", "html_url": "https://github.com/rust-lang/rust/commit/0197f982b2c2d4dbf7d95fc28e0e47bce39ea944", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0197f982b2c2d4dbf7d95fc28e0e47bce39ea944/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96a3cd06796fe6a486c01ff238dd88104954433b", "url": "https://api.github.com/repos/rust-lang/rust/commits/96a3cd06796fe6a486c01ff238dd88104954433b", "html_url": "https://github.com/rust-lang/rust/commit/96a3cd06796fe6a486c01ff238dd88104954433b"}], "stats": {"total": 81, "additions": 39, "deletions": 42}, "files": [{"sha": "4d0acd5fac9244bafd0c02c49a6407260b0ea260", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0197f982b2c2d4dbf7d95fc28e0e47bce39ea944/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0197f982b2c2d4dbf7d95fc28e0e47bce39ea944/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=0197f982b2c2d4dbf7d95fc28e0e47bce39ea944", "patch": "@@ -34,6 +34,15 @@ impl<H:Hair> Builder<H> {\n         let discriminant_lvalue =\n             unpack!(block = self.as_lvalue(block, discriminant));\n \n+        // Before we do anything, create uninitialized variables with\n+        // suitable extent for all of the bindings in this match. It's\n+        // easiest to do this up front because some of these arms may\n+        // be unreachable or reachable multiple times.\n+        let var_extent = self.extent_of_innermost_scope().unwrap();\n+        for arm in &arms {\n+            self.declare_bindings(var_extent, arm.patterns[0].clone());\n+        }\n+\n         let mut arm_blocks = ArmBlocks {\n             blocks: arms.iter()\n                         .map(|_| self.cfg.start_new_block())\n@@ -52,14 +61,13 @@ impl<H:Hair> Builder<H> {\n         // reverse of the order in which candidates are written in the\n         // source.\n         let candidates: Vec<Candidate<H>> =\n-            arms.into_iter()\n+            arms.iter()\n                 .enumerate()\n                 .rev() // highest priority comes last\n                 .flat_map(|(arm_index, arm)| {\n-                    let guard = arm.guard;\n-                    arm.patterns.into_iter()\n+                    arm.patterns.iter()\n                                 .rev()\n-                                .map(move |pat| (arm_index, pat, guard.clone()))\n+                                .map(move |pat| (arm_index, pat.clone(), arm.guard.clone()))\n                 })\n                 .map(|(arm_index, pattern, guard)| {\n                     Candidate {\n@@ -73,8 +81,7 @@ impl<H:Hair> Builder<H> {\n \n         // this will generate code to test discriminant_lvalue and\n         // branch to the appropriate arm block\n-        let var_extent = self.extent_of_innermost_scope().unwrap();\n-        self.match_candidates(span, var_extent, &mut arm_blocks, candidates, block);\n+        self.match_candidates(span, &mut arm_blocks, candidates, block);\n \n         // all the arm blocks will rejoin here\n         let end_block = self.cfg.start_new_block();\n@@ -123,9 +130,12 @@ impl<H:Hair> Builder<H> {\n                                initializer: &Lvalue<H>)\n                                -> BlockAnd<()>\n     {\n+        // first, creating the bindings\n+        self.declare_bindings(var_extent, irrefutable_pat.clone());\n+\n         // create a dummy candidate\n         let mut candidate = Candidate::<H> {\n-            match_pairs: vec![self.match_pair(initializer.clone(), irrefutable_pat)],\n+            match_pairs: vec![self.match_pair(initializer.clone(), irrefutable_pat.clone())],\n             bindings: vec![],\n             guard: None,\n             arm_index: 0, // since we don't call `match_candidates`, this field is unused\n@@ -143,38 +153,38 @@ impl<H:Hair> Builder<H> {\n         }\n \n         // now apply the bindings, which will also declare the variables\n-        self.bind_matched_candidate(block, var_extent, candidate.bindings);\n+        self.bind_matched_candidate(block, candidate.bindings);\n \n         block.unit()\n     }\n \n-    pub fn declare_uninitialized_variables(&mut self,\n-                                           var_extent: H::CodeExtent,\n-                                           pattern: PatternRef<H>)\n+    pub fn declare_bindings(&mut self,\n+                            var_extent: H::CodeExtent,\n+                            pattern: PatternRef<H>)\n     {\n         let pattern = self.hir.mirror(pattern);\n         match pattern.kind {\n             PatternKind::Binding { mutability, name, mode: _, var, ty, subpattern } => {\n                 self.declare_binding(var_extent, mutability, name, var, ty, pattern.span);\n                 if let Some(subpattern) = subpattern {\n-                    self.declare_uninitialized_variables(var_extent, subpattern);\n+                    self.declare_bindings(var_extent, subpattern);\n                 }\n             }\n             PatternKind::Array { prefix, slice, suffix } |\n             PatternKind::Slice { prefix, slice, suffix } => {\n                 for subpattern in prefix.into_iter().chain(slice).chain(suffix) {\n-                    self.declare_uninitialized_variables(var_extent, subpattern);\n+                    self.declare_bindings(var_extent, subpattern);\n                 }\n             }\n             PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n             }\n             PatternKind::Deref { subpattern } => {\n-                self.declare_uninitialized_variables(var_extent, subpattern);\n+                self.declare_bindings(var_extent, subpattern);\n             }\n             PatternKind::Leaf { subpatterns } |\n             PatternKind::Variant { subpatterns, .. } => {\n                 for subpattern in subpatterns {\n-                    self.declare_uninitialized_variables(var_extent, subpattern.pattern);\n+                    self.declare_bindings(var_extent, subpattern.pattern);\n                 }\n             }\n         }\n@@ -249,13 +259,12 @@ struct Test<H:Hair> {\n impl<H:Hair> Builder<H> {\n     fn match_candidates(&mut self,\n                         span: H::Span,\n-                        var_extent: H::CodeExtent,\n                         arm_blocks: &mut ArmBlocks,\n                         mut candidates: Vec<Candidate<H>>,\n                         mut block: BasicBlock)\n     {\n-        debug!(\"matched_candidate(span={:?}, var_extent={:?}, block={:?}, candidates={:?})\",\n-               span, var_extent, block, candidates);\n+        debug!(\"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n+               span, block, candidates);\n \n         // Start by simplifying candidates. Once this process is\n         // complete, all the match pairs which remain require some\n@@ -275,8 +284,7 @@ impl<H:Hair> Builder<H> {\n             // If so, apply any bindings, test the guard (if any), and\n             // branch to the arm.\n             let candidate = candidates.pop().unwrap();\n-            if let Some(b) = self.bind_and_guard_matched_candidate(block, var_extent,\n-                                                                   arm_blocks, candidate) {\n+            if let Some(b) = self.bind_and_guard_matched_candidate(block, arm_blocks, candidate) {\n                 block = b;\n             } else {\n                 // if None is returned, then any remaining candidates\n@@ -309,7 +317,7 @@ impl<H:Hair> Builder<H> {\n                                                                       candidate))\n                           })\n                           .collect();\n-            self.match_candidates(span, var_extent, arm_blocks, applicable_candidates, target_block);\n+            self.match_candidates(span, arm_blocks, applicable_candidates, target_block);\n         }\n     }\n \n@@ -327,16 +335,15 @@ impl<H:Hair> Builder<H> {\n     /// MIR).\n     fn bind_and_guard_matched_candidate(&mut self,\n                                         mut block: BasicBlock,\n-                                        var_extent: H::CodeExtent,\n                                         arm_blocks: &mut ArmBlocks,\n                                         candidate: Candidate<H>)\n                                         -> Option<BasicBlock> {\n-        debug!(\"bind_and_guard_matched_candidate(block={:?}, var_extent={:?}, candidate={:?})\",\n-               block, var_extent, candidate);\n+        debug!(\"bind_and_guard_matched_candidate(block={:?}, candidate={:?})\",\n+               block, candidate);\n \n         debug_assert!(candidate.match_pairs.is_empty());\n \n-        self.bind_matched_candidate(block, var_extent, candidate.bindings);\n+        self.bind_matched_candidate(block, candidate.bindings);\n \n         let arm_block = arm_blocks.blocks[candidate.arm_index];\n \n@@ -356,26 +363,16 @@ impl<H:Hair> Builder<H> {\n \n     fn bind_matched_candidate(&mut self,\n                               block: BasicBlock,\n-                              var_extent: H::CodeExtent,\n                               bindings: Vec<Binding<H>>) {\n-        debug!(\"bind_matched_candidate(block={:?}, var_extent={:?}, bindings={:?})\",\n-               block, var_extent, bindings);\n+        debug!(\"bind_matched_candidate(block={:?}, bindings={:?})\",\n+               block, bindings);\n \n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n-            // Create a variable for the `var_id` being bound. In the\n-            // case where there are multiple patterns for a single\n-            // arm, it may already exist.\n-            let var_index = if !self.var_indices.contains_key(&binding.var_id) {\n-                self.declare_binding(var_extent,\n-                                     binding.mutability,\n-                                     binding.name,\n-                                     binding.var_id,\n-                                     binding.var_ty,\n-                                     binding.span)\n-            } else {\n-                self.var_indices[&binding.var_id]\n-            };\n+            // Find the variable for the `var_id` being bound. It\n+            // should have been created by a previous call to\n+            // `declare_bindings`.\n+            let var_index = self.var_indices[&binding.var_id];\n \n             let rvalue = match binding.binding_mode {\n                 BindingMode::ByValue =>"}, {"sha": "3dd4f5f253c0ad549b835cc82715206f4541cc2f", "filename": "src/librustc_mir/build/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0197f982b2c2d4dbf7d95fc28e0e47bce39ea944/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0197f982b2c2d4dbf7d95fc28e0e47bce39ea944/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs?ref=0197f982b2c2d4dbf7d95fc28e0e47bce39ea944", "patch": "@@ -40,7 +40,7 @@ impl<H:Hair> Builder<H> {\n             StmtKind::Let { remainder_scope, init_scope, pattern, initializer: None, stmts } => {\n                 this.in_scope(remainder_scope, block, |this| {\n                     unpack!(block = this.in_scope(init_scope, block, |this| {\n-                        this.declare_uninitialized_variables(remainder_scope, pattern);\n+                        this.declare_bindings(remainder_scope, pattern);\n                         block.unit()\n                     }));\n                     this.stmts(block, stmts)"}]}