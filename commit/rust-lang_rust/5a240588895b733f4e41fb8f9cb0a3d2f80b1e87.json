{"sha": "5a240588895b733f4e41fb8f9cb0a3d2f80b1e87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMjQwNTg4ODk1YjczM2Y0ZTQxZmI4ZjljYjBhM2QyZjgwYjFlODc=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-27T21:44:57Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-07T04:53:01Z"}, "message": "libcollections: remove unnecessary `as_mut_slice()` calls", "tree": {"sha": "b1bc74ebe26001d129211dc2982888fd14b4aaf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1bc74ebe26001d129211dc2982888fd14b4aaf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a240588895b733f4e41fb8f9cb0a3d2f80b1e87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a240588895b733f4e41fb8f9cb0a3d2f80b1e87", "html_url": "https://github.com/rust-lang/rust/commit/5a240588895b733f4e41fb8f9cb0a3d2f80b1e87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a240588895b733f4e41fb8f9cb0a3d2f80b1e87/comments", "author": null, "committer": null, "parents": [{"sha": "a0621f8eba169780c592916eeaf2855c69541f4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0621f8eba169780c592916eeaf2855c69541f4b", "html_url": "https://github.com/rust-lang/rust/commit/a0621f8eba169780c592916eeaf2855c69541f4b"}], "stats": {"total": 64, "additions": 32, "deletions": 32}, "files": [{"sha": "e321ef16f66b5b623424d41a5395ff9cc8e19c87", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a240588895b733f4e41fb8f9cb0a3d2f80b1e87/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a240588895b733f4e41fb8f9cb0a3d2f80b1e87/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=5a240588895b733f4e41fb8f9cb0a3d2f80b1e87", "patch": "@@ -485,7 +485,7 @@ impl<T: Ord> BinaryHeap<T> {\n         let mut end = q.len();\n         while end > 1 {\n             end -= 1;\n-            q.data.as_mut_slice().swap(0, end);\n+            q.data.swap(0, end);\n             q.siftdown_range(0, end)\n         }\n         q.into_vec()"}, {"sha": "3f53bad6518f22e40b581b909833374860a65174", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a240588895b733f4e41fb8f9cb0a3d2f80b1e87/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a240588895b733f4e41fb8f9cb0a3d2f80b1e87/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=5a240588895b733f4e41fb8f9cb0a3d2f80b1e87", "patch": "@@ -158,13 +158,13 @@ impl <K, V> Node<K, V> {\n     /// Swap the given key-value pair with the key-value pair stored in the node's index,\n     /// without checking bounds.\n     pub unsafe fn unsafe_swap(&mut self, index: uint, key: &mut K, val: &mut V) {\n-        mem::swap(self.keys.as_mut_slice().unsafe_mut(index), key);\n-        mem::swap(self.vals.as_mut_slice().unsafe_mut(index), val);\n+        mem::swap(self.keys.unsafe_mut(index), key);\n+        mem::swap(self.vals.unsafe_mut(index), val);\n     }\n \n     /// Get the node's key mutably without any bounds checks.\n     pub unsafe fn unsafe_key_mut(&mut self, index: uint) -> &mut K {\n-        self.keys.as_mut_slice().unsafe_mut(index)\n+        self.keys.unsafe_mut(index)\n     }\n \n     /// Get the node's value at the given index\n@@ -189,12 +189,12 @@ impl <K, V> Node<K, V> {\n \n     /// Get the node's edge mutably at the given index\n     pub fn edge_mut(&mut self, index: uint) -> Option<&mut Node<K,V>> {\n-        self.edges.as_mut_slice().get_mut(index)\n+        self.edges.get_mut(index)\n     }\n \n     /// Get the node's edge mutably without any bounds checks.\n     pub unsafe fn unsafe_edge_mut(&mut self, index: uint) -> &mut Node<K,V> {\n-        self.edges.as_mut_slice().unsafe_mut(index)\n+        self.edges.unsafe_mut(index)\n     }\n \n     /// Pop an edge off the end of the node\n@@ -292,8 +292,8 @@ impl <K, V> Node<K, V> {\n     pub fn iter_mut<'a>(&'a mut self) -> MutTraversal<'a, K, V> {\n         let is_leaf = self.is_leaf();\n         MutTraversal {\n-            elems: self.keys.iter().zip(self.vals.as_mut_slice().iter_mut()),\n-            edges: self.edges.as_mut_slice().iter_mut(),\n+            elems: self.keys.iter().zip(self.vals.iter_mut()),\n+            edges: self.edges.iter_mut(),\n             head_is_edge: true,\n             tail_is_edge: true,\n             has_edges: !is_leaf,\n@@ -478,7 +478,7 @@ fn split<T>(left: &mut Vec<T>) -> Vec<T> {\n     let mut right = Vec::with_capacity(left.capacity());\n     unsafe {\n         let left_ptr = left.unsafe_get(left_len) as *const _;\n-        let right_ptr = right.as_mut_slice().as_mut_ptr();\n+        let right_ptr = right.as_mut_ptr();\n         ptr::copy_nonoverlapping_memory(right_ptr, left_ptr, right_len);\n         left.set_len(left_len);\n         right.set_len(right_len);"}, {"sha": "9417cc3e5947910bc4dfd0417c850633bde42ea1", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5a240588895b733f4e41fb8f9cb0a3d2f80b1e87/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a240588895b733f4e41fb8f9cb0a3d2f80b1e87/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=5a240588895b733f4e41fb8f9cb0a3d2f80b1e87", "patch": "@@ -201,7 +201,7 @@ impl Iterator<(uint, uint)> for ElementSwaps {\n         match max {\n             Some((i, sd)) => {\n                 let j = new_pos(i, sd.dir);\n-                self.sdir.as_mut_slice().swap(i, j);\n+                self.sdir.swap(i, j);\n \n                 // Swap the direction of each larger SizeDirection\n                 for x in self.sdir.iter_mut() {\n@@ -256,7 +256,7 @@ impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n             Some((0,0)) => Some(self.v.clone()),\n             Some((a, b)) => {\n                 let elt = self.v.clone();\n-                self.v.as_mut_slice().swap(a, b);\n+                self.v.swap(a, b);\n                 Some(elt)\n             }\n         }\n@@ -779,11 +779,11 @@ mod tests {\n     #[test]\n     fn test_head_mut() {\n         let mut a = vec![];\n-        assert_eq!(a.as_mut_slice().head_mut(), None);\n+        assert_eq!(a.head_mut(), None);\n         a = vec![11i];\n-        assert_eq!(*a.as_mut_slice().head_mut().unwrap(), 11);\n+        assert_eq!(*a.head_mut().unwrap(), 11);\n         a = vec![11i, 12];\n-        assert_eq!(*a.as_mut_slice().head_mut().unwrap(), 11);\n+        assert_eq!(*a.head_mut().unwrap(), 11);\n     }\n \n     #[test]\n@@ -800,10 +800,10 @@ mod tests {\n     fn test_tail_mut() {\n         let mut a = vec![11i];\n         let b: &mut [int] = &mut [];\n-        assert!(a.as_mut_slice().tail_mut() == b);\n+        assert!(a.tail_mut() == b);\n         a = vec![11i, 12];\n         let b: &mut [int] = &mut [12];\n-        assert!(a.as_mut_slice().tail_mut() == b);\n+        assert!(a.tail_mut() == b);\n     }\n \n     #[test]\n@@ -817,7 +817,7 @@ mod tests {\n     #[should_fail]\n     fn test_tail_mut_empty() {\n         let mut a: Vec<int> = vec![];\n-        a.as_mut_slice().tail_mut();\n+        a.tail_mut();\n     }\n \n     #[test]\n@@ -834,10 +834,10 @@ mod tests {\n     fn test_init_mut() {\n         let mut a = vec![11i];\n         let b: &mut [int] = &mut [];\n-        assert!(a.as_mut_slice().init_mut() == b);\n+        assert!(a.init_mut() == b);\n         a = vec![11i, 12];\n         let b: &mut [int] = &mut [11];\n-        assert!(a.as_mut_slice().init_mut() == b);\n+        assert!(a.init_mut() == b);\n     }\n \n     #[test]\n@@ -851,7 +851,7 @@ mod tests {\n     #[should_fail]\n     fn test_init_mut_empty() {\n         let mut a: Vec<int> = vec![];\n-        a.as_mut_slice().init_mut();\n+        a.init_mut();\n     }\n \n     #[test]\n@@ -867,11 +867,11 @@ mod tests {\n     #[test]\n     fn test_last_mut() {\n         let mut a = vec![];\n-        assert_eq!(a.as_mut_slice().last_mut(), None);\n+        assert_eq!(a.last_mut(), None);\n         a = vec![11i];\n-        assert_eq!(*a.as_mut_slice().last_mut().unwrap(), 11);\n+        assert_eq!(*a.last_mut().unwrap(), 11);\n         a = vec![11i, 12];\n-        assert_eq!(*a.as_mut_slice().last_mut().unwrap(), 12);\n+        assert_eq!(*a.last_mut().unwrap(), 12);\n     }\n \n     #[test]\n@@ -1299,13 +1299,13 @@ mod tests {\n                                       .collect::<Vec<uint>>();\n                 let mut v1 = v.clone();\n \n-                v.as_mut_slice().sort();\n+                v.sort();\n                 assert!(v.as_slice().windows(2).all(|w| w[0] <= w[1]));\n \n-                v1.as_mut_slice().sort_by(|a, b| a.cmp(b));\n+                v1.sort_by(|a, b| a.cmp(b));\n                 assert!(v1.as_slice().windows(2).all(|w| w[0] <= w[1]));\n \n-                v1.as_mut_slice().sort_by(|a, b| b.cmp(a));\n+                v1.sort_by(|a, b| b.cmp(a));\n                 assert!(v1.as_slice().windows(2).all(|w| w[0] >= w[1]));\n             }\n         }"}, {"sha": "c77ef86697ba43f3409a832d78e1cb590bd42b18", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a240588895b733f4e41fb8f9cb0a3d2f80b1e87/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a240588895b733f4e41fb8f9cb0a3d2f80b1e87/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=5a240588895b733f4e41fb8f9cb0a3d2f80b1e87", "patch": "@@ -211,7 +211,7 @@ impl<T> Vec<T> {\n             let mut xs = Vec::with_capacity(length);\n             while xs.len < length {\n                 let len = xs.len;\n-                ptr::write(xs.as_mut_slice().unsafe_mut(len), op(len));\n+                ptr::write(xs.unsafe_mut(len), op(len));\n                 xs.len += 1;\n             }\n             xs\n@@ -328,7 +328,7 @@ impl<T: Clone> Vec<T> {\n             let mut xs = Vec::with_capacity(length);\n             while xs.len < length {\n                 let len = xs.len;\n-                ptr::write(xs.as_mut_slice().unsafe_mut(len),\n+                ptr::write(xs.unsafe_mut(len),\n                            value.clone());\n                 xs.len += 1;\n             }\n@@ -361,7 +361,7 @@ impl<T: Clone> Vec<T> {\n             // during the loop can prevent this optimisation.\n             unsafe {\n                 ptr::write(\n-                    self.as_mut_slice().unsafe_mut(len),\n+                    self.unsafe_mut(len),\n                     other.unsafe_get(i).clone());\n                 self.set_len(len + 1);\n             }\n@@ -896,7 +896,7 @@ impl<T> Vec<T> {\n     pub fn swap_remove(&mut self, index: uint) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length - 1 {\n-            self.as_mut_slice().swap(index, length - 1);\n+            self.swap(index, length - 1);\n         } else if index >= length {\n             return None\n         }\n@@ -1231,7 +1231,7 @@ impl<T: PartialEq> Vec<T> {\n             if ln < 1 { return; }\n \n             // Avoid bounds checks by using unsafe pointers.\n-            let p = self.as_mut_slice().as_mut_ptr();\n+            let p = self.as_mut_ptr();\n             let mut r = 1;\n             let mut w = 1;\n \n@@ -1293,7 +1293,7 @@ impl<T> Drop for Vec<T> {\n         // zeroed (when moving out, because of #[unsafe_no_drop_flag]).\n         if self.cap != 0 {\n             unsafe {\n-                for x in self.as_mut_slice().iter() {\n+                for x in self.iter() {\n                     ptr::read(x);\n                 }\n                 dealloc(self.ptr, self.cap)"}]}