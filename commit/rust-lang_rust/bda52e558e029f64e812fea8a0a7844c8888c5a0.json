{"sha": "bda52e558e029f64e812fea8a0a7844c8888c5a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkYTUyZTU1OGUwMjlmNjRlODEyZmVhOGEwYTc4NDRjODg4OGM1YTA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-19T16:31:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-19T16:31:37Z"}, "message": "Rollup merge of #63448 - RalfJung:miri-discriminant, r=eddyb\n\nfix Miri discriminant handling\n\nThis can be reviewed commit-by-commit fairly well.\n\nThe Miri side is at https://github.com/rust-lang/miri/pull/903.\n\nFixes https://github.com/rust-lang/rust/issues/62138\n\nr? @eddyb @oli-obk", "tree": {"sha": "61a255d88f3fcbb6c648b7ab2e59bcaffca531fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61a255d88f3fcbb6c648b7ab2e59bcaffca531fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bda52e558e029f64e812fea8a0a7844c8888c5a0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdg61qCRBK7hj4Ov3rIwAAdHIIAJqUcdDBjMKN50PMg+AiKqjP\nhHu6AFhsvjipPHR6j4egiqCFsTfsLbTlYA4ml/Ji3TuJdXHkO0bN8j7H9AYY+rF0\n1/sL162KhgqelrEtyp4xVEIo8x1VtKra4i3nZ24K+XN137nwyW/k8Z0NiFCNoU/n\no2+uHn4nt9lNRja0czBq3LhsK1Sl9Onbq2iSM8HvmJOW5VOcb2hIJGNXZSEzucrB\ntmVowwRhnHdYvXTTiaWbQTMPCX+KnRx5XO9ash9D6QEe/4VMZGOPH8VUcvTYBsd9\ng9bLW1mEKRkEArWTU48WCXsoN4FICWnjaOYCHhxi9IBfVtP7oL6TgZwxaq4+Kq4=\n=ja9K\n-----END PGP SIGNATURE-----\n", "payload": "tree 61a255d88f3fcbb6c648b7ab2e59bcaffca531fd\nparent 9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7\nparent 1de533ac1a3bddd6bf61791f4ee6cf52cb186fdf\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1568910697 +0200\ncommitter GitHub <noreply@github.com> 1568910697 +0200\n\nRollup merge of #63448 - RalfJung:miri-discriminant, r=eddyb\n\nfix Miri discriminant handling\n\nThis can be reviewed commit-by-commit fairly well.\n\nThe Miri side is at https://github.com/rust-lang/miri/pull/903.\n\nFixes https://github.com/rust-lang/rust/issues/62138\n\nr? @eddyb @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bda52e558e029f64e812fea8a0a7844c8888c5a0", "html_url": "https://github.com/rust-lang/rust/commit/bda52e558e029f64e812fea8a0a7844c8888c5a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bda52e558e029f64e812fea8a0a7844c8888c5a0/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7", "html_url": "https://github.com/rust-lang/rust/commit/9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7"}, {"sha": "1de533ac1a3bddd6bf61791f4ee6cf52cb186fdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/1de533ac1a3bddd6bf61791f4ee6cf52cb186fdf", "html_url": "https://github.com/rust-lang/rust/commit/1de533ac1a3bddd6bf61791f4ee6cf52cb186fdf"}], "stats": {"total": 280, "additions": 253, "deletions": 27}, "files": [{"sha": "e52feea1624c11e3b5f1912f8a199e0105483ccc", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bda52e558e029f64e812fea8a0a7844c8888c5a0/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bda52e558e029f64e812fea8a0a7844c8888c5a0/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=bda52e558e029f64e812fea8a0a7844c8888c5a0", "patch": "@@ -127,6 +127,7 @@ impl IntegerExt for Integer {\n \n pub trait PrimitiveExt {\n     fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx>;\n+    fn to_int_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx>;\n }\n \n impl PrimitiveExt for Primitive {\n@@ -138,6 +139,16 @@ impl PrimitiveExt for Primitive {\n             Pointer => tcx.mk_mut_ptr(tcx.mk_unit()),\n         }\n     }\n+\n+    /// Return an *integer* type matching this primitive.\n+    /// Useful in particular when dealing with enum discriminants.\n+    fn to_int_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            Int(i, signed) => i.to_ty(tcx, signed),\n+            Pointer => tcx.types.usize,\n+            Float(..) => bug!(\"floats do not have an int type\"),\n+        }\n+    }\n }\n \n /// The first half of a fat pointer."}, {"sha": "dd214c4a031f7f9b2ff52f13e65e51669d0dc8b8", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bda52e558e029f64e812fea8a0a7844c8888c5a0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bda52e558e029f64e812fea8a0a7844c8888c5a0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=bda52e558e029f64e812fea8a0a7844c8888c5a0", "patch": "@@ -1,11 +1,11 @@\n //! Functions concerning immediate values and operands, and reading from operands.\n //! All high-level functions to read from memory work on operands as sources.\n \n-use std::convert::TryInto;\n+use std::convert::{TryInto, TryFrom};\n \n use rustc::{mir, ty};\n use rustc::ty::layout::{\n-    self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt, VariantIdx,\n+    self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt, PrimitiveExt, VariantIdx,\n };\n \n use rustc::mir::interpret::{\n@@ -609,15 +609,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, (u128, VariantIdx)> {\n         trace!(\"read_discriminant_value {:#?}\", rval.layout);\n \n-        let (discr_kind, discr_index) = match rval.layout.variants {\n+        let (discr_layout, discr_kind, discr_index) = match rval.layout.variants {\n             layout::Variants::Single { index } => {\n                 let discr_val = rval.layout.ty.discriminant_for_variant(*self.tcx, index).map_or(\n                     index.as_u32() as u128,\n                     |discr| discr.val);\n                 return Ok((discr_val, index));\n             }\n-            layout::Variants::Multiple { ref discr_kind, discr_index, .. } =>\n-                (discr_kind, discr_index),\n+            layout::Variants::Multiple {\n+                discr: ref discr_layout,\n+                ref discr_kind,\n+                discr_index,\n+                ..\n+            } =>\n+                (discr_layout, discr_kind, discr_index),\n         };\n \n         // read raw discriminant value\n@@ -634,7 +639,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     .map_err(|_| err_unsup!(InvalidDiscriminant(raw_discr.erase_tag())))?;\n                 let real_discr = if discr_val.layout.ty.is_signed() {\n                     // going from layout tag type to typeck discriminant type\n-                    // requires first sign extending with the layout discriminant\n+                    // requires first sign extending with the discriminant layout\n                     let sexted = sign_extend(bits_discr, discr_val.layout.size) as i128;\n                     // and then zeroing with the typeck discriminant type\n                     let discr_ty = rval.layout.ty\n@@ -666,8 +671,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 ref niche_variants,\n                 niche_start,\n             } => {\n-                let variants_start = niche_variants.start().as_u32() as u128;\n-                let variants_end = niche_variants.end().as_u32() as u128;\n+                let variants_start = niche_variants.start().as_u32();\n+                let variants_end = niche_variants.end().as_u32();\n                 let raw_discr = raw_discr.not_undef().map_err(|_| {\n                     err_unsup!(InvalidDiscriminant(ScalarMaybeUndef::Undef))\n                 })?;\n@@ -682,18 +687,34 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         (dataful_variant.as_u32() as u128, dataful_variant)\n                     },\n                     Ok(raw_discr) => {\n-                        let adjusted_discr = raw_discr.wrapping_sub(niche_start)\n-                            .wrapping_add(variants_start);\n-                        if variants_start <= adjusted_discr && adjusted_discr <= variants_end {\n-                            let index = adjusted_discr as usize;\n-                            assert_eq!(index as u128, adjusted_discr);\n-                            assert!(index < rval.layout.ty\n+                        // We need to use machine arithmetic to get the relative variant idx:\n+                        // variant_index_relative = discr_val - niche_start_val\n+                        let discr_layout = self.layout_of(discr_layout.value.to_int_ty(*self.tcx))?;\n+                        let discr_val = ImmTy::from_uint(raw_discr, discr_layout);\n+                        let niche_start_val = ImmTy::from_uint(niche_start, discr_layout);\n+                        let variant_index_relative_val = self.binary_op(\n+                            mir::BinOp::Sub,\n+                            discr_val,\n+                            niche_start_val,\n+                        )?;\n+                        let variant_index_relative = variant_index_relative_val\n+                            .to_scalar()?\n+                            .assert_bits(discr_val.layout.size);\n+                        // Check if this is in the range that indicates an actual discriminant.\n+                        if variant_index_relative <= u128::from(variants_end - variants_start) {\n+                            let variant_index_relative = u32::try_from(variant_index_relative)\n+                                .expect(\"we checked that this fits into a u32\");\n+                            // Then computing the absolute variant idx should not overflow any more.\n+                            let variant_index = variants_start\n+                                .checked_add(variant_index_relative)\n+                                .expect(\"oveflow computing absolute variant idx\");\n+                            assert!((variant_index as usize) < rval.layout.ty\n                                 .ty_adt_def()\n                                 .expect(\"tagged layout for non adt\")\n                                 .variants.len());\n-                            (adjusted_discr, VariantIdx::from_usize(index))\n+                            (u128::from(variant_index), VariantIdx::from_u32(variant_index))\n                         } else {\n-                            (dataful_variant.as_u32() as u128, dataful_variant)\n+                            (u128::from(dataful_variant.as_u32()), dataful_variant)\n                         }\n                     },\n                 }"}, {"sha": "c3660fb7a2e28ffe07758838cbd994fb904ece10", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bda52e558e029f64e812fea8a0a7844c8888c5a0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bda52e558e029f64e812fea8a0a7844c8888c5a0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=bda52e558e029f64e812fea8a0a7844c8888c5a0", "patch": "@@ -8,7 +8,9 @@ use std::hash::Hash;\n use rustc::mir;\n use rustc::mir::interpret::truncate;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx};\n+use rustc::ty::layout::{\n+    self, Size, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx, PrimitiveExt\n+};\n use rustc::ty::TypeFoldable;\n \n use super::{\n@@ -1027,7 +1029,7 @@ where\n             }\n             layout::Variants::Multiple {\n                 discr_kind: layout::DiscriminantKind::Tag,\n-                ref discr,\n+                discr: ref discr_layout,\n                 discr_index,\n                 ..\n             } => {\n@@ -1038,7 +1040,7 @@ where\n                 // raw discriminants for enums are isize or bigger during\n                 // their computation, but the in-memory tag is the smallest possible\n                 // representation\n-                let size = discr.value.size(self);\n+                let size = discr_layout.value.size(self);\n                 let discr_val = truncate(discr_val, size);\n \n                 let discr_dest = self.place_field(dest, discr_index as u64)?;\n@@ -1050,22 +1052,32 @@ where\n                     ref niche_variants,\n                     niche_start,\n                 },\n+                discr: ref discr_layout,\n                 discr_index,\n                 ..\n             } => {\n                 assert!(\n                     variant_index.as_usize() < dest.layout.ty.ty_adt_def().unwrap().variants.len(),\n                 );\n                 if variant_index != dataful_variant {\n-                    let niche_dest =\n-                        self.place_field(dest, discr_index as u64)?;\n-                    let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n-                    let niche_value = (niche_value as u128)\n-                        .wrapping_add(niche_start);\n-                    self.write_scalar(\n-                        Scalar::from_uint(niche_value, niche_dest.layout.size),\n-                        niche_dest\n+                    let variants_start = niche_variants.start().as_u32();\n+                    let variant_index_relative = variant_index.as_u32()\n+                        .checked_sub(variants_start)\n+                        .expect(\"overflow computing relative variant idx\");\n+                    // We need to use machine arithmetic when taking into account `niche_start`:\n+                    // discr_val = variant_index_relative + niche_start_val\n+                    let discr_layout = self.layout_of(discr_layout.value.to_int_ty(*self.tcx))?;\n+                    let niche_start_val = ImmTy::from_uint(niche_start, discr_layout);\n+                    let variant_index_relative_val =\n+                        ImmTy::from_uint(variant_index_relative, discr_layout);\n+                    let discr_val = self.binary_op(\n+                        mir::BinOp::Add,\n+                        variant_index_relative_val,\n+                        niche_start_val,\n                     )?;\n+                    // Write result.\n+                    let niche_dest = self.place_field(dest, discr_index as u64)?;\n+                    self.write_immediate(*discr_val, niche_dest)?;\n                 }\n             }\n         }"}, {"sha": "9f34fc73953a4bc93fae58930c0e91dc22056d97", "filename": "src/test/ui/consts/miri_unleashed/enum_discriminants.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/bda52e558e029f64e812fea8a0a7844c8888c5a0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fenum_discriminants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bda52e558e029f64e812fea8a0a7844c8888c5a0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fenum_discriminants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fenum_discriminants.rs?ref=bda52e558e029f64e812fea8a0a7844c8888c5a0", "patch": "@@ -0,0 +1,110 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+// run-pass\n+\n+//! Make sure that we read and write enum discriminants correctly for corner cases caused\n+//! by layout optimizations.\n+\n+const OVERFLOW: usize = {\n+    // Tests for https://github.com/rust-lang/rust/issues/62138.\n+    #[repr(u8)]\n+    #[allow(dead_code)]\n+    enum WithWraparoundInvalidValues {\n+        X = 1,\n+        Y = 254,\n+    }\n+\n+    #[allow(dead_code)]\n+    enum Foo {\n+        A,\n+        B,\n+        C(WithWraparoundInvalidValues),\n+    }\n+\n+    let x = Foo::B;\n+    match x {\n+        Foo::B => 0,\n+        _ => panic!(),\n+    }\n+};\n+\n+const MORE_OVERFLOW: usize = {\n+    pub enum Infallible {}\n+\n+    // The check that the `bool` field of `V1` is encoding a \"niche variant\"\n+    // (i.e. not `V1`, so `V3` or `V4`) used to be mathematically incorrect,\n+    // causing valid `V1` values to be interpreted as other variants.\n+    #[allow(dead_code)]\n+    pub enum E1 {\n+        V1 { f: bool },\n+        V2 { f: Infallible },\n+        V3,\n+        V4,\n+    }\n+\n+    // Computing the discriminant used to be done using the niche type (here `u8`,\n+    // from the `bool` field of `V1`), overflowing for variants with large enough\n+    // indices (`V3` and `V4`), causing them to be interpreted as other variants.\n+    #[allow(dead_code)]\n+    pub enum E2<X> {\n+        V1 { f: bool },\n+\n+        /*_00*/ _01(X), _02(X), _03(X), _04(X), _05(X), _06(X), _07(X),\n+        _08(X), _09(X), _0A(X), _0B(X), _0C(X), _0D(X), _0E(X), _0F(X),\n+        _10(X), _11(X), _12(X), _13(X), _14(X), _15(X), _16(X), _17(X),\n+        _18(X), _19(X), _1A(X), _1B(X), _1C(X), _1D(X), _1E(X), _1F(X),\n+        _20(X), _21(X), _22(X), _23(X), _24(X), _25(X), _26(X), _27(X),\n+        _28(X), _29(X), _2A(X), _2B(X), _2C(X), _2D(X), _2E(X), _2F(X),\n+        _30(X), _31(X), _32(X), _33(X), _34(X), _35(X), _36(X), _37(X),\n+        _38(X), _39(X), _3A(X), _3B(X), _3C(X), _3D(X), _3E(X), _3F(X),\n+        _40(X), _41(X), _42(X), _43(X), _44(X), _45(X), _46(X), _47(X),\n+        _48(X), _49(X), _4A(X), _4B(X), _4C(X), _4D(X), _4E(X), _4F(X),\n+        _50(X), _51(X), _52(X), _53(X), _54(X), _55(X), _56(X), _57(X),\n+        _58(X), _59(X), _5A(X), _5B(X), _5C(X), _5D(X), _5E(X), _5F(X),\n+        _60(X), _61(X), _62(X), _63(X), _64(X), _65(X), _66(X), _67(X),\n+        _68(X), _69(X), _6A(X), _6B(X), _6C(X), _6D(X), _6E(X), _6F(X),\n+        _70(X), _71(X), _72(X), _73(X), _74(X), _75(X), _76(X), _77(X),\n+        _78(X), _79(X), _7A(X), _7B(X), _7C(X), _7D(X), _7E(X), _7F(X),\n+        _80(X), _81(X), _82(X), _83(X), _84(X), _85(X), _86(X), _87(X),\n+        _88(X), _89(X), _8A(X), _8B(X), _8C(X), _8D(X), _8E(X), _8F(X),\n+        _90(X), _91(X), _92(X), _93(X), _94(X), _95(X), _96(X), _97(X),\n+        _98(X), _99(X), _9A(X), _9B(X), _9C(X), _9D(X), _9E(X), _9F(X),\n+        _A0(X), _A1(X), _A2(X), _A3(X), _A4(X), _A5(X), _A6(X), _A7(X),\n+        _A8(X), _A9(X), _AA(X), _AB(X), _AC(X), _AD(X), _AE(X), _AF(X),\n+        _B0(X), _B1(X), _B2(X), _B3(X), _B4(X), _B5(X), _B6(X), _B7(X),\n+        _B8(X), _B9(X), _BA(X), _BB(X), _BC(X), _BD(X), _BE(X), _BF(X),\n+        _C0(X), _C1(X), _C2(X), _C3(X), _C4(X), _C5(X), _C6(X), _C7(X),\n+        _C8(X), _C9(X), _CA(X), _CB(X), _CC(X), _CD(X), _CE(X), _CF(X),\n+        _D0(X), _D1(X), _D2(X), _D3(X), _D4(X), _D5(X), _D6(X), _D7(X),\n+        _D8(X), _D9(X), _DA(X), _DB(X), _DC(X), _DD(X), _DE(X), _DF(X),\n+        _E0(X), _E1(X), _E2(X), _E3(X), _E4(X), _E5(X), _E6(X), _E7(X),\n+        _E8(X), _E9(X), _EA(X), _EB(X), _EC(X), _ED(X), _EE(X), _EF(X),\n+        _F0(X), _F1(X), _F2(X), _F3(X), _F4(X), _F5(X), _F6(X), _F7(X),\n+        _F8(X), _F9(X), _FA(X), _FB(X), _FC(X), _FD(X), _FE(X), _FF(X),\n+\n+        V3,\n+        V4,\n+    }\n+\n+    if let E1::V2 { .. } = (E1::V1 { f: true }) {\n+        unreachable!()\n+    }\n+    if let E1::V1 { .. } = (E1::V1 { f: true }) {\n+    } else {\n+        unreachable!()\n+    }\n+\n+    if let E2::V1 { .. } = E2::V3::<Infallible> {\n+        unreachable!()\n+    }\n+    if let E2::V3 { .. } = E2::V3::<Infallible> {\n+    } else {\n+        unreachable!()\n+    }\n+\n+    0\n+};\n+\n+fn main() {\n+    assert_eq!(OVERFLOW, 0);\n+    assert_eq!(MORE_OVERFLOW, 0);\n+}"}, {"sha": "8ca81ad22b72b9f82c11258e97b133a8788c01f5", "filename": "src/test/ui/consts/miri_unleashed/enum_discriminants.stderr", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bda52e558e029f64e812fea8a0a7844c8888c5a0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fenum_discriminants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bda52e558e029f64e812fea8a0a7844c8888c5a0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fenum_discriminants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fenum_discriminants.stderr?ref=bda52e558e029f64e812fea8a0a7844c8888c5a0", "patch": "@@ -0,0 +1,72 @@\n+warning: skipping const checks\n+  --> $DIR/enum_discriminants.rs:23:13\n+   |\n+LL |     let x = Foo::B;\n+   |             ^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/enum_discriminants.rs:25:9\n+   |\n+LL |         Foo::B => 0,\n+   |         ^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/enum_discriminants.rs:88:28\n+   |\n+LL |     if let E1::V2 { .. } = (E1::V1 { f: true }) {\n+   |                            ^^^^^^^^^^^^^^^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/enum_discriminants.rs:88:12\n+   |\n+LL |     if let E1::V2 { .. } = (E1::V1 { f: true }) {\n+   |            ^^^^^^^^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/enum_discriminants.rs:108:5\n+   |\n+LL |     assert_eq!(OVERFLOW, 0);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+warning: skipping const checks\n+  --> $DIR/enum_discriminants.rs:108:5\n+   |\n+LL |     assert_eq!(OVERFLOW, 0);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+warning: skipping const checks\n+  --> $DIR/enum_discriminants.rs:108:5\n+   |\n+LL |     assert_eq!(OVERFLOW, 0);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+warning: skipping const checks\n+  --> $DIR/enum_discriminants.rs:109:5\n+   |\n+LL |     assert_eq!(MORE_OVERFLOW, 0);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+warning: skipping const checks\n+  --> $DIR/enum_discriminants.rs:109:5\n+   |\n+LL |     assert_eq!(MORE_OVERFLOW, 0);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+warning: skipping const checks\n+  --> $DIR/enum_discriminants.rs:109:5\n+   |\n+LL |     assert_eq!(MORE_OVERFLOW, 0);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+"}]}