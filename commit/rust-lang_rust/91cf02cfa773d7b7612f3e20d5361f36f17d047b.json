{"sha": "91cf02cfa773d7b7612f3e20d5361f36f17d047b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxY2YwMmNmYTc3M2Q3Yjc2MTJmM2UyMGQ1MzYxZjM2ZjE3ZDA0N2I=", "commit": {"author": {"name": "Charles Gleason", "email": "charles_gleason@alumni.brown.edu", "date": "2019-10-03T19:03:59Z"}, "committer": {"name": "Charles Gleason", "email": "charles_gleason@alumni.brown.edu", "date": "2019-10-11T02:49:17Z"}, "message": "Implement Clone::clone_from for VecDeque", "tree": {"sha": "487738d1f31f9e9b62ed2e5dd55ae5c5b8d98a93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/487738d1f31f9e9b62ed2e5dd55ae5c5b8d98a93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91cf02cfa773d7b7612f3e20d5361f36f17d047b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91cf02cfa773d7b7612f3e20d5361f36f17d047b", "html_url": "https://github.com/rust-lang/rust/commit/91cf02cfa773d7b7612f3e20d5361f36f17d047b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91cf02cfa773d7b7612f3e20d5361f36f17d047b/comments", "author": {"login": "crgl", "id": 36055314, "node_id": "MDQ6VXNlcjM2MDU1MzE0", "avatar_url": "https://avatars.githubusercontent.com/u/36055314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crgl", "html_url": "https://github.com/crgl", "followers_url": "https://api.github.com/users/crgl/followers", "following_url": "https://api.github.com/users/crgl/following{/other_user}", "gists_url": "https://api.github.com/users/crgl/gists{/gist_id}", "starred_url": "https://api.github.com/users/crgl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crgl/subscriptions", "organizations_url": "https://api.github.com/users/crgl/orgs", "repos_url": "https://api.github.com/users/crgl/repos", "events_url": "https://api.github.com/users/crgl/events{/privacy}", "received_events_url": "https://api.github.com/users/crgl/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crgl", "id": 36055314, "node_id": "MDQ6VXNlcjM2MDU1MzE0", "avatar_url": "https://avatars.githubusercontent.com/u/36055314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crgl", "html_url": "https://github.com/crgl", "followers_url": "https://api.github.com/users/crgl/followers", "following_url": "https://api.github.com/users/crgl/following{/other_user}", "gists_url": "https://api.github.com/users/crgl/gists{/gist_id}", "starred_url": "https://api.github.com/users/crgl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crgl/subscriptions", "organizations_url": "https://api.github.com/users/crgl/orgs", "repos_url": "https://api.github.com/users/crgl/repos", "events_url": "https://api.github.com/users/crgl/events{/privacy}", "received_events_url": "https://api.github.com/users/crgl/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfb6d84720019236e33872e145d187dfd6e81090", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfb6d84720019236e33872e145d187dfd6e81090", "html_url": "https://github.com/rust-lang/rust/commit/cfb6d84720019236e33872e145d187dfd6e81090"}], "stats": {"total": 81, "additions": 79, "deletions": 2}, "files": [{"sha": "42c00fd121dde345bb85afed5fa683c0d8878f86", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/91cf02cfa773d7b7612f3e20d5361f36f17d047b/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91cf02cfa773d7b7612f3e20d5361f36f17d047b/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=91cf02cfa773d7b7612f3e20d5361f36f17d047b", "patch": "@@ -10,8 +10,8 @@\n use core::array::LengthAtMost32;\n use core::cmp::{self, Ordering};\n use core::fmt;\n-use core::iter::{repeat_with, FromIterator, FusedIterator};\n-use core::mem;\n+use core::iter::{once, repeat_with, FromIterator, FusedIterator};\n+use core::mem::{self, replace};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, IndexMut, RangeBounds, Try};\n use core::ptr::{self, NonNull};\n@@ -57,11 +57,88 @@ pub struct VecDeque<T> {\n     buf: RawVec<T>,\n }\n \n+/// PairSlices pairs up equal length slice parts of two deques\n+///\n+/// For example, given deques \"A\" and \"B\" with the following division into slices:\n+///\n+/// A: [0 1 2] [3 4 5]\n+/// B: [a b] [c d e]\n+///\n+/// It produces the following sequence of matching slices:\n+///\n+/// ([0 1], [a b])\n+/// ([2], [c])\n+/// ([3 4], [d e])\n+///\n+/// and the uneven remainder of either A or B is skipped.\n+struct PairSlices<'a, 'b, T> {\n+    a0: &'a mut [T],\n+    a1: &'a mut [T],\n+    b0: &'b [T],\n+    b1: &'b [T],\n+}\n+\n+impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n+    fn from(to: &'a mut VecDeque<T>, from: &'b VecDeque<T>) -> Self {\n+        let (a0, a1) = to.as_mut_slices();\n+        let (b0, b1) = from.as_slices();\n+        PairSlices { a0, a1, b0, b1 }\n+    }\n+\n+    fn has_remainder(&self) -> bool {\n+        !self.b0.is_empty()\n+    }\n+\n+    fn remainder(self) -> impl Iterator<Item=&'b [T]> {\n+        once(self.b0).chain(once(self.b1))\n+    }\n+}\n+\n+impl<'a, 'b, T> Iterator for PairSlices<'a, 'b, T>\n+{\n+    type Item = (&'a mut [T], &'b [T]);\n+    fn next(&mut self) -> Option<Self::Item> {\n+        // Get next part length\n+        let part = cmp::min(self.a0.len(), self.b0.len());\n+        if part == 0 {\n+            return None;\n+        }\n+        let (p0, p1) = replace(&mut self.a0, &mut []).split_at_mut(part);\n+        let (q0, q1) = self.b0.split_at(part);\n+\n+        // Move a1 into a0, if it's empty (and b1, b0 the same way).\n+        self.a0 = p1;\n+        self.b0 = q1;\n+        if self.a0.is_empty() {\n+            self.a0 = replace(&mut self.a1, &mut []);\n+        }\n+        if self.b0.is_empty() {\n+            self.b0 = replace(&mut self.b1, &[]);\n+        }\n+        Some((p0, q0))\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for VecDeque<T> {\n     fn clone(&self) -> VecDeque<T> {\n         self.iter().cloned().collect()\n     }\n+\n+    fn clone_from(&mut self, other: &Self) {\n+        self.truncate(other.len());\n+\n+        let mut iter = PairSlices::from(self, other);\n+        while let Some((dst, src)) = iter.next() {\n+            dst.clone_from_slice(&src);\n+        }\n+\n+        if iter.has_remainder() {\n+            for remainder in iter.remainder() {\n+                self.extend(remainder.iter().cloned());\n+            }\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}]}