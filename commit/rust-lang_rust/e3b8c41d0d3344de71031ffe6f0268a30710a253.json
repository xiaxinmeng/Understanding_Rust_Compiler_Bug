{"sha": "e3b8c41d0d3344de71031ffe6f0268a30710a253", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzYjhjNDFkMGQzMzQ0ZGU3MTAzMWZmZTZmMDI2OGEzMDcxMGEyNTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-02T08:11:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-02T08:11:48Z"}, "message": "Auto merge of #5536 - rail-rain:fix_manual_memcpy, r=phansch\n\nFix the bugs of `manual_memcpy`, simplify the suggestion and refactor it\n\nWhile I\u2019m working on the long procrastinated work to expand `manual_memcpy`(#1670), I found a few minor bugs and probably unidiomatic or old coding style. There is a brief explanation of changes to the behaviour this PR will make below. And, I have a questoin: do I need to add tests for the first and second fixed bugs? I thought it might be too rare cases to include the tests for those. I added for the last one though.\n\n* Bug fix\n  * It negates resulted offsets (`src/dst_offset`) when `offset` is subtraction by 0. This PR will remove any subtraction by 0 as a part of minification.\n\n    ```rust\n    for i in 0..5 {\n        dst[i - 0] = src[i];\n    }\n    ```\n\n    ```diff\n     warning: it looks like you're manually copying between slices\n       --> src/main.rs:2:14\n        |\n    LL  |     for i in 0..5 {\n    -   |              ^^^^ help: try replacing the loop by: `dst[..-5].clone_from_slice(&src[..5])`\n    +   |              ^^^^ help: try replacing the loop by: `dst[..5].clone_from_slice(&src[..5])`\n        |\n    ```\n  * It prints `RangeTo` or `RangeFull` when both of `end` and `offset` are 0, which have different meaning. This PR will print 0. I could reject the cases `end` is 0, but I thought I won\u2019t catch other cases `reverse_range_loop` will trigger, and it\u2019s over to catch every such cases.\n\n    ```rust\n    for i in 0..0 {\n        dst[i] = src[i];\n    }\n    ```\n\n    ```diff\n     warning: it looks like you're manually copying between slices\n       --> src/main.rs:2:14\n        |\n     LL |     for i in 0..0 {\n    -   |              ^^^^ help: try replacing the loop by: `dst.clone_from_slice(&src[..])`\n    +   |              ^^^^ help: try replacing the loop by: `dst[..0].clone_from_slice(&src[..0])`\n        |\n    ```\n  * it prints four dots when `end` is `None`. This PR will ignore any `for` loops without `end` because a `for` loop that takes `RangeFrom` as its argument and contains indexing without the statements or the expressions that end loops such as `break` will definitely panic, and `manual_memcpy` should ignore the loops with such control flow.\n\n    ```rust\n    fn manual_copy(src: &[u32], dst: &mut [u32]) {\n        for i in 0.. {\n            dst[i] = src[i];\n        }\n    }\n    ```\n\n    ```diff\n    -warning: it looks like you're manually copying between slices\n    -  --> src/main.rs:2:14\n    -   |\n    -LL |     for i in 0.. {\n    -   |              ^^^ help: try replacing the loop by: `dst[....].clone_from_slice(&src[....])`\n    -   |\n    ```\n* Simplification of the suggestion\n\n  * It prints 0 when `start` or `end` and `offset` are same (from #3323). This PR will use `RangeTo`\n\nchangelog: fixed the bugs of `manual_memcpy` and also simplify the suggestion.", "tree": {"sha": "9fd3fd9f6a155514ed724218da04796d3d452cd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fd3fd9f6a155514ed724218da04796d3d452cd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3b8c41d0d3344de71031ffe6f0268a30710a253", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3b8c41d0d3344de71031ffe6f0268a30710a253", "html_url": "https://github.com/rust-lang/rust/commit/e3b8c41d0d3344de71031ffe6f0268a30710a253", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3b8c41d0d3344de71031ffe6f0268a30710a253/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2708873ef711ec8ab45df1e984ecf24a96cd369", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2708873ef711ec8ab45df1e984ecf24a96cd369", "html_url": "https://github.com/rust-lang/rust/commit/d2708873ef711ec8ab45df1e984ecf24a96cd369"}, {"sha": "461f4a34660691675434a318ac4fd61a83444428", "url": "https://api.github.com/repos/rust-lang/rust/commits/461f4a34660691675434a318ac4fd61a83444428", "html_url": "https://github.com/rust-lang/rust/commit/461f4a34660691675434a318ac4fd61a83444428"}], "stats": {"total": 396, "additions": 207, "deletions": 189}, "files": [{"sha": "2bbf4dba614b41970f846d8175d995a06fca8ba6", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 176, "deletions": 185, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/e3b8c41d0d3344de71031ffe6f0268a30710a253/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b8c41d0d3344de71031ffe6f0268a30710a253/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=e3b8c41d0d3344de71031ffe6f0268a30710a253", "patch": "@@ -10,7 +10,6 @@ use crate::utils::{\n };\n use crate::utils::{is_type_diagnostic_item, qpath_res, same_tys, sext, sugg};\n use if_chain::if_chain;\n-use itertools::Itertools;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n@@ -772,40 +771,48 @@ fn check_for_loop<'a, 'tcx>(\n \n fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>, var: HirId) -> bool {\n     if_chain! {\n-        if let ExprKind::Path(ref qpath) = expr.kind;\n-        if let QPath::Resolved(None, ref path) = *qpath;\n+        if let ExprKind::Path(qpath) = &expr.kind;\n+        if let QPath::Resolved(None, path) = qpath;\n         if path.segments.len() == 1;\n         if let Res::Local(local_id) = qpath_res(cx, qpath, expr.hir_id);\n-        // our variable!\n-        if local_id == var;\n         then {\n-            return true;\n+            // our variable!\n+            local_id == var\n+        } else {\n+            false\n         }\n     }\n+}\n \n-    false\n+#[derive(Clone, Copy)]\n+enum OffsetSign {\n+    Positive,\n+    Negative,\n }\n \n struct Offset {\n     value: String,\n-    negate: bool,\n+    sign: OffsetSign,\n }\n \n impl Offset {\n-    fn negative(s: String) -> Self {\n-        Self { value: s, negate: true }\n+    fn negative(value: String) -> Self {\n+        Self {\n+            value,\n+            sign: OffsetSign::Negative,\n+        }\n     }\n \n-    fn positive(s: String) -> Self {\n+    fn positive(value: String) -> Self {\n         Self {\n-            value: s,\n-            negate: false,\n+            value,\n+            sign: OffsetSign::Positive,\n         }\n     }\n }\n \n-struct FixedOffsetVar {\n-    var_name: String,\n+struct FixedOffsetVar<'hir> {\n+    var: &'hir Expr<'hir>,\n     offset: Offset,\n }\n \n@@ -819,10 +826,20 @@ fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'_>) -> bool {\n     is_slice || is_type_diagnostic_item(cx, ty, sym!(vec_type)) || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n }\n \n-fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>, var: HirId) -> Option<FixedOffsetVar> {\n+fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n+    if_chain! {\n+        if let ExprKind::MethodCall(method, _, args) = expr.kind;\n+        if method.ident.name == sym!(clone);\n+        if args.len() == 1;\n+        if let Some(arg) = args.get(0);\n+        then { arg } else { expr }\n+    }\n+}\n+\n+fn get_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, idx: &Expr<'_>, var: HirId) -> Option<Offset> {\n     fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr<'_>, var: HirId) -> Option<String> {\n-        match e.kind {\n-            ExprKind::Lit(ref l) => match l.node {\n+        match &e.kind {\n+            ExprKind::Lit(l) => match l.node {\n                 ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n                 _ => None,\n             },\n@@ -831,115 +848,139 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>, v\n         }\n     }\n \n-    if let ExprKind::Index(ref seqexpr, ref idx) = expr.kind {\n-        let ty = cx.tables.expr_ty(seqexpr);\n-        if !is_slice_like(cx, ty) {\n-            return None;\n-        }\n-\n-        let offset = match idx.kind {\n-            ExprKind::Binary(op, ref lhs, ref rhs) => match op.node {\n-                BinOpKind::Add => {\n-                    let offset_opt = if same_var(cx, lhs, var) {\n-                        extract_offset(cx, rhs, var)\n-                    } else if same_var(cx, rhs, var) {\n-                        extract_offset(cx, lhs, var)\n-                    } else {\n-                        None\n-                    };\n-\n-                    offset_opt.map(Offset::positive)\n-                },\n-                BinOpKind::Sub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n-                _ => None,\n-            },\n-            ExprKind::Path(..) => {\n-                if same_var(cx, idx, var) {\n-                    Some(Offset::positive(\"0\".into()))\n+    match idx.kind {\n+        ExprKind::Binary(op, lhs, rhs) => match op.node {\n+            BinOpKind::Add => {\n+                let offset_opt = if same_var(cx, lhs, var) {\n+                    extract_offset(cx, rhs, var)\n+                } else if same_var(cx, rhs, var) {\n+                    extract_offset(cx, lhs, var)\n                 } else {\n                     None\n-                }\n+                };\n+\n+                offset_opt.map(Offset::positive)\n             },\n+            BinOpKind::Sub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n             _ => None,\n-        };\n-\n-        offset.map(|o| FixedOffsetVar {\n-            var_name: snippet_opt(cx, seqexpr.span).unwrap_or_else(|| \"???\".into()),\n-            offset: o,\n-        })\n-    } else {\n-        None\n-    }\n-}\n-\n-fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &Expr<'_>,\n-    var: HirId,\n-) -> Option<FixedOffsetVar> {\n-    if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref args) = expr.kind;\n-        if method.ident.name == sym!(clone);\n-        if args.len() == 1;\n-        if let Some(arg) = args.get(0);\n-        then {\n-            return get_fixed_offset_var(cx, arg, var);\n-        }\n+        },\n+        ExprKind::Path(..) if same_var(cx, idx, var) => Some(Offset::positive(\"0\".into())),\n+        _ => None,\n     }\n-\n-    get_fixed_offset_var(cx, expr, var)\n }\n \n-fn get_indexed_assignments<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    body: &Expr<'_>,\n-    var: HirId,\n-) -> Vec<(FixedOffsetVar, FixedOffsetVar)> {\n-    fn get_assignment<'a, 'tcx>(\n-        cx: &LateContext<'a, 'tcx>,\n-        e: &Expr<'_>,\n-        var: HirId,\n-    ) -> Option<(FixedOffsetVar, FixedOffsetVar)> {\n-        if let ExprKind::Assign(ref lhs, ref rhs, _) = e.kind {\n-            match (\n-                get_fixed_offset_var(cx, lhs, var),\n-                fetch_cloned_fixed_offset_var(cx, rhs, var),\n-            ) {\n-                (Some(offset_left), Some(offset_right)) => {\n-                    // Source and destination must be different\n-                    if offset_left.var_name == offset_right.var_name {\n-                        None\n-                    } else {\n-                        Some((offset_left, offset_right))\n-                    }\n-                },\n-                _ => None,\n-            }\n+fn get_assignments<'tcx>(body: &'tcx Expr<'tcx>) -> impl Iterator<Item = Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>> {\n+    fn get_assignment<'tcx>(e: &'tcx Expr<'tcx>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+        if let ExprKind::Assign(lhs, rhs, _) = e.kind {\n+            Some((lhs, rhs))\n         } else {\n             None\n         }\n     }\n \n-    if let ExprKind::Block(ref b, _) = body.kind {\n-        let Block {\n-            ref stmts, ref expr, ..\n-        } = **b;\n+    // This is one of few ways to return different iterators\n+    // derived from: https://stackoverflow.com/questions/29760668/conditionally-iterate-over-one-of-several-possible-iterators/52064434#52064434\n+    let mut iter_a = None;\n+    let mut iter_b = None;\n+\n+    if let ExprKind::Block(b, _) = body.kind {\n+        let Block { stmts, expr, .. } = *b;\n \n-        stmts\n+        iter_a = stmts\n             .iter()\n-            .map(|stmt| match stmt.kind {\n+            .filter_map(|stmt| match stmt.kind {\n                 StmtKind::Local(..) | StmtKind::Item(..) => None,\n-                StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => Some(get_assignment(cx, e, var)),\n+                StmtKind::Expr(e) | StmtKind::Semi(e) => Some(e),\n             })\n-            .chain(expr.as_ref().into_iter().map(|e| Some(get_assignment(cx, &*e, var))))\n-            .filter_map(|op| op)\n-            .collect::<Option<Vec<_>>>()\n-            .unwrap_or_default()\n+            .chain(expr.into_iter())\n+            .map(get_assignment)\n+            .into()\n     } else {\n-        get_assignment(cx, body, var).into_iter().collect()\n+        iter_b = Some(get_assignment(body))\n     }\n+\n+    iter_a.into_iter().flatten().chain(iter_b.into_iter())\n }\n \n+fn build_manual_memcpy_suggestion<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    start: &Expr<'_>,\n+    end: &Expr<'_>,\n+    limits: ast::RangeLimits,\n+    dst_var: FixedOffsetVar<'_>,\n+    src_var: FixedOffsetVar<'_>,\n+) -> String {\n+    fn print_sum(arg1: &str, arg2: &Offset) -> String {\n+        match (arg1, &arg2.value[..], arg2.sign) {\n+            (\"0\", \"0\", _) => \"0\".into(),\n+            (\"0\", x, OffsetSign::Positive) | (x, \"0\", _) => x.into(),\n+            (\"0\", x, OffsetSign::Negative) => format!(\"-{}\", x),\n+            (x, y, OffsetSign::Positive) => format!(\"({} + {})\", x, y),\n+            (x, y, OffsetSign::Negative) => {\n+                if x == y {\n+                    \"0\".into()\n+                } else {\n+                    format!(\"({} - {})\", x, y)\n+                }\n+            },\n+        }\n+    }\n+\n+    fn print_offset(start_str: &str, inline_offset: &Offset) -> String {\n+        let offset = print_sum(start_str, inline_offset);\n+        if offset.as_str() == \"0\" {\n+            \"\".into()\n+        } else {\n+            offset\n+        }\n+    }\n+\n+    let print_limit = |end: &Expr<'_>, offset: Offset, var: &Expr<'_>| {\n+        if_chain! {\n+            if let ExprKind::MethodCall(method, _, len_args) = end.kind;\n+            if method.ident.name == sym!(len);\n+            if len_args.len() == 1;\n+            if let Some(arg) = len_args.get(0);\n+            if var_def_id(cx, arg) == var_def_id(cx, var);\n+            then {\n+                match offset.sign {\n+                    OffsetSign::Negative => format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value),\n+                    OffsetSign::Positive => \"\".into(),\n+                }\n+            } else {\n+                let end_str = match limits {\n+                    ast::RangeLimits::Closed => {\n+                        let end = sugg::Sugg::hir(cx, end, \"<count>\");\n+                        format!(\"{}\", end + sugg::ONE)\n+                    },\n+                    ast::RangeLimits::HalfOpen => format!(\"{}\", snippet(cx, end.span, \"..\")),\n+                };\n+\n+                print_sum(&end_str, &offset)\n+            }\n+        }\n+    };\n+\n+    let start_str = snippet(cx, start.span, \"\").to_string();\n+    let dst_offset = print_offset(&start_str, &dst_var.offset);\n+    let dst_limit = print_limit(end, dst_var.offset, dst_var.var);\n+    let src_offset = print_offset(&start_str, &src_var.offset);\n+    let src_limit = print_limit(end, src_var.offset, src_var.var);\n+\n+    let dst_var_name = snippet_opt(cx, dst_var.var.span).unwrap_or_else(|| \"???\".into());\n+    let src_var_name = snippet_opt(cx, src_var.var.span).unwrap_or_else(|| \"???\".into());\n+\n+    let dst = if dst_offset == \"\" && dst_limit == \"\" {\n+        dst_var_name\n+    } else {\n+        format!(\"{}[{}..{}]\", dst_var_name, dst_offset, dst_limit)\n+    };\n+\n+    format!(\n+        \"{}.clone_from_slice(&{}[{}..{}])\",\n+        dst, src_var_name, src_offset, src_limit\n+    )\n+}\n /// Checks for for loops that sequentially copy items from one slice-like\n /// object to another.\n fn detect_manual_memcpy<'a, 'tcx>(\n@@ -951,93 +992,43 @@ fn detect_manual_memcpy<'a, 'tcx>(\n ) {\n     if let Some(higher::Range {\n         start: Some(start),\n-        ref end,\n+        end: Some(end),\n         limits,\n     }) = higher::range(cx, arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {\n-            let print_sum = |arg1: &Offset, arg2: &Offset| -> String {\n-                match (&arg1.value[..], arg1.negate, &arg2.value[..], arg2.negate) {\n-                    (\"0\", _, \"0\", _) => \"\".into(),\n-                    (\"0\", _, x, false) | (x, false, \"0\", false) => x.into(),\n-                    (\"0\", _, x, true) | (x, false, \"0\", true) => format!(\"-{}\", x),\n-                    (x, false, y, false) => format!(\"({} + {})\", x, y),\n-                    (x, false, y, true) => {\n-                        if x == y {\n-                            \"0\".into()\n-                        } else {\n-                            format!(\"({} - {})\", x, y)\n-                        }\n-                    },\n-                    (x, true, y, false) => {\n-                        if x == y {\n-                            \"0\".into()\n-                        } else {\n-                            format!(\"({} - {})\", y, x)\n-                        }\n-                    },\n-                    (x, true, y, true) => format!(\"-({} + {})\", x, y),\n-                }\n-            };\n-\n-            let print_limit = |end: &Option<&Expr<'_>>, offset: Offset, var_name: &str| {\n-                if let Some(end) = *end {\n-                    if_chain! {\n-                        if let ExprKind::MethodCall(ref method, _, ref len_args) = end.kind;\n-                        if method.ident.name == sym!(len);\n-                        if len_args.len() == 1;\n-                        if let Some(arg) = len_args.get(0);\n-                        if snippet(cx, arg.span, \"??\") == var_name;\n-                        then {\n-                            return if offset.negate {\n-                                format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value)\n-                            } else {\n-                                String::new()\n-                            };\n-                        }\n-                    }\n-\n-                    let end_str = match limits {\n-                        ast::RangeLimits::Closed => {\n-                            let end = sugg::Sugg::hir(cx, end, \"<count>\");\n-                            format!(\"{}\", end + sugg::ONE)\n-                        },\n-                        ast::RangeLimits::HalfOpen => format!(\"{}\", snippet(cx, end.span, \"..\")),\n-                    };\n-\n-                    print_sum(&Offset::positive(end_str), &offset)\n-                } else {\n-                    \"..\".into()\n-                }\n-            };\n-\n             // The only statements in the for loops can be indexed assignments from\n             // indexed retrievals.\n-            let manual_copies = get_indexed_assignments(cx, body, canonical_id);\n-\n-            let big_sugg = manual_copies\n-                .into_iter()\n-                .map(|(dst_var, src_var)| {\n-                    let start_str = Offset::positive(snippet(cx, start.span, \"\").to_string());\n-                    let dst_offset = print_sum(&start_str, &dst_var.offset);\n-                    let dst_limit = print_limit(end, dst_var.offset, &dst_var.var_name);\n-                    let src_offset = print_sum(&start_str, &src_var.offset);\n-                    let src_limit = print_limit(end, src_var.offset, &src_var.var_name);\n-                    let dst = if dst_offset == \"\" && dst_limit == \"\" {\n-                        dst_var.var_name\n-                    } else {\n-                        format!(\"{}[{}..{}]\", dst_var.var_name, dst_offset, dst_limit)\n-                    };\n-\n-                    format!(\n-                        \"{}.clone_from_slice(&{}[{}..{}])\",\n-                        dst, src_var.var_name, src_offset, src_limit\n-                    )\n+            let big_sugg = get_assignments(body)\n+                .map(|o| {\n+                    o.and_then(|(lhs, rhs)| {\n+                        let rhs = fetch_cloned_expr(rhs);\n+                        if_chain! {\n+                            if let ExprKind::Index(seqexpr_left, idx_left) = lhs.kind;\n+                            if let ExprKind::Index(seqexpr_right, idx_right) = rhs.kind;\n+                            if is_slice_like(cx, cx.tables.expr_ty(seqexpr_left))\n+                                && is_slice_like(cx, cx.tables.expr_ty(seqexpr_right));\n+                            if let Some(offset_left) = get_offset(cx, &idx_left, canonical_id);\n+                            if let Some(offset_right) = get_offset(cx, &idx_right, canonical_id);\n+\n+                            // Source and destination must be different\n+                            if var_def_id(cx, seqexpr_left) != var_def_id(cx, seqexpr_right);\n+                            then {\n+                                Some((FixedOffsetVar { var: seqexpr_left, offset: offset_left },\n+                                    FixedOffsetVar { var: seqexpr_right, offset: offset_right }))\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                    })\n                 })\n-                .join(\"\\n    \");\n+                .map(|o| o.map(|(dst, src)| build_manual_memcpy_suggestion(cx, start, end, limits, dst, src)))\n+                .collect::<Option<Vec<_>>>()\n+                .filter(|v| !v.is_empty())\n+                .map(|v| v.join(\"\\n    \"));\n \n-            if !big_sugg.is_empty() {\n+            if let Some(big_sugg) = big_sugg {\n                 span_lint_and_sugg(\n                     cx,\n                     MANUAL_MEMCPY,"}, {"sha": "9c24d6d4db1f257de14382cdd58ad2d58c11ff21", "filename": "tests/ui/manual_memcpy.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e3b8c41d0d3344de71031ffe6f0268a30710a253/tests%2Fui%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b8c41d0d3344de71031ffe6f0268a30710a253/tests%2Fui%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy.rs?ref=e3b8c41d0d3344de71031ffe6f0268a30710a253", "patch": "@@ -98,6 +98,21 @@ pub fn manual_copy(src: &[i32], dst: &mut [i32], dst2: &mut [i32]) {\n     for i in from..from + 3 {\n         dst[i] = src[i - from];\n     }\n+\n+    #[allow(clippy::identity_op)]\n+    for i in 0..5 {\n+        dst[i - 0] = src[i];\n+    }\n+\n+    #[allow(clippy::reverse_range_loop)]\n+    for i in 0..0 {\n+        dst[i] = src[i];\n+    }\n+\n+    // `RangeTo` `for` loop - don't trigger lint\n+    for i in 0.. {\n+        dst[i] = src[i];\n+    }\n }\n \n #[warn(clippy::needless_range_loop, clippy::manual_memcpy)]"}, {"sha": "bad84a589008180df702444d2e57b4a9042b9d82", "filename": "tests/ui/manual_memcpy.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e3b8c41d0d3344de71031ffe6f0268a30710a253/tests%2Fui%2Fmanual_memcpy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3b8c41d0d3344de71031ffe6f0268a30710a253/tests%2Fui%2Fmanual_memcpy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy.stderr?ref=e3b8c41d0d3344de71031ffe6f0268a30710a253", "patch": "@@ -58,19 +58,31 @@ error: it looks like you're manually copying between slices\n   --> $DIR/manual_memcpy.rs:94:14\n    |\n LL |     for i in from..from + src.len() {\n-   |              ^^^^^^^^^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[from..from + src.len()].clone_from_slice(&src[0..(from + src.len() - from)])`\n+   |              ^^^^^^^^^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[from..from + src.len()].clone_from_slice(&src[..(from + src.len() - from)])`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/manual_memcpy.rs:98:14\n    |\n LL |     for i in from..from + 3 {\n-   |              ^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[from..from + 3].clone_from_slice(&src[0..(from + 3 - from)])`\n+   |              ^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[from..from + 3].clone_from_slice(&src[..(from + 3 - from)])`\n \n error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:105:14\n+  --> $DIR/manual_memcpy.rs:103:14\n+   |\n+LL |     for i in 0..5 {\n+   |              ^^^^ help: try replacing the loop by: `dst[..5].clone_from_slice(&src[..5])`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/manual_memcpy.rs:108:14\n+   |\n+LL |     for i in 0..0 {\n+   |              ^^^^ help: try replacing the loop by: `dst[..0].clone_from_slice(&src[..0])`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/manual_memcpy.rs:120:14\n    |\n LL |     for i in 0..src.len() {\n    |              ^^^^^^^^^^^^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[..])`\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 13 previous errors\n "}]}