{"sha": "343432a74d1b92e4d3e71de4271e68304e046da3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MzQzMmE3NGQxYjkyZTRkM2U3MWRlNDI3MWU2ODMwNGUwNDZkYTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-29T04:36:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-29T04:36:50Z"}, "message": "Auto merge of #68512 - spastorino:local-is-copy, r=oli-obk\n\nLocal is copy\n\nr? @oli-obk", "tree": {"sha": "2d1aca750013077b388c7b44a3f2a95e69f9214f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d1aca750013077b388c7b44a3f2a95e69f9214f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/343432a74d1b92e4d3e71de4271e68304e046da3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/343432a74d1b92e4d3e71de4271e68304e046da3", "html_url": "https://github.com/rust-lang/rust/commit/343432a74d1b92e4d3e71de4271e68304e046da3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/343432a74d1b92e4d3e71de4271e68304e046da3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d55f3e9f1da631c636b54a7c22c1caccbe4bf0db", "url": "https://api.github.com/repos/rust-lang/rust/commits/d55f3e9f1da631c636b54a7c22c1caccbe4bf0db", "html_url": "https://github.com/rust-lang/rust/commit/d55f3e9f1da631c636b54a7c22c1caccbe4bf0db"}, {"sha": "3021856626974eb571b59ebd549661f11290f32a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3021856626974eb571b59ebd549661f11290f32a", "html_url": "https://github.com/rust-lang/rust/commit/3021856626974eb571b59ebd549661f11290f32a"}], "stats": {"total": 264, "additions": 134, "deletions": 130}, "files": [{"sha": "4e9835a52b779ad47bb9d375ead90fadd4695968", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -1773,7 +1773,7 @@ rustc_index::newtype_index! {\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct PlaceRef<'a, 'tcx> {\n-    pub local: &'a Local,\n+    pub local: Local,\n     pub projection: &'a [PlaceElem<'tcx>],\n }\n \n@@ -1797,8 +1797,8 @@ impl<'tcx> Place<'tcx> {\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n         match self.as_ref() {\n-            PlaceRef { local, projection: &[] }\n-            | PlaceRef { local, projection: &[ProjectionElem::Deref] } => Some(*local),\n+            PlaceRef { local, projection: [] }\n+            | PlaceRef { local, projection: [ProjectionElem::Deref] } => Some(local),\n             _ => None,\n         }\n     }\n@@ -1810,7 +1810,7 @@ impl<'tcx> Place<'tcx> {\n     }\n \n     pub fn as_ref(&self) -> PlaceRef<'_, 'tcx> {\n-        PlaceRef { local: &self.local, projection: &self.projection }\n+        PlaceRef { local: self.local, projection: &self.projection }\n     }\n }\n \n@@ -1826,18 +1826,18 @@ impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n     //\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n-        match self {\n+        match *self {\n             PlaceRef { local, projection: [] }\n-            | PlaceRef { local, projection: [ProjectionElem::Deref] } => Some(**local),\n+            | PlaceRef { local, projection: [ProjectionElem::Deref] } => Some(local),\n             _ => None,\n         }\n     }\n \n     /// If this place represents a local variable like `_X` with no\n     /// projections, return `Some(_X)`.\n     pub fn as_local(&self) -> Option<Local> {\n-        match self {\n-            PlaceRef { local, projection: [] } => Some(**local),\n+        match *self {\n+            PlaceRef { local, projection: [] } => Some(local),\n             _ => None,\n         }\n     }"}, {"sha": "e6c7c84494cd80c0d934ae0aaace8a138fc5ddf1", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -114,7 +114,7 @@ impl<'tcx> PlaceTy<'tcx> {\n \n impl<'tcx> Place<'tcx> {\n     pub fn ty_from<D>(\n-        local: &Local,\n+        local: Local,\n         projection: &[PlaceElem<'tcx>],\n         local_decls: &D,\n         tcx: TyCtxt<'tcx>,\n@@ -124,7 +124,7 @@ impl<'tcx> Place<'tcx> {\n     {\n         projection\n             .iter()\n-            .fold(PlaceTy::from_ty(local_decls.local_decls()[*local].ty), |place_ty, elem| {\n+            .fold(PlaceTy::from_ty(local_decls.local_decls()[local].ty), |place_ty, elem| {\n                 place_ty.projection_ty(tcx, elem)\n             })\n     }\n@@ -133,7 +133,7 @@ impl<'tcx> Place<'tcx> {\n     where\n         D: HasLocalDecls<'tcx>,\n     {\n-        Place::ty_from(&self.local, &self.projection, local_decls, tcx)\n+        Place::ty_from(self.local, &self.projection, local_decls, tcx)\n     }\n }\n "}, {"sha": "d4b0ab0448a8b46b8cb73bb09b52b529eca2f7a7", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -134,7 +134,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                 // ZSTs don't require any actual memory access.\n                 let elem_ty = base_ty.projection_ty(cx.tcx(), elem).ty;\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n-                let span = self.fx.mir.local_decls[*place_ref.local].source_info.span;\n+                let span = self.fx.mir.local_decls[place_ref.local].source_info.span;\n                 if cx.spanned_layout_of(elem_ty, span).is_zst() {\n                     return;\n                 }\n@@ -174,7 +174,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                     // We use `NonUseContext::VarDebugInfo` for the base,\n                     // which might not force the base local to memory,\n                     // so we have to do it manually.\n-                    self.visit_local(place_ref.local, context, location);\n+                    self.visit_local(&place_ref.local, context, location);\n                 }\n             }\n \n@@ -212,8 +212,8 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                 };\n             }\n \n-            self.visit_place_base(place_ref.local, context, location);\n-            self.visit_projection(place_ref.local, place_ref.projection, context, location);\n+            self.visit_place_base(&place_ref.local, context, location);\n+            self.visit_projection(&place_ref.local, place_ref.projection, context, location);\n         }\n     }\n }"}, {"sha": "7f43e66549896769704f8bc7bb9bf6abec1bd0ff", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -264,7 +264,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             PassMode::Direct(_) | PassMode::Pair(..) => {\n-                let op = self.codegen_consume(&mut bx, &mir::Place::return_place().as_ref());\n+                let op = self.codegen_consume(&mut bx, mir::Place::return_place().as_ref());\n                 if let Ref(llval, _, align) = op.val {\n                     bx.load(llval, align)\n                 } else {\n@@ -319,7 +319,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             return;\n         }\n \n-        let place = self.codegen_place(&mut bx, &location.as_ref());\n+        let place = self.codegen_place(&mut bx, location.as_ref());\n         let (args1, args2);\n         let mut args = if let Some(llextra) = place.llextra {\n             args2 = [place.llval, llextra];\n@@ -1111,7 +1111,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         } else {\n             self.codegen_place(\n                 bx,\n-                &mir::PlaceRef { local: &dest.local, projection: &dest.projection },\n+                mir::PlaceRef { local: dest.local, projection: &dest.projection },\n             )\n         };\n         if fn_ret.is_indirect() {\n@@ -1137,7 +1137,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n                 LocalRef::UnsizedPlace(_) => bug!(\"transmute must not involve unsized locals\"),\n                 LocalRef::Operand(None) => {\n-                    let dst_layout = bx.layout_of(self.monomorphized_place_ty(&dst.as_ref()));\n+                    let dst_layout = bx.layout_of(self.monomorphized_place_ty(dst.as_ref()));\n                     assert!(!dst_layout.ty.has_erasable_regions());\n                     let place = PlaceRef::alloca(bx, dst_layout);\n                     place.storage_live(bx);\n@@ -1151,7 +1151,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n         } else {\n-            let dst = self.codegen_place(bx, &dst.as_ref());\n+            let dst = self.codegen_place(bx, dst.as_ref());\n             self.codegen_transmute_into(bx, src, dst);\n         }\n     }"}, {"sha": "a33cd2ddad97b479dbc32001a3023934a0f0c3fe", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -369,11 +369,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn maybe_codegen_consume_direct(\n         &mut self,\n         bx: &mut Bx,\n-        place_ref: &mir::PlaceRef<'_, 'tcx>,\n+        place_ref: mir::PlaceRef<'_, 'tcx>,\n     ) -> Option<OperandRef<'tcx, Bx::Value>> {\n         debug!(\"maybe_codegen_consume_direct(place_ref={:?})\", place_ref);\n \n-        match self.locals[*place_ref.local] {\n+        match self.locals[place_ref.local] {\n             LocalRef::Operand(Some(mut o)) => {\n                 // Moves out of scalar and scalar pair fields are trivial.\n                 for elem in place_ref.projection.iter() {\n@@ -413,7 +413,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_consume(\n         &mut self,\n         bx: &mut Bx,\n-        place_ref: &mir::PlaceRef<'_, 'tcx>,\n+        place_ref: mir::PlaceRef<'_, 'tcx>,\n     ) -> OperandRef<'tcx, Bx::Value> {\n         debug!(\"codegen_consume(place_ref={:?})\", place_ref);\n \n@@ -444,7 +444,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         match *operand {\n             mir::Operand::Copy(ref place) | mir::Operand::Move(ref place) => {\n-                self.codegen_consume(bx, &place.as_ref())\n+                self.codegen_consume(bx, place.as_ref())\n             }\n \n             mir::Operand::Constant(ref constant) => {"}, {"sha": "fa82daa0f7d526addf04a56654a049af6c280d45", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -408,14 +408,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_place(\n         &mut self,\n         bx: &mut Bx,\n-        place_ref: &mir::PlaceRef<'_, 'tcx>,\n+        place_ref: mir::PlaceRef<'_, 'tcx>,\n     ) -> PlaceRef<'tcx, Bx::Value> {\n         debug!(\"codegen_place(place_ref={:?})\", place_ref);\n         let cx = self.cx;\n         let tcx = self.cx.tcx();\n \n         let result = match place_ref {\n-            mir::PlaceRef { local, projection: [] } => match self.locals[**local] {\n+            mir::PlaceRef { local, projection: [] } => match self.locals[local] {\n                 LocalRef::Place(place) => {\n                     return place;\n                 }\n@@ -428,13 +428,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             },\n             mir::PlaceRef { local, projection: [proj_base @ .., mir::ProjectionElem::Deref] } => {\n                 // Load the pointer from its location.\n-                self.codegen_consume(bx, &mir::PlaceRef { local, projection: proj_base })\n+                self.codegen_consume(bx, mir::PlaceRef { local, projection: proj_base })\n                     .deref(bx.cx())\n             }\n             mir::PlaceRef { local, projection: [proj_base @ .., elem] } => {\n                 // FIXME turn this recursion into iteration\n                 let cg_base =\n-                    self.codegen_place(bx, &mir::PlaceRef { local, projection: proj_base });\n+                    self.codegen_place(bx, mir::PlaceRef { local, projection: proj_base });\n \n                 match elem {\n                     mir::ProjectionElem::Deref => bug!(),\n@@ -497,7 +497,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         result\n     }\n \n-    pub fn monomorphized_place_ty(&self, place_ref: &mir::PlaceRef<'_, 'tcx>) -> Ty<'tcx> {\n+    pub fn monomorphized_place_ty(&self, place_ref: mir::PlaceRef<'_, 'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n         let place_ty = mir::Place::ty_from(place_ref.local, place_ref.projection, *self.mir, tcx);\n         self.monomorphize(&place_ty.ty)"}, {"sha": "2f83298741aa610506071b07cf36c62cd4a06e0c", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -467,7 +467,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::Rvalue::Discriminant(ref place) => {\n                 let discr_ty = rvalue.ty(*self.mir, bx.tcx());\n                 let discr = self\n-                    .codegen_place(&mut bx, &place.as_ref())\n+                    .codegen_place(&mut bx, place.as_ref())\n                     .codegen_get_discr(&mut bx, discr_ty);\n                 (\n                     bx,\n@@ -541,7 +541,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n         }\n         // use common size calculation for non zero-sized types\n-        let cg_value = self.codegen_place(bx, &place.as_ref());\n+        let cg_value = self.codegen_place(bx, place.as_ref());\n         cg_value.len(bx.cx())\n     }\n \n@@ -552,7 +552,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         place: &mir::Place<'tcx>,\n         mk_ptr_ty: impl FnOnce(TyCtxt<'tcx>, Ty<'tcx>) -> Ty<'tcx>,\n     ) -> (Bx, OperandRef<'tcx, Bx::Value>) {\n-        let cg_place = self.codegen_place(&mut bx, &place.as_ref());\n+        let cg_place = self.codegen_place(&mut bx, place.as_ref());\n \n         let ty = cg_place.layout.ty;\n "}, {"sha": "e68b41ad188792eefe3e52fe0e861f3d06a4d7e5", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -41,12 +41,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                     }\n                 } else {\n-                    let cg_dest = self.codegen_place(&mut bx, &place.as_ref());\n+                    let cg_dest = self.codegen_place(&mut bx, place.as_ref());\n                     self.codegen_rvalue(bx, cg_dest, rvalue)\n                 }\n             }\n             mir::StatementKind::SetDiscriminant { box ref place, variant_index } => {\n-                self.codegen_place(&mut bx, &place.as_ref())\n+                self.codegen_place(&mut bx, place.as_ref())\n                     .codegen_set_discr(&mut bx, variant_index);\n                 bx\n             }\n@@ -70,7 +70,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let outputs = asm\n                     .outputs\n                     .iter()\n-                    .map(|output| self.codegen_place(&mut bx, &output.as_ref()))\n+                    .map(|output| self.codegen_place(&mut bx, output.as_ref()))\n                     .collect();\n \n                 let input_vals = asm.inputs.iter().fold("}, {"sha": "19b7e0cf59bb4bff2d3442a25d3236cd28e22c31", "filename": "src/librustc_mir/borrow_check/constraint_generation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -97,7 +97,7 @@ impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n             ));\n \n             // If there are borrows on this now dead local, we need to record them as `killed`.\n-            if let StatementKind::StorageDead(ref local) = statement.kind {\n+            if let StatementKind::StorageDead(local) = statement.kind {\n                 record_killed_borrows_for_local(\n                     all_facts,\n                     self.borrow_set,\n@@ -212,7 +212,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                         local, location\n                     );\n \n-                    if let Some(borrow_indices) = self.borrow_set.local_map.get(local) {\n+                    if let Some(borrow_indices) = self.borrow_set.local_map.get(&local) {\n                         for &borrow_index in borrow_indices {\n                             let places_conflict = places_conflict::places_conflict(\n                                 self.infcx.tcx,\n@@ -239,10 +239,10 @@ fn record_killed_borrows_for_local(\n     all_facts: &mut AllFacts,\n     borrow_set: &BorrowSet<'_>,\n     location_table: &LocationTable,\n-    local: &Local,\n+    local: Local,\n     location: Location,\n ) {\n-    if let Some(borrow_indices) = borrow_set.local_map.get(local) {\n+    if let Some(borrow_indices) = borrow_set.local_map.get(&local) {\n         all_facts.killed.reserve(borrow_indices.len());\n         for &borrow_index in borrow_indices {\n             let location_index = location_table.mid_index(location);"}, {"sha": "f49ddbced2ef4cc05503dc67256045cedf278b06", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -604,8 +604,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     cursor = proj_base;\n \n                     match elem {\n-                        ProjectionElem::Field(field, _) if union_ty(local, proj_base).is_some() => {\n-                            return Some((PlaceRef { local, projection: proj_base }, field));\n+                        ProjectionElem::Field(field, _)\n+                            if union_ty(*local, proj_base).is_some() =>\n+                        {\n+                            return Some((\n+                                PlaceRef { local: *local, projection: proj_base },\n+                                field,\n+                            ));\n                         }\n                         _ => {}\n                     }\n@@ -622,14 +627,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     cursor = proj_base;\n \n                     if let ProjectionElem::Field(field, _) = elem {\n-                        if let Some(union_ty) = union_ty(local, proj_base) {\n+                        if let Some(union_ty) = union_ty(*local, proj_base) {\n                             if field != target_field\n-                                && local == target_base.local\n+                                && *local == target_base.local\n                                 && proj_base == target_base.projection\n                             {\n                                 // FIXME when we avoid clone reuse describe_place closure\n                                 let describe_base_place = self\n-                                    .describe_place(PlaceRef { local, projection: proj_base })\n+                                    .describe_place(PlaceRef {\n+                                        local: *local,\n+                                        projection: proj_base,\n+                                    })\n                                     .unwrap_or_else(|| \"_\".to_owned());\n \n                                 return Some((\n@@ -686,12 +694,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let borrow_span = borrow_spans.var_or_use();\n \n         assert!(root_place.projection.is_empty());\n-        let proper_span = self.body.local_decls[*root_place.local].source_info.span;\n+        let proper_span = self.body.local_decls[root_place.local].source_info.span;\n \n         let root_place_projection = self.infcx.tcx.intern_place_elems(root_place.projection);\n \n         if self.access_place_error_reported.contains(&(\n-            Place { local: *root_place.local, projection: root_place_projection },\n+            Place { local: root_place.local, projection: root_place_projection },\n             borrow_span,\n         )) {\n             debug!(\n@@ -702,7 +710,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         self.access_place_error_reported.insert((\n-            Place { local: *root_place.local, projection: root_place_projection },\n+            Place { local: root_place.local, projection: root_place_projection },\n             borrow_span,\n         ));\n \n@@ -1139,7 +1147,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let root_place =\n                 self.prefixes(borrow.borrowed_place.as_ref(), PrefixSet::All).last().unwrap();\n             let local = root_place.local;\n-            match self.body.local_kind(*local) {\n+            match self.body.local_kind(local) {\n                 LocalKind::ReturnPointer | LocalKind::Temp => {\n                     (\"temporary value\".to_string(), \"temporary value created here\".to_string())\n                 }\n@@ -1513,17 +1521,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         StorageDeadOrDrop::LocalStorageDead\n                         | StorageDeadOrDrop::BoxedStorageDead => {\n                             assert!(\n-                                Place::ty_from(&place.local, proj_base, *self.body, tcx)\n-                                    .ty\n-                                    .is_box(),\n+                                Place::ty_from(place.local, proj_base, *self.body, tcx).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n                             );\n                             StorageDeadOrDrop::BoxedStorageDead\n                         }\n                         StorageDeadOrDrop::Destructor(_) => base_access,\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = Place::ty_from(&place.local, proj_base, *self.body, tcx).ty;\n+                        let base_ty = Place::ty_from(place.local, proj_base, *self.body, tcx).ty;\n                         match base_ty.kind {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor"}, {"sha": "ba4af59eede06f97774de81ffa4be85fa60c2f3f", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -169,10 +169,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> Result<(), ()> {\n         match place {\n             PlaceRef { local, projection: [] } => {\n-                self.append_local_to_string(*local, buf)?;\n+                self.append_local_to_string(local, buf)?;\n             }\n             PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[*local].is_ref_for_guard() =>\n+                if self.body.local_decls[local].is_ref_for_guard() =>\n             {\n                 self.append_place_to_string(\n                     PlaceRef { local: local, projection: &[] },\n@@ -182,9 +182,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 )?;\n             }\n             PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[*local].is_ref_to_static() =>\n+                if self.body.local_decls[local].is_ref_to_static() =>\n             {\n-                let local_info = &self.body.local_decls[*local].local_info;\n+                let local_info = &self.body.local_decls[local].local_info;\n                 if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n                     buf.push_str(&self.infcx.tcx.item_name(def_id).as_str());\n                 } else {\n@@ -307,7 +307,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // FIXME Place2 Make this work iteratively\n         match place {\n             PlaceRef { local, projection: [] } => {\n-                let local = &self.body.local_decls[*local];\n+                let local = &self.body.local_decls[local];\n                 self.describe_field_from_ty(&local.ty, field, None)\n             }\n             PlaceRef { local, projection: [proj_base @ .., elem] } => match elem {"}, {"sha": "14f675c0fdf83ea6c6dbb2dd717af1cf15704de8", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -274,8 +274,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let description = if place.projection.len() == 1 {\n             format!(\"static item `{}`\", self.describe_place(place.as_ref()).unwrap())\n         } else {\n-            let base_static =\n-                PlaceRef { local: &place.local, projection: &[ProjectionElem::Deref] };\n+            let base_static = PlaceRef { local: place.local, projection: &[ProjectionElem::Deref] };\n \n             format!(\n                 \"`{:?}` as `{:?}` is a static item\",\n@@ -304,17 +303,17 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         let deref_base = match deref_target_place.projection.as_ref() {\n             &[ref proj_base @ .., ProjectionElem::Deref] => {\n-                PlaceRef { local: &deref_target_place.local, projection: &proj_base }\n+                PlaceRef { local: deref_target_place.local, projection: &proj_base }\n             }\n             _ => bug!(\"deref_target_place is not a deref projection\"),\n         };\n \n         if let PlaceRef { local, projection: [] } = deref_base {\n-            let decl = &self.body.local_decls[*local];\n+            let decl = &self.body.local_decls[local];\n             if decl.is_ref_for_guard() {\n                 let mut err = self.cannot_move_out_of(\n                     span,\n-                    &format!(\"`{}` in pattern guard\", self.local_names[*local].unwrap()),\n+                    &format!(\"`{}` in pattern guard\", self.local_names[local].unwrap()),\n                 );\n                 err.note(\n                     \"variables bound in patterns cannot be moved from \\"}, {"sha": "563ff1112c3a654ea2e6a8967e88ec6ebc645fdc", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if access_place.as_local().is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n-                    let name = self.local_names[*local].expect(\"immutable unnamed local\");\n+                    let name = self.local_names[local].expect(\"immutable unnamed local\");\n                     reason = format!(\", as `{}` is not declared as mutable\", name);\n                 }\n             }\n@@ -70,20 +70,20 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[*local].is_ref_for_guard() =>\n+                if self.body.local_decls[local].is_ref_for_guard() =>\n             {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                 reason = \", as it is immutable for the pattern guard\".to_string();\n             }\n             PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[*local].is_ref_to_static() =>\n+                if self.body.local_decls[local].is_ref_to_static() =>\n             {\n                 if access_place.projection.len() == 1 {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();\n                 } else {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    let local_info = &self.body.local_decls[*local].local_info;\n+                    let local_info = &self.body.local_decls[local].local_info;\n                     if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n                         let static_name = &self.infcx.tcx.item_name(def_id);\n                         reason = format!(\", as `{}` is an immutable static item\", static_name);\n@@ -93,7 +93,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n             PlaceRef { local: _, projection: [proj_base @ .., ProjectionElem::Deref] } => {\n-                if *the_place_err.local == Local::new(1)\n+                if the_place_err.local == Local::new(1)\n                     && proj_base.is_empty()\n                     && !self.upvars.is_empty()\n                 {\n@@ -212,7 +212,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if {\n                     self.body\n                         .local_decls\n-                        .get(*local)\n+                        .get(local)\n                         .map(|local_decl| {\n                             if let LocalInfo::User(ClearCrossCrate::Set(\n                                 mir::BindingForm::ImplicitSelf(kind),\n@@ -224,7 +224,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 // Deliberately fall into this case for all implicit self types,\n                                 // so that we don't fall in to the next case with them.\n                                 kind == mir::ImplicitSelfKind::MutRef\n-                            } else if Some(kw::SelfLower) == self.local_names[*local] {\n+                            } else if Some(kw::SelfLower) == self.local_names[local] {\n                                 // Otherwise, check if the name is the self kewyord - in which case\n                                 // we have an explicit self. Do the same thing in this case and check\n                                 // for a `self: &mut Self` to suggest removing the `&mut`.\n@@ -247,20 +247,20 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // We want to suggest users use `let mut` for local (user\n             // variable) mutations...\n             PlaceRef { local, projection: [] }\n-                if self.body.local_decls[*local].can_be_made_mutable() =>\n+                if self.body.local_decls[local].can_be_made_mutable() =>\n             {\n                 // ... but it doesn't make sense to suggest it on\n                 // variables that are `ref x`, `ref mut x`, `&self`,\n                 // or `&mut self` (such variables are simply not\n                 // mutable).\n-                let local_decl = &self.body.local_decls[*local];\n+                let local_decl = &self.body.local_decls[local];\n                 assert_eq!(local_decl.mutability, Mutability::Not);\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_suggestion(\n                     local_decl.source_info.span,\n                     \"consider changing this to be mutable\",\n-                    format!(\"mut {}\", self.local_names[*local].unwrap()),\n+                    format!(\"mut {}\", self.local_names[local].unwrap()),\n                     Applicability::MachineApplicable,\n                 );\n             }\n@@ -312,7 +312,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[*local].is_ref_for_guard() =>\n+                if self.body.local_decls[local].is_ref_for_guard() =>\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.note(\n@@ -326,9 +326,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // FIXME: can this case be generalized to work for an\n             // arbitrary base for the projection?\n             PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[*local].is_user_variable() =>\n+                if self.body.local_decls[local].is_user_variable() =>\n             {\n-                let local_decl = &self.body.local_decls[*local];\n+                let local_decl = &self.body.local_decls[local];\n                 let suggestion = match local_decl.local_info {\n                     LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf(_))) => {\n                         Some(suggest_ampmut_self(self.infcx.tcx, local_decl))\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     ))) => Some(suggest_ampmut(\n                         self.infcx.tcx,\n                         self.body,\n-                        *local,\n+                        local,\n                         local_decl,\n                         opt_ty_info,\n                     )),\n@@ -379,7 +379,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     );\n                 }\n \n-                match self.local_names[*local] {\n+                match self.local_names[local] {\n                     Some(name) if !local_decl.from_compiler_desugaring() => {\n                         err.span_label(\n                             span,\n@@ -411,7 +411,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 local,\n                 projection: [ProjectionElem::Deref],\n                 // FIXME document what is this 1 magic number about\n-            } if *local == Local::new(1) && !self.upvars.is_empty() => {\n+            } if local == Local::new(1) && !self.upvars.is_empty() => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_help(\n                     self.body.span,"}, {"sha": "717359d75c3bea7ec01ce7e9786139f55066c13c", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -823,7 +823,7 @@ enum InitializationRequiringAction {\n }\n \n struct RootPlace<'d, 'tcx> {\n-    place_local: &'d Local,\n+    place_local: Local,\n     place_projection: &'d [PlaceElem<'tcx>],\n     is_local_mutation_allowed: LocalMutationIsAllowed,\n }\n@@ -1382,7 +1382,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = &borrow.borrowed_place;\n         let deref = [ProjectionElem::Deref];\n-        let mut root_place = PlaceRef { local: &place.local, projection: &[] };\n+        let mut root_place = PlaceRef { local: place.local, projection: &[] };\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n         // we just know that all locals are dropped at function exit (otherwise\n@@ -1391,7 +1391,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // FIXME: allow thread-locals to borrow other thread locals?\n \n         let (might_be_alive, will_be_dropped) =\n-            if self.body.local_decls[*root_place.local].is_ref_to_thread_local() {\n+            if self.body.local_decls[root_place.local].is_ref_to_thread_local() {\n                 // Thread-locals might be dropped after the function exits\n                 // We have to dereference the outer reference because\n                 // borrows don't conflict behind shared references.\n@@ -1722,7 +1722,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     self.check_if_full_path_is_moved(\n                         location, InitializationRequiringAction::Use,\n                         (PlaceRef {\n-                            local: &place.local,\n+                            local: place.local,\n                             projection: proj_base,\n                         }, span), flow_state);\n                     // (base initialized; no need to\n@@ -1740,13 +1740,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // assigning to `P.f` requires `P` itself\n                     // be already initialized\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = Place::ty_from(&place.local, proj_base, self.body(), tcx).ty;\n+                    let base_ty = Place::ty_from(place.local, proj_base, self.body(), tcx).ty;\n                     match base_ty.kind {\n                         ty::Adt(def, _) if def.has_dtor(tcx) => {\n                             self.check_if_path_or_subpath_is_moved(\n                                 location, InitializationRequiringAction::Assignment,\n                                 (PlaceRef {\n-                                    local: &place.local,\n+                                    local: place.local,\n                                     projection: proj_base,\n                                 }, span), flow_state);\n \n@@ -1759,7 +1759,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // is allowed, remove this match arm.\n                         ty::Adt(..) | ty::Tuple(..) => {\n                             check_parent_of_field(self, location, PlaceRef {\n-                                local: &place.local,\n+                                local: place.local,\n                                 projection: proj_base,\n                             }, span, flow_state);\n \n@@ -1998,9 +1998,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // mutated, then it is justified to be annotated with the `mut`\n                 // keyword, since the mutation may be a possible reassignment.\n                 if is_local_mutation_allowed != LocalMutationIsAllowed::Yes\n-                    && self.is_local_ever_initialized(*local, flow_state).is_some()\n+                    && self.is_local_ever_initialized(local, flow_state).is_some()\n                 {\n-                    self.used_mut.insert(*local);\n+                    self.used_mut.insert(local);\n                 }\n             }\n             RootPlace {\n@@ -2032,7 +2032,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> Result<RootPlace<'d, 'tcx>, PlaceRef<'d, 'tcx>> {\n         match place {\n             PlaceRef { local, projection: [] } => {\n-                let local = &self.body.local_decls[*local];\n+                let local = &self.body.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n                         LocalMutationIsAllowed::Yes => Ok(RootPlace {"}, {"sha": "01c44d0d905b6fa6bb1cd9b86de3502dd688ff25", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n             let proj_base = &self.projection[..i];\n \n             if *elem == ProjectionElem::Deref {\n-                let ty = Place::ty_from(&self.local, proj_base, body, tcx).ty;\n+                let ty = Place::ty_from(self.local, proj_base, body, tcx).ty;\n                 match ty.kind {\n                     ty::Ref(_, _, hir::Mutability::Not) if i == 0 => {\n                         // For references to thread-local statics, we do need"}, {"sha": "984de021ca11276da6b3648c87a3ac3d76053d8b", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -119,7 +119,7 @@ fn place_components_conflict<'tcx>(\n     //    and either equal or disjoint.\n     //  - If we did run out of access, the borrow can access a part of it.\n \n-    let borrow_local = &borrow_place.local;\n+    let borrow_local = borrow_place.local;\n     let access_local = access_place.local;\n \n     match place_base_conflict(borrow_local, access_local) {\n@@ -293,7 +293,7 @@ fn place_components_conflict<'tcx>(\n // Given that the bases of `elem1` and `elem2` are always either equal\n // or disjoint (and have the same type!), return the overlap situation\n // between `elem1` and `elem2`.\n-fn place_base_conflict(l1: &Local, l2: &Local) -> Overlap {\n+fn place_base_conflict(l1: Local, l2: Local) -> Overlap {\n     if l1 == l2 {\n         // the same local - base case, equal\n         debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n@@ -311,7 +311,7 @@ fn place_base_conflict(l1: &Local, l2: &Local) -> Overlap {\n fn place_projection_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    pi1_local: &Local,\n+    pi1_local: Local,\n     pi1_proj_base: &[PlaceElem<'tcx>],\n     pi1_elem: &PlaceElem<'tcx>,\n     pi2_elem: &PlaceElem<'tcx>,"}, {"sha": "f645435cdf60fa9aedd59d9aff96ea73e140ced4", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -2390,7 +2390,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             match elem {\n                 ProjectionElem::Deref => {\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = Place::ty_from(&borrowed_place.local, proj_base, body, tcx).ty;\n+                    let base_ty = Place::ty_from(borrowed_place.local, proj_base, body, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.kind {"}, {"sha": "62af196174fd7b91e93d4bff86719385ae0183aa", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -109,7 +109,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             let proj_base = &place.projection[..i];\n             let body = self.builder.body;\n             let tcx = self.builder.tcx;\n-            let place_ty = Place::ty_from(&place.local, proj_base, body, tcx).ty;\n+            let place_ty = Place::ty_from(place.local, proj_base, body, tcx).ty;\n             match place_ty.kind {\n                 ty::Ref(..) | ty::RawPtr(..) => {\n                     let proj = &place.projection[..i + 1];"}, {"sha": "8d62b84bda8f070142e41f50c059c3b1bc7c92cf", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -246,7 +246,7 @@ impl MovePathLookup {\n     // unknown place, but will rather return the nearest available\n     // parent.\n     pub fn find(&self, place: PlaceRef<'_, '_>) -> LookupResult {\n-        let mut result = self.locals[*place.local];\n+        let mut result = self.locals[place.local];\n \n         for elem in place.projection.iter() {\n             if let Some(&subpath) = self.projections.get(&(result, elem.lift())) {"}, {"sha": "2c0c0cbbaddb957ca7ee902d0981a7b05cf94b9d", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -78,7 +78,7 @@ pub trait Qualif {\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         match place {\n-            PlaceRef { local, projection: [] } => per_local(*local),\n+            PlaceRef { local, projection: [] } => per_local(local),\n             PlaceRef { local: _, projection: [.., _] } => Self::in_projection(cx, per_local, place),\n         }\n     }\n@@ -149,12 +149,12 @@ pub trait Qualif {\n             Rvalue::Ref(_, _, ref place) | Rvalue::AddressOf(_, ref place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n-                    let base_ty = Place::ty_from(&place.local, proj_base, *cx.body, cx.tcx).ty;\n+                    let base_ty = Place::ty_from(place.local, proj_base, *cx.body, cx.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         return Self::in_place(\n                             cx,\n                             per_local,\n-                            PlaceRef { local: &place.local, projection: proj_base },\n+                            PlaceRef { local: place.local, projection: proj_base },\n                         );\n                     }\n                 }"}, {"sha": "eac60029784d258ff177abc067d20ebfc4676d53", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -48,7 +48,7 @@ where\n \n         match (value, place.as_ref()) {\n             (true, mir::PlaceRef { local, .. }) => {\n-                self.qualifs_per_local.insert(*local);\n+                self.qualifs_per_local.insert(local);\n             }\n \n             // For now, we do not clear the qualif if a local is overwritten in full by"}, {"sha": "6f109a060dfc1e1712b1127c3615470f61955f03", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -448,7 +448,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match elem {\n             ProjectionElem::Deref => {\n-                let base_ty = Place::ty_from(place_local, proj_base, *self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(*place_local, proj_base, *self.body, self.tcx).ty;\n                 if let ty::RawPtr(_) = base_ty.kind {\n                     if proj_base.is_empty() {\n                         if let (local, []) = (place_local, proj_base) {\n@@ -472,7 +472,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Field(..)\n             | ProjectionElem::Index(_) => {\n-                let base_ty = Place::ty_from(place_local, proj_base, *self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(*place_local, proj_base, *self.body, self.tcx).ty;\n                 match base_ty.ty_adt_def() {\n                     Some(def) if def.is_union() => {\n                         self.check_op(ops::UnionAccess);\n@@ -664,7 +664,7 @@ fn place_as_reborrow(\n         //\n         // This is sufficient to prevent an access to a `static mut` from being marked as a\n         // reborrow, even if the check above were to disappear.\n-        let inner_ty = Place::ty_from(&place.local, inner, body, tcx).ty;\n+        let inner_ty = Place::ty_from(place.local, inner, body, tcx).ty;\n         match inner_ty.kind {\n             ty::Ref(..) => Some(inner),\n             _ => None,"}, {"sha": "cf9a5479afb353e224875b61e3373c392a209c25", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -215,7 +215,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n             }\n             let is_borrow_of_interior_mut = context.is_borrow()\n-                && !Place::ty_from(&place.local, proj_base, self.body, self.tcx).ty.is_freeze(\n+                && !Place::ty_from(place.local, proj_base, self.body, self.tcx).ty.is_freeze(\n                     self.tcx,\n                     self.param_env,\n                     self.source_info.span,\n@@ -260,7 +260,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     }\n                 }\n             }\n-            let base_ty = Place::ty_from(&place.local, proj_base, self.body, self.tcx).ty;\n+            let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n             match base_ty.kind {\n                 ty::RawPtr(..) => self.require_unsafe(\n                     \"dereference of raw pointer\",\n@@ -414,8 +414,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n             match elem {\n                 ProjectionElem::Field(..) => {\n                     let ty =\n-                        Place::ty_from(&place.local, proj_base, &self.body.local_decls, self.tcx)\n-                            .ty;\n+                        Place::ty_from(place.local, proj_base, &self.body.local_decls, self.tcx).ty;\n                     match ty.kind {\n                         ty::Adt(def, _) => match self.tcx.layout_scalar_valid_range(def.did) {\n                             (Bound::Unbounded, Bound::Unbounded) => {}"}, {"sha": "56b6fa68e1841333c6dd8e5565c1bf820fdba4c7", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -640,8 +640,8 @@ impl<'a, 'tcx> Integrator<'a, 'tcx> {\n         new\n     }\n \n-    fn make_integrate_local(&self, local: &Local) -> Local {\n-        if *local == RETURN_PLACE {\n+    fn make_integrate_local(&self, local: Local) -> Local {\n+        if local == RETURN_PLACE {\n             return self.destination.local;\n         }\n \n@@ -660,7 +660,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n     }\n \n     fn visit_local(&mut self, local: &mut Local, _ctxt: PlaceContext, _location: Location) {\n-        *local = self.make_integrate_local(local);\n+        *local = self.make_integrate_local(*local);\n     }\n \n     fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n@@ -680,7 +680,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n \n     fn process_projection_elem(&mut self, elem: &PlaceElem<'tcx>) -> Option<PlaceElem<'tcx>> {\n         if let PlaceElem::Index(local) = elem {\n-            let new_local = self.make_integrate_local(local);\n+            let new_local = self.make_integrate_local(*local);\n \n             if new_local != *local {\n                 return Some(PlaceElem::Index(new_local));"}, {"sha": "f82225c6ae14756251cdb91557d9bfda0b17c1c8", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -329,7 +329,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                                 // FIXME(eddyb) this is probably excessive, with\n                                 // the exception of `union` member accesses.\n                                 let ty =\n-                                    Place::ty_from(&place.local, proj_base, *self.body, self.tcx)\n+                                    Place::ty_from(place.local, proj_base, *self.body, self.tcx)\n                                         .projection_ty(self.tcx, elem)\n                                         .ty;\n                                 if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n@@ -475,7 +475,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n     fn validate_place(&self, place: PlaceRef<'_, 'tcx>) -> Result<(), Unpromotable> {\n         match place {\n-            PlaceRef { local, projection: [] } => self.validate_local(*local),\n+            PlaceRef { local, projection: [] } => self.validate_local(local),\n             PlaceRef { local: _, projection: [proj_base @ .., elem] } => {\n                 match *elem {\n                     ProjectionElem::Deref | ProjectionElem::Downcast(..) => {\n@@ -589,10 +589,10 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // Raw reborrows can come from reference to pointer coercions,\n                 // so are allowed.\n                 if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n-                    let base_ty = Place::ty_from(&place.local, proj_base, *self.body, self.tcx).ty;\n+                    let base_ty = Place::ty_from(place.local, proj_base, *self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         return self.validate_place(PlaceRef {\n-                            local: &place.local,\n+                            local: place.local,\n                             projection: proj_base,\n                         });\n                     }\n@@ -628,9 +628,9 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 let mut place = place.as_ref();\n                 if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n-                    let base_ty = Place::ty_from(&place.local, proj_base, *self.body, self.tcx).ty;\n+                    let base_ty = Place::ty_from(place.local, proj_base, *self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n-                        place = PlaceRef { local: &place.local, projection: proj_base };\n+                        place = PlaceRef { local: place.local, projection: proj_base };\n                     }\n                 }\n \n@@ -640,7 +640,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // `<HasMutInterior as Qualif>::in_projection` from\n                 // `check_consts::qualifs` but without recursion.\n                 let mut has_mut_interior =\n-                    self.qualif_local::<qualifs::HasMutInterior>(*place.local);\n+                    self.qualif_local::<qualifs::HasMutInterior>(place.local);\n                 if has_mut_interior {\n                     let mut place_projection = place.projection;\n                     // FIXME(eddyb) use a forward loop instead of a reverse one."}, {"sha": "49921badf33d958e066e0fe87e25a7fa5a9e2bc8", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -268,7 +268,7 @@ fn check_place(\n             ProjectionElem::Downcast(_symbol, _variant_index) => {}\n \n             ProjectionElem::Field(..) => {\n-                let base_ty = Place::ty_from(&place.local, &proj_base, body, tcx).ty;\n+                let base_ty = Place::ty_from(place.local, &proj_base, body, tcx).ty;\n                 if let Some(def) = base_ty.ty_adt_def() {\n                     // No union field accesses in `const fn`\n                     if def.is_union() {"}, {"sha": "bd661195a4852b749aa06ebcb6ab5db739283ff7", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -139,7 +139,7 @@ fn match_variant_field_place<'tcx>(place: &Place<'tcx>) -> Option<(Local, VarFie\n         PlaceRef {\n             local,\n             projection: &[ProjectionElem::Downcast(_, var_idx), ProjectionElem::Field(field, ty)],\n-        } => Some((*local, VarField { field, field_ty: ty, var_idx })),\n+        } => Some((local, VarField { field, field_ty: ty, var_idx })),\n         _ => None,\n     }\n }"}, {"sha": "d7f2abfbe9943b8c9a316fb0b6150bcb3b837d34", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -46,7 +46,7 @@ where\n             // encountered a Deref, which is ABI-aligned\n             ProjectionElem::Deref => break,\n             ProjectionElem::Field(..) => {\n-                let ty = Place::ty_from(&place.local, proj_base, local_decls, tcx).ty;\n+                let ty = Place::ty_from(place.local, proj_base, local_decls, tcx).ty;\n                 match ty.kind {\n                     ty::Adt(def, _) if def.repr.packed() => return true,\n                     _ => {}"}, {"sha": "907300d45aac0142f4088ecafc3cb3d1b43476d1", "filename": "src/librustc_mir_build/build/expr/as_place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -364,7 +364,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) {\n         let tcx = self.hir.tcx();\n         let place_ty =\n-            Place::ty_from(&base_place.local, &base_place.projection, &self.local_decls, tcx);\n+            Place::ty_from(base_place.local, &base_place.projection, &self.local_decls, tcx);\n         if let ty::Slice(_) = place_ty.ty.kind {\n             // We need to create fake borrows to ensure that the bounds\n             // check that we just did stays valid. Since we can't assign to\n@@ -374,7 +374,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 match elem {\n                     ProjectionElem::Deref => {\n                         let fake_borrow_deref_ty = Place::ty_from(\n-                            &base_place.local,\n+                            base_place.local,\n                             &base_place.projection[..idx],\n                             &self.local_decls,\n                             tcx,\n@@ -399,7 +399,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     }\n                     ProjectionElem::Index(_) => {\n                         let index_ty = Place::ty_from(\n-                            &base_place.local,\n+                            base_place.local,\n                             &base_place.projection[..idx],\n                             &self.local_decls,\n                             tcx,"}, {"sha": "16795b459b6bd5dbbb87629e7fca282c780750fd", "filename": "src/librustc_mir_build/build/expr/as_rvalue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -393,20 +393,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let arg_place = unpack!(block = this.as_place(block, arg));\n \n         let mutability = match arg_place.as_ref() {\n-            PlaceRef { local, projection: &[] } => this.local_decls[*local].mutability,\n+            PlaceRef { local, projection: &[] } => this.local_decls[local].mutability,\n             PlaceRef { local, projection: &[ProjectionElem::Deref] } => {\n                 debug_assert!(\n-                    this.local_decls[*local].is_ref_for_guard(),\n+                    this.local_decls[local].is_ref_for_guard(),\n                     \"Unexpected capture place\",\n                 );\n-                this.local_decls[*local].mutability\n+                this.local_decls[local].mutability\n             }\n             PlaceRef {\n-                ref local,\n+                local,\n                 projection: &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             }\n             | PlaceRef {\n-                ref local,\n+                local,\n                 projection:\n                     &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _), ProjectionElem::Deref],\n             } => {"}, {"sha": "ad55a9fb7b81af8b9ce5b4f23dcc24c291e0166a", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343432a74d1b92e4d3e71de4271e68304e046da3/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=343432a74d1b92e4d3e71de4271e68304e046da3", "patch": "@@ -1241,7 +1241,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // Insert a shallow borrow after a deref. For other\n                     // projections the borrow of prefix_cursor will\n                     // conflict with any mutation of base.\n-                    all_fake_borrows.push(PlaceRef { local: &place.local, projection: proj_base });\n+                    all_fake_borrows.push(PlaceRef { local: place.local, projection: proj_base });\n                 }\n             }\n \n@@ -1258,7 +1258,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             .into_iter()\n             .map(|matched_place_ref| {\n                 let matched_place = Place {\n-                    local: *matched_place_ref.local,\n+                    local: matched_place_ref.local,\n                     projection: tcx.intern_place_elems(matched_place_ref.projection),\n                 };\n                 let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).ty;"}]}