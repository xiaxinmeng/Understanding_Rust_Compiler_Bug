{"sha": "0aa42bc91e08faac450d1850f3b549b78382ccf4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhYTQyYmM5MWUwOGZhYWM0NTBkMTg1MGYzYjU0OWI3ODM4MmNjZjQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-09T21:40:23Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-09T21:40:23Z"}, "message": "Copyedit the macro tutorial\n\nI hope I haven't introduced any grievous errors :-)", "tree": {"sha": "e46d13a250825f1a27c847637269772b27d13b9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e46d13a250825f1a27c847637269772b27d13b9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0aa42bc91e08faac450d1850f3b549b78382ccf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0aa42bc91e08faac450d1850f3b549b78382ccf4", "html_url": "https://github.com/rust-lang/rust/commit/0aa42bc91e08faac450d1850f3b549b78382ccf4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0aa42bc91e08faac450d1850f3b549b78382ccf4/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22efa39382d41b084fde1719df7ae8ce5697d8c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/22efa39382d41b084fde1719df7ae8ce5697d8c9", "html_url": "https://github.com/rust-lang/rust/commit/22efa39382d41b084fde1719df7ae8ce5697d8c9"}], "stats": {"total": 117, "additions": 73, "deletions": 44}, "files": [{"sha": "31f260076f00303637b42ec57f2dd77017844f14", "filename": "doc/tutorial-macros.md", "status": "modified", "additions": 73, "deletions": 44, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/0aa42bc91e08faac450d1850f3b549b78382ccf4/doc%2Ftutorial-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/0aa42bc91e08faac450d1850f3b549b78382ccf4/doc%2Ftutorial-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-macros.md?ref=0aa42bc91e08faac450d1850f3b549b78382ccf4", "patch": "@@ -2,10 +2,11 @@\n \n # Introduction\n \n-Functions are the programmer's primary tool of abstraction, but there are\n-cases in which they are insufficient, because the programmer wants to\n-abstract over concepts not represented as values. Consider the following\n-example:\n+Functions are the primary tool that programmers can use to build\n+abstractions. Sometimes, though, programmers want to abstract over\n+compile-time, syntactic structures rather than runtime values. For example,\n+the following two code fragments both pattern-match on their input and return\n+early in one case, doing nothing otherwise:\n \n ~~~~\n # enum t { special_a(uint), special_b(uint) };\n@@ -24,11 +25,12 @@ match input_2 {\n # }\n ~~~~\n \n-This code could become tiresome if repeated many times. However, there is\n-no reasonable function that could be written to solve this problem. In such a\n-case, it's possible to define a macro to solve the problem. Macros are\n+This code could become tiresome if repeated many times. However, there is no\n+straightforward way to rewrite it without the repeated code, using functions\n+alone. There is a solution, though: defining a macro to solve the problem. Macros are\n lightweight custom syntax extensions, themselves defined using the\n-`macro_rules!` syntax extension:\n+`macro_rules!` syntax extension. The following `early_return` macro captures\n+the pattern in the above code:\n \n ~~~~\n # enum t { special_a(uint), special_b(uint) };\n@@ -42,56 +44,85 @@ macro_rules! early_return(\n         }\n     );\n );\n-// ...\n+~~~~\n+\n+Now, we can replace each `match` with an invocation of the `early_return`\n+macro:\n+\n+~~~~\n early_return!(input_1 special_a);\n // ...\n early_return!(input_2 special_b);\n # return 0;\n # }\n ~~~~\n \n-Macros are defined in pattern-matching style:\n+Macros are defined in pattern-matching style: in the above example, the text\n+`($inp:expr $sp:ident)` that appears on the left-hand side of the `=>` is the\n+*macro invocation syntax*, a pattern denoting how to write a call to the\n+macro. The text on the right-hand side of the `=>`, beginning with `match\n+$inp`, is the *macro transcription syntax*: what the macro expands to.\n \n # Invocation syntax\n \n-On the left-hand-side of the `=>` is the macro invocation syntax. It is\n-free-form, excepting the following rules:\n+The macro invocation syntax specifies the syntax for the arguments to the\n+macro. It appears on the left-hand side of the `=>` in a macro definition. It\n+conforms to the following rules:\n \n-1. It must be surrounded in parentheses.\n+1. It must be surrounded by parentheses.\n 2. `$` has special meaning.\n 3. The `()`s, `[]`s, and `{}`s it contains must balance. For example, `([)` is\n forbidden.\n \n+Otherwise, the invocation syntax is free-form.\n+\n To take as an argument a fragment of Rust code, write `$` followed by a name\n- (for use on the right-hand side), followed by a `:`, followed by the sort of\n-fragment to match (the most common ones are `ident`, `expr`, `ty`, `pat`, and\n-`block`). Anything not preceded by a `$` is taken literally. The standard\n+ (for use on the right-hand side), followed by a `:`, followed by a *fragment\n+ specifier*. The fragment specifier denotes the sort of fragment to match. The\n+ most common fragment specifiers are:\n+\n+* `ident` (an identifier, referring to a variable or item. Examples: `f`, `x`,\n+  `foo`.)\n+* `expr` (an expression. Examples: `2 + 2`; `if true then { 1 } else { 2 }`;\n+  `f(42)`.)\n+* `ty` (a type. Examples: `int`, `~[(char, ~str)]`, `&T`.)\n+* `pat` (a pattern, usually appearing in a `match` or on the left-hand side of\n+  a declaration. Examples: `Some(t)`; `(17, 'a')`; `_`.)\n+* `block` (a sequence of actions. Example: `{ log(error, \"hi\"); return 12; }`)\n+ \n+The parser interprets any token that's not preceded by a `$` literally. Rust's usual\n rules of tokenization apply,\n \n-So `($x:ident => (($e:expr)))`, though excessively fancy, would create a macro\n-that could be invoked like `my_macro!(i=>(( 2+2 )))`.\n+So `($x:ident -> (($e:expr)))`, though excessively fancy, would designate a macro\n+that could be invoked like: `my_macro!(i->(( 2+2 )))`.\n \n # Transcription syntax\n \n The right-hand side of the `=>` follows the same rules as the left-hand side,\n-except that `$` need only be followed by the name of the syntactic fragment\n-to transcribe.\n+except that a `$` need only be followed by the name of the syntactic fragment\n+to transcribe into the macro expansion; its type need not be repeated.\n \n-The right-hand side must be surrounded by delimiters of some kind, and must be\n-an expression; currently, user-defined macros can only be invoked in\n-expression position (even though `macro_rules!` itself can be in item\n-position).\n+The right-hand side must be enclosed by delimiters, and must be\n+an expression. Currently, invocations of user-defined macros can only appear in a context\n+where the Rust grammar requires an expression, even though `macro_rules!` itself can appear\n+in a context where the grammar requires an item.\n \n # Multiplicity\n \n ## Invocation\n \n-Going back to the motivating example, suppose that we wanted each invocation\n-of `early_return` to potentially accept multiple \"special\" identifiers. The\n-syntax `$(...)*` accepts zero or more occurrences of its contents, much like\n-the Kleene star operator in regular expressions. It also supports a separator\n-token (a comma-separated list could be written `$(...),*`), and `+` instead of\n-`*` to mean \"at least one\".\n+Going back to the motivating example, recall that `early_return` expanded into\n+a `match` that would `return` if the `match`'s scrutinee matched the\n+\"special case\" identifier provided as the second argument to `early_return`,\n+and do nothing otherwise. Now suppose that we wanted to write a\n+version of `early_return` that could handle a variable number of \"special\"\n+cases.\n+\n+The syntax `$(...)*` on the left-hand side of the `=>` in a macro definition\n+accepts zero or more occurrences of its contents. It works much\n+like the `*` operator in regular expressions. It also supports a\n+separator token (a comma-separated list could be written `$(...),*`), and `+`\n+instead of `*` to mean \"at least one\".\n \n ~~~~\n # enum t { special_a(uint),special_b(uint),special_c(uint),special_d(uint)};\n@@ -118,37 +149,35 @@ early_return!(input_2, [special_b]);\n ### Transcription\n \n As the above example demonstrates, `$(...)*` is also valid on the right-hand\n-side of a macro definition. The behavior of Kleene star in transcription,\n-especially in cases where multiple stars are nested, and multiple different\n+side of a macro definition. The behavior of `*` in transcription,\n+especially in cases where multiple `*`s are nested, and multiple different\n names are involved, can seem somewhat magical and intuitive at first. The\n system that interprets them is called \"Macro By Example\". The two rules to\n keep in mind are (1) the behavior of `$(...)*` is to walk through one \"layer\"\n of repetitions for all of the `$name`s it contains in lockstep, and (2) each\n `$name` must be under at least as many `$(...)*`s as it was matched against.\n-If it is under more, it'll will be repeated, as appropriate.\n+If it is under more, it'll be repeated, as appropriate.\n \n ## Parsing limitations\n \n-The parser used by the macro system is reasonably powerful, but the parsing of\n-Rust syntax is restricted in two ways:\n+The macro parser will parse Rust syntax with two limitations:\n \n 1. The parser will always parse as much as possible. For example, if the comma\n were omitted from the syntax of `early_return!` above, `input_1 [` would've\n been interpreted as the beginning of an array index. In fact, invoking the\n macro would have been impossible.\n 2. The parser must have eliminated all ambiguity by the time it reaches a\n-`$name:fragment_specifier`. This most often affects them when they occur in\n-the beginning of, or immediately after, a `$(...)*`; requiring a distinctive\n+`$name:fragment_specifier` declaration. This limitation can result in parse\n+errors when declarations occur at the beginning of, or immediately after,\n+a `$(...)*`. Changing the invocation syntax to require a distinctive\n token in front can solve the problem.\n \n ## A final note\n \n Macros, as currently implemented, are not for the faint of heart. Even\n-ordinary syntax errors can be more difficult to debug when they occur inside\n-a macro, and errors caused by parse problems in generated code can be very\n+ordinary syntax errors can be more difficult to debug when they occur inside a\n+macro, and errors caused by parse problems in generated code can be very\n tricky. Invoking the `log_syntax!` macro can help elucidate intermediate\n-states, using `trace_macros!(true)` will automatically print those\n-intermediate states out, and using `--pretty expanded` as an argument to the\n-compiler will show the result of expansion.\n-\n-\n+states, invoking `trace_macros!(true)` will automatically print those\n+intermediate states out, and passing the flag `--pretty expanded` as a\n+command-line argument to the compiler will show the result of expansion."}]}