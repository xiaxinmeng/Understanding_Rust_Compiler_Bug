{"sha": "59aa0918662c62159ad591ed281dab026875fb04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5YWEwOTE4NjYyYzYyMTU5YWQ1OTFlZDI4MWRhYjAyNjg3NWZiMDQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-19T15:19:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-19T15:19:06Z"}, "message": "Merge #9855\n\n9855: feature: Destructure Tuple Assist r=Veykril a=Booksbaum\n\nPart of #8673. This PR only handles tuples, not TupleStruct and RecordStruct.\r\n\r\nCode Assist to destructure a tuple into its items:\r\n![Destructure_Tuple_Assist](https://user-images.githubusercontent.com/15612932/129020107-775d7c94-dca7-4d1f-a0a2-cd63cabf4132.gif)\r\n\r\n\r\n\r\n* Should work in nearly all pattern positions, like let assignment, function parameters, match arms, for loops, and nested variables (`if let Some($0t) = Some((1,2))`)  \r\n  -> everywhere `IdentPat` is allowed\r\n  * Exception: If there's a sub-pattern (``@`):`\r\n    ```rust\r\n    if let t @ (1..=3, 1..=3) = ... {}\r\n    //     ^\r\n    ```\r\n    -> `t` must be a `Name`; `TuplePat` (`(_0, _1)`) isn't allowed\r\n    * inside subpattern is ok:\r\n      ```rust\r\n      let t @ (a, _) = ((1,2), 3);\r\n      //       ^\r\n      ```\r\n      ->\r\n      ```rust\r\n      let t @ ((_0, _1), _) = ((1,2), 3);\r\n      ```\r\n* Assist triggers only at tuple declaration, not tuple usage.  \r\n  (might be useful especially when it creates a sub-pattern (after ``@`)` and only changes the usage under cursor -- but not part of this PR).\r\n\r\n### References\r\nReferences can be destructured:\r\n```rust\r\nlet t = &(1,2);\r\n//  ^\r\nlet v = t.0;\r\n```\r\n->\r\n```rust\r\nlet (_0, _1) = &(1,2);\r\nlet v = _0;\r\n```\r\nBUT: `t.0` and `_0` have different types (`i32` vs. `&i32`) -> `v` has now a different type.\r\n\r\nI think that's acceptable: I think the destructure assist is mostly used in simple, immediate scopes and not huge existing code.\r\n\r\nAdditional Notes:\r\n* `ref` has same behaviour (-> `ref` is kept for items)\r\n  ```rust\r\n  let ref t = (1,2);\r\n  //      ^\r\n  ```\r\n  ->\r\n  ```rust\r\n  let (ref _0, ref _1) = (1,2);\r\n  ```\r\n* Rust IntelliJ Plugin: doesn't trigger with `&` or `ref` at all \r\n\r\n### mutable\r\n```rust\r\nlet mut t = (1,2);\r\n//      ^\r\n```\r\n->\r\n```rust\r\nlet (mut _0, mut _1) = (1,2);\r\n```\r\nand\r\n```rust\r\nlet t = &mut (1,2);\r\n//  ^\r\n```\r\n->\r\n```rust\r\nlet (_0, _1) = &mut (1,2);\r\n```\r\nAgain: with reference (`&mut`), `t.0` and `_0` have different types (`i32` vs `&mut i32`).  \r\nAnd there's an additional issue with `&mut` and assignment:\r\n```rust\r\nlet t = &mut (1,2);\r\n//  ^\r\nt.0 = 9;\r\n```\r\n->\r\n```rust\r\nlet (_0, _1) = &mut (1,2);\r\n_0 = 9;\r\n//   ^\r\n//   mismatched types\r\n//   expected `&mut {integer}`, found integer\r\n//   consider dereferencing here to assign to the mutable borrowed piece of memory\r\n```\r\nBut I think that's quite a niche use case, so I don't catch that (`*_0 = 9;`)\r\n\r\nAdditional Notes:\r\n* Rust IntelliJ Plugin: removes the `mut` (`let mut t = ...` -> `let (_0, _1) = ...`), doesn't trigger with `&mut`\r\n\r\n### Binding after ``@``\r\nDestructure tuple in sub-pattern is implemented:\r\n```rust\r\nlet t = (1,2);\r\n//  ^\r\nlet v = t.0;\r\nlet f = t.into();\r\n```\r\n->\r\n```rust\r\nlet t @ (_0, _1) = (1,2);\r\nlet v = _0;\r\nlet f = t.into();\r\n```\r\nBUT: Bindings after ``@`` aren't currently in stable and require `#![feature(bindings_after_at)]` (though should be generally [available quite soon](https://github.com/rust-lang/rust/pull/85305#event-5072889913) (with `1.56.0`)).  \r\nBut I don't know how to check for an enabled feature -> Destructure tuple in sub-pattern [isn't enabled](https://github.com/Booksbaum/rust-analyzer/blob/a4ee6c7954f910da3ca74fc0e25edda9077ad184/crates/ide_assists/src/handlers/destructure_tuple_binding.rs#L32) yet.\r\n\r\n* When Destructure in sub-pattern is enabled there are two assists:\r\n  * `Destructure tuple in place`:\r\n    ```rust\r\n    let t = (1,2);\r\n    //  ^\r\n    ```\r\n    ->\r\n    ```rust\r\n    let (_0, _1) = (1,2);\r\n    let v = _0;\r\n    let f = /*t*/.into();\r\n    ```\r\n  * `Destructure tuple in sub-pattern`:\r\n    ```rust\r\n    let t = (1,2);\r\n    //  ^\r\n    let v = t.0;\r\n    let f = t.into();\r\n    ```\r\n    ->\r\n    ```rust\r\n    let t @ (_0, _1) = (1,2);\r\n    let v = _0;\r\n    let f = t.into();\r\n    ```\r\n* When Destructure in sub-pattern is disabled, only the first one is available and just named `Destructure tuple`\r\n\r\n<br/>\r\n<br/>\r\n\r\n### Caveats\r\n* Unlike in #8673 or IntelliJ rust plugin, I'm not leaving the previous tuple name at function calls.  \r\n  **Reasoning**: It's not too unlikely the tuple variable shadows another variable. Destructuring the tuple while leaving the function call untouched, results in still a valid function call -- but now with another variable:\r\n  ```rust\r\n  let t = (8,9);\r\n  let t = (1,2);\r\n  //  ^\r\n  t.into()\r\n  ```\r\n  => Destructure Tuple\r\n  ```rust\r\n  let t = (8,9);\r\n  let (_0, _1) = (1,2);\r\n  t.into()\r\n  ```\r\n  `t.into()` is still valid -- using the first tuple.  \r\n  Instead I comment out the tuple usage, which results in invalid code -> must be handled by user:\r\n  ```rust\r\n  /*t*/.into()\r\n  ```\r\n  * (though that might be a biased decision: For testing I just declared a lot of `t`s and quite ofen in lines next to each other...)\r\n  * Issue: there are some cases that results in still valid code:\r\n    * macro that accept the tuple as well as no arguments:\r\n      ```rust\r\n      macro_rules! m {\r\n          () => { \"foo\" };\r\n          ($e:expr) => { $e; \"foo\" };\r\n      }\r\n      let t = (1,2);\r\n      m!(t);\r\n      m!(/*t*/);\r\n      ```\r\n      -> both calls are valid ([test](https://github.com/Booksbaum/rust-analyzer/blob/a4ee6c7954f910da3ca74fc0e25edda9077ad184/crates/ide_assists/src/handlers/destructure_tuple_binding.rs#L1474))  \r\n    * Probably with tuple as return value. Changing the return value most likely results in an error -- but in another place; not where the tuple usage was. \r\n\r\n  -> not sure that's the best way....  \r\n  Additional the tuple name surrounded by comment is more difficult to edit than just the name.\r\n* Code Assists don't support snippet placeholder, and rust analyzer just the first `$0` -> unfortunately no editing of generated tuple item variables. Cursor (`$0`) is placed on first generated item.\r\n\r\n<br/>\r\n<br/>\r\n\r\n### Issues\r\n* Tuple index usage in macro calls aren't converted:\r\n  ```rust\r\n  let t = (1,2);\r\n  //  ^\r\n  let v = t.0;\r\n  println!(\"{}\", t.0);\r\n  ```\r\n  ->\r\n  ```rust\r\n  let (_0, _1) = (1,2);\r\n  let v = _0;\r\n  println!(\"{}\", /*t*/.0);\r\n  ```\r\n  ([tests](https://github.com/Booksbaum/rust-analyzer/blob/a4ee6c7954f910da3ca74fc0e25edda9077ad184/crates/ide_assists/src/handlers/destructure_tuple_binding.rs#L1294))\r\n  * Issue is:  \r\n    [name.syntax()](https://github.com/Booksbaum/rust-analyzer/blob/a4ee6c7954f910da3ca74fc0e25edda9077ad184/crates/ide_assists/src/handlers/destructure_tuple_binding.rs#L242-L244) in each [usage](https://github.com/Booksbaum/rust-analyzer/blob/a4ee6c7954f910da3ca74fc0e25edda9077ad184/crates/ide_assists/src/handlers/destructure_tuple_binding.rs#L108-L113) of a tuple is syntax & text_range in its file.  \r\n    EXCEPT when tuple usage is in a macro call (`m!(t.0)`), the macro is expanded and syntax (and range) is based on that expanded macro, not in actual file.  \r\n    That leads to several things:\r\n    * I cannot differentiate between calling the macro with the tuple or with tuple item:\r\n      ```rust\r\n      macro_rules! m {\r\n          ($t:expr, $i:expr) => { $t.0 + $i };\r\n      }\r\n      let t = (1,2);\r\n      m!(t, t.0);\r\n      ```\r\n      -> both `t` usages are resolved as tuple index usage\r\n    * Range of resolved tuple index usage is in expanded macro, not in actual file  \r\n     -> don't know where to replace index usage\r\n\r\n    -> tuple items passed into a macro are ignored, and only the tuple name itself is handled (uncommented)\r\n* I'm not checking if the generated names conflict with already existing variables.\r\n  ```rust\r\n  let _0 = 42;            // >-|\r\n  let t = (1,2);          //   |\r\n  let v = _0;             // <-|\r\n  //  ^ 42\r\n  ```\r\n  => deconstruct tuple\r\n  ```rust\r\n  let _0 = 42;\r\n  let (_0, _1) = (1,2);     // >-|\r\n  let v = _0;               // <-|\r\n  //  ^ now 1\r\n  ```\r\n  * I tried to get the scope at tuple declaration and its usages. And then iterate all names with [`process_all_names`](https://github.com/rust-analyzer/rust-analyzer/blob/145b51f9daf5371f1754c09eb2e3a77e0a24a0dc/crates/hir/src/semantics.rs#L935). But that doesn't find all local names for declarations (`let t = (1,2)`) (for usages it does)\r\n  * This isn't unique to this Code Assist, but happen in others too (like `extract into variable` or `extract into function`). But here a name conflict is more likely (when destructuring multiple tuples, for examples nested ones (`let t = ((1,2),3)` -> `let (_0, _1) = ...` -> `let ((_0, _1), _1) = ...` -> error))\r\n  * IntelliJ rust plugin does handle this (-> name is `_00`)\n\nCo-authored-by: BooksBaum <15612932+Booksbaum@users.noreply.github.com>", "tree": {"sha": "9e029248f0f728a488950d159e9db073dedd5d79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e029248f0f728a488950d159e9db073dedd5d79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59aa0918662c62159ad591ed281dab026875fb04", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhHnZqCRBK7hj4Ov3rIwAAXIQIAAZgyAyH4eOFBMRt/gYXEjhO\n2IL6OHDhrFBYch49wFwlnPZG/UaHZc8rXhRh7k5VnjjbN/nEWlMGP6vUPXT/grC3\n45a/eAhHtve0OyEUtJNrhGsp7Cwh3ZpuUikCZ5iyjcPzDs02OoF+yyr19SYEqi6c\n8W/xsifarnesuXGZa7R+8G7Osc5GGvi2NMV4wZQibrguTvRveV75u/Fhoq5z84eq\ncbpnFQZj/0q7h0bDT1XWMxfIzmerMn7ACpVQ9kDDqjdFWvCidFYaVR3JQHrgxt3L\nieqiRb62w6a0FtBwNqpuOkn64f/OYO6o6m0AQBtrox19CgxO6Iqttfb4foMM2Xg=\n=GVSC\n-----END PGP SIGNATURE-----\n", "payload": "tree 9e029248f0f728a488950d159e9db073dedd5d79\nparent f696fb51c335d700c2a4bda5a4e613272ded341f\nparent 8a9feeddd34d7a765e401613d8a4293b16660e29\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1629386346 +0000\ncommitter GitHub <noreply@github.com> 1629386346 +0000\n\nMerge #9855\n\n9855: feature: Destructure Tuple Assist r=Veykril a=Booksbaum\n\nPart of #8673. This PR only handles tuples, not TupleStruct and RecordStruct.\r\n\r\nCode Assist to destructure a tuple into its items:\r\n![Destructure_Tuple_Assist](https://user-images.githubusercontent.com/15612932/129020107-775d7c94-dca7-4d1f-a0a2-cd63cabf4132.gif)\r\n\r\n\r\n\r\n* Should work in nearly all pattern positions, like let assignment, function parameters, match arms, for loops, and nested variables (`if let Some($0t) = Some((1,2))`)  \r\n  -> everywhere `IdentPat` is allowed\r\n  * Exception: If there's a sub-pattern (``@`):`\r\n    ```rust\r\n    if let t @ (1..=3, 1..=3) = ... {}\r\n    //     ^\r\n    ```\r\n    -> `t` must be a `Name`; `TuplePat` (`(_0, _1)`) isn't allowed\r\n    * inside subpattern is ok:\r\n      ```rust\r\n      let t @ (a, _) = ((1,2), 3);\r\n      //       ^\r\n      ```\r\n      ->\r\n      ```rust\r\n      let t @ ((_0, _1), _) = ((1,2), 3);\r\n      ```\r\n* Assist triggers only at tuple declaration, not tuple usage.  \r\n  (might be useful especially when it creates a sub-pattern (after ``@`)` and only changes the usage under cursor -- but not part of this PR).\r\n\r\n### References\r\nReferences can be destructured:\r\n```rust\r\nlet t = &(1,2);\r\n//  ^\r\nlet v = t.0;\r\n```\r\n->\r\n```rust\r\nlet (_0, _1) = &(1,2);\r\nlet v = _0;\r\n```\r\nBUT: `t.0` and `_0` have different types (`i32` vs. `&i32`) -> `v` has now a different type.\r\n\r\nI think that's acceptable: I think the destructure assist is mostly used in simple, immediate scopes and not huge existing code.\r\n\r\nAdditional Notes:\r\n* `ref` has same behaviour (-> `ref` is kept for items)\r\n  ```rust\r\n  let ref t = (1,2);\r\n  //      ^\r\n  ```\r\n  ->\r\n  ```rust\r\n  let (ref _0, ref _1) = (1,2);\r\n  ```\r\n* Rust IntelliJ Plugin: doesn't trigger with `&` or `ref` at all \r\n\r\n### mutable\r\n```rust\r\nlet mut t = (1,2);\r\n//      ^\r\n```\r\n->\r\n```rust\r\nlet (mut _0, mut _1) = (1,2);\r\n```\r\nand\r\n```rust\r\nlet t = &mut (1,2);\r\n//  ^\r\n```\r\n->\r\n```rust\r\nlet (_0, _1) = &mut (1,2);\r\n```\r\nAgain: with reference (`&mut`), `t.0` and `_0` have different types (`i32` vs `&mut i32`).  \r\nAnd there's an additional issue with `&mut` and assignment:\r\n```rust\r\nlet t = &mut (1,2);\r\n//  ^\r\nt.0 = 9;\r\n```\r\n->\r\n```rust\r\nlet (_0, _1) = &mut (1,2);\r\n_0 = 9;\r\n//   ^\r\n//   mismatched types\r\n//   expected `&mut {integer}`, found integer\r\n//   consider dereferencing here to assign to the mutable borrowed piece of memory\r\n```\r\nBut I think that's quite a niche use case, so I don't catch that (`*_0 = 9;`)\r\n\r\nAdditional Notes:\r\n* Rust IntelliJ Plugin: removes the `mut` (`let mut t = ...` -> `let (_0, _1) = ...`), doesn't trigger with `&mut`\r\n\r\n### Binding after ``@``\r\nDestructure tuple in sub-pattern is implemented:\r\n```rust\r\nlet t = (1,2);\r\n//  ^\r\nlet v = t.0;\r\nlet f = t.into();\r\n```\r\n->\r\n```rust\r\nlet t @ (_0, _1) = (1,2);\r\nlet v = _0;\r\nlet f = t.into();\r\n```\r\nBUT: Bindings after ``@`` aren't currently in stable and require `#![feature(bindings_after_at)]` (though should be generally [available quite soon](https://github.com/rust-lang/rust/pull/85305#event-5072889913) (with `1.56.0`)).  \r\nBut I don't know how to check for an enabled feature -> Destructure tuple in sub-pattern [isn't enabled](https://github.com/Booksbaum/rust-analyzer/blob/a4ee6c7954f910da3ca74fc0e25edda9077ad184/crates/ide_assists/src/handlers/destructure_tuple_binding.rs#L32) yet.\r\n\r\n* When Destructure in sub-pattern is enabled there are two assists:\r\n  * `Destructure tuple in place`:\r\n    ```rust\r\n    let t = (1,2);\r\n    //  ^\r\n    ```\r\n    ->\r\n    ```rust\r\n    let (_0, _1) = (1,2);\r\n    let v = _0;\r\n    let f = /*t*/.into();\r\n    ```\r\n  * `Destructure tuple in sub-pattern`:\r\n    ```rust\r\n    let t = (1,2);\r\n    //  ^\r\n    let v = t.0;\r\n    let f = t.into();\r\n    ```\r\n    ->\r\n    ```rust\r\n    let t @ (_0, _1) = (1,2);\r\n    let v = _0;\r\n    let f = t.into();\r\n    ```\r\n* When Destructure in sub-pattern is disabled, only the first one is available and just named `Destructure tuple`\r\n\r\n<br/>\r\n<br/>\r\n\r\n### Caveats\r\n* Unlike in #8673 or IntelliJ rust plugin, I'm not leaving the previous tuple name at function calls.  \r\n  **Reasoning**: It's not too unlikely the tuple variable shadows another variable. Destructuring the tuple while leaving the function call untouched, results in still a valid function call -- but now with another variable:\r\n  ```rust\r\n  let t = (8,9);\r\n  let t = (1,2);\r\n  //  ^\r\n  t.into()\r\n  ```\r\n  => Destructure Tuple\r\n  ```rust\r\n  let t = (8,9);\r\n  let (_0, _1) = (1,2);\r\n  t.into()\r\n  ```\r\n  `t.into()` is still valid -- using the first tuple.  \r\n  Instead I comment out the tuple usage, which results in invalid code -> must be handled by user:\r\n  ```rust\r\n  /*t*/.into()\r\n  ```\r\n  * (though that might be a biased decision: For testing I just declared a lot of `t`s and quite ofen in lines next to each other...)\r\n  * Issue: there are some cases that results in still valid code:\r\n    * macro that accept the tuple as well as no arguments:\r\n      ```rust\r\n      macro_rules! m {\r\n          () => { \"foo\" };\r\n          ($e:expr) => { $e; \"foo\" };\r\n      }\r\n      let t = (1,2);\r\n      m!(t);\r\n      m!(/*t*/);\r\n      ```\r\n      -> both calls are valid ([test](https://github.com/Booksbaum/rust-analyzer/blob/a4ee6c7954f910da3ca74fc0e25edda9077ad184/crates/ide_assists/src/handlers/destructure_tuple_binding.rs#L1474))  \r\n    * Probably with tuple as return value. Changing the return value most likely results in an error -- but in another place; not where the tuple usage was. \r\n\r\n  -> not sure that's the best way....  \r\n  Additional the tuple name surrounded by comment is more difficult to edit than just the name.\r\n* Code Assists don't support snippet placeholder, and rust analyzer just the first `$0` -> unfortunately no editing of generated tuple item variables. Cursor (`$0`) is placed on first generated item.\r\n\r\n<br/>\r\n<br/>\r\n\r\n### Issues\r\n* Tuple index usage in macro calls aren't converted:\r\n  ```rust\r\n  let t = (1,2);\r\n  //  ^\r\n  let v = t.0;\r\n  println!(\"{}\", t.0);\r\n  ```\r\n  ->\r\n  ```rust\r\n  let (_0, _1) = (1,2);\r\n  let v = _0;\r\n  println!(\"{}\", /*t*/.0);\r\n  ```\r\n  ([tests](https://github.com/Booksbaum/rust-analyzer/blob/a4ee6c7954f910da3ca74fc0e25edda9077ad184/crates/ide_assists/src/handlers/destructure_tuple_binding.rs#L1294))\r\n  * Issue is:  \r\n    [name.syntax()](https://github.com/Booksbaum/rust-analyzer/blob/a4ee6c7954f910da3ca74fc0e25edda9077ad184/crates/ide_assists/src/handlers/destructure_tuple_binding.rs#L242-L244) in each [usage](https://github.com/Booksbaum/rust-analyzer/blob/a4ee6c7954f910da3ca74fc0e25edda9077ad184/crates/ide_assists/src/handlers/destructure_tuple_binding.rs#L108-L113) of a tuple is syntax & text_range in its file.  \r\n    EXCEPT when tuple usage is in a macro call (`m!(t.0)`), the macro is expanded and syntax (and range) is based on that expanded macro, not in actual file.  \r\n    That leads to several things:\r\n    * I cannot differentiate between calling the macro with the tuple or with tuple item:\r\n      ```rust\r\n      macro_rules! m {\r\n          ($t:expr, $i:expr) => { $t.0 + $i };\r\n      }\r\n      let t = (1,2);\r\n      m!(t, t.0);\r\n      ```\r\n      -> both `t` usages are resolved as tuple index usage\r\n    * Range of resolved tuple index usage is in expanded macro, not in actual file  \r\n     -> don't know where to replace index usage\r\n\r\n    -> tuple items passed into a macro are ignored, and only the tuple name itself is handled (uncommented)\r\n* I'm not checking if the generated names conflict with already existing variables.\r\n  ```rust\r\n  let _0 = 42;            // >-|\r\n  let t = (1,2);          //   |\r\n  let v = _0;             // <-|\r\n  //  ^ 42\r\n  ```\r\n  => deconstruct tuple\r\n  ```rust\r\n  let _0 = 42;\r\n  let (_0, _1) = (1,2);     // >-|\r\n  let v = _0;               // <-|\r\n  //  ^ now 1\r\n  ```\r\n  * I tried to get the scope at tuple declaration and its usages. And then iterate all names with [`process_all_names`](https://github.com/rust-analyzer/rust-analyzer/blob/145b51f9daf5371f1754c09eb2e3a77e0a24a0dc/crates/hir/src/semantics.rs#L935). But that doesn't find all local names for declarations (`let t = (1,2)`) (for usages it does)\r\n  * This isn't unique to this Code Assist, but happen in others too (like `extract into variable` or `extract into function`). But here a name conflict is more likely (when destructuring multiple tuples, for examples nested ones (`let t = ((1,2),3)` -> `let (_0, _1) = ...` -> `let ((_0, _1), _1) = ...` -> error))\r\n  * IntelliJ rust plugin does handle this (-> name is `_00`)\n\nCo-authored-by: BooksBaum <15612932+Booksbaum@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59aa0918662c62159ad591ed281dab026875fb04", "html_url": "https://github.com/rust-lang/rust/commit/59aa0918662c62159ad591ed281dab026875fb04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59aa0918662c62159ad591ed281dab026875fb04/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f696fb51c335d700c2a4bda5a4e613272ded341f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f696fb51c335d700c2a4bda5a4e613272ded341f", "html_url": "https://github.com/rust-lang/rust/commit/f696fb51c335d700c2a4bda5a4e613272ded341f"}, {"sha": "8a9feeddd34d7a765e401613d8a4293b16660e29", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a9feeddd34d7a765e401613d8a4293b16660e29", "html_url": "https://github.com/rust-lang/rust/commit/8a9feeddd34d7a765e401613d8a4293b16660e29"}], "stats": {"total": 2169, "additions": 2169, "deletions": 0}, "files": [{"sha": "a421f57754672111a0e2e14c879ebc5a1e0af0c9", "filename": "crates/ide_assists/src/handlers/destructure_tuple_binding.rs", "status": "added", "additions": 2148, "deletions": 0, "changes": 2148, "blob_url": "https://github.com/rust-lang/rust/blob/59aa0918662c62159ad591ed281dab026875fb04/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59aa0918662c62159ad591ed281dab026875fb04/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs?ref=59aa0918662c62159ad591ed281dab026875fb04", "patch": "@@ -0,0 +1,2148 @@\n+use ide_db::{\n+    assists::{AssistId, AssistKind},\n+    defs::Definition,\n+    search::{FileReference, SearchScope, UsageSearchResult},\n+};\n+use itertools::Itertools;\n+use syntax::{\n+    ast::{self, AstNode, FieldExpr, IdentPat, MethodCallExpr, NameOwner},\n+    TextRange,\n+};\n+\n+use crate::assist_context::{AssistBuilder, AssistContext, Assists};\n+\n+// Assist: destructure_tuple_binding\n+//\n+// Destructures a tuple binding in place.\n+//\n+// ```\n+// fn main() {\n+//     let $0t = (1,2);\n+//     let v = t.0;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let ($0_0, _1) = (1,2);\n+//     let v = _0;\n+// }\n+// ```\n+pub(crate) fn destructure_tuple_binding(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    destructure_tuple_binding_impl(acc, ctx, false)\n+}\n+\n+// And when `with_sub_pattern` enabled (currently disabled):\n+// Assist: destructure_tuple_binding_in_sub_pattern\n+//\n+// Destructures tuple items in sub-pattern (after `@`).\n+//\n+// ```\n+// fn main() {\n+//     let $0t = (1,2);\n+//     let v = t.0;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let t @ ($0_0, _1) = (1,2);\n+//     let v = _0;\n+// }\n+// ```\n+pub(crate) fn destructure_tuple_binding_impl(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+    with_sub_pattern: bool,\n+) -> Option<()> {\n+    let ident_pat = ctx.find_node_at_offset::<ast::IdentPat>()?;\n+    let data = collect_data(ident_pat, ctx)?;\n+\n+    if with_sub_pattern {\n+        acc.add(\n+            AssistId(\"destructure_tuple_binding_in_sub_pattern\", AssistKind::RefactorRewrite),\n+            \"Destructure tuple in sub-pattern\",\n+            data.range,\n+            |builder| {\n+                edit_tuple_assignment(ctx, builder, &data, true);\n+                edit_tuple_usages(&data, builder, ctx, true);\n+            },\n+        );\n+    }\n+\n+    acc.add(\n+        AssistId(\"destructure_tuple_binding\", AssistKind::RefactorRewrite),\n+        if with_sub_pattern { \"Destructure tuple in place\" } else { \"Destructure tuple\" },\n+        data.range,\n+        |builder| {\n+            edit_tuple_assignment(ctx, builder, &data, false);\n+            edit_tuple_usages(&data, builder, ctx, false);\n+        },\n+    );\n+\n+    Some(())\n+}\n+\n+fn collect_data(ident_pat: IdentPat, ctx: &AssistContext) -> Option<TupleData> {\n+    if ident_pat.at_token().is_some() {\n+        // Cannot destructure pattern with sub-pattern:\n+        // Only IdentPat can have sub-pattern,\n+        // but not TuplePat (`(a,b)`).\n+        cov_mark::hit!(destructure_tuple_subpattern);\n+        return None;\n+    }\n+\n+    let ty = ctx.sema.type_of_pat(&ident_pat.clone().into())?.adjusted();\n+    let ref_type = if ty.is_mutable_reference() {\n+        Some(RefType::Mutable)\n+    } else if ty.is_reference() {\n+        Some(RefType::ReadOnly)\n+    } else {\n+        None\n+    };\n+    // might be reference\n+    let ty = ty.strip_references();\n+    // must be tuple\n+    let field_types = ty.tuple_fields(ctx.db());\n+    if field_types.is_empty() {\n+        cov_mark::hit!(destructure_tuple_no_tuple);\n+        return None;\n+    }\n+\n+    let name = ident_pat.name()?.to_string();\n+    let range = ident_pat.syntax().text_range();\n+\n+    let usages = ctx.sema.to_def(&ident_pat).map(|def| {\n+        Definition::Local(def)\n+            .usages(&ctx.sema)\n+            .in_scope(SearchScope::single_file(ctx.frange.file_id))\n+            .all()\n+    });\n+\n+    let field_names = (0..field_types.len())\n+        .map(|i| generate_name(ctx, i, &name, &ident_pat, &usages))\n+        .collect_vec();\n+\n+    Some(TupleData { ident_pat, range, ref_type, field_names, usages })\n+}\n+\n+fn generate_name(\n+    _ctx: &AssistContext,\n+    index: usize,\n+    _tuple_name: &str,\n+    _ident_pat: &IdentPat,\n+    _usages: &Option<UsageSearchResult>,\n+) -> String {\n+    // FIXME: detect if name already used\n+    format!(\"_{}\", index)\n+}\n+\n+enum RefType {\n+    ReadOnly,\n+    Mutable,\n+}\n+struct TupleData {\n+    ident_pat: IdentPat,\n+    // name: String,\n+    range: TextRange,\n+    ref_type: Option<RefType>,\n+    field_names: Vec<String>,\n+    // field_types: Vec<Type>,\n+    usages: Option<UsageSearchResult>,\n+}\n+fn edit_tuple_assignment(\n+    ctx: &AssistContext,\n+    builder: &mut AssistBuilder,\n+    data: &TupleData,\n+    in_sub_pattern: bool,\n+) {\n+    let tuple_pat = {\n+        let original = &data.ident_pat;\n+        let is_ref = original.ref_token().is_some();\n+        let is_mut = original.mut_token().is_some();\n+        let fields = data.field_names.iter().map(|name| {\n+            ast::Pat::from(ast::make::ident_pat(is_ref, is_mut, ast::make::name(name)))\n+        });\n+        ast::make::tuple_pat(fields)\n+    };\n+\n+    let add_cursor = |text: &str| {\n+        // place cursor on first tuple item\n+        let first_tuple = &data.field_names[0];\n+        text.replacen(first_tuple, &format!(\"$0{}\", first_tuple), 1)\n+    };\n+\n+    // with sub_pattern: keep original tuple and add subpattern: `tup @ (_0, _1)`\n+    if in_sub_pattern {\n+        let text = format!(\" @ {}\", tuple_pat.to_string());\n+        match ctx.config.snippet_cap {\n+            Some(cap) => {\n+                let snip = add_cursor(&text);\n+                builder.insert_snippet(cap, data.range.end(), snip);\n+            }\n+            None => builder.insert(data.range.end(), text),\n+        };\n+    } else {\n+        let text = tuple_pat.to_string();\n+        match ctx.config.snippet_cap {\n+            Some(cap) => {\n+                let snip = add_cursor(&text);\n+                builder.replace_snippet(cap, data.range, snip);\n+            }\n+            None => builder.replace(data.range, text),\n+        };\n+    }\n+}\n+\n+fn edit_tuple_usages(\n+    data: &TupleData,\n+    builder: &mut AssistBuilder,\n+    ctx: &AssistContext,\n+    in_sub_pattern: bool,\n+) {\n+    if let Some(usages) = data.usages.as_ref() {\n+        for (file_id, refs) in usages.iter() {\n+            builder.edit_file(*file_id);\n+\n+            for r in refs {\n+                edit_tuple_usage(ctx, builder, r, data, in_sub_pattern);\n+            }\n+        }\n+    }\n+}\n+fn edit_tuple_usage(\n+    ctx: &AssistContext,\n+    builder: &mut AssistBuilder,\n+    usage: &FileReference,\n+    data: &TupleData,\n+    in_sub_pattern: bool,\n+) {\n+    match detect_tuple_index(usage, data) {\n+        Some(index) => edit_tuple_field_usage(ctx, builder, data, index),\n+        None => {\n+            if in_sub_pattern {\n+                cov_mark::hit!(destructure_tuple_call_with_subpattern);\n+                return;\n+            }\n+\n+            // no index access -> make invalid -> requires handling by user\n+            // -> put usage in block comment\n+            //\n+            // Note: For macro invocations this might result in still valid code:\n+            //   When a macro accepts the tuple as argument, as well as no arguments at all,\n+            //   uncommenting the tuple still leaves the macro call working (see `tests::in_macro_call::empty_macro`).\n+            //   But this is an unlikely case. Usually the resulting macro call will become erroneous.\n+            builder.insert(usage.range.start(), \"/*\");\n+            builder.insert(usage.range.end(), \"*/\");\n+        }\n+    }\n+}\n+\n+fn edit_tuple_field_usage(\n+    ctx: &AssistContext,\n+    builder: &mut AssistBuilder,\n+    data: &TupleData,\n+    index: TupleIndex,\n+) {\n+    let field_name = &data.field_names[index.index];\n+\n+    if data.ref_type.is_some() {\n+        let ref_data = handle_ref_field_usage(ctx, &index.field_expr);\n+        builder.replace(ref_data.range, ref_data.format(field_name));\n+    } else {\n+        builder.replace(index.range, field_name);\n+    }\n+}\n+struct TupleIndex {\n+    index: usize,\n+    range: TextRange,\n+    field_expr: FieldExpr,\n+}\n+fn detect_tuple_index(usage: &FileReference, data: &TupleData) -> Option<TupleIndex> {\n+    // usage is IDENT\n+    // IDENT\n+    //  NAME_REF\n+    //   PATH_SEGMENT\n+    //    PATH\n+    //     PATH_EXPR\n+    //      PAREN_EXRP*\n+    //       FIELD_EXPR\n+\n+    let node = usage\n+        .name\n+        .syntax()\n+        .ancestors()\n+        .skip_while(|s| !ast::PathExpr::can_cast(s.kind()))\n+        .skip(1) // PATH_EXPR\n+        .find(|s| !ast::ParenExpr::can_cast(s.kind()))?; // skip parentheses\n+\n+    if let Some(field_expr) = ast::FieldExpr::cast(node) {\n+        let idx = field_expr.name_ref()?.as_tuple_field()?;\n+        if idx < data.field_names.len() {\n+            // special case: in macro call -> range of `field_expr` in applied macro, NOT range in actual file!\n+            if field_expr.syntax().ancestors().any(|a| ast::MacroStmts::can_cast(a.kind())) {\n+                cov_mark::hit!(destructure_tuple_macro_call);\n+\n+                // issue: cannot differentiate between tuple index passed into macro or tuple index as result of macro:\n+                // ```rust\n+                // macro_rules! m {\n+                //     ($t1:expr, $t2:expr) => { $t1; $t2.0 }\n+                // }\n+                // let t = (1,2);\n+                // m!(t.0, t)\n+                // ```\n+                // -> 2 tuple index usages detected!\n+                //\n+                // -> only handle `t`\n+                return None;\n+            }\n+\n+            Some(TupleIndex { index: idx, range: field_expr.syntax().text_range(), field_expr })\n+        } else {\n+            // tuple index out of range\n+            None\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+struct RefData {\n+    range: TextRange,\n+    needs_deref: bool,\n+    needs_parentheses: bool,\n+}\n+impl RefData {\n+    fn format(&self, field_name: &str) -> String {\n+        match (self.needs_deref, self.needs_parentheses) {\n+            (true, true) => format!(\"(*{})\", field_name),\n+            (true, false) => format!(\"*{}\", field_name),\n+            (false, true) => format!(\"({})\", field_name),\n+            (false, false) => field_name.to_string(),\n+        }\n+    }\n+}\n+fn handle_ref_field_usage(ctx: &AssistContext, field_expr: &FieldExpr) -> RefData {\n+    let s = field_expr.syntax();\n+    let mut ref_data =\n+        RefData { range: s.text_range(), needs_deref: true, needs_parentheses: true };\n+\n+    let parent = match s.parent().map(ast::Expr::cast) {\n+        Some(Some(parent)) => parent,\n+        Some(None) => {\n+            ref_data.needs_parentheses = false;\n+            return ref_data;\n+        }\n+        None => return ref_data,\n+    };\n+\n+    match parent {\n+        ast::Expr::ParenExpr(it) => {\n+            // already parens in place -> don't replace\n+            ref_data.needs_parentheses = false;\n+            // there might be a ref outside: `&(t.0)` -> can be removed\n+            if let Some(it) = it.syntax().parent().and_then(ast::RefExpr::cast) {\n+                ref_data.needs_deref = false;\n+                ref_data.range = it.syntax().text_range();\n+            }\n+        }\n+        ast::Expr::RefExpr(it) => {\n+            // `&*` -> cancel each other out\n+            ref_data.needs_deref = false;\n+            ref_data.needs_parentheses = false;\n+            // might be surrounded by parens -> can be removed too\n+            match it.syntax().parent().and_then(ast::ParenExpr::cast) {\n+                Some(parent) => ref_data.range = parent.syntax().text_range(),\n+                None => ref_data.range = it.syntax().text_range(),\n+            };\n+        }\n+        // higher precedence than deref `*`\n+        // https://doc.rust-lang.org/reference/expressions.html#expression-precedence\n+        // -> requires parentheses\n+        ast::Expr::PathExpr(_it) => {}\n+        ast::Expr::MethodCallExpr(it) => {\n+            // `field_expr` is `self_param` (otherwise it would be in `ArgList`)\n+\n+            // test if there's already auto-ref in place (`value` -> `&value`)\n+            // -> no method accepting `self`, but `&self` -> no need for deref\n+            //\n+            // other combinations (`&value` -> `value`, `&&value` -> `&value`, `&value` -> `&&value`) might or might not be able to auto-ref/deref,\n+            // but there might be trait implementations an added `&` might resolve to\n+            // -> ONLY handle auto-ref from `value` to `&value`\n+            fn is_auto_ref(ctx: &AssistContext, call_expr: &MethodCallExpr) -> bool {\n+                fn impl_(ctx: &AssistContext, call_expr: &MethodCallExpr) -> Option<bool> {\n+                    let rec = call_expr.receiver()?;\n+                    let rec_ty = ctx.sema.type_of_expr(&rec)?.adjusted();\n+                    // input must be actual value\n+                    if rec_ty.is_reference() {\n+                        return Some(false);\n+                    }\n+\n+                    // doesn't resolve trait impl\n+                    let f = ctx.sema.resolve_method_call(call_expr)?;\n+                    let self_param = f.self_param(ctx.db())?;\n+                    // self must be ref\n+                    match self_param.access(ctx.db()) {\n+                        hir::Access::Shared | hir::Access::Exclusive => Some(true),\n+                        hir::Access::Owned => Some(false),\n+                    }\n+                }\n+                impl_(ctx, call_expr).unwrap_or(false)\n+            }\n+\n+            if is_auto_ref(ctx, &it) {\n+                ref_data.needs_deref = false;\n+                ref_data.needs_parentheses = false;\n+            }\n+        }\n+        ast::Expr::FieldExpr(_it) => {\n+            // `t.0.my_field`\n+            ref_data.needs_deref = false;\n+            ref_data.needs_parentheses = false;\n+        }\n+        ast::Expr::IndexExpr(_it) => {\n+            // `t.0[1]`\n+            ref_data.needs_deref = false;\n+            ref_data.needs_parentheses = false;\n+        }\n+        ast::Expr::TryExpr(_it) => {\n+            // `t.0?`\n+            // requires deref and parens: `(*_0)`\n+        }\n+        // lower precedence than deref `*` -> no parens\n+        _ => {\n+            ref_data.needs_parentheses = false;\n+        }\n+    };\n+\n+    ref_data\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    // Tests for direct tuple destructure:\n+    // `let $0t = (1,2);` -> `let (_0, _1) = (1,2);`\n+\n+    fn assist(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+        destructure_tuple_binding_impl(acc, ctx, false)\n+    }\n+\n+    #[test]\n+    fn dont_trigger_on_unit() {\n+        cov_mark::check!(destructure_tuple_no_tuple);\n+        check_assist_not_applicable(\n+            assist,\n+            r#\"\n+fn main() {\n+let $0v = ();\n+}\n+            \"#,\n+        )\n+    }\n+    #[test]\n+    fn dont_trigger_on_number() {\n+        cov_mark::check!(destructure_tuple_no_tuple);\n+        check_assist_not_applicable(\n+            assist,\n+            r#\"\n+fn main() {\n+let $0v = 32;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn destructure_3_tuple() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let $0tup = (1,2,3);\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1, _2) = (1,2,3);\n+}\n+            \"#,\n+        )\n+    }\n+    #[test]\n+    fn destructure_2_tuple() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let $0tup = (1,2);\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+}\n+            \"#,\n+        )\n+    }\n+    #[test]\n+    fn replace_indices() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let $0tup = (1,2,3);\n+    let v1 = tup.0;\n+    let v2 = tup.1;\n+    let v3 = tup.2;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1, _2) = (1,2,3);\n+    let v1 = _0;\n+    let v2 = _1;\n+    let v3 = _2;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_usage_in_parentheses() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let $0tup = (1,2,3);\n+    let a = (tup).1;\n+    let b = ((tup)).1;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1, _2) = (1,2,3);\n+    let a = _1;\n+    let b = _1;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn handle_function_call() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let $0tup = (1,2);\n+    let v = tup.into();\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    let v = /*tup*/.into();\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn handle_invalid_index() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let $0tup = (1,2);\n+    let v = tup.3;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    let v = /*tup*/.3;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_replace_variable_with_same_name_as_tuple() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let tup = (1,2);\n+    let v = tup.1;\n+    let $0tup = (1,2,3);\n+    let v = tup.1;\n+    let tup = (1,2,3);\n+    let v = tup.1;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let tup = (1,2);\n+    let v = tup.1;\n+    let ($0_0, _1, _2) = (1,2,3);\n+    let v = _1;\n+    let tup = (1,2,3);\n+    let v = tup.1;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn keep_function_call_in_tuple_item() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let $0t = (\"3.14\", 0);\n+    let pi: f32 = t.0.parse().unwrap_or(0.0);\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1) = (\"3.14\", 0);\n+    let pi: f32 = _0.parse().unwrap_or(0.0);\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn keep_type() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let $0t: (usize, i32) = (1,2);\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1): (usize, i32) = (1,2);\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn destructure_reference() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let t = (1,2);\n+    let $0t = &t;\n+    let v = t.0;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let t = (1,2);\n+    let ($0_0, _1) = &t;\n+    let v = *_0;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn destructure_multiple_reference() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let t = (1,2);\n+    let $0t = &&t;\n+    let v = t.0;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let t = (1,2);\n+    let ($0_0, _1) = &&t;\n+    let v = *_0;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn keep_reference() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn foo(t: &(usize, usize)) -> usize {\n+    match t {\n+        &$0t => t.0\n+    }\n+}\n+            \"#,\n+            r#\"\n+fn foo(t: &(usize, usize)) -> usize {\n+    match t {\n+        &($0_0, _1) => _0\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn with_ref() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let ref $0t = (1,2);\n+    let v = t.0;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let (ref $0_0, ref _1) = (1,2);\n+    let v = *_0;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn with_mut() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let mut $0t = (1,2);\n+    t.0 = 42;\n+    let v = t.0;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let (mut $0_0, mut _1) = (1,2);\n+    _0 = 42;\n+    let v = _0;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn with_ref_mut() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let ref mut $0t = (1,2);\n+    t.0 = 42;\n+    let v = t.0;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let (ref mut $0_0, ref mut _1) = (1,2);\n+    *_0 = 42;\n+    let v = *_0;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_trigger_for_non_tuple_reference() {\n+        check_assist_not_applicable(\n+            assist,\n+            r#\"\n+fn main() {\n+    let v = 42;\n+    let $0v = &42;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_trigger_on_static_tuple() {\n+        check_assist_not_applicable(\n+            assist,\n+            r#\"\n+static $0TUP: (usize, usize) = (1,2);\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_trigger_on_wildcard() {\n+        check_assist_not_applicable(\n+            assist,\n+            r#\"\n+fn main() {\n+    let $0_ = (1,2);\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_trigger_in_struct() {\n+        check_assist_not_applicable(\n+            assist,\n+            r#\"\n+struct S {\n+    $0tup: (usize, usize),\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_trigger_in_struct_creation() {\n+        check_assist_not_applicable(\n+            assist,\n+            r#\"\n+struct S {\n+    tup: (usize, usize),\n+}\n+fn main() {\n+    let s = S {\n+        $0tup: (1,2),\n+    };\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_trigger_on_tuple_struct() {\n+        check_assist_not_applicable(\n+            assist,\n+            r#\"\n+struct S(usize, usize);\n+fn main() {\n+    let $0s = S(1,2);\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_trigger_when_subpattern_exists() {\n+        // sub-pattern is only allowed with IdentPat (name), not other patterns (like TuplePat)\n+        cov_mark::check!(destructure_tuple_subpattern);\n+        check_assist_not_applicable(\n+            assist,\n+            r#\"\n+fn sum(t: (usize, usize)) -> usize {\n+    match t {\n+        $0t @ (1..=3,1..=3) => t.0 + t.1,\n+        _ => 0,\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn in_subpattern() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let t1 @ (_, $0t2) = (1, (2,3));\n+    let v = t1.0 + t2.0 + t2.1;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let t1 @ (_, ($0_0, _1)) = (1, (2,3));\n+    let v = t1.0 + _0 + _1;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn in_nested_tuple() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let ($0tup, v) = ((1,2),3);\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let (($0_0, _1), v) = ((1,2),3);\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn in_closure() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let $0tup = (1,2,3);\n+    let f = |v| v + tup.1;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1, _2) = (1,2,3);\n+    let f = |v| v + _1;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn in_closure_args() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let f = |$0t| t.0 + t.1;\n+    let v = f((1,2));\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let f = |($0_0, _1)| _0 + _1;\n+    let v = f((1,2));\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn in_function_args() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn f($0t: (usize, usize)) {\n+    let v = t.0;\n+}\n+            \"#,\n+            r#\"\n+fn f(($0_0, _1): (usize, usize)) {\n+    let v = _0;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn in_if_let() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn f(t: (usize, usize)) {\n+    if let $0t = t {\n+        let v = t.0;\n+    }\n+}\n+            \"#,\n+            r#\"\n+fn f(t: (usize, usize)) {\n+    if let ($0_0, _1) = t {\n+        let v = _0;\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+    #[test]\n+    fn in_if_let_option() {\n+        check_assist(\n+            assist,\n+            r#\"\n+//- minicore: option\n+fn f(o: Option<(usize, usize)>) {\n+    if let Some($0t) = o {\n+        let v = t.0;\n+    }\n+}\n+            \"#,\n+            r#\"\n+fn f(o: Option<(usize, usize)>) {\n+    if let Some(($0_0, _1)) = o {\n+        let v = _0;\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn in_match() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    match (1,2) {\n+        $0t => t.1,\n+    };\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    match (1,2) {\n+        ($0_0, _1) => _1,\n+    };\n+}\n+            \"#,\n+        )\n+    }\n+    #[test]\n+    fn in_match_option() {\n+        check_assist(\n+            assist,\n+            r#\"\n+//- minicore: option\n+fn main() {\n+    match Some((1,2)) {\n+        Some($0t) => t.1,\n+        _ => 0,\n+    };\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    match Some((1,2)) {\n+        Some(($0_0, _1)) => _1,\n+        _ => 0,\n+    };\n+}\n+            \"#,\n+        )\n+    }\n+    #[test]\n+    fn in_match_reference_option() {\n+        check_assist(\n+            assist,\n+            r#\"\n+//- minicore: option\n+fn main() {\n+    let t = (1,2);\n+    match Some(&t) {\n+        Some($0t) => t.1,\n+        _ => 0,\n+    };\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let t = (1,2);\n+    match Some(&t) {\n+        Some(($0_0, _1)) => *_1,\n+        _ => 0,\n+    };\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn in_for() {\n+        check_assist(\n+            assist,\n+            r#\"\n+//- minicore: iterators\n+fn main() {\n+    for $0t in core::iter::repeat((1,2))  {\n+        let v = t.1;\n+    }\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    for ($0_0, _1) in core::iter::repeat((1,2))  {\n+        let v = _1;\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+    #[test]\n+    fn in_for_nested() {\n+        check_assist(\n+            assist,\n+            r#\"\n+//- minicore: iterators\n+fn main() {\n+    for (a, $0b) in core::iter::repeat((1,(2,3)))  {\n+        let v = b.1;\n+    }\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    for (a, ($0_0, _1)) in core::iter::repeat((1,(2,3)))  {\n+        let v = _1;\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_on_tuple_usage() {\n+        //Improvement: might be reasonable to allow & implement\n+        check_assist_not_applicable(\n+            assist,\n+            r#\"\n+fn main() {\n+    let t = (1,2);\n+    let v = $0t.0;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_all() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main() {\n+    let $0t = (1,2);\n+    let v = t.1;\n+    let s = (t.0 + t.1) / 2;\n+    let f = |v| v + t.0;\n+    let r = f(t.1);\n+    let e = t == (9,0);\n+    let m =\n+      match t {\n+        (_,2) if t.0 > 2 => 1,\n+        _ => 0,\n+      };\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    let v = _1;\n+    let s = (_0 + _1) / 2;\n+    let f = |v| v + _0;\n+    let r = f(_1);\n+    let e = /*t*/ == (9,0);\n+    let m =\n+      match /*t*/ {\n+        (_,2) if _0 > 2 => 1,\n+        _ => 0,\n+      };\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn non_trivial_tuple_assignment() {\n+        check_assist(\n+            assist,\n+            r#\"\n+fn main {\n+    let $0t =\n+        if 1 > 2 {\n+            (1,2)\n+        } else {\n+            (5,6)\n+        };\n+    let v1 = t.0;\n+    let v2 =\n+        if t.0 > t.1 {\n+            t.0 - t.1\n+        } else {\n+            t.1 - t.0\n+        };\n+}\n+            \"#,\n+            r#\"\n+fn main {\n+    let ($0_0, _1) =\n+        if 1 > 2 {\n+            (1,2)\n+        } else {\n+            (5,6)\n+        };\n+    let v1 = _0;\n+    let v2 =\n+        if _0 > _1 {\n+            _0 - _1\n+        } else {\n+            _1 - _0\n+        };\n+}\n+            \"#,\n+        )\n+    }\n+\n+    mod assist {\n+        use super::*;\n+        use crate::tests::check_assist_by_label;\n+\n+        fn assist(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+            destructure_tuple_binding_impl(acc, ctx, true)\n+        }\n+        fn in_place_assist(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+            destructure_tuple_binding_impl(acc, ctx, false)\n+        }\n+\n+        pub(crate) fn check_in_place_assist(ra_fixture_before: &str, ra_fixture_after: &str) {\n+            check_assist_by_label(\n+                in_place_assist,\n+                ra_fixture_before,\n+                ra_fixture_after,\n+                // \"Destructure tuple in place\",\n+                \"Destructure tuple\",\n+            );\n+        }\n+\n+        pub(crate) fn check_sub_pattern_assist(ra_fixture_before: &str, ra_fixture_after: &str) {\n+            check_assist_by_label(\n+                assist,\n+                ra_fixture_before,\n+                ra_fixture_after,\n+                \"Destructure tuple in sub-pattern\",\n+            );\n+        }\n+\n+        pub(crate) fn check_both_assists(\n+            ra_fixture_before: &str,\n+            ra_fixture_after_in_place: &str,\n+            ra_fixture_after_in_sub_pattern: &str,\n+        ) {\n+            check_in_place_assist(ra_fixture_before, ra_fixture_after_in_place);\n+            check_sub_pattern_assist(ra_fixture_before, ra_fixture_after_in_sub_pattern);\n+        }\n+    }\n+\n+    /// Tests for destructure of tuple in sub-pattern:\n+    /// `let $0t = (1,2);` -> `let t @ (_0, _1) = (1,2);`\n+    mod sub_pattern {\n+        use super::assist::*;\n+        use super::*;\n+        use crate::tests::check_assist_by_label;\n+\n+        #[test]\n+        fn destructure_in_sub_pattern() {\n+            check_sub_pattern_assist(\n+                r#\"\n+#![feature(bindings_after_at)]\n+\n+fn main() {\n+    let $0t = (1,2);\n+}\n+                \"#,\n+                r#\"\n+#![feature(bindings_after_at)]\n+\n+fn main() {\n+    let t @ ($0_0, _1) = (1,2);\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn trigger_both_destructure_tuple_assists() {\n+            fn assist(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+                destructure_tuple_binding_impl(acc, ctx, true)\n+            }\n+            let text = r#\"\n+fn main() {\n+    let $0t = (1,2);\n+}\n+            \"#;\n+            check_assist_by_label(\n+                assist,\n+                text,\n+                r#\"\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+}\n+            \"#,\n+                \"Destructure tuple in place\",\n+            );\n+            check_assist_by_label(\n+                assist,\n+                text,\n+                r#\"\n+fn main() {\n+    let t @ ($0_0, _1) = (1,2);\n+}\n+            \"#,\n+                \"Destructure tuple in sub-pattern\",\n+            );\n+        }\n+\n+        #[test]\n+        fn replace_indices() {\n+            check_sub_pattern_assist(\n+                r#\"\n+fn main() {\n+    let $0t = (1,2);\n+    let v1 = t.0;\n+    let v2 = t.1;\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let t @ ($0_0, _1) = (1,2);\n+    let v1 = _0;\n+    let v2 = _1;\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn keep_function_call() {\n+            cov_mark::check!(destructure_tuple_call_with_subpattern);\n+            check_sub_pattern_assist(\n+                r#\"\n+fn main() {\n+    let $0t = (1,2);\n+    let v = t.into();\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let t @ ($0_0, _1) = (1,2);\n+    let v = t.into();\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn keep_type() {\n+            check_sub_pattern_assist(\n+                r#\"\n+fn main() {\n+    let $0t: (usize, i32) = (1,2);\n+    let v = t.1;\n+    let f = t.into();\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let t @ ($0_0, _1): (usize, i32) = (1,2);\n+    let v = _1;\n+    let f = t.into();\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn in_function_args() {\n+            check_sub_pattern_assist(\n+                r#\"\n+fn f($0t: (usize, usize)) {\n+    let v = t.0;\n+    let f = t.into();\n+}\n+                \"#,\n+                r#\"\n+fn f(t @ ($0_0, _1): (usize, usize)) {\n+    let v = _0;\n+    let f = t.into();\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn with_ref() {\n+            check_sub_pattern_assist(\n+                r#\"\n+fn main() {\n+    let ref $0t = (1,2);\n+    let v = t.1;\n+    let f = t.into();\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let ref t @ (ref $0_0, ref _1) = (1,2);\n+    let v = *_1;\n+    let f = t.into();\n+}\n+                \"#,\n+            )\n+        }\n+        #[test]\n+        fn with_mut() {\n+            check_sub_pattern_assist(\n+                r#\"\n+fn main() {\n+    let mut $0t = (1,2);\n+    let v = t.1;\n+    let f = t.into();\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let mut t @ (mut $0_0, mut _1) = (1,2);\n+    let v = _1;\n+    let f = t.into();\n+}\n+                \"#,\n+            )\n+        }\n+        #[test]\n+        fn with_ref_mut() {\n+            check_sub_pattern_assist(\n+                r#\"\n+fn main() {\n+    let ref mut $0t = (1,2);\n+    let v = t.1;\n+    let f = t.into();\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let ref mut t @ (ref mut $0_0, ref mut _1) = (1,2);\n+    let v = *_1;\n+    let f = t.into();\n+}\n+                \"#,\n+            )\n+        }\n+    }\n+\n+    /// Tests for tuple usage in macro call:\n+    /// `println!(\"{}\", t.0)`\n+    mod in_macro_call {\n+        use super::assist::*;\n+\n+        #[test]\n+        fn detect_macro_call() {\n+            cov_mark::check!(destructure_tuple_macro_call);\n+            check_in_place_assist(\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let $0t = (1,2);\n+    m!(t.0);\n+}\n+                \"#,\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    m!(/*t*/.0);\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn tuple_usage() {\n+            check_both_assists(\n+                // leading `\"foo\"` to ensure `$e` doesn't start at position `0`\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let $0t = (1,2);\n+    m!(t);\n+}\n+                \"#,\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    m!(/*t*/);\n+}\n+                \"#,\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let t @ ($0_0, _1) = (1,2);\n+    m!(t);\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn tuple_function_usage() {\n+            check_both_assists(\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let $0t = (1,2);\n+    m!(t.into());\n+}\n+                \"#,\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    m!(/*t*/.into());\n+}\n+                \"#,\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let t @ ($0_0, _1) = (1,2);\n+    m!(t.into());\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn tuple_index_usage() {\n+            check_both_assists(\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let $0t = (1,2);\n+    m!(t.0);\n+}\n+                \"#,\n+                // FIXME: replace `t.0` with `_0` (cannot detect range of tuple index in macro call)\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    m!(/*t*/.0);\n+}\n+                \"#,\n+                // FIXME: replace `t.0` with `_0`\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let t @ ($0_0, _1) = (1,2);\n+    m!(t.0);\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn tuple_in_parentheses_index_usage() {\n+            check_both_assists(\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let $0t = (1,2);\n+    m!((t).0);\n+}\n+                \"#,\n+                // FIXME: replace `(t).0` with `_0`\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    m!((/*t*/).0);\n+}\n+                \"#,\n+                // FIXME: replace `(t).0` with `_0`\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let t @ ($0_0, _1) = (1,2);\n+    m!((t).0);\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn empty_macro() {\n+            check_in_place_assist(\n+                r#\"\n+macro_rules! m {\n+    () => { \"foo\" };\n+    ($e:expr) => { $e; \"foo\" };\n+}\n+\n+fn main() {\n+    let $0t = (1,2);\n+    m!(t);\n+}\n+                \"#,\n+                // FIXME: macro allows no arg -> is valid. But assist should result in invalid code\n+                r#\"\n+macro_rules! m {\n+    () => { \"foo\" };\n+    ($e:expr) => { $e; \"foo\" };\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    m!(/*t*/);\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn tuple_index_in_macro() {\n+            check_both_assists(\n+                r#\"\n+macro_rules! m {\n+    ($t:expr, $i:expr) => { $t.0 + $i };\n+}\n+\n+fn main() {\n+    let $0t = (1,2);\n+    m!(t, t.0);\n+}\n+                \"#,\n+                // FIXME: replace `t.0` in macro call (not IN macro) with `_0`\n+                r#\"\n+macro_rules! m {\n+    ($t:expr, $i:expr) => { $t.0 + $i };\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    m!(/*t*/, /*t*/.0);\n+}\n+                \"#,\n+                // FIXME: replace `t.0` in macro call with `_0`\n+                r#\"\n+macro_rules! m {\n+    ($t:expr, $i:expr) => { $t.0 + $i };\n+}\n+\n+fn main() {\n+    let t @ ($0_0, _1) = (1,2);\n+    m!(t, t.0);\n+}\n+                \"#,\n+            )\n+        }\n+    }\n+\n+    mod refs {\n+        use super::assist::*;\n+\n+        #[test]\n+        fn no_ref() {\n+            check_in_place_assist(\n+                r#\"\n+fn main() {\n+    let $0t = &(1,2);\n+    let v: i32 = t.0;\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let ($0_0, _1) = &(1,2);\n+    let v: i32 = *_0;\n+}\n+                \"#,\n+            )\n+        }\n+        #[test]\n+        fn no_ref_with_parens() {\n+            check_in_place_assist(\n+                r#\"\n+fn main() {\n+    let $0t = &(1,2);\n+    let v: i32 = (t.0);\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let ($0_0, _1) = &(1,2);\n+    let v: i32 = (*_0);\n+}\n+                \"#,\n+            )\n+        }\n+        #[test]\n+        fn with_ref() {\n+            check_in_place_assist(\n+                r#\"\n+fn main() {\n+    let $0t = &(1,2);\n+    let v: &i32 = &t.0;\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let ($0_0, _1) = &(1,2);\n+    let v: &i32 = _0;\n+}\n+                \"#,\n+            )\n+        }\n+        #[test]\n+        fn with_ref_in_parens_ref() {\n+            check_in_place_assist(\n+                r#\"\n+fn main() {\n+    let $0t = &(1,2);\n+    let v: &i32 = &(t.0);\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let ($0_0, _1) = &(1,2);\n+    let v: &i32 = _0;\n+}\n+                \"#,\n+            )\n+        }\n+        #[test]\n+        fn with_ref_in_ref_parens() {\n+            check_in_place_assist(\n+                r#\"\n+fn main() {\n+    let $0t = &(1,2);\n+    let v: &i32 = (&t.0);\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let ($0_0, _1) = &(1,2);\n+    let v: &i32 = _0;\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn deref_and_parentheses() {\n+            // Operator/Expressions with higher precedence than deref (`*`):\n+            // https://doc.rust-lang.org/reference/expressions.html#expression-precedence\n+            // * Path\n+            // * Method call\n+            // * Field expression\n+            // * Function calls, array indexing\n+            // * `?`\n+            check_in_place_assist(\n+                r#\"\n+//- minicore: option\n+fn f1(v: i32) {}\n+fn f2(v: &i32) {}\n+trait T {\n+    fn do_stuff(self) {}\n+}\n+impl T for i32 {\n+    fn do_stuff(self) {}\n+}\n+impl T for &i32 {\n+    fn do_stuff(self) {}\n+}\n+struct S4 {\n+    value: i32,\n+}\n+\n+fn foo() -> Option<()> {\n+    let $0t = &(0, (1,\"1\"), Some(2), [3;3], S4 { value: 4 }, &5);\n+    let v: i32 = t.0;           // deref, no parens\n+    let v: &i32 = &t.0;         // no deref, no parens, remove `&`\n+    f1(t.0);                    // deref, no parens\n+    f2(&t.0);                   // `&*` -> cancel out -> no deref, no parens\n+    // https://github.com/rust-analyzer/rust-analyzer/issues/1109#issuecomment-658868639\n+    // let v: i32 = t.1.0;      // no deref, no parens\n+    let v: i32 = t.4.value;     // no deref, no parens\n+    t.0.do_stuff();             // deref, parens\n+    let v: i32 = t.2?;          // deref, parens\n+    let v: i32 = t.3[0];        // no deref, no parens\n+    (t.0).do_stuff();           // deref, no additional parens\n+    let v: i32 = *t.5;          // deref (-> 2), no parens\n+\n+    None\n+}\n+                \"#,\n+                r#\"\n+fn f1(v: i32) {}\n+fn f2(v: &i32) {}\n+trait T {\n+    fn do_stuff(self) {}\n+}\n+impl T for i32 {\n+    fn do_stuff(self) {}\n+}\n+impl T for &i32 {\n+    fn do_stuff(self) {}\n+}\n+struct S4 {\n+    value: i32,\n+}\n+\n+fn foo() -> Option<()> {\n+    let ($0_0, _1, _2, _3, _4, _5) = &(0, (1,\"1\"), Some(2), [3;3], S4 { value: 4 }, &5);\n+    let v: i32 = *_0;           // deref, no parens\n+    let v: &i32 = _0;         // no deref, no parens, remove `&`\n+    f1(*_0);                    // deref, no parens\n+    f2(_0);                   // `&*` -> cancel out -> no deref, no parens\n+    // https://github.com/rust-analyzer/rust-analyzer/issues/1109#issuecomment-658868639\n+    // let v: i32 = t.1.0;      // no deref, no parens\n+    let v: i32 = _4.value;     // no deref, no parens\n+    (*_0).do_stuff();             // deref, parens\n+    let v: i32 = (*_2)?;          // deref, parens\n+    let v: i32 = _3[0];        // no deref, no parens\n+    (*_0).do_stuff();           // deref, no additional parens\n+    let v: i32 = **_5;          // deref (-> 2), no parens\n+\n+    None\n+}\n+                \"#,\n+            )\n+        }\n+\n+        // ---------\n+        // auto-ref/deref\n+\n+        #[test]\n+        fn self_auto_ref_doesnt_need_deref() {\n+            check_in_place_assist(\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+  fn f(&self) {}\n+}\n+\n+fn main() {\n+    let $0t = &(S,2);\n+    let s = t.0.f();\n+}\n+                \"#,\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+  fn f(&self) {}\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = &(S,2);\n+    let s = _0.f();\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn self_owned_requires_deref() {\n+            check_in_place_assist(\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+  fn f(self) {}\n+}\n+\n+fn main() {\n+    let $0t = &(S,2);\n+    let s = t.0.f();\n+}\n+                \"#,\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+  fn f(self) {}\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = &(S,2);\n+    let s = (*_0).f();\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn self_auto_ref_in_trait_call_doesnt_require_deref() {\n+            check_in_place_assist(\n+                r#\"\n+trait T {\n+    fn f(self);\n+}\n+#[derive(Clone, Copy)]\n+struct S;\n+impl T for &S {\n+    fn f(self) {}\n+}\n+\n+fn main() {\n+    let $0t = &(S,2);\n+    let s = t.0.f();\n+}\n+                \"#,\n+                // FIXME: doesn't need deref * parens. But `ctx.sema.resolve_method_call` doesn't resolve trait implementations\n+                r#\"\n+trait T {\n+    fn f(self);\n+}\n+#[derive(Clone, Copy)]\n+struct S;\n+impl T for &S {\n+    fn f(self) {}\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = &(S,2);\n+    let s = (*_0).f();\n+}\n+                \"#,\n+            )\n+        }\n+        #[test]\n+        fn no_auto_deref_because_of_owned_and_ref_trait_impl() {\n+            check_in_place_assist(\n+                r#\"\n+trait T {\n+    fn f(self);\n+}\n+#[derive(Clone, Copy)]\n+struct S;\n+impl T for S {\n+    fn f(self) {}\n+}\n+impl T for &S {\n+    fn f(self) {}\n+}\n+\n+fn main() {\n+    let $0t = &(S,2);\n+    let s = t.0.f();\n+}\n+                \"#,\n+                r#\"\n+trait T {\n+    fn f(self);\n+}\n+#[derive(Clone, Copy)]\n+struct S;\n+impl T for S {\n+    fn f(self) {}\n+}\n+impl T for &S {\n+    fn f(self) {}\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = &(S,2);\n+    let s = (*_0).f();\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn no_outer_parens_when_ref_deref() {\n+            check_in_place_assist(\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+    fn do_stuff(&self) -> i32 { 42 }\n+}\n+fn main() {\n+    let $0t = &(S,&S);\n+    let v = (&t.0).do_stuff();\n+}\n+                \"#,\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+    fn do_stuff(&self) -> i32 { 42 }\n+}\n+fn main() {\n+    let ($0_0, _1) = &(S,&S);\n+    let v = _0.do_stuff();\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn auto_ref_deref() {\n+            check_in_place_assist(\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+    fn do_stuff(&self) -> i32 { 42 }\n+}\n+fn main() {\n+    let $0t = &(S,&S);\n+    let v = (&t.0).do_stuff();      // no deref, remove parens\n+    // `t.0` gets auto-refed -> no deref needed -> no parens\n+    let v = t.0.do_stuff();         // no deref, no parens\n+    let v = &t.0.do_stuff();        // `&` is for result -> no deref, no parens\n+    // deref: `_1` is `&&S`, but method called is on `&S` -> there might be a method accepting `&&S`\n+    let v = t.1.do_stuff();         // deref, parens\n+}\n+                \"#,\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+    fn do_stuff(&self) -> i32 { 42 }\n+}\n+fn main() {\n+    let ($0_0, _1) = &(S,&S);\n+    let v = _0.do_stuff();      // no deref, remove parens\n+    // `t.0` gets auto-refed -> no deref needed -> no parens\n+    let v = _0.do_stuff();         // no deref, no parens\n+    let v = &_0.do_stuff();        // `&` is for result -> no deref, no parens\n+    // deref: `_1` is `&&S`, but method called is on `&S` -> there might be a method accepting `&&S`\n+    let v = (*_1).do_stuff();         // deref, parens\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn mutable() {\n+            check_in_place_assist(\n+                r#\"\n+fn f_owned(v: i32) {}\n+fn f(v: &i32) {}\n+fn f_mut(v: &mut i32) { *v = 42; }\n+\n+fn main() {\n+    let $0t = &mut (1,2);\n+    let v = t.0;\n+    t.0 = 42;\n+    f_owned(t.0);\n+    f(&t.0);\n+    f_mut(&mut t.0);\n+}\n+                \"#,\n+                r#\"\n+fn f_owned(v: i32) {}\n+fn f(v: &i32) {}\n+fn f_mut(v: &mut i32) { *v = 42; }\n+\n+fn main() {\n+    let ($0_0, _1) = &mut (1,2);\n+    let v = *_0;\n+    *_0 = 42;\n+    f_owned(*_0);\n+    f(_0);\n+    f_mut(_0);\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn with_ref_keyword() {\n+            check_in_place_assist(\n+                r#\"\n+fn f_owned(v: i32) {}\n+fn f(v: &i32) {}\n+\n+fn main() {\n+    let ref $0t = (1,2);\n+    let v = t.0;\n+    f_owned(t.0);\n+    f(&t.0);\n+}\n+                \"#,\n+                r#\"\n+fn f_owned(v: i32) {}\n+fn f(v: &i32) {}\n+\n+fn main() {\n+    let (ref $0_0, ref _1) = (1,2);\n+    let v = *_0;\n+    f_owned(*_0);\n+    f(_0);\n+}\n+                \"#,\n+            )\n+        }\n+        #[test]\n+        fn with_ref_mut_keywords() {\n+            check_in_place_assist(\n+                r#\"\n+fn f_owned(v: i32) {}\n+fn f(v: &i32) {}\n+fn f_mut(v: &mut i32) { *v = 42; }\n+\n+fn main() {\n+    let ref mut $0t = (1,2);\n+    let v = t.0;\n+    t.0 = 42;\n+    f_owned(t.0);\n+    f(&t.0);\n+    f_mut(&mut t.0);\n+}\n+                \"#,\n+                r#\"\n+fn f_owned(v: i32) {}\n+fn f(v: &i32) {}\n+fn f_mut(v: &mut i32) { *v = 42; }\n+\n+fn main() {\n+    let (ref mut $0_0, ref mut _1) = (1,2);\n+    let v = *_0;\n+    *_0 = 42;\n+    f_owned(*_0);\n+    f(_0);\n+    f_mut(_0);\n+}\n+                \"#,\n+            )\n+        }\n+    }\n+}"}, {"sha": "7c074a4f63210a7ecc4729c69d3593f8a4429861", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59aa0918662c62159ad591ed281dab026875fb04/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59aa0918662c62159ad591ed281dab026875fb04/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=59aa0918662c62159ad591ed281dab026875fb04", "patch": "@@ -62,6 +62,7 @@ mod handlers {\n     mod convert_iter_for_each_to_for;\n     mod convert_tuple_struct_to_named_struct;\n     mod convert_to_guarded_return;\n+    mod destructure_tuple_binding;\n     mod expand_glob_import;\n     mod extract_function;\n     mod extract_struct_from_enum_variant;\n@@ -134,6 +135,7 @@ mod handlers {\n             convert_iter_for_each_to_for::convert_iter_for_each_to_for,\n             convert_to_guarded_return::convert_to_guarded_return,\n             convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n+            destructure_tuple_binding::destructure_tuple_binding,\n             expand_glob_import::expand_glob_import,\n             extract_struct_from_enum_variant::extract_struct_from_enum_variant,\n             extract_type_alias::extract_type_alias,"}, {"sha": "21daaf46c4c56ef95fd45222c70f942a762cbd87", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/59aa0918662c62159ad591ed281dab026875fb04/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59aa0918662c62159ad591ed281dab026875fb04/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=59aa0918662c62159ad591ed281dab026875fb04", "patch": "@@ -367,6 +367,25 @@ impl Point {\n     )\n }\n \n+#[test]\n+fn doctest_destructure_tuple_binding() {\n+    check_doc_test(\n+        \"destructure_tuple_binding\",\n+        r#####\"\n+fn main() {\n+    let $0t = (1,2);\n+    let v = t.0;\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    let v = _0;\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_expand_glob_import() {\n     check_doc_test("}]}