{"sha": "8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNjFmZjI1ZDg1ZGNkYzgxYzU1ZjUxYmEyYTc3N2UxM2U1NjFhMjU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-12-10T06:45:58Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-12-19T20:57:00Z"}, "message": "Optimize `ast::PathSegment`.", "tree": {"sha": "686664d55e46afdf746f673e509896aec0e5105e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/686664d55e46afdf746f673e509896aec0e5105e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "html_url": "https://github.com/rust-lang/rust/commit/8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcae8bfb409c6b4f67b57a52b36bcecd4eafa3a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcae8bfb409c6b4f67b57a52b36bcecd4eafa3a4", "html_url": "https://github.com/rust-lang/rust/commit/dcae8bfb409c6b4f67b57a52b36bcecd4eafa3a4"}], "stats": {"total": 296, "additions": 86, "deletions": 210}, "files": [{"sha": "e8c3492705a3f95da1e4886b661479e9748a27c6", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "patch": "@@ -433,13 +433,19 @@ impl<'a> LoweringContext<'a> {\n                           segment: &PathSegment,\n                           param_mode: ParamMode)\n                           -> hir::PathSegment {\n-        let parameters = match segment.parameters {\n-            PathParameters::AngleBracketed(ref data) => {\n-                let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n-                hir::AngleBracketedParameters(data)\n+        let parameters = if let Some(ref parameters) = segment.parameters {\n+            match **parameters {\n+                PathParameters::AngleBracketed(ref data) => {\n+                    let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n+                    hir::AngleBracketedParameters(data)\n+                }\n+                PathParameters::Parenthesized(ref data) => {\n+                    hir::ParenthesizedParameters(self.lower_parenthesized_parameter_data(data))\n+                }\n             }\n-            PathParameters::Parenthesized(ref data) =>\n-                hir::ParenthesizedParameters(self.lower_parenthesized_parameter_data(data)),\n+        } else {\n+            let data = self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode);\n+            hir::AngleBracketedParameters(data)\n         };\n \n         hir::PathSegment {"}, {"sha": "bc150b847786f2c08531e847d08061b2f9600d3d", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "patch": "@@ -171,7 +171,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         match item.node {\n             ItemKind::Use(ref view_path) => {\n                 let path = view_path.node.path();\n-                if !path.segments.iter().all(|segment| segment.parameters.is_empty()) {\n+                if path.segments.iter().any(|segment| segment.parameters.is_some()) {\n                     self.err_handler()\n                         .span_err(path.span, \"type or lifetime parameters in import path\");\n                 }\n@@ -275,7 +275,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_vis(&mut self, vis: &'a Visibility) {\n         match *vis {\n             Visibility::Restricted { ref path, .. } => {\n-                if !path.segments.iter().all(|segment| segment.parameters.is_empty()) {\n+                if !path.segments.iter().all(|segment| segment.parameters.is_none()) {\n                     self.err_handler()\n                         .span_err(path.span, \"type or lifetime parameters in visibility path\");\n                 }"}, {"sha": "821820df8388be92bfa224949e5b95dffc87b57e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "patch": "@@ -62,7 +62,7 @@ use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Local, Mutability, Pat, PatKind, Path};\n-use syntax::ast::{PathSegment, PathParameters, QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n+use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n \n use syntax_pos::{Span, DUMMY_SP};\n use errors::DiagnosticBuilder;\n@@ -2960,14 +2960,9 @@ impl<'a> Resolver<'a> {\n                 if ident.name == lookup_name && ns == namespace {\n                     if filter_fn(name_binding.def()) {\n                         // create the path\n-                        let params = PathParameters::none();\n-                        let segment = PathSegment {\n-                            identifier: ident,\n-                            parameters: params,\n-                        };\n                         let span = name_binding.span;\n                         let mut segms = path_segments.clone();\n-                        segms.push(segment);\n+                        segms.push(ident.into());\n                         let path = Path {\n                             span: span,\n                             global: false,\n@@ -2990,10 +2985,7 @@ impl<'a> Resolver<'a> {\n                 if let Some(module) = name_binding.module() {\n                     // form the path\n                     let mut path_segments = path_segments.clone();\n-                    path_segments.push(PathSegment {\n-                        identifier: ident,\n-                        parameters: PathParameters::none(),\n-                    });\n+                    path_segments.push(ident.into());\n \n                     if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup"}, {"sha": "6399a266fcf38fe449931531d1a7de0e40cf0489", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "patch": "@@ -183,9 +183,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n         let ast::Path { ref segments, global, span } = *path;\n-        if segments.iter().any(|segment| !segment.parameters.is_empty()) {\n+        if segments.iter().any(|segment| segment.parameters.is_some()) {\n             let kind =\n-                if segments.last().unwrap().parameters.is_empty() { \"module\" } else { \"macro\" };\n+                if segments.last().unwrap().parameters.is_some() { \"macro\" } else { \"module\" };\n             let msg = format!(\"type parameters are not allowed on {}s\", kind);\n             self.session.span_err(path.span, &msg);\n             return Err(Determinacy::Determined);"}, {"sha": "fdd82225b974747990adb31c6a9d8067499011d2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 15, "deletions": 82, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "patch": "@@ -137,12 +137,7 @@ impl Path {\n         Path {\n             span: s,\n             global: false,\n-            segments: vec![\n-                PathSegment {\n-                    identifier: identifier,\n-                    parameters: PathParameters::none()\n-                }\n-            ],\n+            segments: vec![identifier.into()],\n         }\n     }\n }\n@@ -160,7 +155,15 @@ pub struct PathSegment {\n     /// this is more than just simple syntactic sugar; the use of\n     /// parens affects the region binding rules, so we preserve the\n     /// distinction.\n-    pub parameters: PathParameters,\n+    /// The `Option<P<..>>` wrapper is purely a size optimization;\n+    /// `None` is used to represent both `Path` and `Path<>`.\n+    pub parameters: Option<P<PathParameters>>,\n+}\n+\n+impl From<Ident> for PathSegment {\n+    fn from(id: Ident) -> Self {\n+        PathSegment { identifier: id, parameters: None }\n+    }\n }\n \n /// Parameters of a path segment.\n@@ -174,79 +177,8 @@ pub enum PathParameters {\n     Parenthesized(ParenthesizedParameterData),\n }\n \n-impl PathParameters {\n-    pub fn none() -> PathParameters {\n-        PathParameters::AngleBracketed(AngleBracketedParameterData {\n-            lifetimes: Vec::new(),\n-            types: P::new(),\n-            bindings: P::new(),\n-        })\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => data.is_empty(),\n-\n-            // Even if the user supplied no types, something like\n-            // `X()` is equivalent to `X<(),()>`.\n-            PathParameters::Parenthesized(..) => false,\n-        }\n-    }\n-\n-    pub fn has_lifetimes(&self) -> bool {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => !data.lifetimes.is_empty(),\n-            PathParameters::Parenthesized(_) => false,\n-        }\n-    }\n-\n-    pub fn has_types(&self) -> bool {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => !data.types.is_empty(),\n-            PathParameters::Parenthesized(..) => true,\n-        }\n-    }\n-\n-    /// Returns the types that the user wrote. Note that these do not necessarily map to the type\n-    /// parameters in the parenthesized case.\n-    pub fn types(&self) -> Vec<&P<Ty>> {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => {\n-                data.types.iter().collect()\n-            }\n-            PathParameters::Parenthesized(ref data) => {\n-                data.inputs.iter()\n-                    .chain(data.output.iter())\n-                    .collect()\n-            }\n-        }\n-    }\n-\n-    pub fn lifetimes(&self) -> Vec<&Lifetime> {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => {\n-                data.lifetimes.iter().collect()\n-            }\n-            PathParameters::Parenthesized(_) => {\n-                Vec::new()\n-            }\n-        }\n-    }\n-\n-    pub fn bindings(&self) -> Vec<&TypeBinding> {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => {\n-                data.bindings.iter().collect()\n-            }\n-            PathParameters::Parenthesized(_) => {\n-                Vec::new()\n-            }\n-        }\n-    }\n-}\n-\n /// A path like `Foo<'a, T>`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Default)]\n pub struct AngleBracketedParameterData {\n     /// The lifetime parameters for this path segment.\n     pub lifetimes: Vec<Lifetime>,\n@@ -258,9 +190,10 @@ pub struct AngleBracketedParameterData {\n     pub bindings: P<[TypeBinding]>,\n }\n \n-impl AngleBracketedParameterData {\n-    fn is_empty(&self) -> bool {\n-        self.lifetimes.is_empty() && self.types.is_empty() && self.bindings.is_empty()\n+impl Into<Option<P<PathParameters>>> for AngleBracketedParameterData {\n+    fn into(self) -> Option<P<PathParameters>> {\n+        let empty = self.lifetimes.is_empty() && self.types.is_empty() && self.bindings.is_empty();\n+        if empty { None } else { Some(P(PathParameters::AngleBracketed(self))) }\n     }\n }\n "}, {"sha": "c0dfb90024006971679ed8fde5dd7ab90a988d8d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "patch": "@@ -322,21 +322,17 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 bindings: Vec<ast::TypeBinding> )\n                 -> ast::Path {\n         let last_identifier = idents.pop().unwrap();\n-        let mut segments: Vec<ast::PathSegment> = idents.into_iter()\n-                                                      .map(|ident| {\n-            ast::PathSegment {\n-                identifier: ident,\n-                parameters: ast::PathParameters::none(),\n-            }\n-        }).collect();\n-        segments.push(ast::PathSegment {\n-            identifier: last_identifier,\n-            parameters: ast::PathParameters::AngleBracketed(ast::AngleBracketedParameterData {\n+        let mut segments: Vec<ast::PathSegment> = idents.into_iter().map(Into::into).collect();\n+        let parameters = if lifetimes.is_empty() && types.is_empty() && bindings.is_empty() {\n+            None\n+        } else {\n+            Some(P(ast::PathParameters::AngleBracketed(ast::AngleBracketedParameterData {\n                 lifetimes: lifetimes,\n                 types: P::from_vec(types),\n                 bindings: P::from_vec(bindings),\n-            })\n-        });\n+            })))\n+        };\n+        segments.push(ast::PathSegment { identifier: last_identifier, parameters: parameters });\n         ast::Path {\n             span: sp,\n             global: global,\n@@ -367,13 +363,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                  bindings: Vec<ast::TypeBinding>)\n                  -> (ast::QSelf, ast::Path) {\n         let mut path = trait_path;\n+        let parameters = ast::AngleBracketedParameterData {\n+            lifetimes: lifetimes,\n+            types: P::from_vec(types),\n+            bindings: P::from_vec(bindings),\n+        };\n         path.segments.push(ast::PathSegment {\n             identifier: ident,\n-            parameters: ast::PathParameters::AngleBracketed(ast::AngleBracketedParameterData {\n-                lifetimes: lifetimes,\n-                types: P::from_vec(types),\n-                bindings: P::from_vec(bindings),\n-            })\n+            parameters: Some(P(ast::PathParameters::AngleBracketed(parameters))),\n         });\n \n         (ast::QSelf {"}, {"sha": "b3753e3e977e331cf424d382694f2bcd28ff0c34", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "patch": "@@ -438,7 +438,7 @@ pub fn noop_fold_path<T: Folder>(Path {global, segments, span}: Path, fld: &mut\n         global: global,\n         segments: segments.move_map(|PathSegment {identifier, parameters}| PathSegment {\n             identifier: fld.fold_ident(identifier),\n-            parameters: fld.fold_path_parameters(parameters),\n+            parameters: parameters.map(|ps| ps.map(|ps| fld.fold_path_parameters(ps))),\n         }),\n         span: fld.new_span(span)\n     }"}, {"sha": "b9e6605639ead2c8ff0f8ee61cd0814c5df31738", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 9, "deletions": 44, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "patch": "@@ -634,12 +634,7 @@ mod tests {\n                     node: ast::ExprKind::Path(None, ast::Path {\n                         span: sp(0, 1),\n                         global: false,\n-                        segments: vec![\n-                            ast::PathSegment {\n-                                identifier: Ident::from_str(\"a\"),\n-                                parameters: ast::PathParameters::none(),\n-                            }\n-                        ],\n+                        segments: vec![Ident::from_str(\"a\").into()],\n                     }),\n                     span: sp(0, 1),\n                     attrs: ThinVec::new(),\n@@ -651,19 +646,10 @@ mod tests {\n                    P(ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprKind::Path(None, ast::Path {\n-                            span: sp(0, 6),\n-                            global: true,\n-                            segments: vec![\n-                                ast::PathSegment {\n-                                    identifier: Ident::from_str(\"a\"),\n-                                    parameters: ast::PathParameters::none(),\n-                                },\n-                                ast::PathSegment {\n-                                    identifier: Ident::from_str(\"b\"),\n-                                    parameters: ast::PathParameters::none(),\n-                                }\n-                            ]\n-                        }),\n+                        span: sp(0, 6),\n+                        global: true,\n+                        segments: vec![Ident::from_str(\"a\").into(), Ident::from_str(\"b\").into()],\n+                    }),\n                     span: sp(0, 6),\n                     attrs: ThinVec::new(),\n                    }))\n@@ -772,12 +758,7 @@ mod tests {\n                         node:ast::ExprKind::Path(None, ast::Path{\n                             span: sp(7, 8),\n                             global: false,\n-                            segments: vec![\n-                                ast::PathSegment {\n-                                    identifier: Ident::from_str(\"d\"),\n-                                    parameters: ast::PathParameters::none(),\n-                                }\n-                            ],\n+                            segments: vec![Ident::from_str(\"d\").into()],\n                         }),\n                         span:sp(7,8),\n                         attrs: ThinVec::new(),\n@@ -795,12 +776,7 @@ mod tests {\n                            node: ast::ExprKind::Path(None, ast::Path {\n                                span:sp(0,1),\n                                global:false,\n-                               segments: vec![\n-                                ast::PathSegment {\n-                                    identifier: Ident::from_str(\"b\"),\n-                                    parameters: ast::PathParameters::none(),\n-                                }\n-                               ],\n+                               segments: vec![Ident::from_str(\"b\").into()],\n                             }),\n                            span: sp(0,1),\n                            attrs: ThinVec::new()})),\n@@ -842,12 +818,7 @@ mod tests {\n                                                   node: ast::TyKind::Path(None, ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n-                                        segments: vec![\n-                                            ast::PathSegment {\n-                                                identifier: Ident::from_str(\"i32\"),\n-                                                parameters: ast::PathParameters::none(),\n-                                            }\n-                                        ],\n+                                        segments: vec![Ident::from_str(\"i32\").into()],\n                                         }),\n                                         span:sp(10,13)\n                                     }),\n@@ -890,13 +861,7 @@ mod tests {\n                                                       ast::Path{\n                                                         span:sp(17,18),\n                                                         global:false,\n-                                                        segments: vec![\n-                                                            ast::PathSegment {\n-                                                                identifier: Ident::from_str(\"b\"),\n-                                                                parameters:\n-                                                                ast::PathParameters::none(),\n-                                                            }\n-                                                        ],\n+                                                        segments: vec![Ident::from_str(\"b\").into()],\n                                                       }),\n                                                 span: sp(17,18),\n                                                 attrs: ThinVec::new()})),"}, {"sha": "72462b74e686ca60b1f002f220738dd7e55b162f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "patch": "@@ -1705,12 +1705,11 @@ impl<'a> Parser<'a> {\n             // Parse types, optionally.\n             let parameters = if self.eat_lt() {\n                 let (lifetimes, types, bindings) = self.parse_generic_values_after_lt()?;\n-\n-                ast::PathParameters::AngleBracketed(ast::AngleBracketedParameterData {\n+                ast::AngleBracketedParameterData {\n                     lifetimes: lifetimes,\n                     types: P::from_vec(types),\n                     bindings: P::from_vec(bindings),\n-                })\n+                }.into()\n             } else if self.eat(&token::OpenDelim(token::Paren)) {\n                 let lo = self.prev_span.lo;\n \n@@ -1727,18 +1726,17 @@ impl<'a> Parser<'a> {\n \n                 let hi = self.prev_span.hi;\n \n-                ast::PathParameters::Parenthesized(ast::ParenthesizedParameterData {\n+                Some(P(ast::PathParameters::Parenthesized(ast::ParenthesizedParameterData {\n                     span: mk_sp(lo, hi),\n                     inputs: inputs,\n                     output: output_ty,\n-                })\n+                })))\n             } else {\n-                ast::PathParameters::none()\n+                None\n             };\n \n             // Assemble and push the result.\n-            segments.push(ast::PathSegment { identifier: identifier,\n-                                             parameters: parameters });\n+            segments.push(ast::PathSegment { identifier: identifier, parameters: parameters });\n \n             // Continue only if we see a `::`\n             if !self.eat(&token::ModSep) {\n@@ -1757,25 +1755,21 @@ impl<'a> Parser<'a> {\n \n             // If we do not see a `::`, stop.\n             if !self.eat(&token::ModSep) {\n-                segments.push(ast::PathSegment {\n-                    identifier: identifier,\n-                    parameters: ast::PathParameters::none()\n-                });\n+                segments.push(identifier.into());\n                 return Ok(segments);\n             }\n \n             // Check for a type segment.\n             if self.eat_lt() {\n                 // Consumed `a::b::<`, go look for types\n                 let (lifetimes, types, bindings) = self.parse_generic_values_after_lt()?;\n-                let parameters = ast::AngleBracketedParameterData {\n-                    lifetimes: lifetimes,\n-                    types: P::from_vec(types),\n-                    bindings: P::from_vec(bindings),\n-                };\n                 segments.push(ast::PathSegment {\n                     identifier: identifier,\n-                    parameters: ast::PathParameters::AngleBracketed(parameters),\n+                    parameters: ast::AngleBracketedParameterData {\n+                        lifetimes: lifetimes,\n+                        types: P::from_vec(types),\n+                        bindings: P::from_vec(bindings),\n+                    }.into(),\n                 });\n \n                 // Consumed `a::b::<T,U>`, check for `::` before proceeding\n@@ -1784,10 +1778,7 @@ impl<'a> Parser<'a> {\n                 }\n             } else {\n                 // Consumed `a::`, go look for `b`\n-                segments.push(ast::PathSegment {\n-                    identifier: identifier,\n-                    parameters: ast::PathParameters::none(),\n-                });\n+                segments.push(identifier.into());\n             }\n         }\n     }\n@@ -1802,10 +1793,7 @@ impl<'a> Parser<'a> {\n             let identifier = self.parse_path_segment_ident()?;\n \n             // Assemble and push the result.\n-            segments.push(ast::PathSegment {\n-                identifier: identifier,\n-                parameters: ast::PathParameters::none()\n-            });\n+            segments.push(identifier.into());\n \n             // If we do not see a `::` or see `::{`/`::*`, stop.\n             if !self.check(&token::ModSep) || self.is_import_coupler() {"}, {"sha": "22e8391de93ed4910d9fbf988db6e3093392c844", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "patch": "@@ -2349,7 +2349,9 @@ impl<'a> State<'a> {\n \n             try!(self.print_ident(segment.identifier));\n \n-            try!(self.print_path_parameters(&segment.parameters, colons_before_params));\n+            if let Some(ref parameters) = segment.parameters {\n+                try!(self.print_path_parameters(parameters, colons_before_params))\n+            }\n         }\n \n         Ok(())\n@@ -2373,18 +2375,17 @@ impl<'a> State<'a> {\n         try!(word(&mut self.s, \"::\"));\n         let item_segment = path.segments.last().unwrap();\n         try!(self.print_ident(item_segment.identifier));\n-        self.print_path_parameters(&item_segment.parameters, colons_before_params)\n+        match item_segment.parameters {\n+            Some(ref parameters) => self.print_path_parameters(parameters, colons_before_params),\n+            None => Ok(()),\n+        }\n     }\n \n     fn print_path_parameters(&mut self,\n                              parameters: &ast::PathParameters,\n                              colons_before_params: bool)\n                              -> io::Result<()>\n     {\n-        if parameters.is_empty() {\n-            return Ok(());\n-        }\n-\n         if colons_before_params {\n             try!(word(&mut self.s, \"::\"))\n         }"}, {"sha": "4ad760a3cafe4194ca60be1ec28fb9e5c5c12168", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "patch": "@@ -81,9 +81,8 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n         vis: ast::Visibility::Inherited,\n         node: ast::ItemKind::Use(P(codemap::dummy_spanned(ast::ViewPathGlob(ast::Path {\n             global: false,\n-            segments: vec![name, \"prelude\", \"v1\"].into_iter().map(|name| ast::PathSegment {\n-                identifier: ast::Ident::from_str(name),\n-                parameters: ast::PathParameters::none(),\n+            segments: vec![name, \"prelude\", \"v1\"].into_iter().map(|name| {\n+                ast::Ident::from_str(name).into()\n             }).collect(),\n             span: span,\n         })))),"}, {"sha": "7709d3bd1cf1ce27e5bcd1492ac54a34a7ad08b8", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "patch": "@@ -580,10 +580,7 @@ fn path_node(ids: Vec<Ident>) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n         global: false,\n-        segments: ids.into_iter().map(|identifier| ast::PathSegment {\n-            identifier: identifier,\n-            parameters: ast::PathParameters::none(),\n-        }).collect()\n+        segments: ids.into_iter().map(Into::into).collect(),\n     }\n }\n "}, {"sha": "ad29cb50a84c80221e308b2b381ed08bed08406e", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "patch": "@@ -383,7 +383,9 @@ pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'a PathSegment) {\n     visitor.visit_ident(path_span, segment.identifier);\n-    visitor.visit_path_parameters(path_span, &segment.parameters);\n+    if let Some(ref parameters) = segment.parameters {\n+        visitor.visit_path_parameters(path_span, parameters);\n+    }\n }\n \n pub fn walk_path_parameters<'a, V>(visitor: &mut V,"}, {"sha": "1381490efa194b3bd7a1e7850aa35c394bae9a30", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e61ff25d85dcdc81c55f51ba2a777e13e561a25/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=8e61ff25d85dcdc81c55f51ba2a777e13e561a25", "patch": "@@ -59,14 +59,10 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n \n     impl Result {\n         fn path(&self) -> ast::Path {\n-            let segment = ast::PathSegment {\n-                identifier: self.ident,\n-                parameters: ast::PathParameters::none(),\n-            };\n             ast::Path {\n                 span: self.span,\n                 global: false,\n-                segments: vec![segment],\n+                segments: vec![self.ident.into()],\n             }\n         }\n     }"}]}