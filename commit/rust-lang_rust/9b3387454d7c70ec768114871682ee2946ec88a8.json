{"sha": "9b3387454d7c70ec768114871682ee2946ec88a8", "node_id": "C_kwDOAAsO6NoAKDliMzM4NzQ1NGQ3YzcwZWM3NjgxMTQ4NzE2ODJlZTI5NDZlYzg4YTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-11T14:26:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-11T14:26:59Z"}, "message": "Auto merge of #14781 - lowr:patch/macro-subns-and-prelude, r=Veykril\n\nIntroduce macro sub-namespaces and `macro_use` prelude\n\nThis PR implements two mechanisms needed for correct macro name resolution: macro sub-namespace and `macro_use` prelude.\n\n- [macro sub-namespaces][subns-ref]\n\n  Macros have two sub-namespaces: one for function-like macro and the other for those in attributes (including custom derive macros). When we're resolving a macro name for function-like macro, we should ignore non-function-like macros, and vice versa.\n\n  This helps resolve single-segment macro names because we can (and should, as rustc does) fallback to names in preludes when the name in the current module scope is in different sub-namespace.\n\n- [`macro_use` prelude][prelude-ref]\n\n  `#[macro_use]`'d extern crate declarations (including the standard library) bring their macros into scope, but they should not be prioritized over local macros (those defined in place and those explicitly imported).\n\n  We have been bringing them into legacy (textual) macro scope, which has the highest precedence in name resolution. This PR introduces the `macro_use` prelude in crate-level `DefMap`s, whose precedence is lower than local macros but higher than the standard library prelude.\n\nThe first 3 commits are drive-by fixes/refactors.\n\nFixes #8828 (prelude)\nFixes #12505 (prelude)\nFixes #12734 (prelude)\nFixes #13683 (prelude)\nFixes #13821 (prelude)\nFixes #13974 (prelude)\nFixes #14254 (namespace)\n\n[subns-ref]: https://doc.rust-lang.org/reference/names/namespaces.html#sub-namespaces\n[prelude-ref]: https://doc.rust-lang.org/reference/names/preludes.html#macro_use-prelude", "tree": {"sha": "5418771a650b118fa206ff108a319c5eac1f23a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5418771a650b118fa206ff108a319c5eac1f23a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b3387454d7c70ec768114871682ee2946ec88a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b3387454d7c70ec768114871682ee2946ec88a8", "html_url": "https://github.com/rust-lang/rust/commit/9b3387454d7c70ec768114871682ee2946ec88a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b3387454d7c70ec768114871682ee2946ec88a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b069eb720bec6ce40ab224f57d271687b19b5a07", "url": "https://api.github.com/repos/rust-lang/rust/commits/b069eb720bec6ce40ab224f57d271687b19b5a07", "html_url": "https://github.com/rust-lang/rust/commit/b069eb720bec6ce40ab224f57d271687b19b5a07"}, {"sha": "f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "html_url": "https://github.com/rust-lang/rust/commit/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444"}], "stats": {"total": 594, "additions": 425, "deletions": 169}, "files": [{"sha": "d92698a938a7b11e1588eed6ee2c454ac7ceefac", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -37,7 +37,7 @@ use crate::{\n     item_scope::BuiltinShadowMode,\n     lang_item::LangItem,\n     lower::LowerCtx,\n-    nameres::DefMap,\n+    nameres::{DefMap, MacroSubNs},\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n     AdtId, BlockId, BlockLoc, ModuleDefId, UnresolvedMacro,\n@@ -800,7 +800,13 @@ impl ExprCollector<'_> {\n         let module = self.expander.module.local_id;\n         let res = self.expander.enter_expand(self.db, mcall, |path| {\n             self.def_map\n-                .resolve_path(self.db, module, &path, crate::item_scope::BuiltinShadowMode::Other)\n+                .resolve_path(\n+                    self.db,\n+                    module,\n+                    &path,\n+                    crate::item_scope::BuiltinShadowMode::Other,\n+                    Some(MacroSubNs::Bang),\n+                )\n                 .0\n                 .take_macros()\n         });\n@@ -1056,6 +1062,7 @@ impl ExprCollector<'_> {\n                         self.expander.module.local_id,\n                         &name.clone().into(),\n                         BuiltinShadowMode::Other,\n+                        None,\n                     );\n                     match resolved.take_values() {\n                         Some(ModuleDefId::ConstId(_)) => (None, Pat::Path(name.into())),"}, {"sha": "40e6a4308784c546cedd8ed462fe8bd198541d57", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -22,7 +22,7 @@ use crate::{\n         attr_resolution::ResolvedAttr,\n         diagnostics::DefDiagnostic,\n         proc_macro::{parse_macro_name_and_helper_attrs, ProcMacroKind},\n-        DefMap,\n+        DefMap, MacroSubNs,\n     },\n     type_ref::{TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n@@ -673,6 +673,7 @@ impl<'a> AssocItemCollector<'a> {\n                             module,\n                             &path,\n                             crate::item_scope::BuiltinShadowMode::Other,\n+                            Some(MacroSubNs::Bang),\n                         )\n                         .0\n                         .take_macros()"}, {"sha": "b401762255ef8a1911fde3d1b4aabf7b274a8008", "filename": "crates/hir-def/src/find_path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ffind_path.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -543,6 +543,7 @@ mod tests {\n                 module.local_id,\n                 &mod_path,\n                 crate::item_scope::BuiltinShadowMode::Module,\n+                None,\n             )\n             .0\n             .take_types()"}, {"sha": "f19c3f028f42f7c41fe7f412cf23c894bfaa418a", "filename": "crates/hir-def/src/generics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -22,7 +22,7 @@ use crate::{\n     dyn_map::{keys, DynMap},\n     expander::Expander,\n     lower::LowerCtx,\n-    nameres::DefMap,\n+    nameres::{DefMap, MacroSubNs},\n     src::{HasChildSource, HasSource},\n     type_ref::{LifetimeRef, TypeBound, TypeRef},\n     AdtId, ConstParamId, GenericDefId, HasModule, LifetimeParamId, LocalLifetimeParamId,\n@@ -361,6 +361,7 @@ impl GenericParams {\n                             module,\n                             &path,\n                             crate::item_scope::BuiltinShadowMode::Other,\n+                            Some(MacroSubNs::Bang),\n                         )\n                         .0\n                         .take_macros()"}, {"sha": "6cb741dac719fc2b7bd4dcdf3346bfe4e8aed49f", "filename": "crates/hir-def/src/macro_expansion_tests/builtin_fn_macro.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -13,12 +13,12 @@ macro_rules! column {() => {}}\n \n fn main() { column!(); }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[rustc_builtin_macro]\n macro_rules! column {() => {}}\n \n-fn main() { 0; }\n-\"##]],\n+fn main() { 0 as u32; }\n+\"#]],\n     );\n }\n \n@@ -31,12 +31,12 @@ macro_rules! line {() => {}}\n \n fn main() { line!() }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[rustc_builtin_macro]\n macro_rules! line {() => {}}\n \n-fn main() { 0 }\n-\"##]],\n+fn main() { 0 as u32 }\n+\"#]],\n     );\n }\n "}, {"sha": "c056c077a56838738dded1b01d7edeef8741b148", "filename": "crates/hir-def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -922,7 +922,7 @@ macro_rules! m {\n \n fn bar() -> &'a Baz<u8> {}\n \n-fn bar() -> extern \"Rust\"fn() -> Ret {}\n+fn bar() -> extern \"Rust\" fn() -> Ret {}\n \"#]],\n     );\n }\n@@ -1333,7 +1333,7 @@ macro_rules! matches {\n }\n fn main() {\n     match 0 {\n-        0|1if true =>true , _=>false\n+        0|1 if true =>true , _=>false\n     };\n }\n  \"#]],"}, {"sha": "0909d8c835443e00fe721d1e090e4c7e0082166b", "filename": "crates/hir-def/src/macro_expansion_tests/mbe/matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -73,7 +73,7 @@ fn main() {\n macro_rules! asi { ($($stmt:stmt)*) => ($($stmt)*); }\n \n fn main() {\n-    let a = 2let b = 5drop(b-a)println!(\"{}\", a+b)\n+    let a = 2 let b = 5 drop(b-a)println!(\"{}\", a+b)\n }\n \"#]],\n     )"}, {"sha": "d8e4a4dcc7c2b231501963e35434a2656690964a", "filename": "crates/hir-def/src/macro_expansion_tests/mbe/regression.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -297,55 +297,55 @@ macro_rules! impl_fn_for_zst  {\n \n #[derive(Clone)] struct CharEscapeDebugContinue;\n impl Fn<(char, )> for CharEscapeDebugContinue {\n-    #[inline] extern \"rust-call\"fn call(&self , (c, ): (char, )) -> char::EscapeDebug { {\n+    #[inline] extern \"rust-call\" fn call(&self , (c, ): (char, )) -> char::EscapeDebug { {\n             c.escape_debug_ext(false )\n         }\n     }\n }\n impl FnMut<(char, )> for CharEscapeDebugContinue {\n-    #[inline] extern \"rust-call\"fn call_mut(&mut self , (c, ): (char, )) -> char::EscapeDebug {\n+    #[inline] extern \"rust-call\" fn call_mut(&mut self , (c, ): (char, )) -> char::EscapeDebug {\n         Fn::call(&*self , (c, ))\n     }\n }\n impl FnOnce<(char, )> for CharEscapeDebugContinue {\n     type Output = char::EscapeDebug;\n-    #[inline] extern \"rust-call\"fn call_once(self , (c, ): (char, )) -> char::EscapeDebug {\n+    #[inline] extern \"rust-call\" fn call_once(self , (c, ): (char, )) -> char::EscapeDebug {\n         Fn::call(&self , (c, ))\n     }\n }\n #[derive(Clone)] struct CharEscapeUnicode;\n impl Fn<(char, )> for CharEscapeUnicode {\n-    #[inline] extern \"rust-call\"fn call(&self , (c, ): (char, )) -> char::EscapeUnicode { {\n+    #[inline] extern \"rust-call\" fn call(&self , (c, ): (char, )) -> char::EscapeUnicode { {\n             c.escape_unicode()\n         }\n     }\n }\n impl FnMut<(char, )> for CharEscapeUnicode {\n-    #[inline] extern \"rust-call\"fn call_mut(&mut self , (c, ): (char, )) -> char::EscapeUnicode {\n+    #[inline] extern \"rust-call\" fn call_mut(&mut self , (c, ): (char, )) -> char::EscapeUnicode {\n         Fn::call(&*self , (c, ))\n     }\n }\n impl FnOnce<(char, )> for CharEscapeUnicode {\n     type Output = char::EscapeUnicode;\n-    #[inline] extern \"rust-call\"fn call_once(self , (c, ): (char, )) -> char::EscapeUnicode {\n+    #[inline] extern \"rust-call\" fn call_once(self , (c, ): (char, )) -> char::EscapeUnicode {\n         Fn::call(&self , (c, ))\n     }\n }\n #[derive(Clone)] struct CharEscapeDefault;\n impl Fn<(char, )> for CharEscapeDefault {\n-    #[inline] extern \"rust-call\"fn call(&self , (c, ): (char, )) -> char::EscapeDefault { {\n+    #[inline] extern \"rust-call\" fn call(&self , (c, ): (char, )) -> char::EscapeDefault { {\n             c.escape_default()\n         }\n     }\n }\n impl FnMut<(char, )> for CharEscapeDefault {\n-    #[inline] extern \"rust-call\"fn call_mut(&mut self , (c, ): (char, )) -> char::EscapeDefault {\n+    #[inline] extern \"rust-call\" fn call_mut(&mut self , (c, ): (char, )) -> char::EscapeDefault {\n         Fn::call(&*self , (c, ))\n     }\n }\n impl FnOnce<(char, )> for CharEscapeDefault {\n     type Output = char::EscapeDefault;\n-    #[inline] extern \"rust-call\"fn call_once(self , (c, ): (char, )) -> char::EscapeDefault {\n+    #[inline] extern \"rust-call\" fn call_once(self , (c, ): (char, )) -> char::EscapeDefault {\n         Fn::call(&self , (c, ))\n     }\n }\n@@ -833,7 +833,7 @@ macro_rules! rgb_color {\n /* parse error: expected SEMICOLON */\n /* parse error: expected expression, item or let statement */\n pub fn new() {\n-    let _ = 0as u32<<(8+8);\n+    let _ = 0 as u32<<(8+8);\n }\n // MACRO_ITEMS@0..31\n //   FN@0..31"}, {"sha": "40849d4a66d8ca672e0d98eec382c6977b6eab3b", "filename": "crates/hir-def/src/macro_expansion_tests/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -33,8 +33,13 @@ use syntax::{\n use tt::token_id::{Subtree, TokenId};\n \n use crate::{\n-    db::DefDatabase, macro_id_to_def_id, nameres::ModuleSource, resolver::HasResolver,\n-    src::HasSource, test_db::TestDB, AdtId, AsMacroCall, Lookup, ModuleDefId,\n+    db::DefDatabase,\n+    macro_id_to_def_id,\n+    nameres::{MacroSubNs, ModuleSource},\n+    resolver::HasResolver,\n+    src::HasSource,\n+    test_db::TestDB,\n+    AdtId, AsMacroCall, Lookup, ModuleDefId,\n };\n \n #[track_caller]\n@@ -127,7 +132,9 @@ pub fn identity_when_valid(_attr: TokenStream, item: TokenStream) -> TokenStream\n         let macro_call = InFile::new(source.file_id, &macro_call);\n         let res = macro_call\n             .as_call_id_with_errors(&db, krate, |path| {\n-                resolver.resolve_path_as_macro(&db, &path).map(|it| macro_id_to_def_id(&db, it))\n+                resolver\n+                    .resolve_path_as_macro(&db, &path, Some(MacroSubNs::Bang))\n+                    .map(|it| macro_id_to_def_id(&db, it))\n             })\n             .unwrap();\n         let macro_call_id = res.value.unwrap();\n@@ -280,6 +287,7 @@ fn pretty_print_macro_expansion(expn: SyntaxNode, map: Option<&TokenMap>) -> Str\n         let curr_kind = token.kind();\n         let space = match (prev_kind, curr_kind) {\n             _ if prev_kind.is_trivia() || curr_kind.is_trivia() => \"\",\n+            _ if prev_kind.is_literal() && !curr_kind.is_punct() => \" \",\n             (T!['{'], T!['}']) => \"\",\n             (T![=], _) | (_, T![=]) => \" \",\n             (_, T!['{']) => \" \","}, {"sha": "39a56814ed88bee0127df9753e9eb538bb79f183", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 64, "deletions": 4, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -59,7 +59,7 @@ mod tests;\n \n use std::{cmp::Ord, ops::Deref};\n \n-use base_db::{CrateId, Edition, FileId};\n+use base_db::{CrateId, Edition, FileId, ProcMacroKind};\n use hir_expand::{name::Name, InFile, MacroCallId, MacroDefId};\n use itertools::Itertools;\n use la_arena::Arena;\n@@ -77,7 +77,8 @@ use crate::{\n     path::ModPath,\n     per_ns::PerNs,\n     visibility::Visibility,\n-    AstId, BlockId, BlockLoc, FunctionId, LocalModuleId, MacroId, ModuleId, ProcMacroId,\n+    AstId, BlockId, BlockLoc, FunctionId, LocalModuleId, Lookup, MacroExpander, MacroId, ModuleId,\n+    ProcMacroId,\n };\n \n /// Contains the results of (early) name resolution.\n@@ -105,6 +106,9 @@ pub struct DefMap {\n     prelude: Option<ModuleId>,\n     /// The extern prelude is only populated for non-block DefMaps\n     extern_prelude: FxHashMap<Name, ModuleId>,\n+    /// `macro_use` prelude that contains macros from `#[macro_use]`'d external crates. Note that\n+    /// this contains all kinds of macro, not just `macro_rules!` macro.\n+    macro_use_prelude: FxHashMap<Name, MacroId>,\n \n     /// Side table for resolving derive helpers.\n     exported_derives: FxHashMap<MacroDefId, Box<[Name]>>,\n@@ -277,6 +281,7 @@ impl DefMap {\n             edition,\n             recursion_limit: None,\n             extern_prelude: FxHashMap::default(),\n+            macro_use_prelude: FxHashMap::default(),\n             exported_derives: FxHashMap::default(),\n             fn_proc_macro_mapping: FxHashMap::default(),\n             proc_macro_loading_error: None,\n@@ -376,9 +381,16 @@ impl DefMap {\n         original_module: LocalModuleId,\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n+        expected_macro_subns: Option<MacroSubNs>,\n     ) -> (PerNs, Option<usize>) {\n-        let res =\n-            self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path, shadow);\n+        let res = self.resolve_path_fp_with_macro(\n+            db,\n+            ResolveMode::Other,\n+            original_module,\n+            path,\n+            shadow,\n+            expected_macro_subns,\n+        );\n         (res.resolved_def, res.segment_index)\n     }\n \n@@ -395,6 +407,7 @@ impl DefMap {\n             original_module,\n             path,\n             shadow,\n+            None, // Currently this function isn't used for macro resolution.\n         );\n         (res.resolved_def, res.segment_index)\n     }\n@@ -489,6 +502,7 @@ impl DefMap {\n             _c: _,\n             exported_derives,\n             extern_prelude,\n+            macro_use_prelude,\n             diagnostics,\n             modules,\n             registered_attrs,\n@@ -507,6 +521,7 @@ impl DefMap {\n         } = self;\n \n         extern_prelude.shrink_to_fit();\n+        macro_use_prelude.shrink_to_fit();\n         exported_derives.shrink_to_fit();\n         diagnostics.shrink_to_fit();\n         modules.shrink_to_fit();\n@@ -562,3 +577,48 @@ pub enum ModuleSource {\n     Module(ast::Module),\n     BlockExpr(ast::BlockExpr),\n }\n+\n+/// See `sub_namespace_match()`.\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub enum MacroSubNs {\n+    /// Function-like macros, suffixed with `!`.\n+    Bang,\n+    /// Macros inside attributes, i.e. attribute macros and derive macros.\n+    Attr,\n+}\n+\n+impl MacroSubNs {\n+    fn from_id(db: &dyn DefDatabase, macro_id: MacroId) -> Self {\n+        let expander = match macro_id {\n+            MacroId::Macro2Id(it) => it.lookup(db).expander,\n+            MacroId::MacroRulesId(it) => it.lookup(db).expander,\n+            MacroId::ProcMacroId(it) => {\n+                return match it.lookup(db).kind {\n+                    ProcMacroKind::CustomDerive | ProcMacroKind::Attr => Self::Attr,\n+                    ProcMacroKind::FuncLike => Self::Bang,\n+                };\n+            }\n+        };\n+\n+        // Eager macros aren't *guaranteed* to be bang macros, but they *are* all bang macros currently.\n+        match expander {\n+            MacroExpander::Declarative\n+            | MacroExpander::BuiltIn(_)\n+            | MacroExpander::BuiltInEager(_) => Self::Bang,\n+            MacroExpander::BuiltInAttr(_) | MacroExpander::BuiltInDerive(_) => Self::Attr,\n+        }\n+    }\n+}\n+\n+/// Quoted from [rustc]:\n+/// Macro namespace is separated into two sub-namespaces, one for bang macros and\n+/// one for attribute-like macros (attributes, derives).\n+/// We ignore resolutions from one sub-namespace when searching names in scope for another.\n+///\n+/// [rustc]: https://github.com/rust-lang/rust/blob/1.69.0/compiler/rustc_resolve/src/macros.rs#L75\n+fn sub_namespace_match(candidate: Option<MacroSubNs>, expected: Option<MacroSubNs>) -> bool {\n+    match (candidate, expected) {\n+        (Some(candidate), Some(expected)) => candidate == expected,\n+        _ => true,\n+    }\n+}"}, {"sha": "6567bda709d6384a57c1df0ae2c54197078dcec0", "filename": "crates/hir-def/src/nameres/attr_resolution.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -14,7 +14,7 @@ use crate::{\n     AstIdWithPath, LocalModuleId, UnresolvedMacro,\n };\n \n-use super::DefMap;\n+use super::{DefMap, MacroSubNs};\n \n pub enum ResolvedAttr {\n     /// Attribute resolved to an attribute macro.\n@@ -43,9 +43,12 @@ impl DefMap {\n             original_module,\n             &ast_id.path,\n             BuiltinShadowMode::Module,\n+            Some(MacroSubNs::Attr),\n         );\n         let def = match resolved_res.resolved_def.take_macros() {\n             Some(def) => {\n+                // `MacroSubNs` is just a hint, so the path may still resolve to a custom derive\n+                // macro, or even function-like macro when the path is qualified.\n                 if def.is_attribute(db) {\n                     def\n                 } else {"}, {"sha": "177edcbb7f2401a22570718082b03980cb34e1a0", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 113, "deletions": 98, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -44,7 +44,7 @@ use crate::{\n         mod_resolution::ModDir,\n         path_resolution::ReachedFixedPoint,\n         proc_macro::{parse_macro_name_and_helper_attrs, ProcMacroDef, ProcMacroKind},\n-        BuiltinShadowMode, DefMap, ModuleData, ModuleOrigin, ResolveMode,\n+        BuiltinShadowMode, DefMap, MacroSubNs, ModuleData, ModuleOrigin, ResolveMode,\n     },\n     path::{ImportAlias, ModPath, PathKind},\n     per_ns::PerNs,\n@@ -289,80 +289,84 @@ impl DefCollector<'_> {\n         let module_id = self.def_map.root;\n \n         let attrs = item_tree.top_level_attrs(self.db, self.def_map.krate);\n-        if attrs.cfg().map_or(true, |cfg| self.cfg_options.check(&cfg) != Some(false)) {\n-            self.inject_prelude(&attrs);\n-\n-            // Process other crate-level attributes.\n-            for attr in &*attrs {\n-                let attr_name = match attr.path.as_ident() {\n-                    Some(name) => name,\n-                    None => continue,\n-                };\n+        if let Some(cfg) = attrs.cfg() {\n+            if self.cfg_options.check(&cfg) == Some(false) {\n+                return;\n+            }\n+        }\n \n-                if *attr_name == hir_expand::name![recursion_limit] {\n-                    if let Some(limit) = attr.string_value() {\n-                        if let Ok(limit) = limit.parse() {\n-                            self.def_map.recursion_limit = Some(limit);\n-                        }\n-                    }\n-                    continue;\n-                }\n+        self.inject_prelude(&attrs);\n \n-                if *attr_name == hir_expand::name![crate_type] {\n-                    if let Some(\"proc-macro\") = attr.string_value().map(SmolStr::as_str) {\n-                        self.is_proc_macro = true;\n-                    }\n-                    continue;\n-                }\n+        // Process other crate-level attributes.\n+        for attr in &*attrs {\n+            let attr_name = match attr.path.as_ident() {\n+                Some(name) => name,\n+                None => continue,\n+            };\n \n-                if attr_name.as_text().as_deref() == Some(\"rustc_coherence_is_core\") {\n-                    self.def_map.rustc_coherence_is_core = true;\n-                    continue;\n+            if *attr_name == hir_expand::name![recursion_limit] {\n+                if let Some(limit) = attr.string_value() {\n+                    if let Ok(limit) = limit.parse() {\n+                        self.def_map.recursion_limit = Some(limit);\n+                    }\n                 }\n+                continue;\n+            }\n \n-                if *attr_name == hir_expand::name![feature] {\n-                    let hygiene = &Hygiene::new_unhygienic();\n-                    let features = attr\n-                        .parse_path_comma_token_tree(self.db.upcast(), hygiene)\n-                        .into_iter()\n-                        .flatten()\n-                        .filter_map(|feat| match feat.segments() {\n-                            [name] => Some(name.to_smol_str()),\n-                            _ => None,\n-                        });\n-                    self.def_map.unstable_features.extend(features);\n+            if *attr_name == hir_expand::name![crate_type] {\n+                if let Some(\"proc-macro\") = attr.string_value().map(SmolStr::as_str) {\n+                    self.is_proc_macro = true;\n                 }\n+                continue;\n+            }\n \n-                let attr_is_register_like = *attr_name == hir_expand::name![register_attr]\n-                    || *attr_name == hir_expand::name![register_tool];\n-                if !attr_is_register_like {\n-                    continue;\n-                }\n+            if attr_name.as_text().as_deref() == Some(\"rustc_coherence_is_core\") {\n+                self.def_map.rustc_coherence_is_core = true;\n+                continue;\n+            }\n \n-                let registered_name = match attr.single_ident_value() {\n-                    Some(ident) => ident.as_name(),\n-                    _ => continue,\n-                };\n+            if *attr_name == hir_expand::name![feature] {\n+                let hygiene = &Hygiene::new_unhygienic();\n+                let features = attr\n+                    .parse_path_comma_token_tree(self.db.upcast(), hygiene)\n+                    .into_iter()\n+                    .flatten()\n+                    .filter_map(|feat| match feat.segments() {\n+                        [name] => Some(name.to_smol_str()),\n+                        _ => None,\n+                    });\n+                self.def_map.unstable_features.extend(features);\n+            }\n \n-                if *attr_name == hir_expand::name![register_attr] {\n-                    self.def_map.registered_attrs.push(registered_name.to_smol_str());\n-                    cov_mark::hit!(register_attr);\n-                } else {\n-                    self.def_map.registered_tools.push(registered_name.to_smol_str());\n-                    cov_mark::hit!(register_tool);\n-                }\n+            let attr_is_register_like = *attr_name == hir_expand::name![register_attr]\n+                || *attr_name == hir_expand::name![register_tool];\n+            if !attr_is_register_like {\n+                continue;\n             }\n \n-            ModCollector {\n-                def_collector: self,\n-                macro_depth: 0,\n-                module_id,\n-                tree_id: TreeId::new(file_id.into(), None),\n-                item_tree: &item_tree,\n-                mod_dir: ModDir::root(),\n+            let registered_name = match attr.single_ident_value() {\n+                Some(ident) => ident.as_name(),\n+                _ => continue,\n+            };\n+\n+            if *attr_name == hir_expand::name![register_attr] {\n+                self.def_map.registered_attrs.push(registered_name.to_smol_str());\n+                cov_mark::hit!(register_attr);\n+            } else {\n+                self.def_map.registered_tools.push(registered_name.to_smol_str());\n+                cov_mark::hit!(register_tool);\n             }\n-            .collect_in_top_module(item_tree.top_level_items());\n         }\n+\n+        ModCollector {\n+            def_collector: self,\n+            macro_depth: 0,\n+            module_id,\n+            tree_id: TreeId::new(file_id.into(), None),\n+            item_tree: &item_tree,\n+            mod_dir: ModDir::root(),\n+        }\n+        .collect_in_top_module(item_tree.top_level_items());\n     }\n \n     fn seed_with_inner(&mut self, tree_id: TreeId) {\n@@ -543,33 +547,26 @@ impl DefCollector<'_> {\n             Edition::Edition2015 => PathKind::Plain,\n             _ => PathKind::Abs,\n         };\n-        let path =\n-            ModPath::from_segments(path_kind, [krate.clone(), name![prelude], edition].into_iter());\n-        // Fall back to the older `std::prelude::v1` for compatibility with Rust <1.52.0\n-        // FIXME remove this fallback\n-        let fallback_path =\n-            ModPath::from_segments(path_kind, [krate, name![prelude], name![v1]].into_iter());\n-\n-        for path in &[path, fallback_path] {\n-            let (per_ns, _) = self.def_map.resolve_path(\n-                self.db,\n-                self.def_map.root,\n-                path,\n-                BuiltinShadowMode::Other,\n-            );\n+        let path = ModPath::from_segments(path_kind, [krate, name![prelude], edition]);\n+\n+        let (per_ns, _) = self.def_map.resolve_path(\n+            self.db,\n+            self.def_map.root,\n+            &path,\n+            BuiltinShadowMode::Other,\n+            None,\n+        );\n \n-            match per_ns.types {\n-                Some((ModuleDefId::ModuleId(m), _)) => {\n-                    self.def_map.prelude = Some(m);\n-                    break;\n-                }\n-                types => {\n-                    tracing::debug!(\n-                        \"could not resolve prelude path `{}` to module (resolved to {:?})\",\n-                        path,\n-                        types\n-                    );\n-                }\n+        match per_ns.types {\n+            Some((ModuleDefId::ModuleId(m), _)) => {\n+                self.def_map.prelude = Some(m);\n+            }\n+            types => {\n+                tracing::debug!(\n+                    \"could not resolve prelude path `{}` to module (resolved to {:?})\",\n+                    path,\n+                    types\n+                );\n             }\n         }\n     }\n@@ -715,6 +712,7 @@ impl DefCollector<'_> {\n     }\n \n     /// Import macros from `#[macro_use] extern crate`.\n+    // FIXME: Support `#[macro_rules(macro_name, ...)]`.\n     fn import_macros_from_extern_crate(\n         &mut self,\n         current_module_id: LocalModuleId,\n@@ -733,7 +731,7 @@ impl DefCollector<'_> {\n             }\n \n             cov_mark::hit!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-            self.import_all_macros_exported(current_module_id, m.krate);\n+            self.import_all_macros_exported(m.krate);\n         }\n     }\n \n@@ -742,11 +740,12 @@ impl DefCollector<'_> {\n     /// Exported macros are just all macros in the root module scope.\n     /// Note that it contains not only all `#[macro_export]` macros, but also all aliases\n     /// created by `use` in the root module, ignoring the visibility of `use`.\n-    fn import_all_macros_exported(&mut self, current_module_id: LocalModuleId, krate: CrateId) {\n+    fn import_all_macros_exported(&mut self, krate: CrateId) {\n         let def_map = self.db.crate_def_map(krate);\n         for (name, def) in def_map[def_map.root].scope.macros() {\n-            // `#[macro_use]` brings macros into legacy scope. Yes, even non-`macro_rules!` macros.\n-            self.define_legacy_macro(current_module_id, name.clone(), def);\n+            // `#[macro_use]` brings macros into macro_use prelude. Yes, even non-`macro_rules!`\n+            // macros.\n+            self.def_map.macro_use_prelude.insert(name.clone(), def);\n         }\n     }\n \n@@ -802,6 +801,7 @@ impl DefCollector<'_> {\n                 module_id,\n                 &import.path,\n                 BuiltinShadowMode::Module,\n+                None, // An import may resolve to any kind of macro.\n             );\n \n             let def = res.resolved_def;\n@@ -1099,14 +1099,22 @@ impl DefCollector<'_> {\n             resolved.push((directive.module_id, directive.depth, directive.container, call_id));\n         };\n         let mut res = ReachedFixedPoint::Yes;\n+        // Retain unresolved macros after this round of resolution.\n         macros.retain(|directive| {\n+            let subns = match &directive.kind {\n+                MacroDirectiveKind::FnLike { .. } => MacroSubNs::Bang,\n+                MacroDirectiveKind::Attr { .. } | MacroDirectiveKind::Derive { .. } => {\n+                    MacroSubNs::Attr\n+                }\n+            };\n             let resolver = |path| {\n                 let resolved_res = self.def_map.resolve_path_fp_with_macro(\n                     self.db,\n                     ResolveMode::Other,\n                     directive.module_id,\n                     &path,\n                     BuiltinShadowMode::Module,\n+                    Some(subns),\n                 );\n                 resolved_res\n                     .resolved_def\n@@ -1425,6 +1433,7 @@ impl DefCollector<'_> {\n                                 directive.module_id,\n                                 &path,\n                                 BuiltinShadowMode::Module,\n+                                Some(MacroSubNs::Bang),\n                             );\n                             resolved_res\n                                 .resolved_def\n@@ -1517,26 +1526,32 @@ impl ModCollector<'_, '_> {\n \n     fn collect(&mut self, items: &[ModItem], container: ItemContainerId) {\n         let krate = self.def_collector.def_map.krate;\n+        let is_crate_root = self.module_id == self.def_collector.def_map.root;\n \n         // Note: don't assert that inserted value is fresh: it's simply not true\n         // for macros.\n         self.def_collector.mod_dirs.insert(self.module_id, self.mod_dir.clone());\n \n         // Prelude module is always considered to be `#[macro_use]`.\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n-            if prelude_module.krate != krate {\n+            if prelude_module.krate != krate && is_crate_root {\n                 cov_mark::hit!(prelude_is_macro_use);\n-                self.def_collector.import_all_macros_exported(self.module_id, prelude_module.krate);\n+                self.def_collector.import_all_macros_exported(prelude_module.krate);\n             }\n         }\n \n         // This should be processed eagerly instead of deferred to resolving.\n         // `#[macro_use] extern crate` is hoisted to imports macros before collecting\n         // any other items.\n-        for &item in items {\n-            let attrs = self.item_tree.attrs(self.def_collector.db, krate, item.into());\n-            if attrs.cfg().map_or(true, |cfg| self.is_cfg_enabled(&cfg)) {\n-                if let ModItem::ExternCrate(id) = item {\n+        //\n+        // If we're not at the crate root, `macro_use`d extern crates are an error so let's just\n+        // ignore them.\n+        // FIXME: Support `#[macro_rules(macro_name, ...)]`.\n+        if is_crate_root {\n+            for &item in items {\n+                let ModItem::ExternCrate(id) = item else { continue; };\n+                let attrs = self.item_tree.attrs(self.def_collector.db, krate, item.into());\n+                if attrs.cfg().map_or(true, |cfg| self.is_cfg_enabled(&cfg)) {\n                     let import = &self.item_tree[id];\n                     let attrs = self.item_tree.attrs(\n                         self.def_collector.db,"}, {"sha": "4740fd7f449944755a3747c356589df85a3306ee", "filename": "crates/hir-def/src/nameres/path_resolution.rs", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -16,7 +16,7 @@ use hir_expand::name::Name;\n use crate::{\n     db::DefDatabase,\n     item_scope::BUILTIN_SCOPE,\n-    nameres::{BuiltinShadowMode, DefMap},\n+    nameres::{sub_namespace_match, BuiltinShadowMode, DefMap, MacroSubNs},\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n     visibility::{RawVisibility, Visibility},\n@@ -58,6 +58,17 @@ impl ResolvePathResult {\n     }\n }\n \n+impl PerNs {\n+    fn filter_macro(mut self, db: &dyn DefDatabase, expected: Option<MacroSubNs>) -> Self {\n+        self.macros = self.macros.filter(|&(id, _)| {\n+            let this = MacroSubNs::from_id(db, id);\n+            sub_namespace_match(Some(this), expected)\n+        });\n+\n+        self\n+    }\n+}\n+\n impl DefMap {\n     pub(super) fn resolve_name_in_extern_prelude(\n         &self,\n@@ -83,7 +94,7 @@ impl DefMap {\n         let mut vis = match visibility {\n             RawVisibility::Module(path) => {\n                 let (result, remaining) =\n-                    self.resolve_path(db, original_module, path, BuiltinShadowMode::Module);\n+                    self.resolve_path(db, original_module, path, BuiltinShadowMode::Module, None);\n                 if remaining.is_some() {\n                     return None;\n                 }\n@@ -124,6 +135,9 @@ impl DefMap {\n         mut original_module: LocalModuleId,\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n+        // Pass `MacroSubNs` if we know we're resolving macro names and which kind of macro we're\n+        // resolving them to. Pass `None` otherwise, e.g. when we're resolving import paths.\n+        expected_macro_subns: Option<MacroSubNs>,\n     ) -> ResolvePathResult {\n         let mut result = ResolvePathResult::empty(ReachedFixedPoint::No);\n \n@@ -136,6 +150,7 @@ impl DefMap {\n                 original_module,\n                 path,\n                 shadow,\n+                expected_macro_subns,\n             );\n \n             // Merge `new` into `result`.\n@@ -169,6 +184,7 @@ impl DefMap {\n         original_module: LocalModuleId,\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n+        expected_macro_subns: Option<MacroSubNs>,\n     ) -> ResolvePathResult {\n         let graph = db.crate_graph();\n         let _cx = stdx::panic_context::enter(format!(\n@@ -220,7 +236,13 @@ impl DefMap {\n                     if path.segments().len() == 1 { shadow } else { BuiltinShadowMode::Module };\n \n                 tracing::debug!(\"resolving {:?} in module\", segment);\n-                self.resolve_name_in_module(db, original_module, segment, prefer_module)\n+                self.resolve_name_in_module(\n+                    db,\n+                    original_module,\n+                    segment,\n+                    prefer_module,\n+                    expected_macro_subns,\n+                )\n             }\n             PathKind::Super(lvl) => {\n                 let mut module = original_module;\n@@ -245,6 +267,7 @@ impl DefMap {\n                                     block.parent.local_id,\n                                     &new_path,\n                                     shadow,\n+                                    expected_macro_subns,\n                                 );\n                             }\n                             None => {\n@@ -303,7 +326,12 @@ impl DefMap {\n                         );\n                         tracing::debug!(\"resolving {:?} in other crate\", path);\n                         let defp_map = module.def_map(db);\n-                        let (def, s) = defp_map.resolve_path(db, module.local_id, &path, shadow);\n+                        // Macro sub-namespaces only matter when resolving single-segment paths\n+                        // because `macro_use` and other preludes should be taken into account. At\n+                        // this point, we know we're resolving a multi-segment path so macro kind\n+                        // expectation is discarded.\n+                        let (def, s) =\n+                            defp_map.resolve_path(db, module.local_id, &path, shadow, None);\n                         return ResolvePathResult::with(\n                             def,\n                             ReachedFixedPoint::Yes,\n@@ -381,19 +409,24 @@ impl DefMap {\n         module: LocalModuleId,\n         name: &Name,\n         shadow: BuiltinShadowMode,\n+        expected_macro_subns: Option<MacroSubNs>,\n     ) -> PerNs {\n         // Resolve in:\n         //  - legacy scope of macro\n         //  - current module / scope\n-        //  - extern prelude\n+        //  - extern prelude / macro_use prelude\n         //  - std prelude\n         let from_legacy_macro = self[module]\n             .scope\n             .get_legacy_macro(name)\n             // FIXME: shadowing\n             .and_then(|it| it.last())\n-            .map_or_else(PerNs::none, |&m| PerNs::macros(m, Visibility::Public));\n-        let from_scope = self[module].scope.get(name);\n+            .copied()\n+            .filter(|&id| {\n+                sub_namespace_match(Some(MacroSubNs::from_id(db, id)), expected_macro_subns)\n+            })\n+            .map_or_else(PerNs::none, |m| PerNs::macros(m, Visibility::Public));\n+        let from_scope = self[module].scope.get(name).filter_macro(db, expected_macro_subns);\n         let from_builtin = match self.block {\n             Some(_) => {\n                 // Only resolve to builtins in the root `DefMap`.\n@@ -414,9 +447,18 @@ impl DefMap {\n                 .get(name)\n                 .map_or(PerNs::none(), |&it| PerNs::types(it.into(), Visibility::Public))\n         };\n+        let macro_use_prelude = || {\n+            self.macro_use_prelude\n+                .get(name)\n+                .map_or(PerNs::none(), |&it| PerNs::macros(it.into(), Visibility::Public))\n+        };\n         let prelude = || self.resolve_in_prelude(db, name);\n \n-        from_legacy_macro.or(from_scope_or_builtin).or_else(extern_prelude).or_else(prelude)\n+        from_legacy_macro\n+            .or(from_scope_or_builtin)\n+            .or_else(extern_prelude)\n+            .or_else(macro_use_prelude)\n+            .or_else(prelude)\n     }\n \n     fn resolve_name_in_crate_root_or_extern_prelude("}, {"sha": "e795b7b9b7e6fadb7bb1f5843195e28a5bf0477d", "filename": "crates/hir-def/src/nameres/tests/macros.rs", "status": "modified", "additions": 103, "deletions": 8, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -1216,17 +1216,112 @@ fn proc_attr(a: TokenStream, b: TokenStream) -> TokenStream { a }\n     \"#,\n     );\n \n-    let root = &def_map[def_map.root()].scope;\n-    let actual = root\n-        .legacy_macros()\n-        .sorted_by(|a, b| std::cmp::Ord::cmp(&a.0, &b.0))\n-        .map(|(name, _)| format!(\"{name}\\n\"))\n-        .collect::<String>();\n+    let root_module = &def_map[def_map.root()].scope;\n+    assert!(\n+        root_module.legacy_macros().count() == 0,\n+        \"`#[macro_use]` shouldn't bring macros into textual macro scope\",\n+    );\n+\n+    let actual = def_map.macro_use_prelude.iter().map(|(name, _)| name).sorted().join(\"\\n\");\n \n     expect![[r#\"\n         legacy\n         macro20\n-        proc_attr\n-    \"#]]\n+        proc_attr\"#]]\n     .assert_eq(&actual);\n }\n+\n+#[test]\n+fn non_prelude_macros_take_precedence_over_macro_use_prelude() {\n+    check(\n+        r#\"\n+//- /lib.rs edition:2021 crate:lib deps:dep,core\n+#[macro_use]\n+extern crate dep;\n+\n+macro foo() { struct Ok; }\n+macro bar() { fn ok() {} }\n+\n+foo!();\n+bar!();\n+\n+//- /dep.rs crate:dep\n+#[macro_export]\n+macro_rules! foo {\n+    () => { struct NotOk; }\n+}\n+\n+//- /core.rs crate:core\n+pub mod prelude {\n+    pub mod rust_2021 {\n+        #[macro_export]\n+        macro_rules! bar {\n+            () => { fn not_ok() {} }\n+        }\n+    }\n+}\n+        \"#,\n+        expect![[r#\"\n+            crate\n+            Ok: t v\n+            bar: m\n+            dep: t\n+            foo: m\n+            ok: v\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn macro_sub_namespace() {\n+    let map = compute_crate_def_map(\n+        r#\"\n+//- minicore: derive, clone\n+macro_rules! Clone { () => {} }\n+macro_rules! derive { () => {} }\n+\n+#[derive(Clone)]\n+struct S;\n+    \"#,\n+    );\n+    assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n+}\n+\n+#[test]\n+fn macro_sub_namespace2() {\n+    check(\n+        r#\"\n+//- /main.rs edition:2021 crate:main deps:proc,core\n+use proc::{foo, bar};\n+\n+foo!();\n+bar!();\n+\n+//- /proc.rs crate:proc\n+#![crate_type=\"proc-macro\"]\n+#[proc_macro_derive(foo)]\n+pub fn foo() {}\n+#[proc_macro_attribute]\n+pub fn bar() {}\n+\n+//- /core.rs crate:core\n+pub mod prelude {\n+    pub mod rust_2021 {\n+        pub macro foo() {\n+            struct Ok;\n+        }\n+        pub macro bar() {\n+            fn ok() {}\n+        }\n+    }\n+}\n+    \"#,\n+        expect![[r#\"\n+            crate\n+            Ok: t v\n+            bar: m\n+            foo: m\n+            ok: v\n+        \"#]],\n+    );\n+}"}, {"sha": "4bec2b4dea429fb157af120267fe0d17033a5cad", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -17,7 +17,7 @@ use crate::{\n     hir::{BindingId, ExprId, LabelId},\n     item_scope::{BuiltinShadowMode, BUILTIN_SCOPE},\n     lang_item::LangItemTarget,\n-    nameres::DefMap,\n+    nameres::{DefMap, MacroSubNs},\n     path::{ModPath, Path, PathKind},\n     per_ns::PerNs,\n     visibility::{RawVisibility, Visibility},\n@@ -155,7 +155,8 @@ impl Resolver {\n         path: &ModPath,\n     ) -> Option<PerNs> {\n         let (item_map, module) = self.item_scope();\n-        let (module_res, idx) = item_map.resolve_path(db, module, path, BuiltinShadowMode::Module);\n+        let (module_res, idx) =\n+            item_map.resolve_path(db, module, path, BuiltinShadowMode::Module, None);\n         match module_res.take_types()? {\n             ModuleDefId::TraitId(it) => {\n                 let idx = idx?;\n@@ -385,9 +386,17 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroId> {\n+    pub fn resolve_path_as_macro(\n+        &self,\n+        db: &dyn DefDatabase,\n+        path: &ModPath,\n+        expected_macro_kind: Option<MacroSubNs>,\n+    ) -> Option<MacroId> {\n         let (item_map, module) = self.item_scope();\n-        item_map.resolve_path(db, module, path, BuiltinShadowMode::Other).0.take_macros()\n+        item_map\n+            .resolve_path(db, module, path, BuiltinShadowMode::Other, expected_macro_kind)\n+            .0\n+            .take_macros()\n     }\n \n     /// Returns a set of names available in the current scope.\n@@ -626,7 +635,8 @@ impl Resolver {\n         shadow: BuiltinShadowMode,\n     ) -> PerNs {\n         let (item_map, module) = self.item_scope();\n-        let (module_res, segment_index) = item_map.resolve_path(db, module, path, shadow);\n+        // This method resolves `path` just like import paths, so no expected macro subns is given.\n+        let (module_res, segment_index) = item_map.resolve_path(db, module, path, shadow, None);\n         if segment_index.is_some() {\n             return PerNs::none();\n         }"}, {"sha": "9c8dc4ed1fca761a9b0f371e374b748cf3cabf44", "filename": "crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -135,9 +135,8 @@ fn line_expand(\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     // dummy implementation for type-checking purposes\n-    let line_num = 0;\n     let expanded = quote! {\n-        #line_num\n+        0 as u32\n     };\n \n     ExpandResult::ok(expanded)\n@@ -179,9 +178,8 @@ fn column_expand(\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     // dummy implementation for type-checking purposes\n-    let col_num = 0;\n     let expanded = quote! {\n-        #col_num\n+        0 as u32\n     };\n \n     ExpandResult::ok(expanded)"}, {"sha": "0c68891fe4932de9478aa04103ac69dc533e88f3", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -24,6 +24,7 @@ use hir_def::{\n         TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n     },\n     lang_item::{lang_attr, LangItem},\n+    nameres::MacroSubNs,\n     path::{GenericArg, GenericArgs, ModPath, Path, PathKind, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{ConstRefOrPath, TraitBoundModifier, TraitRef as HirTraitRef, TypeBound, TypeRef},\n@@ -378,9 +379,15 @@ impl<'a> TyLoweringContext<'a> {\n                 };\n                 let ty = {\n                     let macro_call = macro_call.to_node(self.db.upcast());\n-                    match expander.enter_expand::<ast::Type>(self.db.upcast(), macro_call, |path| {\n-                        self.resolver.resolve_path_as_macro(self.db.upcast(), &path)\n-                    }) {\n+                    let resolver = |path| {\n+                        self.resolver.resolve_path_as_macro(\n+                            self.db.upcast(),\n+                            &path,\n+                            Some(MacroSubNs::Bang),\n+                        )\n+                    };\n+                    match expander.enter_expand::<ast::Type>(self.db.upcast(), macro_call, resolver)\n+                    {\n                         Ok(ExpandResult { value: Some((mark, expanded)), .. }) => {\n                             let ctx = expander.ctx(self.db.upcast());\n                             // FIXME: Report syntax errors in expansion here"}, {"sha": "9377a3a5f26ac53798ca97900416bed12e359581", "filename": "crates/hir-ty/src/tests/macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -661,8 +661,9 @@ fn infer_builtin_macros_line() {\n         \"#,\n         expect![[r#\"\n             !0..1 '0': i32\n+            !0..6 '0asu32': u32\n             63..87 '{     ...!(); }': ()\n-            73..74 'x': i32\n+            73..74 'x': u32\n         \"#]],\n     );\n }\n@@ -699,8 +700,9 @@ fn infer_builtin_macros_column() {\n         \"#,\n         expect![[r#\"\n             !0..1 '0': i32\n+            !0..6 '0asu32': u32\n             65..91 '{     ...!(); }': ()\n-            75..76 'x': i32\n+            75..76 'x': u32\n         \"#]],\n     );\n }"}, {"sha": "b817937296d204607493bb4e98463db8e20a4c7e", "filename": "crates/hir/src/attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fattrs.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -4,7 +4,6 @@ use hir_def::{\n     attr::{AttrsWithOwner, Documentation},\n     item_scope::ItemInNs,\n     path::ModPath,\n-    per_ns::PerNs,\n     resolver::HasResolver,\n     AttrDefId, GenericParamId, ModuleDefId,\n };\n@@ -121,6 +120,7 @@ impl HasAttrs for AssocItem {\n     }\n }\n \n+/// Resolves the item `link` points to in the scope of `def`.\n fn resolve_doc_path(\n     db: &dyn HirDatabase,\n     def: AttrDefId,\n@@ -155,14 +155,14 @@ fn resolve_doc_path(\n             .syntax_node()\n             .descendants()\n             .find_map(ast::Path::cast)?;\n-        if ast_path.to_string() != link {\n+        if ast_path.syntax().text() != link {\n             return None;\n         }\n         ModPath::from_src(db.upcast(), ast_path, &Hygiene::new_unhygienic())?\n     };\n \n     let resolved = resolver.resolve_module_path_in_items(db.upcast(), &modpath);\n-    let resolved = if resolved == PerNs::none() {\n+    let resolved = if resolved.is_none() {\n         resolver.resolve_module_path_in_trait_assoc_items(db.upcast(), &modpath)?\n     } else {\n         resolved"}, {"sha": "2d2b00b147e554078dd79c0a676672c82cfde769", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -10,6 +10,7 @@ use hir_def::{\n     hir::Expr,\n     lower::LowerCtx,\n     macro_id_to_def_id,\n+    nameres::MacroSubNs,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n     type_ref::Mutability,\n     AsMacroCall, DefWithBodyId, FieldId, FunctionId, MacroId, TraitId, VariantId,\n@@ -616,7 +617,7 @@ impl<'db> SemanticsImpl<'db> {\n         let krate = resolver.krate();\n         let macro_call_id = macro_call.as_call_id(self.db.upcast(), krate, |path| {\n             resolver\n-                .resolve_path_as_macro(self.db.upcast(), &path)\n+                .resolve_path_as_macro(self.db.upcast(), &path, Some(MacroSubNs::Bang))\n                 .map(|it| macro_id_to_def_id(self.db.upcast(), it))\n         })?;\n         hir_expand::db::expand_speculative("}, {"sha": "dae77fad2f37b2a425cce8e7cdf49d662e751e9c", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3387454d7c70ec768114871682ee2946ec88a8/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=9b3387454d7c70ec768114871682ee2946ec88a8", "patch": "@@ -17,6 +17,7 @@ use hir_def::{\n     lang_item::LangItem,\n     lower::LowerCtx,\n     macro_id_to_def_id,\n+    nameres::MacroSubNs,\n     path::{ModPath, Path, PathKind},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n     type_ref::Mutability,\n@@ -484,7 +485,9 @@ impl SourceAnalyzer {\n     ) -> Option<Macro> {\n         let ctx = LowerCtx::with_file_id(db.upcast(), macro_call.file_id);\n         let path = macro_call.value.path().and_then(|ast| Path::from_src(ast, &ctx))?;\n-        self.resolver.resolve_path_as_macro(db.upcast(), path.mod_path()?).map(|it| it.into())\n+        self.resolver\n+            .resolve_path_as_macro(db.upcast(), path.mod_path()?, Some(MacroSubNs::Bang))\n+            .map(|it| it.into())\n     }\n \n     pub(crate) fn resolve_bind_pat_to_const(\n@@ -678,7 +681,7 @@ impl SourceAnalyzer {\n                     }\n                 }\n             }\n-            return match resolve_hir_path_as_macro(db, &self.resolver, &hir_path) {\n+            return match resolve_hir_path_as_attr_macro(db, &self.resolver, &hir_path) {\n                 Some(m) => Some(PathResolution::Def(ModuleDef::Macro(m))),\n                 // this labels any path that starts with a tool module as the tool itself, this is technically wrong\n                 // but there is no benefit in differentiating these two cases for the time being\n@@ -756,7 +759,7 @@ impl SourceAnalyzer {\n         let krate = self.resolver.krate();\n         let macro_call_id = macro_call.as_call_id(db.upcast(), krate, |path| {\n             self.resolver\n-                .resolve_path_as_macro(db.upcast(), &path)\n+                .resolve_path_as_macro(db.upcast(), &path, Some(MacroSubNs::Bang))\n                 .map(|it| macro_id_to_def_id(db.upcast(), it))\n         })?;\n         Some(macro_call_id.as_file()).filter(|it| it.expansion_level(db.upcast()) < 64)\n@@ -956,12 +959,14 @@ pub(crate) fn resolve_hir_path(\n }\n \n #[inline]\n-pub(crate) fn resolve_hir_path_as_macro(\n+pub(crate) fn resolve_hir_path_as_attr_macro(\n     db: &dyn HirDatabase,\n     resolver: &Resolver,\n     path: &Path,\n ) -> Option<Macro> {\n-    resolver.resolve_path_as_macro(db.upcast(), path.mod_path()?).map(Into::into)\n+    resolver\n+        .resolve_path_as_macro(db.upcast(), path.mod_path()?, Some(MacroSubNs::Attr))\n+        .map(Into::into)\n }\n \n fn resolve_hir_path_(\n@@ -1060,7 +1065,7 @@ fn resolve_hir_path_(\n \n     let macros = || {\n         resolver\n-            .resolve_path_as_macro(db.upcast(), path.mod_path()?)\n+            .resolve_path_as_macro(db.upcast(), path.mod_path()?, None)\n             .map(|def| PathResolution::Def(ModuleDef::Macro(def.into())))\n     };\n "}]}