{"sha": "35c798b3fcef00f6a31b40da91afa596a1476b4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1Yzc5OGIzZmNlZjAwZjZhMzFiNDBkYTkxYWZhNTk2YTE0NzZiNGI=", "commit": {"author": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-03-01T17:20:46Z"}, "committer": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-03-03T02:55:37Z"}, "message": "metadata: Bye bye `EsLabel`. No regrets.\n\nFor the reference, while it is designed to be selectively enabled,\nit was essentially enabled throughout every snapshot and nightly\nas far as I can tell. This makes the usefulness of `EsLabel` itself\nquestionable, as it was quite rare that `EsLabel` broke the build.\nIt had consumed about 20~30% of metadata (!) and so this should be\na huge win.", "tree": {"sha": "05dc437350946841f33b60eacd4ebde21757aeb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05dc437350946841f33b60eacd4ebde21757aeb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35c798b3fcef00f6a31b40da91afa596a1476b4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35c798b3fcef00f6a31b40da91afa596a1476b4b", "html_url": "https://github.com/rust-lang/rust/commit/35c798b3fcef00f6a31b40da91afa596a1476b4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35c798b3fcef00f6a31b40da91afa596a1476b4b/comments", "author": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f3aa0dd2e9a599a80e22d79c33a5d7e2554f90b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f3aa0dd2e9a599a80e22d79c33a5d7e2554f90b", "html_url": "https://github.com/rust-lang/rust/commit/2f3aa0dd2e9a599a80e22d79c33a5d7e2554f90b"}], "stats": {"total": 51, "additions": 4, "deletions": 47}, "files": [{"sha": "70a6ff88f06963097e1bae35660dd44e78c55114", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 4, "deletions": 47, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/35c798b3fcef00f6a31b40da91afa596a1476b4b/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c798b3fcef00f6a31b40da91afa596a1476b4b/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=35c798b3fcef00f6a31b40da91afa596a1476b4b", "patch": "@@ -108,11 +108,7 @@ pub enum EbmlEncoderTag {\n     EsMap      = 0x15,\n     EsMapKey   = 0x16,\n     EsMapVal   = 0x17,\n-\n     EsOpaque   = 0x18,\n-\n-    // Used only when debugging\n-    EsLabel    = 0x19,\n }\n \n const NUM_TAGS: uint = 0x1000;\n@@ -159,7 +155,7 @@ pub mod reader {\n     use super::{ ApplicationError, EsVec, EsMap, EsEnum, EsVecLen, EsVecElt,\n         EsMapLen, EsMapKey, EsEnumVid, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64,\n         EsI32, EsI16, EsI8, EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n-        EsUint, EsOpaque, EsLabel, EbmlEncoderTag, Doc, TaggedDoc,\n+        EsUint, EsOpaque, EbmlEncoderTag, Doc, TaggedDoc,\n         Error, IntTooBig, InvalidTag, Expected, NUM_IMPLICIT_TAGS, TAG_IMPLICIT_LEN };\n \n     pub type DecodeResult<T> = Result<T, Error>;\n@@ -395,23 +391,6 @@ pub mod reader {\n             }\n         }\n \n-        fn _check_label(&mut self, lbl: &str) -> DecodeResult<()> {\n-            if self.pos < self.parent.end {\n-                let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                    try!(doc_at(self.parent.data, self.pos));\n-\n-                if r_tag == (EsLabel as uint) {\n-                    self.pos = r_doc.end;\n-                    let str = r_doc.as_str_slice();\n-                    if lbl != str {\n-                        return Err(Expected(format!(\"Expected label {:?} but \\\n-                                                     found {:?}\", lbl, str)));\n-                    }\n-                }\n-            }\n-            Ok(())\n-        }\n-\n         fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<Doc<'doc>> {\n             debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n             if self.pos >= self.parent.end {\n@@ -540,7 +519,6 @@ pub mod reader {\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_enum({})\", name);\n-            try!(self._check_label(name));\n \n             let doc = try!(self.next_doc(EsEnum));\n \n@@ -606,7 +584,6 @@ pub mod reader {\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n-            try!(self._check_label(name));\n             f(self)\n         }\n \n@@ -723,7 +700,7 @@ pub mod writer {\n     use super::{ EsVec, EsMap, EsEnum, EsVecLen, EsVecElt, EsMapLen, EsMapKey,\n         EsEnumVid, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64, EsI32, EsI16, EsI8,\n         EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal, EsUint,\n-        EsOpaque, EsLabel, EbmlEncoderTag, NUM_IMPLICIT_TAGS, NUM_TAGS };\n+        EsOpaque, EbmlEncoderTag, NUM_IMPLICIT_TAGS, NUM_TAGS };\n \n     use serialize;\n \n@@ -928,31 +905,13 @@ pub mod writer {\n     // FIXME (#2743): optionally perform \"relaxations\" on end_tag to more\n     // efficiently encode sizes; this is a fixed point iteration\n \n-    // Set to true to generate more debugging in EBML code.\n-    // Totally lame approach.\n-    #[cfg(not(ndebug))]\n-    static DEBUG: bool = true;\n-    #[cfg(ndebug)]\n-    static DEBUG: bool = false;\n-\n     impl<'a, W: Writer + Seek> Encoder<'a, W> {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) -> EncodeResult {\n             assert!(v <= 0xFFFF_FFFF);\n             self.wr_tagged_raw_u32(t as uint, v as u32)\n         }\n \n-        fn _emit_label(&mut self, label: &str) -> EncodeResult {\n-            // There are various strings that we have access to, such as\n-            // the name of a record field, which do not actually appear in\n-            // the encoded EBML (normally).  This is just for\n-            // efficiency.  When debugging, though, we can emit such\n-            // labels and then they will be checked by decoder to\n-            // try and check panics more quickly.\n-            if DEBUG { self.wr_tagged_str(EsLabel as uint, label) }\n-            else { Ok(()) }\n-        }\n-\n         pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<W>) -> EncodeResult,\n         {\n@@ -1021,10 +980,9 @@ pub mod writer {\n             self.wr_tagged_str(EsStr as uint, v)\n         }\n \n-        fn emit_enum<F>(&mut self, name: &str, f: F) -> EncodeResult where\n+        fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n         {\n-            try!(self._emit_label(name));\n             try!(self.start_tag(EsEnum as uint));\n             try!(f(self));\n             self.end_tag()\n@@ -1072,10 +1030,9 @@ pub mod writer {\n             f(self)\n         }\n \n-        fn emit_struct_field<F>(&mut self, name: &str, _: uint, f: F) -> EncodeResult where\n+        fn emit_struct_field<F>(&mut self, _name: &str, _: uint, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n         {\n-            try!(self._emit_label(name));\n             f(self)\n         }\n "}]}