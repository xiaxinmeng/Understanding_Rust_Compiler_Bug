{"sha": "e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MWNlZDNmOGQ4ZTJmM2YzNzdlZjkzMTQ1OGU2MTJkNWYzZDFmM2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-24T02:17:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-24T02:17:29Z"}, "message": "Auto merge of #66686 - Centril:rollup-07slyoo, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #64856 (Scope format! temporaries)\n - #66411 (mem::forget docs: mention ManuallyDrop)\n - #66594 (Fix cycle when debug-printing opaque types)\n - #66641 (parser: recover on nested ADTs as enum variants)\n - #66659 (make `./x.py bench` again)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "7d1fb15021ff6320393277ab0aeb5ce5ac5a566c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d1fb15021ff6320393277ab0aeb5ce5ac5a566c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "html_url": "https://github.com/rust-lang/rust/commit/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad808d95c4839caedc2be76d0ed059dc920ab4b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad808d95c4839caedc2be76d0ed059dc920ab4b6", "html_url": "https://github.com/rust-lang/rust/commit/ad808d95c4839caedc2be76d0ed059dc920ab4b6"}, {"sha": "d22bf91320cf3ba08326ca644e39de35592ce394", "url": "https://api.github.com/repos/rust-lang/rust/commits/d22bf91320cf3ba08326ca644e39de35592ce394", "html_url": "https://github.com/rust-lang/rust/commit/d22bf91320cf3ba08326ca644e39de35592ce394"}], "stats": {"total": 474, "additions": 315, "deletions": 159}, "files": [{"sha": "422d3486f92b29cc860cc33f4868590c7562f5e7", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "patch": "@@ -98,5 +98,8 @@ macro_rules! vec {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! format {\n-    ($($arg:tt)*) => ($crate::fmt::format($crate::__export::format_args!($($arg)*)))\n+    ($($arg:tt)*) => {{\n+        let res = $crate::fmt::format($crate::__export::format_args!($($arg)*));\n+        res\n+    }}\n }"}, {"sha": "2dcdf2b6fe9f71e60080c0e66cf07abaa2f408fe", "filename": "src/libcore/benches/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs?ref=e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "patch": "@@ -35,7 +35,7 @@ macro_rules! from_str_bench {\n                     .iter()\n                     .cycle()\n                     .take(5_000)\n-                    .filter_map(|s| <($t)>::from_str(s).ok())\n+                    .filter_map(|s| <$t>::from_str(s).ok())\n                     .max()\n             })\n         }\n@@ -51,7 +51,7 @@ macro_rules! from_str_radix_bench {\n                     .iter()\n                     .cycle()\n                     .take(5_000)\n-                    .filter_map(|s| <($t)>::from_str_radix(s, $radix).ok())\n+                    .filter_map(|s| <$t>::from_str_radix(s, $radix).ok())\n                     .max()\n             })\n         }"}, {"sha": "bba441464ff35bf22452748bd111b82829249b00", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "patch": "@@ -45,8 +45,9 @@ pub use crate::intrinsics::transmute;\n /// `mem::forget` from safe code does not fundamentally change Rust's safety\n /// guarantees.\n ///\n-/// That said, leaking resources such as memory or I/O objects is usually undesirable,\n-/// so `forget` is only recommended for specialized use cases like those shown below.\n+/// That said, leaking resources such as memory or I/O objects is usually undesirable.\n+/// The need comes up in some specialized use cases for FFI or unsafe code, but even\n+/// then, [`ManuallyDrop`] is typically preferred.\n ///\n /// Because forgetting a value is allowed, any `unsafe` code you write must\n /// allow for this possibility. You cannot return a value and expect that the\n@@ -68,7 +69,35 @@ pub use crate::intrinsics::transmute;\n /// ```\n ///\n /// The practical use cases for `forget` are rather specialized and mainly come\n-/// up in unsafe or FFI code.\n+/// up in unsafe or FFI code. However, [`ManuallyDrop`] is usually preferred\n+/// for such cases, e.g.:\n+///\n+/// ```\n+/// use std::mem::ManuallyDrop;\n+///\n+/// let v = vec![65, 122];\n+/// // Before we disassemble `v` into its raw parts, make sure it\n+/// // does not get dropped!\n+/// let mut v = ManuallyDrop::new(v);\n+/// // Now disassemble `v`. These operations cannot panic, so there cannot be a leak.\n+/// let ptr = v.as_mut_ptr();\n+/// let cap = v.capacity();\n+/// // Finally, build a `String`.\n+/// let s = unsafe { String::from_raw_parts(ptr, 2, cap) };\n+/// assert_eq!(s, \"Az\");\n+/// // `s` is implicitly dropped and its memory deallocated.\n+/// ```\n+///\n+/// Using `ManuallyDrop` here has two advantages:\n+///\n+/// * We do not \"touch\" `v` after disassembling it. For some types, operations\n+///   such as passing ownership (to a funcion like `mem::forget`) requires them to actually\n+///   be fully owned right now; that is a promise we do not want to make here as we are\n+///   in the process of transferring ownership to the new `String` we are building.\n+/// * In case of an unexpected panic, `ManuallyDrop` is not dropped, but if the panic\n+///   occurs before `mem::forget` was called we might end up dropping invalid data,\n+///   or double-dropping. In other words, `ManuallyDrop` errs on the side of leaking\n+///   instead of erring on the side of dropping.\n ///\n /// [drop]: fn.drop.html\n /// [uninit]: fn.uninitialized.html\n@@ -78,6 +107,7 @@ pub use crate::intrinsics::transmute;\n /// [leak]: ../../std/boxed/struct.Box.html#method.leak\n /// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n /// [ub]: ../../reference/behavior-considered-undefined.html\n+/// [`ManuallyDrop`]: struct.ManuallyDrop.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn forget<T>(t: T) {"}, {"sha": "e3b36be5696b3ca1d44d1fa35b46ee2f57b4a85c", "filename": "src/librustc/benches/dispatch.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad808d95c4839caedc2be76d0ed059dc920ab4b6/src%2Flibrustc%2Fbenches%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad808d95c4839caedc2be76d0ed059dc920ab4b6/src%2Flibrustc%2Fbenches%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fbenches%2Fdispatch.rs?ref=ad808d95c4839caedc2be76d0ed059dc920ab4b6", "patch": "@@ -1,34 +0,0 @@\n-use test::Bencher;\n-\n-// Static/dynamic method dispatch\n-\n-struct Struct {\n-    field: isize\n-}\n-\n-trait Trait {\n-    fn method(&self) -> isize;\n-}\n-\n-impl Trait for Struct {\n-    fn method(&self) -> isize {\n-        self.field\n-    }\n-}\n-\n-#[bench]\n-fn trait_vtable_method_call(b: &mut Bencher) {\n-    let s = Struct { field: 10 };\n-    let t = &s as &Trait;\n-    b.iter(|| {\n-        t.method()\n-    });\n-}\n-\n-#[bench]\n-fn trait_static_method_call(b: &mut Bencher) {\n-    let s = Struct { field: 10 };\n-    b.iter(|| {\n-        s.method()\n-    });\n-}"}, {"sha": "6b624028896ac15c8628e1c1d8135cbca02d5995", "filename": "src/librustc/benches/lib.rs", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Flibrustc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Flibrustc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fbenches%2Flib.rs?ref=e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "patch": "@@ -1,6 +1,63 @@\n+#![feature(slice_patterns)]\n #![feature(test)]\n \n extern crate test;\n \n-mod dispatch;\n-mod pattern;\n+use test::Bencher;\n+\n+// Static/dynamic method dispatch\n+\n+struct Struct {\n+    field: isize\n+}\n+\n+trait Trait {\n+    fn method(&self) -> isize;\n+}\n+\n+impl Trait for Struct {\n+    fn method(&self) -> isize {\n+        self.field\n+    }\n+}\n+\n+#[bench]\n+fn trait_vtable_method_call(b: &mut Bencher) {\n+    let s = Struct { field: 10 };\n+    let t = &s as &dyn Trait;\n+    b.iter(|| {\n+        t.method()\n+    });\n+}\n+\n+#[bench]\n+fn trait_static_method_call(b: &mut Bencher) {\n+    let s = Struct { field: 10 };\n+    b.iter(|| {\n+        s.method()\n+    });\n+}\n+\n+// Overhead of various match forms\n+\n+#[bench]\n+fn option_some(b: &mut Bencher) {\n+    let x = Some(10);\n+    b.iter(|| {\n+        match x {\n+            Some(y) => y,\n+            None => 11\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn vec_pattern(b: &mut Bencher) {\n+    let x = [1,2,3,4,5,6];\n+    b.iter(|| {\n+        match x {\n+            [1,2,3,..] => 10,\n+            _ => 11,\n+        }\n+    });\n+}"}, {"sha": "fd8cc5b83fd5a85ce2cbdd18642c3dfba17a4226", "filename": "src/librustc/benches/pattern.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad808d95c4839caedc2be76d0ed059dc920ab4b6/src%2Flibrustc%2Fbenches%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad808d95c4839caedc2be76d0ed059dc920ab4b6/src%2Flibrustc%2Fbenches%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fbenches%2Fpattern.rs?ref=ad808d95c4839caedc2be76d0ed059dc920ab4b6", "patch": "@@ -1,25 +0,0 @@\n-use test::Bencher;\n-\n-// Overhead of various match forms\n-\n-#[bench]\n-fn option_some(b: &mut Bencher) {\n-    let x = Some(10);\n-    b.iter(|| {\n-        match x {\n-            Some(y) => y,\n-            None => 11\n-        }\n-    });\n-}\n-\n-#[bench]\n-fn vec_pattern(b: &mut Bencher) {\n-    let x = [1,2,3,4,5,6];\n-    b.iter(|| {\n-        match x {\n-            [1,2,3,..] => 10,\n-            _ => 11,\n-        }\n-    });\n-}"}, {"sha": "ee05d57d239104b2b890a22647e842034a3caeaa", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 65, "deletions": 38, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "patch": "@@ -49,6 +49,24 @@ macro_rules! define_scoped_cx {\n thread_local! {\n     static FORCE_IMPL_FILENAME_LINE: Cell<bool> = Cell::new(false);\n     static SHOULD_PREFIX_WITH_CRATE: Cell<bool> = Cell::new(false);\n+    static NO_QUERIES: Cell<bool> = Cell::new(false);\n+}\n+\n+/// Avoids running any queries during any prints that occur\n+/// during the closure. This may alter the apperance of some\n+/// types (e.g. forcing verbose printing for opaque types).\n+/// This method is used during some queries (e.g. `predicates_of`\n+/// for opaque types), to ensure that any debug printing that\n+/// occurs during the query computation does not end up recursively\n+/// calling the same query.\n+pub fn with_no_queries<F: FnOnce() -> R, R>(f: F) -> R {\n+    NO_QUERIES.with(|no_queries| {\n+        let old = no_queries.get();\n+        no_queries.set(true);\n+        let result = f();\n+        no_queries.set(old);\n+        result\n+    })\n }\n \n /// Force us to name impls with just the filename/line number. We\n@@ -556,52 +574,61 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::Opaque(def_id, substs) => {\n                 // FIXME(eddyb) print this with `print_def_path`.\n-                if self.tcx().sess.verbose() {\n+                // We use verbose printing in 'NO_QUERIES' mode, to\n+                // avoid needing to call `predicates_of`. This should\n+                // only affect certain debug messages (e.g. messages printed\n+                // from `rustc::ty` during the computation of `tcx.predicates_of`),\n+                // and should have no effect on any compiler output.\n+                if self.tcx().sess.verbose() || NO_QUERIES.with(|q| q.get())  {\n                     p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n                     return Ok(self);\n                 }\n \n-                let def_key = self.tcx().def_key(def_id);\n-                if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n-                    p!(write(\"{}\", name));\n-                    let mut substs = substs.iter();\n-                    // FIXME(eddyb) print this with `print_def_path`.\n-                    if let Some(first) = substs.next() {\n-                        p!(write(\"::<\"));\n-                        p!(print(first));\n-                        for subst in substs {\n-                            p!(write(\", \"), print(subst));\n+                return Ok(with_no_queries(|| {\n+\n+                    let def_key = self.tcx().def_key(def_id);\n+                    if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n+                        p!(write(\"{}\", name));\n+                        let mut substs = substs.iter();\n+                        // FIXME(eddyb) print this with `print_def_path`.\n+                        if let Some(first) = substs.next() {\n+                            p!(write(\"::<\"));\n+                            p!(print(first));\n+                            for subst in substs {\n+                                p!(write(\", \"), print(subst));\n+                            }\n+                            p!(write(\">\"));\n                         }\n-                        p!(write(\">\"));\n+                        return Ok(self);\n                     }\n-                    return Ok(self);\n-                }\n-                // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                // by looking up the projections associated with the def_id.\n-                let bounds = self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n-\n-                let mut first = true;\n-                let mut is_sized = false;\n-                p!(write(\"impl\"));\n-                for predicate in bounds.predicates {\n-                    if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n-                        // Don't print +Sized, but rather +?Sized if absent.\n-                        if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n-                            is_sized = true;\n-                            continue;\n-                        }\n+                    // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                    // by looking up the projections associated with the def_id.\n+                    let bounds = self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n+\n+                    let mut first = true;\n+                    let mut is_sized = false;\n+                    p!(write(\"impl\"));\n+                    for predicate in bounds.predicates {\n+                        if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                            // Don't print +Sized, but rather +?Sized if absent.\n+                            if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n+                                is_sized = true;\n+                                continue;\n+                            }\n \n-                        p!(\n-                                write(\"{}\", if first { \" \" } else { \"+\" }),\n-                                print(trait_ref));\n-                        first = false;\n+                            p!(\n+                                    write(\"{}\", if first { \" \" } else { \"+\" }),\n+                                    print(trait_ref));\n+                            first = false;\n+                        }\n                     }\n-                }\n-                if !is_sized {\n-                    p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n-                } else if first {\n-                    p!(write(\" Sized\"));\n-                }\n+                    if !is_sized {\n+                        p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n+                    } else if first {\n+                        p!(write(\" Sized\"));\n+                    }\n+                    Ok(self)\n+                })?);\n             }\n             ty::Str => p!(write(\"str\")),\n             ty::Generator(did, substs, movability) => {"}, {"sha": "e8457fe0e19eadfebcf2336d4dbd269e907589b7", "filename": "src/librustc_codegen_ssa/back/rpath/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Flibrustc_codegen_ssa%2Fback%2Frpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Flibrustc_codegen_ssa%2Fback%2Frpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Frpath%2Ftests.rs?ref=e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "patch": "@@ -52,7 +52,7 @@ fn test_minimize2() {\n fn test_rpath_relative() {\n     if cfg!(target_os = \"macos\") {\n         let config = &mut RPathConfig {\n-            used_crates: Vec::new(),\n+            used_crates: &[],\n             has_rpath: true,\n             is_like_osx: true,\n             linker_is_gnu: false,\n@@ -64,7 +64,7 @@ fn test_rpath_relative() {\n         assert_eq!(res, \"@loader_path/../lib\");\n     } else {\n         let config = &mut RPathConfig {\n-            used_crates: Vec::new(),\n+            used_crates: &[],\n             out_filename: PathBuf::from(\"bin/rustc\"),\n             get_install_prefix_lib_path: &mut || panic!(),\n             has_rpath: true,"}, {"sha": "2c9d4004226c74b5c9a853850db244e2ee128add", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "patch": "@@ -9,14 +9,15 @@ use syntax::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness\n use syntax::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n use syntax::ast::{Ty, TyKind, Generics, TraitRef, EnumDef, VariantData, StructField};\n use syntax::ast::{Mac, MacDelimiter, Block, BindingMode, FnDecl, FnSig, SelfKind, Param};\n+use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::ThinVec;\n use syntax::token;\n use syntax::tokenstream::{TokenTree, TokenStream};\n use syntax::source_map::{self, respan, Span};\n use syntax::struct_span_err;\n use syntax_pos::BytePos;\n-use syntax_pos::symbol::{kw, sym};\n+use syntax_pos::symbol::{kw, sym, Symbol};\n \n use rustc_error_codes::*;\n \n@@ -1336,11 +1337,17 @@ impl<'a> Parser<'a> {\n     /// Parses the part of an enum declaration following the `{`.\n     fn parse_enum_def(&mut self, _generics: &Generics) -> PResult<'a, EnumDef> {\n         let mut variants = Vec::new();\n+        // FIXME: Consider using `parse_delim_comma_seq`.\n+        // We could then remove eating comma in `recover_nested_adt_item`.\n         while self.token != token::CloseDelim(token::Brace) {\n             let variant_attrs = self.parse_outer_attributes()?;\n             let vlo = self.token.span;\n \n             let vis = self.parse_visibility(FollowedByType::No)?;\n+            if !self.recover_nested_adt_item(kw::Enum)? {\n+                // Item already parsed, we need to skip this variant.\n+                continue\n+            }\n             let ident = self.parse_ident()?;\n \n             let struct_def = if self.check(&token::OpenDelim(token::Brace)) {\n@@ -1742,6 +1749,33 @@ impl<'a> Parser<'a> {\n         ).emit();\n     }\n \n+    /// Checks if current token is one of tokens which cannot be nested like `kw::Enum`. In case\n+    /// it is, we try to parse the item and report error about nested types.\n+    fn recover_nested_adt_item(&mut self, keyword: Symbol) -> PResult<'a, bool> {\n+        if self.token.is_keyword(kw::Enum) ||\n+            self.token.is_keyword(kw::Struct) ||\n+            self.token.is_keyword(kw::Union)\n+        {\n+            let kw_token = self.token.clone();\n+            let kw_str = pprust::token_to_string(&kw_token);\n+            let item = self.parse_item()?;\n+            self.eat(&token::Comma);\n+\n+            self.struct_span_err(\n+                kw_token.span,\n+                &format!(\"`{}` definition cannot be nested inside `{}`\", kw_str, keyword),\n+            ).span_suggestion(\n+                item.unwrap().span,\n+                &format!(\"consider creating a new `{}` definition instead of nesting\", kw_str),\n+                String::new(),\n+                Applicability::MaybeIncorrect,\n+            ).emit();\n+            // We successfully parsed the item but we must inform the caller about nested problem.\n+            return Ok(false)\n+        }\n+        Ok(true)\n+    }\n+\n     fn mk_item(&self, span: Span, ident: Ident, kind: ItemKind, vis: Visibility,\n                attrs: Vec<Attribute>) -> P<Item> {\n         P(Item {"}, {"sha": "8dced83b987ea950b8e257d0830fae58e8453fdd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "patch": "@@ -2056,20 +2056,22 @@ fn explicit_predicates_of(\n \n         Node::ImplItem(item) => match item.kind {\n             ImplItemKind::OpaqueTy(ref bounds) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                let opaque_ty = tcx.mk_opaque(def_id, substs);\n-\n-                // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n-                let bounds = AstConv::compute_bounds(\n-                    &icx,\n-                    opaque_ty,\n-                    bounds,\n-                    SizedByDefault::Yes,\n-                    tcx.def_span(def_id),\n-                );\n+                ty::print::with_no_queries(|| {\n+                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                    let opaque_ty = tcx.mk_opaque(def_id, substs);\n+\n+                    // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n+                    let bounds = AstConv::compute_bounds(\n+                        &icx,\n+                        opaque_ty,\n+                        bounds,\n+                        SizedByDefault::Yes,\n+                        tcx.def_span(def_id),\n+                    );\n \n-                predicates.extend(bounds.predicates(tcx, opaque_ty));\n-                &item.generics\n+                    predicates.extend(bounds.predicates(tcx, opaque_ty));\n+                    &item.generics\n+                })\n             }\n             _ => &item.generics,\n         },\n@@ -2102,19 +2104,21 @@ fn explicit_predicates_of(\n                     ref generics,\n                     origin: _,\n                 }) => {\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    let opaque_ty = tcx.mk_opaque(def_id, substs);\n-\n-                    // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n-                    let bounds = AstConv::compute_bounds(\n-                        &icx,\n-                        opaque_ty,\n-                        bounds,\n-                        SizedByDefault::Yes,\n-                        tcx.def_span(def_id),\n-                    );\n+                    let bounds_predicates = ty::print::with_no_queries(|| {\n+                        let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                        let opaque_ty = tcx.mk_opaque(def_id, substs);\n+\n+                        // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n+                        let bounds = AstConv::compute_bounds(\n+                            &icx,\n+                            opaque_ty,\n+                            bounds,\n+                            SizedByDefault::Yes,\n+                            tcx.def_span(def_id),\n+                        );\n \n-                    let bounds_predicates = bounds.predicates(tcx, opaque_ty);\n+                        bounds.predicates(tcx, opaque_ty)\n+                    });\n                     if impl_trait_fn.is_some() {\n                         // opaque types\n                         return ty::GenericPredicates {"}, {"sha": "8aa4cdeb5394e4df4b8684e2fe7c74178d1bcf85", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "patch": "@@ -29,33 +29,37 @@\n \n \n \n-                  ((::alloc::fmt::format as\n-                       for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((::core::fmt::Arguments::new_v1\n-                                                                                                           as\n-                                                                                                           fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments::<'_>::new_v1})((&([(\"test\"\n-                                                                                                                                                                                                                            as\n-                                                                                                                                                                                                                            &'static str)]\n-                                                                                                                                                                                                                          as\n-                                                                                                                                                                                                                          [&str; 1])\n-                                                                                                                                                                                                                        as\n-                                                                                                                                                                                                                        &[&str; 1]),\n-                                                                                                                                                                                                                    (&(match (()\n+                  ({\n+                       let res =\n+                           ((::alloc::fmt::format as\n+                                for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((::core::fmt::Arguments::new_v1\n+                                                                                                                    as\n+                                                                                                                    fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments::<'_>::new_v1})((&([(\"test\"\n+                                                                                                                                                                                                                                     as\n+                                                                                                                                                                                                                                     &'static str)]\n+                                                                                                                                                                                                                                   as\n+                                                                                                                                                                                                                                   [&str; 1])\n                                                                                                                                                                                                                                  as\n-                                                                                                                                                                                                                                 ())\n-                                                                                                                                                                                                                           {\n-                                                                                                                                                                                                                           ()\n-                                                                                                                                                                                                                           =>\n-                                                                                                                                                                                                                           ([]\n-                                                                                                                                                                                                                               as\n-                                                                                                                                                                                                                               [std::fmt::ArgumentV1<'_>; 0]),\n-                                                                                                                                                                                                                       }\n-                                                                                                                                                                                                                          as\n-                                                                                                                                                                                                                          [std::fmt::ArgumentV1<'_>; 0])\n-                                                                                                                                                                                                                        as\n-                                                                                                                                                                                                                        &[std::fmt::ArgumentV1<'_>; 0]))\n-                                                                                                          as\n-                                                                                                          std::fmt::Arguments<'_>))\n-                      as std::string::String);\n+                                                                                                                                                                                                                                 &[&str; 1]),\n+                                                                                                                                                                                                                             (&(match (()\n+                                                                                                                                                                                                                                          as\n+                                                                                                                                                                                                                                          ())\n+                                                                                                                                                                                                                                    {\n+                                                                                                                                                                                                                                    ()\n+                                                                                                                                                                                                                                    =>\n+                                                                                                                                                                                                                                    ([]\n+                                                                                                                                                                                                                                        as\n+                                                                                                                                                                                                                                        [std::fmt::ArgumentV1<'_>; 0]),\n+                                                                                                                                                                                                                                }\n+                                                                                                                                                                                                                                   as\n+                                                                                                                                                                                                                                   [std::fmt::ArgumentV1<'_>; 0])\n+                                                                                                                                                                                                                                 as\n+                                                                                                                                                                                                                                 &[std::fmt::ArgumentV1<'_>; 0]))\n+                                                                                                                   as\n+                                                                                                                   std::fmt::Arguments<'_>))\n+                               as std::string::String);\n+                       (res as std::string::String)\n+                   } as std::string::String);\n               } as ())\n pub type Foo = [i32; (3 as usize)];\n pub struct Bar {"}, {"sha": "2360b57cc454461e479ad92a5581af12e10a03ad", "filename": "src/test/ui/async-await/issues/issue-64477-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64477-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64477-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64477-2.rs?ref=e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "patch": "@@ -0,0 +1,22 @@\n+// Another regression test for #64477.\n+//\n+// In the past, the code generated by `format!` produced temporaries in the surrounding scope that\n+// borrowed the arguments through `&dyn Trait`. These temporaries do not implement `Send`, which\n+// meant that when `format!` was used in an async block, the resulting generator was not `Send`.\n+// See https://github.com/rust-lang/rust/issues/64477#issuecomment-534669068 for details\n+// and https://github.com/rust-lang/rust/issues/64477#issuecomment-531882958 for an example.\n+//\n+// check-pass\n+// edition:2018\n+\n+async fn foo(_: String) {}\n+\n+fn bar() -> impl Send {\n+    async move {\n+        foo(format!(\"{}:{}\", 1, 2)).await;\n+    }\n+}\n+\n+fn main() {\n+    let _ = bar();\n+}"}, {"sha": "80957b8a14c238184184a1c837cca51bd707d54c", "filename": "src/test/ui/enum/nested-enum.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Ftest%2Fui%2Fenum%2Fnested-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Ftest%2Fui%2Fenum%2Fnested-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum%2Fnested-enum.rs?ref=e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "patch": "@@ -0,0 +1,8 @@\n+enum Foo {\n+    enum Bar { Baz }, //~ ERROR `enum` definition cannot be nested inside `enum`\n+    struct Quux { field: u8 }, //~ ERROR `struct` definition cannot be nested inside `enum`\n+    union Wibble { field: u8 }, //~ ERROR `union` definition cannot be nested inside `enum`\n+    Bat,\n+}\n+\n+fn main() { }"}, {"sha": "7d6f57e88a8269b08fe008ff1a31d98b1d5f8482", "filename": "src/test/ui/enum/nested-enum.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Ftest%2Fui%2Fenum%2Fnested-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f/src%2Ftest%2Fui%2Fenum%2Fnested-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum%2Fnested-enum.stderr?ref=e41ced3f8d8e2f3f377ef931458e612d5f3d1f3f", "patch": "@@ -0,0 +1,26 @@\n+error: `enum` definition cannot be nested inside `enum`\n+  --> $DIR/nested-enum.rs:2:5\n+   |\n+LL |     enum Bar { Baz },\n+   |     ^^^^------------\n+   |     |\n+   |     help: consider creating a new `enum` definition instead of nesting\n+\n+error: `struct` definition cannot be nested inside `enum`\n+  --> $DIR/nested-enum.rs:3:5\n+   |\n+LL |     struct Quux { field: u8 },\n+   |     ^^^^^^-------------------\n+   |     |\n+   |     help: consider creating a new `struct` definition instead of nesting\n+\n+error: `union` definition cannot be nested inside `enum`\n+  --> $DIR/nested-enum.rs:4:5\n+   |\n+LL |     union Wibble { field: u8 },\n+   |     ^^^^^---------------------\n+   |     |\n+   |     help: consider creating a new `union` definition instead of nesting\n+\n+error: aborting due to 3 previous errors\n+"}]}