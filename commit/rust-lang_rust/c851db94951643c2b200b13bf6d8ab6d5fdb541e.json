{"sha": "c851db94951643c2b200b13bf6d8ab6d5fdb541e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NTFkYjk0OTUxNjQzYzJiMjAwYjEzYmY2ZDhhYjZkNWZkYjU0MWU=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-22T12:44:59Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-02-05T11:41:02Z"}, "message": "Move specialization_graph definition in traits::types.", "tree": {"sha": "b6414ca9f8c9581c23849ed09460d2b81234aefb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6414ca9f8c9581c23849ed09460d2b81234aefb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c851db94951643c2b200b13bf6d8ab6d5fdb541e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c851db94951643c2b200b13bf6d8ab6d5fdb541e", "html_url": "https://github.com/rust-lang/rust/commit/c851db94951643c2b200b13bf6d8ab6d5fdb541e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c851db94951643c2b200b13bf6d8ab6d5fdb541e/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9444975e96e417beaf9a261292f02c29f0eb7b2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9444975e96e417beaf9a261292f02c29f0eb7b2b", "html_url": "https://github.com/rust-lang/rust/commit/9444975e96e417beaf9a261292f02c29f0eb7b2b"}], "stats": {"total": 400, "additions": 204, "deletions": 196}, "files": [{"sha": "c90fa428001fcd4af655dd9437e981227ade6813", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 4, "deletions": 196, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/c851db94951643c2b200b13bf6d8ab6d5fdb541e/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c851db94951643c2b200b13bf6d8ab6d5fdb541e/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=c851db94951643c2b200b13bf6d8ab6d5fdb541e", "patch": "@@ -1,58 +1,11 @@\n use super::OverlapError;\n \n-use crate::ich::{self, StableHashingContext};\n use crate::traits;\n-use crate::ty::fast_reject::{self, SimplifiedType};\n-use crate::ty::{self, TyCtxt, TypeFoldable};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_hir::def_id::{DefId, DefIdMap};\n-use syntax::ast::Ident;\n-\n-/// A per-trait graph of impls in specialization order. At the moment, this\n-/// graph forms a tree rooted with the trait itself, with all other nodes\n-/// representing impls, and parent-child relationships representing\n-/// specializations.\n-///\n-/// The graph provides two key services:\n-///\n-/// - Construction. This implicitly checks for overlapping impls (i.e., impls\n-///   that overlap but where neither specializes the other -- an artifact of the\n-///   simple \"chain\" rule.\n-///\n-/// - Parent extraction. In particular, the graph can give you the *immediate*\n-///   parents of a given specializing impl, which is needed for extracting\n-///   default items amongst other things. In the simple \"chain\" rule, every impl\n-///   has at most one parent.\n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Graph {\n-    // All impls have a parent; the \"root\" impls have as their parent the `def_id`\n-    // of the trait.\n-    parent: DefIdMap<DefId>,\n-\n-    // The \"root\" impls are found by looking up the trait's def_id.\n-    children: DefIdMap<Children>,\n-}\n+use rustc::ty::fast_reject::{self, SimplifiedType};\n+use rustc::ty::{self, TyCtxt, TypeFoldable};\n+use rustc_hir::def_id::DefId;\n \n-/// Children of a given impl, grouped into blanket/non-blanket varieties as is\n-/// done in `TraitDef`.\n-#[derive(Default, RustcEncodable, RustcDecodable)]\n-struct Children {\n-    // Impls of a trait (or specializations of a given impl). To allow for\n-    // quicker lookup, the impls are indexed by a simplified version of their\n-    // `Self` type: impls with a simplifiable `Self` are stored in\n-    // `nonblanket_impls` keyed by it, while all other impls are stored in\n-    // `blanket_impls`.\n-    //\n-    // A similar division is used within `TraitDef`, but the lists there collect\n-    // together *all* the impls for a trait, and are populated prior to building\n-    // the specialization graph.\n-    /// Impls of the trait.\n-    nonblanket_impls: FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n-\n-    /// Blanket impls associated with the trait.\n-    blanket_impls: Vec<DefId>,\n-}\n+pub use rustc::traits::types::specialization_graph::*;\n \n #[derive(Copy, Clone, Debug)]\n pub enum FutureCompatOverlapErrorKind {\n@@ -269,10 +222,6 @@ where\n }\n \n impl<'tcx> Graph {\n-    pub fn new() -> Graph {\n-        Graph { parent: Default::default(), children: Default::default() }\n-    }\n-\n     /// Insert a local impl into the specialization graph. If an existing impl\n     /// conflicts with it (has overlap, but neither specializes the other),\n     /// information about the area of overlap is returned in the `Err`.\n@@ -383,145 +332,4 @@ impl<'tcx> Graph {\n \n         self.children.entry(parent).or_default().insert_blindly(tcx, child);\n     }\n-\n-    /// The parent of a given impl, which is the `DefId` of the trait when the\n-    /// impl is a \"specialization root\".\n-    pub fn parent(&self, child: DefId) -> DefId {\n-        *self.parent.get(&child).unwrap_or_else(|| panic!(\"Failed to get parent for {:?}\", child))\n-    }\n-}\n-\n-/// A node in the specialization graph is either an impl or a trait\n-/// definition; either can serve as a source of item definitions.\n-/// There is always exactly one trait definition node: the root.\n-#[derive(Debug, Copy, Clone)]\n-pub enum Node {\n-    Impl(DefId),\n-    Trait(DefId),\n-}\n-\n-impl<'tcx> Node {\n-    pub fn is_from_trait(&self) -> bool {\n-        match *self {\n-            Node::Trait(..) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items(&self, tcx: TyCtxt<'tcx>) -> ty::AssocItemsIterator<'tcx> {\n-        tcx.associated_items(self.def_id())\n-    }\n-\n-    /// Finds an associated item defined in this node.\n-    ///\n-    /// If this returns `None`, the item can potentially still be found in\n-    /// parents of this node.\n-    pub fn item(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        trait_item_name: Ident,\n-        trait_item_kind: ty::AssocKind,\n-        trait_def_id: DefId,\n-    ) -> Option<ty::AssocItem> {\n-        use crate::ty::AssocKind::*;\n-\n-        tcx.associated_items(self.def_id()).find(move |impl_item| {\n-            match (trait_item_kind, impl_item.kind) {\n-                | (Const, Const)\n-                | (Method, Method)\n-                | (Type, Type)\n-                | (Type, OpaqueTy)  // assoc. types can be made opaque in impls\n-                => tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id),\n-\n-                | (Const, _)\n-                | (Method, _)\n-                | (Type, _)\n-                | (OpaqueTy, _)\n-                => false,\n-            }\n-        })\n-    }\n-\n-    pub fn def_id(&self) -> DefId {\n-        match *self {\n-            Node::Impl(did) => did,\n-            Node::Trait(did) => did,\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct Ancestors<'tcx> {\n-    trait_def_id: DefId,\n-    specialization_graph: &'tcx Graph,\n-    current_source: Option<Node>,\n-}\n-\n-impl Iterator for Ancestors<'_> {\n-    type Item = Node;\n-    fn next(&mut self) -> Option<Node> {\n-        let cur = self.current_source.take();\n-        if let Some(Node::Impl(cur_impl)) = cur {\n-            let parent = self.specialization_graph.parent(cur_impl);\n-\n-            self.current_source = if parent == self.trait_def_id {\n-                Some(Node::Trait(parent))\n-            } else {\n-                Some(Node::Impl(parent))\n-            };\n-        }\n-        cur\n-    }\n-}\n-\n-pub struct NodeItem<T> {\n-    pub node: Node,\n-    pub item: T,\n-}\n-\n-impl<T> NodeItem<T> {\n-    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> NodeItem<U> {\n-        NodeItem { node: self.node, item: f(self.item) }\n-    }\n-}\n-\n-impl<'tcx> Ancestors<'tcx> {\n-    /// Finds the bottom-most (ie. most specialized) definition of an associated\n-    /// item.\n-    pub fn leaf_def(\n-        mut self,\n-        tcx: TyCtxt<'tcx>,\n-        trait_item_name: Ident,\n-        trait_item_kind: ty::AssocKind,\n-    ) -> Option<NodeItem<ty::AssocItem>> {\n-        let trait_def_id = self.trait_def_id;\n-        self.find_map(|node| {\n-            node.item(tcx, trait_item_name, trait_item_kind, trait_def_id)\n-                .map(|item| NodeItem { node, item })\n-        })\n-    }\n-}\n-\n-/// Walk up the specialization ancestors of a given impl, starting with that\n-/// impl itself.\n-pub fn ancestors(\n-    tcx: TyCtxt<'tcx>,\n-    trait_def_id: DefId,\n-    start_from_impl: DefId,\n-) -> Ancestors<'tcx> {\n-    let specialization_graph = tcx.specialization_graph_of(trait_def_id);\n-    Ancestors {\n-        trait_def_id,\n-        specialization_graph,\n-        current_source: Some(Node::Impl(start_from_impl)),\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for Children {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let Children { ref nonblanket_impls, ref blanket_impls } = *self;\n-\n-        ich::hash_stable_trait_impls(hcx, hasher, blanket_impls, nonblanket_impls);\n-    }\n }"}, {"sha": "571fb505779ca2408d2303a525fbc4d848df145d", "filename": "src/librustc/traits/types/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c851db94951643c2b200b13bf6d8ab6d5fdb541e/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c851db94951643c2b200b13bf6d8ab6d5fdb541e/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs?ref=c851db94951643c2b200b13bf6d8ab6d5fdb541e", "patch": "@@ -4,6 +4,7 @@\n \n pub mod query;\n pub mod select;\n+pub mod specialization_graph;\n mod structural_impls;\n \n use crate::mir::interpret::ErrorHandled;"}, {"sha": "3086850db6d9cdf38a57ee9b5afa0ac969827446", "filename": "src/librustc/traits/types/specialization_graph.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/c851db94951643c2b200b13bf6d8ab6d5fdb541e/src%2Flibrustc%2Ftraits%2Ftypes%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c851db94951643c2b200b13bf6d8ab6d5fdb541e/src%2Flibrustc%2Ftraits%2Ftypes%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fspecialization_graph.rs?ref=c851db94951643c2b200b13bf6d8ab6d5fdb541e", "patch": "@@ -0,0 +1,199 @@\n+use crate::ich::{self, StableHashingContext};\n+use crate::ty::fast_reject::SimplifiedType;\n+use crate::ty::{self, TyCtxt};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_hir::def_id::{DefId, DefIdMap};\n+use syntax::ast::Ident;\n+\n+/// A per-trait graph of impls in specialization order. At the moment, this\n+/// graph forms a tree rooted with the trait itself, with all other nodes\n+/// representing impls, and parent-child relationships representing\n+/// specializations.\n+///\n+/// The graph provides two key services:\n+///\n+/// - Construction. This implicitly checks for overlapping impls (i.e., impls\n+///   that overlap but where neither specializes the other -- an artifact of the\n+///   simple \"chain\" rule.\n+///\n+/// - Parent extraction. In particular, the graph can give you the *immediate*\n+///   parents of a given specializing impl, which is needed for extracting\n+///   default items amongst other things. In the simple \"chain\" rule, every impl\n+///   has at most one parent.\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+pub struct Graph {\n+    // All impls have a parent; the \"root\" impls have as their parent the `def_id`\n+    // of the trait.\n+    pub parent: DefIdMap<DefId>,\n+\n+    // The \"root\" impls are found by looking up the trait's def_id.\n+    pub children: DefIdMap<Children>,\n+}\n+\n+impl Graph {\n+    pub fn new() -> Graph {\n+        Graph { parent: Default::default(), children: Default::default() }\n+    }\n+\n+    /// The parent of a given impl, which is the `DefId` of the trait when the\n+    /// impl is a \"specialization root\".\n+    pub fn parent(&self, child: DefId) -> DefId {\n+        *self.parent.get(&child).unwrap_or_else(|| panic!(\"Failed to get parent for {:?}\", child))\n+    }\n+}\n+\n+/// Children of a given impl, grouped into blanket/non-blanket varieties as is\n+/// done in `TraitDef`.\n+#[derive(Default, RustcEncodable, RustcDecodable)]\n+pub struct Children {\n+    // Impls of a trait (or specializations of a given impl). To allow for\n+    // quicker lookup, the impls are indexed by a simplified version of their\n+    // `Self` type: impls with a simplifiable `Self` are stored in\n+    // `nonblanket_impls` keyed by it, while all other impls are stored in\n+    // `blanket_impls`.\n+    //\n+    // A similar division is used within `TraitDef`, but the lists there collect\n+    // together *all* the impls for a trait, and are populated prior to building\n+    // the specialization graph.\n+    /// Impls of the trait.\n+    pub nonblanket_impls: FxHashMap<SimplifiedType, Vec<DefId>>,\n+\n+    /// Blanket impls associated with the trait.\n+    pub blanket_impls: Vec<DefId>,\n+}\n+\n+/// A node in the specialization graph is either an impl or a trait\n+/// definition; either can serve as a source of item definitions.\n+/// There is always exactly one trait definition node: the root.\n+#[derive(Debug, Copy, Clone)]\n+pub enum Node {\n+    Impl(DefId),\n+    Trait(DefId),\n+}\n+\n+impl<'tcx> Node {\n+    pub fn is_from_trait(&self) -> bool {\n+        match *self {\n+            Node::Trait(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Iterate over the items defined directly by the given (impl or trait) node.\n+    pub fn items(&self, tcx: TyCtxt<'tcx>) -> ty::AssocItemsIterator<'tcx> {\n+        tcx.associated_items(self.def_id())\n+    }\n+\n+    /// Finds an associated item defined in this node.\n+    ///\n+    /// If this returns `None`, the item can potentially still be found in\n+    /// parents of this node.\n+    pub fn item(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        trait_item_name: Ident,\n+        trait_item_kind: ty::AssocKind,\n+        trait_def_id: DefId,\n+    ) -> Option<ty::AssocItem> {\n+        use crate::ty::AssocKind::*;\n+\n+        tcx.associated_items(self.def_id()).find(move |impl_item| {\n+            match (trait_item_kind, impl_item.kind) {\n+                | (Const, Const)\n+                | (Method, Method)\n+                | (Type, Type)\n+                | (Type, OpaqueTy)  // assoc. types can be made opaque in impls\n+                => tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id),\n+\n+                | (Const, _)\n+                | (Method, _)\n+                | (Type, _)\n+                | (OpaqueTy, _)\n+                => false,\n+            }\n+        })\n+    }\n+\n+    pub fn def_id(&self) -> DefId {\n+        match *self {\n+            Node::Impl(did) => did,\n+            Node::Trait(did) => did,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct Ancestors<'tcx> {\n+    trait_def_id: DefId,\n+    specialization_graph: &'tcx Graph,\n+    current_source: Option<Node>,\n+}\n+\n+impl Iterator for Ancestors<'_> {\n+    type Item = Node;\n+    fn next(&mut self) -> Option<Node> {\n+        let cur = self.current_source.take();\n+        if let Some(Node::Impl(cur_impl)) = cur {\n+            let parent = self.specialization_graph.parent(cur_impl);\n+\n+            self.current_source = if parent == self.trait_def_id {\n+                Some(Node::Trait(parent))\n+            } else {\n+                Some(Node::Impl(parent))\n+            };\n+        }\n+        cur\n+    }\n+}\n+\n+pub struct NodeItem<T> {\n+    pub node: Node,\n+    pub item: T,\n+}\n+\n+impl<T> NodeItem<T> {\n+    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> NodeItem<U> {\n+        NodeItem { node: self.node, item: f(self.item) }\n+    }\n+}\n+\n+impl<'tcx> Ancestors<'tcx> {\n+    /// Finds the bottom-most (ie. most specialized) definition of an associated\n+    /// item.\n+    pub fn leaf_def(\n+        mut self,\n+        tcx: TyCtxt<'tcx>,\n+        trait_item_name: Ident,\n+        trait_item_kind: ty::AssocKind,\n+    ) -> Option<NodeItem<ty::AssocItem>> {\n+        let trait_def_id = self.trait_def_id;\n+        self.find_map(|node| {\n+            node.item(tcx, trait_item_name, trait_item_kind, trait_def_id)\n+                .map(|item| NodeItem { node, item })\n+        })\n+    }\n+}\n+\n+/// Walk up the specialization ancestors of a given impl, starting with that\n+/// impl itself.\n+pub fn ancestors(\n+    tcx: TyCtxt<'tcx>,\n+    trait_def_id: DefId,\n+    start_from_impl: DefId,\n+) -> Ancestors<'tcx> {\n+    let specialization_graph = tcx.specialization_graph_of(trait_def_id);\n+    Ancestors {\n+        trait_def_id,\n+        specialization_graph,\n+        current_source: Some(Node::Impl(start_from_impl)),\n+    }\n+}\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for Children {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        let Children { ref nonblanket_impls, ref blanket_impls } = *self;\n+\n+        ich::hash_stable_trait_impls(hcx, hasher, blanket_impls, nonblanket_impls);\n+    }\n+}"}]}