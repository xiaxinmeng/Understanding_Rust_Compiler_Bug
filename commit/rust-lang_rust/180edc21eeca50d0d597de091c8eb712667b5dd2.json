{"sha": "180edc21eeca50d0d597de091c8eb712667b5dd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MGVkYzIxZWVjYTUwZDBkNTk3ZGUwOTFjOGViNzEyNjY3YjVkZDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-26T01:51:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-26T01:51:05Z"}, "message": "Auto merge of #60296 - Centril:rollup-qh9la7k, r=Centril\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #59734 (Prevent failure in case no space left on device in rustdoc)\n - #59940 (Set cfg(test) when rustdoc is running with --test option)\n - #60134 (Fix index-page generation)\n - #60165 (Add Pin::{into_inner,into_inner_unchecked})\n - #60183 (Chalkify: Add builtin Copy/Clone)\n - #60225 (Introduce hir::ExprKind::Use and employ in for loop desugaring.)\n - #60247 (Implement Debug for Place using Place::iterate)\n - #60259 (Derive Default instead of new in applicable lint)\n - #60267 (Add feature-gate for f16c target feature)\n - #60284 (Do not allow const generics to depend on type parameters)\n - #60285 (Do not ICE when checking types against foreign fn)\n - #60289 (Make `-Z allow-features` work for stdlib features)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "9de980a6d79928bd00a4004d5587c6dc7582bbec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9de980a6d79928bd00a4004d5587c6dc7582bbec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/180edc21eeca50d0d597de091c8eb712667b5dd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/180edc21eeca50d0d597de091c8eb712667b5dd2", "html_url": "https://github.com/rust-lang/rust/commit/180edc21eeca50d0d597de091c8eb712667b5dd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/180edc21eeca50d0d597de091c8eb712667b5dd2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3991285f55a4b7cd92b7ffcdc396a3023076f5cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3991285f55a4b7cd92b7ffcdc396a3023076f5cb", "html_url": "https://github.com/rust-lang/rust/commit/3991285f55a4b7cd92b7ffcdc396a3023076f5cb"}, {"sha": "a133caab36b311a6c0812336698c817450184283", "url": "https://api.github.com/repos/rust-lang/rust/commits/a133caab36b311a6c0812336698c817450184283", "html_url": "https://github.com/rust-lang/rust/commit/a133caab36b311a6c0812336698c817450184283"}], "stats": {"total": 858, "additions": 640, "deletions": 218}, "files": [{"sha": "9c2531097bfbfa499f96819b99092b3201171fa9", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -1523,7 +1523,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"minifier\"\n-version = \"0.0.29\"\n+version = \"0.0.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"macro-utils 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3038,7 +3038,7 @@ dependencies = [\n name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n- \"minifier 0.0.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"minifier 0.0.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -4170,7 +4170,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2efc7bc57c883d4a4d6e3246905283d8dae951bb3bd32f49d6ef297f546e1c39\"\n \"checksum memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2ffa2c986de11a9df78620c01eeaaf27d94d3ff02bf81bfcca953102dd0c6ff\"\n \"checksum memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0f9dc261e2b62d7a622bf416ea3c5245cdd5d9a7fcc428c0d06804dfce1775b3\"\n-\"checksum minifier 0.0.29 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1f4950cb2617b1933e2da0446e864dfe0d6a22c22ff72297996c46e6a63b210b\"\n+\"checksum minifier 0.0.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c909e78edf61f3aa0dd2086da168cdf304329044bbf248768ca3d20253ec8c0\"\n \"checksum miniz-sys 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0300eafb20369952951699b68243ab4334f4b10a88f411c221d444b36c40e649\"\n \"checksum miniz_oxide 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5ad30a47319c16cde58d0314f5d98202a80c9083b5f61178457403dfb14e509c\"\n \"checksum miniz_oxide_c_api 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"28edaef377517fd9fe3e085c37d892ce7acd1fbeab9239c5a36eec352d8a8b7e\""}, {"sha": "e74ed9b7889cb31b311dfee52b40283d430f555e", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -349,6 +349,18 @@ where\n         // around pinning.\n         unsafe { Pin::new_unchecked(pointer) }\n     }\n+\n+    /// Unwraps this `Pin<P>` returning the underlying pointer.\n+    ///\n+    /// This requires that the data inside this `Pin` is [`Unpin`] so that we\n+    /// can ignore the pinning invariants when unwrapping it.\n+    ///\n+    /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n+    #[unstable(feature = \"pin_into_inner\", issue = \"60245\")]\n+    #[inline(always)]\n+    pub fn into_inner(pin: Pin<P>) -> P {\n+        pin.pointer\n+    }\n }\n \n impl<P: Deref> Pin<P> {\n@@ -434,6 +446,28 @@ impl<P: Deref> Pin<P> {\n     pub fn as_ref(self: &Pin<P>) -> Pin<&P::Target> {\n         unsafe { Pin::new_unchecked(&*self.pointer) }\n     }\n+\n+    /// Unwraps this `Pin<P>` returning the underlying pointer.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe. You must guarantee that you will continue to\n+    /// treat the pointer `P` as pinned after you call this function, so that\n+    /// the invariants on the `Pin` type can be upheld. If the code using the\n+    /// resulting `P` does not continue to maintain the pinning invariants that\n+    /// is a violation of the API contract and may lead to undefined behavior in\n+    /// later (safe) operations.\n+    ///\n+    /// If the underlying data is [`Unpin`], [`Pin::into_inner`] should be used\n+    /// instead.\n+    ///\n+    /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n+    /// [`Pin::into_inner`]: #method.into_inner\n+    #[unstable(feature = \"pin_into_inner\", issue = \"60245\")]\n+    #[inline(always)]\n+    pub unsafe fn into_inner_unchecked(pin: Pin<P>) -> P {\n+        pin.pointer\n+    }\n }\n \n impl<P: DerefMut> Pin<P> {"}, {"sha": "8a4594fe0e89eec33ff20663d3a006849834f80b", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -369,6 +369,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ExprKind::AddrOf(_, ref e) |\n             hir::ExprKind::Cast(ref e, _) |\n             hir::ExprKind::Type(ref e, _) |\n+            hir::ExprKind::Use(ref e) |\n             hir::ExprKind::Unary(_, ref e) |\n             hir::ExprKind::Field(ref e, _) |\n             hir::ExprKind::Yield(ref e) |"}, {"sha": "3d727f7cd912809cfbdbc068446288b775ade187", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -1029,6 +1029,9 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n         }\n+        ExprKind::Use(ref subexpression) => {\n+            visitor.visit_expr(subexpression);\n+        }\n         ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n             visitor.visit_expr(head_expression);\n             visitor.visit_expr(if_block);"}, {"sha": "37373da72fbd6a58755151552f1d896c62575e76", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -4738,16 +4738,11 @@ impl<'a> LoweringContext<'a> {\n                     hir::MatchSource::ForLoopDesugar,\n                 ));\n \n-                // `{ let _result = ...; _result }`\n-                // Underscore prevents an `unused_variables` lint if the head diverges.\n-                let result_ident = self.str_to_ident(\"_result\");\n-                let (let_stmt, let_stmt_binding) =\n-                    self.stmt_let(e.span, false, result_ident, match_expr);\n-\n-                let result = P(self.expr_ident(e.span, result_ident, let_stmt_binding));\n-                let block = P(self.block_all(e.span, hir_vec![let_stmt], Some(result)));\n-                // Add the attributes to the outer returned expr node.\n-                return self.expr_block(block, e.attrs.clone());\n+                // This is effectively `{ let _result = ...; _result }`.\n+                // The construct was introduced in #21984.\n+                // FIXME(60253): Is this still necessary?\n+                // Also, add the attributes to the outer returned expr node.\n+                return self.expr_use(head_sp, match_expr, e.attrs.clone())\n             }\n \n             // Desugar `ExprKind::Try`\n@@ -5117,6 +5112,17 @@ impl<'a> LoweringContext<'a> {\n         )\n     }\n \n+    /// Wrap the given `expr` in `hir::ExprKind::Use`.\n+    ///\n+    /// In terms of drop order, it has the same effect as\n+    /// wrapping `expr` in `{ let _t = $expr; _t }` but\n+    /// should provide better compile-time performance.\n+    ///\n+    /// The drop order can be important in e.g. `if expr { .. }`.\n+    fn expr_use(&mut self, span: Span, expr: P<hir::Expr>, attrs: ThinVec<Attribute>) -> hir::Expr {\n+        self.expr(span, hir::ExprKind::Use(expr), attrs)\n+    }\n+\n     fn expr_match(\n         &mut self,\n         span: Span,\n@@ -5172,25 +5178,6 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn stmt_let(\n-        &mut self,\n-        sp: Span,\n-        mutbl: bool,\n-        ident: Ident,\n-        ex: P<hir::Expr>,\n-    ) -> (hir::Stmt, hir::HirId) {\n-        let (pat, pat_hid) = if mutbl {\n-            self.pat_ident_binding_mode(sp, ident, hir::BindingAnnotation::Mutable)\n-        } else {\n-            self.pat_ident(sp, ident)\n-        };\n-\n-        (\n-            self.stmt_let_pat(sp, Some(ex), pat, hir::LocalSource::Normal),\n-            pat_hid,\n-        )\n-    }\n-\n     fn block_expr(&mut self, expr: P<hir::Expr>) -> hir::Block {\n         self.block_all(expr.span, hir::HirVec::new(), Some(expr))\n     }"}, {"sha": "2e10300dced0ef273add3e875fe1a51dbe4b55a1", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -1366,6 +1366,7 @@ impl Expr {\n             ExprKind::Unary(..) => ExprPrecedence::Unary,\n             ExprKind::Lit(_) => ExprPrecedence::Lit,\n             ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n+            ExprKind::Use(ref expr, ..) => expr.precedence(),\n             ExprKind::If(..) => ExprPrecedence::If,\n             ExprKind::While(..) => ExprPrecedence::While,\n             ExprKind::Loop(..) => ExprPrecedence::Loop,\n@@ -1437,6 +1438,7 @@ impl Expr {\n             ExprKind::Binary(..) |\n             ExprKind::Yield(..) |\n             ExprKind::Cast(..) |\n+            ExprKind::Use(..) |\n             ExprKind::Err => {\n                 false\n             }\n@@ -1486,6 +1488,10 @@ pub enum ExprKind {\n     Cast(P<Expr>, P<Ty>),\n     /// A type reference (e.g., `Foo`).\n     Type(P<Expr>, P<Ty>),\n+    /// Semantically equivalent to `{ let _t = expr; _t }`.\n+    /// Maps directly to `hair::ExprKind::Use`.\n+    /// Only exists to tweak the drop order in HIR.\n+    Use(P<Expr>),\n     /// An `if` block, with an optional else block.\n     ///\n     /// I.e., `if <expr> { <expr> } else { <expr> }`."}, {"sha": "06225364f6c70091feb4f4b9d1f52baa825d678a", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 40, "deletions": 13, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -995,23 +995,32 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::SubItem(ii.hir_id))\n     }\n \n+    pub fn print_local(\n+        &mut self,\n+        init: Option<&hir::Expr>,\n+        decl: impl Fn(&mut Self) -> io::Result<()>\n+    ) -> io::Result<()> {\n+        self.space_if_not_bol()?;\n+        self.ibox(indent_unit)?;\n+        self.word_nbsp(\"let\")?;\n+\n+        self.ibox(indent_unit)?;\n+        decl(self)?;\n+        self.end()?;\n+\n+        if let Some(ref init) = init {\n+            self.nbsp()?;\n+            self.word_space(\"=\")?;\n+            self.print_expr(&init)?;\n+        }\n+        self.end()\n+    }\n+\n     pub fn print_stmt(&mut self, st: &hir::Stmt) -> io::Result<()> {\n         self.maybe_print_comment(st.span.lo())?;\n         match st.node {\n             hir::StmtKind::Local(ref loc) => {\n-                self.space_if_not_bol()?;\n-                self.ibox(indent_unit)?;\n-                self.word_nbsp(\"let\")?;\n-\n-                self.ibox(indent_unit)?;\n-                self.print_local_decl(&loc)?;\n-                self.end()?;\n-                if let Some(ref init) = loc.init {\n-                    self.nbsp()?;\n-                    self.word_space(\"=\")?;\n-                    self.print_expr(&init)?;\n-                }\n-                self.end()?\n+                self.print_local(loc.init.deref(), |this| this.print_local_decl(&loc))?;\n             }\n             hir::StmtKind::Item(item) => {\n                 self.ann.nested(self, Nested::Item(item))?\n@@ -1379,6 +1388,24 @@ impl<'a> State<'a> {\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n             }\n+            hir::ExprKind::Use(ref init) => {\n+                // Print `{`:\n+                self.cbox(indent_unit)?;\n+                self.ibox(0)?;\n+                self.bopen()?;\n+\n+                // Print `let _t = $init;`:\n+                let temp = ast::Ident::from_str(\"_t\");\n+                self.print_local(Some(init), |this| this.print_ident(temp))?;\n+                self.s.word(\";\")?;\n+\n+                // Print `_t`:\n+                self.space_if_not_bol()?;\n+                self.print_ident(temp)?;\n+\n+                // Print `}`:\n+                self.bclose_maybe_open(expr.span, indent_unit, true)?;\n+            }\n             hir::ExprKind::If(ref test, ref blk, ref elseopt) => {\n                 self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e))?;\n             }"}, {"sha": "920f978054396b6e4d29553fb8b2a065d84f1101", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -37,6 +37,7 @@\n #![feature(box_syntax)]\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n+#![feature(inner_deref)]\n #![cfg_attr(windows, feature(libc))]\n #![feature(never_type)]\n #![feature(exhaustive_patterns)]"}, {"sha": "52f105b8c40e53c5be7cc28f1f882c07a82e0ed6", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -521,6 +521,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_expr(&base);\n             }\n \n+            hir::ExprKind::Use(ref expr) => {\n+                self.consume_expr(&expr);\n+            }\n+\n             hir::ExprKind::AssignOp(_, ref lhs, ref rhs) => {\n                 if self.mc.tables.is_method_call(expr) {\n                     self.consume_expr(lhs);"}, {"sha": "966bec8381ae7c02d1de9963ad91f386462cea7d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -521,6 +521,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n       hir::ExprKind::Binary(..) |\n       hir::ExprKind::AddrOf(..) |\n       hir::ExprKind::Cast(..) |\n+      hir::ExprKind::Use(..) |\n       hir::ExprKind::Unary(..) |\n       hir::ExprKind::Break(..) |\n       hir::ExprKind::Continue(_) |\n@@ -1221,6 +1222,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             hir::ExprKind::AddrOf(_, ref e) |\n             hir::ExprKind::Cast(ref e, _) |\n             hir::ExprKind::Type(ref e, _) |\n+            hir::ExprKind::Use(ref e) |\n             hir::ExprKind::Unary(_, ref e) |\n             hir::ExprKind::Yield(ref e) |\n             hir::ExprKind::Repeat(ref e, _) => {\n@@ -1524,9 +1526,9 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n         hir::ExprKind::Match(..) | hir::ExprKind::While(..) | hir::ExprKind::Loop(..) |\n         hir::ExprKind::Index(..) | hir::ExprKind::Field(..) |\n         hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::Binary(..) |\n-        hir::ExprKind::Cast(..) | hir::ExprKind::Unary(..) | hir::ExprKind::Ret(..) |\n-        hir::ExprKind::Break(..) | hir::ExprKind::Continue(..) | hir::ExprKind::Lit(_) |\n-        hir::ExprKind::Block(..) | hir::ExprKind::AddrOf(..) |\n+        hir::ExprKind::Cast(..) | hir::ExprKind::Use(..) | hir::ExprKind::Unary(..) |\n+        hir::ExprKind::Ret(..) | hir::ExprKind::Break(..) | hir::ExprKind::Continue(..) |\n+        hir::ExprKind::Lit(_) | hir::ExprKind::Block(..) | hir::ExprKind::AddrOf(..) |\n         hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |\n         hir::ExprKind::Closure(..) | hir::ExprKind::Path(_) | hir::ExprKind::Yield(..) |\n         hir::ExprKind::Box(..) | hir::ExprKind::Type(..) | hir::ExprKind::Err => {"}, {"sha": "25fa19558de9759c94141fbe3c998a0903ce8ee3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -678,7 +678,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Assign(..) | hir::ExprKind::AssignOp(..) |\n             hir::ExprKind::Closure(..) | hir::ExprKind::Ret(..) |\n             hir::ExprKind::Unary(..) | hir::ExprKind::Yield(..) |\n-            hir::ExprKind::MethodCall(..) | hir::ExprKind::Cast(..) |\n+            hir::ExprKind::MethodCall(..) | hir::ExprKind::Cast(..) | hir::ExprKind::Use(..) |\n             hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::If(..) |\n             hir::ExprKind::Binary(..) | hir::ExprKind::While(..) |\n             hir::ExprKind::Block(..) | hir::ExprKind::Loop(..) | hir::ExprKind::Match(..) |"}, {"sha": "9a5af8a25378f93a7dfbac9ea42c1eabf43d9e78", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -909,6 +909,12 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n                 visitor.cx.var_parent = visitor.cx.parent;\n             }\n \n+            hir::ExprKind::Use(ref expr) => {\n+                // `Use(expr)` does not denote a conditional scope.\n+                // Rather, we want to achieve the same behavior as `{ let _t = expr; _t }`.\n+                terminating(expr.hir_id.local_id);\n+            }\n+\n             hir::ExprKind::AssignOp(..) | hir::ExprKind::Index(..) |\n             hir::ExprKind::Unary(..) | hir::ExprKind::Call(..) | hir::ExprKind::MethodCall(..) => {\n                 // FIXME(https://github.com/rust-lang/rfcs/issues/811) Nested method calls"}, {"sha": "3d094e72d26aa295288de5c652b51a37d2dbb030", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 86, "deletions": 52, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -2156,61 +2156,95 @@ impl<'p, 'tcx> FusedIterator for PlaceProjectionsIter<'p, 'tcx> {}\n \n impl<'tcx> Debug for Place<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        use self::Place::*;\n-\n-        match *self {\n-            Base(PlaceBase::Local(id)) => write!(fmt, \"{:?}\", id),\n-            Base(PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static(def_id) })) => {\n-                write!(\n-                    fmt,\n-                    \"({}: {:?})\",\n-                    ty::tls::with(|tcx| tcx.def_path_str(def_id)),\n-                    ty\n-                )\n-            },\n-            Base(PlaceBase::Static(\n-                box self::Static { ty, kind: StaticKind::Promoted(promoted) })\n-            ) => {\n-                write!(\n-                    fmt,\n-                    \"({:?}: {:?})\",\n-                    promoted,\n-                    ty\n-                )\n-            },\n-            Projection(ref data) => match data.elem {\n-                ProjectionElem::Downcast(Some(name), _index) => {\n-                    write!(fmt, \"({:?} as {})\", data.base, name)\n-                }\n-                ProjectionElem::Downcast(None, index) => {\n-                    write!(fmt, \"({:?} as variant#{:?})\", data.base, index)\n-                }\n-                ProjectionElem::Deref => write!(fmt, \"(*{:?})\", data.base),\n-                ProjectionElem::Field(field, ty) => {\n-                    write!(fmt, \"({:?}.{:?}: {:?})\", data.base, field.index(), ty)\n-                }\n-                ProjectionElem::Index(ref index) => write!(fmt, \"{:?}[{:?}]\", data.base, index),\n-                ProjectionElem::ConstantIndex {\n-                    offset,\n-                    min_length,\n-                    from_end: false,\n-                } => write!(fmt, \"{:?}[{:?} of {:?}]\", data.base, offset, min_length),\n-                ProjectionElem::ConstantIndex {\n-                    offset,\n-                    min_length,\n-                    from_end: true,\n-                } => write!(fmt, \"{:?}[-{:?} of {:?}]\", data.base, offset, min_length),\n-                ProjectionElem::Subslice { from, to } if to == 0 => {\n-                    write!(fmt, \"{:?}[{:?}:]\", data.base, from)\n+        self.iterate(|_place_base, place_projections| {\n+            // FIXME: remove this collect once we have migrated to slices\n+            let projs_vec: Vec<_> = place_projections.collect();\n+            for projection in projs_vec.iter().rev() {\n+                match projection.elem {\n+                    ProjectionElem::Downcast(_, _) |\n+                    ProjectionElem::Field(_, _) => {\n+                        write!(fmt, \"(\").unwrap();\n+                    }\n+                    ProjectionElem::Deref => {\n+                        write!(fmt, \"(*\").unwrap();\n+                    }\n+                    ProjectionElem::Index(_) |\n+                    ProjectionElem::ConstantIndex { .. } |\n+                    ProjectionElem::Subslice { .. } => {}\n                 }\n-                ProjectionElem::Subslice { from, to } if from == 0 => {\n-                    write!(fmt, \"{:?}[:-{:?}]\", data.base, to)\n+            }\n+        });\n+\n+        self.iterate(|place_base, place_projections| {\n+            match place_base {\n+                PlaceBase::Local(id) => {\n+                    write!(fmt, \"{:?}\", id)?;\n                 }\n-                ProjectionElem::Subslice { from, to } => {\n-                    write!(fmt, \"{:?}[{:?}:-{:?}]\", data.base, from, to)\n+                PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static(def_id) }) => {\n+                    write!(\n+                        fmt,\n+                        \"({}: {:?})\",\n+                        ty::tls::with(|tcx| tcx.def_path_str(*def_id)),\n+                        ty\n+                    )?;\n+                },\n+                PlaceBase::Static(\n+                    box self::Static { ty, kind: StaticKind::Promoted(promoted) }\n+                ) => {\n+                    write!(\n+                        fmt,\n+                        \"({:?}: {:?})\",\n+                        promoted,\n+                        ty\n+                    )?;\n+                },\n+            }\n+\n+            for projection in place_projections {\n+                match projection.elem {\n+                    ProjectionElem::Downcast(Some(name), _index) => {\n+                        write!(fmt, \" as {})\", name)?;\n+                    }\n+                    ProjectionElem::Downcast(None, index) => {\n+                        write!(fmt, \" as variant#{:?})\", index)?;\n+                    }\n+                    ProjectionElem::Deref => {\n+                        write!(fmt, \")\")?;\n+                    }\n+                    ProjectionElem::Field(field, ty) => {\n+                        write!(fmt, \".{:?}: {:?})\", field.index(), ty)?;\n+                    }\n+                    ProjectionElem::Index(ref index) => {\n+                        write!(fmt, \"[{:?}]\", index)?;\n+                    }\n+                    ProjectionElem::ConstantIndex {\n+                        offset,\n+                        min_length,\n+                        from_end: false,\n+                    } => {\n+                        write!(fmt, \"[{:?} of {:?}]\", offset, min_length)?;\n+                    }\n+                    ProjectionElem::ConstantIndex {\n+                        offset,\n+                        min_length,\n+                        from_end: true,\n+                    } => {\n+                        write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n+                    }\n+                    ProjectionElem::Subslice { from, to } if to == 0 => {\n+                        write!(fmt, \"[{:?}:]\", from)?;\n+                    }\n+                    ProjectionElem::Subslice { from, to } if from == 0 => {\n+                        write!(fmt, \"[:-{:?}]\", to)?;\n+                    }\n+                    ProjectionElem::Subslice { from, to } => {\n+                        write!(fmt, \"[{:?}:-{:?}]\", from, to)?;\n+                    }\n                 }\n-            },\n-        }\n+            }\n+\n+            Ok(())\n+        })\n     }\n }\n "}, {"sha": "cf69885c3e07c13679fe21bcf7e8a892e94bd6c2", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -2505,16 +2505,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             ty::Closure(def_id, substs) => {\n-                let trait_id = obligation.predicate.def_id();\n-                let is_copy_trait = Some(trait_id) == self.tcx().lang_items().copy_trait();\n-                let is_clone_trait = Some(trait_id) == self.tcx().lang_items().clone_trait();\n-                if is_copy_trait || is_clone_trait {\n-                    Where(ty::Binder::bind(\n-                        substs.upvar_tys(def_id, self.tcx()).collect(),\n-                    ))\n-                } else {\n-                    None\n-                }\n+                // (*) binder moved here\n+                Where(ty::Binder::bind(\n+                    substs.upvar_tys(def_id, self.tcx()).collect(),\n+                ))\n             }\n \n             ty::Adt(..) | ty::Projection(..) | ty::Param(..) | ty::Opaque(..) => {"}, {"sha": "47c1c16f1f828b3a530db7ef9b3f9f4be46c6a06", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -542,18 +542,13 @@ declare_lint! {\n     \"detects missing implementations of fmt::Debug\"\n }\n \n+#[derive(Default)]\n pub struct MissingDebugImplementations {\n     impling_types: Option<HirIdSet>,\n }\n \n impl_lint_pass!(MissingDebugImplementations => [MISSING_DEBUG_IMPLEMENTATIONS]);\n \n-impl MissingDebugImplementations {\n-    pub fn new() -> MissingDebugImplementations {\n-        MissingDebugImplementations { impling_types: None }\n-    }\n-}\n-\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n         if !cx.access_levels.is_reachable(item.hir_id) {\n@@ -1285,6 +1280,7 @@ declare_lint! {\n     \"`...` range patterns are deprecated\"\n }\n \n+#[derive(Default)]\n pub struct EllipsisInclusiveRangePatterns {\n     /// If `Some(_)`, suppress all subsequent pattern\n     /// warnings for better diagnostics.\n@@ -1293,14 +1289,6 @@ pub struct EllipsisInclusiveRangePatterns {\n \n impl_lint_pass!(EllipsisInclusiveRangePatterns => [ELLIPSIS_INCLUSIVE_RANGE_PATTERNS]);\n \n-impl EllipsisInclusiveRangePatterns {\n-    pub fn new() -> Self {\n-        Self {\n-            node_id: None,\n-        }\n-    }\n-}\n-\n impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n     fn check_pat(&mut self, cx: &EarlyContext<'_>, pat: &ast::Pat) {\n         if self.node_id.is_some() {"}, {"sha": "7d23da857bbbb35d26f4a4bf3f6860aef0d44c40", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -94,7 +94,7 @@ macro_rules! early_lint_passes {\n             UnusedImportBraces: UnusedImportBraces,\n             UnsafeCode: UnsafeCode,\n             AnonymousParameters: AnonymousParameters,\n-            EllipsisInclusiveRangePatterns: EllipsisInclusiveRangePatterns::new(),\n+            EllipsisInclusiveRangePatterns: EllipsisInclusiveRangePatterns::default(),\n             NonCamelCaseTypes: NonCamelCaseTypes,\n             DeprecatedAttr: DeprecatedAttr::new(),\n         ]);\n@@ -132,7 +132,7 @@ macro_rules! late_lint_passes {\n             // Depends on access levels\n             // FIXME: Turn the computation of types which implement Debug into a query\n             // and change this to a module lint pass\n-            MissingDebugImplementations: MissingDebugImplementations::new(),\n+            MissingDebugImplementations: MissingDebugImplementations::default(),\n         ]);\n     )\n }"}, {"sha": "e54a24f4df197dbec308ec7e24897e4981ff023b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -759,6 +759,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 }\n             }\n         }\n+        hir::ExprKind::Use(ref source) => {\n+            ExprKind::Use { source: source.to_ref() }\n+        }\n         hir::ExprKind::Box(ref value) => {\n             ExprKind::Box {\n                 value: value.to_ref(),"}, {"sha": "2a423cc41661abd52596bae76541383ab7be6e84", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -436,7 +436,9 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Err => Promotable,\n \n         hir::ExprKind::AddrOf(_, ref expr) |\n-        hir::ExprKind::Repeat(ref expr, _) => {\n+        hir::ExprKind::Repeat(ref expr, _) |\n+        hir::ExprKind::Type(ref expr, _) |\n+        hir::ExprKind::Use(ref expr) => {\n             v.check_expr(&expr)\n         }\n \n@@ -483,10 +485,6 @@ fn check_expr_kind<'a, 'tcx>(\n             array_result\n         }\n \n-        hir::ExprKind::Type(ref expr, ref _ty) => {\n-            v.check_expr(&expr)\n-        }\n-\n         hir::ExprKind::Tup(ref hirvec) => {\n             let mut tup_result = Promotable;\n             for index in hirvec.iter() {\n@@ -495,7 +493,6 @@ fn check_expr_kind<'a, 'tcx>(\n             tup_result\n         }\n \n-\n         // Conditional control flow (possible to implement).\n         hir::ExprKind::Match(ref expr, ref hirvec_arm, ref _match_source) => {\n             // Compute the most demanding borrow from all the arms'"}, {"sha": "7cd26dce1447c9d93657a3d87498458f0eb3ce52", "filename": "src/librustc_resolve/error_codes.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -1642,6 +1642,19 @@ fn main() {\n ```\n \"##,\n \n+E0671: r##\"\n+Const parameters cannot depend on type parameters.\n+The following is therefore invalid:\n+```compile_fail,E0671\n+#![feature(const_generics)]\n+\n+fn const_id<T, const N: T>() -> T { // error: const parameter\n+                                    // depends on type parameter\n+    N\n+}\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "80b82bc4dbd8490a18653016fb2f1ddad3947161", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -185,6 +185,8 @@ enum ResolutionError<'a> {\n     BindingShadowsSomethingUnacceptable(&'a str, Name, &'a NameBinding<'a>),\n     /// Error E0128: type parameters with a default cannot use forward-declared identifiers.\n     ForwardDeclaredTyParam, // FIXME(const_generics:defaults)\n+    /// Error E0671: const parameter cannot depend on type parameter.\n+    ConstParamDependentOnTypeParam,\n }\n \n /// Combines an error with provided span and emits it.\n@@ -440,6 +442,16 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                 span, \"defaulted type parameters cannot be forward declared\".to_string());\n             err\n         }\n+        ResolutionError::ConstParamDependentOnTypeParam => {\n+            let mut err = struct_span_err!(\n+                resolver.session,\n+                span,\n+                E0671,\n+                \"const parameters cannot depend on type parameters\"\n+            );\n+            err.span_label(span, format!(\"const parameter depends on type parameter\"));\n+            err\n+        }\n     }\n }\n \n@@ -915,6 +927,18 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                 }\n             }));\n \n+        // We also ban access to type parameters for use as the types of const parameters.\n+        let mut const_ty_param_ban_rib = Rib::new(TyParamAsConstParamTy);\n+        const_ty_param_ban_rib.bindings.extend(generics.params.iter()\n+            .filter(|param| {\n+                if let GenericParamKind::Type { .. } = param.kind {\n+                    true\n+                } else {\n+                    false\n+                }\n+            })\n+            .map(|param| (Ident::with_empty_ctxt(param.ident.name), Def::Err)));\n+\n         for param in &generics.params {\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => self.visit_generic_param(param),\n@@ -933,11 +957,15 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                     default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(param.ident.name));\n                 }\n                 GenericParamKind::Const { ref ty } => {\n+                    self.ribs[TypeNS].push(const_ty_param_ban_rib);\n+\n                     for bound in &param.bounds {\n                         self.visit_param_bound(bound);\n                     }\n \n                     self.visit_ty(ty);\n+\n+                    const_ty_param_ban_rib = self.ribs[TypeNS].pop().unwrap();\n                 }\n             }\n         }\n@@ -994,6 +1022,9 @@ enum RibKind<'a> {\n     /// from the default of a type parameter because they're not declared\n     /// before said type parameter. Also see the `visit_generics` override.\n     ForwardTyParamBanRibKind,\n+\n+    /// We forbid the use of type parameters as the types of const parameters.\n+    TyParamAsConstParamTy,\n }\n \n /// A single local scope.\n@@ -3944,6 +3975,15 @@ impl<'a> Resolver<'a> {\n             return Def::Err;\n         }\n \n+        // An invalid use of a type parameter as the type of a const parameter.\n+        if let TyParamAsConstParamTy = self.ribs[ns][rib_index].kind {\n+            if record_used {\n+                resolve_error(self, span, ResolutionError::ConstParamDependentOnTypeParam);\n+            }\n+            assert_eq!(def, Def::Err);\n+            return Def::Err;\n+        }\n+\n         match def {\n             Def::Upvar(..) => {\n                 span_bug!(span, \"unexpected {:?} in bindings\", def)\n@@ -3955,7 +3995,7 @@ impl<'a> Resolver<'a> {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | ModuleRibKind(..) | MacroDefinition(..) |\n-                        ForwardTyParamBanRibKind => {\n+                        ForwardTyParamBanRibKind | TyParamAsConstParamTy => {\n                             // Nothing to do. Continue.\n                         }\n                         ClosureRibKind(function_id) => {\n@@ -4013,7 +4053,7 @@ impl<'a> Resolver<'a> {\n                     match rib.kind {\n                         NormalRibKind | TraitOrImplItemRibKind | ClosureRibKind(..) |\n                         ModuleRibKind(..) | MacroDefinition(..) | ForwardTyParamBanRibKind |\n-                        ConstantItemRibKind => {\n+                        ConstantItemRibKind | TyParamAsConstParamTy => {\n                             // Nothing to do. Continue.\n                         }\n                         ItemRibKind | FnItemRibKind => {"}, {"sha": "27af8511915d1bce01d4604bbf9d997451c07ad5", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "modified", "additions": 141, "deletions": 27, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -6,10 +6,42 @@ use rustc::traits::{\n };\n use rustc::ty;\n use rustc::ty::subst::{InternalSubsts, Subst};\n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n use crate::lowering::Lower;\n use crate::generic_types;\n \n+/// Returns a predicate of the form\n+/// `Implemented(ty: Trait) :- Implemented(nested: Trait)...`\n+/// where `Trait` is specified by `trait_def_id`.\n+fn builtin_impl_clause(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    ty: ty::Ty<'tcx>,\n+    nested: &[ty::Ty<'tcx>],\n+    trait_def_id: DefId\n+) -> ProgramClause<'tcx> {\n+    ProgramClause {\n+        goal: ty::TraitPredicate {\n+            trait_ref: ty::TraitRef {\n+                def_id: trait_def_id,\n+                substs: tcx.mk_substs_trait(ty, &[]),\n+            },\n+        }.lower(),\n+        hypotheses: tcx.mk_goals(\n+            nested.iter()\n+                .cloned()\n+                .map(|nested_ty| ty::TraitRef {\n+                    def_id: trait_def_id,\n+                    substs: tcx.mk_substs_trait(nested_ty, &[]),\n+                })\n+                .map(|trait_ref| ty::TraitPredicate { trait_ref })\n+                .map(|pred| GoalKind::DomainGoal(pred.lower()))\n+                .map(|goal_kind| tcx.mk_goal(goal_kind))\n+        ),\n+        category: ProgramClauseCategory::Other,\n+    }\n+}\n+\n crate fn assemble_builtin_unsize_impls<'tcx>(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n     unsize_def_id: DefId,\n@@ -93,26 +125,7 @@ crate fn assemble_builtin_sized_impls<'tcx>(\n     clauses: &mut Vec<Clause<'tcx>>\n ) {\n     let mut push_builtin_impl = |ty: ty::Ty<'tcx>, nested: &[ty::Ty<'tcx>]| {\n-        let clause = ProgramClause {\n-            goal: ty::TraitPredicate {\n-                trait_ref: ty::TraitRef {\n-                    def_id: sized_def_id,\n-                    substs: tcx.mk_substs_trait(ty, &[]),\n-                },\n-            }.lower(),\n-            hypotheses: tcx.mk_goals(\n-                nested.iter()\n-                    .cloned()\n-                    .map(|nested_ty| ty::TraitRef {\n-                        def_id: sized_def_id,\n-                        substs: tcx.mk_substs_trait(nested_ty, &[]),\n-                    })\n-                    .map(|trait_ref| ty::TraitPredicate { trait_ref })\n-                    .map(|pred| GoalKind::DomainGoal(pred.lower()))\n-                    .map(|goal_kind| tcx.mk_goal(goal_kind))\n-            ),\n-            category: ProgramClauseCategory::Other,\n-        };\n+        let clause = builtin_impl_clause(tcx, ty, nested, sized_def_id);\n         // Bind innermost bound vars that may exist in `ty` and `nested`.\n         clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n     };\n@@ -124,6 +137,8 @@ crate fn assemble_builtin_sized_impls<'tcx>(\n         ty::Int(..) |\n         ty::Uint(..) |\n         ty::Float(..) |\n+        ty::Infer(ty::IntVar(_)) |\n+        ty::Infer(ty::FloatVar(_)) |\n         ty::Error |\n         ty::Never => push_builtin_impl(ty, &[]),\n \n@@ -175,14 +190,11 @@ crate fn assemble_builtin_sized_impls<'tcx>(\n             push_builtin_impl(adt, &sized_constraint);\n         }\n \n-        // Artificially trigger an ambiguity.\n-        ty::Infer(..) => {\n-            // Everybody can find at least two types to unify against:\n-            // general ty vars, int vars and float vars.\n+        // Artificially trigger an ambiguity by adding two possible types to\n+        // unify against.\n+        ty::Infer(ty::TyVar(_)) => {\n             push_builtin_impl(tcx.types.i32, &[]);\n-            push_builtin_impl(tcx.types.u32, &[]);\n             push_builtin_impl(tcx.types.f32, &[]);\n-            push_builtin_impl(tcx.types.f64, &[]);\n         }\n \n         ty::Projection(_projection_ty) => {\n@@ -203,6 +215,108 @@ crate fn assemble_builtin_sized_impls<'tcx>(\n         ty::Opaque(..) => (),\n \n         ty::Bound(..) |\n-        ty::GeneratorWitness(..) => bug!(\"unexpected type {:?}\", ty),\n+        ty::GeneratorWitness(..) |\n+        ty::Infer(ty::FreshTy(_)) |\n+        ty::Infer(ty::FreshIntTy(_)) |\n+        ty::Infer(ty::FreshFloatTy(_)) => bug!(\"unexpected type {:?}\", ty),\n+    }\n+}\n+\n+crate fn assemble_builtin_copy_clone_impls<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    trait_def_id: DefId,\n+    ty: ty::Ty<'tcx>,\n+    clauses: &mut Vec<Clause<'tcx>>\n+) {\n+    let mut push_builtin_impl = |ty: ty::Ty<'tcx>, nested: &[ty::Ty<'tcx>]| {\n+        let clause = builtin_impl_clause(tcx, ty, nested, trait_def_id);\n+        // Bind innermost bound vars that may exist in `ty` and `nested`.\n+        clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n+    };\n+\n+    match &ty.sty {\n+        // Implementations provided in libcore.\n+        ty::Bool |\n+        ty::Char |\n+        ty::Int(..) |\n+        ty::Uint(..) |\n+        ty::Float(..) |\n+        ty::RawPtr(..) |\n+        ty::Never |\n+        ty::Ref(_, _, hir::MutImmutable) => (),\n+\n+        // Non parametric primitive types.\n+        ty::Infer(ty::IntVar(_)) |\n+        ty::Infer(ty::FloatVar(_)) |\n+        ty::Error => push_builtin_impl(ty, &[]),\n+\n+        // These implement `Copy`/`Clone` if their element types do.\n+        &ty::Array(_, length) => {\n+            let element_ty = generic_types::bound(tcx, 0);\n+            push_builtin_impl(tcx.mk_ty(ty::Array(element_ty, length)), &[element_ty]);\n+        }\n+        &ty::Tuple(type_list) => {\n+            let type_list = generic_types::type_list(tcx, type_list.len());\n+            push_builtin_impl(tcx.mk_ty(ty::Tuple(type_list)), &**type_list);\n+        }\n+        &ty::Closure(def_id, ..) => {\n+            let closure_ty = generic_types::closure(tcx, def_id);\n+            let upvar_tys: Vec<_> = match &closure_ty.sty {\n+                ty::Closure(_, substs) => substs.upvar_tys(def_id, tcx).collect(),\n+                _ => bug!(),\n+            };\n+            push_builtin_impl(closure_ty, &upvar_tys);\n+        }\n+\n+        // These ones are always `Clone`.\n+        ty::FnPtr(fn_ptr) => {\n+            let fn_ptr = fn_ptr.skip_binder();\n+            let fn_ptr = generic_types::fn_ptr(\n+                tcx,\n+                fn_ptr.inputs_and_output.len(),\n+                fn_ptr.c_variadic,\n+                fn_ptr.unsafety,\n+                fn_ptr.abi\n+            );\n+            push_builtin_impl(fn_ptr, &[]);\n+        }\n+        &ty::FnDef(def_id, ..) => {\n+            push_builtin_impl(generic_types::fn_def(tcx, def_id), &[]);\n+        }\n+\n+        // These depend on whatever user-defined impls might exist.\n+        ty::Adt(_, _) => (),\n+\n+        // Artificially trigger an ambiguity by adding two possible types to\n+        // unify against.\n+        ty::Infer(ty::TyVar(_)) => {\n+            push_builtin_impl(tcx.types.i32, &[]);\n+            push_builtin_impl(tcx.types.f32, &[]);\n+        }\n+\n+        ty::Projection(_projection_ty) => {\n+            // FIXME: add builtin impls from the associated type values found in\n+            // trait impls of `projection_ty.trait_ref(tcx)`.\n+        }\n+\n+        // The `Copy`/`Clone` bound can only come from the environment.\n+        ty::Param(..) |\n+        ty::Placeholder(..) |\n+        ty::UnnormalizedProjection(..) |\n+        ty::Opaque(..) => (),\n+\n+        // Definitely not `Copy`/`Clone`.\n+        ty::Dynamic(..) |\n+        ty::Foreign(..) |\n+        ty::Generator(..) |\n+        ty::Str |\n+        ty::Slice(..) |\n+        ty::Ref(_, _, hir::MutMutable) => (),\n+\n+        ty::Bound(..) |\n+        ty::GeneratorWitness(..) |\n+        ty::Infer(ty::FreshTy(_)) |\n+        ty::Infer(ty::FreshIntTy(_)) |\n+        ty::Infer(ty::FreshFloatTy(_)) => bug!(\"unexpected type {:?}\", ty),\n     }\n }"}, {"sha": "7feb63bb100691202dc720f9da5ea2289b75e0f3", "filename": "src/librustc_traits/chalk_context/program_clauses/mod.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -96,8 +96,27 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n                     );\n                 }\n \n+                if Some(trait_predicate.def_id()) == self.infcx.tcx.lang_items().copy_trait() {\n+                    assemble_builtin_copy_clone_impls(\n+                        self.infcx.tcx,\n+                        trait_predicate.def_id(),\n+                        trait_predicate.self_ty(),\n+                        &mut clauses\n+                    );\n+                }\n+\n+                if Some(trait_predicate.def_id()) == self.infcx.tcx.lang_items().clone_trait() {\n+                    // For all builtin impls, the conditions for `Copy` and\n+                    // `Clone` are the same.\n+                    assemble_builtin_copy_clone_impls(\n+                        self.infcx.tcx,\n+                        trait_predicate.def_id(),\n+                        trait_predicate.self_ty(),\n+                        &mut clauses\n+                    );\n+                }\n+\n                 // FIXME: we need to add special rules for other builtin impls:\n-                // * `Copy` / `Clone`\n                 // * `Generator`\n                 // * `FnOnce` / `FnMut` / `Fn`\n                 // * trait objects"}, {"sha": "ff3245a467ad8ed460da84dd2279307076b54320", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -4533,6 +4533,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.check_expr_eq_type(&e, ty);\n                 ty\n             }\n+            ExprKind::Use(ref e) => {\n+                self.check_expr_with_expectation(e, expected)\n+            }\n             ExprKind::Array(ref args) => {\n                 let uty = expected.to_option(self).and_then(|uty| {\n                     match uty.sty {"}, {"sha": "d1ca05780930aae22a28854174b9713195467b4d", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -443,13 +443,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     ) -> bool /* did we suggest to call a function because of missing parenthesis? */ {\n         err.span_label(span, ty.to_string());\n         if let FnDef(def_id, _) = ty.sty {\n+            let source_map = self.tcx.sess.source_map();\n+            let hir_id = match self.tcx.hir().as_local_hir_id(def_id) {\n+                Some(hir_id) => hir_id,\n+                None => return false,\n+            };\n             if self.tcx.has_typeck_tables(def_id) == false {\n                 return false;\n             }\n-            let source_map = self.tcx.sess.source_map();\n-            let hir_id = &self.tcx.hir().as_local_hir_id(def_id).unwrap();\n             let fn_sig = {\n-                match self.tcx.typeck_tables_of(def_id).liberated_fn_sigs().get(*hir_id) {\n+                match self.tcx.typeck_tables_of(def_id).liberated_fn_sigs().get(hir_id) {\n                     Some(f) => f.clone(),\n                     None => {\n                         bug!(\"No fn-sig entry for def_id={:?}\", def_id);\n@@ -458,11 +461,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             let other_ty = if let FnDef(def_id, _) = other_ty.sty {\n+                let hir_id = match self.tcx.hir().as_local_hir_id(def_id) {\n+                    Some(hir_id) => hir_id,\n+                    None => return false,\n+                };\n                 if self.tcx.has_typeck_tables(def_id) == false {\n                     return false;\n                 }\n-                let hir_id = &self.tcx.hir().as_local_hir_id(def_id).unwrap();\n-                match self.tcx.typeck_tables_of(def_id).liberated_fn_sigs().get(*hir_id) {\n+                match self.tcx.typeck_tables_of(def_id).liberated_fn_sigs().get(hir_id) {\n                     Some(f) => f.clone().output(),\n                     None => {\n                         bug!(\"No fn-sig entry for def_id={:?}\", def_id);"}, {"sha": "6cedab412df924ddcfcdf49e8a27005dcb6214cd", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -10,6 +10,6 @@ path = \"lib.rs\"\n \n [dependencies]\n pulldown-cmark = { version = \"0.4.1\", default-features = false }\n-minifier = \"0.0.29\"\n+minifier = \"0.0.30\"\n tempfile = \"3\"\n parking_lot = \"0.7\""}, {"sha": "72421c9decc6febf4c10e40cfd56a42aec037783", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -351,6 +351,9 @@ impl Options {\n                             .unwrap_or_else(|| PathBuf::from(\"doc\"));\n         let mut cfgs = matches.opt_strs(\"cfg\");\n         cfgs.push(\"rustdoc\".to_string());\n+        if should_test {\n+            cfgs.push(\"test\".to_string());\n+        }\n \n         let extension_css = matches.opt_str(\"e\").map(|s| PathBuf::from(&s));\n "}, {"sha": "3e6aeddeae0d024534561c3546e76ffd03a84781", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -951,40 +951,15 @@ themePicker.onblur = handleThemeButtonsBlur;\n         key: &str,\n         for_search_index: bool,\n     ) -> io::Result<(Vec<String>, Vec<String>, Vec<String>)> {\n-        use minifier::js;\n-\n         let mut ret = Vec::new();\n         let mut krates = Vec::new();\n         let mut variables = Vec::new();\n \n-        let mut krate = krate.to_owned();\n-\n         if path.exists() {\n             for line in BufReader::new(File::open(path)?).lines() {\n                 let line = line?;\n                 if for_search_index && line.starts_with(\"var R\") {\n                     variables.push(line.clone());\n-                    // We need to check if the crate name has been put into a variable as well.\n-                    let tokens: js::Tokens<'_> = js::simple_minify(&line)\n-                                                    .into_iter()\n-                                                    .filter(js::clean_token)\n-                                                    .collect::<Vec<_>>()\n-                                                    .into();\n-                    let mut pos = 0;\n-                    while pos < tokens.len() {\n-                        if let Some((var_pos, Some(value_pos))) =\n-                                js::get_variable_name_and_value_positions(&tokens, pos) {\n-                            if let Some(s) = tokens.0[value_pos].get_string() {\n-                                if &s[1..s.len() - 1] == krate {\n-                                    if let Some(var) = tokens[var_pos].get_other() {\n-                                        krate = var.to_owned();\n-                                        break\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        pos += 1;\n-                    }\n                     continue;\n                 }\n                 if !line.starts_with(key) {\n@@ -1340,10 +1315,20 @@ fn write_minify_replacer<W: Write>(\n                         .into();\n                     tokens.apply(|f| {\n                         // We add a backline after the newly created variables.\n-                        minifier::js::aggregate_strings_into_array_with_separation(\n+                        minifier::js::aggregate_strings_into_array_with_separation_filter(\n                             f,\n                             \"R\",\n                             Token::Char(ReservedChar::Backline),\n+                            // This closure prevents crates' names from being aggregated.\n+                            //\n+                            // The point here is to check if the string is preceded by '[' and\n+                            // \"searchIndex\". If so, it means this is a crate name and that it\n+                            // shouldn't be aggregated.\n+                            |tokens, pos| {\n+                                pos < 2 ||\n+                                !tokens[pos - 1].is_char(ReservedChar::OpenBracket) ||\n+                                tokens[pos - 2].get_other() != Some(\"searchIndex\")\n+                            }\n                         )\n                     })\n                     .to_string()\n@@ -1358,7 +1343,8 @@ fn write_minify_replacer<W: Write>(\n /// static HTML tree. Each component in the cleaned path will be passed as an\n /// argument to `f`. The very last component of the path (ie the file name) will\n /// be passed to `f` if `keep_filename` is true, and ignored otherwise.\n-fn clean_srcpath<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F) where\n+fn clean_srcpath<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n+where\n     F: FnMut(&OsStr),\n {\n     // make it relative, if possible\n@@ -1470,11 +1456,11 @@ impl<'a> SourceCollector<'a> {\n         let mut href = String::new();\n         clean_srcpath(&self.scx.src_root, &p, false, |component| {\n             cur.push(component);\n-            fs::create_dir_all(&cur).unwrap();\n             root_path.push_str(\"../\");\n             href.push_str(&component.to_string_lossy());\n             href.push('/');\n         });\n+        fs::create_dir_all(&cur)?;\n         let mut fname = p.file_name()\n                          .expect(\"source has no filename\")\n                          .to_os_string();\n@@ -1483,7 +1469,7 @@ impl<'a> SourceCollector<'a> {\n         href.push_str(&fname.to_string_lossy());\n \n         let mut w = BufWriter::new(File::create(&cur)?);\n-        let title = format!(\"{} -- source\", cur.file_name().unwrap()\n+        let title = format!(\"{} -- source\", cur.file_name().expect(\"failed to get file name\")\n                                                .to_string_lossy());\n         let desc = format!(\"Source to the Rust file `{}`.\", filename);\n         let page = layout::Page {"}, {"sha": "98952ad918c923e1119e679193db22818b1817df", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -403,6 +403,7 @@ declare_features! (\n     (active, cmpxchg16b_target_feature, \"1.32.0\", Some(44839), None),\n     (active, movbe_target_feature, \"1.34.0\", Some(44839), None),\n     (active, rtm_target_feature, \"1.35.0\", Some(44839), None),\n+    (active, f16c_target_feature, \"1.36.0\", Some(44839), None),\n \n     // Allows macro invocations on modules expressions and statements and\n     // procedural macros to expand to non-items.\n@@ -2258,32 +2259,32 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n                 continue;\n             }\n \n-            if let Some((.., set)) = ACTIVE_FEATURES.iter().find(|f| name == f.0) {\n-                if let Some(allowed) = allow_features.as_ref() {\n-                    if allowed.iter().find(|f| *f == name.as_str()).is_none() {\n-                        span_err!(span_handler, mi.span(), E0725,\n-                                  \"the feature `{}` is not in the list of allowed features\",\n-                                  name);\n-                        continue;\n-                    }\n-                }\n-\n-                set(&mut features, mi.span());\n-                features.declared_lang_features.push((name, mi.span(), None));\n-                continue\n-            }\n-\n             let removed = REMOVED_FEATURES.iter().find(|f| name == f.0);\n             let stable_removed = STABLE_REMOVED_FEATURES.iter().find(|f| name == f.0);\n             if let Some((.., reason)) = removed.or(stable_removed) {\n                 feature_removed(span_handler, mi.span(), *reason);\n-                continue\n+                continue;\n             }\n \n             if let Some((_, since, ..)) = ACCEPTED_FEATURES.iter().find(|f| name == f.0) {\n                 let since = Some(Symbol::intern(since));\n                 features.declared_lang_features.push((name, mi.span(), since));\n-                continue\n+                continue;\n+            }\n+\n+            if let Some(allowed) = allow_features.as_ref() {\n+                if allowed.iter().find(|f| *f == name.as_str()).is_none() {\n+                    span_err!(span_handler, mi.span(), E0725,\n+                              \"the feature `{}` is not in the list of allowed features\",\n+                              name);\n+                    continue;\n+                }\n+            }\n+\n+            if let Some((.., set)) = ACTIVE_FEATURES.iter().find(|f| name == f.0) {\n+                set(&mut features, mi.span());\n+                features.declared_lang_features.push((name, mi.span(), None));\n+                continue;\n             }\n \n             features.declared_lib_features.push((name, mi.span()));"}, {"sha": "4f69714bc747d7b3c5ebcf5d482716c1b809f111", "filename": "src/test/run-pass/chalkify/builtin-copy-clone.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Frun-pass%2Fchalkify%2Fbuiltin-copy-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Frun-pass%2Fchalkify%2Fbuiltin-copy-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchalkify%2Fbuiltin-copy-clone.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -0,0 +1,43 @@\n+// compile-flags: -Z chalk\n+\n+// Test that `Clone` is correctly implemented for builtin types.\n+\n+#[derive(Copy, Clone)]\n+struct S(i32);\n+\n+fn test_clone<T: Clone>(arg: T) {\n+    let _ = arg.clone();\n+}\n+\n+fn test_copy<T: Copy>(arg: T) {\n+    let _ = arg;\n+    let _ = arg;\n+}\n+\n+fn test_copy_clone<T: Copy + Clone>(arg: T) {\n+    test_copy(arg);\n+    test_clone(arg);\n+}\n+\n+fn foo() { }\n+\n+fn main() {\n+    test_copy_clone(foo);\n+    let f: fn() = foo;\n+    test_copy_clone(f);\n+    // FIXME: add closures when they're considered WF\n+    test_copy_clone([1; 56]);\n+    test_copy_clone((1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));\n+    test_copy_clone((1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, true, 'a', 1.1));\n+    test_copy_clone(());\n+    test_copy_clone(((1, 1), (1, 1, 1), (1.1, 1, 1, 'a'), ()));\n+\n+    let a = (\n+        (S(1), S(0)),\n+        (\n+            (S(0), S(0), S(1)),\n+            S(0)\n+        )\n+    );\n+    test_copy_clone(a);\n+}"}, {"sha": "e26034371f444b3452992751950526cb9abdc015", "filename": "src/test/rustdoc-ui/cfg-test.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Frustdoc-ui%2Fcfg-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Frustdoc-ui%2Fcfg-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcfg-test.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -0,0 +1,19 @@\n+// compile-pass\n+// compile-flags:--test\n+// normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n+\n+/// this doctest will be ignored:\n+///\n+/// ```\n+/// assert!(false);\n+/// ```\n+#[cfg(not(test))]\n+pub struct Foo;\n+\n+/// this doctest will be tested:\n+///\n+/// ```\n+/// assert!(true);\n+/// ```\n+#[cfg(test)]\n+pub struct Foo;"}, {"sha": "30bb0038d1b8dfb13cc8a43db9979c8e585d78c2", "filename": "src/test/rustdoc-ui/cfg-test.stdout", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Frustdoc-ui%2Fcfg-test.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Frustdoc-ui%2Fcfg-test.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcfg-test.stdout?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -0,0 +1,6 @@\n+\n+running 1 test\n+test $DIR/cfg-test.rs - Foo (line 15) ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+"}, {"sha": "f0476f083b8a15d1e39222faece26c3fc0c3c12c", "filename": "src/test/rustdoc/index-page.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Frustdoc%2Findex-page.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Frustdoc%2Findex-page.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Findex-page.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -1,8 +1,11 @@\n+// aux-build:all-item-types.rs\n+// build-aux-docs\n // compile-flags: -Z unstable-options --enable-index-page\n \n #![crate_name = \"foo\"]\n \n // @has foo/../index.html\n // @has - '//span[@class=\"in-band\"]' 'List of all crates'\n // @has - '//ul[@class=\"mod\"]//a[@href=\"foo/index.html\"]' 'foo'\n+// @has - '//ul[@class=\"mod\"]//a[@href=\"all_item_types/index.html\"]' 'all_item_types'\n pub struct Foo;"}, {"sha": "af5e8f49754e819ee8cb97fbe554ae156e80c2aa", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param-ungated.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -0,0 +1,6 @@\n+use std::marker::PhantomData;\n+\n+struct B<T, const N: T>(PhantomData<[T; N]>); //~ ERROR const generics are unstable\n+//~^ ERROR const parameters cannot depend on type parameters\n+\n+fn main() {}"}, {"sha": "e3adbcfe60204647e674b4ece694c31099a2921d", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param-ungated.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -0,0 +1,19 @@\n+error[E0671]: const parameters cannot depend on type parameters\n+  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:22\n+   |\n+LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n+   |                      ^ const parameter depends on type parameter\n+\n+error[E0658]: const generics are unstable\n+  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:19\n+   |\n+LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n+   |                   ^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/44580\n+   = help: add #![feature(const_generics)] to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0658, E0671.\n+For more information about an error, try `rustc --explain E0658`."}, {"sha": "28e0d6c2bb7e7b219f13353cf92f2c03bfceb419", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -0,0 +1,13 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+// Currently, const parameters cannot depend on type parameters, because there is no way to\n+// enforce the `structural_match` property on an arbitrary type parameter. This restriction\n+// may be relaxed in the future. See https://github.com/rust-lang/rfcs/pull/2000 for more\n+// details.\n+\n+pub struct Dependent<T, const X: T>([(); X]);\n+//~^ ERROR const parameters cannot depend on type parameters\n+//~^^ ERROR parameter `T` is never used\n+\n+fn main() {}"}, {"sha": "c7dcbe1354266fde863fd807a784ab0bf642d765", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.stderr?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -0,0 +1,24 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/const-param-type-depends-on-type-param.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+\n+error[E0671]: const parameters cannot depend on type parameters\n+  --> $DIR/const-param-type-depends-on-type-param.rs:9:34\n+   |\n+LL | pub struct Dependent<T, const X: T>([(); X]);\n+   |                                  ^ const parameter depends on type parameter\n+\n+error[E0392]: parameter `T` is never used\n+  --> $DIR/const-param-type-depends-on-type-param.rs:9:22\n+   |\n+LL | pub struct Dependent<T, const X: T>([(); X]);\n+   |                      ^ unused parameter\n+   |\n+   = help: consider removing `T` or using a marker such as `std::marker::PhantomData`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0392, E0671.\n+For more information about an error, try `rustc --explain E0392`."}, {"sha": "784a1d2697d672b7816b3c42efab2c0bee0f7c13", "filename": "src/test/ui/feature-gate/allow-features-empty.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features-empty.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -7,4 +7,6 @@\n \n #![feature(lang_items)] //~ ERROR\n \n+#![feature(unknown_stdlib_feature)] //~ ERROR\n+\n fn main() {}"}, {"sha": "ab41422ed05b858851ccd2499ad9712e258488e5", "filename": "src/test/ui/feature-gate/allow-features-empty.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features-empty.stderr?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -16,6 +16,12 @@ error[E0725]: the feature `lang_items` is not in the list of allowed features\n LL | #![feature(lang_items)]\n    |            ^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error[E0725]: the feature `unknown_stdlib_feature` is not in the list of allowed features\n+  --> $DIR/allow-features-empty.rs:10:12\n+   |\n+LL | #![feature(unknown_stdlib_feature)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0725`."}, {"sha": "de3439a5b628f1868d81564a63019968dddbedb9", "filename": "src/test/ui/feature-gate/allow-features.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -7,4 +7,6 @@\n \n #![feature(lang_items)]\n \n+#![feature(unknown_stdlib_feature)] //~ ERROR\n+\n fn main() {}"}, {"sha": "5b39a6f053bde479da20e4973a96897903561119", "filename": "src/test/ui/feature-gate/allow-features.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features.stderr?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -4,6 +4,12 @@ error[E0725]: the feature `rustc_const_unstable` is not in the list of allowed f\n LL | #![feature(rustc_const_unstable)]\n    |            ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0725]: the feature `unknown_stdlib_feature` is not in the list of allowed features\n+  --> $DIR/allow-features.rs:10:12\n+   |\n+LL | #![feature(unknown_stdlib_feature)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0725`."}, {"sha": "bc7f7caa1076663e66b98ec01872da0c4e11e034", "filename": "src/test/ui/target-feature-gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Ftarget-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Ftarget-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-gate.rs?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -24,6 +24,7 @@\n // gate-test-cmpxchg16b_target_feature\n // gate-test-movbe_target_feature\n // gate-test-rtm_target_feature\n+// gate-test-f16c_target_feature\n // min-llvm-version 6.0\n \n #[target_feature(enable = \"avx512bw\")]"}, {"sha": "c7adba868eaf866020f1412ad6430a975abe6c3c", "filename": "src/test/ui/target-feature-gate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Ftarget-feature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/180edc21eeca50d0d597de091c8eb712667b5dd2/src%2Ftest%2Fui%2Ftarget-feature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-gate.stderr?ref=180edc21eeca50d0d597de091c8eb712667b5dd2", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: the target feature `avx512bw` is currently unstable\n-  --> $DIR/target-feature-gate.rs:29:18\n+  --> $DIR/target-feature-gate.rs:30:18\n    |\n LL | #[target_feature(enable = \"avx512bw\")]\n    |                  ^^^^^^^^^^^^^^^^^^^"}]}