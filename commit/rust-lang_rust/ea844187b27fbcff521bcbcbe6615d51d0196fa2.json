{"sha": "ea844187b27fbcff521bcbcbe6615d51d0196fa2", "node_id": "C_kwDOAAsO6NoAKGVhODQ0MTg3YjI3ZmJjZmY1MjFiY2JjYmU2NjE1ZDUxZDAxOTZmYTI", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-01-27T19:32:50Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-01-27T19:33:42Z"}, "message": "Special-case handling of impl blocks", "tree": {"sha": "1db6d6dcd1cc151a2a9f24d72f63cf28c93c687e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1db6d6dcd1cc151a2a9f24d72f63cf28c93c687e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea844187b27fbcff521bcbcbe6615d51d0196fa2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea844187b27fbcff521bcbcbe6615d51d0196fa2", "html_url": "https://github.com/rust-lang/rust/commit/ea844187b27fbcff521bcbcbe6615d51d0196fa2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea844187b27fbcff521bcbcbe6615d51d0196fa2/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b3eef873407ab49918f941810e69c47c79a2b3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b3eef873407ab49918f941810e69c47c79a2b3c", "html_url": "https://github.com/rust-lang/rust/commit/4b3eef873407ab49918f941810e69c47c79a2b3c"}], "stats": {"total": 123, "additions": 75, "deletions": 48}, "files": [{"sha": "8c733ddefc0a5a1efe02dd3d95647f85533a297b", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 61, "deletions": 44, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/ea844187b27fbcff521bcbcbe6615d51d0196fa2/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea844187b27fbcff521bcbcbe6615d51d0196fa2/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=ea844187b27fbcff521bcbcbe6615d51d0196fa2", "patch": "@@ -59,57 +59,74 @@ impl<'a, 'tcx> Stripper<'a, 'tcx> {\n         self.is_in_hidden_item = prev;\n         ret\n     }\n+\n+    /// In case `i` is a non-hidden impl block, then we special-case it by changing the value\n+    /// of `is_in_hidden_item` to `true` because the impl children inherit its visibility.\n+    fn recurse_in_impl(&mut self, i: Item) -> Item {\n+        let prev = mem::replace(&mut self.is_in_hidden_item, false);\n+        let ret = self.fold_item_recur(i);\n+        self.is_in_hidden_item = prev;\n+        ret\n+    }\n }\n \n impl<'a, 'tcx> DocFolder for Stripper<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         let has_doc_hidden = i.attrs.lists(sym::doc).has_word(sym::hidden);\n-        let mut is_hidden = self.is_in_hidden_item || has_doc_hidden;\n-        if !is_hidden && i.inline_stmt_id.is_none() {\n-            // We don't need to check if it's coming from a reexport since the reexport itself was\n-            // already checked.\n-            is_hidden = i\n-                .item_id\n-                .as_def_id()\n-                .and_then(|def_id| def_id.as_local())\n-                .map(|def_id| inherits_doc_hidden(self.tcx, def_id))\n-                .unwrap_or(false);\n+        let is_impl = matches!(*i.kind, clean::ImplItem(..));\n+        let mut is_hidden = has_doc_hidden;\n+        if !is_impl {\n+            is_hidden = self.is_in_hidden_item || has_doc_hidden;\n+            if !is_hidden && i.inline_stmt_id.is_none() {\n+                // We don't need to check if it's coming from a reexport since the reexport itself was\n+                // already checked.\n+                is_hidden = i\n+                    .item_id\n+                    .as_def_id()\n+                    .and_then(|def_id| def_id.as_local())\n+                    .map(|def_id| inherits_doc_hidden(self.tcx, def_id))\n+                    .unwrap_or(false);\n+            }\n         }\n-        if is_hidden {\n-            debug!(\"strip_hidden: stripping {:?} {:?}\", i.type_(), i.name);\n-            // Use a dedicated hidden item for fields, variants, and modules.\n-            // We need to keep private fields and variants, so that the docs\n-            // can show a placeholder \"// some variants omitted\". We need to keep\n-            // private modules, because they can contain impl blocks, and impl\n-            // block privacy is inherited from the type and trait, not from the\n-            // module it's defined in. Both of these are marked \"stripped,\" and\n-            // not included in the final docs, but since they still have an effect\n-            // on the final doc, cannot be completely removed from the Clean IR.\n-            return match *i.kind {\n-                clean::StructFieldItem(..) | clean::ModuleItem(..) | clean::VariantItem(..) => {\n-                    // We need to recurse into stripped modules to\n-                    // strip things like impl methods but when doing so\n-                    // we must not add any items to the `retained` set.\n-                    let old = mem::replace(&mut self.update_retained, false);\n-                    let ret = strip_item(self.set_is_in_hidden_item_and_fold(true, i));\n-                    self.update_retained = old;\n-                    Some(ret)\n-                }\n-                _ => {\n-                    let ret = self.set_is_in_hidden_item_and_fold(true, i);\n-                    if has_doc_hidden {\n-                        // If the item itself has `#[doc(hidden)]`, then we simply remove it.\n-                        None\n-                    } else {\n-                        // However if it's a \"descendant\" of a `#[doc(hidden)]` item, then we strip it.\n-                        Some(strip_item(ret))\n-                    }\n-                }\n-            };\n+        if !is_hidden {\n+            if self.update_retained {\n+                self.retained.insert(i.item_id);\n+            }\n+            return Some(if is_impl {\n+                self.recurse_in_impl(i)\n+            } else {\n+                self.set_is_in_hidden_item_and_fold(false, i)\n+            });\n         }\n-        if self.update_retained {\n-            self.retained.insert(i.item_id);\n+        debug!(\"strip_hidden: stripping {:?} {:?}\", i.type_(), i.name);\n+        // Use a dedicated hidden item for fields, variants, and modules.\n+        // We need to keep private fields and variants, so that the docs\n+        // can show a placeholder \"// some variants omitted\". We need to keep\n+        // private modules, because they can contain impl blocks, and impl\n+        // block privacy is inherited from the type and trait, not from the\n+        // module it's defined in. Both of these are marked \"stripped,\" and\n+        // not included in the final docs, but since they still have an effect\n+        // on the final doc, cannot be completely removed from the Clean IR.\n+        match *i.kind {\n+            clean::StructFieldItem(..) | clean::ModuleItem(..) | clean::VariantItem(..) => {\n+                // We need to recurse into stripped modules to\n+                // strip things like impl methods but when doing so\n+                // we must not add any items to the `retained` set.\n+                let old = mem::replace(&mut self.update_retained, false);\n+                let ret = strip_item(self.set_is_in_hidden_item_and_fold(true, i));\n+                self.update_retained = old;\n+                Some(ret)\n+            }\n+            _ => {\n+                let ret = self.set_is_in_hidden_item_and_fold(true, i);\n+                if has_doc_hidden {\n+                    // If the item itself has `#[doc(hidden)]`, then we simply remove it.\n+                    None\n+                } else {\n+                    // However if it's a \"descendant\" of a `#[doc(hidden)]` item, then we strip it.\n+                    Some(strip_item(ret))\n+                }\n+            }\n         }\n-        Some(self.set_is_in_hidden_item_and_fold(is_hidden, i))\n     }\n }"}, {"sha": "088cb3f339492be74fc4e8091b5693f7e2427fdc", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ea844187b27fbcff521bcbcbe6615d51d0196fa2/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea844187b27fbcff521bcbcbe6615d51d0196fa2/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=ea844187b27fbcff521bcbcbe6615d51d0196fa2", "patch": "@@ -55,11 +55,21 @@ fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<Symbol> {\n     std::iter::once(crate_name).chain(relative).collect()\n }\n \n-pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: LocalDefId) -> bool {\n-    while let Some(id) = tcx.opt_local_parent(node) {\n-        node = id;\n-        if tcx.is_doc_hidden(node.to_def_id()) {\n+pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut def_id: LocalDefId) -> bool {\n+    let hir = tcx.hir();\n+    while let Some(id) = tcx.opt_local_parent(def_id) {\n+        def_id = id;\n+        if tcx.is_doc_hidden(def_id.to_def_id()) {\n             return true;\n+        } else if let Some(node) = hir.find_by_def_id(def_id) &&\n+            matches!(\n+                node,\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(_), .. }),\n+            )\n+        {\n+            // `impl` blocks stand a bit on their own: unless they have `#[doc(hidden)]` directly\n+            // on them, they don't inherit it from the parent context.\n+            return false;\n         }\n     }\n     false"}]}