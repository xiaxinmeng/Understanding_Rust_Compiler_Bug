{"sha": "7e8f17188efcecfdfd1afbbc894a53c65985f836", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlOGYxNzE4OGVmY2VjZmRmZDFhZmJiYzg5NGE1M2M2NTk4NWY4MzY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-21T19:13:11Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-25T07:52:12Z"}, "message": "diagnostics", "tree": {"sha": "aab311a7646f9880adc82607abd227ef07e35d71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aab311a7646f9880adc82607abd227ef07e35d71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e8f17188efcecfdfd1afbbc894a53c65985f836", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e8f17188efcecfdfd1afbbc894a53c65985f836", "html_url": "https://github.com/rust-lang/rust/commit/7e8f17188efcecfdfd1afbbc894a53c65985f836", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e8f17188efcecfdfd1afbbc894a53c65985f836/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4132fbf3a08c9de2e28a50bc29a2c37a7c1a42fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4132fbf3a08c9de2e28a50bc29a2c37a7c1a42fc", "html_url": "https://github.com/rust-lang/rust/commit/4132fbf3a08c9de2e28a50bc29a2c37a7c1a42fc"}], "stats": {"total": 80, "additions": 74, "deletions": 6}, "files": [{"sha": "58481e715e70d359021c67527bb88d44e714d9ec", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e8f17188efcecfdfd1afbbc894a53c65985f836/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e8f17188efcecfdfd1afbbc894a53c65985f836/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=7e8f17188efcecfdfd1afbbc894a53c65985f836", "patch": "@@ -17,6 +17,7 @@ use crate::{\n     ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeId},\n     impl_block::ImplBlock,\n     resolve::Resolver,\n+    diagnostics::FunctionDiagnostic,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -519,6 +520,10 @@ impl Function {\n         let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n         r\n     }\n+\n+    pub fn diagnostics(&self, db: &impl HirDatabase) -> Vec<FunctionDiagnostic> {\n+        self.infer(db).diagnostics()\n+    }\n }\n \n impl Docs for Function {"}, {"sha": "82aff9cee0d34e0d5d9ce5d569dfe4c82b47b583", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e8f17188efcecfdfd1afbbc894a53c65985f836/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e8f17188efcecfdfd1afbbc894a53c65985f836/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=7e8f17188efcecfdfd1afbbc894a53c65985f836", "patch": "@@ -0,0 +1,6 @@\n+use crate::{expr::ExprId};\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum FunctionDiagnostic {\n+    NoSuchField { expr: ExprId, field: usize },\n+}"}, {"sha": "31af5d241080b6d2e8134445149037bf02d76199", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7e8f17188efcecfdfd1afbbc894a53c65985f836/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e8f17188efcecfdfd1afbbc894a53c65985f836/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=7e8f17188efcecfdfd1afbbc894a53c65985f836", "patch": "@@ -5,7 +5,7 @@ use rustc_hash::FxHashMap;\n \n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use ra_syntax::{\n-    SyntaxNodePtr, AstNode,\n+    SyntaxNodePtr, AstPtr, AstNode,\n     ast::{self, LoopBodyOwner, ArgListOwner, NameOwner, LiteralFlavor, TypeAscriptionOwner}\n };\n \n@@ -54,6 +54,7 @@ pub struct BodySourceMap {\n     expr_map_back: ArenaMap<ExprId, SyntaxNodePtr>,\n     pat_map: FxHashMap<SyntaxNodePtr, PatId>,\n     pat_map_back: ArenaMap<PatId, SyntaxNodePtr>,\n+    field_map: FxHashMap<(ExprId, usize), AstPtr<ast::NamedField>>,\n }\n \n impl Body {\n@@ -138,6 +139,10 @@ impl BodySourceMap {\n     pub fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n         self.pat_map.get(&SyntaxNodePtr::new(node.syntax())).cloned()\n     }\n+\n+    pub fn field_syntax(&self, expr: ExprId, field: usize) -> Option<AstPtr<ast::NamedField>> {\n+        self.field_map.get(&(expr, field)).cloned()\n+    }\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -629,8 +634,10 @@ impl ExprCollector {\n             }\n             ast::ExprKind::StructLit(e) => {\n                 let path = e.path().and_then(Path::from_ast);\n+                let mut field_ptrs = Vec::new();\n                 let fields = if let Some(nfl) = e.named_field_list() {\n                     nfl.fields()\n+                        .inspect(|field| field_ptrs.push(AstPtr::new(*field)))\n                         .map(|field| StructLitField {\n                             name: field\n                                 .name_ref()\n@@ -657,7 +664,11 @@ impl ExprCollector {\n                     Vec::new()\n                 };\n                 let spread = e.spread().map(|s| self.collect_expr(s));\n-                self.alloc_expr(Expr::StructLit { path, fields, spread }, syntax_ptr)\n+                let res = self.alloc_expr(Expr::StructLit { path, fields, spread }, syntax_ptr);\n+                for (i, ptr) in field_ptrs.into_iter().enumerate() {\n+                    self.source_map.field_map.insert((res, i), ptr);\n+                }\n+                res\n             }\n             ast::ExprKind::FieldExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());"}, {"sha": "390aef0a9cddb443b135ce6071e68c5555ac7ca3", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e8f17188efcecfdfd1afbbc894a53c65985f836/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e8f17188efcecfdfd1afbbc894a53c65985f836/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=7e8f17188efcecfdfd1afbbc894a53c65985f836", "patch": "@@ -35,6 +35,7 @@ mod expr;\n mod generics;\n mod docs;\n mod resolve;\n+pub mod diagnostics;\n \n mod code_model_api;\n mod code_model_impl;"}, {"sha": "269b5162e3117e7cbe3d154a413d701bca24f0b1", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7e8f17188efcecfdfd1afbbc894a53c65985f836/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e8f17188efcecfdfd1afbbc894a53c65985f836/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=7e8f17188efcecfdfd1afbbc894a53c65985f836", "patch": "@@ -36,7 +36,8 @@ use crate::{\n     path::{GenericArgs, GenericArg},\n     adt::VariantDef,\n     resolve::{Resolver, Resolution},\n-    nameres::Namespace\n+    nameres::Namespace,\n+    diagnostics::FunctionDiagnostic,\n };\n use super::{Ty, TypableDef, Substs, primitive, op, FnSig, ApplicationTy, TypeCtor};\n \n@@ -96,6 +97,7 @@ pub struct InferenceResult {\n     field_resolutions: FxHashMap<ExprId, StructField>,\n     /// For each associated item record what it resolves to\n     assoc_resolutions: FxHashMap<ExprOrPatId, ImplItem>,\n+    diagnostics: Vec<FunctionDiagnostic>,\n     pub(super) type_of_expr: ArenaMap<ExprId, Ty>,\n     pub(super) type_of_pat: ArenaMap<PatId, Ty>,\n }\n@@ -113,6 +115,9 @@ impl InferenceResult {\n     pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<ImplItem> {\n         self.assoc_resolutions.get(&id.into()).map(|it| *it)\n     }\n+    pub(crate) fn diagnostics(&self) -> Vec<FunctionDiagnostic> {\n+        self.diagnostics.clone()\n+    }\n }\n \n impl Index<ExprId> for InferenceResult {\n@@ -143,6 +148,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     assoc_resolutions: FxHashMap<ExprOrPatId, ImplItem>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n+    diagnostics: Vec<FunctionDiagnostic>,\n     /// The return type of the function being inferred.\n     return_ty: Ty,\n }\n@@ -155,6 +161,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             assoc_resolutions: FxHashMap::default(),\n             type_of_expr: ArenaMap::default(),\n             type_of_pat: ArenaMap::default(),\n+            diagnostics: Vec::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             db,\n@@ -181,6 +188,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             assoc_resolutions: self.assoc_resolutions,\n             type_of_expr: expr_types,\n             type_of_pat: pat_types,\n+            diagnostics: self.diagnostics,\n         }\n     }\n \n@@ -915,9 +923,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::StructLit { path, fields, spread } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_ref());\n                 let substs = ty.substs().unwrap_or_else(Substs::empty);\n-                for field in fields {\n+                for (field_idx, field) in fields.into_iter().enumerate() {\n                     let field_ty = def_id\n-                        .and_then(|it| it.field(self.db, &field.name))\n+                        .and_then(|it| match it.field(self.db, &field.name) {\n+                            Some(field) => Some(field),\n+                            None => {\n+                                self.diagnostics.push(FunctionDiagnostic::NoSuchField {\n+                                    expr: tgt_expr,\n+                                    field: field_idx,\n+                                });\n+                                None\n+                            }\n+                        })\n                         .map_or(Ty::Unknown, |field| field.ty(self.db))\n                         .subst(&substs);\n                     self.infer_expr(field.expr, &Expectation::has_type(field_ty));"}, {"sha": "f662f7e2f1b07ccb0a67b74aebfc75d08c292366", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7e8f17188efcecfdfd1afbbc894a53c65985f836/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e8f17188efcecfdfd1afbbc894a53c65985f836/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=7e8f17188efcecfdfd1afbbc894a53c65985f836", "patch": "@@ -3,7 +3,7 @@ use hir::{Problem, source_binder};\n use ra_db::SourceDatabase;\n use ra_syntax::{\n     Location, SourceFile, SyntaxKind, TextRange, SyntaxNode,\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, NameOwner},\n \n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n@@ -134,6 +134,13 @@ fn check_module(\n     file_id: FileId,\n     module: hir::Module,\n ) {\n+    for decl in module.declarations(db) {\n+        match decl {\n+            hir::ModuleDef::Function(f) => check_function(acc, db, f),\n+            _ => (),\n+        }\n+    }\n+\n     let source_root = db.file_source_root(file_id);\n     for (name_node, problem) in module.problems(db) {\n         let diag = match problem {\n@@ -153,6 +160,27 @@ fn check_module(\n     }\n }\n \n+fn check_function(acc: &mut Vec<Diagnostic>, db: &RootDatabase, function: hir::Function) {\n+    let (_file_id, fn_def) = function.source(db);\n+    let source_file = fn_def.syntax().ancestors().find_map(ast::SourceFile::cast).unwrap();\n+    let source_map = function.body_source_map(db);\n+    for d in function.diagnostics(db) {\n+        match d {\n+            hir::diagnostics::FunctionDiagnostic::NoSuchField { expr, field } => {\n+                if let Some(field) = source_map.field_syntax(expr, field) {\n+                    let field = field.to_node(&source_file);\n+                    acc.push(Diagnostic {\n+                        message: \"no such field\".into(),\n+                        range: field.syntax().range(),\n+                        severity: Severity::Error,\n+                        fix: None,\n+                    })\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use test_utils::assert_eq_text;"}]}