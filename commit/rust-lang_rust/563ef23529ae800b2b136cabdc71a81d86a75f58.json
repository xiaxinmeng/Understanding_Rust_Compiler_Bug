{"sha": "563ef23529ae800b2b136cabdc71a81d86a75f58", "node_id": "C_kwDOAAsO6NoAKDU2M2VmMjM1MjlhZTgwMGIyYjEzNmNhYmRjNzFhODFkODZhNzVmNTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-16T22:04:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-16T22:04:10Z"}, "message": "Auto merge of #95899 - petrochenkov:modchild2, r=cjgillot\n\nrustc_metadata: Do not encode unnecessary module children\n\nThis should remove the syntax context shift and the special case for `ExternCrate` in decoder in https://github.com/rust-lang/rust/pull/95880.\n\nThis PR also shifts some work from decoding to encoding, which is typically useful for performance (but probably not much in this case).\nr? `@cjgillot`", "tree": {"sha": "6457ca2757a1938584ef0a1cb21842d9e1bb43bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6457ca2757a1938584ef0a1cb21842d9e1bb43bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/563ef23529ae800b2b136cabdc71a81d86a75f58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/563ef23529ae800b2b136cabdc71a81d86a75f58", "html_url": "https://github.com/rust-lang/rust/commit/563ef23529ae800b2b136cabdc71a81d86a75f58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/563ef23529ae800b2b136cabdc71a81d86a75f58/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "url": "https://api.github.com/repos/rust-lang/rust/commits/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "html_url": "https://github.com/rust-lang/rust/commit/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936"}, {"sha": "233fa659f455e84cdf5ba74d8cda6e9fb3f6245b", "url": "https://api.github.com/repos/rust-lang/rust/commits/233fa659f455e84cdf5ba74d8cda6e9fb3f6245b", "html_url": "https://github.com/rust-lang/rust/commit/233fa659f455e84cdf5ba74d8cda6e9fb3f6245b"}], "stats": {"total": 167, "additions": 96, "deletions": 71}, "files": [{"sha": "30a3ddc6003035e417b74db88c7fd4864211af4d", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/563ef23529ae800b2b136cabdc71a81d86a75f58/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ef23529ae800b2b136cabdc71a81d86a75f58/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=563ef23529ae800b2b136cabdc71a81d86a75f58", "patch": "@@ -14,6 +14,8 @@\n #![feature(control_flow_enum)]\n #![feature(core_intrinsics)]\n #![feature(extend_one)]\n+#![feature(generator_trait)]\n+#![feature(generators)]\n #![feature(let_else)]\n #![feature(hash_raw_entry)]\n #![feature(maybe_uninit_uninit_array)]\n@@ -112,6 +114,9 @@ pub mod unhash;\n pub use ena::undo_log;\n pub use ena::unify;\n \n+use std::ops::{Generator, GeneratorState};\n+use std::pin::Pin;\n+\n pub struct OnDrop<F: Fn()>(pub F);\n \n impl<F: Fn()> OnDrop<F> {\n@@ -130,6 +135,26 @@ impl<F: Fn()> Drop for OnDrop<F> {\n     }\n }\n \n+struct IterFromGenerator<G>(G);\n+\n+impl<G: Generator<Return = ()> + Unpin> Iterator for IterFromGenerator<G> {\n+    type Item = G::Yield;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match Pin::new(&mut self.0).resume(()) {\n+            GeneratorState::Yielded(n) => Some(n),\n+            GeneratorState::Complete(_) => None,\n+        }\n+    }\n+}\n+\n+/// An adapter for turning a generator closure into an iterator, similar to `iter::from_fn`.\n+pub fn iter_from_generator<G: Generator<Return = ()> + Unpin>(\n+    generator: G,\n+) -> impl Iterator<Item = G::Yield> {\n+    IterFromGenerator(generator)\n+}\n+\n // See comments in src/librustc_middle/lib.rs\n #[doc(hidden)]\n pub fn __noop_fix_for_27438() {}"}, {"sha": "dfed9dd15a72173acddb6304ff87350393dd4974", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/563ef23529ae800b2b136cabdc71a81d86a75f58/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ef23529ae800b2b136cabdc71a81d86a75f58/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=563ef23529ae800b2b136cabdc71a81d86a75f58", "patch": "@@ -1,6 +1,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n+#![feature(generators)]\n #![feature(let_else)]\n #![feature(nll)]\n #![feature(once_cell)]"}, {"sha": "611694a0d304201cb4fc3d734bee720fec66469c", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 50, "deletions": 57, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/563ef23529ae800b2b136cabdc71a81d86a75f58/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ef23529ae800b2b136cabdc71a81d86a75f58/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=563ef23529ae800b2b136cabdc71a81d86a75f58", "patch": "@@ -1089,63 +1089,32 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         // Iterate over all children.\n         if let Some(children) = self.root.tables.children.get(self, id) {\n             for child_index in children.decode((self, sess)) {\n-                if let Some(ident) = self.opt_item_ident(child_index, sess) {\n-                    let kind = self.def_kind(child_index);\n-                    let def_id = self.local_def_id(child_index);\n-                    let res = Res::Def(kind, def_id);\n-                    let vis = self.get_visibility(child_index);\n-                    let span = self.get_span(child_index, sess);\n-                    let macro_rules = match kind {\n-                        DefKind::Macro(..) => match self.kind(child_index) {\n-                            EntryKind::MacroDef(_, macro_rules) => macro_rules,\n-                            _ => unreachable!(),\n-                        },\n-                        _ => false,\n-                    };\n-\n-                    callback(ModChild { ident, res, vis, span, macro_rules });\n-\n-                    // For non-re-export structs and variants add their constructors to children.\n-                    // Re-export lists automatically contain constructors when necessary.\n-                    match kind {\n-                        DefKind::Struct => {\n-                            if let Some((ctor_def_id, ctor_kind)) =\n-                                self.get_ctor_def_id_and_kind(child_index)\n-                            {\n-                                let ctor_res =\n-                                    Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n-                                let vis = self.get_visibility(ctor_def_id.index);\n-                                callback(ModChild {\n-                                    ident,\n-                                    res: ctor_res,\n-                                    vis,\n-                                    span,\n-                                    macro_rules: false,\n-                                });\n-                            }\n-                        }\n-                        DefKind::Variant => {\n-                            // Braced variants, unlike structs, generate unusable names in\n-                            // value namespace, they are reserved for possible future use.\n-                            // It's ok to use the variant's id as a ctor id since an\n-                            // error will be reported on any use of such resolution anyway.\n-                            let (ctor_def_id, ctor_kind) = self\n-                                .get_ctor_def_id_and_kind(child_index)\n-                                .unwrap_or((def_id, CtorKind::Fictive));\n+                let ident = self.item_ident(child_index, sess);\n+                let kind = self.def_kind(child_index);\n+                let def_id = self.local_def_id(child_index);\n+                let res = Res::Def(kind, def_id);\n+                let vis = self.get_visibility(child_index);\n+                let span = self.get_span(child_index, sess);\n+                let macro_rules = match kind {\n+                    DefKind::Macro(..) => match self.kind(child_index) {\n+                        EntryKind::MacroDef(_, macro_rules) => macro_rules,\n+                        _ => unreachable!(),\n+                    },\n+                    _ => false,\n+                };\n+\n+                callback(ModChild { ident, res, vis, span, macro_rules });\n+\n+                // For non-re-export structs and variants add their constructors to children.\n+                // Re-export lists automatically contain constructors when necessary.\n+                match kind {\n+                    DefKind::Struct => {\n+                        if let Some((ctor_def_id, ctor_kind)) =\n+                            self.get_ctor_def_id_and_kind(child_index)\n+                        {\n                             let ctor_res =\n-                                Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n-                            let mut vis = self.get_visibility(ctor_def_id.index);\n-                            if ctor_def_id == def_id && vis.is_public() {\n-                                // For non-exhaustive variants lower the constructor visibility to\n-                                // within the crate. We only need this for fictive constructors,\n-                                // for other constructors correct visibilities\n-                                // were already encoded in metadata.\n-                                let mut attrs = self.get_item_attrs(def_id.index, sess);\n-                                if attrs.any(|item| item.has_name(sym::non_exhaustive)) {\n-                                    let crate_def_id = self.local_def_id(CRATE_DEF_INDEX);\n-                                    vis = ty::Visibility::Restricted(crate_def_id);\n-                                }\n-                            }\n+                                Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n+                            let vis = self.get_visibility(ctor_def_id.index);\n                             callback(ModChild {\n                                 ident,\n                                 res: ctor_res,\n@@ -1154,8 +1123,32 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                                 macro_rules: false,\n                             });\n                         }\n-                        _ => {}\n                     }\n+                    DefKind::Variant => {\n+                        // Braced variants, unlike structs, generate unusable names in\n+                        // value namespace, they are reserved for possible future use.\n+                        // It's ok to use the variant's id as a ctor id since an\n+                        // error will be reported on any use of such resolution anyway.\n+                        let (ctor_def_id, ctor_kind) = self\n+                            .get_ctor_def_id_and_kind(child_index)\n+                            .unwrap_or((def_id, CtorKind::Fictive));\n+                        let ctor_res =\n+                            Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n+                        let mut vis = self.get_visibility(ctor_def_id.index);\n+                        if ctor_def_id == def_id && vis.is_public() {\n+                            // For non-exhaustive variants lower the constructor visibility to\n+                            // within the crate. We only need this for fictive constructors,\n+                            // for other constructors correct visibilities\n+                            // were already encoded in metadata.\n+                            let mut attrs = self.get_item_attrs(def_id.index, sess);\n+                            if attrs.any(|item| item.has_name(sym::non_exhaustive)) {\n+                                let crate_def_id = self.local_def_id(CRATE_DEF_INDEX);\n+                                vis = ty::Visibility::Restricted(crate_def_id);\n+                            }\n+                        }\n+                        callback(ModChild { ident, res: ctor_res, vis, span, macro_rules: false });\n+                    }\n+                    _ => {}\n                 }\n             }\n         }"}, {"sha": "732e7ef8a23d3f646dd25be2b6f49939dc7d0e85", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/563ef23529ae800b2b136cabdc71a81d86a75f58/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ef23529ae800b2b136cabdc71a81d86a75f58/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=563ef23529ae800b2b136cabdc71a81d86a75f58", "patch": "@@ -4,6 +4,7 @@ use crate::rmeta::*;\n \n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n+use rustc_data_structures::iter_from_generator;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{join, par_iter, Lrc, ParallelIterator};\n use rustc_hir as hir;\n@@ -1107,21 +1108,26 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             // Encode this here because we don't do it in encode_def_ids.\n             record!(self.tables.expn_that_defined[def_id] <- tcx.expn_that_defined(local_def_id));\n         } else {\n-            let direct_children = md.item_ids.iter().map(|item_id| item_id.def_id.local_def_index);\n-            // Foreign items are planted into their parent modules from name resolution point of view.\n-            let tcx = self.tcx;\n-            let foreign_item_children = md\n-                .item_ids\n-                .iter()\n-                .filter_map(|item_id| match tcx.hir().item(*item_id).kind {\n-                    hir::ItemKind::ForeignMod { items, .. } => {\n-                        Some(items.iter().map(|fi_ref| fi_ref.id.def_id.local_def_index))\n+            record!(self.tables.children[def_id] <- iter_from_generator(|| {\n+                for item_id in md.item_ids {\n+                    match tcx.hir().item(*item_id).kind {\n+                        // Foreign items are planted into their parent modules\n+                        // from name resolution point of view.\n+                        hir::ItemKind::ForeignMod { items, .. } => {\n+                            for foreign_item in items {\n+                                yield foreign_item.id.def_id.local_def_index;\n+                            }\n+                        }\n+                        // Only encode named non-reexport children, reexports are encoded\n+                        // separately and unnamed items are not used by name resolution.\n+                        hir::ItemKind::ExternCrate(..) => continue,\n+                        _ if tcx.def_key(item_id.def_id.to_def_id()).get_opt_name().is_some() => {\n+                            yield item_id.def_id.local_def_index;\n+                        }\n+                        _ => continue,\n                     }\n-                    _ => None,\n-                })\n-                .flatten();\n-\n-            record!(self.tables.children[def_id] <- direct_children.chain(foreign_item_children));\n+                }\n+            }));\n         }\n     }\n "}]}