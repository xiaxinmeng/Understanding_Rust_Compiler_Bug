{"sha": "93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZGUyZjBiNzQ5OGNiYzZhMzA0YmEzY2I4MGY1YTNlYTU3YjhiYzc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-14T15:18:48Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-14T15:30:38Z"}, "message": "Add syntax and representation for return-by-mutably-rooted-ref\n\nThis will be used in the near future to decide what can safely\nbe done with the returned reference.\n\nIssue #918", "tree": {"sha": "dd42794a80d712ff07af81493bd12231924e3e21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd42794a80d712ff07af81493bd12231924e3e21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7", "html_url": "https://github.com/rust-lang/rust/commit/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cabe37155bf83af04ce7814186fbef096a253cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cabe37155bf83af04ce7814186fbef096a253cb", "html_url": "https://github.com/rust-lang/rust/commit/1cabe37155bf83af04ce7814186fbef096a253cb"}], "stats": {"total": 89, "additions": 55, "deletions": 34}, "files": [{"sha": "b4ea33a12778efc28e7a1825dc326fa00d74b044", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7", "patch": "@@ -21,8 +21,6 @@ type str_def = fn(str) -> ast::def_id;\n type pstate =\n     {data: @[u8], crate: int, mutable pos: uint, len: uint, tcx: ty::ctxt};\n \n-tag ty_or_bang { a_ty(ty::t); a_bang; }\n-\n fn peek(st: @pstate) -> u8 { ret st.data[st.pos]; }\n \n fn next(st: @pstate) -> u8 {\n@@ -54,10 +52,12 @@ fn parse_ty_data(data: @[u8], crate_num: int, pos: uint, len: uint,\n     ret result;\n }\n \n-fn parse_ty_or_bang(st: @pstate, sd: str_def) -> ty_or_bang {\n+fn parse_ret_ty(st: @pstate, sd: str_def) -> (ast::ret_style, ty::t) {\n     alt peek(st) as char {\n-      '!' { next(st); ret a_bang; }\n-      _ { ret a_ty(parse_ty(st, sd)); }\n+      '!' { next(st); (ast::noreturn, ty::mk_bot(st.tcx)) }\n+      '&' { next(st); (ast::return_ref(false), parse_ty(st, sd)) }\n+      '^' { next(st); (ast::return_ref(true), parse_ty(st, sd)) }\n+      _ { (ast::return_val, parse_ty(st, sd)) }\n     }\n }\n \n@@ -387,12 +387,8 @@ fn parse_ty_fn(st: @pstate, sd: str_def) ->\n     }\n     st.pos += 1u; // eat the ']'\n     let cs = parse_constrs(st, sd);\n-    alt parse_ty_or_bang(st, sd) {\n-      a_bang. {\n-        ret {args: inputs, ty: ty::mk_bot(st.tcx), cf: ast::noreturn, cs: cs};\n-      }\n-      a_ty(t) { ret {args: inputs, ty: t, cf: ast::return_val, cs: cs}; }\n-    }\n+    let (ret_style, ret_ty) = parse_ret_ty(st, sd);\n+    ret {args: inputs, ty: ret_ty, cf: ret_style, cs: cs};\n }\n \n "}, {"sha": "234968cd97c954a097f73f84bcd746805384c5cf", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7", "patch": "@@ -220,6 +220,10 @@ fn enc_ty_fn(w: io::writer, cx: @ctxt, args: [ty::arg], out: ty::t,\n     }\n     alt cf {\n       noreturn. { w.write_char('!'); }\n+      return_ref(mut) {\n+        w.write_char(mut ? '^' : '&');\n+        enc_ty(w, cx, out);\n+      }\n       _ { enc_ty(w, cx, out); }\n     }\n }"}, {"sha": "c8536ef2ddb8356633340d4bd2f9968be78d4a9e", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7", "patch": "@@ -66,7 +66,7 @@ fn visit_fn(cx: @ctx, f: ast::_fn, _tp: [ast::ty_param], _sp: span,\n       // Non capturing functions start out fresh.\n       _ { [] }\n     };\n-    if f.decl.cf == ast::return_ref && !is_none(f.body.node.expr) {\n+    if ast_util::ret_by_ref(f.decl.cf) && !is_none(f.body.node.expr) {\n         // FIXME this will be easier to lift once have DPS\n         cx.tcx.sess.span_err(option::get(f.body.node.expr).span,\n                              \"reference-returning functions may not \" +\n@@ -118,8 +118,13 @@ fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n         check_assign(cx, dest, src, sc, v);\n       }\n       ast::expr_ret(oexpr) {\n-        if sc.ret_style == ast::return_ref && !is_none(oexpr) {\n-            check_ret_ref(*cx, sc, option::get(oexpr));\n+        if !is_none(oexpr) {\n+            alt sc.ret_style {\n+              ast::return_ref(mut) {\n+                check_ret_ref(*cx, sc, mut, option::get(oexpr));\n+              }\n+              _ {}\n+            }\n         }\n         handled = false;\n       }\n@@ -176,7 +181,7 @@ fn cant_copy(cx: ctx, b: binding) -> bool {\n \n fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [binding] {\n     let fty = ty::type_autoderef(cx.tcx, ty::expr_ty(cx.tcx, f));\n-    let ret_ref = ty::ty_fn_ret_style(cx.tcx, fty) == ast::return_ref;\n+    let ret_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(cx.tcx, fty));\n     let arg_ts = ty::ty_fn_args(cx.tcx, fty);\n     let mut_roots: [{arg: uint, node: node_id}] = [];\n     let bindings = [];\n@@ -266,7 +271,7 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [binding] {\n     ret bindings;\n }\n \n-fn check_ret_ref(cx: ctx, sc: scope, expr: @ast::expr) {\n+fn check_ret_ref(cx: ctx, sc: scope, mut: bool, expr: @ast::expr) {\n     let root = expr_root(cx.tcx, expr, false);\n     let bad = none;\n     let mut_field = mut_field(root.ds);\n@@ -312,7 +317,7 @@ fn check_ret_ref(cx: ctx, sc: scope, expr: @ast::expr) {\n       // FIXME allow references to constants and static items?\n       _ { bad = some(\"non-local value\"); }\n     }\n-      if mut_field { bad = some(\"mutable field\"); }\n+    if mut_field && !mut { bad = some(\"mutable field\"); }\n     alt bad {\n       some(name) {\n         cx.tcx.sess.span_err(expr.span, \"can not return a reference \" +"}, {"sha": "ba495934387b87bf707b0f58ab47cf10ebc3c7b4", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7", "patch": "@@ -101,7 +101,7 @@ fn type_of_fn(cx: @crate_ctxt, sp: span, proto: ast::proto,\n // Given a function type and a count of ty params, construct an llvm type\n fn type_of_fn_from_ty(cx: @crate_ctxt, sp: span, fty: ty::t,\n                       ty_param_count: uint) -> TypeRef {\n-    let by_ref = ty::ty_fn_ret_style(cx.tcx, fty) == ast::return_ref;\n+    let by_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(cx.tcx, fty));\n     ret type_of_fn(cx, sp, ty::ty_fn_proto(cx.tcx, fty),\n                    false, by_ref, ty::ty_fn_args(cx.tcx, fty),\n                    ty::ty_fn_ret(cx.tcx, fty), ty_param_count);\n@@ -2969,7 +2969,7 @@ fn trans_field(cx: @block_ctxt, sp: span, v: ValueRef, t0: ty::t,\n         let v = GEP(r.bcx, vtbl, [C_int(0), C_int(ix as int)]);\n         let tcx = bcx_tcx(cx);\n         let fn_ty: ty::t = ty::method_ty_to_fn_ty(tcx, methods[ix]);\n-        let ret_ref = ty::ty_fn_ret_style(tcx, fn_ty) == ast::return_ref;\n+        let ret_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(tcx, fn_ty));\n         let ll_fn_ty =\n             type_of_fn(bcx_ccx(cx), sp, ty::ty_fn_proto(tcx, fn_ty),\n                        true, ret_ref, ty::ty_fn_args(tcx, fn_ty),\n@@ -3532,7 +3532,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n     let ccx = bcx_ccx(cx);\n     let tcx = ccx.tcx;\n     let bcx: @block_ctxt = cx;\n-    let by_ref = ty::ty_fn_ret_style(tcx, fn_ty) == ast::return_ref;\n+    let by_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(tcx, fn_ty));\n     // Arg 0: Output pointer.\n \n     // FIXME: test case looks like\n@@ -3629,7 +3629,8 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     // with trans_call.\n     let fn_expr_ty = ty::expr_ty(bcx_tcx(in_cx), f);\n     let fn_ty = ty::type_autoderef(bcx_tcx(in_cx), fn_expr_ty);\n-    let by_ref = ty::ty_fn_ret_style(bcx_tcx(in_cx), fn_ty) == ast::return_ref;\n+    let by_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(bcx_tcx(in_cx),\n+                                                          fn_ty));\n     // Things that return by reference must put their arguments (FIXME only\n     // the referenced arguments) into the outer scope, so that they are still\n     // alive when the return value is used.\n@@ -4391,7 +4392,7 @@ fn trans_ret(cx: @block_ctxt, e: option::t<@ast::expr>) -> result {\n         let t = ty::expr_ty(bcx_tcx(cx), x);\n         let lv = trans_lval(cx, x);\n         bcx = lv.res.bcx;\n-        if cx.fcx.ret_style == ast::return_ref {\n+        if ast_util::ret_by_ref(cx.fcx.ret_style) {\n             assert lv.is_mem;\n             Store(bcx, lv.res.val, cx.fcx.llretptr);\n         } else {\n@@ -5364,7 +5365,7 @@ fn decl_fn_and_pair_full(ccx: @crate_ctxt, sp: span, path: [str], _flav: str,\n     alt ty::struct(ccx.tcx, node_type) {\n       ty::ty_fn(proto, inputs, output, rs, _) {\n         llfty = type_of_fn(ccx, sp, proto, false,\n-                           rs == ast::return_ref, inputs, output,\n+                           ast_util::ret_by_ref(rs), inputs, output,\n                            vec::len(ty_params));\n       }\n       _ { ccx.sess.bug(\"decl_fn_and_pair(): fn item doesn't have fn type!\"); }"}, {"sha": "a74ee6ba9ed63d02f52988c19d4fe38421f66ca9", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7", "patch": "@@ -882,7 +882,7 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n     alt ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.node.id)) {\n       ty::ty_fn(proto, inputs, output, rs, _) {\n         llfnty = type_of_fn(cx.ccx, m.span, proto, true,\n-                            rs == ast::return_ref, inputs, output,\n+                            ast_util::ret_by_ref(rs), inputs, output,\n                             vec::len(ty_params));\n       }\n     }\n@@ -933,7 +933,7 @@ fn populate_self_stack(bcx: @block_ctxt, self_stack: ValueRef,\n \n fn type_of_meth(ccx: @crate_ctxt, sp: span, m: @ty::method,\n                 tps: [ast::ty_param]) -> TypeRef {\n-    type_of_fn(ccx, sp, m.proto, true, m.cf == ast::return_ref,\n+    type_of_fn(ccx, sp, m.proto, true, ast_util::ret_by_ref(m.cf),\n                m.inputs, m.output, vec::len(tps))\n }\n "}, {"sha": "e03a3c80a00457ed154f5f8321fc4a39884f117f", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7", "patch": "@@ -2471,7 +2471,7 @@ fn type_err_to_str(err: ty::type_err) -> str {\n             alt s {\n               ast::noreturn. { \"non-returning\" }\n               ast::return_val. { \"return-by-value\" }\n-              ast::return_ref. { \"return-by-reference\" }\n+              ast::return_ref(_) { \"return-by-reference\" }\n             }\n         }\n         ret to_str(actual) + \" function found where \" + to_str(expect) +"}, {"sha": "f064519cca3526ba9821b4a7164b7338c19d609a", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7", "patch": "@@ -381,7 +381,7 @@ tag ret_style {\n     noreturn; // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n     return_val; // everything else\n-    return_ref;\n+    return_ref(bool);\n }\n \n type _fn = {decl: fn_decl, proto: proto, body: blk};"}, {"sha": "b6c4eb9a9293f0df3ecbd8bf2d4903e171d1c4b0", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7", "patch": "@@ -213,6 +213,13 @@ fn ternary_to_if(e: @expr) -> @expr {\n     }\n }\n \n+fn ret_by_ref(style: ret_style) -> bool {\n+    alt style {\n+      return_ref(_) { true }\n+      _ { false }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "543f2e6538323ec6a98867ba6437c693befbc967", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7", "patch": "@@ -445,7 +445,7 @@ fn parse_ret_ty(p: parser) -> (ast::ret_style, @ast::ty) {\n         } else {\n             let style = ast::return_val;\n             if eat(p, token::BINOP(token::AND)) {\n-                style = ast::return_ref;\n+                style = ast::return_ref(eat(p, token::NOT));\n             };\n             (style, parse_ty(p, false))\n         }"}, {"sha": "92ecceb7ad1effb6e3fbe027a435740473cdc23e", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7", "patch": "@@ -1224,7 +1224,10 @@ fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl, constrs: [@ast::constr]) {\n     if decl.output.node != ast::ty_nil {\n         space_if_not_bol(s);\n         word_space(s, \"->\");\n-        if decl.cf == ast::return_ref { word(s.s, \"&\"); }\n+        alt decl.cf {\n+          ast::return_ref(mut) { word(s.s, mut ? \"&!\" : \"&\"); }\n+          _ {}\n+        }\n         print_type(s, decl.output);\n     }\n }\n@@ -1423,7 +1426,10 @@ fn print_ty_fn(s: ps, proto: ast::proto, id: option::t<ast::ident>,\n         if cf == ast::noreturn {\n             word_nbsp(s, \"!\")\n         } else {\n-            if cf == ast::return_ref { word(s.s, \"&\"); }\n+            alt cf {\n+              ast::return_ref(mut) { word(s.s, mut ? \"&!\" : \"&\"); }\n+              _ {}\n+            }\n             print_type(s, output);\n         }\n         end(s);"}, {"sha": "7e84c08a1d0ea128bc399bab0c25d387c9167bce", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=93de2f0b7498cbc6a304ba3cb80f5a3ea57b8bc7", "patch": "@@ -59,11 +59,13 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         s += \")\";\n         if struct(cx, output) != ty_nil {\n             s += \" -> \";\n-            if cf == ast::noreturn {\n-                s += \"!\";\n-            } else {\n-                if cf == ast::return_ref { s += \"&\"; }\n+            alt cf {\n+              ast::noreturn. { s += \"!\"; }\n+              ast::return_ref(mut) {\n+                s += mut ? \"&!\" : \"&\";\n                 s += ty_to_str(cx, output);\n+              }\n+              ast::return_val. { s += ty_to_str(cx, output); }\n             }\n         }\n         s += constrs_str(constrs);"}]}