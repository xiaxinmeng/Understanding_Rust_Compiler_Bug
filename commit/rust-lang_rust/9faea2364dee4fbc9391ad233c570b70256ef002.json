{"sha": "9faea2364dee4fbc9391ad233c570b70256ef002", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYWVhMjM2NGRlZTRmYmM5MzkxYWQyMzNjNTcwYjcwMjU2ZWYwMDI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-13T15:05:46Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-16T16:42:30Z"}, "message": "Use `dyn Trait` for working with databse\n\nIt improves compile time in `--release` mode quite a bit, it doesn't\nreally slow things down and, conceptually, it seems closer to what we\nwant the physical architecture to look like (we don't want to\nmonomorphise EVERYTHING in a single leaf crate).", "tree": {"sha": "160af959553ce57fdfcbc0a6c79bafcc3611aeea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/160af959553ce57fdfcbc0a6c79bafcc3611aeea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9faea2364dee4fbc9391ad233c570b70256ef002", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9faea2364dee4fbc9391ad233c570b70256ef002", "html_url": "https://github.com/rust-lang/rust/commit/9faea2364dee4fbc9391ad233c570b70256ef002", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9faea2364dee4fbc9391ad233c570b70256ef002/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "648df02953a6ebf87a5876668eceba208687e8a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/648df02953a6ebf87a5876668eceba208687e8a7", "html_url": "https://github.com/rust-lang/rust/commit/648df02953a6ebf87a5876668eceba208687e8a7"}], "stats": {"total": 1607, "additions": 813, "deletions": 794}, "files": [{"sha": "bac24e218603b766270da28ceb1e95045bcfb5fb", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -32,6 +32,10 @@ macro_rules! impl_intern_key {\n     };\n }\n \n+pub trait Upcast<T: ?Sized> {\n+    fn upcast(&self) -> &T;\n+}\n+\n pub trait CheckCanceled {\n     /// Aborts current query if there are pending changes.\n     ///"}, {"sha": "45e31095c5adbdf17787031013691bd97b17da2c", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 163, "deletions": 166, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -33,11 +33,7 @@ use ra_syntax::{\n };\n use rustc_hash::FxHashSet;\n \n-use crate::{\n-    db::{DefDatabase, HirDatabase},\n-    has_source::HasSource,\n-    CallableDef, HirDisplay, InFile, Name,\n-};\n+use crate::{db::HirDatabase, has_source::HasSource, CallableDef, HirDisplay, InFile, Name};\n \n /// hir::Crate describes a single crate. It's the main interface with which\n /// a crate's dependencies interact. Mostly, it should be just a proxy for the\n@@ -54,7 +50,7 @@ pub struct CrateDependency {\n }\n \n impl Crate {\n-    pub fn dependencies(self, db: &impl DefDatabase) -> Vec<CrateDependency> {\n+    pub fn dependencies(self, db: &dyn HirDatabase) -> Vec<CrateDependency> {\n         db.crate_graph()[self.id]\n             .dependencies\n             .iter()\n@@ -67,7 +63,7 @@ impl Crate {\n     }\n \n     // FIXME: add `transitive_reverse_dependencies`.\n-    pub fn reverse_dependencies(self, db: &impl DefDatabase) -> Vec<Crate> {\n+    pub fn reverse_dependencies(self, db: &dyn HirDatabase) -> Vec<Crate> {\n         let crate_graph = db.crate_graph();\n         crate_graph\n             .iter()\n@@ -78,20 +74,20 @@ impl Crate {\n             .collect()\n     }\n \n-    pub fn root_module(self, db: &impl DefDatabase) -> Option<Module> {\n+    pub fn root_module(self, db: &dyn HirDatabase) -> Option<Module> {\n         let module_id = db.crate_def_map(self.id).root;\n         Some(Module::new(self, module_id))\n     }\n \n-    pub fn root_file(self, db: &impl DefDatabase) -> FileId {\n+    pub fn root_file(self, db: &dyn HirDatabase) -> FileId {\n         db.crate_graph()[self.id].root_file_id\n     }\n \n-    pub fn edition(self, db: &impl DefDatabase) -> Edition {\n+    pub fn edition(self, db: &dyn HirDatabase) -> Edition {\n         db.crate_graph()[self.id].edition\n     }\n \n-    pub fn all(db: &impl DefDatabase) -> Vec<Crate> {\n+    pub fn all(db: &dyn HirDatabase) -> Vec<Crate> {\n         db.crate_graph().iter().map(|id| Crate { id }).collect()\n     }\n }\n@@ -128,7 +124,7 @@ impl_froms!(\n );\n \n impl ModuleDef {\n-    pub fn module(self, db: &impl HirDatabase) -> Option<Module> {\n+    pub fn module(self, db: &dyn HirDatabase) -> Option<Module> {\n         match self {\n             ModuleDef::Module(it) => it.parent(db),\n             ModuleDef::Function(it) => Some(it.module(db)),\n@@ -153,7 +149,7 @@ impl Module {\n     }\n \n     /// Name of this module.\n-    pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n         let def_map = db.crate_def_map(self.id.krate);\n         let parent = def_map[self.id.local_id].parent?;\n         def_map[parent].children.iter().find_map(|(name, module_id)| {\n@@ -173,13 +169,13 @@ impl Module {\n     /// Topmost parent of this module. Every module has a `crate_root`, but some\n     /// might be missing `krate`. This can happen if a module's file is not included\n     /// in the module tree of any target in `Cargo.toml`.\n-    pub fn crate_root(self, db: &impl DefDatabase) -> Module {\n+    pub fn crate_root(self, db: &dyn HirDatabase) -> Module {\n         let def_map = db.crate_def_map(self.id.krate);\n         self.with_module_id(def_map.root)\n     }\n \n     /// Iterates over all child modules.\n-    pub fn children(self, db: &impl DefDatabase) -> impl Iterator<Item = Module> {\n+    pub fn children(self, db: &dyn HirDatabase) -> impl Iterator<Item = Module> {\n         let def_map = db.crate_def_map(self.id.krate);\n         let children = def_map[self.id.local_id]\n             .children\n@@ -190,13 +186,13 @@ impl Module {\n     }\n \n     /// Finds a parent module.\n-    pub fn parent(self, db: &impl DefDatabase) -> Option<Module> {\n+    pub fn parent(self, db: &dyn HirDatabase) -> Option<Module> {\n         let def_map = db.crate_def_map(self.id.krate);\n         let parent_id = def_map[self.id.local_id].parent?;\n         Some(self.with_module_id(parent_id))\n     }\n \n-    pub fn path_to_root(self, db: &impl HirDatabase) -> Vec<Module> {\n+    pub fn path_to_root(self, db: &dyn HirDatabase) -> Vec<Module> {\n         let mut res = vec![self];\n         let mut curr = self;\n         while let Some(next) = curr.parent(db) {\n@@ -209,15 +205,16 @@ impl Module {\n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n     pub fn scope(\n         self,\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         visible_from: Option<Module>,\n     ) -> Vec<(Name, ScopeDef)> {\n         db.crate_def_map(self.id.krate)[self.id.local_id]\n             .scope\n             .entries()\n             .filter_map(|(name, def)| {\n                 if let Some(m) = visible_from {\n-                    let filtered = def.filter_visibility(|vis| vis.is_visible_from(db, m.id));\n+                    let filtered =\n+                        def.filter_visibility(|vis| vis.is_visible_from(db.upcast(), m.id));\n                     if filtered.is_none() && !def.is_none() {\n                         None\n                     } else {\n@@ -233,10 +230,10 @@ impl Module {\n             .collect()\n     }\n \n-    pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n+    pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n         let _p = profile(\"Module::diagnostics\");\n         let crate_def_map = db.crate_def_map(self.id.krate);\n-        crate_def_map.add_diagnostics(db, self.id.local_id, sink);\n+        crate_def_map.add_diagnostics(db.upcast(), self.id.local_id, sink);\n         for decl in self.declarations(db) {\n             match decl {\n                 crate::ModuleDef::Function(f) => f.diagnostics(db, sink),\n@@ -259,12 +256,12 @@ impl Module {\n         }\n     }\n \n-    pub fn declarations(self, db: &impl DefDatabase) -> Vec<ModuleDef> {\n+    pub fn declarations(self, db: &dyn HirDatabase) -> Vec<ModuleDef> {\n         let def_map = db.crate_def_map(self.id.krate);\n         def_map[self.id.local_id].scope.declarations().map(ModuleDef::from).collect()\n     }\n \n-    pub fn impl_defs(self, db: &impl DefDatabase) -> Vec<ImplDef> {\n+    pub fn impl_defs(self, db: &dyn HirDatabase) -> Vec<ImplDef> {\n         let def_map = db.crate_def_map(self.id.krate);\n         def_map[self.id.local_id].scope.impls().map(ImplDef::from).collect()\n     }\n@@ -277,11 +274,11 @@ impl Module {\n     /// this module, if possible.\n     pub fn find_use_path(\n         self,\n-        db: &impl DefDatabase,\n+        db: &dyn HirDatabase,\n         item: ModuleDef,\n     ) -> Option<hir_def::path::ModPath> {\n         // FIXME expose namespace choice\n-        hir_def::find_path::find_path(db, determine_item_namespace(item), self.into())\n+        hir_def::find_path::find_path(db.upcast(), determine_item_namespace(item), self.into())\n     }\n }\n \n@@ -307,15 +304,15 @@ pub enum FieldSource {\n }\n \n impl StructField {\n-    pub fn name(&self, db: &impl HirDatabase) -> Name {\n+    pub fn name(&self, db: &dyn HirDatabase) -> Name {\n         self.parent.variant_data(db).fields()[self.id].name.clone()\n     }\n \n     /// Returns the type as in the signature of the struct (i.e., with\n     /// placeholder types for type parameters). This is good for showing\n     /// signature help, but not so good to actually get the type of the field\n     /// when you actually have a variable of the struct.\n-    pub fn signature_ty(&self, db: &impl HirDatabase) -> Type {\n+    pub fn signature_ty(&self, db: &dyn HirDatabase) -> Type {\n         let var_id = self.parent.into();\n         let generic_def_id: GenericDefId = match self.parent {\n             VariantDef::Struct(it) => it.id.into(),\n@@ -327,17 +324,17 @@ impl StructField {\n         Type::new(db, self.parent.module(db).id.krate, var_id, ty)\n     }\n \n-    pub fn parent_def(&self, _db: &impl HirDatabase) -> VariantDef {\n+    pub fn parent_def(&self, _db: &dyn HirDatabase) -> VariantDef {\n         self.parent\n     }\n }\n \n impl HasVisibility for StructField {\n-    fn visibility(&self, db: &impl HirDatabase) -> Visibility {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n         let variant_data = self.parent.variant_data(db);\n         let visibility = &variant_data.fields()[self.id].visibility;\n         let parent_id: hir_def::VariantId = self.parent.into();\n-        visibility.resolve(db, &parent_id.resolver(db))\n+        visibility.resolve(db.upcast(), &parent_id.resolver(db.upcast()))\n     }\n }\n \n@@ -347,19 +344,19 @@ pub struct Struct {\n }\n \n impl Struct {\n-    pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.lookup(db).container.module(db) }\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.lookup(db.upcast()).container.module(db.upcast()) }\n     }\n \n-    pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n+    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n         Some(self.module(db).krate())\n     }\n \n-    pub fn name(self, db: &impl DefDatabase) -> Name {\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n         db.struct_data(self.id).name.clone()\n     }\n \n-    pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n+    pub fn fields(self, db: &dyn HirDatabase) -> Vec<StructField> {\n         db.struct_data(self.id)\n             .variant_data\n             .fields()\n@@ -368,11 +365,11 @@ impl Struct {\n             .collect()\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Type {\n-        Type::from_def(db, self.id.lookup(db).container.module(db).krate, self.id)\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::from_def(db, self.id.lookup(db.upcast()).container.module(db.upcast()).krate, self.id)\n     }\n \n-    fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n+    fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n         db.struct_data(self.id).variant_data.clone()\n     }\n }\n@@ -383,19 +380,19 @@ pub struct Union {\n }\n \n impl Union {\n-    pub fn name(self, db: &impl DefDatabase) -> Name {\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n         db.union_data(self.id).name.clone()\n     }\n \n-    pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.lookup(db).container.module(db) }\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.lookup(db.upcast()).container.module(db.upcast()) }\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Type {\n-        Type::from_def(db, self.id.lookup(db).container.module(db).krate, self.id)\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::from_def(db, self.id.lookup(db.upcast()).container.module(db.upcast()).krate, self.id)\n     }\n \n-    pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n+    pub fn fields(self, db: &dyn HirDatabase) -> Vec<StructField> {\n         db.union_data(self.id)\n             .variant_data\n             .fields()\n@@ -404,7 +401,7 @@ impl Union {\n             .collect()\n     }\n \n-    fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n+    fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n         db.union_data(self.id).variant_data.clone()\n     }\n }\n@@ -415,28 +412,28 @@ pub struct Enum {\n }\n \n impl Enum {\n-    pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.lookup(db).container.module(db) }\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.lookup(db.upcast()).container.module(db.upcast()) }\n     }\n \n-    pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n+    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n         Some(self.module(db).krate())\n     }\n \n-    pub fn name(self, db: &impl DefDatabase) -> Name {\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n         db.enum_data(self.id).name.clone()\n     }\n \n-    pub fn variants(self, db: &impl DefDatabase) -> Vec<EnumVariant> {\n+    pub fn variants(self, db: &dyn HirDatabase) -> Vec<EnumVariant> {\n         db.enum_data(self.id)\n             .variants\n             .iter()\n             .map(|(id, _)| EnumVariant { parent: self, id })\n             .collect()\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Type {\n-        Type::from_def(db, self.id.lookup(db).container.module(db).krate, self.id)\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::from_def(db, self.id.lookup(db.upcast()).container.module(db.upcast()).krate, self.id)\n     }\n }\n \n@@ -447,30 +444,30 @@ pub struct EnumVariant {\n }\n \n impl EnumVariant {\n-    pub fn module(self, db: &impl HirDatabase) -> Module {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n         self.parent.module(db)\n     }\n-    pub fn parent_enum(self, _db: &impl DefDatabase) -> Enum {\n+    pub fn parent_enum(self, _db: &dyn HirDatabase) -> Enum {\n         self.parent\n     }\n \n-    pub fn name(self, db: &impl DefDatabase) -> Name {\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n         db.enum_data(self.parent.id).variants[self.id].name.clone()\n     }\n \n-    pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n+    pub fn fields(self, db: &dyn HirDatabase) -> Vec<StructField> {\n         self.variant_data(db)\n             .fields()\n             .iter()\n             .map(|(id, _)| StructField { parent: self.into(), id })\n             .collect()\n     }\n \n-    pub fn kind(self, db: &impl HirDatabase) -> StructKind {\n+    pub fn kind(self, db: &dyn HirDatabase) -> StructKind {\n         self.variant_data(db).kind()\n     }\n \n-    pub(crate) fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n+    pub(crate) fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n         db.enum_data(self.parent.id).variants[self.id].variant_data.clone()\n     }\n }\n@@ -485,32 +482,32 @@ pub enum Adt {\n impl_froms!(Adt: Struct, Union, Enum);\n \n impl Adt {\n-    pub fn has_non_default_type_params(self, db: &impl HirDatabase) -> bool {\n+    pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {\n         let subst = db.generic_defaults(self.into());\n         subst.iter().any(|ty| ty == &Ty::Unknown)\n     }\n \n     /// Turns this ADT into a type. Any type parameters of the ADT will be\n     /// turned into unknown types, which is good for e.g. finding the most\n     /// general set of completions, but will not look very nice when printed.\n-    pub fn ty(self, db: &impl HirDatabase) -> Type {\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n         let id = AdtId::from(self);\n-        Type::from_def(db, id.module(db).krate, id)\n+        Type::from_def(db, id.module(db.upcast()).krate, id)\n     }\n \n-    pub fn module(self, db: &impl DefDatabase) -> Module {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n         match self {\n             Adt::Struct(s) => s.module(db),\n             Adt::Union(s) => s.module(db),\n             Adt::Enum(e) => e.module(db),\n         }\n     }\n \n-    pub fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n+    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n         Some(self.module(db).krate())\n     }\n \n-    pub fn name(&self, db: &impl HirDatabase) -> Name {\n+    pub fn name(&self, db: &dyn HirDatabase) -> Name {\n         match self {\n             Adt::Struct(s) => s.name(db),\n             Adt::Union(u) => u.name(db),\n@@ -528,31 +525,31 @@ pub enum VariantDef {\n impl_froms!(VariantDef: Struct, Union, EnumVariant);\n \n impl VariantDef {\n-    pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n+    pub fn fields(self, db: &dyn HirDatabase) -> Vec<StructField> {\n         match self {\n             VariantDef::Struct(it) => it.fields(db),\n             VariantDef::Union(it) => it.fields(db),\n             VariantDef::EnumVariant(it) => it.fields(db),\n         }\n     }\n \n-    pub fn module(self, db: &impl HirDatabase) -> Module {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n         match self {\n             VariantDef::Struct(it) => it.module(db),\n             VariantDef::Union(it) => it.module(db),\n             VariantDef::EnumVariant(it) => it.module(db),\n         }\n     }\n \n-    pub fn name(&self, db: &impl HirDatabase) -> Name {\n+    pub fn name(&self, db: &dyn HirDatabase) -> Name {\n         match self {\n             VariantDef::Struct(s) => s.name(db),\n             VariantDef::Union(u) => u.name(db),\n             VariantDef::EnumVariant(e) => e.name(db),\n         }\n     }\n \n-    pub(crate) fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n+    pub(crate) fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n         match self {\n             VariantDef::Struct(it) => it.variant_data(db),\n             VariantDef::Union(it) => it.variant_data(db),\n@@ -572,15 +569,15 @@ pub enum DefWithBody {\n impl_froms!(DefWithBody: Function, Const, Static);\n \n impl DefWithBody {\n-    pub fn module(self, db: &impl HirDatabase) -> Module {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n         match self {\n             DefWithBody::Const(c) => c.module(db),\n             DefWithBody::Function(f) => f.module(db),\n             DefWithBody::Static(s) => s.module(db),\n         }\n     }\n \n-    pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n         match self {\n             DefWithBody::Function(f) => Some(f.name(db)),\n             DefWithBody::Static(s) => s.name(db),\n@@ -595,27 +592,27 @@ pub struct Function {\n }\n \n impl Function {\n-    pub fn module(self, db: &impl DefDatabase) -> Module {\n-        self.id.lookup(db).module(db).into()\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        self.id.lookup(db.upcast()).module(db.upcast()).into()\n     }\n \n-    pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n+    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n         Some(self.module(db).krate())\n     }\n \n-    pub fn name(self, db: &impl HirDatabase) -> Name {\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n         db.function_data(self.id).name.clone()\n     }\n \n-    pub fn has_self_param(self, db: &impl HirDatabase) -> bool {\n+    pub fn has_self_param(self, db: &dyn HirDatabase) -> bool {\n         db.function_data(self.id).has_self_param\n     }\n \n-    pub fn params(self, db: &impl HirDatabase) -> Vec<TypeRef> {\n+    pub fn params(self, db: &dyn HirDatabase) -> Vec<TypeRef> {\n         db.function_data(self.id).params.clone()\n     }\n \n-    pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n+    pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n         let _p = profile(\"Function::diagnostics\");\n         let infer = db.infer(self.id.into());\n         infer.add_diagnostics(db, self.id, sink);\n@@ -625,10 +622,10 @@ impl Function {\n }\n \n impl HasVisibility for Function {\n-    fn visibility(&self, db: &impl HirDatabase) -> Visibility {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n         let function_data = db.function_data(self.id);\n         let visibility = &function_data.visibility;\n-        visibility.resolve(db, &self.id.resolver(db))\n+        visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n     }\n }\n \n@@ -638,24 +635,24 @@ pub struct Const {\n }\n \n impl Const {\n-    pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.lookup(db).module(db) }\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.lookup(db.upcast()).module(db.upcast()) }\n     }\n \n-    pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n+    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n         Some(self.module(db).krate())\n     }\n \n-    pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n         db.const_data(self.id).name.clone()\n     }\n }\n \n impl HasVisibility for Const {\n-    fn visibility(&self, db: &impl HirDatabase) -> Visibility {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n         let function_data = db.const_data(self.id);\n         let visibility = &function_data.visibility;\n-        visibility.resolve(db, &self.id.resolver(db))\n+        visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n     }\n }\n \n@@ -665,15 +662,15 @@ pub struct Static {\n }\n \n impl Static {\n-    pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.lookup(db).module(db) }\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.lookup(db.upcast()).module(db.upcast()) }\n     }\n \n-    pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n+    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n         Some(self.module(db).krate())\n     }\n \n-    pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n         db.static_data(self.id).name.clone()\n     }\n }\n@@ -684,19 +681,19 @@ pub struct Trait {\n }\n \n impl Trait {\n-    pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.lookup(db).container.module(db) }\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.lookup(db.upcast()).container.module(db.upcast()) }\n     }\n \n-    pub fn name(self, db: &impl DefDatabase) -> Name {\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n         db.trait_data(self.id).name.clone()\n     }\n \n-    pub fn items(self, db: &impl DefDatabase) -> Vec<AssocItem> {\n+    pub fn items(self, db: &dyn HirDatabase) -> Vec<AssocItem> {\n         db.trait_data(self.id).items.iter().map(|(_name, it)| (*it).into()).collect()\n     }\n \n-    pub fn is_auto(self, db: &impl DefDatabase) -> bool {\n+    pub fn is_auto(self, db: &dyn HirDatabase) -> bool {\n         db.trait_data(self.id).auto\n     }\n }\n@@ -707,37 +704,37 @@ pub struct TypeAlias {\n }\n \n impl TypeAlias {\n-    pub fn has_non_default_type_params(self, db: &impl HirDatabase) -> bool {\n+    pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {\n         let subst = db.generic_defaults(self.id.into());\n         subst.iter().any(|ty| ty == &Ty::Unknown)\n     }\n \n-    pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.lookup(db).module(db) }\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.lookup(db.upcast()).module(db.upcast()) }\n     }\n \n-    pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n+    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n         Some(self.module(db).krate())\n     }\n \n-    pub fn type_ref(self, db: &impl DefDatabase) -> Option<TypeRef> {\n+    pub fn type_ref(self, db: &dyn HirDatabase) -> Option<TypeRef> {\n         db.type_alias_data(self.id).type_ref.clone()\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Type {\n-        Type::from_def(db, self.id.lookup(db).module(db).krate, self.id)\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::from_def(db, self.id.lookup(db.upcast()).module(db.upcast()).krate, self.id)\n     }\n \n-    pub fn name(self, db: &impl DefDatabase) -> Name {\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n         db.type_alias_data(self.id).name.clone()\n     }\n }\n \n impl HasVisibility for TypeAlias {\n-    fn visibility(&self, db: &impl HirDatabase) -> Visibility {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n         let function_data = db.type_alias_data(self.id);\n         let visibility = &function_data.visibility;\n-        visibility.resolve(db, &self.id.resolver(db))\n+        visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n     }\n }\n \n@@ -750,14 +747,14 @@ impl MacroDef {\n     /// FIXME: right now, this just returns the root module of the crate that\n     /// defines this macro. The reasons for this is that macros are expanded\n     /// early, in `ra_hir_expand`, where modules simply do not exist yet.\n-    pub fn module(self, db: &impl HirDatabase) -> Option<Module> {\n+    pub fn module(self, db: &dyn HirDatabase) -> Option<Module> {\n         let krate = self.id.krate?;\n         let module_id = db.crate_def_map(krate).root;\n         Some(Module::new(Crate { id: krate }, module_id))\n     }\n \n     /// XXX: this parses the file\n-    pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n         self.source(db).value.name().map(|it| it.as_name())\n     }\n }\n@@ -775,50 +772,50 @@ pub enum AssocItemContainer {\n     ImplDef(ImplDef),\n }\n pub trait AsAssocItem {\n-    fn as_assoc_item(self, db: &impl DefDatabase) -> Option<AssocItem>;\n+    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem>;\n }\n \n impl AsAssocItem for Function {\n-    fn as_assoc_item(self, db: &impl DefDatabase) -> Option<AssocItem> {\n+    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {\n         as_assoc_item(db, AssocItem::Function, self.id)\n     }\n }\n impl AsAssocItem for Const {\n-    fn as_assoc_item(self, db: &impl DefDatabase) -> Option<AssocItem> {\n+    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {\n         as_assoc_item(db, AssocItem::Const, self.id)\n     }\n }\n impl AsAssocItem for TypeAlias {\n-    fn as_assoc_item(self, db: &impl DefDatabase) -> Option<AssocItem> {\n+    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {\n         as_assoc_item(db, AssocItem::TypeAlias, self.id)\n     }\n }\n-fn as_assoc_item<ID, DEF, CTOR, AST>(db: &impl DefDatabase, ctor: CTOR, id: ID) -> Option<AssocItem>\n+fn as_assoc_item<ID, DEF, CTOR, AST>(db: &dyn HirDatabase, ctor: CTOR, id: ID) -> Option<AssocItem>\n where\n     ID: Lookup<Data = AssocItemLoc<AST>>,\n     DEF: From<ID>,\n     CTOR: FnOnce(DEF) -> AssocItem,\n     AST: AstNode,\n {\n-    match id.lookup(db).container {\n+    match id.lookup(db.upcast()).container {\n         AssocContainerId::TraitId(_) | AssocContainerId::ImplId(_) => Some(ctor(DEF::from(id))),\n         AssocContainerId::ContainerId(_) => None,\n     }\n }\n \n impl AssocItem {\n-    pub fn module(self, db: &impl DefDatabase) -> Module {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n         match self {\n             AssocItem::Function(f) => f.module(db),\n             AssocItem::Const(c) => c.module(db),\n             AssocItem::TypeAlias(t) => t.module(db),\n         }\n     }\n-    pub fn container(self, db: &impl DefDatabase) -> AssocItemContainer {\n+    pub fn container(self, db: &dyn HirDatabase) -> AssocItemContainer {\n         let container = match self {\n-            AssocItem::Function(it) => it.id.lookup(db).container,\n-            AssocItem::Const(it) => it.id.lookup(db).container,\n-            AssocItem::TypeAlias(it) => it.id.lookup(db).container,\n+            AssocItem::Function(it) => it.id.lookup(db.upcast()).container,\n+            AssocItem::Const(it) => it.id.lookup(db.upcast()).container,\n+            AssocItem::TypeAlias(it) => it.id.lookup(db.upcast()).container,\n         };\n         match container {\n             AssocContainerId::TraitId(id) => AssocItemContainer::Trait(id.into()),\n@@ -829,7 +826,7 @@ impl AssocItem {\n }\n \n impl HasVisibility for AssocItem {\n-    fn visibility(&self, db: &impl HirDatabase) -> Visibility {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n         match self {\n             AssocItem::Function(f) => f.visibility(db),\n             AssocItem::Const(c) => c.visibility(db),\n@@ -862,7 +859,7 @@ impl_froms!(\n );\n \n impl GenericDef {\n-    pub fn params(self, db: &impl HirDatabase) -> Vec<TypeParam> {\n+    pub fn params(self, db: &dyn HirDatabase) -> Vec<TypeParam> {\n         let generics: Arc<hir_def::generics::GenericParams> = db.generic_params(self.into());\n         generics\n             .types\n@@ -880,19 +877,19 @@ pub struct Local {\n \n impl Local {\n     // FIXME: why is this an option? It shouldn't be?\n-    pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n         let body = db.body(self.parent.into());\n         match &body[self.pat_id] {\n             Pat::Bind { name, .. } => Some(name.clone()),\n             _ => None,\n         }\n     }\n \n-    pub fn is_self(self, db: &impl HirDatabase) -> bool {\n+    pub fn is_self(self, db: &dyn HirDatabase) -> bool {\n         self.name(db) == Some(name![self])\n     }\n \n-    pub fn is_mut(self, db: &impl HirDatabase) -> bool {\n+    pub fn is_mut(self, db: &dyn HirDatabase) -> bool {\n         let body = db.body(self.parent.into());\n         match &body[self.pat_id] {\n             Pat::Bind { mode, .. } => match mode {\n@@ -903,28 +900,28 @@ impl Local {\n         }\n     }\n \n-    pub fn parent(self, _db: &impl HirDatabase) -> DefWithBody {\n+    pub fn parent(self, _db: &dyn HirDatabase) -> DefWithBody {\n         self.parent.into()\n     }\n \n-    pub fn module(self, db: &impl HirDatabase) -> Module {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n         self.parent(db).module(db)\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Type {\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n         let def = DefWithBodyId::from(self.parent);\n         let infer = db.infer(def);\n         let ty = infer[self.pat_id].clone();\n-        let resolver = def.resolver(db);\n-        let krate = def.module(db).krate;\n+        let resolver = def.resolver(db.upcast());\n+        let krate = def.module(db.upcast()).krate;\n         let environment = TraitEnvironment::lower(db, &resolver);\n         Type { krate, ty: InEnvironment { value: ty, environment } }\n     }\n \n-    pub fn source(self, db: &impl HirDatabase) -> InFile<Either<ast::BindPat, ast::SelfParam>> {\n+    pub fn source(self, db: &dyn HirDatabase) -> InFile<Either<ast::BindPat, ast::SelfParam>> {\n         let (_body, source_map) = db.body_with_source_map(self.parent.into());\n         let src = source_map.pat_syntax(self.pat_id).unwrap(); // Hmm...\n-        let root = src.file_syntax(db);\n+        let root = src.file_syntax(db.upcast());\n         src.map(|ast| {\n             ast.map_left(|it| it.cast().unwrap().to_node(&root)).map_right(|it| it.to_node(&root))\n         })\n@@ -937,13 +934,13 @@ pub struct TypeParam {\n }\n \n impl TypeParam {\n-    pub fn name(self, db: &impl HirDatabase) -> Name {\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n         let params = db.generic_params(self.id.parent);\n         params.types[self.id.local_id].name.clone().unwrap_or_else(Name::missing)\n     }\n \n-    pub fn module(self, db: &impl HirDatabase) -> Module {\n-        self.id.parent.module(db).into()\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        self.id.parent.module(db.upcast()).into()\n     }\n }\n \n@@ -954,55 +951,55 @@ pub struct ImplDef {\n }\n \n impl ImplDef {\n-    pub fn all_in_crate(db: &impl HirDatabase, krate: Crate) -> Vec<ImplDef> {\n+    pub fn all_in_crate(db: &dyn HirDatabase, krate: Crate) -> Vec<ImplDef> {\n         let impls = db.impls_in_crate(krate.id);\n         impls.all_impls().map(Self::from).collect()\n     }\n-    pub fn for_trait(db: &impl HirDatabase, krate: Crate, trait_: Trait) -> Vec<ImplDef> {\n+    pub fn for_trait(db: &dyn HirDatabase, krate: Crate, trait_: Trait) -> Vec<ImplDef> {\n         let impls = db.impls_in_crate(krate.id);\n         impls.lookup_impl_defs_for_trait(trait_.id).map(Self::from).collect()\n     }\n \n-    pub fn target_trait(&self, db: &impl DefDatabase) -> Option<TypeRef> {\n+    pub fn target_trait(&self, db: &dyn HirDatabase) -> Option<TypeRef> {\n         db.impl_data(self.id).target_trait.clone()\n     }\n \n-    pub fn target_type(&self, db: &impl DefDatabase) -> TypeRef {\n+    pub fn target_type(&self, db: &dyn HirDatabase) -> TypeRef {\n         db.impl_data(self.id).target_type.clone()\n     }\n \n-    pub fn target_ty(&self, db: &impl HirDatabase) -> Type {\n+    pub fn target_ty(&self, db: &dyn HirDatabase) -> Type {\n         let impl_data = db.impl_data(self.id);\n-        let resolver = self.id.resolver(db);\n+        let resolver = self.id.resolver(db.upcast());\n         let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n         let environment = TraitEnvironment::lower(db, &resolver);\n         let ty = Ty::from_hir(&ctx, &impl_data.target_type);\n         Type {\n-            krate: self.id.lookup(db).container.module(db).krate,\n+            krate: self.id.lookup(db.upcast()).container.module(db.upcast()).krate,\n             ty: InEnvironment { value: ty, environment },\n         }\n     }\n \n-    pub fn items(&self, db: &impl DefDatabase) -> Vec<AssocItem> {\n+    pub fn items(&self, db: &dyn HirDatabase) -> Vec<AssocItem> {\n         db.impl_data(self.id).items.iter().map(|it| (*it).into()).collect()\n     }\n \n-    pub fn is_negative(&self, db: &impl DefDatabase) -> bool {\n+    pub fn is_negative(&self, db: &dyn HirDatabase) -> bool {\n         db.impl_data(self.id).is_negative\n     }\n \n-    pub fn module(&self, db: &impl DefDatabase) -> Module {\n-        self.id.lookup(db).container.module(db).into()\n+    pub fn module(&self, db: &dyn HirDatabase) -> Module {\n+        self.id.lookup(db.upcast()).container.module(db.upcast()).into()\n     }\n \n-    pub fn krate(&self, db: &impl DefDatabase) -> Crate {\n+    pub fn krate(&self, db: &dyn HirDatabase) -> Crate {\n         Crate { id: self.module(db).id.krate }\n     }\n \n-    pub fn is_builtin_derive(&self, db: &impl DefDatabase) -> Option<InFile<ast::Attr>> {\n+    pub fn is_builtin_derive(&self, db: &dyn HirDatabase) -> Option<InFile<ast::Attr>> {\n         let src = self.source(db);\n-        let item = src.file_id.is_builtin_derive(db)?;\n-        let hygenic = hir_expand::hygiene::Hygiene::new(db, item.file_id);\n+        let item = src.file_id.is_builtin_derive(db.upcast())?;\n+        let hygenic = hir_expand::hygiene::Hygiene::new(db.upcast(), item.file_id);\n \n         let attr = item\n             .value\n@@ -1028,14 +1025,14 @@ pub struct Type {\n }\n \n impl Type {\n-    fn new(db: &impl HirDatabase, krate: CrateId, lexical_env: impl HasResolver, ty: Ty) -> Type {\n-        let resolver = lexical_env.resolver(db);\n+    fn new(db: &dyn HirDatabase, krate: CrateId, lexical_env: impl HasResolver, ty: Ty) -> Type {\n+        let resolver = lexical_env.resolver(db.upcast());\n         let environment = TraitEnvironment::lower(db, &resolver);\n         Type { krate, ty: InEnvironment { value: ty, environment } }\n     }\n \n     fn from_def(\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         krate: CrateId,\n         def: impl HasResolver + Into<TyDefId> + Into<GenericDefId>,\n     ) -> Type {\n@@ -1073,7 +1070,7 @@ impl Type {\n \n     /// Checks that particular type `ty` implements `std::future::Future`.\n     /// This function is used in `.await` syntax completion.\n-    pub fn impls_future(&self, db: &impl HirDatabase) -> bool {\n+    pub fn impls_future(&self, db: &dyn HirDatabase) -> bool {\n         let krate = self.krate;\n \n         let std_future_trait =\n@@ -1110,7 +1107,7 @@ impl Type {\n         }\n     }\n \n-    pub fn fields(&self, db: &impl HirDatabase) -> Vec<(StructField, Type)> {\n+    pub fn fields(&self, db: &dyn HirDatabase) -> Vec<(StructField, Type)> {\n         if let Ty::Apply(a_ty) = &self.ty.value {\n             if let TypeCtor::Adt(AdtId::StructId(s)) = a_ty.ctor {\n                 let var_def = s.into();\n@@ -1128,7 +1125,7 @@ impl Type {\n         Vec::new()\n     }\n \n-    pub fn tuple_fields(&self, _db: &impl HirDatabase) -> Vec<Type> {\n+    pub fn tuple_fields(&self, _db: &dyn HirDatabase) -> Vec<Type> {\n         let mut res = Vec::new();\n         if let Ty::Apply(a_ty) = &self.ty.value {\n             if let TypeCtor::Tuple { .. } = a_ty.ctor {\n@@ -1143,7 +1140,7 @@ impl Type {\n \n     pub fn variant_fields(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         def: VariantDef,\n     ) -> Vec<(StructField, Type)> {\n         // FIXME: check that ty and def match\n@@ -1162,7 +1159,7 @@ impl Type {\n         }\n     }\n \n-    pub fn autoderef<'a>(&'a self, db: &'a impl HirDatabase) -> impl Iterator<Item = Type> + 'a {\n+    pub fn autoderef<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Type> + 'a {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         let canonical = Canonical { value: self.ty.value.clone(), num_vars: 0 };\n@@ -1177,7 +1174,7 @@ impl Type {\n     // lifetime problems, because we need to borrow temp `CrateImplDefs`.\n     pub fn iterate_impl_items<T>(\n         self,\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         krate: Crate,\n         mut callback: impl FnMut(AssocItem) -> Option<T>,\n     ) -> Option<T> {\n@@ -1197,7 +1194,7 @@ impl Type {\n \n     pub fn iterate_method_candidates<T>(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         krate: Crate,\n         traits_in_scope: &FxHashSet<TraitId>,\n         name: Option<&Name>,\n@@ -1228,7 +1225,7 @@ impl Type {\n \n     pub fn iterate_path_candidates<T>(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         krate: Crate,\n         traits_in_scope: &FxHashSet<TraitId>,\n         name: Option<&Name>,\n@@ -1283,7 +1280,7 @@ impl Type {\n }\n \n impl HirDisplay for Type {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> std::fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> std::fmt::Result {\n         self.ty.value.hir_fmt(f)\n     }\n }\n@@ -1360,30 +1357,30 @@ impl_froms!(\n );\n \n pub trait HasAttrs {\n-    fn attrs(self, db: &impl DefDatabase) -> Attrs;\n+    fn attrs(self, db: &dyn HirDatabase) -> Attrs;\n }\n \n impl<T: Into<AttrDef>> HasAttrs for T {\n-    fn attrs(self, db: &impl DefDatabase) -> Attrs {\n+    fn attrs(self, db: &dyn HirDatabase) -> Attrs {\n         let def: AttrDef = self.into();\n         db.attrs(def.into())\n     }\n }\n \n pub trait Docs {\n-    fn docs(&self, db: &impl HirDatabase) -> Option<Documentation>;\n+    fn docs(&self, db: &dyn HirDatabase) -> Option<Documentation>;\n }\n impl<T: Into<AttrDef> + Copy> Docs for T {\n-    fn docs(&self, db: &impl HirDatabase) -> Option<Documentation> {\n+    fn docs(&self, db: &dyn HirDatabase) -> Option<Documentation> {\n         let def: AttrDef = (*self).into();\n         db.documentation(def.into())\n     }\n }\n \n pub trait HasVisibility {\n-    fn visibility(&self, db: &impl HirDatabase) -> Visibility;\n-    fn is_visible_from(&self, db: &impl HirDatabase, module: Module) -> bool {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility;\n+    fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {\n         let vis = self.visibility(db);\n-        vis.is_visible_from(db, module.id)\n+        vis.is_visible_from(db.upcast(), module.id)\n     }\n }"}, {"sha": "129764e0ae08d3f3438eec1a1902a098d69c7b9b", "filename": "crates/ra_hir/src/has_source.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fhas_source.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -9,39 +9,39 @@ use hir_def::{\n use ra_syntax::ast;\n \n use crate::{\n-    db::DefDatabase, Const, Enum, EnumVariant, FieldSource, Function, ImplDef, MacroDef, Module,\n+    db::HirDatabase, Const, Enum, EnumVariant, FieldSource, Function, ImplDef, MacroDef, Module,\n     Static, Struct, StructField, Trait, TypeAlias, TypeParam, Union,\n };\n \n pub use hir_expand::InFile;\n \n pub trait HasSource {\n     type Ast;\n-    fn source(self, db: &impl DefDatabase) -> InFile<Self::Ast>;\n+    fn source(self, db: &dyn HirDatabase) -> InFile<Self::Ast>;\n }\n \n /// NB: Module is !HasSource, because it has two source nodes at the same time:\n /// definition and declaration.\n impl Module {\n     /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n-    pub fn definition_source(self, db: &impl DefDatabase) -> InFile<ModuleSource> {\n+    pub fn definition_source(self, db: &dyn HirDatabase) -> InFile<ModuleSource> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        def_map[self.id.local_id].definition_source(db)\n+        def_map[self.id.local_id].definition_source(db.upcast())\n     }\n \n     /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n     /// `None` for the crate root.\n-    pub fn declaration_source(self, db: &impl DefDatabase) -> Option<InFile<ast::Module>> {\n+    pub fn declaration_source(self, db: &dyn HirDatabase) -> Option<InFile<ast::Module>> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        def_map[self.id.local_id].declaration_source(db)\n+        def_map[self.id.local_id].declaration_source(db.upcast())\n     }\n }\n \n impl HasSource for StructField {\n     type Ast = FieldSource;\n-    fn source(self, db: &impl DefDatabase) -> InFile<FieldSource> {\n+    fn source(self, db: &dyn HirDatabase) -> InFile<FieldSource> {\n         let var = VariantId::from(self.parent);\n-        let src = var.child_source(db);\n+        let src = var.child_source(db.upcast());\n         src.map(|it| match it[self.id].clone() {\n             Either::Left(it) => FieldSource::Pos(it),\n             Either::Right(it) => FieldSource::Named(it),\n@@ -50,78 +50,78 @@ impl HasSource for StructField {\n }\n impl HasSource for Struct {\n     type Ast = ast::StructDef;\n-    fn source(self, db: &impl DefDatabase) -> InFile<ast::StructDef> {\n-        self.id.lookup(db).source(db)\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::StructDef> {\n+        self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n impl HasSource for Union {\n     type Ast = ast::UnionDef;\n-    fn source(self, db: &impl DefDatabase) -> InFile<ast::UnionDef> {\n-        self.id.lookup(db).source(db)\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::UnionDef> {\n+        self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n impl HasSource for Enum {\n     type Ast = ast::EnumDef;\n-    fn source(self, db: &impl DefDatabase) -> InFile<ast::EnumDef> {\n-        self.id.lookup(db).source(db)\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::EnumDef> {\n+        self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n impl HasSource for EnumVariant {\n     type Ast = ast::EnumVariant;\n-    fn source(self, db: &impl DefDatabase) -> InFile<ast::EnumVariant> {\n-        self.parent.id.child_source(db).map(|map| map[self.id].clone())\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::EnumVariant> {\n+        self.parent.id.child_source(db.upcast()).map(|map| map[self.id].clone())\n     }\n }\n impl HasSource for Function {\n     type Ast = ast::FnDef;\n-    fn source(self, db: &impl DefDatabase) -> InFile<ast::FnDef> {\n-        self.id.lookup(db).source(db)\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::FnDef> {\n+        self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n impl HasSource for Const {\n     type Ast = ast::ConstDef;\n-    fn source(self, db: &impl DefDatabase) -> InFile<ast::ConstDef> {\n-        self.id.lookup(db).source(db)\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::ConstDef> {\n+        self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n impl HasSource for Static {\n     type Ast = ast::StaticDef;\n-    fn source(self, db: &impl DefDatabase) -> InFile<ast::StaticDef> {\n-        self.id.lookup(db).source(db)\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::StaticDef> {\n+        self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n impl HasSource for Trait {\n     type Ast = ast::TraitDef;\n-    fn source(self, db: &impl DefDatabase) -> InFile<ast::TraitDef> {\n-        self.id.lookup(db).source(db)\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::TraitDef> {\n+        self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n impl HasSource for TypeAlias {\n     type Ast = ast::TypeAliasDef;\n-    fn source(self, db: &impl DefDatabase) -> InFile<ast::TypeAliasDef> {\n-        self.id.lookup(db).source(db)\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::TypeAliasDef> {\n+        self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n impl HasSource for MacroDef {\n     type Ast = ast::MacroCall;\n-    fn source(self, db: &impl DefDatabase) -> InFile<ast::MacroCall> {\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::MacroCall> {\n         InFile {\n             file_id: self.id.ast_id.expect(\"MacroDef without ast_id\").file_id,\n-            value: self.id.ast_id.expect(\"MacroDef without ast_id\").to_node(db),\n+            value: self.id.ast_id.expect(\"MacroDef without ast_id\").to_node(db.upcast()),\n         }\n     }\n }\n impl HasSource for ImplDef {\n     type Ast = ast::ImplDef;\n-    fn source(self, db: &impl DefDatabase) -> InFile<ast::ImplDef> {\n-        self.id.lookup(db).source(db)\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::ImplDef> {\n+        self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n \n impl HasSource for TypeParam {\n     type Ast = Either<ast::TraitDef, ast::TypeParam>;\n-    fn source(self, db: &impl DefDatabase) -> InFile<Self::Ast> {\n-        let child_source = self.id.parent.child_source(db);\n+    fn source(self, db: &dyn HirDatabase) -> InFile<Self::Ast> {\n+        let child_source = self.id.parent.child_source(db.upcast());\n         child_source.map(|it| it[self.id.local_id].clone())\n     }\n }"}, {"sha": "55e634528903d2c6339a1bec984dd835c181e787", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -190,7 +190,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         T::to_def(self, src)\n     }\n \n-    fn with_ctx<F: FnOnce(&mut SourceToDefCtx<&DB>) -> T, T>(&self, f: F) -> T {\n+    fn with_ctx<F: FnOnce(&mut SourceToDefCtx) -> T, T>(&self, f: F) -> T {\n         let mut cache = self.s2d_cache.borrow_mut();\n         let mut ctx = SourceToDefCtx { db: self.db, cache: &mut *cache };\n         f(&mut ctx)\n@@ -369,35 +369,35 @@ impl<'a, DB: HirDatabase> SemanticsScope<'a, DB> {\n }\n \n // FIXME: Change `HasSource` trait to work with `Semantics` and remove this?\n-pub fn original_range(db: &impl HirDatabase, node: InFile<&SyntaxNode>) -> FileRange {\n+pub fn original_range(db: &dyn HirDatabase, node: InFile<&SyntaxNode>) -> FileRange {\n     if let Some(range) = original_range_opt(db, node) {\n-        let original_file = range.file_id.original_file(db);\n+        let original_file = range.file_id.original_file(db.upcast());\n         if range.file_id == original_file.into() {\n             return FileRange { file_id: original_file, range: range.value };\n         }\n \n         log::error!(\"Fail to mapping up more for {:?}\", range);\n-        return FileRange { file_id: range.file_id.original_file(db), range: range.value };\n+        return FileRange { file_id: range.file_id.original_file(db.upcast()), range: range.value };\n     }\n \n     // Fall back to whole macro call\n-    if let Some(expansion) = node.file_id.expansion_info(db) {\n+    if let Some(expansion) = node.file_id.expansion_info(db.upcast()) {\n         if let Some(call_node) = expansion.call_node() {\n             return FileRange {\n-                file_id: call_node.file_id.original_file(db),\n+                file_id: call_node.file_id.original_file(db.upcast()),\n                 range: call_node.value.text_range(),\n             };\n         }\n     }\n \n-    FileRange { file_id: node.file_id.original_file(db), range: node.value.text_range() }\n+    FileRange { file_id: node.file_id.original_file(db.upcast()), range: node.value.text_range() }\n }\n \n fn original_range_opt(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     node: InFile<&SyntaxNode>,\n ) -> Option<InFile<TextRange>> {\n-    let expansion = node.file_id.expansion_info(db)?;\n+    let expansion = node.file_id.expansion_info(db.upcast())?;\n \n     // the input node has only one token ?\n     let single = skip_trivia_token(node.value.first_token()?, Direction::Next)?\n@@ -419,15 +419,15 @@ fn original_range_opt(\n }\n \n fn ascend_call_token(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     expansion: &ExpansionInfo,\n     token: InFile<SyntaxToken>,\n ) -> Option<InFile<SyntaxToken>> {\n     let (mapped, origin) = expansion.map_token_up(token.as_ref())?;\n     if origin != Origin::Call {\n         return None;\n     }\n-    if let Some(info) = mapped.file_id.expansion_info(db) {\n+    if let Some(info) = mapped.file_id.expansion_info(db.upcast()) {\n         return ascend_call_token(db, &info, mapped);\n     }\n     Some(mapped)"}, {"sha": "8843f2835413062a008aedd26df4c72ca10d2f85", "filename": "crates/ra_hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -21,12 +21,12 @@ use crate::{db::HirDatabase, InFile, MacroDefId};\n \n pub(super) type SourceToDefCache = FxHashMap<ChildContainer, DynMap>;\n \n-pub(super) struct SourceToDefCtx<'a, DB> {\n-    pub(super) db: DB,\n+pub(super) struct SourceToDefCtx<'a, 'b> {\n+    pub(super) db: &'b dyn HirDatabase,\n     pub(super) cache: &'a mut SourceToDefCache,\n }\n \n-impl<DB: HirDatabase> SourceToDefCtx<'_, &'_ DB> {\n+impl SourceToDefCtx<'_, '_> {\n     pub(super) fn file_to_def(&mut self, file: FileId) -> Option<ModuleId> {\n         let _p = profile(\"SourceBinder::to_module_def\");\n         let (krate, local_id) = self.db.relevant_crates(file).iter().find_map(|&crate_id| {\n@@ -43,7 +43,7 @@ impl<DB: HirDatabase> SourceToDefCtx<'_, &'_ DB> {\n             .as_ref()\n             .map(|it| it.syntax())\n             .cloned()\n-            .ancestors_with_macros(self.db)\n+            .ancestors_with_macros(self.db.upcast())\n             .skip(1)\n             .find_map(|it| {\n                 let m = ast::Module::cast(it.value.clone())?;\n@@ -53,7 +53,7 @@ impl<DB: HirDatabase> SourceToDefCtx<'_, &'_ DB> {\n         let parent_module = match parent_declaration {\n             Some(parent_declaration) => self.module_to_def(parent_declaration),\n             None => {\n-                let file_id = src.file_id.original_file(self.db);\n+                let file_id = src.file_id.original_file(self.db.upcast());\n                 self.file_to_def(file_id)\n             }\n         }?;\n@@ -147,15 +147,15 @@ impl<DB: HirDatabase> SourceToDefCtx<'_, &'_ DB> {\n     // FIXME: use DynMap as well?\n     pub(super) fn macro_call_to_def(&mut self, src: InFile<ast::MacroCall>) -> Option<MacroDefId> {\n         let kind = MacroDefKind::Declarative;\n-        let file_id = src.file_id.original_file(self.db);\n+        let file_id = src.file_id.original_file(self.db.upcast());\n         let krate = self.file_to_def(file_id)?.krate;\n         let file_ast_id = self.db.ast_id_map(src.file_id).ast_id(&src.value);\n         let ast_id = Some(AstId::new(src.file_id, file_ast_id));\n         Some(MacroDefId { krate: Some(krate), ast_id, kind })\n     }\n \n     pub(super) fn find_container(&mut self, src: InFile<&SyntaxNode>) -> Option<ChildContainer> {\n-        for container in src.cloned().ancestors_with_macros(self.db).skip(1) {\n+        for container in src.cloned().ancestors_with_macros(self.db.upcast()).skip(1) {\n             let res: ChildContainer = match_ast! {\n                 match (container.value) {\n                     ast::Module(it) => {\n@@ -200,12 +200,12 @@ impl<DB: HirDatabase> SourceToDefCtx<'_, &'_ DB> {\n             return Some(res);\n         }\n \n-        let def = self.file_to_def(src.file_id.original_file(self.db))?;\n+        let def = self.file_to_def(src.file_id.original_file(self.db.upcast()))?;\n         Some(def.into())\n     }\n \n     fn find_type_param_container(&mut self, src: InFile<&SyntaxNode>) -> Option<GenericDefId> {\n-        for container in src.cloned().ancestors_with_macros(self.db).skip(1) {\n+        for container in src.cloned().ancestors_with_macros(self.db.upcast()).skip(1) {\n             let res: GenericDefId = match_ast! {\n                 match (container.value) {\n                     ast::FnDef(it) => { self.fn_to_def(container.with_value(it))?.into() },\n@@ -223,7 +223,7 @@ impl<DB: HirDatabase> SourceToDefCtx<'_, &'_ DB> {\n     }\n \n     fn find_pat_container(&mut self, src: InFile<&SyntaxNode>) -> Option<DefWithBodyId> {\n-        for container in src.cloned().ancestors_with_macros(self.db).skip(1) {\n+        for container in src.cloned().ancestors_with_macros(self.db.upcast()).skip(1) {\n             let res: DefWithBodyId = match_ast! {\n                 match (container.value) {\n                     ast::ConstDef(it) => { self.const_to_def(container.with_value(it))?.into() },\n@@ -262,7 +262,8 @@ impl_froms! {\n }\n \n impl ChildContainer {\n-    fn child_by_source(self, db: &impl HirDatabase) -> DynMap {\n+    fn child_by_source(self, db: &dyn HirDatabase) -> DynMap {\n+        let db = db.upcast();\n         match self {\n             ChildContainer::DefWithBodyId(it) => it.child_by_source(db),\n             ChildContainer::ModuleId(it) => it.child_by_source(db),"}, {"sha": "e8afef32852680fe5e80edb4020cf5666719ab38", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 47, "deletions": 42, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -42,7 +42,7 @@ pub(crate) struct SourceAnalyzer {\n \n impl SourceAnalyzer {\n     pub(crate) fn new_for_body(\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         def: DefWithBodyId,\n         node: InFile<&SyntaxNode>,\n         offset: Option<TextUnit>,\n@@ -53,7 +53,7 @@ impl SourceAnalyzer {\n             None => scope_for(&scopes, &source_map, node),\n             Some(offset) => scope_for_offset(&scopes, &source_map, node.with_value(offset)),\n         };\n-        let resolver = resolver_for_scope(db, def, scope);\n+        let resolver = resolver_for_scope(db.upcast(), def, scope);\n         SourceAnalyzer {\n             resolver,\n             body: Some(body),\n@@ -90,7 +90,7 @@ impl SourceAnalyzer {\n \n     fn expand_expr(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         expr: InFile<ast::MacroCall>,\n     ) -> Option<InFile<ast::Expr>> {\n         let macro_file = self.body_source_map.as_ref()?.node_macro_file(expr.as_ref())?;\n@@ -103,11 +103,11 @@ impl SourceAnalyzer {\n         Some(res)\n     }\n \n-    fn trait_env(&self, db: &impl HirDatabase) -> Arc<TraitEnvironment> {\n+    fn trait_env(&self, db: &dyn HirDatabase) -> Arc<TraitEnvironment> {\n         TraitEnvironment::lower(db, &self.resolver)\n     }\n \n-    pub(crate) fn type_of(&self, db: &impl HirDatabase, expr: &ast::Expr) -> Option<Type> {\n+    pub(crate) fn type_of(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<Type> {\n         let expr_id = match expr {\n             ast::Expr::MacroCall(call) => {\n                 let expr = self.expand_expr(db, InFile::new(self.file_id, call.clone()))?;\n@@ -121,7 +121,7 @@ impl SourceAnalyzer {\n         Some(Type { krate: self.resolver.krate()?, ty: InEnvironment { value: ty, environment } })\n     }\n \n-    pub(crate) fn type_of_pat(&self, db: &impl HirDatabase, pat: &ast::Pat) -> Option<Type> {\n+    pub(crate) fn type_of_pat(&self, db: &dyn HirDatabase, pat: &ast::Pat) -> Option<Type> {\n         let pat_id = self.pat_id(pat)?;\n         let ty = self.infer.as_ref()?[pat_id].clone();\n         let environment = self.trait_env(db);\n@@ -140,7 +140,7 @@ impl SourceAnalyzer {\n \n     pub(crate) fn resolve_record_field(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         field: &ast::RecordField,\n     ) -> Option<(crate::StructField, Option<Local>)> {\n         let (expr_id, local) = match field.expr() {\n@@ -150,7 +150,7 @@ impl SourceAnalyzer {\n                 let expr_id = self.body_source_map.as_ref()?.field_init_shorthand_expr(src)?;\n                 let local_name = field.name_ref()?.as_name();\n                 let path = ModPath::from_segments(PathKind::Plain, once(local_name));\n-                let local = match self.resolver.resolve_path_in_value_ns_fully(db, &path) {\n+                let local = match self.resolver.resolve_path_in_value_ns_fully(db.upcast(), &path) {\n                     Some(ValueNs::LocalBinding(pat_id)) => {\n                         Some(Local { pat_id, parent: self.resolver.body_owner()? })\n                     }\n@@ -181,17 +181,17 @@ impl SourceAnalyzer {\n \n     pub(crate) fn resolve_macro_call(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         macro_call: InFile<&ast::MacroCall>,\n     ) -> Option<MacroDef> {\n-        let hygiene = Hygiene::new(db, macro_call.file_id);\n+        let hygiene = Hygiene::new(db.upcast(), macro_call.file_id);\n         let path = macro_call.value.path().and_then(|ast| Path::from_src(ast, &hygiene))?;\n-        self.resolver.resolve_path_as_macro(db, path.mod_path()).map(|it| it.into())\n+        self.resolver.resolve_path_as_macro(db.upcast(), path.mod_path()).map(|it| it.into())\n     }\n \n     pub(crate) fn resolve_bind_pat_to_const(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         pat: &ast::BindPat,\n     ) -> Option<ModuleDef> {\n         let pat_id = self.pat_id(&pat.clone().into())?;\n@@ -209,7 +209,7 @@ impl SourceAnalyzer {\n \n     pub(crate) fn resolve_path(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         path: &ast::Path,\n     ) -> Option<PathResolution> {\n         if let Some(path_expr) = path.syntax().parent().and_then(ast::PathExpr::cast) {\n@@ -231,11 +231,12 @@ impl SourceAnalyzer {\n \n     pub(crate) fn expand(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         macro_call: InFile<&ast::MacroCall>,\n     ) -> Option<HirFileId> {\n-        let macro_call_id =\n-            macro_call.as_call_id(db, |path| self.resolver.resolve_path_as_macro(db, &path))?;\n+        let macro_call_id = macro_call.as_call_id(db.upcast(), |path| {\n+            self.resolver.resolve_path_as_macro(db.upcast(), &path)\n+        })?;\n         Some(macro_call_id.as_file())\n     }\n }\n@@ -283,42 +284,46 @@ fn scope_for_offset(\n }\n \n pub(crate) fn resolve_hir_path(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     resolver: &Resolver,\n     path: &crate::Path,\n ) -> Option<PathResolution> {\n-    let types = resolver.resolve_path_in_type_ns_fully(db, path.mod_path()).map(|ty| match ty {\n-        TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n-        TypeNs::GenericParam(id) => PathResolution::TypeParam(TypeParam { id }),\n-        TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => PathResolution::Def(Adt::from(it).into()),\n-        TypeNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n-        TypeNs::TypeAliasId(it) => PathResolution::Def(TypeAlias::from(it).into()),\n-        TypeNs::BuiltinType(it) => PathResolution::Def(it.into()),\n-        TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n-    });\n-    let body_owner = resolver.body_owner();\n-    let values = resolver.resolve_path_in_value_ns_fully(db, path.mod_path()).and_then(|val| {\n-        let res = match val {\n-            ValueNs::LocalBinding(pat_id) => {\n-                let var = Local { parent: body_owner?.into(), pat_id };\n-                PathResolution::Local(var)\n+    let types =\n+        resolver.resolve_path_in_type_ns_fully(db.upcast(), path.mod_path()).map(|ty| match ty {\n+            TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n+            TypeNs::GenericParam(id) => PathResolution::TypeParam(TypeParam { id }),\n+            TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => {\n+                PathResolution::Def(Adt::from(it).into())\n             }\n-            ValueNs::FunctionId(it) => PathResolution::Def(Function::from(it).into()),\n-            ValueNs::ConstId(it) => PathResolution::Def(Const::from(it).into()),\n-            ValueNs::StaticId(it) => PathResolution::Def(Static::from(it).into()),\n-            ValueNs::StructId(it) => PathResolution::Def(Struct::from(it).into()),\n-            ValueNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n-        };\n-        Some(res)\n-    });\n+            TypeNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n+            TypeNs::TypeAliasId(it) => PathResolution::Def(TypeAlias::from(it).into()),\n+            TypeNs::BuiltinType(it) => PathResolution::Def(it.into()),\n+            TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n+        });\n+    let body_owner = resolver.body_owner();\n+    let values =\n+        resolver.resolve_path_in_value_ns_fully(db.upcast(), path.mod_path()).and_then(|val| {\n+            let res = match val {\n+                ValueNs::LocalBinding(pat_id) => {\n+                    let var = Local { parent: body_owner?.into(), pat_id };\n+                    PathResolution::Local(var)\n+                }\n+                ValueNs::FunctionId(it) => PathResolution::Def(Function::from(it).into()),\n+                ValueNs::ConstId(it) => PathResolution::Def(Const::from(it).into()),\n+                ValueNs::StaticId(it) => PathResolution::Def(Static::from(it).into()),\n+                ValueNs::StructId(it) => PathResolution::Def(Struct::from(it).into()),\n+                ValueNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n+            };\n+            Some(res)\n+        });\n \n     let items = resolver\n-        .resolve_module_path_in_items(db, path.mod_path())\n+        .resolve_module_path_in_items(db.upcast(), path.mod_path())\n         .take_types()\n         .map(|it| PathResolution::Def(it.into()));\n     types.or(values).or(items).or_else(|| {\n         resolver\n-            .resolve_path_as_macro(db, path.mod_path())\n+            .resolve_path_as_macro(db.upcast(), path.mod_path())\n             .map(|def| PathResolution::Macro(def.into()))\n     })\n }"}, {"sha": "d55c49938f02837bc8c5a75a734e04da303c24b0", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -52,14 +52,14 @@ pub struct StructFieldData {\n }\n \n impl StructData {\n-    pub(crate) fn struct_data_query(db: &impl DefDatabase, id: StructId) -> Arc<StructData> {\n+    pub(crate) fn struct_data_query(db: &dyn DefDatabase, id: StructId) -> Arc<StructData> {\n         let src = id.lookup(db).source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let variant_data = VariantData::new(db, src.map(|s| s.kind()));\n         let variant_data = Arc::new(variant_data);\n         Arc::new(StructData { name, variant_data })\n     }\n-    pub(crate) fn union_data_query(db: &impl DefDatabase, id: UnionId) -> Arc<StructData> {\n+    pub(crate) fn union_data_query(db: &dyn DefDatabase, id: UnionId) -> Arc<StructData> {\n         let src = id.lookup(db).source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let variant_data = VariantData::new(\n@@ -76,7 +76,7 @@ impl StructData {\n }\n \n impl EnumData {\n-    pub(crate) fn enum_data_query(db: &impl DefDatabase, e: EnumId) -> Arc<EnumData> {\n+    pub(crate) fn enum_data_query(db: &dyn DefDatabase, e: EnumId) -> Arc<EnumData> {\n         let _p = profile(\"enum_data_query\");\n         let src = e.lookup(db).source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n@@ -94,7 +94,7 @@ impl EnumData {\n impl HasChildSource for EnumId {\n     type ChildId = LocalEnumVariantId;\n     type Value = ast::EnumVariant;\n-    fn child_source(&self, db: &impl DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>> {\n+    fn child_source(&self, db: &dyn DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>> {\n         let src = self.lookup(db).source(db);\n         let mut trace = Trace::new_for_map();\n         lower_enum(db, &mut trace, &src);\n@@ -103,7 +103,7 @@ impl HasChildSource for EnumId {\n }\n \n fn lower_enum(\n-    db: &impl DefDatabase,\n+    db: &dyn DefDatabase,\n     trace: &mut Trace<LocalEnumVariantId, EnumVariantData, ast::EnumVariant>,\n     ast: &InFile<ast::EnumDef>,\n ) {\n@@ -119,7 +119,7 @@ fn lower_enum(\n }\n \n impl VariantData {\n-    fn new(db: &impl DefDatabase, flavor: InFile<ast::StructKind>) -> Self {\n+    fn new(db: &dyn DefDatabase, flavor: InFile<ast::StructKind>) -> Self {\n         let mut trace = Trace::new_for_arena();\n         match lower_struct(db, &mut trace, &flavor) {\n             StructKind::Tuple => VariantData::Tuple(trace.into_arena()),\n@@ -153,7 +153,7 @@ impl HasChildSource for VariantId {\n     type ChildId = LocalStructFieldId;\n     type Value = Either<ast::TupleFieldDef, ast::RecordFieldDef>;\n \n-    fn child_source(&self, db: &impl DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>> {\n+    fn child_source(&self, db: &dyn DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>> {\n         let src = match self {\n             VariantId::EnumVariantId(it) => {\n                 // I don't really like the fact that we call into parent source\n@@ -182,7 +182,7 @@ pub enum StructKind {\n }\n \n fn lower_struct(\n-    db: &impl DefDatabase,\n+    db: &dyn DefDatabase,\n     trace: &mut Trace<\n         LocalStructFieldId,\n         StructFieldData,"}, {"sha": "71a18f5e1ac9bb0b966a8dab8f91124ce8d7ca3e", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -32,7 +32,7 @@ impl ops::Deref for Attrs {\n }\n \n impl Attrs {\n-    pub(crate) fn attrs_query(db: &impl DefDatabase, def: AttrDefId) -> Attrs {\n+    pub(crate) fn attrs_query(db: &dyn DefDatabase, def: AttrDefId) -> Attrs {\n         match def {\n             AttrDefId::ModuleId(module) => {\n                 let def_map = db.crate_def_map(module.krate);\n@@ -71,8 +71,8 @@ impl Attrs {\n         }\n     }\n \n-    fn from_attrs_owner(db: &impl DefDatabase, owner: InFile<&dyn AttrsOwner>) -> Attrs {\n-        let hygiene = Hygiene::new(db, owner.file_id);\n+    fn from_attrs_owner(db: &dyn DefDatabase, owner: InFile<&dyn AttrsOwner>) -> Attrs {\n+        let hygiene = Hygiene::new(db.upcast(), owner.file_id);\n         Attrs::new(owner.value, &hygiene)\n     }\n \n@@ -155,20 +155,18 @@ impl<'a> AttrQuery<'a> {\n     }\n }\n \n-fn attrs_from_ast<D, N>(src: AstId<N>, db: &D) -> Attrs\n+fn attrs_from_ast<N>(src: AstId<N>, db: &dyn DefDatabase) -> Attrs\n where\n     N: ast::AttrsOwner,\n-    D: DefDatabase,\n {\n-    let src = InFile::new(src.file_id, src.to_node(db));\n+    let src = InFile::new(src.file_id, src.to_node(db.upcast()));\n     Attrs::from_attrs_owner(db, src.as_ref().map(|it| it as &dyn AttrsOwner))\n }\n \n-fn attrs_from_loc<T, D>(node: T, db: &D) -> Attrs\n+fn attrs_from_loc<T>(node: T, db: &dyn DefDatabase) -> Attrs\n where\n     T: HasSource,\n     T::Value: ast::AttrsOwner,\n-    D: DefDatabase,\n {\n     let src = node.source(db);\n     Attrs::from_attrs_owner(db, src.as_ref().map(|it| it as &dyn AttrsOwner))"}, {"sha": "34561ee73bc761f8413048bc33e337e1d4bdaf19", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -34,19 +34,19 @@ pub(crate) struct Expander {\n \n impl Expander {\n     pub(crate) fn new(\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         current_file_id: HirFileId,\n         module: ModuleId,\n     ) -> Expander {\n         let crate_def_map = db.crate_def_map(module.krate);\n-        let hygiene = Hygiene::new(db, current_file_id);\n+        let hygiene = Hygiene::new(db.upcast(), current_file_id);\n         let ast_id_map = db.ast_id_map(current_file_id);\n         Expander { crate_def_map, current_file_id, hygiene, ast_id_map, module }\n     }\n \n-    pub(crate) fn enter_expand<T: ast::AstNode, DB: DefDatabase>(\n+    pub(crate) fn enter_expand<T: ast::AstNode>(\n         &mut self,\n-        db: &DB,\n+        db: &dyn DefDatabase,\n         local_scope: Option<&ItemScope>,\n         macro_call: ast::MacroCall,\n     ) -> Option<(Mark, T)> {\n@@ -70,7 +70,7 @@ impl Expander {\n                         ast_id_map: mem::take(&mut self.ast_id_map),\n                         bomb: DropBomb::new(\"expansion mark dropped\"),\n                     };\n-                    self.hygiene = Hygiene::new(db, file_id);\n+                    self.hygiene = Hygiene::new(db.upcast(), file_id);\n                     self.current_file_id = file_id;\n                     self.ast_id_map = db.ast_id_map(file_id);\n \n@@ -84,8 +84,8 @@ impl Expander {\n         None\n     }\n \n-    pub(crate) fn exit(&mut self, db: &impl DefDatabase, mut mark: Mark) {\n-        self.hygiene = Hygiene::new(db, mark.file_id);\n+    pub(crate) fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n+        self.hygiene = Hygiene::new(db.upcast(), mark.file_id);\n         self.current_file_id = mark.file_id;\n         self.ast_id_map = mem::take(&mut mark.ast_id_map);\n         mark.bomb.defuse();\n@@ -99,7 +99,7 @@ impl Expander {\n         Path::from_src(path, &self.hygiene)\n     }\n \n-    fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &ModPath) -> Option<MacroDefId> {\n+    fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroDefId> {\n         self.crate_def_map\n             .resolve_path(db, self.module.local_id, path, BuiltinShadowMode::Other)\n             .0\n@@ -167,7 +167,7 @@ pub struct SyntheticSyntax;\n \n impl Body {\n     pub(crate) fn body_with_source_map_query(\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         def: DefWithBodyId,\n     ) -> (Arc<Body>, Arc<BodySourceMap>) {\n         let _p = profile(\"body_with_source_map_query\");\n@@ -196,12 +196,12 @@ impl Body {\n         (Arc::new(body), Arc::new(source_map))\n     }\n \n-    pub(crate) fn body_query(db: &impl DefDatabase, def: DefWithBodyId) -> Arc<Body> {\n+    pub(crate) fn body_query(db: &dyn DefDatabase, def: DefWithBodyId) -> Arc<Body> {\n         db.body_with_source_map(def).0\n     }\n \n     fn new(\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         def: DefWithBodyId,\n         expander: Expander,\n         params: Option<ast::ParamList>,"}, {"sha": "6238de6065c5ffce8682f4afe12f752fca3a6fc3", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -36,7 +36,7 @@ use crate::{\n };\n \n pub(super) fn lower(\n-    db: &impl DefDatabase,\n+    db: &dyn DefDatabase,\n     def: DefWithBodyId,\n     expander: Expander,\n     params: Option<ast::ParamList>,\n@@ -58,19 +58,16 @@ pub(super) fn lower(\n     .collect(params, body)\n }\n \n-struct ExprCollector<DB> {\n-    db: DB,\n+struct ExprCollector<'a> {\n+    db: &'a dyn DefDatabase,\n     def: DefWithBodyId,\n     expander: Expander,\n \n     body: Body,\n     source_map: BodySourceMap,\n }\n \n-impl<'a, DB> ExprCollector<&'a DB>\n-where\n-    DB: DefDatabase,\n-{\n+impl ExprCollector<'_> {\n     fn collect(\n         mut self,\n         param_list: Option<ast::ParamList>,"}, {"sha": "7c3db8869e89b24286d91f0bbdda080b872485fe", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -45,7 +45,7 @@ pub struct ScopeData {\n }\n \n impl ExprScopes {\n-    pub(crate) fn expr_scopes_query(db: &impl DefDatabase, def: DefWithBodyId) -> Arc<ExprScopes> {\n+    pub(crate) fn expr_scopes_query(db: &dyn DefDatabase, def: DefWithBodyId) -> Arc<ExprScopes> {\n         let body = db.body(def);\n         Arc::new(ExprScopes::new(&*body))\n     }"}, {"sha": "7009f21d1a58c43ee1b75734bf671e1605b61fc0", "filename": "crates/ra_hir_def/src/child_by_source.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fchild_by_source.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -17,11 +17,11 @@ use crate::{\n };\n \n pub trait ChildBySource {\n-    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap;\n+    fn child_by_source(&self, db: &dyn DefDatabase) -> DynMap;\n }\n \n impl ChildBySource for TraitId {\n-    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+    fn child_by_source(&self, db: &dyn DefDatabase) -> DynMap {\n         let mut res = DynMap::default();\n \n         let data = db.trait_data(*self);\n@@ -47,7 +47,7 @@ impl ChildBySource for TraitId {\n }\n \n impl ChildBySource for ImplId {\n-    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+    fn child_by_source(&self, db: &dyn DefDatabase) -> DynMap {\n         let mut res = DynMap::default();\n \n         let data = db.impl_data(*self);\n@@ -73,21 +73,21 @@ impl ChildBySource for ImplId {\n }\n \n impl ChildBySource for ModuleId {\n-    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+    fn child_by_source(&self, db: &dyn DefDatabase) -> DynMap {\n         let crate_def_map = db.crate_def_map(self.krate);\n         let module_data = &crate_def_map[self.local_id];\n         module_data.scope.child_by_source(db)\n     }\n }\n \n impl ChildBySource for ItemScope {\n-    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+    fn child_by_source(&self, db: &dyn DefDatabase) -> DynMap {\n         let mut res = DynMap::default();\n         self.declarations().for_each(|item| add_module_def(db, &mut res, item));\n         self.impls().for_each(|imp| add_impl(db, &mut res, imp));\n         return res;\n \n-        fn add_module_def(db: &impl DefDatabase, map: &mut DynMap, item: ModuleDefId) {\n+        fn add_module_def(db: &dyn DefDatabase, map: &mut DynMap, item: ModuleDefId) {\n             match item {\n                 ModuleDefId::FunctionId(func) => {\n                     let src = func.lookup(db).source(db);\n@@ -126,15 +126,15 @@ impl ChildBySource for ItemScope {\n                 _ => (),\n             }\n         }\n-        fn add_impl(db: &impl DefDatabase, map: &mut DynMap, imp: ImplId) {\n+        fn add_impl(db: &dyn DefDatabase, map: &mut DynMap, imp: ImplId) {\n             let src = imp.lookup(db).source(db);\n             map[keys::IMPL].insert(src, imp)\n         }\n     }\n }\n \n impl ChildBySource for VariantId {\n-    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+    fn child_by_source(&self, db: &dyn DefDatabase) -> DynMap {\n         let mut res = DynMap::default();\n \n         let arena_map = self.child_source(db);\n@@ -155,7 +155,7 @@ impl ChildBySource for VariantId {\n }\n \n impl ChildBySource for EnumId {\n-    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+    fn child_by_source(&self, db: &dyn DefDatabase) -> DynMap {\n         let mut res = DynMap::default();\n \n         let arena_map = self.child_source(db);\n@@ -170,7 +170,7 @@ impl ChildBySource for EnumId {\n }\n \n impl ChildBySource for DefWithBodyId {\n-    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+    fn child_by_source(&self, db: &dyn DefDatabase) -> DynMap {\n         let body = db.body(*self);\n         body.item_scope.child_by_source(db)\n     }"}, {"sha": "04bd4a3059dcb46805864348ead5fe49288c1cc2", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -105,7 +105,7 @@ pub struct TypeAliasData {\n \n impl TypeAliasData {\n     pub(crate) fn type_alias_data_query(\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         typ: TypeAliasId,\n     ) -> Arc<TypeAliasData> {\n         let loc = typ.lookup(db);\n@@ -127,7 +127,7 @@ pub struct TraitData {\n }\n \n impl TraitData {\n-    pub(crate) fn trait_data_query(db: &impl DefDatabase, tr: TraitId) -> Arc<TraitData> {\n+    pub(crate) fn trait_data_query(db: &dyn DefDatabase, tr: TraitId) -> Arc<TraitData> {\n         let src = tr.lookup(db).source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let auto = src.value.is_auto();\n@@ -200,7 +200,7 @@ pub struct ImplData {\n }\n \n impl ImplData {\n-    pub(crate) fn impl_data_query(db: &impl DefDatabase, id: ImplId) -> Arc<ImplData> {\n+    pub(crate) fn impl_data_query(db: &dyn DefDatabase, id: ImplId) -> Arc<ImplData> {\n         let _p = profile(\"impl_data_query\");\n         let impl_loc = id.lookup(db);\n         let src = impl_loc.source(db);\n@@ -235,20 +235,20 @@ pub struct ConstData {\n }\n \n impl ConstData {\n-    pub(crate) fn const_data_query(db: &impl DefDatabase, konst: ConstId) -> Arc<ConstData> {\n+    pub(crate) fn const_data_query(db: &dyn DefDatabase, konst: ConstId) -> Arc<ConstData> {\n         let loc = konst.lookup(db);\n         let node = loc.source(db);\n         let vis_default = RawVisibility::default_for_container(loc.container);\n         Arc::new(ConstData::new(db, vis_default, node))\n     }\n \n-    pub(crate) fn static_data_query(db: &impl DefDatabase, konst: StaticId) -> Arc<ConstData> {\n+    pub(crate) fn static_data_query(db: &dyn DefDatabase, konst: StaticId) -> Arc<ConstData> {\n         let node = konst.lookup(db).source(db);\n         Arc::new(ConstData::new(db, RawVisibility::private(), node))\n     }\n \n     fn new<N: NameOwner + TypeAscriptionOwner + VisibilityOwner>(\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         vis_default: RawVisibility,\n         node: InFile<N>,\n     ) -> ConstData {\n@@ -261,7 +261,7 @@ impl ConstData {\n }\n \n fn collect_impl_items_in_macros(\n-    db: &impl DefDatabase,\n+    db: &dyn DefDatabase,\n     module_id: ModuleId,\n     impl_def: &InFile<ast::ItemList>,\n     id: ImplId,\n@@ -280,7 +280,7 @@ fn collect_impl_items_in_macros(\n }\n \n fn collect_impl_items_in_macro(\n-    db: &impl DefDatabase,\n+    db: &dyn DefDatabase,\n     expander: &mut Expander,\n     m: ast::MacroCall,\n     id: ImplId,\n@@ -312,7 +312,7 @@ fn collect_impl_items_in_macro(\n }\n \n fn collect_impl_items(\n-    db: &impl DefDatabase,\n+    db: &dyn DefDatabase,\n     impl_items: impl Iterator<Item = ImplItem>,\n     file_id: crate::HirFileId,\n     id: ImplId,"}, {"sha": "7f8c1ea2189129ee4c6a42101c16b46a6faf9096", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -2,7 +2,7 @@\n use std::sync::Arc;\n \n use hir_expand::{db::AstDatabase, HirFileId};\n-use ra_db::{salsa, CrateId, SourceDatabase};\n+use ra_db::{salsa, CrateId, SourceDatabase, Upcast};\n use ra_prof::profile;\n use ra_syntax::SmolStr;\n \n@@ -43,7 +43,7 @@ pub trait InternDatabase: SourceDatabase {\n }\n \n #[salsa::query_group(DefDatabaseStorage)]\n-pub trait DefDatabase: InternDatabase + AstDatabase {\n+pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(RawItems::raw_items_query)]\n     fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n \n@@ -109,6 +109,12 @@ pub trait DefDatabase: InternDatabase + AstDatabase {\n     fn documentation(&self, def: AttrDefId) -> Option<Documentation>;\n }\n \n+// impl<T: DefDatabase> Upcast<dyn AstDatabase> for T {\n+//     fn upcast(&self) -> &dyn AstDatabase {\n+//         &*self\n+//     }\n+// }\n+\n fn crate_def_map_wait(db: &impl DefDatabase, krate: CrateId) -> Arc<CrateDefMap> {\n     let _p = profile(\"crate_def_map:wait\");\n     db.crate_def_map_query(krate)"}, {"sha": "0539a77d40c4172fa9441d1e487ec9cd81bebc0b", "filename": "crates/ra_hir_def/src/docs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -34,7 +34,7 @@ impl Documentation {\n     }\n \n     pub(crate) fn documentation_query(\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         def: AttrDefId,\n     ) -> Option<Documentation> {\n         match def {\n@@ -60,7 +60,7 @@ impl Documentation {\n                 docs_from_ast(&src.value[it.local_id])\n             }\n             AttrDefId::TraitId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n-            AttrDefId::MacroDefId(it) => docs_from_ast(&it.ast_id?.to_node(db)),\n+            AttrDefId::MacroDefId(it) => docs_from_ast(&it.ast_id?.to_node(db.upcast())),\n             AttrDefId::ConstId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n             AttrDefId::StaticId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n             AttrDefId::FunctionId(it) => docs_from_ast(&it.lookup(db).source(db).value),"}, {"sha": "d58ac6ba58d705d7c96df3df1089771d7f2dd696", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -44,12 +44,12 @@ impl ModPath {\n \n /// Find a path that can be used to refer to a certain item. This can depend on\n /// *from where* you're referring to the item, hence the `from` parameter.\n-pub fn find_path(db: &impl DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n+pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n     find_path_inner(db, item, from, MAX_PATH_LEN)\n }\n \n fn find_path_inner(\n-    db: &impl DefDatabase,\n+    db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n     max_len: usize,\n@@ -165,7 +165,7 @@ fn select_best_path(old_path: ModPath, new_path: ModPath) -> ModPath {\n }\n \n fn find_importable_locations(\n-    db: &impl DefDatabase,\n+    db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n ) -> Vec<(ModuleId, Name)> {\n@@ -195,7 +195,7 @@ fn find_importable_locations(\n /// Note that the crate doesn't need to be the one in which the item is defined;\n /// it might be re-exported in other crates.\n fn importable_locations_in_crate(\n-    db: &impl DefDatabase,\n+    db: &dyn DefDatabase,\n     item: ItemInNs,\n     krate: CrateId,\n ) -> Vec<(ModuleId, Name, Visibility)> {"}, {"sha": "24adc8153bdea11b4c0ad9e6992a83813f9ed195", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -69,15 +69,15 @@ type SourceMap = ArenaMap<LocalTypeParamId, Either<ast::TraitDef, ast::TypeParam\n \n impl GenericParams {\n     pub(crate) fn generic_params_query(\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         def: GenericDefId,\n     ) -> Arc<GenericParams> {\n         let _p = profile(\"generic_params_query\");\n         let (params, _source_map) = GenericParams::new(db, def);\n         Arc::new(params)\n     }\n \n-    fn new(db: &impl DefDatabase, def: GenericDefId) -> (GenericParams, InFile<SourceMap>) {\n+    fn new(db: &dyn DefDatabase, def: GenericDefId) -> (GenericParams, InFile<SourceMap>) {\n         let mut generics = GenericParams { types: Arena::default(), where_predicates: Vec::new() };\n         let mut sm = ArenaMap::default();\n         // FIXME: add `: Sized` bound for everything except for `Self` in traits\n@@ -242,14 +242,14 @@ impl GenericParams {\n impl HasChildSource for GenericDefId {\n     type ChildId = LocalTypeParamId;\n     type Value = Either<ast::TraitDef, ast::TypeParam>;\n-    fn child_source(&self, db: &impl DefDatabase) -> InFile<SourceMap> {\n+    fn child_source(&self, db: &dyn DefDatabase) -> InFile<SourceMap> {\n         let (_, sm) = GenericParams::new(db, *self);\n         sm\n     }\n }\n \n impl ChildBySource for GenericDefId {\n-    fn child_by_source(&self, db: &impl DefDatabase) -> DynMap {\n+    fn child_by_source(&self, db: &dyn DefDatabase) -> DynMap {\n         let mut res = DynMap::default();\n         let arena_map = self.child_source(db);\n         let arena_map = arena_map.as_ref();"}, {"sha": "01b367278dae70cbf4515120f5f0fed43b7aff67", "filename": "crates/ra_hir_def/src/lang_item.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -77,7 +77,7 @@ impl LangItems {\n     }\n \n     /// Salsa query. This will look for lang items in a specific crate.\n-    pub(crate) fn crate_lang_items_query(db: &impl DefDatabase, krate: CrateId) -> Arc<LangItems> {\n+    pub(crate) fn crate_lang_items_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<LangItems> {\n         let mut lang_items = LangItems::default();\n \n         let crate_def_map = db.crate_def_map(krate);\n@@ -92,7 +92,7 @@ impl LangItems {\n     }\n \n     pub(crate) fn module_lang_items_query(\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         module: ModuleId,\n     ) -> Option<Arc<LangItems>> {\n         let mut lang_items = LangItems::default();\n@@ -107,7 +107,7 @@ impl LangItems {\n     /// Salsa query. Look for a lang item, starting from the specified crate and recursively\n     /// traversing its dependencies.\n     pub(crate) fn lang_item_query(\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         start_crate: CrateId,\n         item: SmolStr,\n     ) -> Option<LangItemTarget> {\n@@ -122,7 +122,7 @@ impl LangItems {\n             .find_map(|dep| db.lang_item(dep.crate_id, item.clone()))\n     }\n \n-    fn collect_lang_items(&mut self, db: &impl DefDatabase, module: ModuleId) {\n+    fn collect_lang_items(&mut self, db: &dyn DefDatabase, module: ModuleId) {\n         // Look for impl targets\n         let def_map = db.crate_def_map(module.krate);\n         let module_data = &def_map[module.local_id];\n@@ -152,7 +152,7 @@ impl LangItems {\n \n     fn collect_lang_item<T>(\n         &mut self,\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         item: T,\n         constructor: fn(T) -> LangItemTarget,\n     ) where"}, {"sha": "24f9eb9e0b704ac0c23fe1e15da9b463657be5b6", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -47,8 +47,8 @@ mod marks;\n use std::hash::Hash;\n \n use hir_expand::{\n-    ast_id_map::FileAstId, db::AstDatabase, eager::expand_eager_macro, hygiene::Hygiene, AstId,\n-    HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n+    ast_id_map::FileAstId, eager::expand_eager_macro, hygiene::Hygiene, AstId, HirFileId, InFile,\n+    MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use ra_arena::{impl_arena_id, RawId};\n use ra_db::{impl_intern_key, salsa, CrateId};\n@@ -87,14 +87,14 @@ macro_rules! impl_intern {\n \n         impl Intern for $loc {\n             type ID = $id;\n-            fn intern(self, db: &impl db::DefDatabase) -> $id {\n+            fn intern(self, db: &dyn db::DefDatabase) -> $id {\n                 db.$intern(self)\n             }\n         }\n \n         impl Lookup for $id {\n             type Data = $loc;\n-            fn lookup(&self, db: &impl db::DefDatabase) -> $loc {\n+            fn lookup(&self, db: &dyn db::DefDatabase) -> $loc {\n                 db.$lookup(*self)\n             }\n         }\n@@ -339,20 +339,20 @@ impl_froms!(VariantId: EnumVariantId, StructId, UnionId);\n \n trait Intern {\n     type ID;\n-    fn intern(self, db: &impl db::DefDatabase) -> Self::ID;\n+    fn intern(self, db: &dyn db::DefDatabase) -> Self::ID;\n }\n \n pub trait Lookup {\n     type Data;\n-    fn lookup(&self, db: &impl db::DefDatabase) -> Self::Data;\n+    fn lookup(&self, db: &dyn db::DefDatabase) -> Self::Data;\n }\n \n pub trait HasModule {\n-    fn module(&self, db: &impl db::DefDatabase) -> ModuleId;\n+    fn module(&self, db: &dyn db::DefDatabase) -> ModuleId;\n }\n \n impl HasModule for ContainerId {\n-    fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n+    fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n         match *self {\n             ContainerId::ModuleId(it) => it,\n             ContainerId::DefWithBodyId(it) => it.module(db),\n@@ -361,7 +361,7 @@ impl HasModule for ContainerId {\n }\n \n impl HasModule for AssocContainerId {\n-    fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n+    fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n         match *self {\n             AssocContainerId::ContainerId(it) => it.module(db),\n             AssocContainerId::ImplId(it) => it.lookup(db).container.module(db),\n@@ -371,13 +371,13 @@ impl HasModule for AssocContainerId {\n }\n \n impl<N: AstNode> HasModule for AssocItemLoc<N> {\n-    fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n+    fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n         self.container.module(db)\n     }\n }\n \n impl HasModule for AdtId {\n-    fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n+    fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n         match self {\n             AdtId::StructId(it) => it.lookup(db).container,\n             AdtId::UnionId(it) => it.lookup(db).container,\n@@ -388,7 +388,7 @@ impl HasModule for AdtId {\n }\n \n impl HasModule for DefWithBodyId {\n-    fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n+    fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n         match self {\n             DefWithBodyId::FunctionId(it) => it.lookup(db).module(db),\n             DefWithBodyId::StaticId(it) => it.lookup(db).module(db),\n@@ -398,7 +398,7 @@ impl HasModule for DefWithBodyId {\n }\n \n impl HasModule for GenericDefId {\n-    fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n+    fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n         match self {\n             GenericDefId::FunctionId(it) => it.lookup(db).module(db),\n             GenericDefId::AdtId(it) => it.module(db),\n@@ -412,7 +412,7 @@ impl HasModule for GenericDefId {\n }\n \n impl HasModule for StaticLoc {\n-    fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n+    fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n         self.container.module(db)\n     }\n }\n@@ -421,19 +421,19 @@ impl HasModule for StaticLoc {\n pub trait AsMacroCall {\n     fn as_call_id(\n         &self,\n-        db: &(impl db::DefDatabase + AstDatabase),\n+        db: &dyn db::DefDatabase,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId>;\n }\n \n impl AsMacroCall for InFile<&ast::MacroCall> {\n     fn as_call_id(\n         &self,\n-        db: &(impl db::DefDatabase + AstDatabase),\n+        db: &dyn db::DefDatabase,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId> {\n         let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(self.value));\n-        let h = Hygiene::new(db, self.file_id);\n+        let h = Hygiene::new(db.upcast(), self.file_id);\n         let path = path::ModPath::from_src(self.value.path()?, &h)?;\n \n         AstIdWithPath::new(ast_id.file_id, ast_id.value, path).as_call_id(db, resolver)\n@@ -456,34 +456,34 @@ impl<T: ast::AstNode> AstIdWithPath<T> {\n impl AsMacroCall for AstIdWithPath<ast::MacroCall> {\n     fn as_call_id(\n         &self,\n-        db: &impl AstDatabase,\n+        db: &dyn db::DefDatabase,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId> {\n         let def: MacroDefId = resolver(self.path.clone())?;\n \n         if let MacroDefKind::BuiltInEager(_) = def.kind {\n-            let macro_call = InFile::new(self.ast_id.file_id, self.ast_id.to_node(db));\n-            let hygiene = Hygiene::new(db, self.ast_id.file_id);\n+            let macro_call = InFile::new(self.ast_id.file_id, self.ast_id.to_node(db.upcast()));\n+            let hygiene = Hygiene::new(db.upcast(), self.ast_id.file_id);\n \n             Some(\n-                expand_eager_macro(db, macro_call, def, &|path: ast::Path| {\n+                expand_eager_macro(db.upcast(), macro_call, def, &|path: ast::Path| {\n                     resolver(path::ModPath::from_src(path, &hygiene)?)\n                 })?\n                 .into(),\n             )\n         } else {\n-            Some(def.as_lazy_macro(db, MacroCallKind::FnLike(self.ast_id)).into())\n+            Some(def.as_lazy_macro(db.upcast(), MacroCallKind::FnLike(self.ast_id)).into())\n         }\n     }\n }\n \n impl AsMacroCall for AstIdWithPath<ast::ModuleItem> {\n     fn as_call_id(\n         &self,\n-        db: &impl AstDatabase,\n+        db: &dyn db::DefDatabase,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId> {\n         let def = resolver(self.path.clone())?;\n-        Some(def.as_lazy_macro(db, MacroCallKind::Attr(self.ast_id)).into())\n+        Some(def.as_lazy_macro(db.upcast(), MacroCallKind::Attr(self.ast_id)).into())\n     }\n }"}, {"sha": "be53313ee785926d04c3898429a41742b9091c22", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -151,16 +151,17 @@ impl ModuleOrigin {\n \n     /// Returns a node which defines this module.\n     /// That is, a file or a `mod foo {}` with items.\n-    fn definition_source(&self, db: &impl DefDatabase) -> InFile<ModuleSource> {\n+    fn definition_source(&self, db: &dyn DefDatabase) -> InFile<ModuleSource> {\n         match self {\n             ModuleOrigin::File { definition, .. } | ModuleOrigin::CrateRoot { definition } => {\n                 let file_id = *definition;\n                 let sf = db.parse(file_id).tree();\n                 InFile::new(file_id.into(), ModuleSource::SourceFile(sf))\n             }\n-            ModuleOrigin::Inline { definition } => {\n-                InFile::new(definition.file_id, ModuleSource::Module(definition.to_node(db)))\n-            }\n+            ModuleOrigin::Inline { definition } => InFile::new(\n+                definition.file_id,\n+                ModuleSource::Module(definition.to_node(db.upcast())),\n+            ),\n         }\n     }\n }\n@@ -176,7 +177,7 @@ pub struct ModuleData {\n }\n \n impl CrateDefMap {\n-    pub(crate) fn crate_def_map_query(db: &impl DefDatabase, krate: CrateId) -> Arc<CrateDefMap> {\n+    pub(crate) fn crate_def_map_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<CrateDefMap> {\n         let _p = profile(\"crate_def_map_query\").detail(|| {\n             db.crate_graph()[krate]\n                 .display_name\n@@ -204,7 +205,7 @@ impl CrateDefMap {\n \n     pub fn add_diagnostics(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         module: LocalModuleId,\n         sink: &mut DiagnosticSink,\n     ) {\n@@ -220,7 +221,7 @@ impl CrateDefMap {\n \n     pub(crate) fn resolve_path(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         original_module: LocalModuleId,\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n@@ -273,15 +274,15 @@ impl CrateDefMap {\n \n impl ModuleData {\n     /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n-    pub fn definition_source(&self, db: &impl DefDatabase) -> InFile<ModuleSource> {\n+    pub fn definition_source(&self, db: &dyn DefDatabase) -> InFile<ModuleSource> {\n         self.origin.definition_source(db)\n     }\n \n     /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n     /// `None` for the crate root or block.\n-    pub fn declaration_source(&self, db: &impl DefDatabase) -> Option<InFile<ast::Module>> {\n+    pub fn declaration_source(&self, db: &dyn DefDatabase) -> Option<InFile<ast::Module>> {\n         let decl = self.origin.declaration()?;\n-        let value = decl.to_node(db);\n+        let value = decl.to_node(db.upcast());\n         Some(InFile { file_id: decl.file_id, value })\n     }\n }\n@@ -311,7 +312,7 @@ mod diagnostics {\n     impl DefDiagnostic {\n         pub(super) fn add_to(\n             &self,\n-            db: &impl DefDatabase,\n+            db: &dyn DefDatabase,\n             target_module: LocalModuleId,\n             sink: &mut DiagnosticSink,\n         ) {\n@@ -320,7 +321,7 @@ mod diagnostics {\n                     if *module != target_module {\n                         return;\n                     }\n-                    let decl = declaration.to_node(db);\n+                    let decl = declaration.to_node(db.upcast());\n                     sink.push(UnresolvedModule {\n                         file: declaration.file_id,\n                         decl: AstPtr::new(&decl),"}, {"sha": "7a042e69fd4cdd3e705ccf54b507ad8e25b0e868", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -30,7 +30,7 @@ use crate::{\n     TraitLoc, TypeAliasLoc, UnionLoc,\n };\n \n-pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n+pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n     let crate_graph = db.crate_graph();\n \n     // populate external prelude\n@@ -112,8 +112,8 @@ struct DeriveDirective {\n }\n \n /// Walks the tree of module recursively\n-struct DefCollector<'a, DB> {\n-    db: &'a DB,\n+struct DefCollector<'a> {\n+    db: &'a dyn DefDatabase,\n     def_map: CrateDefMap,\n     glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, Visibility)>>,\n     unresolved_imports: Vec<ImportDirective>,\n@@ -124,10 +124,7 @@ struct DefCollector<'a, DB> {\n     cfg_options: &'a CfgOptions,\n }\n \n-impl<DB> DefCollector<'_, DB>\n-where\n-    DB: DefDatabase,\n-{\n+impl DefCollector<'_> {\n     fn collect(&mut self) {\n         let file_id = self.db.crate_graph()[self.def_map.krate].root_file_id;\n         let raw_items = self.db.raw_items(file_id.into());\n@@ -605,19 +602,16 @@ where\n }\n \n /// Walks a single module, populating defs, imports and macros\n-struct ModCollector<'a, D> {\n-    def_collector: D,\n+struct ModCollector<'a, 'b> {\n+    def_collector: &'a mut DefCollector<'b>,\n     macro_depth: usize,\n     module_id: LocalModuleId,\n     file_id: HirFileId,\n     raw_items: &'a raw::RawItems,\n     mod_dir: ModDir,\n }\n \n-impl<DB> ModCollector<'_, &'_ mut DefCollector<'_, DB>>\n-where\n-    DB: DefDatabase,\n-{\n+impl ModCollector<'_, '_> {\n     fn collect(&mut self, items: &[raw::RawItem]) {\n         // Note: don't assert that inserted value is fresh: it's simply not true\n         // for macros.\n@@ -950,7 +944,7 @@ mod tests {\n \n     use super::*;\n \n-    fn do_collect_defs(db: &impl DefDatabase, def_map: CrateDefMap) -> CrateDefMap {\n+    fn do_collect_defs(db: &dyn DefDatabase, def_map: CrateDefMap) -> CrateDefMap {\n         let mut collector = DefCollector {\n             db,\n             def_map,"}, {"sha": "386c5cade62dc169eb4ac947900494b488bdc72a", "filename": "crates/ra_hir_def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -40,12 +40,12 @@ impl ModDir {\n \n     pub(super) fn resolve_declaration(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         file_id: HirFileId,\n         name: &Name,\n         attr_path: Option<&SmolStr>,\n     ) -> Result<(FileId, ModDir), RelativePathBuf> {\n-        let file_id = file_id.original_file(db);\n+        let file_id = file_id.original_file(db.upcast());\n \n         let mut candidate_files = Vec::new();\n         match attr_to_path(attr_path) {"}, {"sha": "35a0a0c9885ed54147f8ab02f4cd33b960503419", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -70,7 +70,7 @@ impl CrateDefMap {\n \n     pub(crate) fn resolve_visibility(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         original_module: LocalModuleId,\n         visibility: &RawVisibility,\n     ) -> Option<Visibility> {\n@@ -98,7 +98,7 @@ impl CrateDefMap {\n     // the result.\n     pub(super) fn resolve_path_fp_with_macro(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         mode: ResolveMode,\n         original_module: LocalModuleId,\n         path: &ModPath,\n@@ -262,7 +262,7 @@ impl CrateDefMap {\n \n     fn resolve_name_in_module(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         module: LocalModuleId,\n         name: &Name,\n         shadow: BuiltinShadowMode,\n@@ -304,7 +304,7 @@ impl CrateDefMap {\n         from_crate_root.or(from_extern_prelude)\n     }\n \n-    fn resolve_in_prelude(&self, db: &impl DefDatabase, name: &Name) -> PerNs {\n+    fn resolve_in_prelude(&self, db: &dyn DefDatabase, name: &Name) -> PerNs {\n         if let Some(prelude) = self.prelude {\n             let keep;\n             let def_map = if prelude.krate == self.krate {"}, {"sha": "0e4931f5854c2b96474064f40431b29a5a397511", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -9,7 +9,6 @@ use std::{ops::Index, sync::Arc};\n \n use hir_expand::{\n     ast_id_map::AstIdMap,\n-    db::AstDatabase,\n     hygiene::Hygiene,\n     name::{AsName, Name},\n };\n@@ -45,16 +44,13 @@ pub struct RawItems {\n }\n \n impl RawItems {\n-    pub(crate) fn raw_items_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        file_id: HirFileId,\n-    ) -> Arc<RawItems> {\n+    pub(crate) fn raw_items_query(db: &dyn DefDatabase, file_id: HirFileId) -> Arc<RawItems> {\n         let _p = profile(\"raw_items_query\");\n         let mut collector = RawItemsCollector {\n             raw_items: RawItems::default(),\n             source_ast_id_map: db.ast_id_map(file_id),\n             file_id,\n-            hygiene: Hygiene::new(db, file_id),\n+            hygiene: Hygiene::new(db.upcast(), file_id),\n         };\n         if let Some(node) = db.parse_or_expand(file_id) {\n             if let Some(source_file) = ast::SourceFile::cast(node.clone()) {"}, {"sha": "717506358f9876431236f646a8151c1c4be368fa", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -96,7 +96,7 @@ pub enum ValueNs {\n \n impl Resolver {\n     /// Resolve known trait from std, like `std::futures::Future`\n-    pub fn resolve_known_trait(&self, db: &impl DefDatabase, path: &ModPath) -> Option<TraitId> {\n+    pub fn resolve_known_trait(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<TraitId> {\n         let res = self.resolve_module_path(db, path, BuiltinShadowMode::Other).take_types()?;\n         match res {\n             ModuleDefId::TraitId(it) => Some(it),\n@@ -105,7 +105,7 @@ impl Resolver {\n     }\n \n     /// Resolve known struct from std, like `std::boxed::Box`\n-    pub fn resolve_known_struct(&self, db: &impl DefDatabase, path: &ModPath) -> Option<StructId> {\n+    pub fn resolve_known_struct(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<StructId> {\n         let res = self.resolve_module_path(db, path, BuiltinShadowMode::Other).take_types()?;\n         match res {\n             ModuleDefId::AdtId(AdtId::StructId(it)) => Some(it),\n@@ -114,7 +114,7 @@ impl Resolver {\n     }\n \n     /// Resolve known enum from std, like `std::result::Result`\n-    pub fn resolve_known_enum(&self, db: &impl DefDatabase, path: &ModPath) -> Option<EnumId> {\n+    pub fn resolve_known_enum(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<EnumId> {\n         let res = self.resolve_module_path(db, path, BuiltinShadowMode::Other).take_types()?;\n         match res {\n             ModuleDefId::AdtId(AdtId::EnumId(it)) => Some(it),\n@@ -124,7 +124,7 @@ impl Resolver {\n \n     fn resolve_module_path(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n     ) -> PerNs {\n@@ -139,13 +139,13 @@ impl Resolver {\n         module_res\n     }\n \n-    pub fn resolve_module_path_in_items(&self, db: &impl DefDatabase, path: &ModPath) -> PerNs {\n+    pub fn resolve_module_path_in_items(&self, db: &dyn DefDatabase, path: &ModPath) -> PerNs {\n         self.resolve_module_path(db, path, BuiltinShadowMode::Module)\n     }\n \n     pub fn resolve_path_in_type_ns(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         path: &ModPath,\n     ) -> Option<(TypeNs, Option<usize>)> {\n         let first_name = path.segments.first()?;\n@@ -222,7 +222,7 @@ impl Resolver {\n \n     pub fn resolve_path_in_type_ns_fully(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         path: &ModPath,\n     ) -> Option<TypeNs> {\n         let (res, unresolved) = self.resolve_path_in_type_ns(db, path)?;\n@@ -234,7 +234,7 @@ impl Resolver {\n \n     pub fn resolve_visibility(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         visibility: &RawVisibility,\n     ) -> Option<Visibility> {\n         match visibility {\n@@ -251,7 +251,7 @@ impl Resolver {\n \n     pub fn resolve_path_in_value_ns(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         path: &ModPath,\n     ) -> Option<ResolveValueResult> {\n         let n_segments = path.segments.len();\n@@ -367,7 +367,7 @@ impl Resolver {\n \n     pub fn resolve_path_in_value_ns_fully(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         path: &ModPath,\n     ) -> Option<ValueNs> {\n         match self.resolve_path_in_value_ns(db, path)? {\n@@ -378,7 +378,7 @@ impl Resolver {\n \n     pub fn resolve_path_as_macro(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         path: &ModPath,\n     ) -> Option<MacroDefId> {\n         // Search item scope legacy macro first\n@@ -390,13 +390,13 @@ impl Resolver {\n         item_map.resolve_path(db, module, &path, BuiltinShadowMode::Other).0.take_macros()\n     }\n \n-    pub fn process_all_names(&self, db: &impl DefDatabase, f: &mut dyn FnMut(Name, ScopeDef)) {\n+    pub fn process_all_names(&self, db: &dyn DefDatabase, f: &mut dyn FnMut(Name, ScopeDef)) {\n         for scope in self.scopes.iter().rev() {\n             scope.process_names(db, f);\n         }\n     }\n \n-    pub fn traits_in_scope(&self, db: &impl DefDatabase) -> FxHashSet<TraitId> {\n+    pub fn traits_in_scope(&self, db: &dyn DefDatabase) -> FxHashSet<TraitId> {\n         let mut traits = FxHashSet::default();\n         for scope in &self.scopes {\n             if let Scope::ModuleScope(m) = scope {\n@@ -474,7 +474,7 @@ pub enum ScopeDef {\n }\n \n impl Scope {\n-    fn process_names(&self, db: &impl DefDatabase, f: &mut dyn FnMut(Name, ScopeDef)) {\n+    fn process_names(&self, db: &dyn DefDatabase, f: &mut dyn FnMut(Name, ScopeDef)) {\n         match self {\n             Scope::ModuleScope(m) => {\n                 // FIXME: should we provide `self` here?\n@@ -534,13 +534,13 @@ impl Scope {\n }\n \n // needs arbitrary_self_types to be a method... or maybe move to the def?\n-pub fn resolver_for_expr(db: &impl DefDatabase, owner: DefWithBodyId, expr_id: ExprId) -> Resolver {\n+pub fn resolver_for_expr(db: &dyn DefDatabase, owner: DefWithBodyId, expr_id: ExprId) -> Resolver {\n     let scopes = db.expr_scopes(owner);\n     resolver_for_scope(db, owner, scopes.scope_for(expr_id))\n }\n \n pub fn resolver_for_scope(\n-    db: &impl DefDatabase,\n+    db: &dyn DefDatabase,\n     owner: DefWithBodyId,\n     scope_id: Option<ScopeId>,\n ) -> Resolver {\n@@ -560,7 +560,7 @@ impl Resolver {\n         self\n     }\n \n-    fn push_generic_params_scope(self, db: &impl DefDatabase, def: GenericDefId) -> Resolver {\n+    fn push_generic_params_scope(self, db: &dyn DefDatabase, def: GenericDefId) -> Resolver {\n         let params = db.generic_params(def);\n         self.push_scope(Scope::GenericParams { def, params })\n     }\n@@ -593,24 +593,24 @@ impl Resolver {\n \n pub trait HasResolver: Copy {\n     /// Builds a resolver for type references inside this def.\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver;\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver;\n }\n \n impl HasResolver for ModuleId {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         let def_map = db.crate_def_map(self.krate);\n         Resolver::default().push_module_scope(def_map, self.local_id)\n     }\n }\n \n impl HasResolver for TraitId {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         self.lookup(db).container.resolver(db).push_generic_params_scope(db, self.into())\n     }\n }\n \n impl<T: Into<AdtId> + Copy> HasResolver for T {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         let def = self.into();\n         def.module(db)\n             .resolver(db)\n@@ -620,31 +620,31 @@ impl<T: Into<AdtId> + Copy> HasResolver for T {\n }\n \n impl HasResolver for FunctionId {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         self.lookup(db).container.resolver(db).push_generic_params_scope(db, self.into())\n     }\n }\n \n impl HasResolver for ConstId {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         self.lookup(db).container.resolver(db)\n     }\n }\n \n impl HasResolver for StaticId {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         self.lookup(db).container.resolver(db)\n     }\n }\n \n impl HasResolver for TypeAliasId {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         self.lookup(db).container.resolver(db).push_generic_params_scope(db, self.into())\n     }\n }\n \n impl HasResolver for ImplId {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         self.lookup(db)\n             .container\n             .resolver(db)\n@@ -654,7 +654,7 @@ impl HasResolver for ImplId {\n }\n \n impl HasResolver for DefWithBodyId {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         match self {\n             DefWithBodyId::ConstId(c) => c.resolver(db),\n             DefWithBodyId::FunctionId(f) => f.resolver(db),\n@@ -664,7 +664,7 @@ impl HasResolver for DefWithBodyId {\n }\n \n impl HasResolver for ContainerId {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         match self {\n             ContainerId::ModuleId(it) => it.resolver(db),\n             ContainerId::DefWithBodyId(it) => it.module(db).resolver(db),\n@@ -673,7 +673,7 @@ impl HasResolver for ContainerId {\n }\n \n impl HasResolver for AssocContainerId {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         match self {\n             AssocContainerId::ContainerId(it) => it.resolver(db),\n             AssocContainerId::TraitId(it) => it.resolver(db),\n@@ -683,7 +683,7 @@ impl HasResolver for AssocContainerId {\n }\n \n impl HasResolver for GenericDefId {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         match self {\n             GenericDefId::FunctionId(inner) => inner.resolver(db),\n             GenericDefId::AdtId(adt) => adt.resolver(db),\n@@ -697,7 +697,7 @@ impl HasResolver for GenericDefId {\n }\n \n impl HasResolver for VariantId {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         match self {\n             VariantId::EnumVariantId(it) => it.parent.resolver(db),\n             VariantId::StructId(it) => it.resolver(db),"}, {"sha": "46e90da7009194dd1a92c4306c0616a7e7ff081d", "filename": "crates/ra_hir_def/src/src.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fsrc.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -8,29 +8,29 @@ use crate::{db::DefDatabase, AssocItemLoc, ItemLoc};\n \n pub trait HasSource {\n     type Value;\n-    fn source(&self, db: &impl DefDatabase) -> InFile<Self::Value>;\n+    fn source(&self, db: &dyn DefDatabase) -> InFile<Self::Value>;\n }\n \n impl<N: AstNode> HasSource for AssocItemLoc<N> {\n     type Value = N;\n \n-    fn source(&self, db: &impl DefDatabase) -> InFile<N> {\n-        let node = self.ast_id.to_node(db);\n+    fn source(&self, db: &dyn DefDatabase) -> InFile<N> {\n+        let node = self.ast_id.to_node(db.upcast());\n         InFile::new(self.ast_id.file_id, node)\n     }\n }\n \n impl<N: AstNode> HasSource for ItemLoc<N> {\n     type Value = N;\n \n-    fn source(&self, db: &impl DefDatabase) -> InFile<N> {\n-        let node = self.ast_id.to_node(db);\n+    fn source(&self, db: &dyn DefDatabase) -> InFile<N> {\n+        let node = self.ast_id.to_node(db.upcast());\n         InFile::new(self.ast_id.file_id, node)\n     }\n }\n \n pub trait HasChildSource {\n     type ChildId;\n     type Value;\n-    fn child_source(&self, db: &impl DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>>;\n+    fn child_source(&self, db: &dyn DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>>;\n }"}, {"sha": "eb83dee799eb3ea30671373175c1ccc5b82dca88", "filename": "crates/ra_hir_def/src/test_db.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -5,8 +5,12 @@ use std::{\n     sync::{Arc, Mutex},\n };\n \n+use hir_expand::db::AstDatabase;\n+use ra_db::{\n+    salsa, CrateId, ExternSourceId, FileId, FileLoader, FileLoaderDelegate, RelativePath, Upcast,\n+};\n+\n use crate::db::DefDatabase;\n-use ra_db::{salsa, CrateId, ExternSourceId, FileId, FileLoader, FileLoaderDelegate, RelativePath};\n \n #[salsa::database(\n     ra_db::SourceDatabaseExtStorage,\n@@ -21,6 +25,18 @@ pub struct TestDB {\n     events: Mutex<Option<Vec<salsa::Event<TestDB>>>>,\n }\n \n+impl Upcast<dyn AstDatabase> for TestDB {\n+    fn upcast(&self) -> &(dyn AstDatabase + 'static) {\n+        &*self\n+    }\n+}\n+\n+impl Upcast<dyn DefDatabase> for TestDB {\n+    fn upcast(&self) -> &(dyn DefDatabase + 'static) {\n+        &*self\n+    }\n+}\n+\n impl salsa::Database for TestDB {\n     fn salsa_runtime(&self) -> &salsa::Runtime<Self> {\n         &self.runtime"}, {"sha": "62513873ef50d745835bc6f8749f33d48ff7e429", "filename": "crates/ra_hir_def/src/visibility.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -33,22 +33,22 @@ impl RawVisibility {\n     }\n \n     pub(crate) fn from_ast_with_default(\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         default: RawVisibility,\n         node: InFile<Option<ast::Visibility>>,\n     ) -> RawVisibility {\n         Self::from_ast_with_hygiene_and_default(\n             node.value,\n             default,\n-            &Hygiene::new(db, node.file_id),\n+            &Hygiene::new(db.upcast(), node.file_id),\n         )\n     }\n \n     pub(crate) fn from_ast(\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         node: InFile<Option<ast::Visibility>>,\n     ) -> RawVisibility {\n-        Self::from_ast_with_hygiene(node.value, &Hygiene::new(db, node.file_id))\n+        Self::from_ast_with_hygiene(node.value, &Hygiene::new(db.upcast(), node.file_id))\n     }\n \n     pub(crate) fn from_ast_with_hygiene(\n@@ -90,7 +90,7 @@ impl RawVisibility {\n \n     pub fn resolve(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &dyn DefDatabase,\n         resolver: &crate::resolver::Resolver,\n     ) -> Visibility {\n         // we fall back to public visibility (i.e. fail open) if the path can't be resolved\n@@ -108,7 +108,7 @@ pub enum Visibility {\n }\n \n impl Visibility {\n-    pub fn is_visible_from(self, db: &impl DefDatabase, from_module: ModuleId) -> bool {\n+    pub fn is_visible_from(self, db: &dyn DefDatabase, from_module: ModuleId) -> bool {\n         let to_module = match self {\n             Visibility::Module(m) => m,\n             Visibility::Public => return true,"}, {"sha": "c3e1c68b7aab8aa12bf746b52f6c20741e2ff7cb", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -77,7 +77,7 @@ pub trait AstDatabase: SourceDatabase {\n /// token. The `token_to_map` mapped down into the expansion, with the mapped\n /// token returned.\n pub fn expand_hypothetical(\n-    db: &impl AstDatabase,\n+    db: &dyn AstDatabase,\n     actual_macro_call: MacroCallId,\n     hypothetical_args: &ra_syntax::ast::TokenTree,\n     token_to_map: ra_syntax::SyntaxToken,"}, {"sha": "4cbce4df5b221b0fededfa9a9338c671cae196c2", "filename": "crates/ra_hir_expand/src/eager.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Feager.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -30,7 +30,7 @@ use ra_syntax::{algo::replace_descendants, SyntaxElement, SyntaxNode};\n use std::{collections::HashMap, sync::Arc};\n \n pub fn expand_eager_macro(\n-    db: &impl AstDatabase,\n+    db: &dyn AstDatabase,\n     macro_call: InFile<ast::MacroCall>,\n     def: MacroDefId,\n     resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n@@ -78,7 +78,7 @@ fn to_subtree(node: &SyntaxNode) -> Option<tt::Subtree> {\n }\n \n fn lazy_expand(\n-    db: &impl AstDatabase,\n+    db: &dyn AstDatabase,\n     def: &MacroDefId,\n     macro_call: InFile<ast::MacroCall>,\n ) -> Option<InFile<SyntaxNode>> {\n@@ -91,7 +91,7 @@ fn lazy_expand(\n }\n \n fn eager_macro_recur(\n-    db: &impl AstDatabase,\n+    db: &dyn AstDatabase,\n     curr: InFile<SyntaxNode>,\n     macro_resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n ) -> Option<SyntaxNode> {"}, {"sha": "dfbac494fe34f14693cc2f184d3285b9f1a03a08", "filename": "crates/ra_hir_expand/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -19,7 +19,7 @@ pub struct Hygiene {\n }\n \n impl Hygiene {\n-    pub fn new(db: &impl AstDatabase, file_id: HirFileId) -> Hygiene {\n+    pub fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Hygiene {\n         let def_crate = match file_id.0 {\n             HirFileIdRepr::FileId(_) => None,\n             HirFileIdRepr::MacroFile(macro_file) => match macro_file.macro_call_id {"}, {"sha": "6b59ea4c97fbc855e4ac0f9b24c20bfd5fc37e09", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -366,7 +366,7 @@ impl<T> InFile<T> {\n     pub fn as_ref(&self) -> InFile<&T> {\n         self.with_value(&self.value)\n     }\n-    pub fn file_syntax(&self, db: &impl db::AstDatabase) -> SyntaxNode {\n+    pub fn file_syntax(&self, db: &dyn db::AstDatabase) -> SyntaxNode {\n         db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")\n     }\n }\n@@ -387,7 +387,7 @@ impl<T> InFile<Option<T>> {\n impl InFile<SyntaxNode> {\n     pub fn ancestors_with_macros(\n         self,\n-        db: &impl crate::db::AstDatabase,\n+        db: &dyn db::AstDatabase,\n     ) -> impl Iterator<Item = InFile<SyntaxNode>> + '_ {\n         std::iter::successors(Some(self), move |node| match node.value.parent() {\n             Some(parent) => Some(node.with_value(parent)),\n@@ -402,7 +402,7 @@ impl InFile<SyntaxNode> {\n impl InFile<SyntaxToken> {\n     pub fn ancestors_with_macros(\n         self,\n-        db: &impl crate::db::AstDatabase,\n+        db: &dyn db::AstDatabase,\n     ) -> impl Iterator<Item = InFile<SyntaxNode>> + '_ {\n         self.map(|it| it.parent()).ancestors_with_macros(db)\n     }"}, {"sha": "53e81e85d84d46619bbcd84d6b72cd7ffc98f5a7", "filename": "crates/ra_hir_ty/src/autoderef.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -20,7 +20,7 @@ use crate::{\n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n \n pub fn autoderef<'a>(\n-    db: &'a impl HirDatabase,\n+    db: &'a dyn HirDatabase,\n     krate: Option<CrateId>,\n     ty: InEnvironment<Canonical<Ty>>,\n ) -> impl Iterator<Item = Canonical<Ty>> + 'a {\n@@ -32,7 +32,7 @@ pub fn autoderef<'a>(\n }\n \n pub(crate) fn deref(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     ty: InEnvironment<&Canonical<Ty>>,\n ) -> Option<Canonical<Ty>> {\n@@ -44,7 +44,7 @@ pub(crate) fn deref(\n }\n \n fn deref_by_trait(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     ty: InEnvironment<&Canonical<Ty>>,\n ) -> Option<Canonical<Ty>> {\n@@ -54,7 +54,7 @@ fn deref_by_trait(\n     };\n     let target = db.trait_data(deref_trait).associated_type_by_name(&name![Target])?;\n \n-    let generic_params = generics(db, target.into());\n+    let generic_params = generics(db.upcast(), target.into());\n     if generic_params.len() != 1 {\n         // the Target type + Deref trait should only have one generic parameter,\n         // namely Deref's Self type"}, {"sha": "11fc2ac3d19e5ba9ff4b8b31f5adcb41aea37f64", "filename": "crates/ra_hir_ty/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -7,7 +7,7 @@ use hir_def::{\n     VariantId,\n };\n use ra_arena::map::ArenaMap;\n-use ra_db::{impl_intern_key, salsa, CrateId};\n+use ra_db::{impl_intern_key, salsa, CrateId, Upcast};\n use ra_prof::profile;\n \n use crate::{\n@@ -20,7 +20,7 @@ use hir_expand::name::Name;\n \n #[salsa::query_group(HirDatabaseStorage)]\n #[salsa::requires(salsa::Database)]\n-pub trait HirDatabase: DefDatabase {\n+pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(infer_wait)]\n     fn infer(&self, def: DefWithBodyId) -> Arc<InferenceResult>;\n "}, {"sha": "a6ef44a31c32948c87682286f3d2c641950d8dbf", "filename": "crates/ra_hir_ty/src/display.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -9,8 +9,8 @@ use crate::{\n use hir_def::{generics::TypeParamProvenance, AdtId, AssocContainerId, Lookup};\n use hir_expand::name::Name;\n \n-pub struct HirFormatter<'a, 'b, DB> {\n-    pub db: &'a DB,\n+pub struct HirFormatter<'a, 'b> {\n+    pub db: &'a dyn HirDatabase,\n     fmt: &'a mut fmt::Formatter<'b>,\n     buf: String,\n     curr_size: usize,\n@@ -19,31 +19,28 @@ pub struct HirFormatter<'a, 'b, DB> {\n }\n \n pub trait HirDisplay {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result;\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result;\n \n-    fn display<'a, DB>(&'a self, db: &'a DB) -> HirDisplayWrapper<'a, DB, Self>\n+    fn display<'a>(&'a self, db: &'a dyn HirDatabase) -> HirDisplayWrapper<'a, Self>\n     where\n         Self: Sized,\n     {\n         HirDisplayWrapper(db, self, None, false)\n     }\n \n-    fn display_truncated<'a, DB>(\n+    fn display_truncated<'a>(\n         &'a self,\n-        db: &'a DB,\n+        db: &'a dyn HirDatabase,\n         max_size: Option<usize>,\n-    ) -> HirDisplayWrapper<'a, DB, Self>\n+    ) -> HirDisplayWrapper<'a, Self>\n     where\n         Self: Sized,\n     {\n         HirDisplayWrapper(db, self, max_size, true)\n     }\n }\n \n-impl<'a, 'b, DB> HirFormatter<'a, 'b, DB>\n-where\n-    DB: HirDatabase,\n-{\n+impl<'a, 'b> HirFormatter<'a, 'b> {\n     pub fn write_joined<T: HirDisplay>(\n         &mut self,\n         iter: impl IntoIterator<Item = T>,\n@@ -84,11 +81,10 @@ where\n     }\n }\n \n-pub struct HirDisplayWrapper<'a, DB, T>(&'a DB, &'a T, Option<usize>, bool);\n+pub struct HirDisplayWrapper<'a, T>(&'a dyn HirDatabase, &'a T, Option<usize>, bool);\n \n-impl<'a, DB, T> fmt::Display for HirDisplayWrapper<'a, DB, T>\n+impl<'a, T> fmt::Display for HirDisplayWrapper<'a, T>\n where\n-    DB: HirDatabase,\n     T: HirDisplay,\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -106,13 +102,13 @@ where\n const TYPE_HINT_TRUNCATION: &str = \"\u2026\";\n \n impl HirDisplay for &Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n         HirDisplay::hir_fmt(*self, f)\n     }\n }\n \n impl HirDisplay for ApplicationTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -178,7 +174,7 @@ impl HirDisplay for ApplicationTy {\n                     }\n                 }\n                 if self.parameters.len() > 0 {\n-                    let generics = generics(f.db, def.into());\n+                    let generics = generics(f.db.upcast(), def.into());\n                     let (parent_params, self_param, type_params, _impl_trait_params) =\n                         generics.provenance_split();\n                     let total_len = parent_params + self_param + type_params;\n@@ -238,7 +234,7 @@ impl HirDisplay for ApplicationTy {\n                 }\n             }\n             TypeCtor::AssociatedType(type_alias) => {\n-                let trait_ = match type_alias.lookup(f.db).container {\n+                let trait_ = match type_alias.lookup(f.db.upcast()).container {\n                     AssocContainerId::TraitId(it) => it,\n                     _ => panic!(\"not an associated type\"),\n                 };\n@@ -272,7 +268,7 @@ impl HirDisplay for ApplicationTy {\n }\n \n impl HirDisplay for ProjectionTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -290,7 +286,7 @@ impl HirDisplay for ProjectionTy {\n }\n \n impl HirDisplay for Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -299,7 +295,7 @@ impl HirDisplay for Ty {\n             Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n             Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n             Ty::Placeholder(id) => {\n-                let generics = generics(f.db, id.parent);\n+                let generics = generics(f.db.upcast(), id.parent);\n                 let param_data = &generics.params.types[id.local_id];\n                 match param_data.provenance {\n                     TypeParamProvenance::TypeParamList | TypeParamProvenance::TraitSelf => {\n@@ -334,7 +330,7 @@ impl HirDisplay for Ty {\n \n fn write_bounds_like_dyn_trait(\n     predicates: &[GenericPredicate],\n-    f: &mut HirFormatter<impl HirDatabase>,\n+    f: &mut HirFormatter,\n ) -> fmt::Result {\n     // Note: This code is written to produce nice results (i.e.\n     // corresponding to surface Rust) for types that can occur in\n@@ -398,7 +394,7 @@ fn write_bounds_like_dyn_trait(\n }\n \n impl TraitRef {\n-    fn hir_fmt_ext(&self, f: &mut HirFormatter<impl HirDatabase>, use_as: bool) -> fmt::Result {\n+    fn hir_fmt_ext(&self, f: &mut HirFormatter, use_as: bool) -> fmt::Result {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -420,19 +416,19 @@ impl TraitRef {\n }\n \n impl HirDisplay for TraitRef {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n         self.hir_fmt_ext(f, false)\n     }\n }\n \n impl HirDisplay for &GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n         HirDisplay::hir_fmt(*self, f)\n     }\n }\n \n impl HirDisplay for GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -456,7 +452,7 @@ impl HirDisplay for GenericPredicate {\n }\n \n impl HirDisplay for Obligation {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n         match self {\n             Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db)),\n             Obligation::Projection(proj) => write!("}, {"sha": "b7b476b4c19b6d8fa7a2b549621d18bee6e34e47", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         ExprValidator { func, infer, sink }\n     }\n \n-    pub fn validate_body(&mut self, db: &impl HirDatabase) {\n+    pub fn validate_body(&mut self, db: &dyn HirDatabase) {\n         let body = db.body(self.func.into());\n \n         for e in body.exprs.iter() {\n@@ -67,7 +67,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         _path: &Option<Path>,\n         fields: &[RecordLitField],\n         spread: Option<ExprId>,\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n     ) {\n         if spread.is_some() {\n             return;\n@@ -80,7 +80,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             return;\n         }\n \n-        let variant_data = variant_data(db, variant_def);\n+        let variant_data = variant_data(db.upcast(), variant_def);\n \n         let lit_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();\n         let missed_fields: Vec<Name> = variant_data\n@@ -102,7 +102,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n         if let Ok(source_ptr) = source_map.expr_syntax(id) {\n             if let Some(expr) = source_ptr.value.left() {\n-                let root = source_ptr.file_syntax(db);\n+                let root = source_ptr.file_syntax(db.upcast());\n                 if let ast::Expr::RecordLit(record_lit) = expr.to_node(&root) {\n                     if let Some(field_list) = record_lit.record_field_list() {\n                         self.sink.push(MissingFields {\n@@ -116,12 +116,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n     }\n \n-    fn validate_results_in_tail_expr(\n-        &mut self,\n-        body_id: ExprId,\n-        id: ExprId,\n-        db: &impl HirDatabase,\n-    ) {\n+    fn validate_results_in_tail_expr(&mut self, body_id: ExprId, id: ExprId, db: &dyn HirDatabase) {\n         // the mismatch will be on the whole block currently\n         let mismatch = match self.infer.type_mismatch_for_expr(body_id) {\n             Some(m) => m,\n@@ -130,8 +125,8 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n         let std_result_path = path![std::result::Result];\n \n-        let resolver = self.func.resolver(db);\n-        let std_result_enum = match resolver.resolve_known_enum(db, &std_result_path) {\n+        let resolver = self.func.resolver(db.upcast());\n+        let std_result_enum = match resolver.resolve_known_enum(db.upcast(), &std_result_path) {\n             Some(it) => it,\n             _ => return,\n         };"}, {"sha": "246b0e9be2f947c24d0944cab66e94c390dc6153", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -63,9 +63,9 @@ mod pat;\n mod coerce;\n \n /// The entry point of type inference.\n-pub(crate) fn infer_query(db: &impl HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {\n+pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {\n     let _p = profile(\"infer_query\");\n-    let resolver = def.resolver(db);\n+    let resolver = def.resolver(db.upcast());\n     let mut ctx = InferenceContext::new(db, def, resolver);\n \n     match def {\n@@ -164,7 +164,7 @@ impl InferenceResult {\n     }\n     pub fn add_diagnostics(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         owner: FunctionId,\n         sink: &mut DiagnosticSink,\n     ) {\n@@ -190,8 +190,8 @@ impl Index<PatId> for InferenceResult {\n \n /// The inference context contains all information needed during type inference.\n #[derive(Clone, Debug)]\n-struct InferenceContext<'a, D: HirDatabase> {\n-    db: &'a D,\n+struct InferenceContext<'a> {\n+    db: &'a dyn HirDatabase,\n     owner: DefWithBodyId,\n     body: Arc<Body>,\n     resolver: Resolver,\n@@ -208,8 +208,8 @@ struct InferenceContext<'a, D: HirDatabase> {\n     return_ty: Ty,\n }\n \n-impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n-    fn new(db: &'a D, owner: DefWithBodyId, resolver: Resolver) -> Self {\n+impl<'a> InferenceContext<'a> {\n+    fn new(db: &'a dyn HirDatabase, owner: DefWithBodyId, resolver: Resolver) -> Self {\n         InferenceContext {\n             result: InferenceResult::default(),\n             table: unify::InferenceTable::new(),\n@@ -425,7 +425,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         // FIXME: this should resolve assoc items as well, see this example:\n         // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n-        return match resolver.resolve_path_in_type_ns_fully(self.db, path.mod_path()) {\n+        return match resolver.resolve_path_in_type_ns_fully(self.db.upcast(), path.mod_path()) {\n             Some(TypeNs::AdtId(AdtId::StructId(strukt))) => {\n                 let substs = Ty::substs_from_path(&ctx, path, strukt.into());\n                 let ty = self.db.ty(strukt.into());\n@@ -439,7 +439,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 (ty, Some(var.into()))\n             }\n             Some(TypeNs::SelfType(impl_id)) => {\n-                let generics = crate::utils::generics(self.db, impl_id.into());\n+                let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n                 let substs = Substs::type_params_for_generics(&generics);\n                 let ty = self.db.impl_self_ty(impl_id).subst(&substs);\n                 let variant = ty_variant(&ty);\n@@ -500,13 +500,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n         let path = path![std::iter::IntoIterator];\n-        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n     }\n \n     fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n         let path = path![std::ops::Try];\n-        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Ok])\n     }\n \n@@ -532,37 +532,37 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn resolve_range_full(&self) -> Option<AdtId> {\n         let path = path![std::ops::RangeFull];\n-        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range(&self) -> Option<AdtId> {\n         let path = path![std::ops::Range];\n-        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_inclusive(&self) -> Option<AdtId> {\n         let path = path![std::ops::RangeInclusive];\n-        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_from(&self) -> Option<AdtId> {\n         let path = path![std::ops::RangeFrom];\n-        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_to(&self) -> Option<AdtId> {\n         let path = path![std::ops::RangeTo];\n-        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_to_inclusive(&self) -> Option<AdtId> {\n         let path = path![std::ops::RangeToInclusive];\n-        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n+        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n@@ -676,13 +676,13 @@ mod diagnostics {\n     impl InferenceDiagnostic {\n         pub(super) fn add_to(\n             &self,\n-            db: &impl HirDatabase,\n+            db: &dyn HirDatabase,\n             owner: FunctionId,\n             sink: &mut DiagnosticSink,\n         ) {\n             match self {\n                 InferenceDiagnostic::NoSuchField { expr, field } => {\n-                    let file = owner.lookup(db).source(db).file_id;\n+                    let file = owner.lookup(db.upcast()).source(db.upcast()).file_id;\n                     let (_, source_map) = db.body_with_source_map(owner.into());\n                     let field = source_map.field_syntax(*expr, *field);\n                     sink.push(NoSuchField { file, field })"}, {"sha": "959b1e212400728d58d46b2247b07e87ed5faffd", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -7,13 +7,11 @@\n use hir_def::{lang_item::LangItemTarget, type_ref::Mutability};\n use test_utils::tested_by;\n \n-use crate::{\n-    autoderef, db::HirDatabase, traits::Solution, Obligation, Substs, TraitRef, Ty, TypeCtor,\n-};\n+use crate::{autoderef, traits::Solution, Obligation, Substs, TraitRef, Ty, TypeCtor};\n \n use super::{unify::TypeVarValue, InEnvironment, InferTy, InferenceContext};\n \n-impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n+impl<'a> InferenceContext<'a> {\n     /// Unify two types, but may coerce the first one to the second one\n     /// using \"implicit coercion rules\" if needed.\n     pub(super) fn coerce(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n@@ -126,7 +124,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             _ => return None,\n         };\n \n-        let generic_params = crate::utils::generics(self.db, coerce_unsized_trait.into());\n+        let generic_params = crate::utils::generics(self.db.upcast(), coerce_unsized_trait.into());\n         if generic_params.len() != 2 {\n             // The CoerceUnsized trait should have two generic params: Self and T.\n             return None;"}, {"sha": "1fdb235a090a6b8df3e155f3d7fea6aa157ddbe7", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -14,9 +14,7 @@ use hir_expand::name::Name;\n use ra_syntax::ast::RangeOp;\n \n use crate::{\n-    autoderef,\n-    db::HirDatabase,\n-    method_resolution, op,\n+    autoderef, method_resolution, op,\n     traits::InEnvironment,\n     utils::{generics, variant_data, Generics},\n     ApplicationTy, Binders, CallableDef, InferTy, IntTy, Mutability, Obligation, Substs, TraitRef,\n@@ -25,7 +23,7 @@ use crate::{\n \n use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n \n-impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n+impl<'a> InferenceContext<'a> {\n     pub(super) fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(tgt_expr, expected);\n         let could_unify = self.unify(&ty, &expected.ty);\n@@ -184,7 +182,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n-                let resolver = resolver_for_expr(self.db, self.owner, tgt_expr);\n+                let resolver = resolver_for_expr(self.db.upcast(), self.owner, tgt_expr);\n                 self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n             }\n             Expr::Continue => Ty::simple(TypeCtor::Never),\n@@ -214,7 +212,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 let substs = ty.substs().unwrap_or_else(Substs::empty);\n                 let field_types = def_id.map(|it| self.db.field_types(it)).unwrap_or_default();\n-                let variant_data = def_id.map(|it| variant_data(self.db, it));\n+                let variant_data = def_id.map(|it| variant_data(self.db.upcast(), it));\n                 for (field_idx, field) in fields.iter().enumerate() {\n                     let field_def =\n                         variant_data.as_ref().and_then(|it| match it.field(&field.name) {\n@@ -579,7 +577,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let receiver_ty = self.infer_expr(receiver, &Expectation::none());\n         let canonicalized_receiver = self.canonicalizer().canonicalize_ty(receiver_ty.clone());\n \n-        let traits_in_scope = self.resolver.traits_in_scope(self.db);\n+        let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n \n         let resolved = self.resolver.krate().and_then(|krate| {\n             method_resolution::lookup_method(\n@@ -595,7 +593,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Some((ty, func)) => {\n                 let ty = canonicalized_receiver.decanonicalize_ty(ty);\n                 self.write_method_resolution(tgt_expr, func);\n-                (ty, self.db.value_ty(func.into()), Some(generics(self.db, func.into())))\n+                (ty, self.db.value_ty(func.into()), Some(generics(self.db.upcast(), func.into())))\n             }\n             None => (receiver_ty, Binders::new(0, Ty::Unknown), None),\n         };\n@@ -703,10 +701,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // add obligation for trait implementation, if this is a trait method\n                 match def {\n                     CallableDef::FunctionId(f) => {\n-                        if let AssocContainerId::TraitId(trait_) = f.lookup(self.db).container {\n+                        if let AssocContainerId::TraitId(trait_) =\n+                            f.lookup(self.db.upcast()).container\n+                        {\n                             // construct a TraitDef\n-                            let substs =\n-                                a_ty.parameters.prefix(generics(self.db, trait_.into()).len());\n+                            let substs = a_ty\n+                                .parameters\n+                                .prefix(generics(self.db.upcast(), trait_.into()).len());\n                             self.obligations.push(Obligation::Trait(TraitRef { trait_, substs }));\n                         }\n                     }"}, {"sha": "baed6225b0b156cce99a9178451ba9dd417ecb2b", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -12,9 +12,9 @@ use hir_expand::name::Name;\n use test_utils::tested_by;\n \n use super::{BindingMode, InferenceContext};\n-use crate::{db::HirDatabase, utils::variant_data, Substs, Ty, TypeCtor};\n+use crate::{utils::variant_data, Substs, Ty, TypeCtor};\n \n-impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n+impl<'a> InferenceContext<'a> {\n     fn infer_tuple_struct_pat(\n         &mut self,\n         path: Option<&Path>,\n@@ -23,7 +23,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         default_bm: BindingMode,\n     ) -> Ty {\n         let (ty, def) = self.resolve_variant(path);\n-        let var_data = def.map(|it| variant_data(self.db, it));\n+        let var_data = def.map(|it| variant_data(self.db.upcast(), it));\n         self.unify(&ty, expected);\n \n         let substs = ty.substs().unwrap_or_else(Substs::empty);\n@@ -51,7 +51,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         id: PatId,\n     ) -> Ty {\n         let (ty, def) = self.resolve_variant(path);\n-        let var_data = def.map(|it| variant_data(self.db, it));\n+        let var_data = def.map(|it| variant_data(self.db.upcast(), it));\n         if let Some(variant) = def {\n             self.write_variant_resolution(id.into(), variant);\n         }"}, {"sha": "318652c6113bb08b1a785b6ed090965829207375", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -9,11 +9,11 @@ use hir_def::{\n };\n use hir_expand::name::Name;\n \n-use crate::{db::HirDatabase, method_resolution, Substs, Ty, ValueTyDefId};\n+use crate::{method_resolution, Substs, Ty, ValueTyDefId};\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n \n-impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n+impl<'a> InferenceContext<'a> {\n     pub(super) fn infer_path(\n         &mut self,\n         resolver: &Resolver,\n@@ -47,7 +47,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 id,\n             )?\n         } else {\n-            let value_or_partial = resolver.resolve_path_in_value_ns(self.db, path.mod_path())?;\n+            let value_or_partial =\n+                resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path())?;\n \n             match value_or_partial {\n                 ResolveValueResult::ValueNs(it) => (it, None),\n@@ -192,7 +193,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         let canonical_ty = self.canonicalizer().canonicalize_ty(ty.clone());\n         let krate = self.resolver.krate()?;\n-        let traits_in_scope = self.resolver.traits_in_scope(self.db);\n+        let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n \n         method_resolution::iterate_method_candidates(\n             &canonical_ty.value,\n@@ -205,9 +206,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             move |_ty, item| {\n                 let (def, container) = match item {\n                     AssocItemId::FunctionId(f) => {\n-                        (ValueNs::FunctionId(f), f.lookup(self.db).container)\n+                        (ValueNs::FunctionId(f), f.lookup(self.db.upcast()).container)\n+                    }\n+                    AssocItemId::ConstId(c) => {\n+                        (ValueNs::ConstId(c), c.lookup(self.db.upcast()).container)\n                     }\n-                    AssocItemId::ConstId(c) => (ValueNs::ConstId(c), c.lookup(self.db).container),\n                     AssocItemId::TypeAliasId(_) => unreachable!(),\n                 };\n                 let substs = match container {"}, {"sha": "0bf8fbd630c9e0f4675a487a8febc78a9a842497", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -7,22 +7,22 @@ use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n use test_utils::tested_by;\n \n use super::{InferenceContext, Obligation};\n-use crate::{db::HirDatabase, Canonical, InEnvironment, InferTy, Substs, Ty, TypeCtor, TypeWalk};\n+use crate::{Canonical, InEnvironment, InferTy, Substs, Ty, TypeCtor, TypeWalk};\n \n-impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n-    pub(super) fn canonicalizer<'b>(&'b mut self) -> Canonicalizer<'a, 'b, D>\n+impl<'a> InferenceContext<'a> {\n+    pub(super) fn canonicalizer<'b>(&'b mut self) -> Canonicalizer<'a, 'b>\n     where\n         'a: 'b,\n     {\n         Canonicalizer { ctx: self, free_vars: Vec::new(), var_stack: Vec::new() }\n     }\n }\n \n-pub(super) struct Canonicalizer<'a, 'b, D: HirDatabase>\n+pub(super) struct Canonicalizer<'a, 'b>\n where\n     'a: 'b,\n {\n-    ctx: &'b mut InferenceContext<'a, D>,\n+    ctx: &'b mut InferenceContext<'a>,\n     free_vars: Vec<InferTy>,\n     /// A stack of type variables that is used to detect recursive types (which\n     /// are an error, but we need to protect against them to avoid stack\n@@ -35,7 +35,7 @@ pub(super) struct Canonicalized<T> {\n     free_vars: Vec<InferTy>,\n }\n \n-impl<'a, 'b, D: HirDatabase> Canonicalizer<'a, 'b, D>\n+impl<'a, 'b> Canonicalizer<'a, 'b>\n where\n     'a: 'b,\n {\n@@ -123,11 +123,7 @@ impl<T> Canonicalized<T> {\n         ty\n     }\n \n-    pub fn apply_solution(\n-        &self,\n-        ctx: &mut InferenceContext<'_, impl HirDatabase>,\n-        solution: Canonical<Vec<Ty>>,\n-    ) {\n+    pub fn apply_solution(&self, ctx: &mut InferenceContext<'_>, solution: Canonical<Vec<Ty>>) {\n         // the solution may contain new variables, which we need to convert to new inference vars\n         let new_vars = Substs((0..solution.num_vars).map(|_| ctx.table.new_type_var()).collect());\n         for (i, ty) in solution.value.into_iter().enumerate() {"}, {"sha": "6c5469ecdf0efc4e377c1e07e04759323c3ca7b4", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -152,7 +152,7 @@ pub struct TypeCtorId(salsa::InternId);\n impl_intern_key!(TypeCtorId);\n \n impl TypeCtor {\n-    pub fn num_ty_params(self, db: &impl HirDatabase) -> usize {\n+    pub fn num_ty_params(self, db: &dyn HirDatabase) -> usize {\n         match self {\n             TypeCtor::Bool\n             | TypeCtor::Char\n@@ -167,23 +167,23 @@ impl TypeCtor {\n             | TypeCtor::Closure { .. } // 1 param representing the signature of the closure\n             => 1,\n             TypeCtor::Adt(adt) => {\n-                let generic_params = generics(db, adt.into());\n+                let generic_params = generics(db.upcast(), adt.into());\n                 generic_params.len()\n             }\n             TypeCtor::FnDef(callable) => {\n-                let generic_params = generics(db, callable.into());\n+                let generic_params = generics(db.upcast(), callable.into());\n                 generic_params.len()\n             }\n             TypeCtor::AssociatedType(type_alias) => {\n-                let generic_params = generics(db, type_alias.into());\n+                let generic_params = generics(db.upcast(), type_alias.into());\n                 generic_params.len()\n             }\n             TypeCtor::FnPtr { num_args } => num_args as usize + 1,\n             TypeCtor::Tuple { cardinality } => cardinality as usize,\n         }\n     }\n \n-    pub fn krate(self, db: &impl HirDatabase) -> Option<CrateId> {\n+    pub fn krate(self, db: &dyn HirDatabase) -> Option<CrateId> {\n         match self {\n             TypeCtor::Bool\n             | TypeCtor::Char\n@@ -199,9 +199,11 @@ impl TypeCtor {\n             | TypeCtor::Tuple { .. } => None,\n             // Closure's krate is irrelevant for coherence I would think?\n             TypeCtor::Closure { .. } => None,\n-            TypeCtor::Adt(adt) => Some(adt.module(db).krate),\n+            TypeCtor::Adt(adt) => Some(adt.module(db.upcast()).krate),\n             TypeCtor::FnDef(callable) => Some(callable.krate(db)),\n-            TypeCtor::AssociatedType(type_alias) => Some(type_alias.lookup(db).module(db).krate),\n+            TypeCtor::AssociatedType(type_alias) => {\n+                Some(type_alias.lookup(db.upcast()).module(db.upcast()).krate)\n+            }\n         }\n     }\n \n@@ -246,12 +248,12 @@ pub struct ProjectionTy {\n }\n \n impl ProjectionTy {\n-    pub fn trait_ref(&self, db: &impl HirDatabase) -> TraitRef {\n+    pub fn trait_ref(&self, db: &dyn HirDatabase) -> TraitRef {\n         TraitRef { trait_: self.trait_(db), substs: self.parameters.clone() }\n     }\n \n-    fn trait_(&self, db: &impl HirDatabase) -> TraitId {\n-        match self.associated_ty.lookup(db).container {\n+    fn trait_(&self, db: &dyn HirDatabase) -> TraitId {\n+        match self.associated_ty.lookup(db.upcast()).container {\n             AssocContainerId::TraitId(it) => it,\n             _ => panic!(\"projection ty without parent trait\"),\n         }\n@@ -372,8 +374,8 @@ impl Substs {\n     }\n \n     /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n-    pub fn type_params(db: &impl HirDatabase, def: impl Into<GenericDefId>) -> Substs {\n-        let params = generics(db, def.into());\n+    pub fn type_params(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> Substs {\n+        let params = generics(db.upcast(), def.into());\n         Substs::type_params_for_generics(&params)\n     }\n \n@@ -382,9 +384,9 @@ impl Substs {\n         Substs(generic_params.iter().enumerate().map(|(idx, _)| Ty::Bound(idx as u32)).collect())\n     }\n \n-    pub fn build_for_def(db: &impl HirDatabase, def: impl Into<GenericDefId>) -> SubstsBuilder {\n+    pub fn build_for_def(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> SubstsBuilder {\n         let def = def.into();\n-        let params = generics(db, def);\n+        let params = generics(db.upcast(), def);\n         let param_count = params.len();\n         Substs::builder(param_count)\n     }\n@@ -393,7 +395,7 @@ impl Substs {\n         Substs::builder(generic_params.len())\n     }\n \n-    pub fn build_for_type_ctor(db: &impl HirDatabase, type_ctor: TypeCtor) -> SubstsBuilder {\n+    pub fn build_for_type_ctor(db: &dyn HirDatabase, type_ctor: TypeCtor) -> SubstsBuilder {\n         Substs::builder(type_ctor.num_ty_params(db))\n     }\n \n@@ -538,7 +540,7 @@ impl GenericPredicate {\n         }\n     }\n \n-    pub fn trait_ref(&self, db: &impl HirDatabase) -> Option<TraitRef> {\n+    pub fn trait_ref(&self, db: &dyn HirDatabase) -> Option<TraitRef> {\n         match self {\n             GenericPredicate::Implemented(tr) => Some(tr.clone()),\n             GenericPredicate::Projection(proj) => Some(proj.projection_ty.trait_ref(db)),\n@@ -693,7 +695,7 @@ impl Ty {\n         }\n     }\n \n-    fn callable_sig(&self, db: &impl HirDatabase) -> Option<FnSig> {\n+    fn callable_sig(&self, db: &dyn HirDatabase) -> Option<FnSig> {\n         match self {\n             Ty::Apply(a_ty) => match a_ty.ctor {\n                 TypeCtor::FnPtr { .. } => Some(FnSig::from_fn_ptr_substs(&a_ty.parameters)),"}, {"sha": "d7f250783e8a4f5ce4eee9895cd4f2bb8ec7a693", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 108, "deletions": 112, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -34,8 +34,8 @@ use crate::{\n };\n \n #[derive(Debug)]\n-pub struct TyLoweringContext<'a, DB: HirDatabase> {\n-    pub db: &'a DB,\n+pub struct TyLoweringContext<'a> {\n+    pub db: &'a dyn HirDatabase,\n     pub resolver: &'a Resolver,\n     /// Note: Conceptually, it's thinkable that we could be in a location where\n     /// some type params should be represented as placeholders, and others\n@@ -46,8 +46,8 @@ pub struct TyLoweringContext<'a, DB: HirDatabase> {\n     pub impl_trait_counter: std::cell::Cell<u16>,\n }\n \n-impl<'a, DB: HirDatabase> TyLoweringContext<'a, DB> {\n-    pub fn new(db: &'a DB, resolver: &'a Resolver) -> Self {\n+impl<'a> TyLoweringContext<'a> {\n+    pub fn new(db: &'a dyn HirDatabase, resolver: &'a Resolver) -> Self {\n         let impl_trait_counter = std::cell::Cell::new(0);\n         let impl_trait_mode = ImplTraitLoweringMode::Disallowed;\n         let type_param_mode = TypeParamLoweringMode::Placeholder;\n@@ -90,13 +90,10 @@ pub enum TypeParamLoweringMode {\n }\n \n impl Ty {\n-    pub fn from_hir(ctx: &TyLoweringContext<'_, impl HirDatabase>, type_ref: &TypeRef) -> Self {\n+    pub fn from_hir(ctx: &TyLoweringContext<'_>, type_ref: &TypeRef) -> Self {\n         Ty::from_hir_ext(ctx, type_ref).0\n     }\n-    pub fn from_hir_ext(\n-        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n-        type_ref: &TypeRef,\n-    ) -> (Self, Option<TypeNs>) {\n+    pub fn from_hir_ext(ctx: &TyLoweringContext<'_>, type_ref: &TypeRef) -> (Self, Option<TypeNs>) {\n         let mut res = None;\n         let ty = match type_ref {\n             TypeRef::Never => Ty::simple(TypeCtor::Never),\n@@ -157,7 +154,7 @@ impl Ty {\n                         let idx = ctx.impl_trait_counter.get();\n                         ctx.impl_trait_counter.set(idx + 1);\n                         if let Some(def) = ctx.resolver.generic_def() {\n-                            let generics = generics(ctx.db, def);\n+                            let generics = generics(ctx.db.upcast(), def);\n                             let param = generics\n                                 .iter()\n                                 .filter(|(_, data)| {\n@@ -175,7 +172,7 @@ impl Ty {\n                         ctx.impl_trait_counter.set(idx + 1);\n                         let (parent_params, self_params, list_params, _impl_trait_params) =\n                             if let Some(def) = ctx.resolver.generic_def() {\n-                                let generics = generics(ctx.db, def);\n+                                let generics = generics(ctx.db.upcast(), def);\n                                 generics.provenance_split()\n                             } else {\n                                 (0, 0, 0, 0)\n@@ -201,10 +198,7 @@ impl Ty {\n     /// This is only for `generic_predicates_for_param`, where we can't just\n     /// lower the self types of the predicates since that could lead to cycles.\n     /// So we just check here if the `type_ref` resolves to a generic param, and which.\n-    fn from_hir_only_param(\n-        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n-        type_ref: &TypeRef,\n-    ) -> Option<TypeParamId> {\n+    fn from_hir_only_param(ctx: &TyLoweringContext<'_>, type_ref: &TypeRef) -> Option<TypeParamId> {\n         let path = match type_ref {\n             TypeRef::Path(path) => path,\n             _ => return None,\n@@ -215,10 +209,11 @@ impl Ty {\n         if path.segments().len() > 1 {\n             return None;\n         }\n-        let resolution = match ctx.resolver.resolve_path_in_type_ns(ctx.db, path.mod_path()) {\n-            Some((it, None)) => it,\n-            _ => return None,\n-        };\n+        let resolution =\n+            match ctx.resolver.resolve_path_in_type_ns(ctx.db.upcast(), path.mod_path()) {\n+                Some((it, None)) => it,\n+                _ => return None,\n+            };\n         if let TypeNs::GenericParam(param_id) = resolution {\n             Some(param_id)\n         } else {\n@@ -227,7 +222,7 @@ impl Ty {\n     }\n \n     pub(crate) fn from_type_relative_path(\n-        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n+        ctx: &TyLoweringContext<'_>,\n         ty: Ty,\n         // We need the original resolution to lower `Self::AssocTy` correctly\n         res: Option<TypeNs>,\n@@ -246,7 +241,7 @@ impl Ty {\n     }\n \n     pub(crate) fn from_partly_resolved_hir_path(\n-        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n+        ctx: &TyLoweringContext<'_>,\n         resolution: TypeNs,\n         resolved_segment: PathSegment<'_>,\n         remaining_segments: PathSegments<'_>,\n@@ -260,7 +255,7 @@ impl Ty {\n                 let ty = if remaining_segments.len() == 1 {\n                     let segment = remaining_segments.first().unwrap();\n                     let associated_ty = associated_type_by_name_including_super_traits(\n-                        ctx.db,\n+                        ctx.db.upcast(),\n                         trait_ref.trait_,\n                         &segment.name,\n                     );\n@@ -286,8 +281,10 @@ impl Ty {\n                 return (ty, None);\n             }\n             TypeNs::GenericParam(param_id) => {\n-                let generics =\n-                    generics(ctx.db, ctx.resolver.generic_def().expect(\"generics in scope\"));\n+                let generics = generics(\n+                    ctx.db.upcast(),\n+                    ctx.resolver.generic_def().expect(\"generics in scope\"),\n+                );\n                 match ctx.type_param_mode {\n                     TypeParamLoweringMode::Placeholder => Ty::Placeholder(param_id),\n                     TypeParamLoweringMode::Variable => {\n@@ -297,7 +294,7 @@ impl Ty {\n                 }\n             }\n             TypeNs::SelfType(impl_id) => {\n-                let generics = generics(ctx.db, impl_id.into());\n+                let generics = generics(ctx.db.upcast(), impl_id.into());\n                 let substs = match ctx.type_param_mode {\n                     TypeParamLoweringMode::Placeholder => {\n                         Substs::type_params_for_generics(&generics)\n@@ -307,7 +304,7 @@ impl Ty {\n                 ctx.db.impl_self_ty(impl_id).subst(&substs)\n             }\n             TypeNs::AdtSelfType(adt) => {\n-                let generics = generics(ctx.db, adt.into());\n+                let generics = generics(ctx.db.upcast(), adt.into());\n                 let substs = match ctx.type_param_mode {\n                     TypeParamLoweringMode::Placeholder => {\n                         Substs::type_params_for_generics(&generics)\n@@ -327,17 +324,14 @@ impl Ty {\n         Ty::from_type_relative_path(ctx, ty, Some(resolution), remaining_segments)\n     }\n \n-    pub(crate) fn from_hir_path(\n-        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n-        path: &Path,\n-    ) -> (Ty, Option<TypeNs>) {\n+    pub(crate) fn from_hir_path(ctx: &TyLoweringContext<'_>, path: &Path) -> (Ty, Option<TypeNs>) {\n         // Resolve the path (in type namespace)\n         if let Some(type_ref) = path.type_anchor() {\n             let (ty, res) = Ty::from_hir_ext(ctx, &type_ref);\n             return Ty::from_type_relative_path(ctx, ty, res, path.segments());\n         }\n         let (resolution, remaining_index) =\n-            match ctx.resolver.resolve_path_in_type_ns(ctx.db, path.mod_path()) {\n+            match ctx.resolver.resolve_path_in_type_ns(ctx.db.upcast(), path.mod_path()) {\n                 Some(it) => it,\n                 None => return (Ty::Unknown, None),\n             };\n@@ -352,7 +346,7 @@ impl Ty {\n     }\n \n     fn select_associated_type(\n-        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n+        ctx: &TyLoweringContext<'_>,\n         self_ty: Ty,\n         res: Option<TypeNs>,\n         segment: PathSegment<'_>,\n@@ -374,7 +368,7 @@ impl Ty {\n             }\n             _ => return Ty::Unknown,\n         };\n-        let traits = traits_from_env.into_iter().flat_map(|t| all_super_traits(ctx.db, t));\n+        let traits = traits_from_env.into_iter().flat_map(|t| all_super_traits(ctx.db.upcast(), t));\n         for t in traits {\n             if let Some(associated_ty) = ctx.db.trait_data(t).associated_type_by_name(&segment.name)\n             {\n@@ -388,7 +382,7 @@ impl Ty {\n     }\n \n     fn from_hir_path_inner(\n-        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n+        ctx: &TyLoweringContext<'_>,\n         segment: PathSegment<'_>,\n         typable: TyDefId,\n     ) -> Ty {\n@@ -404,7 +398,7 @@ impl Ty {\n     /// Collect generic arguments from a path into a `Substs`. See also\n     /// `create_substs_for_ast_path` and `def_to_ty` in rustc.\n     pub(super) fn substs_from_path(\n-        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n+        ctx: &TyLoweringContext<'_>,\n         path: &Path,\n         // Note that we don't call `db.value_type(resolved)` here,\n         // `ValueTyDefId` is just a convenient way to pass generics and\n@@ -437,13 +431,13 @@ impl Ty {\n }\n \n pub(super) fn substs_from_path_segment(\n-    ctx: &TyLoweringContext<'_, impl HirDatabase>,\n+    ctx: &TyLoweringContext<'_>,\n     segment: PathSegment<'_>,\n     def_generic: Option<GenericDefId>,\n     _add_self_param: bool,\n ) -> Substs {\n     let mut substs = Vec::new();\n-    let def_generics = def_generic.map(|def| generics(ctx.db, def));\n+    let def_generics = def_generic.map(|def| generics(ctx.db.upcast(), def));\n \n     let (parent_params, self_params, type_params, impl_trait_params) =\n         def_generics.map_or((0, 0, 0, 0), |g| g.provenance_split());\n@@ -489,20 +483,21 @@ pub(super) fn substs_from_path_segment(\n \n impl TraitRef {\n     fn from_path(\n-        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n+        ctx: &TyLoweringContext<'_>,\n         path: &Path,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n-        let resolved = match ctx.resolver.resolve_path_in_type_ns_fully(ctx.db, path.mod_path())? {\n-            TypeNs::TraitId(tr) => tr,\n-            _ => return None,\n-        };\n+        let resolved =\n+            match ctx.resolver.resolve_path_in_type_ns_fully(ctx.db.upcast(), path.mod_path())? {\n+                TypeNs::TraitId(tr) => tr,\n+                _ => return None,\n+            };\n         let segment = path.segments().last().expect(\"path should have at least one segment\");\n         Some(TraitRef::from_resolved_path(ctx, resolved, segment, explicit_self_ty))\n     }\n \n     pub(crate) fn from_resolved_path(\n-        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n+        ctx: &TyLoweringContext<'_>,\n         resolved: TraitId,\n         segment: PathSegment<'_>,\n         explicit_self_ty: Option<Ty>,\n@@ -515,7 +510,7 @@ impl TraitRef {\n     }\n \n     fn from_hir(\n-        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n+        ctx: &TyLoweringContext<'_>,\n         type_ref: &TypeRef,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n@@ -527,7 +522,7 @@ impl TraitRef {\n     }\n \n     fn substs_from_path(\n-        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n+        ctx: &TyLoweringContext<'_>,\n         segment: PathSegment<'_>,\n         resolved: TraitId,\n     ) -> Substs {\n@@ -537,7 +532,7 @@ impl TraitRef {\n     }\n \n     pub(crate) fn from_type_bound(\n-        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n+        ctx: &TyLoweringContext<'_>,\n         bound: &TypeBound,\n         self_ty: Ty,\n     ) -> Option<TraitRef> {\n@@ -550,14 +545,14 @@ impl TraitRef {\n \n impl GenericPredicate {\n     pub(crate) fn from_where_predicate<'a>(\n-        ctx: &'a TyLoweringContext<'a, impl HirDatabase>,\n+        ctx: &'a TyLoweringContext<'a>,\n         where_predicate: &'a WherePredicate,\n     ) -> impl Iterator<Item = GenericPredicate> + 'a {\n         let self_ty = match &where_predicate.target {\n             WherePredicateTarget::TypeRef(type_ref) => Ty::from_hir(ctx, type_ref),\n             WherePredicateTarget::TypeParam(param_id) => {\n                 let generic_def = ctx.resolver.generic_def().expect(\"generics in scope\");\n-                let generics = generics(ctx.db, generic_def);\n+                let generics = generics(ctx.db.upcast(), generic_def);\n                 let param_id = hir_def::TypeParamId { parent: generic_def, local_id: *param_id };\n                 match ctx.type_param_mode {\n                     TypeParamLoweringMode::Placeholder => Ty::Placeholder(param_id),\n@@ -572,7 +567,7 @@ impl GenericPredicate {\n     }\n \n     pub(crate) fn from_type_bound<'a>(\n-        ctx: &'a TyLoweringContext<'a, impl HirDatabase>,\n+        ctx: &'a TyLoweringContext<'a>,\n         bound: &'a TypeBound,\n         self_ty: Ty,\n     ) -> impl Iterator<Item = GenericPredicate> + 'a {\n@@ -587,7 +582,7 @@ impl GenericPredicate {\n }\n \n fn assoc_type_bindings_from_type_bound<'a>(\n-    ctx: &'a TyLoweringContext<'a, impl HirDatabase>,\n+    ctx: &'a TyLoweringContext<'a>,\n     bound: &'a TypeBound,\n     trait_ref: TraitRef,\n ) -> impl Iterator<Item = GenericPredicate> + 'a {\n@@ -600,8 +595,11 @@ fn assoc_type_bindings_from_type_bound<'a>(\n         .flat_map(|segment| segment.args_and_bindings.into_iter())\n         .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n         .map(move |(name, type_ref)| {\n-            let associated_ty =\n-                associated_type_by_name_including_super_traits(ctx.db, trait_ref.trait_, &name);\n+            let associated_ty = associated_type_by_name_including_super_traits(\n+                ctx.db.upcast(),\n+                trait_ref.trait_,\n+                &name,\n+            );\n             let associated_ty = match associated_ty {\n                 None => return GenericPredicate::Error,\n                 Some(t) => t,\n@@ -615,7 +613,7 @@ fn assoc_type_bindings_from_type_bound<'a>(\n }\n \n /// Build the signature of a callable item (function, struct or enum variant).\n-pub fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> PolyFnSig {\n+pub fn callable_item_sig(db: &dyn HirDatabase, def: CallableDef) -> PolyFnSig {\n     match def {\n         CallableDef::FunctionId(f) => fn_sig_for_fn(db, f),\n         CallableDef::StructId(s) => fn_sig_for_struct_constructor(db, s),\n@@ -625,16 +623,16 @@ pub fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> PolyFnSig {\n \n /// Build the type of all specific fields of a struct or enum variant.\n pub(crate) fn field_types_query(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     variant_id: VariantId,\n ) -> Arc<ArenaMap<LocalStructFieldId, Binders<Ty>>> {\n-    let var_data = variant_data(db, variant_id);\n+    let var_data = variant_data(db.upcast(), variant_id);\n     let (resolver, def): (_, GenericDefId) = match variant_id {\n-        VariantId::StructId(it) => (it.resolver(db), it.into()),\n-        VariantId::UnionId(it) => (it.resolver(db), it.into()),\n-        VariantId::EnumVariantId(it) => (it.parent.resolver(db), it.parent.into()),\n+        VariantId::StructId(it) => (it.resolver(db.upcast()), it.into()),\n+        VariantId::UnionId(it) => (it.resolver(db.upcast()), it.into()),\n+        VariantId::EnumVariantId(it) => (it.parent.resolver(db.upcast()), it.parent.into()),\n     };\n-    let generics = generics(db, def);\n+    let generics = generics(db.upcast(), def);\n     let mut res = ArenaMap::default();\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n@@ -653,13 +651,13 @@ pub(crate) fn field_types_query(\n /// following bounds are disallowed: `T: Foo<U::Item>, U: Foo<T::Item>`, but\n /// these are fine: `T: Foo<U::Item>, U: Foo<()>`.\n pub(crate) fn generic_predicates_for_param_query(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     param_id: TypeParamId,\n ) -> Arc<[Binders<GenericPredicate>]> {\n-    let resolver = param_id.parent.resolver(db);\n+    let resolver = param_id.parent.resolver(db.upcast());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n-    let generics = generics(db, param_id.parent);\n+    let generics = generics(db.upcast(), param_id.parent);\n     resolver\n         .where_predicates_in_scope()\n         // we have to filter out all other predicates *first*, before attempting to lower them\n@@ -677,15 +675,15 @@ pub(crate) fn generic_predicates_for_param_query(\n }\n \n pub(crate) fn generic_predicates_for_param_recover(\n-    _db: &impl HirDatabase,\n+    _db: &dyn HirDatabase,\n     _cycle: &[String],\n     _param_id: &TypeParamId,\n ) -> Arc<[Binders<GenericPredicate>]> {\n     Arc::new([])\n }\n \n impl TraitEnvironment {\n-    pub fn lower(db: &impl HirDatabase, resolver: &Resolver) -> Arc<TraitEnvironment> {\n+    pub fn lower(db: &dyn HirDatabase, resolver: &Resolver) -> Arc<TraitEnvironment> {\n         let ctx = TyLoweringContext::new(db, &resolver)\n             .with_type_param_mode(TypeParamLoweringMode::Placeholder);\n         let mut predicates = resolver\n@@ -696,13 +694,13 @@ impl TraitEnvironment {\n         if let Some(def) = resolver.generic_def() {\n             let container: Option<AssocContainerId> = match def {\n                 // FIXME: is there a function for this?\n-                GenericDefId::FunctionId(f) => Some(f.lookup(db).container),\n+                GenericDefId::FunctionId(f) => Some(f.lookup(db.upcast()).container),\n                 GenericDefId::AdtId(_) => None,\n                 GenericDefId::TraitId(_) => None,\n-                GenericDefId::TypeAliasId(t) => Some(t.lookup(db).container),\n+                GenericDefId::TypeAliasId(t) => Some(t.lookup(db.upcast()).container),\n                 GenericDefId::ImplId(_) => None,\n                 GenericDefId::EnumVariantId(_) => None,\n-                GenericDefId::ConstId(c) => Some(c.lookup(db).container),\n+                GenericDefId::ConstId(c) => Some(c.lookup(db.upcast()).container),\n             };\n             if let Some(AssocContainerId::TraitId(trait_id)) = container {\n                 // add `Self: Trait<T1, T2, ...>` to the environment in trait\n@@ -723,13 +721,13 @@ impl TraitEnvironment {\n \n /// Resolve the where clause(s) of an item with generics.\n pub(crate) fn generic_predicates_query(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     def: GenericDefId,\n ) -> Arc<[Binders<GenericPredicate>]> {\n-    let resolver = def.resolver(db);\n+    let resolver = def.resolver(db.upcast());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n-    let generics = generics(db, def);\n+    let generics = generics(db.upcast(), def);\n     resolver\n         .where_predicates_in_scope()\n         .flat_map(|pred| {\n@@ -740,10 +738,10 @@ pub(crate) fn generic_predicates_query(\n }\n \n /// Resolve the default type params from generics\n-pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDefId) -> Substs {\n-    let resolver = def.resolver(db);\n+pub(crate) fn generic_defaults_query(db: &dyn HirDatabase, def: GenericDefId) -> Substs {\n+    let resolver = def.resolver(db.upcast());\n     let ctx = TyLoweringContext::new(db, &resolver);\n-    let generic_params = generics(db, def);\n+    let generic_params = generics(db.upcast(), def);\n \n     let defaults = generic_params\n         .iter()\n@@ -753,43 +751,43 @@ pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDefId) -\n     Substs(defaults)\n }\n \n-fn fn_sig_for_fn(db: &impl HirDatabase, def: FunctionId) -> PolyFnSig {\n+fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n     let data = db.function_data(def);\n-    let resolver = def.resolver(db);\n+    let resolver = def.resolver(db.upcast());\n     let ctx_params = TyLoweringContext::new(db, &resolver)\n         .with_impl_trait_mode(ImplTraitLoweringMode::Variable)\n         .with_type_param_mode(TypeParamLoweringMode::Variable);\n     let params = data.params.iter().map(|tr| Ty::from_hir(&ctx_params, tr)).collect::<Vec<_>>();\n     let ctx_ret = ctx_params.with_impl_trait_mode(ImplTraitLoweringMode::Opaque);\n     let ret = Ty::from_hir(&ctx_ret, &data.ret_type);\n-    let generics = generics(db, def.into());\n+    let generics = generics(db.upcast(), def.into());\n     let num_binders = generics.len();\n     Binders::new(num_binders, FnSig::from_params_and_return(params, ret))\n }\n \n /// Build the declared type of a function. This should not need to look at the\n /// function body.\n-fn type_for_fn(db: &impl HirDatabase, def: FunctionId) -> Binders<Ty> {\n-    let generics = generics(db, def.into());\n+fn type_for_fn(db: &dyn HirDatabase, def: FunctionId) -> Binders<Ty> {\n+    let generics = generics(db.upcast(), def.into());\n     let substs = Substs::bound_vars(&generics);\n     Binders::new(substs.len(), Ty::apply(TypeCtor::FnDef(def.into()), substs))\n }\n \n /// Build the declared type of a const.\n-fn type_for_const(db: &impl HirDatabase, def: ConstId) -> Binders<Ty> {\n+fn type_for_const(db: &dyn HirDatabase, def: ConstId) -> Binders<Ty> {\n     let data = db.const_data(def);\n-    let generics = generics(db, def.into());\n-    let resolver = def.resolver(db);\n+    let generics = generics(db.upcast(), def.into());\n+    let resolver = def.resolver(db.upcast());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n \n     Binders::new(generics.len(), Ty::from_hir(&ctx, &data.type_ref))\n }\n \n /// Build the declared type of a static.\n-fn type_for_static(db: &impl HirDatabase, def: StaticId) -> Binders<Ty> {\n+fn type_for_static(db: &dyn HirDatabase, def: StaticId) -> Binders<Ty> {\n     let data = db.static_data(def);\n-    let resolver = def.resolver(db);\n+    let resolver = def.resolver(db.upcast());\n     let ctx = TyLoweringContext::new(db, &resolver);\n \n     Binders::new(0, Ty::from_hir(&ctx, &data.type_ref))\n@@ -806,10 +804,10 @@ fn type_for_builtin(def: BuiltinType) -> Ty {\n     })\n }\n \n-fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> PolyFnSig {\n+fn fn_sig_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> PolyFnSig {\n     let struct_data = db.struct_data(def);\n     let fields = struct_data.variant_data.fields();\n-    let resolver = def.resolver(db);\n+    let resolver = def.resolver(db.upcast());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let params =\n@@ -819,21 +817,21 @@ fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> PolyFn\n }\n \n /// Build the type of a tuple struct constructor.\n-fn type_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> Binders<Ty> {\n+fn type_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> Binders<Ty> {\n     let struct_data = db.struct_data(def);\n     if let StructKind::Unit = struct_data.variant_data.kind() {\n         return type_for_adt(db, def.into());\n     }\n-    let generics = generics(db, def.into());\n+    let generics = generics(db.upcast(), def.into());\n     let substs = Substs::bound_vars(&generics);\n     Binders::new(substs.len(), Ty::apply(TypeCtor::FnDef(def.into()), substs))\n }\n \n-fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> PolyFnSig {\n+fn fn_sig_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId) -> PolyFnSig {\n     let enum_data = db.enum_data(def.parent);\n     let var_data = &enum_data.variants[def.local_id];\n     let fields = var_data.variant_data.fields();\n-    let resolver = def.parent.resolver(db);\n+    let resolver = def.parent.resolver(db.upcast());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let params =\n@@ -843,26 +841,26 @@ fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId\n }\n \n /// Build the type of a tuple enum variant constructor.\n-fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> Binders<Ty> {\n+fn type_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId) -> Binders<Ty> {\n     let enum_data = db.enum_data(def.parent);\n     let var_data = &enum_data.variants[def.local_id].variant_data;\n     if let StructKind::Unit = var_data.kind() {\n         return type_for_adt(db, def.parent.into());\n     }\n-    let generics = generics(db, def.parent.into());\n+    let generics = generics(db.upcast(), def.parent.into());\n     let substs = Substs::bound_vars(&generics);\n     Binders::new(substs.len(), Ty::apply(TypeCtor::FnDef(def.into()), substs))\n }\n \n-fn type_for_adt(db: &impl HirDatabase, adt: AdtId) -> Binders<Ty> {\n-    let generics = generics(db, adt.into());\n+fn type_for_adt(db: &dyn HirDatabase, adt: AdtId) -> Binders<Ty> {\n+    let generics = generics(db.upcast(), adt.into());\n     let substs = Substs::bound_vars(&generics);\n     Binders::new(substs.len(), Ty::apply(TypeCtor::Adt(adt), substs))\n }\n \n-fn type_for_type_alias(db: &impl HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n-    let generics = generics(db, t.into());\n-    let resolver = t.resolver(db);\n+fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n+    let generics = generics(db.upcast(), t.into());\n+    let resolver = t.resolver(db.upcast());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let type_ref = &db.type_alias_data(t).type_ref;\n@@ -880,7 +878,8 @@ pub enum CallableDef {\n impl_froms!(CallableDef: FunctionId, StructId, EnumVariantId);\n \n impl CallableDef {\n-    pub fn krate(self, db: &impl HirDatabase) -> CrateId {\n+    pub fn krate(self, db: &dyn HirDatabase) -> CrateId {\n+        let db = db.upcast();\n         match self {\n             CallableDef::FunctionId(f) => f.lookup(db).module(db),\n             CallableDef::StructId(s) => s.lookup(db).container.module(db),\n@@ -922,24 +921,24 @@ impl_froms!(ValueTyDefId: FunctionId, StructId, EnumVariantId, ConstId, StaticId\n /// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n /// the constructor function `(usize) -> Foo` which lives in the values\n /// namespace.\n-pub(crate) fn ty_query(db: &impl HirDatabase, def: TyDefId) -> Binders<Ty> {\n+pub(crate) fn ty_query(db: &dyn HirDatabase, def: TyDefId) -> Binders<Ty> {\n     match def {\n         TyDefId::BuiltinType(it) => Binders::new(0, type_for_builtin(it)),\n         TyDefId::AdtId(it) => type_for_adt(db, it),\n         TyDefId::TypeAliasId(it) => type_for_type_alias(db, it),\n     }\n }\n \n-pub(crate) fn ty_recover(db: &impl HirDatabase, _cycle: &[String], def: &TyDefId) -> Binders<Ty> {\n+pub(crate) fn ty_recover(db: &dyn HirDatabase, _cycle: &[String], def: &TyDefId) -> Binders<Ty> {\n     let num_binders = match *def {\n         TyDefId::BuiltinType(_) => 0,\n-        TyDefId::AdtId(it) => generics(db, it.into()).len(),\n-        TyDefId::TypeAliasId(it) => generics(db, it.into()).len(),\n+        TyDefId::AdtId(it) => generics(db.upcast(), it.into()).len(),\n+        TyDefId::TypeAliasId(it) => generics(db.upcast(), it.into()).len(),\n     };\n     Binders::new(num_binders, Ty::Unknown)\n }\n \n-pub(crate) fn value_ty_query(db: &impl HirDatabase, def: ValueTyDefId) -> Binders<Ty> {\n+pub(crate) fn value_ty_query(db: &dyn HirDatabase, def: ValueTyDefId) -> Binders<Ty> {\n     match def {\n         ValueTyDefId::FunctionId(it) => type_for_fn(db, it),\n         ValueTyDefId::StructId(it) => type_for_struct_constructor(db, it),\n@@ -949,30 +948,27 @@ pub(crate) fn value_ty_query(db: &impl HirDatabase, def: ValueTyDefId) -> Binder\n     }\n }\n \n-pub(crate) fn impl_self_ty_query(db: &impl HirDatabase, impl_id: ImplId) -> Binders<Ty> {\n+pub(crate) fn impl_self_ty_query(db: &dyn HirDatabase, impl_id: ImplId) -> Binders<Ty> {\n     let impl_data = db.impl_data(impl_id);\n-    let resolver = impl_id.resolver(db);\n-    let generics = generics(db, impl_id.into());\n+    let resolver = impl_id.resolver(db.upcast());\n+    let generics = generics(db.upcast(), impl_id.into());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     Binders::new(generics.len(), Ty::from_hir(&ctx, &impl_data.target_type))\n }\n \n pub(crate) fn impl_self_ty_recover(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     _cycle: &[String],\n     impl_id: &ImplId,\n ) -> Binders<Ty> {\n-    let generics = generics(db, (*impl_id).into());\n+    let generics = generics(db.upcast(), (*impl_id).into());\n     Binders::new(generics.len(), Ty::Unknown)\n }\n \n-pub(crate) fn impl_trait_query(\n-    db: &impl HirDatabase,\n-    impl_id: ImplId,\n-) -> Option<Binders<TraitRef>> {\n+pub(crate) fn impl_trait_query(db: &dyn HirDatabase, impl_id: ImplId) -> Option<Binders<TraitRef>> {\n     let impl_data = db.impl_data(impl_id);\n-    let resolver = impl_id.resolver(db);\n+    let resolver = impl_id.resolver(db.upcast());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let self_ty = db.impl_self_ty(impl_id);"}, {"sha": "69c059ac864466ae3a21cff4d2f7e27c7e0e9694", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -48,10 +48,7 @@ pub struct CrateImplDefs {\n }\n \n impl CrateImplDefs {\n-    pub(crate) fn impls_in_crate_query(\n-        db: &impl HirDatabase,\n-        krate: CrateId,\n-    ) -> Arc<CrateImplDefs> {\n+    pub(crate) fn impls_in_crate_query(db: &dyn HirDatabase, krate: CrateId) -> Arc<CrateImplDefs> {\n         let _p = profile(\"impls_in_crate_query\");\n         let mut res =\n             CrateImplDefs { impls: FxHashMap::default(), impls_by_trait: FxHashMap::default() };\n@@ -92,7 +89,7 @@ impl CrateImplDefs {\n impl Ty {\n     pub fn def_crates(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         cur_crate: CrateId,\n     ) -> Option<ArrayVec<[CrateId; 2]>> {\n         // Types like slice can have inherent impls in several crates, (core and alloc).\n@@ -110,7 +107,7 @@ impl Ty {\n         let lang_item_targets = match self {\n             Ty::Apply(a_ty) => match a_ty.ctor {\n                 TypeCtor::Adt(def_id) => {\n-                    return Some(std::iter::once(def_id.module(db).krate).collect())\n+                    return Some(std::iter::once(def_id.module(db.upcast()).krate).collect())\n                 }\n                 TypeCtor::Bool => lang_item_crate!(\"bool\"),\n                 TypeCtor::Char => lang_item_crate!(\"char\"),\n@@ -134,7 +131,7 @@ impl Ty {\n                 LangItemTarget::ImplDefId(it) => Some(it),\n                 _ => None,\n             })\n-            .map(|it| it.lookup(db).container.module(db).krate)\n+            .map(|it| it.lookup(db.upcast()).container.module(db.upcast()).krate)\n             .collect();\n         Some(res)\n     }\n@@ -143,7 +140,7 @@ impl Ty {\n /// receiver type (but without autoref applied yet).\n pub(crate) fn lookup_method(\n     ty: &Canonical<Ty>,\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n@@ -181,7 +178,7 @@ pub enum LookupMode {\n // FIXME add a context type here?\n pub fn iterate_method_candidates<T>(\n     ty: &Canonical<Ty>,\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n@@ -247,7 +244,7 @@ pub fn iterate_method_candidates<T>(\n \n fn iterate_method_candidates_with_autoref<T>(\n     deref_chain: &[Canonical<Ty>],\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n@@ -304,7 +301,7 @@ fn iterate_method_candidates_with_autoref<T>(\n fn iterate_method_candidates_by_receiver<T>(\n     receiver_ty: &Canonical<Ty>,\n     rest_of_deref_chain: &[Canonical<Ty>],\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n@@ -340,7 +337,7 @@ fn iterate_method_candidates_by_receiver<T>(\n \n fn iterate_method_candidates_for_self_ty<T>(\n     self_ty: &Canonical<Ty>,\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n@@ -367,7 +364,7 @@ fn iterate_method_candidates_for_self_ty<T>(\n \n fn iterate_trait_method_candidates<T>(\n     self_ty: &Canonical<Ty>,\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n@@ -381,7 +378,7 @@ fn iterate_trait_method_candidates<T>(\n         // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n         env.trait_predicates_for_self_ty(&self_ty.value)\n             .map(|tr| tr.trait_)\n-            .flat_map(|t| all_super_traits(db, t))\n+            .flat_map(|t| all_super_traits(db.upcast(), t))\n             .collect()\n     } else {\n         Vec::new()\n@@ -416,7 +413,7 @@ fn iterate_trait_method_candidates<T>(\n \n fn iterate_inherent_methods<T>(\n     self_ty: &Canonical<Ty>,\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n     krate: CrateId,\n@@ -449,7 +446,7 @@ fn iterate_inherent_methods<T>(\n \n /// Returns the self type for the index trait call.\n pub fn resolve_indexing_op(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     ty: &Canonical<Ty>,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n@@ -467,7 +464,7 @@ pub fn resolve_indexing_op(\n }\n \n fn is_valid_candidate(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n     item: AssocItemId,\n@@ -504,7 +501,7 @@ fn is_valid_candidate(\n }\n \n pub(crate) fn inherent_impl_substs(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     impl_id: ImplId,\n     self_ty: &Canonical<Ty>,\n ) -> Option<Substs> {\n@@ -544,11 +541,11 @@ fn fallback_bound_vars(s: Substs, num_vars_to_keep: usize) -> Substs {\n }\n \n fn transform_receiver_ty(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     function_id: FunctionId,\n     self_ty: &Canonical<Ty>,\n ) -> Option<Ty> {\n-    let substs = match function_id.lookup(db).container {\n+    let substs = match function_id.lookup(db.upcast()).container {\n         AssocContainerId::TraitId(_) => Substs::build_for_def(db, function_id)\n             .push(self_ty.value.clone())\n             .fill_with_unknown()\n@@ -562,7 +559,7 @@ fn transform_receiver_ty(\n \n pub fn implements_trait(\n     ty: &Canonical<Ty>,\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     trait_: TraitId,\n@@ -581,7 +578,7 @@ pub fn implements_trait(\n /// This creates Substs for a trait with the given Self type and type variables\n /// for all other parameters, to query Chalk with it.\n fn generic_implements_goal(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     trait_: TraitId,\n     self_ty: Canonical<Ty>,\n@@ -598,7 +595,7 @@ fn generic_implements_goal(\n }\n \n fn autoderef_method_receiver(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     ty: InEnvironment<Canonical<Ty>>,\n ) -> Vec<Canonical<Ty>> {"}, {"sha": "5bbeabf519c0e58b61c21e1dc10e837026f3b4db", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -6,8 +6,10 @@ use std::{\n };\n \n use hir_def::{db::DefDatabase, AssocItemId, ModuleDefId, ModuleId};\n-use hir_expand::diagnostics::DiagnosticSink;\n-use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath, SourceDatabase};\n+use hir_expand::{db::AstDatabase, diagnostics::DiagnosticSink};\n+use ra_db::{\n+    salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath, SourceDatabase, Upcast,\n+};\n \n use crate::{db::HirDatabase, expr::ExprValidator};\n \n@@ -25,6 +27,18 @@ pub struct TestDB {\n     runtime: salsa::Runtime<TestDB>,\n }\n \n+impl Upcast<dyn AstDatabase> for TestDB {\n+    fn upcast(&self) -> &(dyn AstDatabase + 'static) {\n+        &*self\n+    }\n+}\n+\n+impl Upcast<dyn DefDatabase> for TestDB {\n+    fn upcast(&self) -> &(dyn DefDatabase + 'static) {\n+        &*self\n+    }\n+}\n+\n impl salsa::Database for TestDB {\n     fn salsa_runtime(&self) -> &salsa::Runtime<TestDB> {\n         &self.runtime"}, {"sha": "a1ca33c985bfc5dd524fa4c10685cd742699a563", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -24,8 +24,8 @@ const CHALK_SOLVER_MAX_SIZE: usize = 10;\n const CHALK_SOLVER_FUEL: i32 = 100;\n \n #[derive(Debug, Copy, Clone)]\n-struct ChalkContext<'a, DB> {\n-    db: &'a DB,\n+struct ChalkContext<'a> {\n+    db: &'a dyn HirDatabase,\n     krate: CrateId,\n }\n \n@@ -37,7 +37,7 @@ fn create_chalk_solver() -> chalk_solve::Solver<Interner> {\n \n /// Collects impls for the given trait in the whole dependency tree of `krate`.\n pub(crate) fn impls_for_trait_query(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     trait_: TraitId,\n ) -> Arc<[ImplId]> {\n@@ -136,7 +136,7 @@ impl TypeWalk for ProjectionPredicate {\n \n /// Solve a trait goal using Chalk.\n pub(crate) fn trait_solve_query(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     goal: Canonical<InEnvironment<Obligation>>,\n ) -> Option<Solution> {\n@@ -163,7 +163,7 @@ pub(crate) fn trait_solve_query(\n }\n \n fn solve(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal<Interner>>>,\n ) -> Option<chalk_solve::Solution<Interner>> {\n@@ -188,7 +188,7 @@ fn solve(\n }\n \n fn solution_from_chalk(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     solution: chalk_solve::Solution<Interner>,\n ) -> Solution {\n     let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution<Interner>>| {"}, {"sha": "73e3c5c78a91ed8b083d2dac7e7e9adc5ade5e12", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -26,7 +26,7 @@ pub(super) struct BuiltinImplAssocTyValueData {\n }\n \n pub(super) fn get_builtin_impls(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     ty: &Ty,\n     // The first argument for the trait, if present\n@@ -59,7 +59,7 @@ pub(super) fn get_builtin_impls(\n }\n \n fn get_builtin_unsize_impls(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     ty: &Ty,\n     // The first argument for the trait, if present\n@@ -79,7 +79,7 @@ fn get_builtin_unsize_impls(\n         // FIXME what about more complicated dyn tys with marker traits?\n         if let Some(trait_ref) = ty.dyn_trait_ref() {\n             if trait_ref.trait_ != target_trait.trait_ {\n-                let super_traits = all_super_traits(db, trait_ref.trait_);\n+                let super_traits = all_super_traits(db.upcast(), trait_ref.trait_);\n                 if super_traits.contains(&target_trait.trait_) {\n                     callback(Impl::UnsizeToSuperTraitObject(UnsizeToSuperTraitObjectData {\n                         trait_: trait_ref.trait_,\n@@ -94,7 +94,7 @@ fn get_builtin_unsize_impls(\n     }\n }\n \n-pub(super) fn impl_datum(db: &impl HirDatabase, krate: CrateId, impl_: Impl) -> BuiltinImplData {\n+pub(super) fn impl_datum(db: &dyn HirDatabase, krate: CrateId, impl_: Impl) -> BuiltinImplData {\n     match impl_ {\n         Impl::ImplDef(_) => unreachable!(),\n         Impl::ClosureFnTraitImpl(data) => closure_fn_trait_impl_datum(db, krate, data),\n@@ -107,7 +107,7 @@ pub(super) fn impl_datum(db: &impl HirDatabase, krate: CrateId, impl_: Impl) ->\n }\n \n pub(super) fn associated_ty_value(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     data: AssocTyValue,\n ) -> BuiltinImplAssocTyValueData {\n@@ -122,7 +122,7 @@ pub(super) fn associated_ty_value(\n // Closure Fn trait impls\n \n fn check_closure_fn_trait_impl_prerequisites(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     data: super::ClosureFnTraitImplData,\n ) -> bool {\n@@ -143,7 +143,7 @@ fn check_closure_fn_trait_impl_prerequisites(\n }\n \n fn closure_fn_trait_impl_datum(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     data: super::ClosureFnTraitImplData,\n ) -> BuiltinImplData {\n@@ -189,7 +189,7 @@ fn closure_fn_trait_impl_datum(\n }\n \n fn closure_fn_trait_output_assoc_ty_value(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     data: super::ClosureFnTraitImplData,\n ) -> BuiltinImplAssocTyValueData {\n@@ -223,17 +223,17 @@ fn closure_fn_trait_output_assoc_ty_value(\n \n // Array unsizing\n \n-fn check_unsize_impl_prerequisites(db: &impl HirDatabase, krate: CrateId) -> bool {\n+fn check_unsize_impl_prerequisites(db: &dyn HirDatabase, krate: CrateId) -> bool {\n     // the Unsize trait needs to exist and have two type parameters (Self and T)\n     let unsize_trait = match get_unsize_trait(db, krate) {\n         Some(t) => t,\n         None => return false,\n     };\n-    let generic_params = generics(db, unsize_trait.into());\n+    let generic_params = generics(db.upcast(), unsize_trait.into());\n     generic_params.len() == 2\n }\n \n-fn array_unsize_impl_datum(db: &impl HirDatabase, krate: CrateId) -> BuiltinImplData {\n+fn array_unsize_impl_datum(db: &dyn HirDatabase, krate: CrateId) -> BuiltinImplData {\n     // impl<T> Unsize<[T]> for [T; _]\n     // (this can be a single impl because we don't distinguish array sizes currently)\n \n@@ -260,7 +260,7 @@ fn array_unsize_impl_datum(db: &impl HirDatabase, krate: CrateId) -> BuiltinImpl\n // Trait object unsizing\n \n fn trait_object_unsize_impl_datum(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     trait_: TraitId,\n ) -> BuiltinImplData {\n@@ -295,7 +295,7 @@ fn trait_object_unsize_impl_datum(\n }\n \n fn super_trait_object_unsize_impl_datum(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     data: UnsizeToSuperTraitObjectData,\n ) -> BuiltinImplData {\n@@ -313,7 +313,7 @@ fn super_trait_object_unsize_impl_datum(\n     let self_bounds = vec![GenericPredicate::Implemented(self_trait_ref.clone())];\n \n     // we need to go from our trait to the super trait, substituting type parameters\n-    let path = crate::utils::find_super_trait_path(db, data.trait_, data.super_trait);\n+    let path = crate::utils::find_super_trait_path(db.upcast(), data.trait_, data.super_trait);\n \n     let mut current_trait_ref = self_trait_ref;\n     for t in path.into_iter().skip(1) {\n@@ -344,19 +344,15 @@ fn super_trait_object_unsize_impl_datum(\n     BuiltinImplData { num_vars, trait_ref, where_clauses: Vec::new(), assoc_ty_values: Vec::new() }\n }\n \n-fn get_fn_trait(\n-    db: &impl HirDatabase,\n-    krate: CrateId,\n-    fn_trait: super::FnTrait,\n-) -> Option<TraitId> {\n+fn get_fn_trait(db: &dyn HirDatabase, krate: CrateId, fn_trait: super::FnTrait) -> Option<TraitId> {\n     let target = db.lang_item(krate, fn_trait.lang_item_name().into())?;\n     match target {\n         LangItemTarget::TraitId(t) => Some(t),\n         _ => None,\n     }\n }\n \n-fn get_unsize_trait(db: &impl HirDatabase, krate: CrateId) -> Option<TraitId> {\n+fn get_unsize_trait(db: &dyn HirDatabase, krate: CrateId) -> Option<TraitId> {\n     let target = db.lang_item(krate, \"unsize\".into())?;\n     match target {\n         LangItemTarget::TraitId(t) => Some(t),"}, {"sha": "943d5f125998b5d03f9720baadce83ff43fb4bba", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 54, "deletions": 57, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -127,11 +127,11 @@ pub type AssociatedTyValue = chalk_rust_ir::AssociatedTyValue<Interner>;\n \n pub(super) trait ToChalk {\n     type Chalk;\n-    fn to_chalk(self, db: &impl HirDatabase) -> Self::Chalk;\n-    fn from_chalk(db: &impl HirDatabase, chalk: Self::Chalk) -> Self;\n+    fn to_chalk(self, db: &dyn HirDatabase) -> Self::Chalk;\n+    fn from_chalk(db: &dyn HirDatabase, chalk: Self::Chalk) -> Self;\n }\n \n-pub(super) fn from_chalk<T, ChalkT>(db: &impl HirDatabase, chalk: ChalkT) -> T\n+pub(super) fn from_chalk<T, ChalkT>(db: &dyn HirDatabase, chalk: ChalkT) -> T\n where\n     T: ToChalk<Chalk = ChalkT>,\n {\n@@ -140,7 +140,7 @@ where\n \n impl ToChalk for Ty {\n     type Chalk = chalk_ir::Ty<Interner>;\n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Ty<Interner> {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Ty<Interner> {\n         match self {\n             Ty::Apply(apply_ty) => {\n                 let name = apply_ty.ctor.to_chalk(db);\n@@ -179,7 +179,7 @@ impl ToChalk for Ty {\n             }\n         }\n     }\n-    fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty<Interner>) -> Self {\n+    fn from_chalk(db: &dyn HirDatabase, chalk: chalk_ir::Ty<Interner>) -> Self {\n         match chalk.data().clone() {\n             chalk_ir::TyData::Apply(apply_ty) => match apply_ty.name {\n                 TypeName::Error => Ty::Unknown,\n@@ -217,11 +217,11 @@ impl ToChalk for Ty {\n impl ToChalk for Substs {\n     type Chalk = chalk_ir::Substitution<Interner>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Substitution<Interner> {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Substitution<Interner> {\n         chalk_ir::Substitution::from(self.iter().map(|ty| ty.clone().to_chalk(db)))\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, parameters: chalk_ir::Substitution<Interner>) -> Substs {\n+    fn from_chalk(db: &dyn HirDatabase, parameters: chalk_ir::Substitution<Interner>) -> Substs {\n         let tys = parameters\n             .into_iter()\n             .map(|p| match p.ty() {\n@@ -236,13 +236,13 @@ impl ToChalk for Substs {\n impl ToChalk for TraitRef {\n     type Chalk = chalk_ir::TraitRef<Interner>;\n \n-    fn to_chalk(self: TraitRef, db: &impl HirDatabase) -> chalk_ir::TraitRef<Interner> {\n+    fn to_chalk(self: TraitRef, db: &dyn HirDatabase) -> chalk_ir::TraitRef<Interner> {\n         let trait_id = self.trait_.to_chalk(db);\n         let substitution = self.substs.to_chalk(db);\n         chalk_ir::TraitRef { trait_id, substitution }\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, trait_ref: chalk_ir::TraitRef<Interner>) -> Self {\n+    fn from_chalk(db: &dyn HirDatabase, trait_ref: chalk_ir::TraitRef<Interner>) -> Self {\n         let trait_ = from_chalk(db, trait_ref.trait_id);\n         let substs = from_chalk(db, trait_ref.substitution);\n         TraitRef { trait_, substs }\n@@ -252,19 +252,19 @@ impl ToChalk for TraitRef {\n impl ToChalk for hir_def::TraitId {\n     type Chalk = TraitId;\n \n-    fn to_chalk(self, _db: &impl HirDatabase) -> TraitId {\n+    fn to_chalk(self, _db: &dyn HirDatabase) -> TraitId {\n         chalk_ir::TraitId(self.as_intern_id())\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, trait_id: TraitId) -> hir_def::TraitId {\n+    fn from_chalk(_db: &dyn HirDatabase, trait_id: TraitId) -> hir_def::TraitId {\n         InternKey::from_intern_id(trait_id.0)\n     }\n }\n \n impl ToChalk for TypeCtor {\n     type Chalk = TypeName<Interner>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> TypeName<Interner> {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> TypeName<Interner> {\n         match self {\n             TypeCtor::AssociatedType(type_alias) => {\n                 let type_id = type_alias.to_chalk(db);\n@@ -278,7 +278,7 @@ impl ToChalk for TypeCtor {\n         }\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, type_name: TypeName<Interner>) -> TypeCtor {\n+    fn from_chalk(db: &dyn HirDatabase, type_name: TypeName<Interner>) -> TypeCtor {\n         match type_name {\n             TypeName::Struct(struct_id) => db.lookup_intern_type_ctor(struct_id.into()),\n             TypeName::AssociatedType(type_id) => TypeCtor::AssociatedType(from_chalk(db, type_id)),\n@@ -293,43 +293,43 @@ impl ToChalk for TypeCtor {\n impl ToChalk for Impl {\n     type Chalk = ImplId;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> ImplId {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> ImplId {\n         db.intern_chalk_impl(self).into()\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, impl_id: ImplId) -> Impl {\n+    fn from_chalk(db: &dyn HirDatabase, impl_id: ImplId) -> Impl {\n         db.lookup_intern_chalk_impl(impl_id.into())\n     }\n }\n \n impl ToChalk for TypeAliasId {\n     type Chalk = AssocTypeId;\n \n-    fn to_chalk(self, _db: &impl HirDatabase) -> AssocTypeId {\n+    fn to_chalk(self, _db: &dyn HirDatabase) -> AssocTypeId {\n         chalk_ir::AssocTypeId(self.as_intern_id())\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, type_alias_id: AssocTypeId) -> TypeAliasId {\n+    fn from_chalk(_db: &dyn HirDatabase, type_alias_id: AssocTypeId) -> TypeAliasId {\n         InternKey::from_intern_id(type_alias_id.0)\n     }\n }\n \n impl ToChalk for AssocTyValue {\n     type Chalk = AssociatedTyValueId;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> AssociatedTyValueId {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> AssociatedTyValueId {\n         db.intern_assoc_ty_value(self).into()\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, assoc_ty_value_id: AssociatedTyValueId) -> AssocTyValue {\n+    fn from_chalk(db: &dyn HirDatabase, assoc_ty_value_id: AssociatedTyValueId) -> AssocTyValue {\n         db.lookup_intern_assoc_ty_value(assoc_ty_value_id.into())\n     }\n }\n \n impl ToChalk for GenericPredicate {\n     type Chalk = chalk_ir::QuantifiedWhereClause<Interner>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::QuantifiedWhereClause<Interner> {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::QuantifiedWhereClause<Interner> {\n         match self {\n             GenericPredicate::Implemented(trait_ref) => {\n                 make_binders(chalk_ir::WhereClause::Implemented(trait_ref.to_chalk(db)), 0)\n@@ -346,7 +346,7 @@ impl ToChalk for GenericPredicate {\n     }\n \n     fn from_chalk(\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         where_clause: chalk_ir::QuantifiedWhereClause<Interner>,\n     ) -> GenericPredicate {\n         match where_clause.value {\n@@ -365,15 +365,15 @@ impl ToChalk for GenericPredicate {\n impl ToChalk for ProjectionTy {\n     type Chalk = chalk_ir::AliasTy<Interner>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::AliasTy<Interner> {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::AliasTy<Interner> {\n         chalk_ir::AliasTy {\n             associated_ty_id: self.associated_ty.to_chalk(db),\n             substitution: self.parameters.to_chalk(db),\n         }\n     }\n \n     fn from_chalk(\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         projection_ty: chalk_ir::AliasTy<Interner>,\n     ) -> ProjectionTy {\n         ProjectionTy {\n@@ -386,26 +386,26 @@ impl ToChalk for ProjectionTy {\n impl ToChalk for super::ProjectionPredicate {\n     type Chalk = chalk_ir::Normalize<Interner>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Normalize<Interner> {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Normalize<Interner> {\n         chalk_ir::Normalize { alias: self.projection_ty.to_chalk(db), ty: self.ty.to_chalk(db) }\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, _normalize: chalk_ir::Normalize<Interner>) -> Self {\n+    fn from_chalk(_db: &dyn HirDatabase, _normalize: chalk_ir::Normalize<Interner>) -> Self {\n         unimplemented!()\n     }\n }\n \n impl ToChalk for Obligation {\n     type Chalk = chalk_ir::DomainGoal<Interner>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::DomainGoal<Interner> {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::DomainGoal<Interner> {\n         match self {\n             Obligation::Trait(tr) => tr.to_chalk(db).cast(),\n             Obligation::Projection(pr) => pr.to_chalk(db).cast(),\n         }\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, _goal: chalk_ir::DomainGoal<Interner>) -> Self {\n+    fn from_chalk(_db: &dyn HirDatabase, _goal: chalk_ir::DomainGoal<Interner>) -> Self {\n         unimplemented!()\n     }\n }\n@@ -416,21 +416,21 @@ where\n {\n     type Chalk = chalk_ir::Canonical<T::Chalk>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Canonical<T::Chalk> {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Canonical<T::Chalk> {\n         let parameter = chalk_ir::ParameterKind::Ty(chalk_ir::UniverseIndex::ROOT);\n         let value = self.value.to_chalk(db);\n         chalk_ir::Canonical { value, binders: vec![parameter; self.num_vars] }\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, canonical: chalk_ir::Canonical<T::Chalk>) -> Canonical<T> {\n+    fn from_chalk(db: &dyn HirDatabase, canonical: chalk_ir::Canonical<T::Chalk>) -> Canonical<T> {\n         Canonical { num_vars: canonical.binders.len(), value: from_chalk(db, canonical.value) }\n     }\n }\n \n impl ToChalk for Arc<super::TraitEnvironment> {\n     type Chalk = chalk_ir::Environment<Interner>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Environment<Interner> {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Environment<Interner> {\n         let mut clauses = Vec::new();\n         for pred in &self.predicates {\n             if pred.is_error() {\n@@ -445,7 +445,7 @@ impl ToChalk for Arc<super::TraitEnvironment> {\n     }\n \n     fn from_chalk(\n-        _db: &impl HirDatabase,\n+        _db: &dyn HirDatabase,\n         _env: chalk_ir::Environment<Interner>,\n     ) -> Arc<super::TraitEnvironment> {\n         unimplemented!()\n@@ -458,15 +458,15 @@ where\n {\n     type Chalk = chalk_ir::InEnvironment<T::Chalk>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::InEnvironment<T::Chalk> {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::InEnvironment<T::Chalk> {\n         chalk_ir::InEnvironment {\n             environment: self.environment.to_chalk(db),\n             goal: self.value.to_chalk(db),\n         }\n     }\n \n     fn from_chalk(\n-        db: &impl HirDatabase,\n+        db: &dyn HirDatabase,\n         in_env: chalk_ir::InEnvironment<T::Chalk>,\n     ) -> super::InEnvironment<T> {\n         super::InEnvironment {\n@@ -479,7 +479,7 @@ where\n impl ToChalk for builtin::BuiltinImplData {\n     type Chalk = ImplDatum;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> ImplDatum {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> ImplDatum {\n         let impl_type = chalk_rust_ir::ImplType::External;\n         let where_clauses = self.where_clauses.into_iter().map(|w| w.to_chalk(db)).collect();\n \n@@ -495,15 +495,15 @@ impl ToChalk for builtin::BuiltinImplData {\n         }\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, _data: ImplDatum) -> Self {\n+    fn from_chalk(_db: &dyn HirDatabase, _data: ImplDatum) -> Self {\n         unimplemented!()\n     }\n }\n \n impl ToChalk for builtin::BuiltinImplAssocTyValueData {\n     type Chalk = AssociatedTyValue;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> AssociatedTyValue {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> AssociatedTyValue {\n         let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: self.value.to_chalk(db) };\n \n         chalk_rust_ir::AssociatedTyValue {\n@@ -514,7 +514,7 @@ impl ToChalk for builtin::BuiltinImplAssocTyValueData {\n     }\n \n     fn from_chalk(\n-        _db: &impl HirDatabase,\n+        _db: &dyn HirDatabase,\n         _data: AssociatedTyValue,\n     ) -> builtin::BuiltinImplAssocTyValueData {\n         unimplemented!()\n@@ -529,7 +529,7 @@ fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T> {\n }\n \n fn convert_where_clauses(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     def: GenericDefId,\n     substs: &Substs,\n ) -> Vec<chalk_ir::QuantifiedWhereClause<Interner>> {\n@@ -545,10 +545,7 @@ fn convert_where_clauses(\n     result\n }\n \n-impl<'a, DB> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a, DB>\n-where\n-    DB: HirDatabase,\n-{\n+impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     fn associated_ty_data(&self, id: AssocTypeId) -> Arc<AssociatedTyDatum> {\n         self.db.associated_ty_data(id)\n     }\n@@ -618,16 +615,16 @@ where\n }\n \n pub(crate) fn associated_ty_data_query(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     id: AssocTypeId,\n ) -> Arc<AssociatedTyDatum> {\n     debug!(\"associated_ty_data {:?}\", id);\n     let type_alias: TypeAliasId = from_chalk(db, id);\n-    let trait_ = match type_alias.lookup(db).container {\n+    let trait_ = match type_alias.lookup(db.upcast()).container {\n         AssocContainerId::TraitId(t) => t,\n         _ => panic!(\"associated type not in trait\"),\n     };\n-    let generic_params = generics(db, type_alias.into());\n+    let generic_params = generics(db.upcast(), type_alias.into());\n     let bound_data = chalk_rust_ir::AssociatedTyDatumBound {\n         // FIXME add bounds and where clauses\n         bounds: vec![],\n@@ -643,19 +640,19 @@ pub(crate) fn associated_ty_data_query(\n }\n \n pub(crate) fn trait_datum_query(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     trait_id: TraitId,\n ) -> Arc<TraitDatum> {\n     debug!(\"trait_datum {:?}\", trait_id);\n     let trait_: hir_def::TraitId = from_chalk(db, trait_id);\n     let trait_data = db.trait_data(trait_);\n     debug!(\"trait {:?} = {:?}\", trait_id, trait_data.name);\n-    let generic_params = generics(db, trait_.into());\n+    let generic_params = generics(db.upcast(), trait_.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n     let flags = chalk_rust_ir::TraitFlags {\n         auto: trait_data.auto,\n-        upstream: trait_.lookup(db).container.module(db).krate != krate,\n+        upstream: trait_.lookup(db.upcast()).container.module(db.upcast()).krate != krate,\n         non_enumerable: true,\n         coinductive: false, // only relevant for Chalk testing\n         // FIXME set these flags correctly\n@@ -676,7 +673,7 @@ pub(crate) fn trait_datum_query(\n }\n \n pub(crate) fn struct_datum_query(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     struct_id: StructId,\n ) -> Arc<StructDatum> {\n@@ -688,7 +685,7 @@ pub(crate) fn struct_datum_query(\n     let where_clauses = type_ctor\n         .as_generic_def()\n         .map(|generic_def| {\n-            let generic_params = generics(db, generic_def);\n+            let generic_params = generics(db.upcast(), generic_def);\n             let bound_vars = Substs::bound_vars(&generic_params);\n             convert_where_clauses(db, generic_def, &bound_vars)\n         })\n@@ -708,7 +705,7 @@ pub(crate) fn struct_datum_query(\n }\n \n pub(crate) fn impl_datum_query(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     impl_id: ImplId,\n ) -> Arc<ImplDatum> {\n@@ -722,7 +719,7 @@ pub(crate) fn impl_datum_query(\n }\n \n fn impl_def_datum(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     chalk_id: ImplId,\n     impl_id: hir_def::ImplId,\n@@ -734,10 +731,10 @@ fn impl_def_datum(\n         .value;\n     let impl_data = db.impl_data(impl_id);\n \n-    let generic_params = generics(db, impl_id.into());\n+    let generic_params = generics(db.upcast(), impl_id.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n     let trait_ = trait_ref.trait_;\n-    let impl_type = if impl_id.lookup(db).container.module(db).krate == krate {\n+    let impl_type = if impl_id.lookup(db.upcast()).container.module(db.upcast()).krate == krate {\n         chalk_rust_ir::ImplType::Local\n     } else {\n         chalk_rust_ir::ImplType::External\n@@ -786,7 +783,7 @@ fn impl_def_datum(\n }\n \n pub(crate) fn associated_ty_value_query(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     krate: CrateId,\n     id: AssociatedTyValueId,\n ) -> Arc<AssociatedTyValue> {\n@@ -800,12 +797,12 @@ pub(crate) fn associated_ty_value_query(\n }\n \n fn type_alias_associated_ty_value(\n-    db: &impl HirDatabase,\n+    db: &dyn HirDatabase,\n     _krate: CrateId,\n     type_alias: TypeAliasId,\n ) -> Arc<AssociatedTyValue> {\n     let type_alias_data = db.type_alias_data(type_alias);\n-    let impl_id = match type_alias.lookup(db).container {\n+    let impl_id = match type_alias.lookup(db.upcast()).container {\n         AssocContainerId::ImplId(it) => it,\n         _ => panic!(\"assoc ty value should be in impl\"),\n     };"}, {"sha": "b40d4eb73c7f9985481546b223c8a72b78f8aca4", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -14,7 +14,7 @@ use hir_def::{\n };\n use hir_expand::name::{name, Name};\n \n-fn direct_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n+fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n     let resolver = trait_.resolver(db);\n     // returning the iterator directly doesn't easily work because of\n     // lifetime problems, but since there usually shouldn't be more than a\n@@ -43,7 +43,7 @@ fn direct_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n \n /// Returns an iterator over the whole super trait hierarchy (including the\n /// trait itself).\n-pub(super) fn all_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n+pub(super) fn all_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n     // we need to take care a bit here to avoid infinite loops in case of cycles\n     // (i.e. if we have `trait A: B; trait B: A;`)\n     let mut result = vec![trait_];\n@@ -65,15 +65,15 @@ pub(super) fn all_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<Tr\n /// Finds a path from a trait to one of its super traits. Returns an empty\n /// vector if there is no path.\n pub(super) fn find_super_trait_path(\n-    db: &impl DefDatabase,\n+    db: &dyn DefDatabase,\n     trait_: TraitId,\n     super_trait: TraitId,\n ) -> Vec<TraitId> {\n     let mut result = Vec::with_capacity(2);\n     result.push(trait_);\n     return if go(db, super_trait, &mut result) { result } else { Vec::new() };\n \n-    fn go(db: &impl DefDatabase, super_trait: TraitId, path: &mut Vec<TraitId>) -> bool {\n+    fn go(db: &dyn DefDatabase, super_trait: TraitId, path: &mut Vec<TraitId>) -> bool {\n         let trait_ = *path.last().unwrap();\n         if trait_ == super_trait {\n             return true;\n@@ -95,7 +95,7 @@ pub(super) fn find_super_trait_path(\n }\n \n pub(super) fn associated_type_by_name_including_super_traits(\n-    db: &impl DefDatabase,\n+    db: &dyn DefDatabase,\n     trait_: TraitId,\n     name: &Name,\n ) -> Option<TypeAliasId> {\n@@ -104,7 +104,7 @@ pub(super) fn associated_type_by_name_including_super_traits(\n         .find_map(|t| db.trait_data(t).associated_type_by_name(name))\n }\n \n-pub(super) fn variant_data(db: &impl DefDatabase, var: VariantId) -> Arc<VariantData> {\n+pub(super) fn variant_data(db: &dyn DefDatabase, var: VariantId) -> Arc<VariantData> {\n     match var {\n         VariantId::StructId(it) => db.struct_data(it).variant_data.clone(),\n         VariantId::UnionId(it) => db.union_data(it).variant_data.clone(),\n@@ -123,7 +123,7 @@ pub(crate) fn make_mut_slice<T: Clone>(a: &mut Arc<[T]>) -> &mut [T] {\n     Arc::get_mut(a).unwrap()\n }\n \n-pub(crate) fn generics(db: &impl DefDatabase, def: GenericDefId) -> Generics {\n+pub(crate) fn generics(db: &dyn DefDatabase, def: GenericDefId) -> Generics {\n     let parent_generics = parent_generic_def(db, def).map(|def| Box::new(generics(db, def)));\n     Generics { def, params: db.generic_params(def), parent_generics }\n }\n@@ -222,7 +222,7 @@ impl Generics {\n     }\n }\n \n-fn parent_generic_def(db: &impl DefDatabase, def: GenericDefId) -> Option<GenericDefId> {\n+fn parent_generic_def(db: &dyn DefDatabase, def: GenericDefId) -> Option<GenericDefId> {\n     let container = match def {\n         GenericDefId::FunctionId(it) => it.lookup(db).container,\n         GenericDefId::TypeAliasId(it) => it.lookup(db).container,"}, {"sha": "4faeefa8db553229caea44019a94b01e03122a63", "filename": "crates/ra_ide_db/src/lib.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faea2364dee4fbc9391ad233c570b70256ef002/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Flib.rs?ref=9faea2364dee4fbc9391ad233c570b70256ef002", "patch": "@@ -14,10 +14,11 @@ mod wasm_shims;\n \n use std::sync::Arc;\n \n+use hir::db::{AstDatabase, DefDatabase};\n use ra_db::{\n     salsa::{self, Database, Durability},\n     Canceled, CheckCanceled, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath,\n-    SourceDatabase, SourceRootId,\n+    SourceDatabase, SourceRootId, Upcast,\n };\n use rustc_hash::FxHashMap;\n \n@@ -41,6 +42,18 @@ pub struct RootDatabase {\n     pub last_gc_check: crate::wasm_shims::Instant,\n }\n \n+impl Upcast<dyn AstDatabase> for RootDatabase {\n+    fn upcast(&self) -> &(dyn AstDatabase + 'static) {\n+        &*self\n+    }\n+}\n+\n+impl Upcast<dyn DefDatabase> for RootDatabase {\n+    fn upcast(&self) -> &(dyn DefDatabase + 'static) {\n+        &*self\n+    }\n+}\n+\n impl FileLoader for RootDatabase {\n     fn file_text(&self, file_id: FileId) -> Arc<String> {\n         FileLoaderDelegate(self).file_text(file_id)"}]}