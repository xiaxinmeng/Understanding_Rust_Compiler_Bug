{"sha": "7108918db6f59fca6656849c3e360045354e8a42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMDg5MThkYjZmNTlmY2E2NjU2ODQ5YzNlMzYwMDQ1MzU0ZThhNDI=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-03-26T21:40:15Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-03-31T14:16:37Z"}, "message": "Cleanups and comments", "tree": {"sha": "124e089444740f2ac65eef217e221cd832033ef7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/124e089444740f2ac65eef217e221cd832033ef7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7108918db6f59fca6656849c3e360045354e8a42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7108918db6f59fca6656849c3e360045354e8a42", "html_url": "https://github.com/rust-lang/rust/commit/7108918db6f59fca6656849c3e360045354e8a42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7108918db6f59fca6656849c3e360045354e8a42/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c98dc66fdc1bd5a2ff56bc72c67b03c2d376cd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c98dc66fdc1bd5a2ff56bc72c67b03c2d376cd0", "html_url": "https://github.com/rust-lang/rust/commit/0c98dc66fdc1bd5a2ff56bc72c67b03c2d376cd0"}], "stats": {"total": 479, "additions": 214, "deletions": 265}, "files": [{"sha": "7d09ca5152ffe51220243af0fe977162a9894fc5", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7108918db6f59fca6656849c3e360045354e8a42/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7108918db6f59fca6656849c3e360045354e8a42/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=7108918db6f59fca6656849c3e360045354e8a42", "patch": "@@ -504,7 +504,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         let closure_ty = self.mk_closure(closure_def_id, closure_substs);\n         let closure_kind_ty = closure_substs.as_closure().kind_ty();\n         let closure_kind = closure_kind_ty.to_opt_closure_kind()?;\n-        debug_assert!(!closure_ty.has_escaping_bound_vars());\n         let env_ty = match closure_kind {\n             ty::ClosureKind::Fn => self.mk_imm_ref(self.mk_region(env_region), closure_ty),\n             ty::ClosureKind::FnMut => self.mk_mut_ref(self.mk_region(env_region), closure_ty),"}, {"sha": "9ca4b6687f1b54b934eaf0319653cb4c39d1c735", "filename": "compiler/rustc_mir/src/monomorphize/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7108918db6f59fca6656849c3e360045354e8a42/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7108918db6f59fca6656849c3e360045354e8a42/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fmod.rs?ref=7108918db6f59fca6656849c3e360045354e8a42", "patch": "@@ -1,6 +1,6 @@\n use rustc_middle::traits;\n use rustc_middle::ty::adjustment::CustomCoerceUnsized;\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n \n use rustc_hir::lang_items::LangItem;\n \n@@ -15,8 +15,6 @@ fn custom_coerce_unsize_info<'tcx>(\n ) -> CustomCoerceUnsized {\n     let def_id = tcx.require_lang_item(LangItem::CoerceUnsized, None);\n \n-    debug_assert!(!source_ty.has_escaping_bound_vars());\n-    debug_assert!(!target_ty.has_escaping_bound_vars());\n     let trait_ref = ty::Binder::dummy(ty::TraitRef {\n         def_id,\n         substs: tcx.mk_substs_trait(source_ty, &[target_ty.into()]),"}, {"sha": "1377bb781d0086089efd4eec3539947b8e69d05d", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7108918db6f59fca6656849c3e360045354e8a42/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7108918db6f59fca6656849c3e360045354e8a42/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=7108918db6f59fca6656849c3e360045354e8a42", "patch": "@@ -34,7 +34,6 @@ use tracing::debug;\n \n mod diagnostics;\n crate mod lifetimes;\n-crate mod supertraits;\n \n type Res = def::Res<NodeId>;\n "}, {"sha": "b89ad867f46ee82507d88c0509f94b47e6a26ce2", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 211, "deletions": 196, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/7108918db6f59fca6656849c3e360045354e8a42/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7108918db6f59fca6656849c3e360045354e8a42/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=7108918db6f59fca6656849c3e360045354e8a42", "patch": "@@ -151,6 +151,12 @@ struct NamedRegionMap {\n     // (b) it DOES appear in the arguments.\n     late_bound: HirIdSet,\n \n+    // Maps relevant hir items to the bound vars on them. These include:\n+    // - function defs\n+    // - function pointers\n+    // - closures\n+    // - trait refs\n+    // - bound types (like `T` in `for<'a> T<'a>: Foo`)\n     late_bound_vars: HirIdMap<Vec<ty::BoundVariableKind>>,\n }\n \n@@ -171,10 +177,16 @@ crate struct LifetimeContext<'a, 'tcx> {\n     /// any bound var information.\n     ///\n     /// So, if we encounter a quantifier at the outer scope, we set\n-    /// `trait_ref_hack` to `true` (and introduce a scope), and then if we encounter\n-    /// a quantifier at the inner scope, we error. If `trait_ref_hack` is `false`,\n-    /// then we introduce the scope at the inner quantifier.\n-    trait_ref_hack: Option<(Vec<ty::BoundVariableKind>, u32)>,\n+    /// `trait_ref_hack` to the hir id of the bounded type (and introduce a scope).\n+    /// Then, if we encounter a quantifier at the inner scope, then we know to\n+    /// emit an error. Importantly though, we do have to track the lifetimes\n+    /// defined on the outer scope (i.e. the bounded ty), since we continue\n+    /// to type check after emitting an error; we therefore assume that the bound\n+    /// vars on the inner trait refs come from both quantifiers.\n+    ///\n+    /// If we encounter a quantifier in the inner scope `trait_ref_hack` being\n+    /// `None`, then we just introduce the scope at the inner quantifier as normal.\n+    trait_ref_hack: Option<hir::HirId>,\n \n     /// Used to disallow the use of in-band lifetimes in `fn` or `Fn` syntax.\n     is_in_fn_syntax: bool,\n@@ -232,11 +244,9 @@ enum Scope<'a> {\n         /// of the resulting opaque type.\n         opaque_type_parent: bool,\n \n-        /// We need to keep track of the number of named late bound vars, since\n-        /// we may have elided lifetimes that have an index starting *after*\n-        /// these.\n-        named_late_bound_vars: u32,\n-\n+        /// True only if this `Binder` scope is from the quantifiers on a\n+        /// `PolyTraitRef`. This is necessary for `assocated_type_bounds`, which\n+        /// requires binders of nested trait refs to be merged.\n         from_poly_trait_ref: bool,\n \n         /// The late bound vars for a given item are stored by `HirId` to be\n@@ -304,7 +314,6 @@ enum Scope<'a> {\n     /// vars from both `for<...>`s *do* share the same binder level.\n     TraitRefHackInner {\n         hir_id: hir::HirId,\n-        named_late_bound_vars: u32,\n         s: ScopeRef<'a>,\n     },\n \n@@ -331,7 +340,6 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 next_early_index,\n                 track_lifetime_uses,\n                 opaque_type_parent,\n-                named_late_bound_vars,\n                 from_poly_trait_ref,\n                 hir_id,\n                 s: _,\n@@ -341,7 +349,6 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"next_early_index\", next_early_index)\n                 .field(\"track_lifetime_uses\", track_lifetime_uses)\n                 .field(\"opaque_type_parent\", opaque_type_parent)\n-                .field(\"named_late_bound_vars\", named_late_bound_vars)\n                 .field(\"from_poly_trait_ref\", from_poly_trait_ref)\n                 .field(\"hir_id\", hir_id)\n                 .field(\"s\", &\"..\")\n@@ -357,10 +364,9 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"lifetime\", lifetime)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n-            Scope::TraitRefHackInner { hir_id, named_late_bound_vars, s: _ } => f\n+            Scope::TraitRefHackInner { hir_id, s: _ } => f\n                 .debug_struct(\"TraitRefHackInner\")\n                 .field(\"hir_id\", hir_id)\n-                .field(\"named_late_bound_vars\", named_late_bound_vars)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::Supertrait { lifetimes, s: _ } => f\n@@ -664,7 +670,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n-                    named_late_bound_vars: 0,\n                     from_poly_trait_ref: false,\n                 };\n                 self.with(scope, move |_old_scope, this| {\n@@ -790,7 +795,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index: index + non_lifetime_count,\n                     opaque_type_parent: true,\n                     track_lifetime_uses,\n-                    named_late_bound_vars: 0,\n                     from_poly_trait_ref: false,\n                     s: ROOT_SCOPE,\n                 };\n@@ -838,21 +842,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.missing_named_lifetime_spots\n                     .push(MissingLifetimeSpot::HigherRanked { span, span_type });\n-                let mut named_late_bound_vars = 0;\n                 let (lifetimes, binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            let late_bound_idx = named_late_bound_vars;\n-                            named_late_bound_vars += 1;\n-                            let pair = Region::late(late_bound_idx, &self.tcx.hir(), param);\n-                            let r = pair.1.clone();\n-                            let r = late_region_as_bound_region(self.tcx, &r);\n-                            Some((pair, r))\n-                        }\n+                        GenericParamKind::Lifetime { .. } => Some(param),\n                         _ => None,\n                     })\n+                    .enumerate()\n+                    .map(|(late_bound_idx, param)| {\n+                        let pair = Region::late(late_bound_idx as u32, &self.tcx.hir(), param);\n+                        let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                        (pair, r)\n+                    })\n                     .unzip();\n                 self.map.late_bound_vars.insert(ty.hir_id, binders);\n                 let scope = Scope::Binder {\n@@ -862,7 +864,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n-                    named_late_bound_vars,\n                     from_poly_trait_ref: false,\n                 };\n                 self.with(scope, |old_scope, this| {\n@@ -1053,7 +1054,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             s: this.scope,\n                             track_lifetime_uses: true,\n                             opaque_type_parent: false,\n-                            named_late_bound_vars: 0,\n                             from_poly_trait_ref: false,\n                         };\n                         this.with(scope, |_old_scope, this| {\n@@ -1071,7 +1071,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         s: self.scope,\n                         track_lifetime_uses: true,\n                         opaque_type_parent: false,\n-                        named_late_bound_vars: 0,\n                         from_poly_trait_ref: false,\n                     };\n                     self.with(scope, |_old_scope, this| {\n@@ -1128,7 +1127,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: true,\n-                    named_late_bound_vars: 0,\n                     from_poly_trait_ref: false,\n                 };\n                 self.with(scope, |old_scope, this| {\n@@ -1195,7 +1193,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: true,\n-                    named_late_bound_vars: 0,\n                     from_poly_trait_ref: false,\n                 };\n                 self.with(scope, |old_scope, this| {\n@@ -1279,21 +1276,21 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     ref bound_generic_params,\n                     ..\n                 }) => {\n-                    let mut named_late_bound_vars = 0;\n-                    let (lifetimes, binders): (FxHashMap<_, _>, Vec<_>) = bound_generic_params\n-                        .iter()\n-                        .filter_map(|param| match param.kind {\n-                            GenericParamKind::Lifetime { .. } => {\n-                                let late_bound_idx = named_late_bound_vars;\n-                                named_late_bound_vars += 1;\n-                                let pair = Region::late(late_bound_idx, &self.tcx.hir(), param);\n-                                let r = pair.1.clone();\n-                                let r = late_region_as_bound_region(self.tcx, &r);\n-                                Some((pair, r))\n-                            }\n-                            _ => None,\n-                        })\n-                        .unzip();\n+                    let (lifetimes, binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) =\n+                        bound_generic_params\n+                            .iter()\n+                            .filter_map(|param| match param.kind {\n+                                GenericParamKind::Lifetime { .. } => Some(param),\n+                                _ => None,\n+                            })\n+                            .enumerate()\n+                            .map(|(late_bound_idx, param)| {\n+                                let pair =\n+                                    Region::late(late_bound_idx as u32, &self.tcx.hir(), param);\n+                                let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                                (pair, r)\n+                            })\n+                            .unzip();\n                     self.map.late_bound_vars.insert(bounded_ty.hir_id, binders.clone());\n                     if !lifetimes.is_empty() {\n                         let next_early_index = self.next_early_index();\n@@ -1304,13 +1301,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             next_early_index,\n                             track_lifetime_uses: true,\n                             opaque_type_parent: false,\n-                            named_late_bound_vars,\n                             from_poly_trait_ref: true,\n                         };\n                         let result = self.with(scope, |old_scope, this| {\n                             this.check_lifetime_params(old_scope, &bound_generic_params);\n                             this.visit_ty(&bounded_ty);\n-                            this.trait_ref_hack = Some((binders, named_late_bound_vars));\n+                            this.trait_ref_hack = Some(bounded_ty.hir_id);\n                             walk_list!(this, visit_param_bound, bounds);\n                             this.trait_ref_hack = None;\n                         });\n@@ -1351,7 +1347,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index: self.next_early_index(),\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n-                    named_late_bound_vars: 0,\n                     from_poly_trait_ref: false,\n                 };\n                 self.with(scope, |_, this| {\n@@ -1389,112 +1384,97 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             .emit();\n         }\n \n-        let (binders, named_late_bound_vars, lifetimes) =\n-            if let Some((mut binders, mut named_late_bound_vars)) = trait_ref_hack.clone() {\n-                let initial_binders = named_late_bound_vars;\n-                binders.extend(trait_ref.bound_generic_params.iter().filter_map(|param| {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            let late_bound_idx = named_late_bound_vars;\n-                            named_late_bound_vars += 1;\n-                            let region = Region::late(late_bound_idx, &self.tcx.hir(), param).1;\n-                            Some(late_region_as_bound_region(self.tcx, &region))\n-                        }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n-                    }\n-                }));\n-\n-                let mut named_late_bound_vars = initial_binders;\n-                let lifetimes: FxHashMap<hir::ParamName, Region> = trait_ref\n-                    .bound_generic_params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            let late_bound_idx = named_late_bound_vars;\n-                            named_late_bound_vars += 1;\n-                            Some(Region::late(late_bound_idx, &self.tcx.hir(), param))\n-                        }\n-                        _ => None,\n-                    })\n-                    .collect();\n-\n-                (binders, named_late_bound_vars, lifetimes)\n-            } else {\n-                let mut supertrait_lifetimes = vec![];\n-                let mut scope = self.scope;\n-                let mut binders = loop {\n-                    match scope {\n-                        Scope::Body { .. } | Scope::Root => {\n-                            break vec![];\n-                        }\n+        let (binders, lifetimes) = if let Some(hir_id) = trait_ref_hack {\n+            let mut binders = self.map.late_bound_vars.entry(hir_id).or_default().clone();\n+            let initial_bound_vars = binders.len() as u32;\n+            let mut lifetimes: FxHashMap<hir::ParamName, Region> = FxHashMap::default();\n+            let binders_iter = trait_ref\n+                .bound_generic_params\n+                .iter()\n+                .filter_map(|param| match param.kind {\n+                    GenericParamKind::Lifetime { .. } => Some(param),\n+                    _ => None,\n+                })\n+                .enumerate()\n+                .map(|(late_bound_idx, param)| {\n+                    let pair = Region::late(\n+                        initial_bound_vars + late_bound_idx as u32,\n+                        &self.tcx.hir(),\n+                        param,\n+                    );\n+                    let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                    lifetimes.insert(pair.0, pair.1);\n+                    r\n+                });\n+            binders.extend(binders_iter);\n \n-                        Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n-                            scope = s;\n-                        }\n+            (binders, lifetimes)\n+        } else {\n+            let mut supertrait_lifetimes = vec![];\n+            let mut scope = self.scope;\n+            let mut outer_binders = loop {\n+                match scope {\n+                    Scope::Body { .. } | Scope::Root => {\n+                        break vec![];\n+                    }\n \n-                        Scope::TraitRefHackInner { hir_id, .. } => {\n-                            // Nested poly trait refs have the binders concatenated\n-                            // If we reach `TraitRefHackInner`, then there is only one more `Binder` above us,\n-                            // over all the bounds. We don't want this, since all the lifetimes we care about\n-                            // are here anyways.\n-                            let mut full_binders =\n-                                self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n-                            full_binders.extend(supertrait_lifetimes.into_iter());\n-                            break full_binders;\n-                        }\n+                    Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n+                        scope = s;\n+                    }\n \n-                        Scope::Supertrait { s, lifetimes } => {\n-                            supertrait_lifetimes = lifetimes.clone();\n-                            scope = s;\n-                        }\n+                    Scope::TraitRefHackInner { hir_id, .. } => {\n+                        // Nested poly trait refs have the binders concatenated\n+                        // If we reach `TraitRefHackInner`, then there is only one more `Binder` above us,\n+                        // over all the bounds. We don't want this, since all the lifetimes we care about\n+                        // are here anyways.\n+                        let mut full_binders =\n+                            self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n+                        full_binders.extend(supertrait_lifetimes.into_iter());\n+                        break full_binders;\n+                    }\n \n-                        Scope::Binder { hir_id, from_poly_trait_ref, .. } => {\n-                            if !from_poly_trait_ref {\n-                                // We should only see super trait lifetimes if there is a `Binder` above\n-                                assert!(supertrait_lifetimes.is_empty());\n-                                break vec![];\n-                            }\n-                            // Nested poly trait refs have the binders concatenated\n-                            let mut full_binders =\n-                                self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n-                            full_binders.extend(supertrait_lifetimes.into_iter());\n-                            break full_binders;\n-                        }\n+                    Scope::Supertrait { s, lifetimes } => {\n+                        supertrait_lifetimes = lifetimes.clone();\n+                        scope = s;\n                     }\n-                };\n-                let mut named_late_bound_vars = binders.len() as u32;\n-                let local_binders: Vec<_> = trait_ref\n-                    .bound_generic_params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            let late_bound_idx = named_late_bound_vars;\n-                            named_late_bound_vars += 1;\n-                            let region = Region::late(late_bound_idx, &self.tcx.hir(), param).1;\n-                            Some(late_region_as_bound_region(self.tcx, &region))\n-                        }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n-                    })\n-                    .collect();\n \n-                let mut named_late_bound_vars = binders.len() as u32;\n-                let lifetimes: FxHashMap<hir::ParamName, Region> = trait_ref\n-                    .bound_generic_params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            let late_bound_idx = named_late_bound_vars;\n-                            named_late_bound_vars += 1;\n-                            Some(Region::late(late_bound_idx, &self.tcx.hir(), param))\n+                    Scope::Binder { hir_id, from_poly_trait_ref, .. } => {\n+                        if !from_poly_trait_ref {\n+                            // We should only see super trait lifetimes if there is a `Binder` above\n+                            assert!(supertrait_lifetimes.is_empty());\n+                            break vec![];\n                         }\n-                        _ => None,\n-                    })\n-                    .collect();\n+                        // Nested poly trait refs have the binders concatenated\n+                        let mut full_binders =\n+                            self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n+                        full_binders.extend(supertrait_lifetimes.into_iter());\n+                        break full_binders;\n+                    }\n+                }\n+            };\n+            let (lifetimes, local_binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) = trait_ref\n+                .bound_generic_params\n+                .iter()\n+                .filter_map(|param| match param.kind {\n+                    GenericParamKind::Lifetime { .. } => Some(param),\n+                    _ => None,\n+                })\n+                .enumerate()\n+                .map(|(late_bound_idx, param)| {\n+                    let pair = Region::late(\n+                        outer_binders.len() as u32 + late_bound_idx as u32,\n+                        &self.tcx.hir(),\n+                        param,\n+                    );\n+                    let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                    (pair, r)\n+                })\n+                .unzip();\n \n-                binders.extend(local_binders.into_iter());\n+            outer_binders.extend(local_binders.into_iter());\n \n-                (binders, named_late_bound_vars, lifetimes)\n-            };\n+            (outer_binders, lifetimes)\n+        };\n \n         debug!(?binders);\n         self.map.late_bound_vars.insert(trait_ref.trait_ref.hir_ref_id, binders);\n@@ -1507,7 +1487,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 next_early_index,\n                 track_lifetime_uses: true,\n                 opaque_type_parent: false,\n-                named_late_bound_vars: named_late_bound_vars as u32,\n                 from_poly_trait_ref: true,\n             };\n             self.with(scope, |old_scope, this| {\n@@ -1516,11 +1495,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 this.visit_trait_ref(&trait_ref.trait_ref);\n             });\n         } else {\n-            let scope = Scope::TraitRefHackInner {\n-                hir_id: trait_ref.trait_ref.hir_ref_id,\n-                named_late_bound_vars: named_late_bound_vars as u32,\n-                s: self.scope,\n-            };\n+            let scope =\n+                Scope::TraitRefHackInner { hir_id: trait_ref.trait_ref.hir_ref_id, s: self.scope };\n             self.with(scope, |_old_scope, this| {\n                 this.visit_trait_ref(&trait_ref.trait_ref);\n             });\n@@ -2234,23 +2210,22 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             .collect();\n         let next_early_index = next_early_index + non_lifetime_count;\n \n-        let mut named_late_bound_vars = 0;\n         let binders: Vec<_> = generics\n             .params\n             .iter()\n             .filter_map(|param| match param.kind {\n-                GenericParamKind::Lifetime { .. } => {\n-                    if self.map.late_bound.contains(&param.hir_id) {\n-                        let late_bound_idx = named_late_bound_vars;\n-                        named_late_bound_vars += 1;\n-                        let r = Region::late(late_bound_idx, &self.tcx.hir(), param).1;\n-                        let r = late_region_as_bound_region(self.tcx, &r);\n-                        Some(r)\n-                    } else {\n-                        None\n-                    }\n+                GenericParamKind::Lifetime { .. }\n+                    if self.map.late_bound.contains(&param.hir_id) =>\n+                {\n+                    Some(param)\n                 }\n-                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n+                _ => None,\n+            })\n+            .enumerate()\n+            .map(|(late_bound_idx, param)| {\n+                let pair = Region::late(late_bound_idx as u32, &self.tcx.hir(), param);\n+                let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                r\n             })\n             .collect();\n         self.map.late_bound_vars.insert(hir_id, binders);\n@@ -2261,7 +2236,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             s: self.scope,\n             opaque_type_parent: true,\n             track_lifetime_uses: false,\n-            named_late_bound_vars: named_late_bound_vars as u32,\n             from_poly_trait_ref: false,\n         };\n         self.with(scope, move |old_scope, this| {\n@@ -2629,49 +2603,85 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let has_lifetime_parameter =\n             generic_args.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)));\n \n-        // Resolve lifetimes found in the type `XX` from `Item = XX` bindings.\n+        // Resolve lifetimes found in the bindings, so either in the type `XX` in `Item = XX` or\n+        // in the trait ref `YY<...>` in `Item: YY<...>`.\n         for binding in generic_args.bindings {\n             let scope = Scope::ObjectLifetimeDefault {\n                 lifetime: if has_lifetime_parameter { None } else { Some(Region::Static) },\n                 s: self.scope,\n             };\n             if let Some(type_def_id) = type_def_id {\n-                let lifetimes =\n-                    LifetimeContext::supertrait_bounds(self.tcx, type_def_id, binding.ident);\n-                if let Some(lifetimes) = lifetimes {\n-                    self.with(scope, |_, this| {\n-                        let scope = Scope::Supertrait { lifetimes, s: this.scope };\n-                        this.with(scope, |_, this| this.visit_assoc_type_binding(binding));\n-                    });\n-                } else {\n-                    self.with(scope, |_, this| this.visit_assoc_type_binding(binding));\n-                }\n+                let lifetimes = LifetimeContext::supertrait_hrtb_lifetimes(\n+                    self.tcx,\n+                    type_def_id,\n+                    binding.ident,\n+                );\n+                self.with(scope, |_, this| {\n+                    let scope =\n+                        Scope::Supertrait { lifetimes: lifetimes.unwrap_or(vec![]), s: this.scope };\n+                    this.with(scope, |_, this| this.visit_assoc_type_binding(binding));\n+                });\n             } else {\n                 self.with(scope, |_, this| this.visit_assoc_type_binding(binding));\n             }\n         }\n     }\n \n-    fn trait_defines_associated_type_named(\n-        tcx: TyCtxt<'tcx>,\n-        trait_def_id: DefId,\n-        assoc_name: Ident,\n-    ) -> bool {\n-        tcx.associated_items(trait_def_id)\n-            .find_by_name_and_kind(tcx, assoc_name, ty::AssocKind::Type, trait_def_id)\n-            .is_some()\n-    }\n-\n-    fn supertrait_bounds(\n+    /// Returns all the late-bound vars that come into scope from supertrait HRTBs, based on the\n+    /// associated type name and starting trait.\n+    /// For example, imagine we have\n+    /// ```rust\n+    /// trait Foo<'a, 'b> {\n+    ///   type As;\n+    /// }\n+    /// trait Bar<'b>: for<'a> Foo<'a, 'b> {}\n+    /// trait Bar: for<'b> Bar<'b> {}\n+    /// ```\n+    /// In this case, if we wanted to the supertrait HRTB lifetimes for `As` on\n+    /// the starting trait `Bar`, we would return `Some(['b, 'a])`.\n+    fn supertrait_hrtb_lifetimes(\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         assoc_name: Ident,\n     ) -> Option<Vec<ty::BoundVariableKind>> {\n-        let all_candidates = super::supertraits::supertraits(tcx, def_id);\n-        let mut matching_candidates = all_candidates\n-            .filter(|r| LifetimeContext::trait_defines_associated_type_named(tcx, r.0, assoc_name));\n+        let trait_defines_associated_type_named = |trait_def_id: DefId| {\n+            tcx.associated_items(trait_def_id)\n+                .find_by_name_and_kind(tcx, assoc_name, ty::AssocKind::Type, trait_def_id)\n+                .is_some()\n+        };\n+\n+        use smallvec::{smallvec, SmallVec};\n+        let mut stack: SmallVec<[(DefId, SmallVec<[ty::BoundVariableKind; 8]>); 8]> =\n+            smallvec![(def_id, smallvec![])];\n+        let mut visited: FxHashSet<DefId> = FxHashSet::default();\n+        loop {\n+            let (def_id, bound_vars) = match stack.pop() {\n+                Some(next) => next,\n+                None => break None,\n+            };\n+            if trait_defines_associated_type_named(def_id) {\n+                break Some(bound_vars.into_iter().collect());\n+            }\n+            let predicates =\n+                tcx.super_predicates_that_define_assoc_type((def_id, Some(assoc_name)));\n+            let obligations = predicates.predicates.iter().filter_map(|&(pred, _)| {\n+                let bound_predicate = pred.kind();\n+                match bound_predicate.skip_binder() {\n+                    ty::PredicateKind::Trait(data, _) => {\n+                        // The order here needs to match what we would get from `subst_supertrait`\n+                        let pred_bound_vars = bound_predicate.bound_vars();\n+                        let mut all_bound_vars = bound_vars.clone();\n+                        all_bound_vars.extend(pred_bound_vars.iter());\n+                        let super_def_id = data.trait_ref.def_id;\n+                        Some((super_def_id, all_bound_vars))\n+                    }\n+                    _ => None,\n+                }\n+            });\n \n-        matching_candidates.next().map(|c| c.1.into_iter().collect())\n+            let obligations = obligations.filter(|o| visited.insert(o.0));\n+            stack.extend(obligations);\n+        }\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n@@ -2682,13 +2692,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     ) {\n         debug!(\"visit_fn_like_elision: enter\");\n         let mut scope = &*self.scope;\n-        let (hir_id, named_late_bound_vars) = loop {\n+        let hir_id = loop {\n             match scope {\n-                Scope::Binder { hir_id, named_late_bound_vars, .. }\n-                | Scope::TraitRefHackInner { hir_id, named_late_bound_vars, .. } => {\n-                    break (*hir_id, *named_late_bound_vars);\n+                Scope::Binder { hir_id, .. } | Scope::TraitRefHackInner { hir_id, .. } => {\n+                    break *hir_id;\n                 }\n-                Scope::Body { id, .. } => break (id.hir_id, 0),\n+                Scope::Body { id, .. } => break id.hir_id,\n                 Scope::ObjectLifetimeDefault { ref s, .. }\n                 | Scope::Elision { ref s, .. }\n                 | Scope::Supertrait { ref s, .. } => {\n@@ -2697,11 +2706,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Root => bug!(\"In fn_like_elision without appropriate scope above\"),\n             }\n         };\n+        // While not strictly necessary, we gather anon lifetimes *before* actually\n+        // visiting the argument types.\n         let mut gather = GatherAnonLifetimes { anon_count: 0 };\n         for input in inputs {\n             gather.visit_ty(input);\n         }\n-        self.map.late_bound_vars.entry(hir_id).or_default().extend(\n+        let late_bound_vars = self.map.late_bound_vars.entry(hir_id).or_default();\n+        let named_late_bound_vars = late_bound_vars.len() as u32;\n+        late_bound_vars.extend(\n             (0..gather.anon_count).map(|var| ty::BoundVariableKind::Region(ty::BrAnon(var))),\n         );\n         let arg_scope = Scope::Elision {\n@@ -2987,6 +3000,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n+                // If we enter a `BareFn`, then we enter a *new* binding scope\n                 if let hir::TyKind::BareFn(_) = ty.kind {\n                     return;\n                 }\n@@ -2998,6 +3012,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 path_span: Span,\n                 generic_args: &'v hir::GenericArgs<'v>,\n             ) {\n+                // parenthesized args enter a new elison scope\n                 if generic_args.parenthesized {\n                     return;\n                 }"}, {"sha": "2130c33bd770b38fe4622922575dd34aa6eb71ce", "filename": "compiler/rustc_resolve/src/late/supertraits.rs", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0c98dc66fdc1bd5a2ff56bc72c67b03c2d376cd0/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fsupertraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c98dc66fdc1bd5a2ff56bc72c67b03c2d376cd0/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fsupertraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fsupertraits.rs?ref=0c98dc66fdc1bd5a2ff56bc72c67b03c2d376cd0", "patch": "@@ -1,60 +0,0 @@\n-use smallvec::{smallvec, SmallVec};\n-\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::{self, TyCtxt};\n-\n-pub struct Elaborator<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    stack: SmallVec<[(DefId, SmallVec<[ty::BoundVariableKind; 8]>); 8]>,\n-    visited: FxHashSet<DefId>,\n-}\n-\n-#[allow(dead_code)]\n-pub fn supertraits<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Elaborator<'tcx> {\n-    Elaborator { tcx, stack: smallvec![(def_id, smallvec![])], visited: Default::default() }\n-}\n-\n-impl<'tcx> Elaborator<'tcx> {\n-    fn elaborate(&mut self, def_id: DefId, bound_vars: &SmallVec<[ty::BoundVariableKind; 8]>) {\n-        let tcx = self.tcx;\n-\n-        let predicates = tcx.super_predicates_of(def_id);\n-        let obligations = predicates.predicates.iter().filter_map(|&(pred, _)| {\n-            let bound_predicate = pred.kind();\n-            match bound_predicate.skip_binder() {\n-                ty::PredicateKind::Trait(data, _) => {\n-                    // The order here needs to match what we would get from `subst_supertrait`\n-                    let pred_bound_vars = bound_predicate.bound_vars();\n-                    let mut all_bound_vars = bound_vars.clone();\n-                    all_bound_vars.extend(pred_bound_vars.iter());\n-                    let super_def_id = data.trait_ref.def_id;\n-                    Some((super_def_id, all_bound_vars))\n-                }\n-                _ => None,\n-            }\n-        });\n-\n-        let visited = &mut self.visited;\n-        let obligations = obligations.filter(|o| visited.insert(o.0));\n-        self.stack.extend(obligations);\n-    }\n-}\n-\n-impl<'tcx> Iterator for Elaborator<'tcx> {\n-    type Item = (DefId, SmallVec<[ty::BoundVariableKind; 8]>);\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.stack.len(), None)\n-    }\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self.stack.pop() {\n-            Some((def_id, bound_vars)) => {\n-                self.elaborate(def_id, &bound_vars);\n-                Some((def_id, bound_vars))\n-            }\n-            None => None,\n-        }\n-    }\n-}"}, {"sha": "f54eb0914a5a7b1500bfcc228e190280b38f4786", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7108918db6f59fca6656849c3e360045354e8a42/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7108918db6f59fca6656849c3e360045354e8a42/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=7108918db6f59fca6656849c3e360045354e8a42", "patch": "@@ -82,7 +82,6 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     ) -> AutoTraitResult<A> {\n         let tcx = self.tcx;\n \n-        debug_assert!(!ty.has_escaping_bound_vars());\n         let trait_ref = ty::TraitRef { def_id: trait_did, substs: tcx.mk_substs_trait(ty, &[]) };\n \n         let trait_pred = ty::Binder::dummy(trait_ref);"}, {"sha": "b6de491911ab7c260c5d48bb40fd0dbd21e1c257", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7108918db6f59fca6656849c3e360045354e8a42/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7108918db6f59fca6656849c3e360045354e8a42/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=7108918db6f59fca6656849c3e360045354e8a42", "patch": "@@ -2186,13 +2186,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n     }\n \n+    /// Parses the programmer's textual representation of a type into our\n+    /// internal notion of a type.\n     pub fn ast_ty_to_ty(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n         self.ast_ty_to_ty_inner(ast_ty, false)\n     }\n \n-    /// Parses the programmer's textual representation of a type into our\n-    /// internal notion of a type.\n-    ///\n     /// Turns a `hir::Ty` into a `Ty`. For diagnostics' purposes we keep track of whether trait\n     /// objects are borrowed like `&dyn Trait` to avoid emitting redundant errors.\n     #[tracing::instrument(level = \"debug\", skip(self))]"}]}