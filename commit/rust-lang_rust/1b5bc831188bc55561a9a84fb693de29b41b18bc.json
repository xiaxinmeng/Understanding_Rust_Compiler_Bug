{"sha": "1b5bc831188bc55561a9a84fb693de29b41b18bc", "node_id": "C_kwDOAAsO6NoAKDFiNWJjODMxMTg4YmM1NTU2MWE5YTg0ZmI2OTNkZTI5YjQxYjE4YmM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-04T13:45:57Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-04T13:45:57Z"}, "message": "Remove weird nesting of effect blocks in hir", "tree": {"sha": "de9afdf98671436fbe63e24e293757ba5f94e5b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de9afdf98671436fbe63e24e293757ba5f94e5b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b5bc831188bc55561a9a84fb693de29b41b18bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b5bc831188bc55561a9a84fb693de29b41b18bc", "html_url": "https://github.com/rust-lang/rust/commit/1b5bc831188bc55561a9a84fb693de29b41b18bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b5bc831188bc55561a9a84fb693de29b41b18bc/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24ba1bed040f7d8f483b250dbd4e49383823f644", "url": "https://api.github.com/repos/rust-lang/rust/commits/24ba1bed040f7d8f483b250dbd4e49383823f644", "html_url": "https://github.com/rust-lang/rust/commit/24ba1bed040f7d8f483b250dbd4e49383823f644"}], "stats": {"total": 532, "additions": 285, "deletions": 247}, "files": [{"sha": "3164a5f4c290680d9467f949613d0a202f75b3aa", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=1b5bc831188bc55561a9a84fb693de29b41b18bc", "patch": "@@ -37,7 +37,7 @@ use crate::{\n     item_scope::BuiltinShadowMode,\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n-    AdtId, BlockLoc, ModuleDefId, UnresolvedMacro,\n+    AdtId, BlockId, BlockLoc, ModuleDefId, UnresolvedMacro,\n };\n \n pub struct LowerCtx<'a> {\n@@ -238,33 +238,32 @@ impl ExprCollector<'_> {\n             }\n             ast::Expr::BlockExpr(e) => match e.modifier() {\n                 Some(ast::BlockModifier::Try(_)) => {\n-                    let body = self.collect_block(e);\n-                    self.alloc_expr(Expr::TryBlock { body }, syntax_ptr)\n+                    self.collect_block_(e, |id, statements, tail| Expr::TryBlock {\n+                        id,\n+                        statements,\n+                        tail,\n+                    })\n                 }\n                 Some(ast::BlockModifier::Unsafe(_)) => {\n-                    let body = self.collect_block(e);\n-                    self.alloc_expr(Expr::Unsafe { body }, syntax_ptr)\n+                    self.collect_block_(e, |id, statements, tail| Expr::Unsafe {\n+                        id,\n+                        statements,\n+                        tail,\n+                    })\n                 }\n-                // FIXME: we need to record these effects somewhere...\n                 Some(ast::BlockModifier::Label(label)) => {\n                     let label = self.collect_label(label);\n-                    let res = self.collect_block(e);\n-                    match &mut self.body.exprs[res] {\n-                        Expr::Block { label: block_label, .. } => {\n-                            *block_label = Some(label);\n-                        }\n-                        _ => unreachable!(),\n-                    }\n-                    res\n-                }\n-                Some(ast::BlockModifier::Async(_)) => {\n-                    let body = self.collect_block(e);\n-                    self.alloc_expr(Expr::Async { body }, syntax_ptr)\n-                }\n-                Some(ast::BlockModifier::Const(_)) => {\n-                    let body = self.collect_block(e);\n-                    self.alloc_expr(Expr::Const { body }, syntax_ptr)\n+                    self.collect_block_(e, |id, statements, tail| Expr::Block {\n+                        id,\n+                        statements,\n+                        tail,\n+                        label: Some(label),\n+                    })\n                 }\n+                Some(ast::BlockModifier::Async(_)) => self\n+                    .collect_block_(e, |id, statements, tail| Expr::Async { id, statements, tail }),\n+                Some(ast::BlockModifier::Const(_)) => self\n+                    .collect_block_(e, |id, statements, tail| Expr::Const { id, statements, tail }),\n                 None => self.collect_block(e),\n             },\n             ast::Expr::LoopExpr(e) => {\n@@ -737,6 +736,19 @@ impl ExprCollector<'_> {\n     }\n \n     fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {\n+        self.collect_block_(block, |id, statements, tail| Expr::Block {\n+            id,\n+            statements,\n+            tail,\n+            label: None,\n+        })\n+    }\n+\n+    fn collect_block_(\n+        &mut self,\n+        block: ast::BlockExpr,\n+        mk_block: impl FnOnce(BlockId, Box<[Statement]>, Option<ExprId>) -> Expr,\n+    ) -> ExprId {\n         let file_local_id = self.ast_id_map.ast_id(&block);\n         let ast_id = AstId::new(self.expander.current_file_id, file_local_id);\n         let block_loc =\n@@ -769,15 +781,8 @@ impl ExprCollector<'_> {\n         });\n \n         let syntax_node_ptr = AstPtr::new(&block.into());\n-        let expr_id = self.alloc_expr(\n-            Expr::Block {\n-                id: block_id,\n-                statements: statements.into_boxed_slice(),\n-                tail,\n-                label: None,\n-            },\n-            syntax_node_ptr,\n-        );\n+        let expr_id = self\n+            .alloc_expr(mk_block(block_id, statements.into_boxed_slice(), tail), syntax_node_ptr);\n \n         self.expander.def_map = prev_def_map;\n         self.expander.module = prev_local_module;"}, {"sha": "622756ee8a97969906ba3bb1b2cf00621e1590ab", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=1b5bc831188bc55561a9a84fb693de29b41b18bc", "patch": "@@ -292,18 +292,6 @@ impl<'a> Printer<'a> {\n                 self.print_expr(*expr);\n                 w!(self, \"?\");\n             }\n-            Expr::TryBlock { body } => {\n-                w!(self, \"try \");\n-                self.print_expr(*body);\n-            }\n-            Expr::Async { body } => {\n-                w!(self, \"async \");\n-                self.print_expr(*body);\n-            }\n-            Expr::Const { body } => {\n-                w!(self, \"const \");\n-                self.print_expr(*body);\n-            }\n             Expr::Cast { expr, type_ref } => {\n                 self.print_expr(*expr);\n                 w!(self, \" as \");\n@@ -402,10 +390,6 @@ impl<'a> Printer<'a> {\n                 }\n                 w!(self, \")\");\n             }\n-            Expr::Unsafe { body } => {\n-                w!(self, \"unsafe \");\n-                self.print_expr(*body);\n-            }\n             Expr::Array(arr) => {\n                 w!(self, \"[\");\n                 if !matches!(arr, Array::ElementList { elements, .. } if elements.is_empty()) {\n@@ -428,25 +412,47 @@ impl<'a> Printer<'a> {\n             }\n             Expr::Literal(lit) => self.print_literal(lit),\n             Expr::Block { id: _, statements, tail, label } => {\n-                self.whitespace();\n-                if let Some(lbl) = label {\n-                    w!(self, \"{}: \", self.body[*lbl].name);\n+                let label = label.map(|lbl| format!(\"{}: \", self.body[lbl].name));\n+                self.print_block(label.as_deref(), statements, tail);\n+            }\n+            Expr::Unsafe { id: _, statements, tail } => {\n+                self.print_block(Some(\"unsafe \"), statements, tail);\n+            }\n+            Expr::TryBlock { id: _, statements, tail } => {\n+                self.print_block(Some(\"try \"), statements, tail);\n+            }\n+            Expr::Async { id: _, statements, tail } => {\n+                self.print_block(Some(\"async \"), statements, tail);\n+            }\n+            Expr::Const { id: _, statements, tail } => {\n+                self.print_block(Some(\"const \"), statements, tail);\n+            }\n+        }\n+    }\n+\n+    fn print_block(\n+        &mut self,\n+        label: Option<&str>,\n+        statements: &Box<[Statement]>,\n+        tail: &Option<la_arena::Idx<Expr>>,\n+    ) {\n+        self.whitespace();\n+        if let Some(lbl) = label {\n+            w!(self, \"{}\", lbl);\n+        }\n+        w!(self, \"{{\");\n+        if !statements.is_empty() || tail.is_some() {\n+            self.indented(|p| {\n+                for stmt in &**statements {\n+                    p.print_stmt(stmt);\n                 }\n-                w!(self, \"{{\");\n-                if !statements.is_empty() || tail.is_some() {\n-                    self.indented(|p| {\n-                        for stmt in &**statements {\n-                            p.print_stmt(stmt);\n-                        }\n-                        if let Some(tail) = tail {\n-                            p.print_expr(*tail);\n-                        }\n-                        p.newline();\n-                    });\n+                if let Some(tail) = tail {\n+                    p.print_expr(*tail);\n                 }\n-                w!(self, \"}}\");\n-            }\n+                p.newline();\n+            });\n         }\n+        w!(self, \"}}\");\n     }\n \n     fn print_pat(&mut self, pat: PatId) {"}, {"sha": "78a2f861233d6a5a2b7693842d2945e0e672e0c1", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=1b5bc831188bc55561a9a84fb693de29b41b18bc", "patch": "@@ -109,6 +109,26 @@ pub enum Expr {\n         tail: Option<ExprId>,\n         label: Option<LabelId>,\n     },\n+    TryBlock {\n+        id: BlockId,\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n+    },\n+    Async {\n+        id: BlockId,\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n+    },\n+    Const {\n+        id: BlockId,\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n+    },\n+    Unsafe {\n+        id: BlockId,\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n+    },\n     Loop {\n         body: ExprId,\n         label: Option<LabelId>,\n@@ -172,15 +192,6 @@ pub enum Expr {\n     Try {\n         expr: ExprId,\n     },\n-    TryBlock {\n-        body: ExprId,\n-    },\n-    Async {\n-        body: ExprId,\n-    },\n-    Const {\n-        body: ExprId,\n-    },\n     Cast {\n         expr: ExprId,\n         type_ref: Interned<TypeRef>,\n@@ -222,9 +233,6 @@ pub enum Expr {\n         exprs: Box<[ExprId]>,\n         is_assignee_expr: bool,\n     },\n-    Unsafe {\n-        body: ExprId,\n-    },\n     Array(Array),\n     Literal(Literal),\n     Underscore,\n@@ -290,13 +298,20 @@ impl Expr {\n             Expr::Let { expr, .. } => {\n                 f(*expr);\n             }\n-            Expr::Block { statements, tail, .. } => {\n+            Expr::Block { statements, tail, .. }\n+            | Expr::TryBlock { statements, tail, .. }\n+            | Expr::Unsafe { statements, tail, .. }\n+            | Expr::Async { statements, tail, .. }\n+            | Expr::Const { statements, tail, .. } => {\n                 for stmt in statements.iter() {\n                     match stmt {\n-                        Statement::Let { initializer, .. } => {\n+                        Statement::Let { initializer, else_branch, .. } => {\n                             if let &Some(expr) = initializer {\n                                 f(expr);\n                             }\n+                            if let &Some(expr) = else_branch {\n+                                f(expr);\n+                            }\n                         }\n                         Statement::Expr { expr: expression, .. } => f(*expression),\n                     }\n@@ -305,10 +320,6 @@ impl Expr {\n                     f(expr);\n                 }\n             }\n-            Expr::TryBlock { body }\n-            | Expr::Unsafe { body }\n-            | Expr::Async { body }\n-            | Expr::Const { body } => f(*body),\n             Expr::Loop { body, .. } => f(*body),\n             Expr::While { condition, body, .. } => {\n                 f(*condition);"}, {"sha": "9a32a9e92cefcefa8f27503af19efaecab6d12a1", "filename": "crates/hir-ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=1b5bc831188bc55561a9a84fb693de29b41b18bc", "patch": "@@ -94,8 +94,10 @@ fn walk_unsafe(\n                 unsafe_expr_cb(UnsafeExpr { expr: current, inside_unsafe_block });\n             }\n         }\n-        Expr::Unsafe { body: child } => {\n-            return walk_unsafe(db, infer, def, body, *child, true, unsafe_expr_cb);\n+        Expr::Unsafe { .. } => {\n+            expr.walk_child_exprs(|child| {\n+                walk_unsafe(db, infer, def, body, child, true, unsafe_expr_cb);\n+            });\n         }\n         _ => {}\n     }"}, {"sha": "023e19d25ed227075054ec4c77ffc8a9d5d69694", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 113, "deletions": 104, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=1b5bc831188bc55561a9a84fb693de29b41b18bc", "patch": "@@ -124,41 +124,18 @@ impl<'a> InferenceContext<'a> {\n                 self.result.standard_types.bool_.clone()\n             }\n             Expr::Block { statements, tail, label, id: _ } => {\n-                let old_resolver = mem::replace(\n-                    &mut self.resolver,\n-                    resolver_for_expr(self.db.upcast(), self.owner, tgt_expr),\n-                );\n-                let ty = match label {\n-                    Some(_) => {\n-                        let break_ty = expected.coercion_target_type(&mut self.table);\n-                        let (breaks, ty) = self.with_breakable_ctx(\n-                            BreakableKind::Block,\n-                            Some(break_ty.clone()),\n-                            *label,\n-                            |this| {\n-                                this.infer_block(\n-                                    tgt_expr,\n-                                    statements,\n-                                    *tail,\n-                                    &Expectation::has_type(break_ty),\n-                                )\n-                            },\n-                        );\n-                        breaks.unwrap_or(ty)\n-                    }\n-                    None => self.infer_block(tgt_expr, statements, *tail, expected),\n-                };\n-                self.resolver = old_resolver;\n-                ty\n+                self.infer_block(tgt_expr, statements, *tail, *label, expected)\n             }\n-            Expr::Unsafe { body } => self.infer_expr(*body, expected),\n-            Expr::Const { body } => {\n+            Expr::Unsafe { id: _, statements, tail } => {\n+                self.infer_block(tgt_expr, statements, *tail, None, expected)\n+            }\n+            Expr::Const { id: _, statements, tail } => {\n                 self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n-                    this.infer_expr(*body, expected)\n+                    this.infer_block(tgt_expr, statements, *tail, None, expected)\n                 })\n                 .1\n             }\n-            Expr::TryBlock { body } => {\n+            Expr::TryBlock { id: _, statements, tail } => {\n                 // The type that is returned from the try block\n                 let try_ty = self.table.new_type_var();\n                 if let Some(ty) = expected.only_has_type(&mut self.table) {\n@@ -169,13 +146,16 @@ impl<'a> InferenceContext<'a> {\n                 let ok_ty =\n                     self.resolve_associated_type(try_ty.clone(), self.resolve_ops_try_output());\n \n-                self.with_breakable_ctx(BreakableKind::Block, Some(ok_ty.clone()), None, |this| {\n-                    this.infer_expr(*body, &Expectation::has_type(ok_ty));\n-                });\n-\n+                self.infer_block(\n+                    tgt_expr,\n+                    statements,\n+                    *tail,\n+                    None,\n+                    &Expectation::has_type(ok_ty.clone()),\n+                );\n                 try_ty\n             }\n-            Expr::Async { body } => {\n+            Expr::Async { id: _, statements, tail } => {\n                 let ret_ty = self.table.new_type_var();\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n@@ -184,7 +164,13 @@ impl<'a> InferenceContext<'a> {\n \n                 let (_, inner_ty) =\n                     self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n-                        this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty))\n+                        this.infer_block(\n+                            tgt_expr,\n+                            statements,\n+                            *tail,\n+                            None,\n+                            &Expectation::has_type(ret_ty),\n+                        )\n                     });\n \n                 self.diverges = prev_diverges;\n@@ -193,7 +179,8 @@ impl<'a> InferenceContext<'a> {\n \n                 // Use the first type parameter as the output type of future.\n                 // existential type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n-                let impl_trait_id = crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, *body);\n+                let impl_trait_id =\n+                    crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, tgt_expr);\n                 let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n                 TyKind::OpaqueType(opaque_ty_id, Substitution::from1(Interner, inner_ty))\n                     .intern(Interner)\n@@ -1153,80 +1140,102 @@ impl<'a> InferenceContext<'a> {\n         expr: ExprId,\n         statements: &[Statement],\n         tail: Option<ExprId>,\n+        label: Option<LabelId>,\n         expected: &Expectation,\n     ) -> Ty {\n-        for stmt in statements {\n-            match stmt {\n-                Statement::Let { pat, type_ref, initializer, else_branch } => {\n-                    let decl_ty = type_ref\n-                        .as_ref()\n-                        .map(|tr| self.make_ty(tr))\n-                        .unwrap_or_else(|| self.table.new_type_var());\n-\n-                    let ty = if let Some(expr) = initializer {\n-                        let ty = if contains_explicit_ref_binding(&self.body, *pat) {\n-                            self.infer_expr(*expr, &Expectation::has_type(decl_ty.clone()))\n-                        } else {\n-                            self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty.clone()))\n-                        };\n-                        if type_ref.is_some() {\n-                            decl_ty\n-                        } else {\n-                            ty\n+        let coerce_ty = expected.coercion_target_type(&mut self.table);\n+        let old_resolver =\n+            mem::replace(&mut self.resolver, resolver_for_expr(self.db.upcast(), self.owner, expr));\n+\n+        let (break_ty, ty) =\n+            self.with_breakable_ctx(BreakableKind::Block, Some(coerce_ty.clone()), label, |this| {\n+                for stmt in statements {\n+                    match stmt {\n+                        Statement::Let { pat, type_ref, initializer, else_branch } => {\n+                            let decl_ty = type_ref\n+                                .as_ref()\n+                                .map(|tr| this.make_ty(tr))\n+                                .unwrap_or_else(|| this.table.new_type_var());\n+\n+                            let ty = if let Some(expr) = initializer {\n+                                let ty = if contains_explicit_ref_binding(&this.body, *pat) {\n+                                    this.infer_expr(*expr, &Expectation::has_type(decl_ty.clone()))\n+                                } else {\n+                                    this.infer_expr_coerce(\n+                                        *expr,\n+                                        &Expectation::has_type(decl_ty.clone()),\n+                                    )\n+                                };\n+                                if type_ref.is_some() {\n+                                    decl_ty\n+                                } else {\n+                                    ty\n+                                }\n+                            } else {\n+                                decl_ty\n+                            };\n+\n+                            this.infer_top_pat(*pat, &ty);\n+\n+                            if let Some(expr) = else_branch {\n+                                let previous_diverges =\n+                                    mem::replace(&mut this.diverges, Diverges::Maybe);\n+                                this.infer_expr_coerce(\n+                                    *expr,\n+                                    &Expectation::HasType(this.result.standard_types.never.clone()),\n+                                );\n+                                this.diverges = previous_diverges;\n+                            }\n+                        }\n+                        &Statement::Expr { expr, has_semi } => {\n+                            this.infer_expr(\n+                                expr,\n+                                &if has_semi {\n+                                    Expectation::none()\n+                                } else {\n+                                    Expectation::HasType(this.result.standard_types.unit.clone())\n+                                },\n+                            );\n                         }\n-                    } else {\n-                        decl_ty\n-                    };\n-\n-                    self.infer_top_pat(*pat, &ty);\n-\n-                    if let Some(expr) = else_branch {\n-                        let previous_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n-                        self.infer_expr_coerce(\n-                            *expr,\n-                            &Expectation::HasType(self.result.standard_types.never.clone()),\n-                        );\n-                        self.diverges = previous_diverges;\n                     }\n                 }\n-                &Statement::Expr { expr, has_semi } => {\n-                    self.infer_expr(\n-                        expr,\n-                        &if has_semi {\n-                            Expectation::none()\n-                        } else {\n-                            Expectation::HasType(self.result.standard_types.unit.clone())\n-                        },\n-                    );\n-                }\n-            }\n-        }\n \n-        if let Some(expr) = tail {\n-            self.infer_expr_coerce(expr, expected)\n-        } else {\n-            // Citing rustc: if there is no explicit tail expression,\n-            // that is typically equivalent to a tail expression\n-            // of `()` -- except if the block diverges. In that\n-            // case, there is no value supplied from the tail\n-            // expression (assuming there are no other breaks,\n-            // this implies that the type of the block will be\n-            // `!`).\n-            if self.diverges.is_always() {\n-                // we don't even make an attempt at coercion\n-                self.table.new_maybe_never_var()\n-            } else if let Some(t) = expected.only_has_type(&mut self.table) {\n-                if self.coerce(Some(expr), &TyBuilder::unit(), &t).is_err() {\n-                    self.result.type_mismatches.insert(\n-                        expr.into(),\n-                        TypeMismatch { expected: t.clone(), actual: TyBuilder::unit() },\n-                    );\n+                // FIXME: This should make use of the breakable CoerceMany\n+                if let Some(expr) = tail {\n+                    this.infer_expr_coerce(expr, expected)\n+                } else {\n+                    // Citing rustc: if there is no explicit tail expression,\n+                    // that is typically equivalent to a tail expression\n+                    // of `()` -- except if the block diverges. In that\n+                    // case, there is no value supplied from the tail\n+                    // expression (assuming there are no other breaks,\n+                    // this implies that the type of the block will be\n+                    // `!`).\n+                    if this.diverges.is_always() {\n+                        // we don't even make an attempt at coercion\n+                        this.table.new_maybe_never_var()\n+                    } else if let Some(t) = expected.only_has_type(&mut this.table) {\n+                        if this\n+                            .coerce(Some(expr), &this.result.standard_types.unit.clone(), &t)\n+                            .is_err()\n+                        {\n+                            this.result.type_mismatches.insert(\n+                                expr.into(),\n+                                TypeMismatch {\n+                                    expected: t.clone(),\n+                                    actual: this.result.standard_types.unit.clone(),\n+                                },\n+                            );\n+                        }\n+                        t\n+                    } else {\n+                        this.result.standard_types.unit.clone()\n+                    }\n                 }\n-                t\n-            } else {\n-                TyBuilder::unit()\n-            }\n-        }\n+            });\n+        self.resolver = old_resolver;\n+\n+        break_ty.unwrap_or(ty)\n     }\n \n     fn lookup_field("}, {"sha": "936b56a02170ee092c7972f35b7847bf1bc3fd4f", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 60, "deletions": 50, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=1b5bc831188bc55561a9a84fb693de29b41b18bc", "patch": "@@ -331,56 +331,11 @@ impl MirLowerCtx<'_> {\n                 }\n                 Ok(result)\n             }\n+            Expr::Unsafe { id: _, statements, tail } => {\n+                self.lower_block_to_place(None, statements, current, *tail, place)\n+            }\n             Expr::Block { id: _, statements, tail, label } => {\n-                if label.is_some() {\n-                    not_supported!(\"block with label\");\n-                }\n-                for statement in statements.iter() {\n-                    match statement {\n-                        hir_def::expr::Statement::Let {\n-                            pat,\n-                            initializer,\n-                            else_branch,\n-                            type_ref: _,\n-                        } => match initializer {\n-                            Some(expr_id) => {\n-                                let else_block;\n-                                let init_place;\n-                                (init_place, current) =\n-                                    self.lower_expr_to_some_place(*expr_id, current)?;\n-                                (current, else_block) = self.pattern_match(\n-                                    current,\n-                                    None,\n-                                    init_place,\n-                                    self.expr_ty(*expr_id),\n-                                    *pat,\n-                                    BindingAnnotation::Unannotated,\n-                                )?;\n-                                match (else_block, else_branch) {\n-                                    (None, _) => (),\n-                                    (Some(else_block), None) => {\n-                                        self.set_terminator(else_block, Terminator::Unreachable);\n-                                    }\n-                                    (Some(else_block), Some(else_branch)) => {\n-                                        let (_, b) = self\n-                                            .lower_expr_to_some_place(*else_branch, else_block)?;\n-                                        self.set_terminator(b, Terminator::Unreachable);\n-                                    }\n-                                }\n-                            }\n-                            None => continue,\n-                        },\n-                        hir_def::expr::Statement::Expr { expr, has_semi: _ } => {\n-                            let ty = self.expr_ty(*expr);\n-                            let temp = self.temp(ty)?;\n-                            current = self.lower_expr_to_place(*expr, temp.into(), current)?;\n-                        }\n-                    }\n-                }\n-                match tail {\n-                    Some(tail) => self.lower_expr_to_place(*tail, place, current),\n-                    None => Ok(current),\n-                }\n+                self.lower_block_to_place(*label, statements, current, *tail, place)\n             }\n             Expr::Loop { body, label } => self.lower_loop(current, *label, |this, begin, _| {\n                 let (_, block) = this.lower_expr_to_some_place(*body, begin)?;\n@@ -686,7 +641,6 @@ impl MirLowerCtx<'_> {\n                 self.push_assignment(current, place, r);\n                 Ok(current)\n             }\n-            Expr::Unsafe { body } => self.lower_expr_to_place(*body, place, current),\n             Expr::Array(l) => match l {\n                 Array::ElementList { elements, .. } => {\n                     let elem_ty = match &self.expr_ty(expr_id).data(Interner).kind {\n@@ -723,6 +677,62 @@ impl MirLowerCtx<'_> {\n         }\n     }\n \n+    fn lower_block_to_place(\n+        &mut self,\n+        label: Option<LabelId>,\n+        statements: &[hir_def::expr::Statement],\n+        mut current: BasicBlockId,\n+        tail: Option<ExprId>,\n+        place: Place,\n+    ) -> Result<BasicBlockId> {\n+        if label.is_some() {\n+            not_supported!(\"block with label\");\n+        }\n+        for statement in statements.iter() {\n+            match statement {\n+                hir_def::expr::Statement::Let { pat, initializer, else_branch, type_ref: _ } => {\n+                    match initializer {\n+                        Some(expr_id) => {\n+                            let else_block;\n+                            let init_place;\n+                            (init_place, current) =\n+                                self.lower_expr_to_some_place(*expr_id, current)?;\n+                            (current, else_block) = self.pattern_match(\n+                                current,\n+                                None,\n+                                init_place,\n+                                self.expr_ty(*expr_id),\n+                                *pat,\n+                                BindingAnnotation::Unannotated,\n+                            )?;\n+                            match (else_block, else_branch) {\n+                                (None, _) => (),\n+                                (Some(else_block), None) => {\n+                                    self.set_terminator(else_block, Terminator::Unreachable);\n+                                }\n+                                (Some(else_block), Some(else_branch)) => {\n+                                    let (_, b) =\n+                                        self.lower_expr_to_some_place(*else_branch, else_block)?;\n+                                    self.set_terminator(b, Terminator::Unreachable);\n+                                }\n+                            }\n+                        }\n+                        None => continue,\n+                    }\n+                }\n+                hir_def::expr::Statement::Expr { expr, has_semi: _ } => {\n+                    let ty = self.expr_ty(*expr);\n+                    let temp = self.temp(ty)?;\n+                    current = self.lower_expr_to_place(*expr, temp.into(), current)?;\n+                }\n+            }\n+        }\n+        match tail {\n+            Some(tail) => self.lower_expr_to_place(tail, place, current),\n+            None => Ok(current),\n+        }\n+    }\n+\n     fn lower_literal_to_operand(&mut self, ty: Ty, l: &Literal) -> Result<Operand> {\n         let size = layout_of_ty(self.db, &ty, self.owner.module(self.db.upcast()).krate())?\n             .size"}, {"sha": "759878b10bbf2d90b272a448c3673d52cb1471c8", "filename": "crates/hir-ty/src/tests.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=1b5bc831188bc55561a9a84fb693de29b41b18bc", "patch": "@@ -61,22 +61,27 @@ fn setup_tracing() -> Option<tracing::subscriber::DefaultGuard> {\n     Some(tracing::subscriber::set_default(subscriber))\n }\n \n+#[track_caller]\n fn check_types(ra_fixture: &str) {\n     check_impl(ra_fixture, false, true, false)\n }\n \n+#[track_caller]\n fn check_types_source_code(ra_fixture: &str) {\n     check_impl(ra_fixture, false, true, true)\n }\n \n+#[track_caller]\n fn check_no_mismatches(ra_fixture: &str) {\n     check_impl(ra_fixture, true, false, false)\n }\n \n+#[track_caller]\n fn check(ra_fixture: &str) {\n     check_impl(ra_fixture, false, false, false)\n }\n \n+#[track_caller]\n fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_source: bool) {\n     let _tracing = setup_tracing();\n     let (db, files) = TestDB::with_many_files(ra_fixture);"}, {"sha": "4b671449e154dba9695bf096ffeb94eac61e5214", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=1b5bc831188bc55561a9a84fb693de29b41b18bc", "patch": "@@ -1167,7 +1167,6 @@ fn test() {\n             123..167 '{     ...o(); }': ()\n             133..134 's': &S\n             137..151 'unsafe { f() }': &S\n-            137..151 'unsafe { f() }': &S\n             146..147 'f': fn f() -> &S\n             146..149 'f()': &S\n             157..158 's': &S"}, {"sha": "1a07a2c51d812666fbe7be14a88e06b2870aa182", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b5bc831188bc55561a9a84fb693de29b41b18bc/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=1b5bc831188bc55561a9a84fb693de29b41b18bc", "patch": "@@ -352,15 +352,13 @@ unsafe fn baz(u: MyUnion) {\n             71..89 'MyUnio...o: 0 }': MyUnion\n             86..87 '0': u32\n             95..113 'unsafe...(u); }': ()\n-            95..113 'unsafe...(u); }': ()\n             104..107 'baz': fn baz(MyUnion)\n             104..110 'baz(u)': ()\n             108..109 'u': MyUnion\n             122..123 'u': MyUnion\n             126..146 'MyUnio... 0.0 }': MyUnion\n             141..144 '0.0': f32\n             152..170 'unsafe...(u); }': ()\n-            152..170 'unsafe...(u); }': ()\n             161..164 'baz': fn baz(MyUnion)\n             161..167 'baz(u)': ()\n             165..166 'u': MyUnion\n@@ -2077,22 +2075,17 @@ async fn main() {\n             16..193 '{     ...2 }; }': ()\n             26..27 'x': i32\n             30..43 'unsafe { 92 }': i32\n-            30..43 'unsafe { 92 }': i32\n             39..41 '92': i32\n             53..54 'y': impl Future<Output = ()>\n-            57..85 'async ...wait }': ()\n             57..85 'async ...wait }': impl Future<Output = ()>\n-            65..77 'async { () }': ()\n             65..77 'async { () }': impl Future<Output = ()>\n             65..83 'async ....await': ()\n             73..75 '()': ()\n             95..96 'z': ControlFlow<(), ()>\n-            130..140 'try { () }': ()\n             130..140 'try { () }': ControlFlow<(), ()>\n             136..138 '()': ()\n             150..151 'w': i32\n             154..166 'const { 92 }': i32\n-            154..166 'const { 92 }': i32\n             162..164 '92': i32\n             176..177 't': i32\n             180..190 ''a: { 92 }': i32\n@@ -2122,7 +2115,6 @@ fn main() {\n             83..84 'f': F\n             89..91 '{}': ()\n             103..231 '{     ... }); }': ()\n-            109..161 'async ...     }': Result<(), ()>\n             109..161 'async ...     }': impl Future<Output = Result<(), ()>>\n             125..139 'return Err(())': !\n             132..135 'Err': Err<(), ()>(()) -> Result<(), ()>\n@@ -2134,7 +2126,6 @@ fn main() {\n             167..171 'test': fn test<(), (), || -> impl Future<Output = Result<(), ()>>, impl Future<Output = Result<(), ()>>>(|| -> impl Future<Output = Result<(), ()>>)\n             167..228 'test(|...    })': ()\n             172..227 '|| asy...     }': || -> impl Future<Output = Result<(), ()>>\n-            175..227 'async ...     }': Result<(), ()>\n             175..227 'async ...     }': impl Future<Output = Result<(), ()>>\n             191..205 'return Err(())': !\n             198..201 'Err': Err<(), ()>(()) -> Result<(), ()>"}]}