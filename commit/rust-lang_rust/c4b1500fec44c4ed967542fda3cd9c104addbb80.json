{"sha": "c4b1500fec44c4ed967542fda3cd9c104addbb80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0YjE1MDBmZWM0NGM0ZWQ5Njc1NDJmZGEzY2Q5YzEwNGFkZGJiODA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-02T16:06:33Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-02T20:18:58Z"}, "message": "Rollup merge of #22966 - nikomatsakis:closure-region-hierarchy, r=pnkfelix\n\n Remove the synthetic \\\"region bound\\\" from closures and instead update how\ntype-outlives works for closure types so that it ensures that all upvars\noutlive the region in question. This gives the same guarantees but\nwithout introducing artificial regions (and gives better error messages\nto boot). This is refactoring towards #3696.\n\nr? @pnkfelix", "tree": {"sha": "c0f79ec53e9f9ca46755b5ddccc42e67ebbb69a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0f79ec53e9f9ca46755b5ddccc42e67ebbb69a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4b1500fec44c4ed967542fda3cd9c104addbb80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4b1500fec44c4ed967542fda3cd9c104addbb80", "html_url": "https://github.com/rust-lang/rust/commit/c4b1500fec44c4ed967542fda3cd9c104addbb80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4b1500fec44c4ed967542fda3cd9c104addbb80/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f608afe4707aaf5c87a39d43c3708c743d070406", "url": "https://api.github.com/repos/rust-lang/rust/commits/f608afe4707aaf5c87a39d43c3708c743d070406", "html_url": "https://github.com/rust-lang/rust/commit/f608afe4707aaf5c87a39d43c3708c743d070406"}, {"sha": "00fcf794488e5e1a4761342dac7d2bcdfb66152f", "url": "https://api.github.com/repos/rust-lang/rust/commits/00fcf794488e5e1a4761342dac7d2bcdfb66152f", "html_url": "https://github.com/rust-lang/rust/commit/00fcf794488e5e1a4761342dac7d2bcdfb66152f"}], "stats": {"total": 323, "additions": 93, "deletions": 230}, "files": [{"sha": "b33839f33e8203d7a08a8ea0be86294b9f47ec33", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -555,11 +555,9 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n       'k' => {\n           assert_eq!(next(st), '[');\n           let did = parse_def_(st, ClosureSource, conv);\n-          let region = parse_region_(st, conv);\n           let substs = parse_substs_(st, conv);\n           assert_eq!(next(st), ']');\n-          return ty::mk_closure(st.tcx, did,\n-                  st.tcx.mk_region(region), st.tcx.mk_substs(substs));\n+          return ty::mk_closure(st.tcx, did, st.tcx.mk_substs(substs));\n       }\n       'P' => {\n           assert_eq!(next(st), '[');"}, {"sha": "ebb4153e32bce9e90e1432e73e1643a97a479a95", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -139,9 +139,8 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_closure(def, region, substs) => {\n+        ty::ty_closure(def, substs) => {\n             mywrite!(w, \"k[{}|\", (cx.ds)(def));\n-            enc_region(w, cx, *region);\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }"}, {"sha": "063845c6c34255df36dcf0dad2fc04c8bb2c39d3", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -74,7 +74,7 @@ pub fn simplify_type(tcx: &ty::ctxt,\n             let def_id = tcx.lang_items.owned_box().unwrap();\n             Some(StructSimplifiedType(def_id))\n         }\n-        ty::ty_closure(def_id, _, _) => {\n+        ty::ty_closure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))\n         }\n         ty::ty_tup(ref tys) => {"}, {"sha": "be94a73df37ba82d7b4c02c4427b8a58588ef67b", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -503,15 +503,14 @@ pub fn super_tys<'tcx, C>(this: &C,\n             Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n         }\n \n-        (&ty::ty_closure(a_id, a_region, a_substs),\n-         &ty::ty_closure(b_id, b_region, b_substs))\n+        (&ty::ty_closure(a_id, a_substs),\n+         &ty::ty_closure(b_id, b_substs))\n           if a_id == b_id => {\n             // All ty_closure types with the same id represent\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n-            let region = try!(this.equate().regions(*a_region, *b_region));\n             let substs = try!(this.substs_variances(None, a_substs, b_substs));\n-            Ok(ty::mk_closure(tcx, a_id, tcx.mk_region(region), tcx.mk_substs(substs)))\n+            Ok(ty::mk_closure(tcx, a_id, tcx.mk_substs(substs)))\n         }\n \n         (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {"}, {"sha": "224a568c77f02277985a03af03ee9fe1a7dc9a54", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -1496,7 +1496,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n         let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n         match fn_ty.sty {\n-            ty::ty_closure(closure_def_id, _, substs) =>\n+            ty::ty_closure(closure_def_id, substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n             _ =>\n                 ty::ty_fn_ret(fn_ty),"}, {"sha": "1f02f13a4a17823312e934e27c912d5e8a7e45e0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -607,7 +607,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           def::DefUpvar(var_id, fn_node_id) => {\n               let ty = try!(self.node_ty(fn_node_id));\n               match ty.sty {\n-                  ty::ty_closure(closure_id, _, _) => {\n+                  ty::ty_closure(closure_id, _) => {\n                       match self.typer.closure_kind(closure_id) {\n                           Some(kind) => {\n                               self.cat_upvar(id, span, var_id, fn_node_id, kind)"}, {"sha": "b4db3aba7867dc72cbaec8a3519dd07c5725a32f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -320,8 +320,10 @@ impl InnermostEnclosingExpr {\n \n #[derive(Debug, Copy)]\n pub struct Context {\n+    /// the scope that contains any new variables declared\n     var_parent: InnermostDeclaringBlock,\n \n+    /// region parent of expressions etc\n     parent: InnermostEnclosingExpr,\n }\n "}, {"sha": "b9a863f4fe46f51738edc029115ad6dca2304fe6", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -154,7 +154,7 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n     debug!(\"consider_unification_despite_ambiguity: self_ty.sty={:?}\",\n            self_ty.sty);\n     match self_ty.sty {\n-        ty::ty_closure(closure_def_id, _, substs) => {\n+        ty::ty_closure(closure_def_id, substs) => {\n             let closure_typer = selcx.closure_typer();\n             let closure_type = closure_typer.closure_type(closure_def_id, substs);\n             let ty::Binder((_, ret_type)) ="}, {"sha": "470315c78f81d8d15ac1908c4b1988be543155df", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -293,7 +293,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // lifetimes can appear inside the self-type.\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         let (closure_def_id, substs) = match self_ty.sty {\n-            ty::ty_closure(id, _, ref substs) => (id, substs.clone()),\n+            ty::ty_closure(id, ref substs) => (id, substs.clone()),\n             _ => { return; }\n         };\n         assert!(!substs.has_escaping_regions());\n@@ -1054,7 +1054,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         let (closure_def_id, substs) = match self_ty.sty {\n-            ty::ty_closure(id, _, ref substs) => (id, substs.clone()),\n+            ty::ty_closure(id, ref substs) => (id, substs.clone()),\n             ty::ty_infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n@@ -1533,7 +1533,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n             ty::ty_tup(ref tys) => Ok(If(tys.clone())),\n \n-            ty::ty_closure(def_id, _, substs) => {\n+            ty::ty_closure(def_id, substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n                 // closures particularly, we need the results of\n                 // inference to decide how to reflect the type of each\n@@ -1687,7 +1687,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Some(tys.clone())\n             }\n \n-            ty::ty_closure(def_id, _, substs) => {\n+            ty::ty_closure(def_id, substs) => {\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n \n                 match self.closure_typer.closure_upvars(def_id, substs) {"}, {"sha": "aaba840825e69ea23248efe10c6c47d9f96f88a4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -1367,7 +1367,7 @@ pub enum sty<'tcx> {\n     ty_trait(Box<TyTrait<'tcx>>),\n     ty_struct(DefId, &'tcx Substs<'tcx>),\n \n-    ty_closure(DefId, &'tcx Region, &'tcx Substs<'tcx>),\n+    ty_closure(DefId, &'tcx Substs<'tcx>),\n \n     ty_tup(Vec<Ty<'tcx>>),\n \n@@ -2658,8 +2658,7 @@ impl FlagComputation {\n                 }\n             }\n \n-            &ty_closure(_, region, substs) => {\n-                self.add_region(*region);\n+            &ty_closure(_, substs) => {\n                 self.add_substs(substs);\n             }\n \n@@ -2927,10 +2926,9 @@ pub fn mk_struct<'tcx>(cx: &ctxt<'tcx>, struct_id: ast::DefId,\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n \n-pub fn mk_closure<'tcx>(cx: &ctxt<'tcx>, closure_id: ast::DefId,\n-                        region: &'tcx Region, substs: &'tcx Substs<'tcx>)\n+pub fn mk_closure<'tcx>(cx: &ctxt<'tcx>, closure_id: ast::DefId, substs: &'tcx Substs<'tcx>)\n                         -> Ty<'tcx> {\n-    mk_t(cx, ty_closure(closure_id, region, substs))\n+    mk_t(cx, ty_closure(closure_id, substs))\n }\n \n pub fn mk_var<'tcx>(cx: &ctxt<'tcx>, v: TyVid) -> Ty<'tcx> {\n@@ -3513,13 +3511,11 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 apply_lang_items(cx, did, res)\n             }\n \n-            ty_closure(did, r, substs) => {\n+            ty_closure(did, substs) => {\n                 // FIXME(#14449): `borrowed_contents` below assumes `&mut` closure.\n                 let param_env = ty::empty_parameter_environment(cx);\n                 let upvars = closure_upvars(&param_env, did, substs).unwrap();\n-                TypeContents::union(&upvars,\n-                                    |f| tc_ty(cx, &f.ty, cache))\n-                    | borrowed_contents(*r, MutMutable)\n+                TypeContents::union(&upvars, |f| tc_ty(cx, &f.ty, cache))\n             }\n \n             ty_tup(ref tys) => {\n@@ -5175,7 +5171,7 @@ pub fn ty_to_def_id(ty: Ty) -> Option<ast::DefId> {\n             Some(tt.principal_def_id()),\n         ty_struct(id, _) |\n         ty_enum(id, _) |\n-        ty_closure(id, _, _) =>\n+        ty_closure(id, _) =>\n             Some(id),\n         _ =>\n             None\n@@ -6301,10 +6297,9 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                 }\n                 ty_infer(_) => unreachable!(),\n                 ty_err => byte!(21),\n-                ty_closure(d, r, _) => {\n+                ty_closure(d, _) => {\n                     byte!(22);\n                     did(state, d);\n-                    region(state, *r);\n                 }\n                 ty_projection(ref data) => {\n                     byte!(23);\n@@ -6618,8 +6613,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_struct(_, substs) => {\n                 accum_substs(accumulator, substs);\n             }\n-            ty_closure(_, region, substs) => {\n-                accumulator.push(*region);\n+            ty_closure(_, substs) => {\n                 accum_substs(accumulator, substs);\n             }\n             ty_bool |"}, {"sha": "1b904aacc301210558fabc24baedcab941a0643d", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -650,10 +650,9 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             let substs = substs.fold_with(this);\n             ty::ty_struct(did, this.tcx().mk_substs(substs))\n         }\n-        ty::ty_closure(did, ref region, ref substs) => {\n-            let r = region.fold_with(this);\n+        ty::ty_closure(did, ref substs) => {\n             let s = substs.fold_with(this);\n-            ty::ty_closure(did, this.tcx().mk_region(r), this.tcx().mk_substs(s))\n+            ty::ty_closure(did, this.tcx().mk_substs(s))\n         }\n         ty::ty_projection(ref data) => {\n             ty::ty_projection(data.fold_with(this))"}, {"sha": "5b5eac451783a8502edb0844d53bd9c221dde5bf", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -45,7 +45,7 @@ impl<'tcx> TypeWalker<'tcx> {\n             }\n             ty::ty_enum(_, ref substs) |\n             ty::ty_struct(_, ref substs) |\n-            ty::ty_closure(_, _, ref substs) => {\n+            ty::ty_closure(_, ref substs) => {\n                 self.push_reversed(substs.types.as_slice());\n             }\n             ty::ty_tup(ref ts) => {"}, {"sha": "0eeb746022c0d74e1a9ad29cc34fdd96ef3c1d54", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -406,7 +406,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                     data.item_name.user_string(cx))\n         }\n         ty_str => \"str\".to_string(),\n-        ty_closure(ref did, _, substs) => {\n+        ty_closure(ref did, substs) => {\n             let closure_tys = cx.closure_tys.borrow();\n             closure_tys.get(did).map(|closure_type| {\n                 closure_to_string(cx, &closure_type.subst(cx, substs))"}, {"sha": "2fb0488cd704e04b8912da4d3a89523117d4eb7a", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -169,7 +169,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             Univariant(mk_struct(cx, &ftys[..], packed, t), dtor)\n         }\n-        ty::ty_closure(def_id, _, substs) => {\n+        ty::ty_closure(def_id, substs) => {\n             let typer = NormalizingClosureTyper::new(cx.tcx());\n             let upvars = typer.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();"}, {"sha": "7a6960d379026cf612680423dfb79987a0a76962", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -291,7 +291,7 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(_, ref f) => {\n             (&f.sig, f.abi, None)\n         }\n-        ty::ty_closure(closure_did, _, substs) => {\n+        ty::ty_closure(closure_did, substs) => {\n             let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n             function_type = typer.closure_type(closure_did, substs);\n             let self_type = self_type_for_closure(ccx, closure_did, fn_ty);\n@@ -685,7 +685,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n               }\n           })\n       }\n-      ty::ty_closure(def_id, _, substs) => {\n+      ty::ty_closure(def_id, substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           let typer = common::NormalizingClosureTyper::new(cx.tcx());\n           let upvars = typer.closure_upvars(def_id, substs).unwrap();\n@@ -2437,7 +2437,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n     let function_type;\n     let (fn_sig, abi, env_ty) = match fn_ty.sty {\n         ty::ty_bare_fn(_, ref f) => (&f.sig, f.abi, None),\n-        ty::ty_closure(closure_did, _, substs) => {\n+        ty::ty_closure(closure_did, substs) => {\n             let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n             function_type = typer.closure_type(closure_did, substs);\n             let self_type = self_type_for_closure(ccx, closure_did, fn_ty);\n@@ -2454,7 +2454,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n     // These have an odd calling convention, so we need to manually\n     // unpack the input ty's\n     let input_tys = match fn_ty.sty {\n-        ty::ty_closure(_, _, _) => {\n+        ty::ty_closure(..) => {\n             assert!(abi == RustCall);\n \n             match fn_sig.inputs[0].sty {"}, {"sha": "7fa26a7c1284196292c92c22ffe6bf4d5f30c3c3", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -138,7 +138,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n     // duplicate declarations\n     let function_type = erase_regions(ccx.tcx(), &function_type);\n     let params = match function_type.sty {\n-        ty::ty_closure(_, _, substs) => &substs.types,\n+        ty::ty_closure(_, substs) => &substs.types,\n         _ => unreachable!()\n     };\n     let mono_id = MonoId {"}, {"sha": "f3b7058336b2fc350bf0a0257606a5a508976314", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -472,7 +472,7 @@ impl<'tcx> TypeMap<'tcx> {\n                     }\n                 }\n             },\n-            ty::ty_closure(def_id, _, substs) => {\n+            ty::ty_closure(def_id, substs) => {\n                 let typer = NormalizingClosureTyper::new(cx.tcx());\n                 let closure_ty = typer.closure_type(def_id, substs);\n                 self.get_unique_type_id_of_closure_type(cx,\n@@ -2983,7 +2983,7 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(_, ref barefnty) => {\n             subroutine_type_metadata(cx, unique_type_id, &barefnty.sig, usage_site_span)\n         }\n-        ty::ty_closure(def_id, _, substs) => {\n+        ty::ty_closure(def_id, substs) => {\n             let typer = NormalizingClosureTyper::new(cx.tcx());\n             let sig = typer.closure_type(def_id, substs).sig;\n             subroutine_type_metadata(cx, unique_type_id, &sig, usage_site_span)"}, {"sha": "f9495af79c5b0c5969a5bba8a2d157ee272eb39d", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -137,7 +137,7 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             return Some(CallStep::Builtin);\n         }\n \n-        ty::ty_closure(def_id, _, substs) => {\n+        ty::ty_closure(def_id, substs) => {\n             assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n \n             // Check whether this is a call to a closure where we"}, {"sha": "0d4edc01a4c1d73ae16c821e52de1a940b8d6f09", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -16,7 +16,6 @@ use astconv;\n use middle::region;\n use middle::subst;\n use middle::ty::{self, ToPolyTraitRef, Ty};\n-use rscope::RegionScope;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_util;\n@@ -61,17 +60,8 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         abi::RustCall,\n         expected_sig);\n \n-    let region = match fcx.anon_regions(expr.span, 1) {\n-        Err(_) => {\n-            fcx.ccx.tcx.sess.span_bug(expr.span,\n-                                      \"can't make anon regions here?!\")\n-        }\n-        Ok(regions) => regions[0],\n-    };\n-\n     let closure_type = ty::mk_closure(fcx.ccx.tcx,\n                                       expr_def_id,\n-                                      fcx.ccx.tcx.mk_region(region),\n                                       fcx.ccx.tcx.mk_substs(\n                                         fcx.inh.param_env.free_substs.clone()));\n "}, {"sha": "f99ba8940297dbc6c2a9a7e747bd3d5e72cbc9d7", "filename": "src/librustc_typeck/check/implicator.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -29,6 +29,7 @@ use util::ppaux::Repr;\n pub enum Implication<'tcx> {\n     RegionSubRegion(Option<Ty<'tcx>>, ty::Region, ty::Region),\n     RegionSubGeneric(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n+    RegionSubClosure(Option<Ty<'tcx>>, ty::Region, ast::DefId, &'tcx Substs<'tcx>),\n     Predicate(ast::DefId, ty::Predicate<'tcx>),\n }\n \n@@ -91,29 +92,9 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                 // No borrowed content reachable here.\n             }\n \n-            ty::ty_closure(_, region, _) => {\n-                // An \"closure type\" is basically\n-                // modeled here as equivalent to a struct like\n-                //\n-                //     struct TheClosure<'b> {\n-                //         ...\n-                //     }\n-                //\n-                // where the `'b` is the lifetime bound of the\n-                // contents (i.e., all contents must outlive 'b).\n-                //\n-                // Even though closures are glorified structs\n-                // of upvars, we do not need to consider them as they\n-                // can't generate any new constraints.  The\n-                // substitutions on the closure are equal to the free\n-                // substitutions of the enclosing parameter\n-                // environment.  An upvar captured by value has the\n-                // same type as the original local variable which is\n-                // already checked for consistency.  If the upvar is\n-                // captured by reference it must also outlive the\n-                // region bound on the closure, but this is explicitly\n-                // handled by logic in regionck.\n-                self.push_region_constraint_from_top(*region);\n+            ty::ty_closure(def_id, substs) => {\n+                let &(r_a, opt_ty) = self.stack.last().unwrap();\n+                self.out.push(Implication::RegionSubClosure(opt_ty, r_a, def_id, substs));\n             }\n \n             ty::ty_trait(ref t) => {\n@@ -448,6 +429,13 @@ impl<'tcx> Repr<'tcx> for Implication<'tcx> {\n                         p.repr(tcx))\n             }\n \n+            Implication::RegionSubClosure(_, ref a, ref b, ref c) => {\n+                format!(\"RegionSubClosure({}, {}, {})\",\n+                        a.repr(tcx),\n+                        b.repr(tcx),\n+                        c.repr(tcx))\n+            }\n+\n             Implication::Predicate(ref def_id, ref p) => {\n                 format!(\"Predicate({}, {})\",\n                         def_id.repr(tcx),"}, {"sha": "fbf002b709ee54e7cc2514eadf75d73b70ed3cc9", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -278,7 +278,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             }\n             ty::ty_enum(did, _) |\n             ty::ty_struct(did, _) |\n-            ty::ty_closure(did, _, _) => {\n+            ty::ty_closure(did, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(did);\n             }\n             ty::ty_uniq(_) => {\n@@ -641,8 +641,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // If so, add \"synthetic impls\".\n         let steps = self.steps.clone();\n         for step in &*steps {\n-            let (closure_def_id, _, _) = match step.self_ty.sty {\n-                ty::ty_closure(a, b, ref c) => (a, b, c),\n+            let closure_def_id = match step.self_ty.sty {\n+                ty::ty_closure(a, _) => a,\n                 _ => continue,\n             };\n "}, {"sha": "a3e98b0c4c6582b9df464e50e649906c148b1069", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 31, "deletions": 140, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -87,12 +87,11 @@ use check::dropck;\n use check::FnCtxt;\n use check::implicator;\n use check::vtable;\n-use middle::def;\n use middle::mem_categorization as mc;\n use middle::region::CodeExtent;\n+use middle::subst::Substs;\n use middle::traits;\n-use middle::ty::{ReScope};\n-use middle::ty::{self, Ty, MethodCall};\n+use middle::ty::{self, ClosureTyper, ReScope, Ty, MethodCall};\n use middle::infer::{self, GenericKind};\n use middle::pat_util;\n use util::ppaux::{ty_to_string, Repr};\n@@ -179,20 +178,6 @@ pub struct Rcx<'a, 'tcx: 'a> {\n \n }\n \n-/// Returns the validity region of `def` -- that is, how long is `def` valid?\n-fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n-    let tcx = fcx.tcx();\n-    match def {\n-        def::DefLocal(node_id) | def::DefUpvar(node_id, _) => {\n-            tcx.region_maps.var_region(node_id)\n-        }\n-        _ => {\n-            tcx.sess.bug(&format!(\"unexpected def in region_of_def: {:?}\",\n-                                 def))\n-        }\n-    }\n-}\n-\n struct RepeatingScope(ast::NodeId);\n pub enum SubjectNode { Subject(ast::NodeId), None }\n \n@@ -368,7 +353,15 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                                                              ty::ReInfer(ty::ReVar(vid_b))) => {\n                         self.fcx.inh.infcx.add_given(free_a, vid_b);\n                     }\n-                    implicator::Implication::RegionSubRegion(..) => {\n+                    implicator::Implication::RegionSubGeneric(_, r_a, ref generic_b) => {\n+                        debug!(\"RegionSubGeneric: {} <= {}\",\n+                               r_a.repr(tcx), generic_b.repr(tcx));\n+\n+                        self.region_bound_pairs.push((r_a, generic_b.clone()));\n+                    }\n+                    implicator::Implication::RegionSubRegion(..) |\n+                    implicator::Implication::RegionSubClosure(..) |\n+                    implicator::Implication::Predicate(..) => {\n                         // In principle, we could record (and take\n                         // advantage of) every relationship here, but\n                         // we are also free not to -- it simply means\n@@ -379,13 +372,6 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                         // relationship that arises here, but\n                         // presently we do not.)\n                     }\n-                    implicator::Implication::RegionSubGeneric(_, r_a, ref generic_b) => {\n-                        debug!(\"RegionSubGeneric: {} <= {}\",\n-                               r_a.repr(tcx), generic_b.repr(tcx));\n-\n-                        self.region_bound_pairs.push((r_a, generic_b.clone()));\n-                    }\n-                    implicator::Implication::Predicate(..) => { }\n                 }\n             }\n         }\n@@ -792,124 +778,9 @@ fn constrain_cast(rcx: &mut Rcx,\n fn check_expr_fn_block(rcx: &mut Rcx,\n                        expr: &ast::Expr,\n                        body: &ast::Block) {\n-    let tcx = rcx.fcx.tcx();\n-    let function_type = rcx.resolve_node_type(expr.id);\n-\n-    match function_type.sty {\n-        ty::ty_closure(_, region, _) => {\n-            ty::with_freevars(tcx, expr.id, |freevars| {\n-                constrain_captured_variables(rcx, *region, expr, freevars);\n-            })\n-        }\n-        _ => { }\n-    }\n-\n     let repeating_scope = rcx.set_repeating_scope(body.id);\n     visit::walk_expr(rcx, expr);\n     rcx.set_repeating_scope(repeating_scope);\n-\n-    match function_type.sty {\n-        ty::ty_closure(_, region, _) => {\n-            ty::with_freevars(tcx, expr.id, |freevars| {\n-                let bounds = ty::region_existential_bound(*region);\n-                ensure_free_variable_types_outlive_closure_bound(rcx, &bounds, expr, freevars);\n-            })\n-        }\n-        _ => {}\n-    }\n-\n-    /// Make sure that the type of all free variables referenced inside a closure/proc outlive the\n-    /// closure/proc's lifetime bound. This is just a special case of the usual rules about closed\n-    /// over values outliving the object's lifetime bound.\n-    fn ensure_free_variable_types_outlive_closure_bound(\n-        rcx: &mut Rcx,\n-        bounds: &ty::ExistentialBounds,\n-        expr: &ast::Expr,\n-        freevars: &[ty::Freevar])\n-    {\n-        let tcx = rcx.fcx.ccx.tcx;\n-\n-        debug!(\"ensure_free_variable_types_outlive_closure_bound({}, {})\",\n-               bounds.region_bound.repr(tcx), expr.repr(tcx));\n-\n-        for freevar in freevars {\n-            let var_node_id = {\n-                let def_id = freevar.def.def_id();\n-                assert!(def_id.krate == ast::LOCAL_CRATE);\n-                def_id.node\n-            };\n-\n-            // Compute the type of the field in the environment that\n-            // represents `var_node_id`.  For a by-value closure, this\n-            // will be the same as the type of the variable.  For a\n-            // by-reference closure, this will be `&T` where `T` is\n-            // the type of the variable.\n-            let raw_var_ty = rcx.resolve_node_type(var_node_id);\n-            let upvar_id = ty::UpvarId { var_id: var_node_id,\n-                                         closure_expr_id: expr.id };\n-            let var_ty = match rcx.fcx.inh.upvar_capture_map.borrow()[upvar_id] {\n-                ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n-                    ty::mk_rptr(rcx.tcx(),\n-                                rcx.tcx().mk_region(upvar_borrow.region),\n-                                ty::mt { mutbl: upvar_borrow.kind.to_mutbl_lossy(),\n-                                         ty: raw_var_ty })\n-                }\n-                ty::UpvarCapture::ByValue => raw_var_ty,\n-            };\n-\n-            // Check that the type meets the criteria of the existential bounds:\n-            for builtin_bound in &bounds.builtin_bounds {\n-                let code = traits::ClosureCapture(var_node_id, expr.span, builtin_bound);\n-                let cause = traits::ObligationCause::new(freevar.span, rcx.fcx.body_id, code);\n-                rcx.fcx.register_builtin_bound(var_ty, builtin_bound, cause);\n-            }\n-\n-            type_must_outlive(\n-                rcx, infer::FreeVariable(expr.span, var_node_id),\n-                var_ty, bounds.region_bound);\n-        }\n-    }\n-\n-    /// Make sure that all free variables referenced inside the closure outlive the closure's\n-    /// lifetime bound. Also, create an entry in the upvar_borrows map with a region.\n-    fn constrain_captured_variables(\n-        rcx: &mut Rcx,\n-        region_bound: ty::Region,\n-        expr: &ast::Expr,\n-        freevars: &[ty::Freevar])\n-    {\n-        let tcx = rcx.fcx.ccx.tcx;\n-        debug!(\"constrain_captured_variables({}, {})\",\n-               region_bound.repr(tcx), expr.repr(tcx));\n-        for freevar in freevars {\n-            debug!(\"constrain_captured_variables: freevar.def={:?}\", freevar.def);\n-\n-            // Identify the variable being closed over and its node-id.\n-            let def = freevar.def;\n-            let var_node_id = {\n-                let def_id = def.def_id();\n-                assert!(def_id.krate == ast::LOCAL_CRATE);\n-                def_id.node\n-            };\n-            let upvar_id = ty::UpvarId { var_id: var_node_id,\n-                                         closure_expr_id: expr.id };\n-\n-            match rcx.fcx.inh.upvar_capture_map.borrow()[upvar_id] {\n-                ty::UpvarCapture::ByValue => { }\n-                ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                    rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n-                                    region_bound, upvar_borrow.region);\n-\n-                    // Guarantee that the closure does not outlive the variable itself.\n-                    let enclosing_region = region_of_def(rcx.fcx, def);\n-                    debug!(\"constrain_captured_variables: enclosing_region = {}\",\n-                           enclosing_region.repr(tcx));\n-                    rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n-                                    region_bound, enclosing_region);\n-                }\n-            }\n-        }\n-    }\n }\n \n fn constrain_callee(rcx: &mut Rcx,\n@@ -1538,6 +1409,9 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n                 generic_must_outlive(rcx, o1, r_a, generic_b);\n             }\n+            implicator::Implication::RegionSubClosure(_, r_a, def_id, substs) => {\n+                closure_must_outlive(rcx, origin.clone(), r_a, def_id, substs);\n+            }\n             implicator::Implication::Predicate(def_id, predicate) => {\n                 let cause = traits::ObligationCause::new(origin.span(),\n                                                          rcx.body_id,\n@@ -1549,6 +1423,23 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n     }\n }\n \n+fn closure_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+                                  origin: infer::SubregionOrigin<'tcx>,\n+                                  region: ty::Region,\n+                                  def_id: ast::DefId,\n+                                  substs: &'tcx Substs<'tcx>) {\n+    debug!(\"closure_must_outlive(region={}, def_id={}, substs={})\",\n+           region.repr(rcx.tcx()), def_id.repr(rcx.tcx()), substs.repr(rcx.tcx()));\n+\n+    let upvars = rcx.fcx.closure_upvars(def_id, substs).unwrap();\n+    for upvar in upvars {\n+        let var_id = upvar.def.def_id().local_id();\n+        type_must_outlive(\n+            rcx, infer::FreeVariable(origin.span(), var_id),\n+            upvar.ty, region);\n+    }\n+}\n+\n fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                   origin: infer::SubregionOrigin<'tcx>,\n                                   region: ty::Region,"}, {"sha": "58b67d31ab5803458fa02b9b6be6f4ce41451368", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -397,7 +397,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             match self_type.ty.sty {\n                 ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) |\n-                ty::ty_closure(type_def_id, _, _) => {\n+                ty::ty_closure(type_def_id, _) => {\n                     tcx.destructor_for_type\n                        .borrow_mut()\n                        .insert(type_def_id, method_def_id.def_id());"}, {"sha": "85298e4c6e096e3a4e19c576a9ff448fb3685aed", "filename": "src/test/compile-fail/issue-4335.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -14,7 +14,9 @@\n fn id<T>(t: T) -> T { t }\n \n fn f<'r, T>(v: &'r T) -> Box<FnMut() -> T + 'r> {\n-    id(box || *v) //~ ERROR cannot infer\n+    id(box || *v)\n+        //~^ ERROR `v` does not live long enough\n+        //~| ERROR cannot move out of borrowed content\n }\n \n fn main() {"}, {"sha": "cc33d11241757923acc065286c5de077204ca6e9", "filename": "src/test/compile-fail/regions-proc-bound-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -18,7 +18,7 @@ fn borrowed_proc<'a>(x: &'a isize) -> Box<FnMut()->(isize) + 'a> {\n \n fn static_proc(x: &isize) -> Box<FnMut()->(isize) + 'static> {\n     // This is illegal, because the region bound on `proc` is 'static.\n-    box move|| { *x } //~ ERROR cannot infer\n+    box move|| { *x } //~ ERROR captured variable `x` does not outlive the enclosing closure\n }\n \n fn main() { }"}, {"sha": "c9b378d1df26d433eaaffb4dbfed0f8a381d768c", "filename": "src/test/compile-fail/regions-steal-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -20,9 +20,9 @@ fn box_it<'r>(x: Box<FnMut() + 'r>) -> closure_box<'r> {\n }\n \n fn main() {\n-    let cl_box = {\n+    let mut cl_box = {\n         let mut i = 3;\n-        box_it(box || i += 1) //~ ERROR cannot infer\n+        box_it(box || i += 1) //~ ERROR `i` does not live long enough\n     };\n     cl_box.cl.call_mut(());\n }"}, {"sha": "fe03ca8353d293d80ad34a538945db97b6e4bbc5", "filename": "src/test/compile-fail/send-is-not-static-ensures-scoping.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-ensures-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-ensures-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-ensures-scoping.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -13,9 +13,10 @@ use std::thread;\n fn main() {\n     let bad = {\n         let x = 1;\n-        let y = &x;\n+        let y = &x; //~ ERROR `x` does not live long enough\n \n-        thread::scoped(|| { //~ ERROR cannot infer an appropriate lifetime\n+        thread::scoped(|| {\n+            //~^ ERROR `y` does not live long enough\n             let _z = y;\n         })\n     };"}, {"sha": "5f4bf0d33be67c0ccbbeaa2bc6c8ab8adf2237eb", "filename": "src/test/compile-fail/unboxed-closure-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Ftest%2Fcompile-fail%2Funboxed-closure-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b1500fec44c4ed967542fda3cd9c104addbb80/src%2Ftest%2Fcompile-fail%2Funboxed-closure-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-region.rs?ref=c4b1500fec44c4ed967542fda3cd9c104addbb80", "patch": "@@ -15,6 +15,6 @@\n fn main() {\n     let _f = {\n         let x = 0_usize;\n-        || x //~ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n+        || x //~ ERROR `x` does not live long enough\n     };\n }"}]}