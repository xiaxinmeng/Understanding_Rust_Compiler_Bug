{"sha": "420484579dee03d9b306a45a2fd005d3305206b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMDQ4NDU3OWRlZTAzZDliMzA2YTQ1YTJmZDAwNWQzMzA1MjA2YjE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-21T10:40:27Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-23T09:09:57Z"}, "message": "Better handling of unreachable code in trans\n\nThe builder functions in trans_build now look at an 'unreachable' flag\nin the block context and don't generate code (returning undefined\nplaceholder values) when this flag is set. Threading the unreachable\nflag through context still requires some care, but this seems a more\nsane approach than re-checking for terminated blocks throughout the\ncompiler.\n\nWhen creating a block, if you use its closest dominator as parent, the\nflag will be automatically passed through. If you can't do that,\nbecause the dominator is a scope block that you're trying to get out\nof, you'll have to do something like this to explicitly pass on the\nflag:\n\n    if bcx.unreachable { Unreachable(next_cx); }\n\nCloses #949. Closes #946. Closes #942. Closes #895. Closes #894.\nCloses #892. Closes #957. Closes #958.", "tree": {"sha": "a35e7788c0d76d75ae725f9a0735fc566df5dcf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a35e7788c0d76d75ae725f9a0735fc566df5dcf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/420484579dee03d9b306a45a2fd005d3305206b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/420484579dee03d9b306a45a2fd005d3305206b1", "html_url": "https://github.com/rust-lang/rust/commit/420484579dee03d9b306a45a2fd005d3305206b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/420484579dee03d9b306a45a2fd005d3305206b1/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b029789f02b43772fe53d6ec040cf5ad4400d10c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b029789f02b43772fe53d6ec040cf5ad4400d10c", "html_url": "https://github.com/rust-lang/rust/commit/b029789f02b43772fe53d6ec040cf5ad4400d10c"}], "stats": {"total": 597, "additions": 341, "deletions": 256}, "files": [{"sha": "865417031d0e1f970169b9b89b4f596e8346dca4", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 104, "deletions": 150, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/420484579dee03d9b306a45a2fd005d3305206b1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/420484579dee03d9b306a45a2fd005d3305206b1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=420484579dee03d9b306a45a2fd005d3305206b1", "patch": "@@ -1512,17 +1512,11 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n         }\n       }\n       ty::ty_type. {\n-        trans_fail(cx, none, \"attempt to compare values of type type\");\n-\n-        // This is a bit lame, because we return a dummy block to the\n-        // caller that's actually unreachable, but I don't think it\n-        // matters.\n-        ret rslt(new_sub_block_ctxt(cx, \"after_fail_dummy\"), C_bool(false));\n+        ret trans_fail(cx, none, \"attempt to compare values of type type\");\n       }\n       ty::ty_native(_) {\n-        trans_fail(cx, none::<span>,\n+        ret trans_fail(cx, none::<span>,\n                    \"attempt to compare values of type native\");\n-        ret rslt(new_sub_block_ctxt(cx, \"after_fail_dummy\"), C_bool(false));\n       }\n       _ {\n         // Should never get here, because t is scalar.\n@@ -1592,9 +1586,9 @@ fn compare_scalar_values(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n     let unreach_cx = new_sub_block_ctxt(cx, \"unreach\");\n     Unreachable(unreach_cx);\n     let llswitch = Switch(cx, llop, unreach_cx.llbb, 3u);\n-    llvm::LLVMAddCase(llswitch, C_u8(abi::cmp_glue_op_eq), eq_cx.llbb);\n-    llvm::LLVMAddCase(llswitch, C_u8(abi::cmp_glue_op_lt), lt_cx.llbb);\n-    llvm::LLVMAddCase(llswitch, C_u8(abi::cmp_glue_op_le), le_cx.llbb);\n+    AddCase(llswitch, C_u8(abi::cmp_glue_op_eq), eq_cx.llbb);\n+    AddCase(llswitch, C_u8(abi::cmp_glue_op_lt), lt_cx.llbb);\n+    AddCase(llswitch, C_u8(abi::cmp_glue_op_le), le_cx.llbb);\n     let last_result =\n         Phi(last_cx, T_i1(), [eq_result, lt_result, le_result],\n             [eq_cx.llbb, lt_cx.llbb, le_cx.llbb]);\n@@ -1716,7 +1710,7 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n                 new_sub_block_ctxt(cx,\n                                    \"tag-iter-variant-\" +\n                                        uint::to_str(i, 10u));\n-            llvm::LLVMAddCase(llswitch, C_int(i as int), variant_cx.llbb);\n+            AddCase(llswitch, C_int(i as int), variant_cx.llbb);\n             variant_cx =\n                 iter_variant(variant_cx, llunion_a_ptr, variant, tps, tid, f);\n             Br(variant_cx, next_cx.llbb);\n@@ -1984,20 +1978,20 @@ fn call_bzero(cx: @block_ctxt, dst: ValueRef, n_bytes: ValueRef,\n }\n \n fn memmove_ty(cx: @block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n-   result {\n+    @block_ctxt {\n     let ccx = bcx_ccx(cx);\n     if check type_has_static_size(ccx, t) {\n         if ty::type_is_structural(bcx_tcx(cx), t) {\n             let sp = cx.sp;\n             let llsz = llsize_of(type_of(ccx, sp, t));\n-            ret call_memmove(cx, dst, src, llsz);\n+            ret call_memmove(cx, dst, src, llsz).bcx;\n         }\n-\n-        ret rslt(cx, Store(cx, Load(cx, src), dst));\n+        Store(cx, Load(cx, src), dst);\n+        ret cx;\n     }\n \n     let llsz = size_of(cx, t);\n-    ret call_memmove(llsz.bcx, dst, src, llsz.val);\n+    ret call_memmove(llsz.bcx, dst, src, llsz.val).bcx;\n }\n \n tag copy_action { INIT; DROP_EXISTING; }\n@@ -2052,7 +2046,7 @@ fn copy_val_no_check(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n         {\n         let bcx = cx;\n         if action == DROP_EXISTING { bcx = drop_ty(cx, dst, t); }\n-        bcx = memmove_ty(bcx, dst, src, t).bcx;\n+        bcx = memmove_ty(bcx, dst, src, t);\n         ret take_ty(bcx, dst, t);\n     }\n     ccx.sess.bug(\"unexpected type in trans::copy_val_no_check: \" +\n@@ -2086,7 +2080,7 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n     } else if ty::type_is_unique(tcx, t) ||\n                   type_is_structural_or_param(tcx, t) {\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n-        cx = memmove_ty(cx, dst, src_val, t).bcx;\n+        cx = memmove_ty(cx, dst, src_val, t);\n         if src.is_mem { ret zero_alloca(cx, src_val, t).bcx; }\n \n         // If we're here, it must be a temporary.\n@@ -2242,13 +2236,6 @@ fn trans_compare(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n fn trans_eager_binop(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n                      lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t) -> result {\n \n-    // If either is bottom, it diverges. So no need to do the\n-    // operation.\n-    if ty::type_is_bot(bcx_tcx(cx), lhs_t) ||\n-           ty::type_is_bot(bcx_tcx(cx), rhs_t) {\n-        ret rslt(cx, Unreachable(cx));\n-    }\n-\n     let is_float = false;\n     let intype = lhs_t;\n     if ty::type_is_bot(bcx_tcx(cx), intype) { intype = rhs_t; }\n@@ -2355,10 +2342,10 @@ fn trans_binary(cx: @block_ctxt, op: ast::binop, a: @ast::expr, b: @ast::expr)\n       ast::and. {\n         // Lazy-eval and\n         let lhs_res = trans_expr(cx, a);\n-        let rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n+        let rhs_cx = new_scope_block_ctxt(lhs_res.bcx, \"rhs\");\n         let rhs_res = trans_expr(rhs_cx, b);\n \n-        let lhs_false_cx = new_scope_block_ctxt(cx, \"lhs false\");\n+        let lhs_false_cx = new_scope_block_ctxt(lhs_res.bcx, \"lhs false\");\n         let lhs_false_res = rslt(lhs_false_cx, C_bool(false));\n \n         // The following line ensures that any cleanups for rhs\n@@ -2373,9 +2360,9 @@ fn trans_binary(cx: @block_ctxt, op: ast::binop, a: @ast::expr, b: @ast::expr)\n       ast::or. {\n         // Lazy-eval or\n         let lhs_res = trans_expr(cx, a);\n-        let rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n+        let rhs_cx = new_scope_block_ctxt(lhs_res.bcx, \"rhs\");\n         let rhs_res = trans_expr(rhs_cx, b);\n-        let lhs_true_cx = new_scope_block_ctxt(cx, \"lhs true\");\n+        let lhs_true_cx = new_scope_block_ctxt(lhs_res.bcx, \"lhs true\");\n         let lhs_true_res = rslt(lhs_true_cx, C_bool(true));\n \n         // see the and case for an explanation\n@@ -2401,7 +2388,7 @@ fn join_results(parent_cx: @block_ctxt, t: TypeRef, ins: [result]) -> result {\n     let vals: [ValueRef] = [];\n     let bbs: [BasicBlockRef] = [];\n     for r: result in ins {\n-        if !is_terminated(r.bcx) {\n+        if !r.bcx.unreachable {\n             live += [r];\n             vals += [r.val];\n             bbs += [r.bcx.llbb];\n@@ -2412,7 +2399,6 @@ fn join_results(parent_cx: @block_ctxt, t: TypeRef, ins: [result]) -> result {\n         // No incoming edges are live, so we're in dead-code-land.\n         // Arbitrarily pick the first dead edge, since the caller\n         // is just going to propagate it outward.\n-\n         assert (std::vec::len::<result>(ins) >= 1u);\n         ret ins[0];\n       }\n@@ -2428,28 +2414,23 @@ fn join_results(parent_cx: @block_ctxt, t: TypeRef, ins: [result]) -> result {\n \n fn join_branches(parent_cx: @block_ctxt, ins: [result]) -> @block_ctxt {\n     let out = new_sub_block_ctxt(parent_cx, \"join\");\n-    for r: result in ins { if !is_terminated(r.bcx) { Br(r.bcx, out.llbb); } }\n+    let branched = false;\n+    for r: result in ins {\n+        if !r.bcx.unreachable { Br(r.bcx, out.llbb); branched = true; }\n+    }\n+    if !branched { Unreachable(out); }\n     ret out;\n }\n \n tag out_method { return; save_in(ValueRef); }\n \n fn trans_if(cx: @block_ctxt, cond: @ast::expr, thn: ast::blk,\n             els: option::t<@ast::expr>, output: out_method) -> result {\n-    let cond_res = trans_expr(cx, cond);\n-\n-    if ty::type_is_bot(bcx_tcx(cx), ty::expr_ty(bcx_tcx(cx), cond)) {\n-\n-        // No need to generate code for comparison,\n-        // since the cond diverges.\n-        if !is_terminated(cx) {\n-            ret rslt(cx, Unreachable(cx));\n-        } else { ret cond_res; }\n-    }\n+    let {bcx, val: cond_val} = trans_expr(cx, cond);\n \n-    let then_cx = new_scope_block_ctxt(cx, \"then\");\n+    let then_cx = new_scope_block_ctxt(bcx, \"then\");\n     let then_res = trans_block(then_cx, thn, output);\n-    let else_cx = new_scope_block_ctxt(cx, \"else\");\n+    let else_cx = new_scope_block_ctxt(bcx, \"else\");\n     // Synthesize a block here to act as the else block\n     // containing an if expression. Needed in order for the\n     // else scope to behave like a normal block scope. A tad\n@@ -2471,7 +2452,7 @@ fn trans_if(cx: @block_ctxt, cond: @ast::expr, thn: ast::blk,\n           }\n           _ { rslt(else_cx, C_nil()) }\n         };\n-    CondBr(cond_res.bcx, cond_res.val, then_cx.llbb, else_cx.llbb);\n+    CondBr(bcx, cond_val, then_cx.llbb, else_cx.llbb);\n     ret rslt(join_branches(cx, [then_res, else_res]), C_nil());\n }\n \n@@ -2488,10 +2469,7 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n         bcx = trans_alt::bind_irrefutable_pat(scope_cx, local.node.pat, curr,\n                                               bcx.fcx.lllocals, false);\n         bcx = trans_block(bcx, body, return).bcx;\n-        if !is_terminated(bcx) {\n-            Br(bcx, next_cx.llbb);\n-            // otherwise, this code is unreachable\n-        }\n+        Br(bcx, next_cx.llbb);\n         ret next_cx;\n     }\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -2796,10 +2774,7 @@ fn trans_for_each(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n     let r = trans_block(bcx, body, return);\n     finish_fn(fcx, lltop);\n \n-    if !is_terminated(r.bcx) {\n-        // if terminated is true, no need for the ret-fail\n-        build_return(r.bcx);\n-    }\n+    build_return(r.bcx);\n \n     // Step 3: Call iter passing [lliterbody, llenv], plus other args.\n     alt seq.node {\n@@ -2834,14 +2809,6 @@ fn trans_do_while(cx: @block_ctxt, body: ast::blk, cond: @ast::expr) ->\n         new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>, next_cx,\n                                   \"do-while loop body\");\n     let body_res = trans_block(body_cx, body, return);\n-    if is_terminated(body_res.bcx) {\n-        // This is kind of ridiculous, but no permutations\n-        // involving body_res or body_cx.val worked.\n-        let rs = trans_block(cx, body, return);\n-        if !is_terminated(next_cx) { Unreachable(next_cx); }\n-        if !is_terminated(body_cx) { Unreachable(body_cx); }\n-        ret rs;\n-    }\n     let cond_res = trans_expr(body_res.bcx, cond);\n     CondBr(cond_res.bcx, cond_res.val, body_cx.llbb, next_cx.llbb);\n     Br(cx, body_cx.llbb);\n@@ -3657,20 +3624,7 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n     let bcx: @block_ctxt = cx;\n     let ret_style = ty::ty_fn_ret_style(tcx, fn_ty);\n     let by_ref = ast_util::ret_by_ref(ret_style);\n-    // Arg 0: Output pointer.\n \n-    // FIXME: test case looks like\n-    // f(1, fail, @42);\n-    if is_terminated(bcx) {\n-        // This means an earlier arg was divergent.\n-        // So this arg can't be evaluated.\n-        ret {bcx: bcx,\n-             outer_cx: outer_cx,\n-             args: [],\n-             retslot: C_nil(),\n-             to_zero: to_zero,\n-             to_revoke: to_revoke};\n-    }\n     let retty = ty::ty_fn_ret(tcx, fn_ty), full_retty = retty;\n     alt gen {\n       some(g) {\n@@ -3681,6 +3635,7 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n       }\n       _ { }\n     }\n+    // Arg 0: Output pointer.\n     let llretslot_res = if ty::type_is_nil(tcx, retty) {\n         rslt(cx, llvm::LLVMGetUndef(T_ptr(T_nil())))\n     } else if by_ref {\n@@ -3732,11 +3687,6 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n     let arg_tys = type_of_explicit_args(ccx, cx.sp, args);\n     let i = 0u;\n     for e: @ast::expr in es {\n-        if is_terminated(bcx) {\n-            // This means an earlier arg was divergent.\n-            // So this arg can't be evaluated.\n-            break;\n-        }\n         let is_referenced = alt ret_style {\n           ast::return_ref(_, arg_n) { i + 1u == arg_n }\n           _ { false }\n@@ -3761,9 +3711,9 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n     // expression because of the hack that allows us to process self-calls\n     // with trans_call.\n-    let fn_expr_ty = ty::expr_ty(bcx_tcx(in_cx), f);\n-    let by_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(bcx_tcx(in_cx),\n-                                                          fn_expr_ty));\n+    let tcx = bcx_tcx(in_cx);\n+    let fn_expr_ty = ty::expr_ty(tcx, f);\n+    let by_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(tcx, fn_expr_ty));\n     let cx = new_scope_block_ctxt(in_cx, \"call\");\n     let f_res = trans_callee(cx, f);\n     let bcx = f_res.bcx;\n@@ -3786,7 +3736,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n       }\n     }\n \n-    let ret_ty = ty::node_id_to_type(bcx_tcx(cx), id);\n+    let ret_ty = ty::node_id_to_type(tcx, id);\n     let args_res =\n         trans_args(bcx, in_cx, llenv, f_res.generic, lliterbody, args,\n                    fn_expr_ty);\n@@ -3808,38 +3758,38 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n        type _|_. Since that means it diverges, the code\n        for the call itself is unreachable. */\n     let retval = C_nil();\n-    if !is_terminated(bcx) {\n-        bcx = invoke_fastcall(bcx, faddr, llargs,\n-                              args_res.to_zero, args_res.to_revoke).bcx;\n-        alt lliterbody {\n-          none. {\n-            if !ty::type_is_nil(bcx_tcx(cx), ret_ty) {\n-                if by_ref {\n-                    retval = Load(bcx, llretslot);\n-                } else {\n-                    retval = load_if_immediate(bcx, llretslot, ret_ty);\n-                    // Retval doesn't correspond to anything really tangible\n-                    // in the frame, but it's a ref all the same, so we put a\n-                    // note here to drop it when we're done in this scope.\n-                    add_clean_temp(in_cx, retval, ret_ty);\n-                }\n+    bcx = invoke_fastcall(bcx, faddr, llargs,\n+                          args_res.to_zero, args_res.to_revoke);\n+    alt lliterbody {\n+      none. {\n+        if !ty::type_is_nil(tcx, ret_ty) {\n+            if by_ref {\n+                retval = Load(bcx, llretslot);\n+            } else {\n+                retval = load_if_immediate(bcx, llretslot, ret_ty);\n+                // Retval doesn't correspond to anything really tangible\n+                // in the frame, but it's a ref all the same, so we put a\n+                // note here to drop it when we're done in this scope.\n+                add_clean_temp(in_cx, retval, ret_ty);\n             }\n-          }\n-          some(_) {\n-            // If there was an lliterbody, it means we were calling an\n-            // iter, and we are *not* the party using its 'output' value,\n-            // we should ignore llretslot.\n-          }\n         }\n+      }\n+      some(_) {\n+        // If there was an lliterbody, it means we were calling an\n+        // iter, and we are *not* the party using its 'output' value,\n+        // we should ignore llretslot.\n+      }\n+    }\n+    // Forget about anything we moved out.\n+    bcx = zero_and_revoke(bcx, args_res.to_zero, args_res.to_revoke);\n \n-        // Forget about anything we moved out.\n-        bcx = zero_and_revoke(bcx, args_res.to_zero, args_res.to_revoke);\n-\n-        if !by_ref { bcx = trans_block_cleanups(bcx, cx); }\n-        let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n-        Br(bcx, next_cx.llbb);\n-        bcx = next_cx;\n+    if !by_ref { bcx = trans_block_cleanups(bcx, cx); }\n+    let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n+    if bcx.unreachable || ty::type_is_bot(tcx, ret_ty) {\n+        Unreachable(next_cx);\n     }\n+    Br(bcx, next_cx.llbb);\n+    bcx = next_cx;\n     ret {res: rslt(bcx, retval), by_ref: by_ref};\n }\n \n@@ -3857,14 +3807,15 @@ fn zero_and_revoke(bcx: @block_ctxt,\n }\n \n fn invoke(bcx: @block_ctxt, llfn: ValueRef,\n-          llargs: [ValueRef]) -> result {\n+          llargs: [ValueRef]) -> @block_ctxt {\n     ret invoke_(bcx, llfn, llargs, [], [], Invoke);\n }\n \n fn invoke_fastcall(bcx: @block_ctxt, llfn: ValueRef,\n                    llargs: [ValueRef],\n                    to_zero: [{v: ValueRef, t: ty::t}],\n-                   to_revoke: [{v: ValueRef, t: ty::t}]) -> result {\n+                   to_revoke: [{v: ValueRef, t: ty::t}])\n+    -> @block_ctxt {\n     ret invoke_(bcx, llfn, llargs,\n                 to_zero, to_revoke,\n                 FastInvoke);\n@@ -3874,14 +3825,15 @@ fn invoke_(bcx: @block_ctxt, llfn: ValueRef, llargs: [ValueRef],\n            to_zero: [{v: ValueRef, t: ty::t}],\n            to_revoke: [{v: ValueRef, t: ty::t}],\n            invoker: fn(@block_ctxt, ValueRef, [ValueRef],\n-                       BasicBlockRef, BasicBlockRef) -> ValueRef) -> result {\n+                       BasicBlockRef, BasicBlockRef)) -> @block_ctxt {\n     // FIXME: May be worth turning this into a plain call when there are no\n     // cleanups to run\n+    if bcx.unreachable { ret bcx; }\n     let normal_bcx = new_sub_block_ctxt(bcx, \"normal return\");\n-    let retval = invoker(bcx, llfn, llargs,\n-                         normal_bcx.llbb,\n-                         get_landing_pad(bcx, to_zero, to_revoke));\n-    ret rslt(normal_bcx, retval);\n+    invoker(bcx, llfn, llargs,\n+            normal_bcx.llbb,\n+            get_landing_pad(bcx, to_zero, to_revoke));\n+    ret normal_bcx;\n }\n \n fn get_landing_pad(bcx: @block_ctxt,\n@@ -3923,8 +3875,7 @@ fn get_landing_pad(bcx: @block_ctxt,\n \n fn trans_landing_pad(bcx: @block_ctxt,\n                      to_zero: [{v: ValueRef, t: ty::t}],\n-                     to_revoke: [{v: ValueRef, t: ty::t}]\n-                    ) -> BasicBlockRef {\n+                     to_revoke: [{v: ValueRef, t: ty::t}]) -> BasicBlockRef {\n     // The landing pad return type (the type being propagated). Not sure what\n     // this represents but it's determined by the personality function and\n     // this is what the EH proposal example uses.\n@@ -4144,7 +4095,8 @@ fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n             with_out_method(bind trans_block(sub_cx, blk, _), cx, e.id,\n                             output);\n         Br(cx, sub_cx.llbb);\n-        if !is_terminated(sub.bcx) { Br(sub.bcx, next_cx.llbb); }\n+        Br(sub.bcx, next_cx.llbb);\n+        if sub.bcx.unreachable { Unreachable(next_cx); }\n         ret rslt(next_cx, sub.val);\n       }\n       ast::expr_copy(a) {\n@@ -4479,7 +4431,7 @@ fn trans_fail_value(cx: @block_ctxt, sp_opt: option::t<span>,\n     let V_str = PointerCast(cx, V_fail_str, T_ptr(T_i8()));\n     V_filename = PointerCast(cx, V_filename, T_ptr(T_i8()));\n     let args = [cx.fcx.lltaskptr, V_str, V_filename, C_int(V_line)];\n-    let cx = invoke(cx, bcx_ccx(cx).upcalls._fail, args).bcx;\n+    let cx = invoke(cx, bcx_ccx(cx).upcalls._fail, args);\n     Unreachable(cx);\n     ret rslt(cx, C_nil());\n }\n@@ -4517,9 +4469,10 @@ fn trans_put(in_cx: @block_ctxt, e: option::t<@ast::expr>) -> result {\n         llargs += [r.val];\n       }\n     }\n-    bcx = invoke_fastcall(bcx, llcallee, llargs, [], []).bcx;\n+    bcx = invoke_fastcall(bcx, llcallee, llargs, [], []);\n     bcx = trans_block_cleanups(bcx, cx);\n     let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n+    if bcx.unreachable { Unreachable(next_cx); }\n     Br(bcx, next_cx.llbb);\n     ret rslt(next_cx, C_nil());\n }\n@@ -4541,8 +4494,8 @@ fn trans_break_cont(sp: span, cx: @block_ctxt, to_end: bool) -> result {\n                   _ { Br(bcx, cleanup_cx.llbb); }\n                 }\n             }\n-            ret rslt(new_sub_block_ctxt(bcx, \"break_cont.unreachable\"),\n-                     C_nil());\n+            Unreachable(bcx);\n+            ret rslt(bcx, C_nil());\n           }\n           _ {\n             alt cleanup_cx.parent {\n@@ -4614,7 +4567,8 @@ fn trans_ret(cx: @block_ctxt, e: option::t<@ast::expr>) -> result {\n         }\n     }\n     build_return(bcx);\n-    ret rslt(new_sub_block_ctxt(bcx, \"ret.unreachable\"), C_nil());\n+    Unreachable(bcx);\n+    ret rslt(bcx, C_nil());\n }\n \n fn build_return(bcx: @block_ctxt) { Br(bcx, bcx_fcx(bcx).llreturn); }\n@@ -4759,15 +4713,23 @@ fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n     }\n     let llbb: BasicBlockRef =\n         str::as_buf(s, {|buf| llvm::LLVMAppendBasicBlock(cx.llfn, buf) });\n-    ret @{llbb: llbb,\n-          mutable terminated: false,\n-          parent: parent,\n-          kind: kind,\n-          mutable cleanups: [],\n-          mutable lpad_dirty: true,\n-          mutable lpad: option::none,\n-          sp: cx.sp,\n-          fcx: cx};\n+    let bcx = @{llbb: llbb,\n+                mutable terminated: false,\n+                mutable unreachable: false,\n+                parent: parent,\n+                kind: kind,\n+                mutable cleanups: [],\n+                mutable lpad_dirty: true,\n+                mutable lpad: option::none,\n+                sp: cx.sp,\n+                fcx: cx};\n+    alt parent {\n+      parent_some(cx) {\n+        if cx.unreachable { Unreachable(bcx); }\n+      }\n+      _ {}\n+    }\n+    ret bcx;\n }\n \n \n@@ -4797,6 +4759,7 @@ fn new_sub_block_ctxt(bcx: @block_ctxt, n: str) -> @block_ctxt {\n fn new_raw_block_ctxt(fcx: @fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n     ret @{llbb: llbb,\n           mutable terminated: false,\n+          mutable unreachable: false,\n           parent: parent_none,\n           kind: NON_SCOPE_BLOCK,\n           mutable cleanups: [],\n@@ -4814,9 +4777,9 @@ fn new_raw_block_ctxt(fcx: @fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n // need to make sure those variables go out of scope when the block ends.  We\n // do that by running a 'cleanup' function for each variable.\n // trans_block_cleanups runs all the cleanup functions for the block.\n-fn trans_block_cleanups(cx: @block_ctxt, cleanup_cx: @block_ctxt) ->\n+fn trans_block_cleanups(bcx: @block_ctxt, cleanup_cx: @block_ctxt) ->\n    @block_ctxt {\n-    let bcx = cx;\n+    if bcx.unreachable { ret bcx; }\n     if cleanup_cx.kind == NON_SCOPE_BLOCK {\n         assert (std::vec::len::<cleanup>(cleanup_cx.cleanups) == 0u);\n     }\n@@ -4864,6 +4827,7 @@ iter block_locals(b: ast::blk) -> @ast::local {\n fn llstaticallocas_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n     ret @{llbb: fcx.llstaticallocas,\n           mutable terminated: false,\n+          mutable unreachable: false,\n           parent: parent_none,\n           kind: SCOPE_BLOCK,\n           mutable cleanups: [],\n@@ -4876,6 +4840,7 @@ fn llstaticallocas_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n fn llderivedtydescs_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n     ret @{llbb: fcx.llderivedtydescs,\n           mutable terminated: false,\n+          mutable unreachable: false,\n           parent: parent_none,\n           kind: SCOPE_BLOCK,\n           mutable cleanups: [],\n@@ -4946,10 +4911,6 @@ fn trans_block(cx: @block_ctxt, b: ast::blk, output: out_method) -> result {\n     for s: @ast::stmt in b.node.stmts {\n         r = trans_stmt(bcx, *s);\n         bcx = r.bcx;\n-\n-        // If we hit a terminator, control won't go any further so\n-        // we're in dead-code land. Stop here.\n-        if is_terminated(bcx) { ret r; }\n     }\n     fn accept_out_method(expr: @ast::expr) -> bool {\n         ret alt expr.node {\n@@ -4967,12 +4928,10 @@ fn trans_block(cx: @block_ctxt, b: ast::blk, output: out_method) -> result {\n         if pass {\n             r = trans_expr_out(bcx, e, output);\n             bcx = r.bcx;\n-            if is_terminated(bcx) || ty::type_is_bot(ccx.tcx, r_ty) { ret r; }\n         } else {\n             let lv = trans_lval(bcx, e);\n             r = {bcx: lv.bcx, val: lv.val};\n             bcx = r.bcx;\n-            if is_terminated(bcx) || ty::type_is_bot(ccx.tcx, r_ty) { ret r; }\n             alt output {\n               save_in(target) {\n                 // The output method is to save the value at target,\n@@ -5157,11 +5116,6 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, scope: @block_ctxt, args: [ast::arg],\n     fcx.llcopyargs = llcopyargs.llbb;\n }\n \n-fn is_terminated(cx: @block_ctxt) -> bool {\n-    let inst = llvm::LLVMGetLastInstruction(cx.llbb);\n-    ret llvm::LLVMIsATerminatorInst(inst) as int != 0;\n-}\n-\n fn arg_tys_of_fn(ccx: @crate_ctxt, id: ast::node_id) -> [ty::arg] {\n     alt ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, id)) {\n       ty::ty_fn(_, arg_tys, _, _, _) { ret arg_tys; }\n@@ -5293,7 +5247,7 @@ fn trans_closure(bcx_maybe: option::t<@block_ctxt>,\n         } else { trans_block(bcx, f.body, return) };\n     bcx = rslt.bcx;\n \n-    if !is_terminated(bcx) {\n+    if !bcx.unreachable {\n         // FIXME: until LLVM has a unit type, we are moving around\n         // C_nil values rather than their void type.\n         build_return(bcx);"}, {"sha": "c50c6c87d009dc2f63a3514a75832166ce98a1ea", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/420484579dee03d9b306a45a2fd005d3305206b1/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/420484579dee03d9b306a45a2fd005d3305206b1/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=420484579dee03d9b306a45a2fd005d3305206b1", "patch": "@@ -294,8 +294,6 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n         alt data.guard {\n           some(e) {\n             let guard_cx = new_scope_block_ctxt(bcx, \"submatch_guard\");\n-            let next_cx = new_sub_block_ctxt(bcx, \"submatch_next\");\n-            let else_cx = new_sub_block_ctxt(bcx, \"submatch_else\");\n             Br(bcx, guard_cx.llbb);\n             // Temporarily set bindings. They'll be rewritten to PHI nodes for\n             // the actual arm block.\n@@ -306,14 +304,18 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n             let {bcx: guard_bcx, val: guard_val} =\n                 trans::trans_expr(guard_cx, e);\n             guard_bcx = trans::trans_block_cleanups(guard_bcx, guard_cx);\n+            let next_cx = new_sub_block_ctxt(guard_cx, \"submatch_next\");\n+            let else_cx = new_sub_block_ctxt(guard_cx, \"submatch_else\");\n             CondBr(guard_bcx, guard_val, next_cx.llbb, else_cx.llbb);\n             compile_submatch(else_cx, vec::slice(m, 1u, vec::len(m)), vals, f,\n                              exits);\n             bcx = next_cx;\n           }\n           _ { }\n         }\n-        exits += [{bound: m[0].bound, from: bcx.llbb, to: data.body}];\n+        if !bcx.unreachable {\n+            exits += [{bound: m[0].bound, from: bcx.llbb, to: data.body}];\n+        }\n         Br(bcx, data.body);\n         ret;\n     }\n@@ -417,10 +419,15 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n           no_branch. | single. { bcx }\n           _ { new_sub_block_ctxt(bcx, \"match_else\") }\n         };\n-    let sw =\n-        if kind == switch {\n-            Switch(bcx, test_val, else_cx.llbb, vec::len(opts))\n-        } else { C_int(0) }; // Placeholder for when not using a switch\n+    let sw;\n+    if kind == switch {\n+        sw = Switch(bcx, test_val, else_cx.llbb, vec::len(opts));\n+        // FIXME This statement is purely here as a work-around for a bug that\n+        // I expect to be the same as issue #951. If I remove it, sw ends up\n+        // holding a corrupted value (when the compiler is optimized).\n+        // This can be removed after our next LLVM upgrade.\n+        val_ty(sw);\n+    } else { sw = C_int(0); } // Placeholder for when not using a switch\n \n      // Compile subtrees for each option\n     for opt: opt in opts {\n@@ -430,7 +437,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n           switch. {\n             let r = trans_opt(bcx, opt);\n             bcx = r.bcx;\n-            llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n+            AddCase(sw, r.val, opt_cx.llbb);\n           }\n           compare. {\n             let compare_cx = new_scope_block_ctxt(bcx, \"compare_scope\");\n@@ -514,17 +521,10 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms: [ast::arm],\n     let bodies = [];\n     let match: match = [];\n     let er = trans::trans_expr(cx, expr);\n-    if ty::type_is_bot(bcx_tcx(cx), ty::expr_ty(bcx_tcx(cx), expr)) {\n-\n-        // No need to generate code for alt,\n-        // since the disc diverges.\n-        if !is_terminated(cx) {\n-            ret rslt(cx, Unreachable(cx));\n-        } else { ret er; }\n-    }\n+    if er.bcx.unreachable { ret er; }\n \n     for a: ast::arm in arms {\n-        let body = new_scope_block_ctxt(cx, \"case_body\");\n+        let body = new_scope_block_ctxt(er.bcx, \"case_body\");\n         let id_map = ast_util::pat_id_map(a.pats[0]);\n         bodies += [body];\n         for p: @ast::pat in a.pats {"}, {"sha": "979d6813077b3cad16f767a3560adf7a7d0a2716", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 182, "deletions": 85, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/420484579dee03d9b306a45a2fd005d3305206b1/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/420484579dee03d9b306a45a2fd005d3305206b1/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=420484579dee03d9b306a45a2fd005d3305206b1", "patch": "@@ -3,282 +3,347 @@ import std::str::sbuf;\n import lib::llvm::llvm;\n import llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef, Opcode,\n               ModuleRef};\n-import trans_common::block_ctxt;\n+import trans_common::{block_ctxt, T_ptr, T_nil, T_int, T_i8, T_i1, val_ty};\n \n fn B(cx: @block_ctxt) -> BuilderRef {\n     let b = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(b, cx.llbb);\n     ret b;\n }\n \n-fn RetVoid(cx: @block_ctxt) -> ValueRef {\n+// The difference between a block being unreachable and being terminated is\n+// somewhat obscure, and has to do with error checking. When a block is\n+// terminated, we're saying that trying to add any further statements in the\n+// block is an error. On the other hand, if something is unreachable, that\n+// means that the block was terminated in some way that we don't want to check\n+// for (fail/break/ret statements, call to diverging functions, etc), and\n+// further instructions to the block should simply be ignored.\n+\n+fn RetVoid(cx: @block_ctxt) {\n+    if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    ret llvm::LLVMBuildRetVoid(B(cx));\n+    llvm::LLVMBuildRetVoid(B(cx));\n }\n \n-fn Ret(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n+fn Ret(cx: @block_ctxt, V: ValueRef) {\n+    if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    ret llvm::LLVMBuildRet(B(cx), V);\n+    llvm::LLVMBuildRet(B(cx), V);\n }\n \n-fn AggregateRet(cx: @block_ctxt, RetVals: [ValueRef]) -> ValueRef {\n+fn AggregateRet(cx: @block_ctxt, RetVals: [ValueRef]) {\n+    if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    ret llvm::LLVMBuildAggregateRet(B(cx), vec::to_ptr(RetVals),\n-                                    vec::len(RetVals));\n+    llvm::LLVMBuildAggregateRet(B(cx), vec::to_ptr(RetVals),\n+                                vec::len(RetVals));\n }\n \n-fn Br(cx: @block_ctxt, Dest: BasicBlockRef) -> ValueRef {\n+fn Br(cx: @block_ctxt, Dest: BasicBlockRef) {\n+    if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    ret llvm::LLVMBuildBr(B(cx), Dest);\n+    llvm::LLVMBuildBr(B(cx), Dest);\n }\n \n fn CondBr(cx: @block_ctxt, If: ValueRef, Then: BasicBlockRef,\n-          Else: BasicBlockRef) -> ValueRef {\n+          Else: BasicBlockRef) {\n+    if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    ret llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n+    llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n }\n \n fn Switch(cx: @block_ctxt, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n-   -> ValueRef {\n-    assert (!cx.terminated);\n+    -> ValueRef {\n+    if cx.unreachable { ret _Undef(V); }\n+    assert !cx.terminated;\n     cx.terminated = true;\n     ret llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases);\n }\n \n-fn IndirectBr(cx: @block_ctxt, Addr: ValueRef, NumDests: uint) -> ValueRef {\n+fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n+    if llvm::LLVMIsUndef(S) == lib::llvm::True { ret; }\n+    llvm::LLVMAddCase(S, OnVal, Dest);\n+}\n+\n+fn IndirectBr(cx: @block_ctxt, Addr: ValueRef, NumDests: uint) {\n+    if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    ret llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests);\n+    llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests);\n }\n \n fn Invoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n-          Then: BasicBlockRef, Catch: BasicBlockRef) -> ValueRef {\n+          Then: BasicBlockRef, Catch: BasicBlockRef) {\n+    if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n-                                              vec::len(Args), Then, Catch,\n-                                              buf)\n-                    });\n+    str::as_buf(\"\", {|buf|\n+        llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n+                              vec::len(Args), Then, Catch, buf)\n+    });\n }\n \n fn FastInvoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n-              Then: BasicBlockRef, Catch: BasicBlockRef) -> ValueRef {\n+              Then: BasicBlockRef, Catch: BasicBlockRef) {\n+    if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    let v = str::as_buf(\"\",\n-                        {|buf|\n-                            llvm::LLVMBuildInvoke(B(cx), Fn,\n-                                                  vec::to_ptr(Args),\n-                                                  vec::len(Args), Then,\n-                                                  Catch, buf)\n-                        });\n+    let v = str::as_buf(\"\", {|buf|\n+        llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n+                              vec::len(Args), Then, Catch, buf)\n+    });\n     llvm::LLVMSetInstructionCallConv(v, lib::llvm::LLVMFastCallConv);\n-    ret v;\n }\n \n-fn Unreachable(cx: @block_ctxt) -> ValueRef {\n-    assert (!cx.terminated);\n-    cx.terminated = true;\n-    ret llvm::LLVMBuildUnreachable(B(cx));\n+fn Unreachable(cx: @block_ctxt) {\n+    if cx.unreachable { ret; }\n+    cx.unreachable = true;\n+    if !cx.terminated { llvm::LLVMBuildUnreachable(B(cx)); }\n+}\n+\n+fn _Undef(val: ValueRef) -> ValueRef {\n+    ret llvm::LLVMGetUndef(val_ty(val));\n }\n \n /* Arithmetic */\n fn Add(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAdd(B(cx), LHS, RHS, buf) });\n }\n \n fn NSWAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, buf) });\n }\n \n fn NUWAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, buf) });\n }\n \n fn FAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFAdd(B(cx), LHS, RHS, buf) });\n }\n \n fn Sub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildSub(B(cx), LHS, RHS, buf) });\n }\n \n fn NSWSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, buf) });\n }\n \n fn NUWSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, buf) });\n }\n \n fn FSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFSub(B(cx), LHS, RHS, buf) });\n }\n \n fn Mul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildMul(B(cx), LHS, RHS, buf) });\n }\n \n fn NSWMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, buf) });\n }\n \n fn NUWMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, buf) });\n }\n \n fn FMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFMul(B(cx), LHS, RHS, buf) });\n }\n \n fn UDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildUDiv(B(cx), LHS, RHS, buf) });\n }\n \n fn SDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildSDiv(B(cx), LHS, RHS, buf) });\n }\n \n fn ExactSDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, buf) });\n }\n \n fn FDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFDiv(B(cx), LHS, RHS, buf) });\n }\n \n fn URem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildURem(B(cx), LHS, RHS, buf) });\n }\n \n fn SRem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildSRem(B(cx), LHS, RHS, buf) });\n }\n \n fn FRem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFRem(B(cx), LHS, RHS, buf) });\n }\n \n fn Shl(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildShl(B(cx), LHS, RHS, buf) });\n }\n \n fn LShr(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildLShr(B(cx), LHS, RHS, buf) });\n }\n \n fn AShr(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAShr(B(cx), LHS, RHS, buf) });\n }\n \n fn And(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAnd(B(cx), LHS, RHS, buf) });\n }\n \n fn Or(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildOr(B(cx), LHS, RHS, buf) });\n }\n \n fn Xor(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildXor(B(cx), LHS, RHS, buf) });\n }\n \n fn BinOp(cx: @block_ctxt, Op: Opcode, LHS: ValueRef, RHS: ValueRef) ->\n    ValueRef {\n+    if cx.unreachable { ret _Undef(LHS); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, buf) });\n }\n \n fn Neg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(V); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNeg(B(cx), V, buf) });\n }\n \n fn NSWNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(V); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWNeg(B(cx), V, buf) });\n }\n \n fn NUWNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(V); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWNeg(B(cx), V, buf) });\n }\n fn FNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(V); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFNeg(B(cx), V, buf) });\n }\n \n fn Not(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret _Undef(V); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNot(B(cx), V, buf) });\n }\n \n /* Memory */\n fn Malloc(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildMalloc(B(cx), Ty, buf) });\n }\n \n fn ArrayMalloc(cx: @block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, buf) });\n }\n \n fn Alloca(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(Ty)); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAlloca(B(cx), Ty, buf) });\n }\n \n fn ArrayAlloca(cx: @block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(Ty)); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, buf) });\n }\n \n-fn Free(cx: @block_ctxt, PointerVal: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildFree(B(cx), PointerVal);\n+fn Free(cx: @block_ctxt, PointerVal: ValueRef) {\n+    if cx.unreachable { ret; }\n+    llvm::LLVMBuildFree(B(cx), PointerVal);\n }\n \n fn Load(cx: @block_ctxt, PointerVal: ValueRef) -> ValueRef {\n+    if cx.unreachable {\n+        let ty = val_ty(PointerVal);\n+        let eltty = if llvm::LLVMGetTypeKind(ty) == 11 {\n+            llvm::LLVMGetElementType(ty) } else { T_int() };\n+        ret llvm::LLVMGetUndef(eltty);\n+    }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildLoad(B(cx), PointerVal, buf) });\n }\n \n-fn Store(cx: @block_ctxt, Val: ValueRef, Ptr: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildStore(B(cx), Val, Ptr);\n+fn Store(cx: @block_ctxt, Val: ValueRef, Ptr: ValueRef) {\n+    if cx.unreachable { ret; }\n+    llvm::LLVMBuildStore(B(cx), Val, Ptr);\n }\n \n fn GEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildGEP(B(cx), Pointer,\n-                                           vec::to_ptr(Indices),\n-                                           vec::len(Indices), buf)\n-                    });\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n+    ret str::as_buf(\"\", {|buf|\n+        llvm::LLVMBuildGEP(B(cx), Pointer,\n+                           vec::to_ptr(Indices),\n+                           vec::len(Indices), buf)\n+    });\n }\n \n fn InBoundsGEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) ->\n    ValueRef {\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n-                                                   vec::to_ptr(Indices),\n-                                                   vec::len(Indices), buf)\n-                    });\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n+    ret str::as_buf(\"\", {|buf|\n+        llvm::LLVMBuildInBoundsGEP(B(cx), Pointer, vec::to_ptr(Indices),\n+                                   vec::len(Indices), buf)\n+    });\n }\n \n fn StructGEP(cx: @block_ctxt, Pointer: ValueRef, Idx: uint) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx, buf)\n                     });\n }\n \n fn GlobalString(cx: @block_ctxt, _Str: sbuf) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildGlobalString(B(cx), _Str, buf) });\n }\n \n fn GlobalStringPtr(cx: @block_ctxt, _Str: sbuf) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, buf)\n@@ -287,71 +352,84 @@ fn GlobalStringPtr(cx: @block_ctxt, _Str: sbuf) -> ValueRef {\n \n /* Casts */\n fn Trunc(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildTrunc(B(cx), Val, DestTy, buf) });\n }\n \n fn ZExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildZExt(B(cx), Val, DestTy, buf) });\n }\n \n fn SExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildSExt(B(cx), Val, DestTy, buf) });\n }\n \n fn FPToUI(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, buf) });\n }\n \n fn FPToSI(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, buf) });\n }\n \n fn UIToFP(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, buf) });\n }\n \n fn SIToFP(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, buf) });\n }\n \n fn FPTrunc(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, buf) });\n }\n \n fn FPExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildFPExt(B(cx), Val, DestTy, buf) });\n }\n \n fn PtrToInt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, buf)\n                     });\n }\n \n fn IntToPtr(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, buf)\n                     });\n }\n \n fn BitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildBitCast(B(cx), Val, DestTy, buf) });\n }\n \n fn ZExtOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, buf)\n@@ -360,6 +438,7 @@ fn ZExtOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n \n fn SExtOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, buf)\n@@ -368,6 +447,7 @@ fn SExtOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n \n fn TruncOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, buf)\n@@ -376,37 +456,43 @@ fn TruncOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n \n fn Cast(cx: @block_ctxt, Op: Opcode, Val: ValueRef, DestTy: TypeRef,\n         _Name: sbuf) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, buf)\n                     });\n }\n \n fn PointerCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, buf)\n                     });\n }\n \n fn IntCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildIntCast(B(cx), Val, DestTy, buf) });\n }\n \n fn FPCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildFPCast(B(cx), Val, DestTy, buf) });\n }\n \n \n /* Comparisons */\n fn ICmp(cx: @block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildICmp(B(cx), Op, LHS, RHS, buf) });\n }\n \n fn FCmp(cx: @block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildFCmp(B(cx), Op, LHS, RHS, buf) });\n }\n@@ -415,6 +501,7 @@ fn FCmp(cx: @block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n /* Miscellaneous instructions */\n fn Phi(cx: @block_ctxt, Ty: TypeRef, vals: [ValueRef], bbs: [BasicBlockRef])\n    -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n     let phi = str::as_buf(\"\", {|buf| llvm::LLVMBuildPhi(B(cx), Ty, buf) });\n     assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n     llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n@@ -423,12 +510,21 @@ fn Phi(cx: @block_ctxt, Ty: TypeRef, vals: [ValueRef], bbs: [BasicBlockRef])\n }\n \n fn AddIncomingToPhi(phi: ValueRef, vals: [ValueRef], bbs: [BasicBlockRef]) {\n+    if llvm::LLVMIsUndef(phi) == lib::llvm::True { ret; }\n     assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n     llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n                           vec::len(vals));\n }\n \n+fn _UndefReturn(Fn: ValueRef) -> ValueRef {\n+    let ty = val_ty(Fn);\n+    let retty = if llvm::LLVMGetTypeKind(ty) == 8 {\n+        llvm::LLVMGetReturnType(ty) } else { T_int() };\n+    ret llvm::LLVMGetUndef(retty);\n+}\n+\n fn Call(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n+    if cx.unreachable { ret _UndefReturn(Fn); }\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n@@ -437,6 +533,7 @@ fn Call(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n }\n \n fn FastCall(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n+    if cx.unreachable { ret _UndefReturn(Fn); }\n     let v =\n         str::as_buf(\"\",\n                     {|buf|\n@@ -449,6 +546,7 @@ fn FastCall(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n \n fn CallWithConv(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef], Conv: uint)\n    -> ValueRef {\n+    if cx.unreachable { ret _UndefReturn(Fn); }\n     let v =\n         str::as_buf(\"\",\n                     {|buf|\n@@ -461,18 +559,21 @@ fn CallWithConv(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef], Conv: uint)\n \n fn Select(cx: @block_ctxt, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n    ValueRef {\n+    if cx.unreachable { ret _Undef(Then); }\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildSelect(B(cx), If, Then, Else, buf)\n                     });\n }\n \n fn VAArg(cx: @block_ctxt, list: ValueRef, Ty: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildVAArg(B(cx), list, Ty, buf) });\n }\n \n fn ExtractElement(cx: @block_ctxt, VecVal: ValueRef, Index: ValueRef) ->\n    ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_nil()); }\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildExtractElement(B(cx), VecVal, Index,\n@@ -481,52 +582,55 @@ fn ExtractElement(cx: @block_ctxt, VecVal: ValueRef, Index: ValueRef) ->\n }\n \n fn InsertElement(cx: @block_ctxt, VecVal: ValueRef, EltVal: ValueRef,\n-                 Index: ValueRef) -> ValueRef {\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal,\n-                                                     Index, buf)\n-                    });\n+                 Index: ValueRef) {\n+    if cx.unreachable { ret; }\n+    str::as_buf(\"\", {|buf|\n+        llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, buf)\n+    });\n }\n \n-fn ShuffleVector(cx: @block_ctxt, V1: ValueRef, V2: ValueRef, Mask: ValueRef)\n-   -> ValueRef {\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, buf)\n-                    });\n+fn ShuffleVector(cx: @block_ctxt, V1: ValueRef, V2: ValueRef,\n+                 Mask: ValueRef) {\n+    if cx.unreachable { ret; }\n+    str::as_buf(\"\", {|buf|\n+        llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, buf)\n+    });\n }\n \n fn ExtractValue(cx: @block_ctxt, AggVal: ValueRef, Index: uint) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_nil()); }\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildExtractValue(B(cx), AggVal, Index, buf)\n                     });\n }\n \n fn InsertValue(cx: @block_ctxt, AggVal: ValueRef, EltVal: ValueRef,\n-               Index: uint) -> ValueRef {\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal,\n-                                                   Index, buf)\n-                    });\n+               Index: uint) {\n+    if cx.unreachable { ret; }\n+    str::as_buf(\"\", {|buf|\n+        llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index, buf)\n+    });\n }\n \n fn IsNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildIsNull(B(cx), Val, buf) });\n }\n \n fn IsNotNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildIsNotNull(B(cx), Val, buf) });\n }\n \n fn PtrDiff(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_int()); }\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, buf) });\n }\n \n-fn Trap(cx: @block_ctxt) -> ValueRef {\n+fn Trap(cx: @block_ctxt) {\n+    if cx.unreachable { ret; }\n     let b = B(cx);\n     let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(b);\n     let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n@@ -535,24 +639,17 @@ fn Trap(cx: @block_ctxt) -> ValueRef {\n         str::as_buf(\"llvm.trap\", {|buf| llvm::LLVMGetNamedFunction(M, buf) });\n     assert (T as int != 0);\n     let Args: [ValueRef] = [];\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildCall(b, T, vec::to_ptr(Args),\n-                                            vec::len(Args), buf)\n-                    });\n+    str::as_buf(\"\", {|buf|\n+        llvm::LLVMBuildCall(b, T, vec::to_ptr(Args), vec::len(Args), buf)\n+    });\n }\n \n fn LandingPad(cx: @block_ctxt, Ty: TypeRef, PersFn: ValueRef,\n               NumClauses: uint) -> ValueRef {\n-    assert (!cx.terminated);\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildLandingPad(B(cx),\n-                                                  Ty,\n-                                                  PersFn,\n-                                                  NumClauses,\n-                                                  buf)\n-                    });\n+    assert !cx.terminated && !cx.unreachable;\n+    ret str::as_buf(\"\", {|buf|\n+        llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn, NumClauses, buf)\n+    });\n }\n \n fn SetCleanup(_cx: @block_ctxt, LandingPad: ValueRef) {"}, {"sha": "fb32e6bfe9af36425bc18a77a7a473292f4dace3", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/420484579dee03d9b306a45a2fd005d3305206b1/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/420484579dee03d9b306a45a2fd005d3305206b1/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=420484579dee03d9b306a45a2fd005d3305206b1", "patch": "@@ -386,6 +386,7 @@ type block_ctxt =\n     // attached.\n     {llbb: BasicBlockRef,\n      mutable terminated: bool,\n+     mutable unreachable: bool,\n      parent: block_parent,\n      kind: block_kind,\n      mutable cleanups: [cleanup],\n@@ -394,8 +395,6 @@ type block_ctxt =\n      sp: span,\n      fcx: @fn_ctxt};\n \n-fn is_terminated(cx: @block_ctxt) -> bool { ret cx.terminated; }\n-\n // FIXME: we should be able to use option::t<@block_parent> here but\n // the infinite-tag check in rustboot gets upset.\n tag block_parent { parent_none; parent_some(@block_ctxt); }"}, {"sha": "386a9688969f7fb396015d0099279c0e45427604", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/420484579dee03d9b306a45a2fd005d3305206b1/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/420484579dee03d9b306a45a2fd005d3305206b1/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=420484579dee03d9b306a45a2fd005d3305206b1", "patch": "@@ -281,8 +281,8 @@ fn iter_vec_raw(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n     let data_ptr = Phi(header_cx, val_ty(data_ptr), [data_ptr], [bcx.llbb]);\n     let not_yet_at_end =\n         ICmp(header_cx, lib::llvm::LLVMIntULT, data_ptr, data_end_ptr);\n-    let body_cx = new_sub_block_ctxt(bcx, \"iter_vec_loop_body\");\n-    let next_cx = new_sub_block_ctxt(bcx, \"iter_vec_next\");\n+    let body_cx = new_sub_block_ctxt(header_cx, \"iter_vec_loop_body\");\n+    let next_cx = new_sub_block_ctxt(header_cx, \"iter_vec_next\");\n     CondBr(header_cx, not_yet_at_end, body_cx.llbb, next_cx.llbb);\n     body_cx = f(body_cx, data_ptr, unit_ty);\n     let increment ="}, {"sha": "4441ac99a008d1ecb097667c5cf6628b5a258d66", "filename": "src/test/run-pass/unreachable-code.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/420484579dee03d9b306a45a2fd005d3305206b1/src%2Ftest%2Frun-pass%2Funreachable-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/420484579dee03d9b306a45a2fd005d3305206b1/src%2Ftest%2Frun-pass%2Funreachable-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funreachable-code.rs?ref=420484579dee03d9b306a45a2fd005d3305206b1", "patch": "@@ -0,0 +1,35 @@\n+fn id(x: bool) -> bool { x }\n+\n+fn call_id() {\n+    let c <- fail;\n+    id(c);\n+}\n+\n+fn call_id_2() { id(true) && id(ret); }\n+\n+fn call_id_3() { id(ret) && id(ret); }\n+\n+fn call_id_4() { while id(break) { } }\n+\n+iter put_break() -> int {\n+    while true { put break; }\n+}\n+\n+fn log_fail() { log_err fail; }\n+\n+fn ret_ret() -> int { ret (ret 2) + 3; }\n+\n+fn ret_guard() {\n+    alt 2 {\n+      x when (ret) { x; }\n+    }\n+}\n+\n+fn fail_then_concat() {\n+    let x = [], y = [3];\n+    fail;\n+    x += y;\n+    \"good\" + \"bye\";\n+}\n+\n+fn main() {}"}]}