{"sha": "6e73e45e372a0dfc5a2ebf19780dc392ec092492", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNzNlNDVlMzcyYTBkZmM1YTJlYmYxOTc4MGRjMzkyZWMwOTI0OTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-07T17:51:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-19T18:52:39Z"}, "message": "first steps to autoderef on method calls", "tree": {"sha": "93d63dbf5cb36fa11188afaedf8f20b83bedafc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93d63dbf5cb36fa11188afaedf8f20b83bedafc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e73e45e372a0dfc5a2ebf19780dc392ec092492", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e73e45e372a0dfc5a2ebf19780dc392ec092492", "html_url": "https://github.com/rust-lang/rust/commit/6e73e45e372a0dfc5a2ebf19780dc392ec092492", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e73e45e372a0dfc5a2ebf19780dc392ec092492/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c056fba4db7bd85a5fb3610bec6c00a7ad64f81", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c056fba4db7bd85a5fb3610bec6c00a7ad64f81", "html_url": "https://github.com/rust-lang/rust/commit/6c056fba4db7bd85a5fb3610bec6c00a7ad64f81"}], "stats": {"total": 316, "additions": 198, "deletions": 118}, "files": [{"sha": "99542973c179eed918f20d1fa9245c5cc7f69395", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=6e73e45e372a0dfc5a2ebf19780dc392ec092492", "patch": "@@ -20,9 +20,9 @@ import std::serialization::deserializer_helpers;\n import std::prettyprint::serializer;\n import std::smallintmap::map;\n import middle::{ty, typeck};\n-import middle::typeck::{method_origin,\n-                        serialize_method_origin,\n-                        deserialize_method_origin,\n+import middle::typeck::{method_origin, method_map_entry,\n+                        serialize_method_map_entry,\n+                        deserialize_method_map_entry,\n                         vtable_res,\n                         vtable_origin};\n import driver::session::session;\n@@ -546,16 +546,12 @@ impl of tr for freevar_entry {\n }\n \n // ______________________________________________________________________\n-// Encoding and decoding of method_origin\n-\n-fn encode_method_origin(ebml_w: ebml::writer, mo: method_origin) {\n-    serialize_method_origin(ebml_w, mo)\n-}\n+// Encoding and decoding of method_map_entry\n \n impl helper for ebml::ebml_deserializer {\n-    fn read_method_origin(xcx: extended_decode_ctxt) -> method_origin {\n-        let fv = deserialize_method_origin(self);\n-        fv.tr(xcx)\n+    fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry {\n+        let mme = deserialize_method_map_entry(self);\n+        {derefs: mme.derefs, origin: mme.origin.tr(xcx)}\n     }\n }\n \n@@ -565,8 +561,8 @@ impl of tr for method_origin {\n           typeck::method_static(did) {\n             typeck::method_static(did.tr(xcx))\n           }\n-          typeck::method_param(did, m, p, b) {\n-            typeck::method_param(did.tr(xcx), m, p, b)\n+          typeck::method_param(mp) {\n+            typeck::method_param({iface_id:mp.iface_id.tr(xcx) with mp})\n           }\n           typeck::method_iface(did, m) {\n             typeck::method_iface(did.tr(xcx), m)\n@@ -860,11 +856,11 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     // impl_map is not used except when emitting metadata,\n     // don't need to keep it.\n \n-    option::iter(maps.method_map.find(id)) {|mo|\n+    option::iter(maps.method_map.find(id)) {|mme|\n         ebml_w.tag(c::tag_table_method_map) {||\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val) {||\n-                serialize_method_origin(ebml_w, mo)\n+                serialize_method_map_entry(ebml_w, mme)\n             }\n         }\n     }\n@@ -983,8 +979,9 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 let dvec = @dvec::from_vec(vec::to_mut(ids));\n                 dcx.maps.last_use_map.insert(id, dvec);\n             } else if tag == (c::tag_table_method_map as uint) {\n-                dcx.maps.method_map.insert(id,\n-                                           val_dsr.read_method_origin(xcx));\n+                dcx.maps.method_map.insert(\n+                    id,\n+                    val_dsr.read_method_map_entry(xcx));\n             } else if tag == (c::tag_table_vtable_map as uint) {\n                 dcx.maps.vtable_map.insert(id,\n                                            val_dsr.read_vtable_res(xcx));"}, {"sha": "4bec0e35e7e244fddfc2b8cfa32f2e0c0a2f9ff9", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=6e73e45e372a0dfc5a2ebf19780dc392ec092492", "patch": "@@ -261,14 +261,15 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n                 ty::lookup_item_type(cx.tcx, did).bounds\n               }\n               expr_field(base, _, _) {\n-                alt cx.method_map.get(e.id) {\n+                alt cx.method_map.get(e.id).origin {\n                   typeck::method_static(did) {\n                     // n.b.: When we encode class/impl methods, the bounds\n                     // that we encode include both the class/impl bounds\n                     // and then the method bounds themselves...\n                     ty::lookup_item_type(cx.tcx, did).bounds\n                   }\n-                  typeck::method_param(ifce_id, n_mth, _, _) |\n+                  typeck::method_param({iface_id:ifce_id,\n+                                        method_num:n_mth, _}) |\n                   typeck::method_iface(ifce_id, n_mth) {\n                     // ...iface methods bounds, in contrast, include only the\n                     // method bounds, so we must preprend the tps from the"}, {"sha": "c532e51c584b61b6f5bd079456dde4b92ae18de2", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 101, "deletions": 62, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6e73e45e372a0dfc5a2ebf19780dc392ec092492", "patch": "@@ -1517,13 +1517,13 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n     let _icx = bcx.insn_ctxt(\"trans_unary\");\n     // Check for user-defined method call\n     alt bcx.ccx().maps.method_map.find(un_expr.id) {\n-      some(origin) {\n+      some(mentry) {\n         let callee_id = ast_util::op_expr_callee_id(un_expr);\n         let fty = node_id_type(bcx, callee_id);\n         ret trans_call_inner(\n             bcx, un_expr.info(), fty,\n             expr_ty(bcx, un_expr),\n-            {|bcx| impl::trans_method_callee(bcx, callee_id, e, origin) },\n+            {|bcx| impl::trans_method_callee(bcx, callee_id, e, mentry) },\n             arg_exprs([]), dest);\n       }\n       _ {}\n@@ -1814,14 +1814,17 @@ fn root_value(bcx: block, val: ValueRef, ty: ty::t,\n     add_root_cleanup(bcx, scope_id, root_loc, ty);\n }\n \n+// autoderefs the value `v`, either as many times as we can (if `max ==\n+// uint::max_value`) or `max` times.\n fn autoderef(cx: block, e_id: ast::node_id,\n-             v: ValueRef, t: ty::t) -> result_t {\n+             v: ValueRef, t: ty::t,\n+             max: uint) -> result_t {\n     let _icx = cx.insn_ctxt(\"autoderef\");\n     let mut v1: ValueRef = v;\n     let mut t1: ty::t = t;\n     let ccx = cx.ccx();\n     let mut derefs = 0u;\n-    loop {\n+    while derefs < max {\n         #debug[\"autoderef(e_id=%d, v1=%s, t1=%s, derefs=%u)\",\n                e_id, val_str(ccx.tn, v1), ty_to_str(ccx.tcx, t1),\n                derefs];\n@@ -1872,6 +1875,11 @@ fn autoderef(cx: block, e_id: ast::node_id,\n         }\n         v1 = load_if_immediate(cx, v1, t1);\n     }\n+\n+    // either we were asked to deref a specific number of times, in which case\n+    // we should have, or we asked to deref as many times as we can\n+    assert derefs == max || max == uint::max_value;\n+\n     ret {bcx: cx, val: v1, ty: t1};\n }\n \n@@ -2572,7 +2580,9 @@ fn trans_rec_field(bcx: block, base: @ast::expr,\n                    field: ast::ident) -> lval_result {\n     let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n     let {bcx, val} = trans_temp_expr(bcx, base);\n-    let {bcx, val, ty} = autoderef(bcx, base.id, val, expr_ty(bcx, base));\n+    let {bcx, val, ty} =\n+        autoderef(bcx, base.id, val, expr_ty(bcx, base),\n+                  uint::max_value);\n     trans_rec_field_inner(bcx, val, ty, field, base.span)\n }\n \n@@ -2611,7 +2621,7 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n     let _icx = cx.insn_ctxt(\"trans_index\");\n     let base_ty = expr_ty(cx, base);\n     let exp = trans_temp_expr(cx, base);\n-    let lv = autoderef(exp.bcx, base.id, exp.val, base_ty);\n+    let lv = autoderef(exp.bcx, base.id, exp.val, base_ty, uint::max_value);\n     let ix = trans_temp_expr(lv.bcx, idx);\n     let v = lv.val;\n     let bcx = ix.bcx;\n@@ -2921,13 +2931,16 @@ fn trans_loop_body(bcx: block, e: @ast::expr, ret_flag: option<ValueRef>,\n // temp_cleanups: cleanups that should run only if failure occurs before the\n // call takes place:\n fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n-                  &temp_cleanups: [ValueRef], ret_flag: option<ValueRef>)\n+                  &temp_cleanups: [ValueRef], ret_flag: option<ValueRef>,\n+                  derefs: uint)\n     -> result {\n     #debug(\"+++ trans_arg_expr on %s\", expr_to_str(e));\n     let _icx = cx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = cx.ccx();\n     let e_ty = expr_ty(cx, e);\n     let is_bot = ty::type_is_bot(e_ty);\n+\n+    // translate the arg expr as an lvalue\n     let lv = alt ret_flag {\n       // If there is a ret_flag, this *must* be a loop body\n       some(ptr) {\n@@ -2939,93 +2952,111 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n           }\n         }\n       }\n-      none { trans_temp_lval(cx, e) }\n+      none {\n+        trans_temp_lval(cx, e)\n+      }\n     };\n+\n+    // auto-deref value as required (this only applies to method\n+    // call receivers) of method\n+    #debug(\"   pre-deref value: %s\", val_str(lv.bcx.ccx().tn, lv.val));\n+    let {lv, e_ty} = if derefs == 0u {\n+      {lv: lv, e_ty: e_ty}\n+    } else {\n+      let {bcx, val} = lval_result_to_result(lv, e_ty);\n+      let {bcx, val, ty: e_ty} =\n+          autoderef(bcx, e.id, val, e_ty, derefs);\n+      {lv: {bcx: bcx, val: val, kind: temporary},\n+       e_ty: e_ty}\n+    };\n+\n+    // borrow value (convert from @T to &T and so forth)\n     #debug(\"   pre-adaptation value: %s\", val_str(lv.bcx.ccx().tn, lv.val));\n-    let {lv, arg} = adapt_borrowed_value(lv, arg, e);\n+    let {lv, ty: e_ty} = adapt_borrowed_value(lv, e, e_ty);\n     let mut bcx = lv.bcx;\n     let mut val = lv.val;\n     #debug(\"   adapted value: %s\", val_str(bcx.ccx().tn, val));\n+\n+    // finally, deal with the various modes\n     let arg_mode = ty::resolved_mode(ccx.tcx, arg.mode);\n     if is_bot {\n         // For values of type _|_, we generate an\n         // \"undef\" value, as such a value should never\n         // be inspected. It's important for the value\n         // to have type lldestty (the callee's expected type).\n         val = llvm::LLVMGetUndef(lldestty);\n-    } else if arg_mode == ast::by_ref || arg_mode == ast::by_val {\n-        let imm = ty::type_is_immediate(arg.ty);\n-        #debug[\"   arg.ty=%s, imm=%b, arg_mode=%?, lv.kind=%?\",\n-               ty_to_str(bcx.tcx(), arg.ty), imm, arg_mode, lv.kind];\n-        if arg_mode == ast::by_ref && lv.kind != owned && imm {\n-            val = do_spill_noroot(bcx, val);\n-        }\n-        if arg_mode == ast::by_val && (lv.kind == owned || !imm) {\n-            val = Load(bcx, val);\n-        }\n-    } else if arg_mode == ast::by_copy || arg_mode == ast::by_move {\n-        let alloc = alloc_ty(bcx, arg.ty);\n-        let move_out = arg_mode == ast::by_move ||\n-            ccx.maps.last_use_map.contains_key(e.id);\n-        if lv.kind == temporary { revoke_clean(bcx, val); }\n-        if lv.kind == owned || !ty::type_is_immediate(arg.ty) {\n-            memmove_ty(bcx, alloc, val, arg.ty);\n-            if move_out && ty::type_needs_drop(ccx.tcx, arg.ty) {\n-                bcx = zero_mem(bcx, val, arg.ty);\n+    } else {\n+        alt arg_mode {\n+          ast::by_ref | ast::by_mutbl_ref {\n+            // Ensure that the value is spilled into memory:\n+            if lv.kind != owned && ty::type_is_immediate(e_ty) {\n+                val = do_spill_noroot(bcx, val);\n             }\n-        } else { Store(bcx, val, alloc); }\n-        val = alloc;\n-        if lv.kind != temporary && !move_out {\n-            bcx = take_ty(bcx, val, arg.ty);\n-        }\n+          }\n+\n+          ast::by_val {\n+            // Ensure that the value is not spilled into memory:\n+            if lv.kind == owned || !ty::type_is_immediate(e_ty) {\n+                val = Load(bcx, val);\n+            }\n+          }\n \n-        // In the event that failure occurs before the call actually\n-        // happens, have to cleanup this copy:\n-        add_clean_temp_mem(bcx, val, arg.ty);\n-        temp_cleanups += [val];\n-    } else if ty::type_is_immediate(arg.ty) && lv.kind != owned {\n-        val = do_spill(bcx, val, arg.ty);\n+          ast::by_copy | ast::by_move {\n+            // Ensure that an owned copy of the value is in memory:\n+            let alloc = alloc_ty(bcx, arg.ty);\n+            let move_out = arg_mode == ast::by_move ||\n+                ccx.maps.last_use_map.contains_key(e.id);\n+            if lv.kind == temporary { revoke_clean(bcx, val); }\n+            if lv.kind == owned || !ty::type_is_immediate(arg.ty) {\n+                memmove_ty(bcx, alloc, val, arg.ty);\n+                if move_out && ty::type_needs_drop(ccx.tcx, arg.ty) {\n+                    bcx = zero_mem(bcx, val, arg.ty);\n+                }\n+            } else { Store(bcx, val, alloc); }\n+            val = alloc;\n+            if lv.kind != temporary && !move_out {\n+                bcx = take_ty(bcx, val, arg.ty);\n+            }\n+\n+            // In the event that failure occurs before the call actually\n+            // happens, have to cleanup this copy:\n+            add_clean_temp_mem(bcx, val, arg.ty);\n+            temp_cleanups += [val];\n+          }\n+        }\n     }\n \n     if !is_bot && arg.ty != e_ty || ty::type_has_params(arg.ty) {\n         #debug(\"   casting from %s\", val_str(bcx.ccx().tn, val));\n         val = PointerCast(bcx, val, lldestty);\n     }\n+\n     #debug(\"--- trans_arg_expr passing %s\", val_str(bcx.ccx().tn, val));\n     ret rslt(bcx, val);\n }\n \n-fn load_value_from_lval_result(lv: lval_result) -> ValueRef {\n-    alt lv.kind {\n-      temporary { lv.val }\n-      owned { Load(lv.bcx, lv.val) }\n-      owned_imm { lv.val }\n-    }\n-}\n-\n // when invoking a method, an argument of type @T or ~T can be implicltly\n // converted to an argument of type &T. Similarly, [T] can be converted to\n // [T]/& and so on.  If such a conversion (called borrowing) is necessary,\n // then the borrowings table will have an appropriate entry inserted.  This\n // routine consults this table and performs these adaptations.  It returns a\n // new location for the borrowed result as well as a new type for the argument\n // that reflects the borrowed value and not the original.\n-fn adapt_borrowed_value(lv: lval_result, arg: ty::arg,\n-                        e: @ast::expr) -> {lv: lval_result,\n-                                           arg: ty::arg} {\n+fn adapt_borrowed_value(lv: lval_result,\n+                        e: @ast::expr,\n+                        e_ty: ty::t) -> {lv: lval_result,\n+                                         ty: ty::t} {\n     let bcx = lv.bcx;\n     if !expr_is_borrowed(bcx, e) {\n-        ret {lv:lv, arg:arg};\n+        ret {lv:lv, ty:e_ty};\n     }\n \n-    let e_ty = expr_ty(bcx, e);\n     alt ty::get(e_ty).struct {\n       ty::ty_uniq(mt) | ty::ty_box(mt) {\n-        let box_ptr = load_value_from_lval_result(lv);\n+        let box_ptr = load_value_from_lval_result(lv, e_ty);\n         let body_ptr = GEPi(bcx, box_ptr, [0u, abi::box_field_body]);\n         let rptr_ty = ty::mk_rptr(bcx.tcx(), ty::re_static, mt);\n-        ret {lv: lval_temp(bcx, body_ptr),\n-             arg: {ty: rptr_ty with arg}};\n+        ret {lv: lval_temp(bcx, body_ptr), ty: rptr_ty};\n       }\n \n       ty::ty_str | ty::ty_vec(_) |\n@@ -3057,8 +3088,7 @@ fn adapt_borrowed_value(lv: lval_result, arg: ty::arg,\n                                    {ty: unit_ty, mutbl: ast::m_imm},\n                                    ty::vstore_slice(ty::re_static));\n \n-        ret {lv: lval_temp(bcx, p),\n-             arg: {ty: slice_ty with arg}};\n+        ret {lv: lval_temp(bcx, p), ty: slice_ty};\n       }\n \n       _ {\n@@ -3120,7 +3150,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n         vec::iteri(es) {|i, e|\n             let r = trans_arg_expr(bcx, arg_tys[i], llarg_tys[i],\n                                    e, temp_cleanups, if i == last { ret_flag }\n-                                   else { none });\n+                                   else { none }, 0u);\n             bcx = r.bcx;\n             llargs += [r.val];\n         }\n@@ -3494,11 +3524,20 @@ fn trans_temp_lval(bcx: block, e: @ast::expr) -> lval_result {\n // expressions that must 'end up somewhere' (or get ignored).\n fn trans_temp_expr(bcx: block, e: @ast::expr) -> result {\n     let _icx = bcx.insn_ctxt(\"trans_temp_expr\");\n-    let mut {bcx, val, kind} = trans_temp_lval(bcx, e);\n-    if kind == owned {\n-        val = load_if_immediate(bcx, val, expr_ty(bcx, e));\n+    lval_result_to_result(trans_temp_lval(bcx, e), expr_ty(bcx, e))\n+}\n+\n+fn load_value_from_lval_result(lv: lval_result, ty: ty::t) -> ValueRef {\n+    alt lv.kind {\n+      temporary { lv.val }\n+      owned { load_if_immediate(lv.bcx, lv.val, ty) }\n+      owned_imm { lv.val }\n     }\n-    ret {bcx: bcx, val: val};\n+}\n+\n+fn lval_result_to_result(lv: lval_result, ty: ty::t) -> result {\n+    let val = load_value_from_lval_result(lv, ty);\n+    {bcx: lv.bcx, val: val}\n }\n \n // Arranges for the value found in `*root_loc` to be dropped once the scope"}, {"sha": "514a73726602a4d9b703846af93b7c05677005ba", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=6e73e45e372a0dfc5a2ebf19780dc392ec092492", "patch": "@@ -30,14 +30,14 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n     }\n }\n \n-fn trans_self_arg(bcx: block, base: @ast::expr) -> result {\n+fn trans_self_arg(bcx: block, base: @ast::expr, derefs: uint) -> result {\n     let _icx = bcx.insn_ctxt(\"impl::trans_self_arg\");\n     let basety = expr_ty(bcx, base);\n     let m_by_ref = ast::expl(ast::by_ref);\n     let mut temp_cleanups = [];\n     let result = trans_arg_expr(bcx, {mode: m_by_ref, ty: basety},\n                                 T_ptr(type_of::type_of(bcx.ccx(), basety)),\n-                                base, temp_cleanups, none);\n+                                base, temp_cleanups, none, derefs);\n \n     // by-ref self argument should not require cleanup in the case of\n     // other arguments failing:\n@@ -47,19 +47,20 @@ fn trans_self_arg(bcx: block, base: @ast::expr) -> result {\n }\n \n fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n-                       self: @ast::expr, origin: typeck::method_origin)\n+                       self: @ast::expr, mentry: typeck::method_map_entry)\n     -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_method_callee\");\n-    alt origin {\n+    alt mentry.origin {\n       typeck::method_static(did) {\n-        let {bcx, val} = trans_self_arg(bcx, self);\n+        let {bcx, val} = trans_self_arg(bcx, self, mentry.derefs);\n         {env: self_env(val, node_id_type(bcx, self.id), none)\n          with lval_static_fn(bcx, did, callee_id)}\n       }\n-      typeck::method_param(iid, off, p, b) {\n+      typeck::method_param({iface_id:iid, method_num:off,\n+                            param_num:p, bound_num:b}) {\n         alt check bcx.fcx.param_substs {\n           some(substs) {\n-            trans_monomorphized_callee(bcx, callee_id, self,\n+            trans_monomorphized_callee(bcx, callee_id, self, mentry.derefs,\n                                        iid, off, p, b, substs)\n           }\n         }\n@@ -107,8 +108,9 @@ fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n }\n \n fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n-                              base: @ast::expr, iface_id: ast::def_id,\n-                              n_method: uint, n_param: uint, n_bound: uint,\n+                              base: @ast::expr, derefs: uint,\n+                              iface_id: ast::def_id, n_method: uint,\n+                              n_param: uint, n_bound: uint,\n                               substs: param_substs) -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n     alt find_vtable_in_fn_ctxt(substs, n_param, n_bound) {\n@@ -120,7 +122,7 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n         let node_substs = node_id_type_params(bcx, callee_id);\n         let ty_substs = impl_substs +\n             vec::tailn(node_substs, node_substs.len() - n_m_tps);\n-        let {bcx, val} = trans_self_arg(bcx, base);\n+        let {bcx, val} = trans_self_arg(bcx, base, derefs);\n         let lval = lval_static_fn_inner(bcx, mth_id, callee_id, ty_substs,\n                                         some(sub_origins));\n         {env: self_env(val, node_id_type(bcx, base.id), none),"}, {"sha": "4ca10198f177e979e65f3ab235a756b09f0524d8", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=6e73e45e372a0dfc5a2ebf19780dc392ec092492", "patch": "@@ -180,7 +180,9 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n           }\n           expr_field(_, _, _) {\n             alt cx.method_map.find(e.id) {\n-              some(typeck::method_static(did)) { traverse_def_id(cx, did); }\n+              some({origin: typeck::method_static(did), _}) {\n+                traverse_def_id(cx, did);\n+              }\n               _ {}\n             }\n           }"}, {"sha": "1eca2db5e7d5f0def2b0790f7b60525924aa56e1", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=6e73e45e372a0dfc5a2ebf19780dc392ec092492", "patch": "@@ -3,10 +3,10 @@ import driver::session::session;\n import lib::llvm::{ValueRef, TypeRef};\n import back::abi;\n import base::{call_memmove,\n-               INIT, copy_val, load_if_immediate, get_tydesc,\n-               sub_block, do_spill_noroot,\n-               dest, bcx_icx, non_gc_box_cast,\n-               heap, heap_exchange, heap_shared};\n+              INIT, copy_val, load_if_immediate, get_tydesc,\n+              sub_block, do_spill_noroot,\n+              dest, bcx_icx, non_gc_box_cast,\n+              heap, heap_exchange, heap_shared};\n import syntax::codemap::span;\n import shape::llsize_of;\n import build::*;"}, {"sha": "6b453b9d9dc52791d0ba4b647e91394afb7370c3", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=6e73e45e372a0dfc5a2ebf19780dc392ec092492", "patch": "@@ -189,14 +189,14 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n \n         option::iter(cx.ccx.maps.method_map.find(e.id)) {|mth|\n-            alt mth {\n+            alt mth.origin {\n               typeck::method_static(did) {\n                 option::iter(cx.ccx.tcx.node_type_substs.find(e.id)) {|ts|\n                     vec::iter2(type_uses_for(cx.ccx, did, ts.len()), ts)\n                         {|uses, subst| type_needs(cx, uses, subst)}\n                 }\n               }\n-              typeck::method_param(_, _, param, _) {\n+              typeck::method_param({param_num: param, _}) {\n                 cx.uses[param] |= use_tydesc;\n               }\n               typeck::method_iface(_, _) {}"}, {"sha": "ec7ec06080c6ac48d7b961155ec79b88846cbb74", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=6e73e45e372a0dfc5a2ebf19780dc392ec092492", "patch": "@@ -70,18 +70,54 @@ export check_crate;\n export infer;\n export method_map;\n export method_origin, serialize_method_origin, deserialize_method_origin;\n+export method_map_entry, serialize_method_map_entry;\n+export deserialize_method_map_entry;\n export vtable_map;\n export vtable_res;\n export vtable_origin;\n \n #[auto_serialize]\n enum method_origin {\n+    // fully statically resolved method\n     method_static(ast::def_id),\n-    // iface id, method num, param num, bound num\n-    method_param(ast::def_id, uint, uint, uint),\n+\n+    // method invoked on a type parameter with a bounded iface\n+    method_param(method_param),\n+\n+    // method invoked on a boxed iface\n     method_iface(ast::def_id, uint),\n }\n-type method_map = hashmap<ast::node_id, method_origin>;\n+\n+// details for a method invoked with a receiver whose type is a type parameter\n+// with a bounded iface.\n+#[auto_serialize]\n+type method_param = {\n+    // the iface containing the method to be invoked\n+    iface_id: ast::def_id,\n+\n+    // index of the method to be invoked amongst the iface's methods\n+    method_num: uint,\n+\n+    // index of the type parameter (from those that are in scope) that is\n+    // the type of the receiver\n+    param_num: uint,\n+\n+    // index of the bound for this type parameter which specifies the iface\n+    bound_num: uint\n+};\n+\n+#[auto_serialize]\n+type method_map_entry = {\n+    // number of derefs that are required on the receiver\n+    derefs: uint,\n+\n+    // method details being invoked\n+    origin: method_origin\n+};\n+\n+// maps from an expression id that corresponds to a method call to the details\n+// of the method to be invoked\n+type method_map = hashmap<ast::node_id, method_map_entry>;\n \n // Resolutions for bounds of all parameters, left to right, for a given path.\n type vtable_res = @[vtable_origin];"}, {"sha": "9b9b92e1e01153bfdd2530fa0b14bea8cf748d18", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=6e73e45e372a0dfc5a2ebf19780dc392ec092492", "patch": "@@ -1642,8 +1642,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                        supplied_tps: tps,\n                                        include_private: is_self_ref});\n             alt lkup.method() {\n-              some(origin) {\n-                fcx.ccx.method_map.insert(id, origin);\n+              some(entry) {\n+                fcx.ccx.method_map.insert(id, entry);\n               }\n               none {\n                 let t_err = fcx.infcx.resolve_type_vars_if_possible(expr_t);\n@@ -1699,8 +1699,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                    supplied_tps: [],\n                                    include_private: false});\n         alt lkup.method() {\n-          some(origin) {\n-            fcx.ccx.method_map.insert(alloc_id, origin);\n+          some(entry) {\n+            fcx.ccx.method_map.insert(alloc_id, entry);\n \n             // Check that the alloc() method has the expected type, which\n             // should be fn(sz: uint, align: uint) -> *()."}, {"sha": "143a477302bde7b7caf6b95b7d4db1bba27d9fa6", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=6e73e45e372a0dfc5a2ebf19780dc392ec092492", "patch": "@@ -17,7 +17,7 @@ enum lookup = {\n \n impl methods for lookup {\n     // Entrypoint:\n-    fn method() -> option<method_origin> {\n+    fn method() -> option<method_map_entry> {\n         #debug[\"method lookup(m_name=%s, self_ty=%s)\",\n                *self.m_name, self.fcx.infcx.ty_to_str(self.self_ty)];\n \n@@ -45,7 +45,9 @@ impl methods for lookup {\n \n     fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n \n-    fn method_from_param(n: uint, did: ast::def_id) -> option<method_origin> {\n+    fn method_from_param(n: uint, did: ast::def_id)\n+        -> option<method_map_entry> {\n+\n         let tcx = self.tcx();\n         let mut iface_bnd_idx = 0u; // count only iface bounds\n         let bounds = tcx.ty_param_bounds.get(did.node);\n@@ -105,11 +107,15 @@ impl methods for lookup {\n \n         let (substs, mty, iid, pos, n, iface_bnd_idx) = candidates[0u];\n         ret some(self.write_mty_from_m(\n-            substs, mty, method_param(iid, pos, n, iface_bnd_idx)));\n+            substs, mty, method_param({iface_id:iid,\n+                                       method_num:pos,\n+                                       param_num:n,\n+                                       bound_num:iface_bnd_idx})));\n     }\n \n     fn method_from_iface(\n-        did: ast::def_id, iface_substs: ty::substs) -> option<method_origin> {\n+        did: ast::def_id, iface_substs: ty::substs)\n+        -> option<method_map_entry> {\n \n         let ms = *ty::iface_methods(self.tcx(), did);\n         for ms.eachi {|i, m|\n@@ -145,7 +151,7 @@ impl methods for lookup {\n     }\n \n     fn method_from_class(did: ast::def_id, class_substs: ty::substs)\n-        -> option<method_origin> {\n+        -> option<method_map_entry> {\n \n         let ms = *ty::iface_methods(self.tcx(), did);\n \n@@ -196,7 +202,7 @@ impl methods for lookup {\n         */\n     }\n \n-    fn method_from_scope() -> option<method_origin> {\n+    fn method_from_scope() -> option<method_map_entry> {\n         let impls_vecs = self.fcx.ccx.impl_map.get(self.expr.id);\n \n         for list::each(impls_vecs) {|impls|\n@@ -273,7 +279,7 @@ impl methods for lookup {\n \n     fn write_mty_from_m(self_substs: ty::substs,\n                         m: ty::method,\n-                        origin: method_origin) -> method_origin {\n+                        origin: method_origin) -> method_map_entry {\n         let tcx = self.fcx.ccx.tcx;\n \n         // a bit hokey, but the method unbound has a bare protocol, whereas\n@@ -287,7 +293,7 @@ impl methods for lookup {\n     fn write_mty_from_fty(self_substs: ty::substs,\n                           n_tps_m: uint,\n                           fty: ty::t,\n-                          origin: method_origin) -> method_origin {\n+                          origin: method_origin) -> method_map_entry {\n \n         let tcx = self.fcx.ccx.tcx;\n \n@@ -324,7 +330,7 @@ impl methods for lookup {\n \n         self.fcx.write_ty_substs(self.node_id, fty, all_substs);\n \n-        ret origin;\n+        ret {derefs:0u, origin:origin};\n     }\n }\n "}, {"sha": "d772f6861dedd0fc9e9eae771c9a0a2d14dd153b", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=6e73e45e372a0dfc5a2ebf19780dc392ec092492", "patch": "@@ -216,7 +216,7 @@ fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n       ast::expr_unary(*) | ast::expr_assign_op(*) |\n       ast::expr_index(*) {\n         alt cx.method_map.find(ex.id) {\n-          some(method_static(did)) {\n+          some({origin: method_static(did), _}) {\n             let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n             if has_iface_bounds(*bounds) {\n                 let callee_id = alt ex.node {"}, {"sha": "9d79e28b219d00e60cd490c04eecd0de85d02b11", "filename": "src/test/run-pass/borrowck-fixed-length-vecs.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Ftest%2Frun-pass%2Fborrowck-fixed-length-vecs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e73e45e372a0dfc5a2ebf19780dc392ec092492/src%2Ftest%2Frun-pass%2Fborrowck-fixed-length-vecs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-fixed-length-vecs.rs?ref=6e73e45e372a0dfc5a2ebf19780dc392ec092492", "patch": "@@ -1,6 +1,3 @@\n-// xfail-fast   (compile-flags unsupported on windows)\n-// compile-flags:--borrowck=err\n-\n fn main() {\n     let x = [22]/1;\n     let y = &x[0];"}]}