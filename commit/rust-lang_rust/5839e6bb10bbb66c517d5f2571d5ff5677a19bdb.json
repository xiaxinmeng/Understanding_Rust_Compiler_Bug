{"sha": "5839e6bb10bbb66c517d5f2571d5ff5677a19bdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MzllNmJiMTBiYmI2NmM1MTdkNWYyNTcxZDVmZjU2NzdhMTliZGI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-11T20:03:57Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-16T11:34:33Z"}, "message": "Add ability to unit-test dataflow results via `rustc_peek` intrinsic.\n\n(The static semantics of `rustc_peek` is derived from attributes\nattached to the function being compiled; in this case,\n`rustc_peek(&expr)` observes the dataflow state for the l-value\n`expr`.)", "tree": {"sha": "cba4724fd140d0bcc13e1a5c94d103e92b6df5b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cba4724fd140d0bcc13e1a5c94d103e92b6df5b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5839e6bb10bbb66c517d5f2571d5ff5677a19bdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5839e6bb10bbb66c517d5f2571d5ff5677a19bdb", "html_url": "https://github.com/rust-lang/rust/commit/5839e6bb10bbb66c517d5f2571d5ff5677a19bdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5839e6bb10bbb66c517d5f2571d5ff5677a19bdb/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bb598429afacd0416c0c9bc5d0a4520d17de901", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bb598429afacd0416c0c9bc5d0a4520d17de901", "html_url": "https://github.com/rust-lang/rust/commit/3bb598429afacd0416c0c9bc5d0a4520d17de901"}], "stats": {"total": 211, "additions": 208, "deletions": 3}, "files": [{"sha": "f74fb4ebadc2920247cbbe5d0f4fcb0df54046dd", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/5839e6bb10bbb66c517d5f2571d5ff5677a19bdb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5839e6bb10bbb66c517d5f2571d5ff5677a19bdb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=5839e6bb10bbb66c517d5f2571d5ff5677a19bdb", "patch": "@@ -0,0 +1,193 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::abi::{Abi};\n+use syntax::ast;\n+\n+use rustc::ty::{self, TyCtxt};\n+use rustc::mir::repr::{self, Mir};\n+\n+use bitslice::BitSlice;\n+\n+use super::super::gather_moves::MovePath;\n+use super::{bitwise, Union, Subtract};\n+use super::BitDenotation;\n+use super::DataflowResults;\n+use super::HasMoveData;\n+\n+pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                mir: &Mir<'tcx>,\n+                                                id: ast::NodeId,\n+                                                _attributes: &[ast::Attribute],\n+                                                flow_ctxt: &O::Ctxt,\n+                                                results: &DataflowResults<O>)\n+    where O: BitDenotation<Bit=MovePath<'tcx>>, O::Ctxt: HasMoveData<'tcx>\n+{\n+    debug!(\"sanity_check_via_rustc_peek id: {:?}\", id);\n+    // FIXME: this is not DRY. Figure out way to abstract this and\n+    // `dataflow::build_sets`. (But see note below about how the\n+    // behavior of this traversal is a bit different than that\n+    // performed by `build_sets`.)\n+\n+    let blocks = mir.all_basic_blocks();\n+    'next_block: for bb in blocks {\n+        let bb_data = mir.basic_block_data(bb);\n+        let &repr::BasicBlockData { ref statements,\n+                                    ref terminator,\n+                                    is_cleanup: _ } = bb_data;\n+\n+        let (args, span) = if let Some(repr::Terminator { ref kind, span, .. }) = *terminator {\n+            if let repr::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind\n+            {\n+                if let repr::Operand::Constant(ref func) = *oper\n+                {\n+                    if let ty::TyFnDef(def_id, _, &ty::BareFnTy { abi, .. }) = func.ty.sty\n+                    {\n+                        let name = tcx.item_name(def_id);\n+                        if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n+                            if name.as_str() == \"rustc_peek\" {\n+                                (args, span)\n+                            } else {\n+                                continue;\n+                            }\n+                        } else {\n+                            continue;\n+                        }\n+                    } else {\n+                        continue;\n+                    }\n+                } else {\n+                    continue;\n+                }\n+            } else {\n+                continue;\n+            }\n+        } else {\n+            continue;\n+        };\n+        assert!(args.len() == 1);\n+        let peek_arg_lval = match args[0] {\n+            repr::Operand::Consume(ref lval @ repr::Lvalue::Temp(_)) => {\n+                lval\n+            }\n+            repr::Operand::Consume(_) => {\n+                bug!(\"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\");\n+            }\n+            repr::Operand::Constant(_) => {\n+                bug!(\"dataflow::sanity_check cannot feed a constant to rustc_peek.\");\n+            }\n+        };\n+\n+        let mut entry = results.0.sets.on_entry_set_for(bb.index()).to_owned();\n+        let mut gen = results.0.sets.gen_set_for(bb.index()).to_owned();\n+        let mut kill = results.0.sets.kill_set_for(bb.index()).to_owned();\n+\n+        let move_data = flow_ctxt.move_data();\n+\n+        // Emulate effect of all statements in the block up to (but\n+        // not including) the assignment to `peek_arg_lval`. Do *not*\n+        // include terminator (since we are peeking the state of the\n+        // argument at time immediate preceding Call to `rustc_peek`).\n+\n+        let mut sets = super::BlockSets { on_entry: &mut entry[..],\n+                                          gen_set: &mut gen[..],\n+                                          kill_set: &mut kill[..] };\n+        // Unfortunately if we just re-do the same thing that dataflow does, then\n+        // it will always appear like Lvalues are initialized; e.g. in\n+        // a case like:\n+        //\n+        // <bitset maps var1 to 0>\n+        // tmp13 = var1;\n+        // tmp14 = &tmp13;\n+        // rustc_peek(tmp14)\n+        //\n+        // The gen_set for normal dataflow would treat tmp13 as\n+        // initialized, even though it's source expression is\n+        // uninitialized.\n+        //\n+        // Work around this for rustc_peek by explicitly propagating\n+        // the relevant bitvector state when computing the effect of a\n+        // statement.\n+\n+        for (j, stmt) in statements.iter().enumerate() {\n+            debug!(\"rustc_peek: ({:?},{}) {:?}\", bb, j, stmt);\n+            let (lvalue, rvalue) = match stmt.kind {\n+                repr::StatementKind::Assign(ref lvalue, ref rvalue) => {\n+                    (lvalue, rvalue)\n+                }\n+            };\n+\n+            if lvalue == peek_arg_lval {\n+                if let repr::Rvalue::Ref(_,\n+                                         repr::BorrowKind::Shared,\n+                                         ref peeking_at_lval) = *rvalue {\n+                    // Okay, our search is over.\n+                    let peek_mpi = move_data.rev_lookup.find(peeking_at_lval);\n+                    let bit_state = sets.on_entry.get_bit(peek_mpi.idx());\n+                    debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n+                           lvalue, peeking_at_lval, bit_state);\n+                    if !bit_state {\n+                        tcx.sess.span_err(span, &format!(\"rustc_peek: bit not set\"));\n+                    }\n+                    continue 'next_block;\n+                } else {\n+                    // Our search should have been over, but the input\n+                    // does not match expectations of `rustc_peek` for\n+                    // this sanity_check.\n+                    tcx.sess.span_err(span, &format!(\"rustc_peek: argument expression \\\n+                                                      must be immediate borrow of form `&expr`\"));\n+                }\n+            }\n+\n+            enum Effect<'a, 'tcx:'a> { Propagate(&'a repr::Lvalue<'tcx>), Compute }\n+            let lvalue_effect: Effect = match *rvalue {\n+                // tmp = rhs\n+                repr::Rvalue::Use(repr::Operand::Consume(ref rhs_lval)) =>\n+                    Effect::Propagate(rhs_lval),\n+\n+                repr::Rvalue::Use(repr::Operand::Constant(_)) =>\n+                    Effect::Compute,\n+\n+                _ => {\n+                    // (fall back to BitDenotation for all other kinds of Rvalues\n+                    Effect::Compute\n+                }\n+            };\n+\n+            let lhs_mpi = move_data.rev_lookup.find(lvalue);\n+\n+            if let Effect::Propagate(rhs_lval) = lvalue_effect {\n+                let rhs_mpi = move_data.rev_lookup.find(rhs_lval);\n+                let state = sets.on_entry.get_bit(rhs_mpi.idx());\n+                debug!(\"rustc_peek: propagate into lvalue {:?} ({:?}) from rhs: {:?} state: {}\",\n+                       lvalue, lhs_mpi, rhs_lval, state);\n+                if state {\n+                    sets.on_entry.set_bit(lhs_mpi.idx());\n+                } else {\n+                    sets.on_entry.clear_bit(lhs_mpi.idx());\n+                }\n+            } else {\n+                debug!(\"rustc_peek: computing effect on lvalue: {:?} ({:?}) in stmt: {:?}\",\n+                       lvalue, lhs_mpi, stmt);\n+                // reset GEN and KILL sets before emulating their effect.\n+                for e in &mut sets.gen_set[..] { *e = 0; }\n+                for e in &mut sets.kill_set[..] { *e = 0; }\n+                results.0.operator.statement_effect(flow_ctxt, &mut sets, bb, j);\n+                bitwise(sets.on_entry, sets.gen_set, &Union);\n+                bitwise(sets.on_entry, sets.kill_set, &Subtract);\n+            }\n+        }\n+\n+        tcx.sess.span_err(span, &format!(\"rustc_peek: MIR did not match \\\n+                                          anticipated pattern; note that \\\n+                                          rustc_peek expects input of \\\n+                                          form `&expr`\"));\n+    }\n+}"}, {"sha": "ce49e9fc93d6159142c73224b49a31b5a20d8489", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5839e6bb10bbb66c517d5f2571d5ff5677a19bdb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5839e6bb10bbb66c517d5f2571d5ff5677a19bdb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=5839e6bb10bbb66c517d5f2571d5ff5677a19bdb", "patch": "@@ -75,9 +75,21 @@ pub fn borrowck_mir<'a, 'tcx: 'a>(\n     let move_data = MoveData::gather_moves(mir, tcx);\n     let ctxt = (tcx, mir, move_data);\n     let (ctxt, flow_inits) =\n-        do_dataflow(bcx, mir, id, attributes, ctxt, MaybeInitializedLvals::default());\n-    let ((_, _, move_data), flow_uninits) =\n-        do_dataflow(bcx, mir, id, attributes, ctxt, MaybeUninitializedLvals::default());\n+        do_dataflow(tcx, mir, id, attributes, ctxt, MaybeInitializedLvals::default());\n+    let (ctxt, flow_uninits) =\n+        do_dataflow(tcx, mir, id, attributes, ctxt, MaybeUninitializedLvals::default());\n+\n+    if has_rustc_mir_with(attributes, \"rustc_peek_maybe_init\").is_some() {\n+        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &ctxt, &flow_inits);\n+    }\n+    if has_rustc_mir_with(attributes, \"rustc_peek_maybe_uninit\").is_some() {\n+        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &ctxt, &flow_uninits);\n+    }\n+    let move_data = ctxt.2;\n+\n+    if has_rustc_mir_with(attributes, \"stop_after_dataflow\").is_some() {\n+        bcx.tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n+    }\n \n     let mut mbcx = MirBorrowckCtxt {\n         bcx: bcx,"}]}