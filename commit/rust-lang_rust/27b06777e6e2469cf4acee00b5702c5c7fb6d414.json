{"sha": "27b06777e6e2469cf4acee00b5702c5c7fb6d414", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3YjA2Nzc3ZTZlMjQ2OWNmNGFjZWUwMGI1NzAyYzVjN2ZiNmQ0MTQ=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-02-11T21:36:24Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-02-22T00:17:06Z"}, "message": "Cleanup, commenting, trivial renaming", "tree": {"sha": "5299b5ec41e54e2ce5fefebb33d7b4f802a05518", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5299b5ec41e54e2ce5fefebb33d7b4f802a05518"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27b06777e6e2469cf4acee00b5702c5c7fb6d414", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27b06777e6e2469cf4acee00b5702c5c7fb6d414", "html_url": "https://github.com/rust-lang/rust/commit/27b06777e6e2469cf4acee00b5702c5c7fb6d414", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27b06777e6e2469cf4acee00b5702c5c7fb6d414/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a5e8c52183a980f6c2fc63a668245d73ecac200", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a5e8c52183a980f6c2fc63a668245d73ecac200", "html_url": "https://github.com/rust-lang/rust/commit/4a5e8c52183a980f6c2fc63a668245d73ecac200"}], "stats": {"total": 98, "additions": 75, "deletions": 23}, "files": [{"sha": "d16b1282c7c0beb5337bf360ecccd7d5c265eae6", "filename": "src/libstd/json.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27b06777e6e2469cf4acee00b5702c5c7fb6d414/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b06777e6e2469cf4acee00b5702c5c7fb6d414/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=27b06777e6e2469cf4acee00b5702c5c7fb6d414", "patch": "@@ -1294,8 +1294,6 @@ mod tests {\n         }\n     }\n \n-    // testing both auto_encode's calling patterns\n-    // and json... not sure where to put these tests.\n     #[test]\n     fn test_write_enum () {\n         let bw = @io::BytesWriter();"}, {"sha": "87e1dd2d22cb5af98b0c9d6d09291518aec58389", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/27b06777e6e2469cf4acee00b5702c5c7fb6d414/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b06777e6e2469cf4acee00b5702c5c7fb6d414/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=27b06777e6e2469cf4acee00b5702c5c7fb6d414", "patch": "@@ -26,17 +26,9 @@ use std::term;\n pub type Emitter = fn@(cmsp: Option<(@codemap::CodeMap, span)>,\n                    msg: &str, lvl: level);\n \n-\n-pub trait span_handler {\n-    fn span_fatal(@mut self, sp: span, msg: &str) -> !;\n-    fn span_err(@mut self, sp: span, msg: &str);\n-    fn span_warn(@mut self, sp: span, msg: &str);\n-    fn span_note(@mut self, sp: span, msg: &str);\n-    fn span_bug(@mut self, sp: span, msg: &str) -> !;\n-    fn span_unimpl(@mut self, sp: span, msg: &str) -> !;\n-    fn handler(@mut self) -> handler;\n-}\n-\n+// a handler deals with errors; certain errors\n+// (fatal, bug, unimpl) may cause immediate exit,\n+// others log errors for later reporting.\n pub trait handler {\n     fn fatal(@mut self, msg: &str) -> !;\n     fn err(@mut self, msg: &str);\n@@ -45,6 +37,7 @@ pub trait handler {\n     fn abort_if_errors(@mut self);\n     fn warn(@mut self, msg: &str);\n     fn note(@mut self, msg: &str);\n+    // used to indicate a bug in the compiler:\n     fn bug(@mut self, msg: &str) -> !;\n     fn unimpl(@mut self, msg: &str) -> !;\n     fn emit(@mut self,\n@@ -53,6 +46,19 @@ pub trait handler {\n             lvl: level);\n }\n \n+// a span-handler is like a handler but also\n+// accepts span information for source-location\n+// reporting.\n+pub trait span_handler {\n+    fn span_fatal(@mut self, sp: span, msg: &str) -> !;\n+    fn span_err(@mut self, sp: span, msg: &str);\n+    fn span_warn(@mut self, sp: span, msg: &str);\n+    fn span_note(@mut self, sp: span, msg: &str);\n+    fn span_bug(@mut self, sp: span, msg: &str) -> !;\n+    fn span_unimpl(@mut self, sp: span, msg: &str) -> !;\n+    fn handler(@mut self) -> handler;\n+}\n+\n struct HandlerT {\n     err_count: uint,\n     emit: Emitter,"}, {"sha": "4f64d7bed3124c98d025df54046dde747cb025da", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27b06777e6e2469cf4acee00b5702c5c7fb6d414/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b06777e6e2469cf4acee00b5702c5c7fb6d414/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=27b06777e6e2469cf4acee00b5702c5c7fb6d414", "patch": "@@ -18,6 +18,7 @@ use parse::token;\n \n use core::either::{Either, Left, Right};\n \n+// a parser that can parse attributes.\n pub trait parser_attr {\n     fn parse_outer_attributes() -> ~[ast::attribute];\n     fn parse_attribute(style: ast::attr_style) -> ast::attribute;\n@@ -81,6 +82,9 @@ impl parser_attr for Parser {\n     // attribute of the next item (since we can't know whether the attribute\n     // is an inner attribute of the containing item or an outer attribute of\n     // the first contained item until we see the semi).\n+\n+    // you can make the 'next' field an Option, but the result is going to be\n+    // more useful as a vector.\n     fn parse_inner_attrs_and_next() ->\n         (~[ast::attribute], ~[ast::attribute]) {\n         let mut inner_attrs: ~[ast::attribute] = ~[];"}, {"sha": "4f330ea86b0b654ed17ab55b8dfb464781257620", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/27b06777e6e2469cf4acee00b5702c5c7fb6d414/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b06777e6e2469cf4acee00b5702c5c7fb6d414/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=27b06777e6e2469cf4acee00b5702c5c7fb6d414", "patch": "@@ -74,11 +74,18 @@ pub fn new_parse_sess_special_handler(sh: span_handler, cm: @codemap::CodeMap)\n     }\n }\n \n+// a bunch of utility functions of the form parse_<thing>_from_<source>\n+// where <thing> includes crate, expr, item, stmt, tts, and one that\n+// uses a HOF to parse anything, and <source> includes file and\n+// source_str.\n+\n+// this appears to be the main entry point for rust parsing by\n+// rustc and crate:\n pub fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,\n                          sess: @mut ParseSess) -> @ast::crate {\n-    let p = new_crate_parser_from_file(sess, cfg, input);\n-    let r = p.parse_crate_mod(cfg);\n-    return r;\n+    let p = new_parser_from_file(sess, cfg, input);\n+    p.parse_crate_mod(cfg)\n+    // why is there no p.abort_if_errors here?\n }\n \n pub fn parse_crate_from_source_str(name: ~str,\n@@ -174,7 +181,9 @@ pub fn new_parser_from_source_str(sess: @mut ParseSess, cfg: ast::crate_cfg,\n     return Parser(sess, cfg, srdr as reader);\n }\n \n-pub fn new_parser_from_file(sess: @mut ParseSess,\n+// Read the entire source file, return a parser\n+// that draws from that string\n+pub fn new_parser_result_from_file(sess: @mut ParseSess,\n                             cfg: ast::crate_cfg,\n                             path: &Path)\n                          -> Result<Parser, ~str> {\n@@ -194,9 +203,9 @@ pub fn new_parser_from_file(sess: @mut ParseSess,\n \n /// Create a new parser for an entire crate, handling errors as appropriate\n /// if the file doesn't exist\n-pub fn new_crate_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n+pub fn new_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n                               path: &Path) -> Parser {\n-    match new_parser_from_file(sess, cfg, path) {\n+    match new_parser_result_from_file(sess, cfg, path) {\n         Ok(parser) => parser,\n         Err(e) => {\n             sess.span_diagnostic.handler().fatal(e)\n@@ -208,7 +217,7 @@ pub fn new_crate_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n /// error messages correctly when the file does not exist.\n pub fn new_sub_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n                             path: &Path, sp: span) -> Parser {\n-    match new_parser_from_file(sess, cfg, path) {\n+    match new_parser_result_from_file(sess, cfg, path) {\n         Ok(parser) => parser,\n         Err(e) => {\n             sess.span_diagnostic.span_fatal(sp, e)"}, {"sha": "ffc99b654a3fd3260079312817ae71a10f035767", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/27b06777e6e2469cf4acee00b5702c5c7fb6d414/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b06777e6e2469cf4acee00b5702c5c7fb6d414/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=27b06777e6e2469cf4acee00b5702c5c7fb6d414", "patch": "@@ -110,6 +110,7 @@ type arg_or_capture_item = Either<arg, ()>;\n type item_info = (ident, item_, Option<~[attribute]>);\n \n pub enum item_or_view_item {\n+    // indicates a failure to parse any kind of item:\n     iovi_none,\n     iovi_item(@item),\n     iovi_foreign_item(@foreign_item),\n@@ -2666,7 +2667,8 @@ pub impl Parser {\n                           _ => None\n                         }\n                       }\n-                      _ => fail!()\n+                      _ => self.bug(\n+                          ~\"is_ident() said this would be an identifier\")\n                     };\n \n                     match maybe_bound {\n@@ -3204,9 +3206,12 @@ pub impl Parser {\n         self.eat_keyword(~\"static\")\n     }\n \n+    // given a termination token and a vector of already-parsed\n+    // attributes (of length 0 or 1), parse all of the items in a module\n     fn parse_mod_items(term: token::Token,\n                        +first_item_attrs: ~[attribute]) -> _mod {\n-        // Shouldn't be any view items since we've already parsed an item attr\n+        // parse all of the items up to closing or an attribute.\n+        // view items are legal here.\n         let ParsedItemsAndViewItems {\n             attrs_remaining: attrs_remaining,\n             view_items: view_items,\n@@ -3217,6 +3222,9 @@ pub impl Parser {\n                                             true);\n         let mut items: ~[@item] = starting_items;\n \n+        // looks like this code depends on the invariant that\n+        // outer attributes can't occur on view items (or macros\n+        // invocations?)\n         let mut first = true;\n         while self.token != term {\n             let mut attrs = self.parse_outer_attributes();\n@@ -3751,6 +3759,8 @@ pub impl Parser {\n         }\n     }\n \n+    // parse one of the items or view items allowed by the\n+    // flags; on failure, return iovi_none.\n     fn parse_item_or_view_item(+attrs: ~[attribute], items_allowed: bool,\n                                foreign_items_allowed: bool,\n                                macros_allowed: bool)\n@@ -3770,14 +3780,17 @@ pub impl Parser {\n         }\n \n         if items_allowed && self.eat_keyword(~\"const\") {\n+            // CONST ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_const();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if foreign_items_allowed && self.is_keyword(~\"const\") {\n+            // FOREIGN CONST ITEM\n             let item = self.parse_item_foreign_const(visibility, attrs);\n             return iovi_foreign_item(item);\n         } else if items_allowed &&\n+            // FUNCTION ITEM (not sure about lookahead condition...)\n             self.is_keyword(~\"fn\") &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n             self.bump();\n@@ -3786,6 +3799,7 @@ pub impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if items_allowed && self.eat_keyword(~\"pure\") {\n+            // PURE FUNCTION ITEM\n             self.expect_keyword(~\"fn\");\n             let (ident, item_, extra_attrs) = self.parse_item_fn(pure_fn);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n@@ -3794,10 +3808,12 @@ pub impl Parser {\n         } else if foreign_items_allowed &&\n             (self.is_keyword(~\"fn\") || self.is_keyword(~\"pure\") ||\n              self.is_keyword(~\"unsafe\")) {\n+            // FOREIGN FUNCTION ITEM (no items allowed)\n                 let item = self.parse_item_foreign_fn(attrs);\n                 return iovi_foreign_item(item);\n         } else if items_allowed && self.is_keyword(~\"unsafe\")\n             && self.look_ahead(1u) != token::LBRACE {\n+            // UNSAFE FUNCTION ITEM (where items are allowed)\n             self.bump();\n             self.expect_keyword(~\"fn\");\n             let (ident, item_, extra_attrs) = self.parse_item_fn(unsafe_fn);\n@@ -3806,46 +3822,55 @@ pub impl Parser {\n                                           maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"extern\") {\n             if items_allowed && self.eat_keyword(~\"fn\") {\n+                // EXTERN FUNCTION ITEM\n                 let (ident, item_, extra_attrs) =\n                     self.parse_item_fn(extern_fn);\n                 return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n                                               item_, visibility,\n                                               maybe_append(attrs,\n                                                            extra_attrs)));\n             }\n+            // EXTERN MODULE ITEM\n             return self.parse_item_foreign_mod(lo, visibility, attrs,\n                                                items_allowed);\n         } else if items_allowed && self.eat_keyword(~\"mod\") {\n+            // MODULE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_mod(attrs);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if items_allowed && self.eat_keyword(~\"type\") {\n+            // TYPE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_type();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if items_allowed && self.eat_keyword(~\"enum\") {\n+            // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if items_allowed && self.eat_keyword(~\"trait\") {\n+            // TRAIT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if items_allowed && self.eat_keyword(~\"impl\") {\n+            // IMPL ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_impl();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if items_allowed && self.eat_keyword(~\"struct\") {\n+            // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"use\") {\n+            // USE ITEM\n             let view_item = self.parse_use();\n             self.expect(token::SEMI);\n             return iovi_view_item(@ast::view_item {\n@@ -3859,6 +3884,7 @@ pub impl Parser {\n                 && (is_plain_ident(self.look_ahead(2))\n                     || self.look_ahead(2) == token::LPAREN\n                     || self.look_ahead(2) == token::LBRACE) {\n+            // MACRO INVOCATION ITEM\n             if attrs.len() > 0 {\n                 self.fatal(~\"attrs on macros are not yet supported\");\n             }\n@@ -3875,6 +3901,7 @@ pub impl Parser {\n             } else {\n                 token::special_idents::invalid // no special identifier\n             };\n+            // eat a matched-delimiter token tree:\n             let tts = match self.token {\n               token::LPAREN | token::LBRACE => {\n                 let ket = token::flip_delimiter(copy self.token);\n@@ -3884,6 +3911,7 @@ pub impl Parser {\n               }\n               _ => self.fatal(~\"expected open delimiter\")\n             };\n+            // single-variant-enum... :\n             let m = ast::mac_invoc_tt(pth, tts);\n             let m: ast::mac = codemap::spanned { node: m,\n                                              span: mk_sp(self.span.lo,\n@@ -3892,6 +3920,7 @@ pub impl Parser {\n             return iovi_item(self.mk_item(lo, self.last_span.hi, id, item_,\n                                           visibility, attrs));\n         } else {\n+            // FAILURE TO PARSE ITEM\n             if visibility != inherited {\n                 let mut s = ~\"unmatched visibility `\";\n                 s += if visibility == public { ~\"pub\" } else { ~\"priv\" };\n@@ -4030,6 +4059,7 @@ pub impl Parser {\n                 self.token_is_keyword(~\"mod\", next_tok))\n     }\n \n+    // parse a view item.\n     fn parse_view_item(+attrs: ~[attribute], vis: visibility) -> @view_item {\n         let lo = self.span.lo;\n         let node = if self.eat_keyword(~\"use\") {\n@@ -4040,7 +4070,7 @@ pub impl Parser {\n             let metadata = self.parse_optional_meta();\n             view_item_extern_mod(ident, metadata, self.get_id())\n         } else {\n-            fail!();\n+            self.bug(~\"expected view item\");\n         };\n         self.expect(token::SEMI);\n         @ast::view_item { node: node,\n@@ -4049,6 +4079,8 @@ pub impl Parser {\n                           span: mk_sp(lo, self.last_span.hi) }\n     }\n \n+    // Parses a sequence of items. Stops when it finds program\n+    // text that can't be parsed as an item\n     fn parse_items_and_view_items(+first_item_attrs: ~[attribute],\n                                   mode: view_item_parse_mode,\n                                   macros_allowed: bool)\n@@ -4114,8 +4146,11 @@ pub impl Parser {\n     // Parses a source module as a crate\n     fn parse_crate_mod(_cfg: crate_cfg) -> @crate {\n         let lo = self.span.lo;\n+        // parse the crate's inner attrs, maybe (oops) one\n+        // of the attrs of an item:\n         let (inner, next) = self.parse_inner_attrs_and_next();\n         let first_item_outer_attrs = next;\n+        // parse the items inside the crate:\n         let m = self.parse_mod_items(token::EOF, first_item_outer_attrs);\n         @spanned(lo, self.span.lo,\n                  ast::crate_ { module: m,"}]}