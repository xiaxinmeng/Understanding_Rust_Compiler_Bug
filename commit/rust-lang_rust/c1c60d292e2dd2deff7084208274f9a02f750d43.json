{"sha": "c1c60d292e2dd2deff7084208274f9a02f750d43", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxYzYwZDI5MmUyZGQyZGVmZjcwODQyMDgyNzRmOWEwMmY3NTBkNDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-07T09:41:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-07T09:41:06Z"}, "message": "Auto merge of #61209 - matthewjasper:const-tuple-constructors, r=oli-obk\n\nMake tuple constructors real const fns\n\nMir construction special cases `Ctor(...)` to be lowered as `Ctor { 0: ... }`, which means this doesn't come up much in practice, but it seems inconsistent not to allow this.\n\nr? @oli-obk", "tree": {"sha": "314fbfbd0ef2dc81db3674186d122b582b6cc7a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/314fbfbd0ef2dc81db3674186d122b582b6cc7a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1c60d292e2dd2deff7084208274f9a02f750d43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1c60d292e2dd2deff7084208274f9a02f750d43", "html_url": "https://github.com/rust-lang/rust/commit/c1c60d292e2dd2deff7084208274f9a02f750d43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1c60d292e2dd2deff7084208274f9a02f750d43/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca1bcfdde3f19afd68ef808cecf2ce56d08d5df4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca1bcfdde3f19afd68ef808cecf2ce56d08d5df4", "html_url": "https://github.com/rust-lang/rust/commit/ca1bcfdde3f19afd68ef808cecf2ce56d08d5df4"}, {"sha": "bcf836567560c2f31dac79aa0379c0f0e2740081", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcf836567560c2f31dac79aa0379c0f0e2740081", "html_url": "https://github.com/rust-lang/rust/commit/bcf836567560c2f31dac79aa0379c0f0e2740081"}], "stats": {"total": 684, "additions": 516, "deletions": 168}, "files": [{"sha": "56f75e800f2557739c7661595668bebed4f018e1", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -2,35 +2,38 @@ use crate::ty::query::Providers;\n use crate::hir::def_id::DefId;\n use crate::hir;\n use crate::ty::TyCtxt;\n-use syntax_pos::symbol::Symbol;\n+use syntax_pos::symbol::{sym, Symbol};\n use crate::hir::map::blocks::FnLikeNode;\n use syntax::attr;\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// Whether the `def_id` counts as const fn in your current crate, considering all active\n     /// feature gates\n     pub fn is_const_fn(self, def_id: DefId) -> bool {\n-        self.is_const_fn_raw(def_id) && match self.lookup_stability(def_id) {\n-            Some(stab) => match stab.const_stability {\n+        self.is_const_fn_raw(def_id) && match self.is_unstable_const_fn(def_id) {\n+            Some(feature_name) => {\n                 // has a `rustc_const_unstable` attribute, check whether the user enabled the\n-                // corresponding feature gate\n-                Some(feature_name) => self.features()\n+                // corresponding feature gate, const_constructor is not a lib feature, so has\n+                // to be checked separately.\n+                self.features()\n                     .declared_lib_features\n                     .iter()\n-                    .any(|&(sym, _)| sym == feature_name),\n-                // the function has no stability attribute, it is stable as const fn or the user\n-                // needs to use feature gates to use the function at all\n-                None => true,\n+                    .any(|&(sym, _)| sym == feature_name)\n+                    || (feature_name == sym::const_constructor\n+                        && self.features().const_constructor)\n             },\n-            // functions without stability are either stable user written const fn or the user is\n-            // using feature gates and we thus don't care what they do\n+            // functions without const stability are either stable user written\n+            // const fn or the user is using feature gates and we thus don't\n+            // care what they do\n             None => true,\n         }\n     }\n \n     /// Whether the `def_id` is an unstable const fn and what feature gate is necessary to enable it\n     pub fn is_unstable_const_fn(self, def_id: DefId) -> Option<Symbol> {\n-        if self.is_const_fn_raw(def_id) {\n+        if self.is_constructor(def_id) {\n+            Some(sym::const_constructor)\n+        } else if self.is_const_fn_raw(def_id) {\n             self.lookup_stability(def_id)?.const_stability\n         } else {\n             None\n@@ -70,8 +73,11 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n         let hir_id = tcx.hir().as_local_hir_id(def_id)\n                               .expect(\"Non-local call to local provider is_const_fn\");\n \n-        if let Some(fn_like) = FnLikeNode::from_node(tcx.hir().get_by_hir_id(hir_id)) {\n+        let node = tcx.hir().get_by_hir_id(hir_id);\n+        if let Some(fn_like) = FnLikeNode::from_node(node) {\n             fn_like.constness() == hir::Constness::Const\n+        } else if let hir::Node::Ctor(_) = node {\n+            true\n         } else {\n             false\n         }"}, {"sha": "e3e327d0a5bd0920d487f4298f9e2771c372f210", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -1167,6 +1167,7 @@ impl<'a, 'tcx> CrateMetadata {\n         let constness = match self.entry(id).kind {\n             EntryKind::Method(data) => data.decode(self).fn_data.constness,\n             EntryKind::Fn(data) => data.decode(self).constness,\n+            EntryKind::Variant(..) | EntryKind::Struct(..) => hir::Constness::Const,\n             _ => hir::Constness::NotConst,\n         };\n         constness == hir::Constness::Const"}, {"sha": "74b2faa7a4ce8b160b36ed7c9d4616ebee9cf308", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -91,34 +91,6 @@ fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> BorrowC\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id));\n \n-    // We are not borrow checking the automatically generated struct/variant constructors\n-    // because we want to accept structs such as this (taken from the `linked-hash-map`\n-    // crate):\n-    // ```rust\n-    // struct Qey<Q: ?Sized>(Q);\n-    // ```\n-    // MIR of this struct constructor looks something like this:\n-    // ```rust\n-    // fn Qey(_1: Q) -> Qey<Q>{\n-    //     let mut _0: Qey<Q>;                  // return place\n-    //\n-    //     bb0: {\n-    //         (_0.0: Q) = move _1;             // bb0[0]: scope 0 at src/main.rs:1:1: 1:26\n-    //         return;                          // bb0[1]: scope 0 at src/main.rs:1:1: 1:26\n-    //     }\n-    // }\n-    // ```\n-    // The problem here is that `(_0.0: Q) = move _1;` is valid only if `Q` is\n-    // of statically known size, which is not known to be true because of the\n-    // `Q: ?Sized` constraint. However, it is true because the constructor can be\n-    // called only when `Q` is of statically known size.\n-    if tcx.is_constructor(def_id) {\n-        return BorrowCheckResult {\n-            closure_requirements: None,\n-            used_mut_upvars: SmallVec::new(),\n-        };\n-    }\n-\n     let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n         let input_mir: &Body<'_> = &input_mir.borrow();\n         do_mir_borrowck(&infcx, input_mir, def_id)"}, {"sha": "6bde349390ee8972c74bec1b7c093bfbb1fa0d81", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -2,7 +2,6 @@ use crate::build;\n use crate::build::scope::DropKind;\n use crate::hair::cx::Cx;\n use crate::hair::{LintLevel, BindingMode, PatternKind};\n-use crate::shim;\n use crate::transform::MirSource;\n use crate::util as mir_util;\n use rustc::hir;\n@@ -31,8 +30,6 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Body<'\n \n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span) = match tcx.hir().get_by_hir_id(id) {\n-        Node::Ctor(ctor) => return create_constructor_shim(tcx, id, ctor),\n-\n         Node::Expr(hir::Expr { node: hir::ExprKind::Closure(_, decl, body_id, _, _), .. })\n         | Node::Item(hir::Item { node: hir::ItemKind::Fn(decl, _, _, body_id), .. })\n         | Node::ImplItem(\n@@ -234,38 +231,6 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n     }\n }\n \n-fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     ctor_id: hir::HirId,\n-                                     v: &'tcx hir::VariantData)\n-                                     -> Body<'tcx>\n-{\n-    let span = tcx.hir().span_by_hir_id(ctor_id);\n-    if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n-        tcx.infer_ctxt().enter(|infcx| {\n-            let mut mir = shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n-\n-            // Convert the `mir::Body` to global types.\n-            let tcx = infcx.tcx.global_tcx();\n-            let mut globalizer = GlobalizeMir {\n-                tcx,\n-                span: mir.span\n-            };\n-            globalizer.visit_body(&mut mir);\n-            let mir = unsafe {\n-                mem::transmute::<Body<'_>, Body<'tcx>>(mir)\n-            };\n-\n-            mir_util::dump_mir(tcx, None, \"mir_map\", &0,\n-                               MirSource::item(tcx.hir().local_def_id_from_hir_id(ctor_id)),\n-                               &mir, |_, _| Ok(()) );\n-\n-            mir\n-        })\n-    } else {\n-        span_bug!(span, \"attempting to create MIR for non-tuple variant {:?}\", v);\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n "}, {"sha": "53302810b40525503892cf08502bdd83d24b5180", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -22,6 +22,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(unicode_internals)]\n #![feature(step_trait)]\n #![feature(slice_concat_ext)]\n+#![feature(trusted_len)]\n #![feature(try_blocks)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "169e426c1d3c63161b0f083db36f4a7b02432a7b", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 51, "deletions": 31, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -1,6 +1,5 @@\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::infer;\n use rustc::mir::*;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::VariantIdx;\n@@ -21,6 +20,7 @@ use crate::transform::{\n };\n use crate::util::elaborate_drops::{self, DropElaborator, DropStyle, DropFlagMode};\n use crate::util::patch::MirPatch;\n+use crate::util::expand_aggregate;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     providers.mir_shims = make_shim;\n@@ -842,29 +842,26 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir\n }\n \n-pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n-                                      ctor_id: hir::HirId,\n-                                      fields: &[hir::StructField],\n-                                      span: Span)\n-                                      -> Body<'tcx>\n-{\n-    let tcx = infcx.tcx;\n-    let gcx = tcx.global_tcx();\n-    let def_id = tcx.hir().local_def_id_from_hir_id(ctor_id);\n-    let param_env = gcx.param_env(def_id);\n+pub fn build_adt_ctor<'gcx>(tcx: TyCtxt<'_, 'gcx, 'gcx>, ctor_id: DefId) -> &'gcx Body<'gcx> {\n+    debug_assert!(tcx.is_constructor(ctor_id));\n+\n+    let span = tcx.hir().span_if_local(ctor_id)\n+        .unwrap_or_else(|| bug!(\"no span for ctor {:?}\", ctor_id));\n+\n+    let param_env = tcx.param_env(ctor_id);\n \n     // Normalize the sig.\n-    let sig = gcx.fn_sig(def_id)\n+    let sig = tcx.fn_sig(ctor_id)\n         .no_bound_vars()\n         .expect(\"LBR in ADT constructor signature\");\n-    let sig = gcx.normalize_erasing_regions(param_env, sig);\n+    let sig = tcx.normalize_erasing_regions(param_env, sig);\n \n     let (adt_def, substs) = match sig.output().sty {\n         ty::Adt(adt_def, substs) => (adt_def, substs),\n         _ => bug!(\"unexpected type for ADT ctor {:?}\", sig.output())\n     };\n \n-    debug!(\"build_ctor: def_id={:?} sig={:?} fields={:?}\", def_id, sig, fields);\n+    debug!(\"build_ctor: ctor_id={:?} sig={:?}\", ctor_id, sig);\n \n     let local_decls = local_decls_for_sig(&sig, span);\n \n@@ -873,34 +870,45 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         scope: OUTERMOST_SOURCE_SCOPE\n     };\n \n-    let variant_no = if adt_def.is_enum() {\n-        adt_def.variant_index_with_ctor_id(def_id)\n+    let variant_index = if adt_def.is_enum() {\n+        adt_def.variant_index_with_ctor_id(ctor_id)\n     } else {\n         VariantIdx::new(0)\n     };\n \n-    // return = ADT(arg0, arg1, ...); return\n+    // Generate the following MIR:\n+    //\n+    // (return as Variant).field0 = arg0;\n+    // (return as Variant).field1 = arg1;\n+    //\n+    // return;\n+    debug!(\"build_ctor: variant_index={:?}\", variant_index);\n+\n+    let statements = expand_aggregate(\n+        Place::RETURN_PLACE,\n+        adt_def\n+            .variants[variant_index]\n+            .fields\n+            .iter()\n+            .enumerate()\n+            .map(|(idx, field_def)| (\n+                Operand::Move(Place::Base(PlaceBase::Local(Local::new(idx + 1)))),\n+                field_def.ty(tcx, substs),\n+            )),\n+        AggregateKind::Adt(adt_def, variant_index, substs, None, None),\n+        source_info,\n+    ).collect();\n+\n     let start_block = BasicBlockData {\n-        statements: vec![Statement {\n-            source_info,\n-            kind: StatementKind::Assign(\n-                Place::RETURN_PLACE,\n-                box Rvalue::Aggregate(\n-                    box AggregateKind::Adt(adt_def, variant_no, substs, None, None),\n-                    (1..sig.inputs().len()+1).map(|i| {\n-                        Operand::Move(Place::Base(PlaceBase::Local(Local::new(i))))\n-                    }).collect()\n-                )\n-            )\n-        }],\n+        statements,\n         terminator: Some(Terminator {\n             source_info,\n             kind: TerminatorKind::Return,\n         }),\n         is_cleanup: false\n     };\n \n-    Body::new(\n+    let body = Body::new(\n         IndexVec::from_elem_n(start_block, 1),\n         IndexVec::from_elem_n(\n             SourceScopeData { span: span, parent_scope: None }, 1\n@@ -914,5 +922,17 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         vec![],\n         span,\n         vec![],\n-    )\n+    );\n+\n+    crate::util::dump_mir(\n+        tcx,\n+        None,\n+        \"mir_map\",\n+        &0,\n+        crate::transform::MirSource::item(ctor_id),\n+        &body,\n+        |_, _| Ok(()),\n+    );\n+\n+    tcx.arena.alloc(body)\n }"}, {"sha": "286c412622dd5db25666f237695a7365d5921a1e", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 10, "deletions": 58, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -1,8 +1,7 @@\n use rustc::mir::*;\n use rustc::ty::TyCtxt;\n-use rustc::ty::layout::VariantIdx;\n-use rustc_data_structures::indexed_vec::Idx;\n use crate::transform::{MirPass, MirSource};\n+use crate::util::expand_aggregate;\n \n pub struct Deaggregator;\n \n@@ -31,7 +30,7 @@ impl MirPass for Deaggregator {\n \n                 let stmt = stmt.replace_nop();\n                 let source_info = stmt.source_info;\n-                let (mut lhs, kind, operands) = match stmt.kind {\n+                let (lhs, kind, operands) = match stmt.kind {\n                     StatementKind::Assign(lhs, box rvalue) => {\n                         match rvalue {\n                             Rvalue::Aggregate(kind, operands) => (lhs, kind, operands),\n@@ -41,62 +40,15 @@ impl MirPass for Deaggregator {\n                     _ => bug!()\n                 };\n \n-                let mut set_discriminant = None;\n-                let active_field_index = match *kind {\n-                    AggregateKind::Adt(adt_def, variant_index, _, _, active_field_index) => {\n-                        if adt_def.is_enum() {\n-                            set_discriminant = Some(Statement {\n-                                kind: StatementKind::SetDiscriminant {\n-                                    place: lhs.clone(),\n-                                    variant_index,\n-                                },\n-                                source_info,\n-                            });\n-                            lhs = lhs.downcast(adt_def, variant_index);\n-                        }\n-                        active_field_index\n-                    }\n-                    AggregateKind::Generator(..) => {\n-                        // Right now we only support initializing generators to\n-                        // variant 0 (Unresumed).\n-                        let variant_index = VariantIdx::new(0);\n-                        set_discriminant = Some(Statement {\n-                            kind: StatementKind::SetDiscriminant {\n-                                place: lhs.clone(),\n-                                variant_index,\n-                            },\n-                            source_info,\n-                        });\n-\n-                        // Operands are upvars stored on the base place, so no\n-                        // downcast is necessary.\n-\n-                        None\n-                    }\n-                    _ => None\n-                };\n-\n-                Some(operands.into_iter().enumerate().map(move |(i, op)| {\n-                    let lhs_field = if let AggregateKind::Array(_) = *kind {\n-                        // FIXME(eddyb) `offset` should be u64.\n-                        let offset = i as u32;\n-                        assert_eq!(offset as usize, i);\n-                        lhs.clone().elem(ProjectionElem::ConstantIndex {\n-                            offset,\n-                            // FIXME(eddyb) `min_length` doesn't appear to be used.\n-                            min_length: offset + 1,\n-                            from_end: false\n-                        })\n-                    } else {\n+                Some(expand_aggregate(\n+                    lhs,\n+                    operands.into_iter().map(|op| {\n                         let ty = op.ty(local_decls, tcx);\n-                        let field = Field::new(active_field_index.unwrap_or(i));\n-                        lhs.clone().field(field, ty)\n-                    };\n-                    Statement {\n-                        source_info,\n-                        kind: StatementKind::Assign(lhs_field, box Rvalue::Use(op)),\n-                    }\n-                }).chain(set_discriminant))\n+                        (op, ty)\n+                    }),\n+                    *kind,\n+                    source_info,\n+                ))\n             });\n         }\n     }"}, {"sha": "cc8aaa1c97fb398d0f10876b37887c35efa07538", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -1,4 +1,4 @@\n-use crate::build;\n+use crate::{build, shim};\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::mir::{Body, MirPhase, Promoted};\n use rustc::ty::{TyCtxt, InstanceDef};\n@@ -228,7 +228,15 @@ fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n }\n \n fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Body<'tcx> {\n-    // `mir_borrowck` uses `mir_validated`, so we have to force it to\n+    if tcx.is_constructor(def_id) {\n+        // There's no reason to run all of the MIR passes on constructors when\n+        // we can just output the MIR we want directly. This also saves const\n+        // qualification and borrow checking the trouble of special casing\n+        // constructors.\n+        return shim::build_adt_ctor(tcx, def_id);\n+    }\n+\n+    // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n     // execute before we can steal.\n     tcx.ensure().mir_borrowck(def_id);\n "}, {"sha": "98e70671ab71562bfc1a0007eba8fdf58eacc9b6", "filename": "src/librustc_mir/util/aggregate.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Futil%2Faggregate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Futil%2Faggregate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Faggregate.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -0,0 +1,76 @@\n+use rustc::mir::*;\n+use rustc::ty::Ty;\n+use rustc::ty::layout::VariantIdx;\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use std::iter::TrustedLen;\n+\n+/// Expand `lhs = Rvalue::Aggregate(kind, operands)` into assignments to the fields.\n+///\n+/// Produces something like\n+///\n+/// (lhs as Variant).field0 = arg0;     // We only have a downcast if this is an enum\n+/// (lhs as Variant).field1 = arg1;\n+/// discriminant(lhs) = variant_index;  // If lhs is an enum or generator.\n+pub fn expand_aggregate<'tcx>(\n+    mut lhs: Place<'tcx>,\n+    operands: impl Iterator<Item=(Operand<'tcx>, Ty<'tcx>)> + TrustedLen,\n+    kind: AggregateKind<'tcx>,\n+    source_info: SourceInfo,\n+) -> impl Iterator<Item=Statement<'tcx>> + TrustedLen {\n+    let mut set_discriminant = None;\n+    let active_field_index = match kind {\n+        AggregateKind::Adt(adt_def, variant_index, _, _, active_field_index) => {\n+            if adt_def.is_enum() {\n+                set_discriminant = Some(Statement {\n+                    kind: StatementKind::SetDiscriminant {\n+                        place: lhs.clone(),\n+                        variant_index,\n+                    },\n+                    source_info,\n+                });\n+                lhs = lhs.downcast(adt_def, variant_index);\n+            }\n+            active_field_index\n+        }\n+        AggregateKind::Generator(..) => {\n+            // Right now we only support initializing generators to\n+            // variant 0 (Unresumed).\n+            let variant_index = VariantIdx::new(0);\n+            set_discriminant = Some(Statement {\n+                kind: StatementKind::SetDiscriminant {\n+                    place: lhs.clone(),\n+                    variant_index,\n+                },\n+                source_info,\n+            });\n+\n+            // Operands are upvars stored on the base place, so no\n+            // downcast is necessary.\n+\n+            None\n+        }\n+        _ => None\n+    };\n+\n+    operands.into_iter().enumerate().map(move |(i, (op, ty))| {\n+        let lhs_field = if let AggregateKind::Array(_) = kind {\n+            // FIXME(eddyb) `offset` should be u64.\n+            let offset = i as u32;\n+            assert_eq!(offset as usize, i);\n+            lhs.clone().elem(ProjectionElem::ConstantIndex {\n+                offset,\n+                // FIXME(eddyb) `min_length` doesn't appear to be used.\n+                min_length: offset + 1,\n+                from_end: false\n+            })\n+        } else {\n+            let field = Field::new(active_field_index.unwrap_or(i));\n+            lhs.clone().field(field, ty)\n+        };\n+        Statement {\n+            source_info,\n+            kind: StatementKind::Assign(lhs_field, box Rvalue::Use(op)),\n+        }\n+    }).chain(set_discriminant)\n+}"}, {"sha": "e340029434d815416e4b667de3beb1b2dc4aebbb", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -2,6 +2,7 @@ use core::unicode::property::Pattern_White_Space;\n use rustc::ty::TyCtxt;\n use syntax_pos::Span;\n \n+pub mod aggregate;\n pub mod borrowck_errors;\n pub mod elaborate_drops;\n pub mod def_use;\n@@ -13,6 +14,7 @@ pub(crate) mod pretty;\n pub mod liveness;\n pub mod collect_writes;\n \n+pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;\n pub use self::pretty::{dump_enabled, dump_mir, write_mir_pretty, PassWhere};\n pub use self::graphviz::{graphviz_safe_def_name, write_mir_graphviz};"}, {"sha": "b41b91c7631f5b300bba7f61b6133135c5a60379", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -560,6 +560,10 @@ declare_features! (\n     // Allows the user of associated type bounds.\n     (active, associated_type_bounds, \"1.34.0\", Some(52662), None),\n \n+    // Allows calling constructor functions in `const fn`\n+    // FIXME Create issue\n+    (active, const_constructor, \"1.37.0\", Some(61456), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "49123e4cc30c29e6a7388415139555eb2373d0d9", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -185,6 +185,7 @@ symbols! {\n         conservative_impl_trait,\n         console,\n         const_compare_raw_pointers,\n+        const_constructor,\n         const_fn,\n         const_fn_union,\n         const_generics,"}, {"sha": "f4d848dfc7ad12084dcf1ddee976683794cc7a8f", "filename": "src/test/mir-opt/unusual-item-types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -78,7 +78,8 @@ fn main() {\n //     let mut _0: Test;\n //\n //     bb0: {\n-//         _0 = Test::X(move _1,);\n+//         ((_0 as X).0: usize) = move _1;\n+//         discriminant(_0) = 0;\n //         return;\n //     }\n // }"}, {"sha": "f2d2bda53c05380d868cfb6118a15829b15485d6", "filename": "src/test/ui/consts/const_constructor/const-construct-call.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Ftest%2Fui%2Fconsts%2Fconst_constructor%2Fconst-construct-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Ftest%2Fui%2Fconsts%2Fconst_constructor%2Fconst-construct-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_constructor%2Fconst-construct-call.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -0,0 +1,116 @@\n+// Test that constructors are considered to be const fns with the required feature.\n+\n+// run-pass\n+\n+// revisions: min_const_fn const_fn\n+\n+#![cfg_attr(const_fn, feature(const_fn))]\n+\n+#![feature(const_constructor)]\n+\n+// Ctor(..) is transformed to Ctor { 0: ... } in HAIR lowering, so directly\n+// calling constructors doesn't require them to be const.\n+\n+type ExternalType = std::panic::AssertUnwindSafe<(Option<i32>, Result<i32, bool>)>;\n+\n+const fn call_external_constructors_in_local_vars() -> ExternalType {\n+    let f = Some;\n+    let g = Err;\n+    let h = std::panic::AssertUnwindSafe;\n+    let x = f(5);\n+    let y = g(false);\n+    let z = h((x, y));\n+    z\n+}\n+\n+const CALL_EXTERNAL_CONSTRUCTORS_IN_LOCAL_VARS: ExternalType = {\n+    let f = Some;\n+    let g = Err;\n+    let h = std::panic::AssertUnwindSafe;\n+    let x = f(5);\n+    let y = g(false);\n+    let z = h((x, y));\n+    z\n+};\n+\n+const fn call_external_constructors_in_temps() -> ExternalType {\n+    let x = { Some }(5);\n+    let y = (*&Err)(false);\n+    let z = [std::panic::AssertUnwindSafe][0]((x, y));\n+    z\n+}\n+\n+const CALL_EXTERNAL_CONSTRUCTORS_IN_TEMPS: ExternalType = {\n+    let x = { Some }(5);\n+    let y = (*&Err)(false);\n+    let z = [std::panic::AssertUnwindSafe][0]((x, y));\n+    z\n+};\n+\n+#[derive(Debug, PartialEq)]\n+enum LocalOption<T> {\n+    Some(T),\n+    _None,\n+}\n+\n+#[derive(Debug, PartialEq)]\n+enum LocalResult<T, E> {\n+    _Ok(T),\n+    Err(E),\n+}\n+\n+#[derive(Debug, PartialEq)]\n+struct LocalAssertUnwindSafe<T>(T);\n+\n+type LocalType = LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>;\n+\n+const fn call_local_constructors_in_local_vars() -> LocalType {\n+    let f = LocalOption::Some;\n+    let g = LocalResult::Err;\n+    let h = LocalAssertUnwindSafe;\n+    let x = f(5);\n+    let y = g(false);\n+    let z = h((x, y));\n+    z\n+}\n+\n+const CALL_LOCAL_CONSTRUCTORS_IN_LOCAL_VARS: LocalType = {\n+    let f = LocalOption::Some;\n+    let g = LocalResult::Err;\n+    let h = LocalAssertUnwindSafe;\n+    let x = f(5);\n+    let y = g(false);\n+    let z = h((x, y));\n+    z\n+};\n+\n+const fn call_local_constructors_in_temps() -> LocalType {\n+    let x = { LocalOption::Some }(5);\n+    let y = (*&LocalResult::Err)(false);\n+    let z = [LocalAssertUnwindSafe][0]((x, y));\n+    z\n+}\n+\n+const CALL_LOCAL_CONSTRUCTORS_IN_TEMPS: LocalType = {\n+    let x = { LocalOption::Some }(5);\n+    let y = (*&LocalResult::Err)(false);\n+    let z = [LocalAssertUnwindSafe][0]((x, y));\n+    z\n+};\n+\n+fn main() {\n+    assert_eq!(\n+        (\n+            call_external_constructors_in_local_vars().0,\n+            call_external_constructors_in_temps().0,\n+            call_local_constructors_in_local_vars(),\n+            call_local_constructors_in_temps(),\n+        ),\n+        (\n+            CALL_EXTERNAL_CONSTRUCTORS_IN_LOCAL_VARS.0,\n+            CALL_EXTERNAL_CONSTRUCTORS_IN_TEMPS.0,\n+            CALL_LOCAL_CONSTRUCTORS_IN_LOCAL_VARS,\n+            CALL_LOCAL_CONSTRUCTORS_IN_TEMPS,\n+        )\n+    );\n+}"}, {"sha": "fa4f83ed01e157ff62ee43b000cdc409cd1108f6", "filename": "src/test/ui/consts/const_constructor/feature-gate-const_constructor.const_fn.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Ftest%2Fui%2Fconsts%2Fconst_constructor%2Ffeature-gate-const_constructor.const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Ftest%2Fui%2Fconsts%2Fconst_constructor%2Ffeature-gate-const_constructor.const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_constructor%2Ffeature-gate-const_constructor.const_fn.stderr?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -0,0 +1,34 @@\n+error: `std::prelude::v1::Some` is not yet stable as a const fn\n+  --> $DIR/feature-gate-const_constructor.rs:9:37\n+   |\n+LL | const EXTERNAL_CONST: Option<i32> = {Some}(1);\n+   |                                     ^^^^^^^^^\n+   |\n+   = help: add `#![feature(const_constructor)]` to the crate attributes to enable\n+\n+error: `E::V` is not yet stable as a const fn\n+  --> $DIR/feature-gate-const_constructor.rs:12:24\n+   |\n+LL | const LOCAL_CONST: E = {E::V}(1);\n+   |                        ^^^^^^^^^\n+   |\n+   = help: add `#![feature(const_constructor)]` to the crate attributes to enable\n+\n+error: `std::prelude::v1::Some` is not yet stable as a const fn\n+  --> $DIR/feature-gate-const_constructor.rs:17:13\n+   |\n+LL |     let _ = {Some}(1);\n+   |             ^^^^^^^^^\n+   |\n+   = help: add `#![feature(const_constructor)]` to the crate attributes to enable\n+\n+error: `E::V` is not yet stable as a const fn\n+  --> $DIR/feature-gate-const_constructor.rs:23:13\n+   |\n+LL |     let _ = {E::V}(1);\n+   |             ^^^^^^^^^\n+   |\n+   = help: add `#![feature(const_constructor)]` to the crate attributes to enable\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "fa4f83ed01e157ff62ee43b000cdc409cd1108f6", "filename": "src/test/ui/consts/const_constructor/feature-gate-const_constructor.min_const_fn.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Ftest%2Fui%2Fconsts%2Fconst_constructor%2Ffeature-gate-const_constructor.min_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Ftest%2Fui%2Fconsts%2Fconst_constructor%2Ffeature-gate-const_constructor.min_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_constructor%2Ffeature-gate-const_constructor.min_const_fn.stderr?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -0,0 +1,34 @@\n+error: `std::prelude::v1::Some` is not yet stable as a const fn\n+  --> $DIR/feature-gate-const_constructor.rs:9:37\n+   |\n+LL | const EXTERNAL_CONST: Option<i32> = {Some}(1);\n+   |                                     ^^^^^^^^^\n+   |\n+   = help: add `#![feature(const_constructor)]` to the crate attributes to enable\n+\n+error: `E::V` is not yet stable as a const fn\n+  --> $DIR/feature-gate-const_constructor.rs:12:24\n+   |\n+LL | const LOCAL_CONST: E = {E::V}(1);\n+   |                        ^^^^^^^^^\n+   |\n+   = help: add `#![feature(const_constructor)]` to the crate attributes to enable\n+\n+error: `std::prelude::v1::Some` is not yet stable as a const fn\n+  --> $DIR/feature-gate-const_constructor.rs:17:13\n+   |\n+LL |     let _ = {Some}(1);\n+   |             ^^^^^^^^^\n+   |\n+   = help: add `#![feature(const_constructor)]` to the crate attributes to enable\n+\n+error: `E::V` is not yet stable as a const fn\n+  --> $DIR/feature-gate-const_constructor.rs:23:13\n+   |\n+LL |     let _ = {E::V}(1);\n+   |             ^^^^^^^^^\n+   |\n+   = help: add `#![feature(const_constructor)]` to the crate attributes to enable\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "b37fd2fd243d1318942e1fb5a2eb1f0af8f1c743", "filename": "src/test/ui/consts/const_constructor/feature-gate-const_constructor.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Ftest%2Fui%2Fconsts%2Fconst_constructor%2Ffeature-gate-const_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Ftest%2Fui%2Fconsts%2Fconst_constructor%2Ffeature-gate-const_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_constructor%2Ffeature-gate-const_constructor.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -0,0 +1,28 @@\n+// revisions: min_const_fn const_fn\n+\n+#![cfg_attr(const_fn, feature(const_fn))]\n+\n+enum E {\n+    V(i32),\n+}\n+\n+const EXTERNAL_CONST: Option<i32> = {Some}(1);\n+//[min_const_fn]~^ ERROR is not yet stable as a const fn\n+//[const_fn]~^^ ERROR is not yet stable as a const fn\n+const LOCAL_CONST: E = {E::V}(1);\n+//[min_const_fn]~^ ERROR is not yet stable as a const fn\n+//[const_fn]~^^ ERROR is not yet stable as a const fn\n+\n+const fn external_fn() {\n+    let _ = {Some}(1);\n+    //[min_const_fn]~^ ERROR is not yet stable as a const fn\n+    //[const_fn]~^^ ERROR is not yet stable as a const fn\n+}\n+\n+const fn local_fn() {\n+    let _ = {E::V}(1);\n+    //[min_const_fn]~^ ERROR is not yet stable as a const fn\n+    //[const_fn]~^^ ERROR is not yet stable as a const fn\n+}\n+\n+fn main() {}"}, {"sha": "116583223925a3c58085b1d8934ce23d20b405b0", "filename": "src/test/ui/nll/user-annotations/adt-tuple-struct-calls.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct-calls.rs?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -0,0 +1,71 @@\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+struct SomeStruct<T>(T);\n+\n+fn no_annot() {\n+    let c = 66;\n+    let f = SomeStruct;\n+    f(&c);\n+}\n+\n+fn annot_underscore() {\n+    let c = 66;\n+    let f = SomeStruct::<_>;\n+    f(&c);\n+}\n+\n+fn annot_reference_any_lifetime() {\n+    let c = 66;\n+    let f = SomeStruct::<&u32>;\n+    f(&c);\n+}\n+\n+fn annot_reference_static_lifetime() {\n+    let c = 66;\n+    let f = SomeStruct::<&'static u32>;\n+    f(&c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+    let c = 66;\n+    let f = SomeStruct::<&'a u32>;\n+    f(&c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime_ok<'a>(c: &'a u32) {\n+    let f = SomeStruct::<&'a u32>;\n+    f(c);\n+}\n+\n+fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+    let _closure = || {\n+        let c = 66;\n+        let f = SomeStruct::<&'a u32>;\n+        f(&c); //~ ERROR\n+    };\n+}\n+\n+fn annot_reference_named_lifetime_across_closure<'a>(_: &'a u32) {\n+    let f = SomeStruct::<&'a u32>;\n+    let _closure = || {\n+        let c = 66;\n+        f(&c); //~ ERROR\n+    };\n+}\n+\n+fn annot_reference_named_lifetime_in_closure_ok<'a>(c: &'a u32) {\n+    let _closure = || {\n+        let f = SomeStruct::<&'a u32>;\n+        f(c);\n+    };\n+}\n+\n+fn annot_reference_named_lifetime_across_closure_ok<'a>(c: &'a u32) {\n+    let f = SomeStruct::<&'a u32>;\n+    let _closure = || {\n+        f(c);\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "9664fb9f548317ea13151a99abb06665b64ab03b", "filename": "src/test/ui/nll/user-annotations/adt-tuple-struct-calls.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct-calls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60d292e2dd2deff7084208274f9a02f750d43/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct-calls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct-calls.stderr?ref=c1c60d292e2dd2deff7084208274f9a02f750d43", "patch": "@@ -0,0 +1,56 @@\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-tuple-struct-calls.rs:27:7\n+   |\n+LL |     f(&c);\n+   |     --^^-\n+   |     | |\n+   |     | borrowed value does not live long enough\n+   |     argument requires that `c` is borrowed for `'static`\n+LL | }\n+   | - `c` dropped here while still borrowed\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-tuple-struct-calls.rs:33:7\n+   |\n+LL | fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+   |                                   -- lifetime `'a` defined here\n+...\n+LL |     f(&c);\n+   |     --^^-\n+   |     | |\n+   |     | borrowed value does not live long enough\n+   |     argument requires that `c` is borrowed for `'a`\n+LL | }\n+   | - `c` dropped here while still borrowed\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-tuple-struct-calls.rs:45:11\n+   |\n+LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+   |                                              -- lifetime `'a` defined here\n+...\n+LL |         f(&c);\n+   |         --^^-\n+   |         | |\n+   |         | borrowed value does not live long enough\n+   |         argument requires that `c` is borrowed for `'a`\n+LL |     };\n+   |     - `c` dropped here while still borrowed\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-tuple-struct-calls.rs:53:11\n+   |\n+LL |     let f = SomeStruct::<&'a u32>;\n+   |         - lifetime `'1` appears in the type of `f`\n+...\n+LL |         f(&c);\n+   |         --^^-\n+   |         | |\n+   |         | borrowed value does not live long enough\n+   |         argument requires that `c` is borrowed for `'1`\n+LL |     };\n+   |     - `c` dropped here while still borrowed\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}]}