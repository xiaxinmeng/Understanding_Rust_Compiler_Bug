{"sha": "4c869a1b9d3b7b93dd5f5328466a105c18277d91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjODY5YTFiOWQzYjdiOTNkZDVmNTMyODQ2NmExMDVjMTgyNzdkOTE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-21T09:01:19Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-21T09:01:19Z"}, "message": "Extract out more files", "tree": {"sha": "3c856a2d15603b1e93f963966c54121df4fdad3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c856a2d15603b1e93f963966c54121df4fdad3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c869a1b9d3b7b93dd5f5328466a105c18277d91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c869a1b9d3b7b93dd5f5328466a105c18277d91", "html_url": "https://github.com/rust-lang/rust/commit/4c869a1b9d3b7b93dd5f5328466a105c18277d91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c869a1b9d3b7b93dd5f5328466a105c18277d91/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ca3dc063e51a985425adfa61571f26002b4a4d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ca3dc063e51a985425adfa61571f26002b4a4d2", "html_url": "https://github.com/rust-lang/rust/commit/8ca3dc063e51a985425adfa61571f26002b4a4d2"}], "stats": {"total": 1018, "additions": 554, "deletions": 464}, "files": [{"sha": "1da66c4e328a5d8c5222c81014ac41dfe5c7670d", "filename": "src/expr.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=4c869a1b9d3b7b93dd5f5328466a105c18277d91", "patch": "@@ -0,0 +1,149 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use visitor::FmtVisitor;\n+use utils::*;\n+use lists::{write_list, ListFormatting, SeparatorTactic, ListTactic};\n+\n+use syntax::{ast, ptr};\n+use syntax::codemap::{Span, Pos};\n+\n+use {MAX_WIDTH, MIN_STRING};\n+\n+impl<'a> FmtVisitor<'a> {\n+    // TODO NEEDS TESTS\n+    fn rewrite_string_lit(&mut self, s: &str, span: Span, width: usize, offset: usize) -> String {\n+        // FIXME I bet this stomps unicode escapes in the source string\n+\n+        // Check if there is anything to fix: we always try to fixup multi-line\n+        // strings, or if the string is too long for the line.\n+        let l_loc = self.codemap.lookup_char_pos(span.lo);\n+        let r_loc = self.codemap.lookup_char_pos(span.hi);\n+        if l_loc.line == r_loc.line && r_loc.col.to_usize() <= MAX_WIDTH {\n+            return self.snippet(span);\n+        }\n+\n+        // TODO if lo.col > IDEAL - 10, start a new line (need cur indent for that)\n+\n+        let s = s.escape_default();\n+\n+        let offset = offset + 1;\n+        let indent = make_indent(offset);\n+        let indent = &indent;\n+\n+        let max_chars = width - 1;\n+\n+        let mut cur_start = 0;\n+        let mut result = String::new();\n+        result.push('\"');\n+        loop {\n+            let mut cur_end = cur_start + max_chars;\n+\n+            if cur_end >= s.len() {\n+                result.push_str(&s[cur_start..]);\n+                break;\n+            }\n+\n+            // Make sure we're on a char boundary.\n+            cur_end = next_char(&s, cur_end);\n+\n+            // Push cur_end left until we reach whitespace\n+            while !s.char_at(cur_end-1).is_whitespace() {\n+                cur_end = prev_char(&s, cur_end);\n+\n+                if cur_end - cur_start < MIN_STRING {\n+                    // We can't break at whitespace, fall back to splitting\n+                    // anywhere that doesn't break an escape sequence\n+                    cur_end = next_char(&s, cur_start + max_chars);\n+                    while s.char_at(cur_end) == '\\\\' {\n+                        cur_end = prev_char(&s, cur_end);\n+                    }\n+                }\n+            }\n+            // Make sure there is no whitespace to the right of the break.\n+            while cur_end < s.len() && s.char_at(cur_end).is_whitespace() {\n+                cur_end = next_char(&s, cur_end+1);\n+            }\n+            result.push_str(&s[cur_start..cur_end]);\n+            result.push_str(\"\\\\\\n\");\n+            result.push_str(indent);\n+\n+            cur_start = cur_end;\n+        }\n+        result.push('\"');\n+\n+        result\n+    }\n+\n+    fn rewrite_call(&mut self,\n+                    callee: &ast::Expr,\n+                    args: &[ptr::P<ast::Expr>],\n+                    width: usize,\n+                    offset: usize)\n+        -> String\n+    {\n+        debug!(\"rewrite_call, width: {}, offset: {}\", width, offset);\n+\n+        // TODO using byte lens instead of char lens (and probably all over the place too)\n+        let callee_str = self.rewrite_expr(callee, width, offset);\n+        debug!(\"rewrite_call, callee_str: `{}`\", callee_str);\n+        // 2 is for parens.\n+        let remaining_width = width - callee_str.len() - 2;\n+        let offset = callee_str.len() + 1 + offset;\n+        let arg_count = args.len();\n+\n+        let args_str = if arg_count > 0 {\n+            let args: Vec<_> = args.iter().map(|e| (self.rewrite_expr(e,\n+                                                                      remaining_width,\n+                                                                      offset), String::new())).collect();\n+            // TODO move this into write_list\n+            let tactics = if args.iter().any(|&(ref s, _)| s.contains('\\n')) {\n+                ListTactic::Vertical\n+            } else {\n+                ListTactic::HorizontalVertical\n+            };\n+            let fmt = ListFormatting {\n+                tactic: tactics,\n+                separator: \",\",\n+                trailing_separator: SeparatorTactic::Never,\n+                indent: offset,\n+                h_width: remaining_width,\n+                v_width: remaining_width,\n+            };\n+            write_list(&args, &fmt)\n+        } else {\n+            String::new()\n+        };\n+\n+        format!(\"{}({})\", callee_str, args_str)\n+    }\n+\n+    pub fn rewrite_expr(&mut self, expr: &ast::Expr, width: usize, offset: usize) -> String {\n+        match expr.node {\n+            ast::Expr_::ExprLit(ref l) => {\n+                match l.node {\n+                    ast::Lit_::LitStr(ref is, _) => {\n+                        let result = self.rewrite_string_lit(&is, l.span, width, offset);\n+                        debug!(\"string lit: `{}`\", result);\n+                        return result;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            ast::Expr_::ExprCall(ref callee, ref args) => {\n+                return self.rewrite_call(callee, args, width, offset);\n+            }\n+            _ => {}\n+        }\n+\n+        let result = self.snippet(expr.span);\n+        result\n+    }\n+}"}, {"sha": "cf459931ba73941504afaae592d951b160e276f8", "filename": "src/functions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffunctions.rs?ref=4c869a1b9d3b7b93dd5f5328466a105c18277d91", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {FmtVisitor, ReturnIndent, make_indent, MAX_WIDTH, BraceStyle,\n+use {ReturnIndent, MAX_WIDTH, BraceStyle,\n      IDEAL_WIDTH, LEEWAY, FN_BRACE_STYLE, FN_RETURN_INDENT};\n+use utils::make_indent;\n use lists::{write_list, ListFormatting, SeparatorTactic, ListTactic};\n+use visitor::FmtVisitor;\n use syntax::{ast, abi};\n use syntax::print::pprust;\n use syntax::parse::token;"}, {"sha": "34cab06b2fc69d0acd8ccecd84976e070b17b1df", "filename": "src/imports.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=4c869a1b9d3b7b93dd5f5328466a105c18277d91", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use visitor::FmtVisitor;\n+use lists::{write_list, ListFormatting, SeparatorTactic, ListTactic};\n+\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+use syntax::print::pprust;\n+\n+use IDEAL_WIDTH;\n+\n+impl<'a> FmtVisitor<'a> {\n+    // Basically just pretty prints a multi-item import.\n+    pub fn rewrite_use_list(&mut self,\n+                        path: &ast::Path,\n+                        path_list: &[ast::PathListItem],\n+                        vp_span: Span) -> String {\n+        // FIXME remove unused imports\n+\n+        // FIXME check indentation\n+        let l_loc = self.codemap.lookup_char_pos(vp_span.lo);\n+\n+        let path_str = pprust::path_to_string(&path);\n+\n+        // 3 = :: + {\n+        let indent = l_loc.col.0 + path_str.len() + 3;\n+        let fmt = ListFormatting {\n+            tactic: ListTactic::Mixed,\n+            separator: \",\",\n+            trailing_separator: SeparatorTactic::Never,\n+            indent: indent,\n+            // 2 = } + ;\n+            h_width: IDEAL_WIDTH - (indent + path_str.len() + 2),\n+            v_width: IDEAL_WIDTH - (indent + path_str.len() + 2),\n+        };\n+\n+        // TODO handle any comments inbetween items.\n+        // If `self` is in the list, put it first.\n+        let head = if path_list.iter().any(|vpi|\n+            if let ast::PathListItem_::PathListMod{ .. } = vpi.node {\n+                true\n+            } else {\n+                false\n+            }\n+        ) {\n+            Some((\"self\".to_string(), String::new()))\n+        } else {\n+            None\n+        };\n+\n+        let items: Vec<_> = head.into_iter().chain(path_list.iter().filter_map(|vpi| {\n+            match vpi.node {\n+                ast::PathListItem_::PathListIdent{ name, .. } => {\n+                    Some((token::get_ident(name).to_string(), String::new()))\n+                }\n+                // Skip `self`, because we added it above.\n+                ast::PathListItem_::PathListMod{ .. } => None,\n+            }\n+        })).collect();\n+\n+        format!(\"use {}::{{{}}};\", path_str, write_list(&items, &fmt))\n+    }\n+}"}, {"sha": "0cfa592f03ef5a51a66944214eb47780ec9eb140", "filename": "src/lists.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=4c869a1b9d3b7b93dd5f5328466a105c18277d91", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use make_indent;\n+use utils::make_indent;\n \n #[derive(Eq, PartialEq, Debug, Copy, Clone)]\n pub enum ListTactic {"}, {"sha": "7b352dc8a04e5d73fb17e15953574aa08b17359e", "filename": "src/missed_spans.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=4c869a1b9d3b7b93dd5f5328466a105c18277d91", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {FmtVisitor, make_indent};\n+use utils::make_indent;\n+use visitor::FmtVisitor;\n+\n use syntax::codemap::{self, BytePos};\n \n impl<'a> FmtVisitor<'a> {"}, {"sha": "5c179dc910e77bf27e5b29514a85f84a076ffa3c", "filename": "src/mod.rs", "status": "modified", "additions": 8, "deletions": 461, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmod.rs?ref=4c869a1b9d3b7b93dd5f5328466a105c18277d91", "patch": "@@ -40,22 +40,25 @@ use rustc::session::Session;\n use rustc::session::config::{self, Input};\n use rustc_driver::{driver, CompilerCalls, Compilation};\n \n-use syntax::{ast, ptr};\n-use syntax::codemap::{CodeMap, Span, Pos, BytePos};\n+use syntax::ast;\n+use syntax::codemap::CodeMap;\n use syntax::diagnostics;\n-use syntax::parse::token;\n-use syntax::print::pprust;\n use syntax::visit;\n \n use std::path::PathBuf;\n \n use changes::ChangeSet;\n-use lists::{write_list, ListFormatting, SeparatorTactic, ListTactic};\n+use visitor::FmtVisitor;\n \n mod changes;\n+mod visitor;\n mod functions;\n mod missed_spans;\n mod lists;\n+mod utils;\n+mod types;\n+mod expr;\n+mod imports;\n \n const IDEAL_WIDTH: usize = 80;\n const LEEWAY: usize = 5;\n@@ -147,462 +150,6 @@ fn fmt_lines(changes: &mut ChangeSet) {\n     }\n }\n \n-struct FmtVisitor<'a> {\n-    codemap: &'a CodeMap,\n-    changes: ChangeSet<'a>,\n-    last_pos: BytePos,\n-    // TODO RAII util for indenting\n-    block_indent: usize,\n-}\n-\n-impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n-    fn visit_expr(&mut self, ex: &'v ast::Expr) {\n-        debug!(\"visit_expr: {:?} {:?}\",\n-               self.codemap.lookup_char_pos(ex.span.lo),\n-               self.codemap.lookup_char_pos(ex.span.hi));\n-        self.format_missing(ex.span.lo);\n-        let offset = self.changes.cur_offset_span(ex.span);\n-        let new_str = self.rewrite_expr(ex, MAX_WIDTH - offset, offset);\n-        self.changes.push_str_span(ex.span, &new_str);\n-        self.last_pos = ex.span.hi;\n-    }\n-\n-    fn visit_block(&mut self, b: &'v ast::Block) {\n-        debug!(\"visit_block: {:?} {:?}\",\n-               self.codemap.lookup_char_pos(b.span.lo),\n-               self.codemap.lookup_char_pos(b.span.hi));\n-        self.format_missing(b.span.lo);\n-\n-        self.changes.push_str_span(b.span, \"{\");\n-        self.last_pos = self.last_pos + BytePos(1);\n-        self.block_indent += TAB_SPACES;\n-\n-        for stmt in &b.stmts {\n-            self.format_missing_with_indent(stmt.span.lo);\n-            self.visit_stmt(&stmt)\n-        }\n-        match b.expr {\n-            Some(ref e) => {\n-                self.format_missing_with_indent(e.span.lo);\n-                self.visit_expr(e);\n-            }\n-            None => {}\n-        }\n-\n-        self.block_indent -= TAB_SPACES;\n-        // TODO we should compress any newlines here to just one\n-        self.format_missing_with_indent(b.span.hi - BytePos(1));\n-        self.changes.push_str_span(b.span, \"}\");\n-        self.last_pos = b.span.hi;\n-    }\n-\n-    // Note that this only gets called for function defintions. Required methods\n-    // on traits do not get handled here.\n-    fn visit_fn(&mut self,\n-                fk: visit::FnKind<'v>,\n-                fd: &'v ast::FnDecl,\n-                b: &'v ast::Block,\n-                s: Span,\n-                _: ast::NodeId) {\n-        self.format_missing(s.lo);\n-        self.last_pos = s.lo;\n-\n-        // TODO need to check against expected indent\n-        let indent = self.codemap.lookup_char_pos(s.lo).col.0;\n-        match fk {\n-            visit::FkItemFn(ident, ref generics, ref unsafety, ref abi, vis) => {\n-                let new_fn = self.rewrite_fn(indent,\n-                                             ident,\n-                                             fd,\n-                                             None,\n-                                             generics,\n-                                             unsafety,\n-                                             abi,\n-                                             vis);\n-                self.changes.push_str_span(s, &new_fn);\n-            }\n-            visit::FkMethod(ident, ref sig, vis) => {\n-                let new_fn = self.rewrite_fn(indent,\n-                                             ident,\n-                                             fd,\n-                                             Some(&sig.explicit_self),\n-                                             &sig.generics,\n-                                             &sig.unsafety,\n-                                             &sig.abi,\n-                                             vis.unwrap_or(ast::Visibility::Inherited));\n-                self.changes.push_str_span(s, &new_fn);\n-            }\n-            visit::FkFnBlock(..) => {}\n-        }\n-\n-        self.last_pos = b.span.lo;\n-        self.visit_block(b)\n-    }\n-\n-    fn visit_item(&mut self, item: &'v ast::Item) {\n-        match item.node {\n-            ast::Item_::ItemUse(ref vp) => {\n-                match vp.node {\n-                    ast::ViewPath_::ViewPathList(ref path, ref path_list) => {\n-                        self.format_missing(item.span.lo);\n-                        let new_str = self.rewrite_use_list(path, path_list, vp.span);\n-                        self.changes.push_str_span(item.span, &new_str);\n-                        self.last_pos = item.span.hi;\n-                    }\n-                    ast::ViewPath_::ViewPathGlob(_) => {\n-                        // FIXME convert to list?\n-                    }\n-                    _ => {}\n-                }\n-                visit::walk_item(self, item);\n-            }\n-            ast::Item_::ItemImpl(..) => {\n-                self.block_indent += TAB_SPACES;\n-                visit::walk_item(self, item);\n-                self.block_indent -= TAB_SPACES;\n-            }\n-            _ => {\n-                visit::walk_item(self, item);\n-            }\n-        }\n-    }\n-\n-    fn visit_mac(&mut self, mac: &'v ast::Mac) {\n-        visit::walk_mac(self, mac)\n-    }\n-\n-    fn visit_mod(&mut self, m: &'v ast::Mod, s: Span, _: ast::NodeId) {\n-        // Only visit inline mods here.\n-        if self.codemap.lookup_char_pos(s.lo).file.name !=\n-           self.codemap.lookup_char_pos(m.inner.lo).file.name {\n-            return;\n-        }\n-        visit::walk_mod(self, m);\n-    }\n-}\n-\n-impl<'a> FmtVisitor<'a> {\n-    fn from_codemap<'b>(codemap: &'b CodeMap) -> FmtVisitor<'b> {\n-        FmtVisitor {\n-            codemap: codemap,\n-            changes: ChangeSet::from_codemap(codemap),\n-            last_pos: BytePos(0),\n-            block_indent: 0,\n-        }\n-    }\n-\n-    fn snippet(&self, span: Span) -> String {\n-        match self.codemap.span_to_snippet(span) {\n-            Ok(s) => s,\n-            Err(_) => {\n-                println!(\"Couldn't make snippet for span {:?}->{:?}\",\n-                         self.codemap.lookup_char_pos(span.lo),\n-                         self.codemap.lookup_char_pos(span.hi));\n-                \"\".to_string()\n-            }\n-        }\n-    }\n-\n-    // TODO NEEDS TESTS\n-    fn rewrite_string_lit(&mut self, s: &str, span: Span, width: usize, offset: usize) -> String {\n-        // FIXME I bet this stomps unicode escapes in the source string\n-\n-        // Check if there is anything to fix: we always try to fixup multi-line\n-        // strings, or if the string is too long for the line.\n-        let l_loc = self.codemap.lookup_char_pos(span.lo);\n-        let r_loc = self.codemap.lookup_char_pos(span.hi);\n-        if l_loc.line == r_loc.line && r_loc.col.to_usize() <= MAX_WIDTH {\n-            return self.snippet(span);\n-        }\n-\n-        // TODO if lo.col > IDEAL - 10, start a new line (need cur indent for that)\n-\n-        let s = s.escape_default();\n-\n-        let offset = offset + 1;\n-        let indent = make_indent(offset);\n-        let indent = &indent;\n-\n-        let max_chars = width - 1;\n-\n-        let mut cur_start = 0;\n-        let mut result = String::new();\n-        result.push('\"');\n-        loop {\n-            let mut cur_end = cur_start + max_chars;\n-\n-            if cur_end >= s.len() {\n-                result.push_str(&s[cur_start..]);\n-                break;\n-            }\n-\n-            // Make sure we're on a char boundary.\n-            cur_end = next_char(&s, cur_end);\n-\n-            // Push cur_end left until we reach whitespace\n-            while !s.char_at(cur_end-1).is_whitespace() {\n-                cur_end = prev_char(&s, cur_end);\n-\n-                if cur_end - cur_start < MIN_STRING {\n-                    // We can't break at whitespace, fall back to splitting\n-                    // anywhere that doesn't break an escape sequence\n-                    cur_end = next_char(&s, cur_start + max_chars);\n-                    while s.char_at(cur_end) == '\\\\' {\n-                        cur_end = prev_char(&s, cur_end);\n-                    }\n-                }\n-            }\n-            // Make sure there is no whitespace to the right of the break.\n-            while cur_end < s.len() && s.char_at(cur_end).is_whitespace() {\n-                cur_end = next_char(&s, cur_end+1);\n-            }\n-            result.push_str(&s[cur_start..cur_end]);\n-            result.push_str(\"\\\\\\n\");\n-            result.push_str(indent);\n-\n-            cur_start = cur_end;\n-        }\n-        result.push('\"');\n-\n-        result\n-    }\n-\n-    // Basically just pretty prints a multi-item import.\n-    fn rewrite_use_list(&mut self,\n-                        path: &ast::Path,\n-                        path_list: &[ast::PathListItem],\n-                        vp_span: Span) -> String {\n-        // FIXME remove unused imports\n-\n-        // FIXME check indentation\n-        let l_loc = self.codemap.lookup_char_pos(vp_span.lo);\n-\n-        let path_str = pprust::path_to_string(&path);\n-\n-        // 3 = :: + {\n-        let indent = l_loc.col.0 + path_str.len() + 3;\n-        let fmt = ListFormatting {\n-            tactic: ListTactic::Mixed,\n-            separator: \",\",\n-            trailing_separator: SeparatorTactic::Never,\n-            indent: indent,\n-            // 2 = } + ;\n-            h_width: IDEAL_WIDTH - (indent + path_str.len() + 2),\n-            v_width: IDEAL_WIDTH - (indent + path_str.len() + 2),\n-        };\n-\n-        // TODO handle any comments inbetween items.\n-        // If `self` is in the list, put it first.\n-        let head = if path_list.iter().any(|vpi|\n-            if let ast::PathListItem_::PathListMod{ .. } = vpi.node {\n-                true\n-            } else {\n-                false\n-            }\n-        ) {\n-            Some((\"self\".to_string(), String::new()))\n-        } else {\n-            None\n-        };\n-\n-        let items: Vec<_> = head.into_iter().chain(path_list.iter().filter_map(|vpi| {\n-            match vpi.node {\n-                ast::PathListItem_::PathListIdent{ name, .. } => {\n-                    Some((token::get_ident(name).to_string(), String::new()))\n-                }\n-                // Skip `self`, because we added it above.\n-                ast::PathListItem_::PathListMod{ .. } => None,\n-            }\n-        })).collect();\n-\n-        format!(\"use {}::{{{}}};\", path_str, write_list(&items, &fmt))\n-    }\n-\n-\n-    fn rewrite_pred(&self, predicate: &ast::WherePredicate) -> String\n-    {\n-        // TODO dead spans\n-        // TODO assumes we'll always fit on one line...\n-        match predicate {\n-            &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bound_lifetimes,\n-                                                                          ref bounded_ty,\n-                                                                          ref bounds,\n-                                                                          ..}) => {\n-                if bound_lifetimes.len() > 0 {\n-                    format!(\"for<{}> {}: {}\",\n-                            bound_lifetimes.iter().map(|l| self.rewrite_lifetime_def(l)).collect::<Vec<_>>().connect(\", \"),\n-                            pprust::ty_to_string(bounded_ty),\n-                            bounds.iter().map(|b| self.rewrite_ty_bound(b)).collect::<Vec<_>>().connect(\"+\"))\n-\n-                } else {\n-                    format!(\"{}: {}\",\n-                            pprust::ty_to_string(bounded_ty),\n-                            bounds.iter().map(|b| self.rewrite_ty_bound(b)).collect::<Vec<_>>().connect(\"+\"))\n-                }\n-            }\n-            &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n-                                                                            ref bounds,\n-                                                                            ..}) => {\n-                format!(\"{}: {}\",\n-                        pprust::lifetime_to_string(lifetime),\n-                        bounds.iter().map(|l| pprust::lifetime_to_string(l)).collect::<Vec<_>>().connect(\"+\"))\n-            }\n-            &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n-                format!(\"{} = {}\", pprust::path_to_string(path), pprust::ty_to_string(ty))\n-            }\n-        }\n-    }\n-\n-    fn rewrite_lifetime_def(&self, lifetime: &ast::LifetimeDef) -> String\n-    {\n-        if lifetime.bounds.len() == 0 {\n-            return pprust::lifetime_to_string(&lifetime.lifetime);\n-        }\n-\n-        format!(\"{}: {}\",\n-                pprust::lifetime_to_string(&lifetime.lifetime),\n-                lifetime.bounds.iter().map(|l| pprust::lifetime_to_string(l)).collect::<Vec<_>>().connect(\"+\"))\n-    }\n-\n-    fn rewrite_ty_bound(&self, bound: &ast::TyParamBound) -> String\n-    {\n-        match *bound {\n-            ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::None) => {\n-                self.rewrite_poly_trait_ref(tref)\n-            }\n-            ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::Maybe) => {\n-                format!(\"?{}\", self.rewrite_poly_trait_ref(tref))\n-            }\n-            ast::TyParamBound::RegionTyParamBound(ref l) => {\n-                pprust::lifetime_to_string(l)\n-            }\n-        }\n-    }\n-\n-    fn rewrite_ty_param(&self, ty_param: &ast::TyParam) -> String\n-    {\n-        let mut result = String::with_capacity(128);\n-        result.push_str(&token::get_ident(ty_param.ident));\n-        if ty_param.bounds.len() > 0 {\n-            result.push_str(\": \");\n-            result.push_str(&ty_param.bounds.iter().map(|b| self.rewrite_ty_bound(b)).collect::<Vec<_>>().connect(\", \"));\n-        }\n-        if let Some(ref def) = ty_param.default {\n-            result.push_str(\" = \");\n-            result.push_str(&pprust::ty_to_string(&def));\n-        }\n-\n-        result\n-    }\n-\n-    fn rewrite_poly_trait_ref(&self, t: &ast::PolyTraitRef) -> String\n-    {\n-        if t.bound_lifetimes.len() > 0 {\n-            format!(\"for<{}> {}\",\n-                    t.bound_lifetimes.iter().map(|l| self.rewrite_lifetime_def(l)).collect::<Vec<_>>().connect(\", \"),\n-                    pprust::path_to_string(&t.trait_ref.path))\n-\n-        } else {\n-            pprust::path_to_string(&t.trait_ref.path)\n-        }\n-    }\n-\n-    fn rewrite_call(&mut self,\n-                    callee: &ast::Expr,\n-                    args: &[ptr::P<ast::Expr>],\n-                    width: usize,\n-                    offset: usize)\n-        -> String\n-    {\n-        debug!(\"rewrite_call, width: {}, offset: {}\", width, offset);\n-\n-        // TODO using byte lens instead of char lens (and probably all over the place too)\n-        let callee_str = self.rewrite_expr(callee, width, offset);\n-        debug!(\"rewrite_call, callee_str: `{}`\", callee_str);\n-        // 2 is for parens.\n-        let remaining_width = width - callee_str.len() - 2;\n-        let offset = callee_str.len() + 1 + offset;\n-        let arg_count = args.len();\n-\n-        let args_str = if arg_count > 0 {\n-            let args: Vec<_> = args.iter().map(|e| (self.rewrite_expr(e,\n-                                                                      remaining_width,\n-                                                                      offset), String::new())).collect();\n-            // TODO move this into write_list\n-            let tactics = if args.iter().any(|&(ref s, _)| s.contains('\\n')) {\n-                ListTactic::Vertical\n-            } else {\n-                ListTactic::HorizontalVertical\n-            };\n-            let fmt = ListFormatting {\n-                tactic: tactics,\n-                separator: \",\",\n-                trailing_separator: SeparatorTactic::Never,\n-                indent: offset,\n-                h_width: remaining_width,\n-                v_width: remaining_width,\n-            };\n-            write_list(&args, &fmt)\n-        } else {\n-            String::new()\n-        };\n-\n-        format!(\"{}({})\", callee_str, args_str)\n-    }\n-\n-    fn rewrite_expr(&mut self, expr: &ast::Expr, width: usize, offset: usize) -> String {\n-        match expr.node {\n-            ast::Expr_::ExprLit(ref l) => {\n-                match l.node {\n-                    ast::Lit_::LitStr(ref is, _) => {\n-                        let result = self.rewrite_string_lit(&is, l.span, width, offset);\n-                        debug!(\"string lit: `{}`\", result);\n-                        return result;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            ast::Expr_::ExprCall(ref callee, ref args) => {\n-                return self.rewrite_call(callee, args, width, offset);\n-            }\n-            _ => {}\n-        }\n-\n-        let result = self.snippet(expr.span);\n-        result\n-    }\n-}\n-\n-#[inline]\n-fn prev_char(s: &str, mut i: usize) -> usize {\n-    if i == 0 { return 0; }\n-\n-    i -= 1;\n-    while !s.is_char_boundary(i) {\n-        i -= 1;\n-    }\n-    i\n-}\n-\n-#[inline]\n-fn next_char(s: &str, mut i: usize) -> usize {\n-    if i >= s.len() { return s.len(); }\n-\n-    while !s.is_char_boundary(i) {\n-        i += 1;\n-    }\n-    i\n-}\n-\n-#[inline]\n-fn make_indent(width: usize) -> String {\n-    let mut indent = String::with_capacity(width);\n-    for _ in 0..width {\n-        indent.push(' ')\n-    }\n-    indent\n-}\n-\n struct RustFmtCalls {\n     input_path: Option<PathBuf>,\n }"}, {"sha": "839482f921ac19bc35a4f32bf5f1015c5d9151e5", "filename": "src/types.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=4c869a1b9d3b7b93dd5f5328466a105c18277d91", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use visitor::FmtVisitor;\n+\n+use syntax::ast;\n+use syntax::parse::token;\n+use syntax::print::pprust;\n+\n+impl<'a> FmtVisitor<'a> {\n+    pub fn rewrite_pred(&self, predicate: &ast::WherePredicate) -> String\n+    {\n+        // TODO dead spans\n+        // TODO assumes we'll always fit on one line...\n+        match predicate {\n+            &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bound_lifetimes,\n+                                                                          ref bounded_ty,\n+                                                                          ref bounds,\n+                                                                          ..}) => {\n+                if bound_lifetimes.len() > 0 {\n+                    format!(\"for<{}> {}: {}\",\n+                            bound_lifetimes.iter().map(|l| self.rewrite_lifetime_def(l)).collect::<Vec<_>>().connect(\", \"),\n+                            pprust::ty_to_string(bounded_ty),\n+                            bounds.iter().map(|b| self.rewrite_ty_bound(b)).collect::<Vec<_>>().connect(\"+\"))\n+\n+                } else {\n+                    format!(\"{}: {}\",\n+                            pprust::ty_to_string(bounded_ty),\n+                            bounds.iter().map(|b| self.rewrite_ty_bound(b)).collect::<Vec<_>>().connect(\"+\"))\n+                }\n+            }\n+            &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n+                                                                            ref bounds,\n+                                                                            ..}) => {\n+                format!(\"{}: {}\",\n+                        pprust::lifetime_to_string(lifetime),\n+                        bounds.iter().map(|l| pprust::lifetime_to_string(l)).collect::<Vec<_>>().connect(\"+\"))\n+            }\n+            &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n+                format!(\"{} = {}\", pprust::path_to_string(path), pprust::ty_to_string(ty))\n+            }\n+        }\n+    }\n+\n+    pub fn rewrite_lifetime_def(&self, lifetime: &ast::LifetimeDef) -> String\n+    {\n+        if lifetime.bounds.len() == 0 {\n+            return pprust::lifetime_to_string(&lifetime.lifetime);\n+        }\n+\n+        format!(\"{}: {}\",\n+                pprust::lifetime_to_string(&lifetime.lifetime),\n+                lifetime.bounds.iter().map(|l| pprust::lifetime_to_string(l)).collect::<Vec<_>>().connect(\"+\"))\n+    }\n+\n+    pub fn rewrite_ty_bound(&self, bound: &ast::TyParamBound) -> String\n+    {\n+        match *bound {\n+            ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::None) => {\n+                self.rewrite_poly_trait_ref(tref)\n+            }\n+            ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::Maybe) => {\n+                format!(\"?{}\", self.rewrite_poly_trait_ref(tref))\n+            }\n+            ast::TyParamBound::RegionTyParamBound(ref l) => {\n+                pprust::lifetime_to_string(l)\n+            }\n+        }\n+    }\n+\n+    pub fn rewrite_ty_param(&self, ty_param: &ast::TyParam) -> String\n+    {\n+        let mut result = String::with_capacity(128);\n+        result.push_str(&token::get_ident(ty_param.ident));\n+        if ty_param.bounds.len() > 0 {\n+            result.push_str(\": \");\n+            result.push_str(&ty_param.bounds.iter().map(|b| self.rewrite_ty_bound(b)).collect::<Vec<_>>().connect(\", \"));\n+        }\n+        if let Some(ref def) = ty_param.default {\n+            result.push_str(\" = \");\n+            result.push_str(&pprust::ty_to_string(&def));\n+        }\n+\n+        result\n+    }\n+\n+    fn rewrite_poly_trait_ref(&self, t: &ast::PolyTraitRef) -> String\n+    {\n+        if t.bound_lifetimes.len() > 0 {\n+            format!(\"for<{}> {}\",\n+                    t.bound_lifetimes.iter().map(|l| self.rewrite_lifetime_def(l)).collect::<Vec<_>>().connect(\", \"),\n+                    pprust::path_to_string(&t.trait_ref.path))\n+\n+        } else {\n+            pprust::path_to_string(&t.trait_ref.path)\n+        }\n+    }\n+}"}, {"sha": "c22b85f45638d09729c787c4f33be597aef51192", "filename": "src/utils.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=4c869a1b9d3b7b93dd5f5328466a105c18277d91", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#[inline]\n+pub fn prev_char(s: &str, mut i: usize) -> usize {\n+    if i == 0 { return 0; }\n+\n+    i -= 1;\n+    while !s.is_char_boundary(i) {\n+        i -= 1;\n+    }\n+    i\n+}\n+\n+#[inline]\n+pub fn next_char(s: &str, mut i: usize) -> usize {\n+    if i >= s.len() { return s.len(); }\n+\n+    while !s.is_char_boundary(i) {\n+        i += 1;\n+    }\n+    i\n+}\n+\n+#[inline]\n+pub fn make_indent(width: usize) -> String {\n+    let mut indent = String::with_capacity(width);\n+    for _ in 0..width {\n+        indent.push(' ')\n+    }\n+    indent\n+}"}, {"sha": "7e8a885c657d3dfd230ee090f4719a553435951c", "filename": "src/visitor.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c869a1b9d3b7b93dd5f5328466a105c18277d91/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=4c869a1b9d3b7b93dd5f5328466a105c18277d91", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast;\n+use syntax::codemap::{CodeMap, Span, BytePos};\n+use syntax::visit;\n+\n+use {MAX_WIDTH, TAB_SPACES};\n+use changes::ChangeSet;\n+\n+pub struct FmtVisitor<'a> {\n+    pub codemap: &'a CodeMap,\n+    pub changes: ChangeSet<'a>,\n+    pub last_pos: BytePos,\n+    // TODO RAII util for indenting\n+    pub block_indent: usize,\n+}\n+\n+impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n+    fn visit_expr(&mut self, ex: &'v ast::Expr) {\n+        debug!(\"visit_expr: {:?} {:?}\",\n+               self.codemap.lookup_char_pos(ex.span.lo),\n+               self.codemap.lookup_char_pos(ex.span.hi));\n+        self.format_missing(ex.span.lo);\n+        let offset = self.changes.cur_offset_span(ex.span);\n+        let new_str = self.rewrite_expr(ex, MAX_WIDTH - offset, offset);\n+        self.changes.push_str_span(ex.span, &new_str);\n+        self.last_pos = ex.span.hi;\n+    }\n+\n+    fn visit_block(&mut self, b: &'v ast::Block) {\n+        debug!(\"visit_block: {:?} {:?}\",\n+               self.codemap.lookup_char_pos(b.span.lo),\n+               self.codemap.lookup_char_pos(b.span.hi));\n+        self.format_missing(b.span.lo);\n+\n+        self.changes.push_str_span(b.span, \"{\");\n+        self.last_pos = self.last_pos + BytePos(1);\n+        self.block_indent += TAB_SPACES;\n+\n+        for stmt in &b.stmts {\n+            self.format_missing_with_indent(stmt.span.lo);\n+            self.visit_stmt(&stmt)\n+        }\n+        match b.expr {\n+            Some(ref e) => {\n+                self.format_missing_with_indent(e.span.lo);\n+                self.visit_expr(e);\n+            }\n+            None => {}\n+        }\n+\n+        self.block_indent -= TAB_SPACES;\n+        // TODO we should compress any newlines here to just one\n+        self.format_missing_with_indent(b.span.hi - BytePos(1));\n+        self.changes.push_str_span(b.span, \"}\");\n+        self.last_pos = b.span.hi;\n+    }\n+\n+    // Note that this only gets called for function defintions. Required methods\n+    // on traits do not get handled here.\n+    fn visit_fn(&mut self,\n+                fk: visit::FnKind<'v>,\n+                fd: &'v ast::FnDecl,\n+                b: &'v ast::Block,\n+                s: Span,\n+                _: ast::NodeId) {\n+        self.format_missing(s.lo);\n+        self.last_pos = s.lo;\n+\n+        // TODO need to check against expected indent\n+        let indent = self.codemap.lookup_char_pos(s.lo).col.0;\n+        match fk {\n+            visit::FkItemFn(ident, ref generics, ref unsafety, ref abi, vis) => {\n+                let new_fn = self.rewrite_fn(indent,\n+                                             ident,\n+                                             fd,\n+                                             None,\n+                                             generics,\n+                                             unsafety,\n+                                             abi,\n+                                             vis);\n+                self.changes.push_str_span(s, &new_fn);\n+            }\n+            visit::FkMethod(ident, ref sig, vis) => {\n+                let new_fn = self.rewrite_fn(indent,\n+                                             ident,\n+                                             fd,\n+                                             Some(&sig.explicit_self),\n+                                             &sig.generics,\n+                                             &sig.unsafety,\n+                                             &sig.abi,\n+                                             vis.unwrap_or(ast::Visibility::Inherited));\n+                self.changes.push_str_span(s, &new_fn);\n+            }\n+            visit::FkFnBlock(..) => {}\n+        }\n+\n+        self.last_pos = b.span.lo;\n+        self.visit_block(b)\n+    }\n+\n+    fn visit_item(&mut self, item: &'v ast::Item) {\n+        match item.node {\n+            ast::Item_::ItemUse(ref vp) => {\n+                match vp.node {\n+                    ast::ViewPath_::ViewPathList(ref path, ref path_list) => {\n+                        self.format_missing(item.span.lo);\n+                        let new_str = self.rewrite_use_list(path, path_list, vp.span);\n+                        self.changes.push_str_span(item.span, &new_str);\n+                        self.last_pos = item.span.hi;\n+                    }\n+                    ast::ViewPath_::ViewPathGlob(_) => {\n+                        // FIXME convert to list?\n+                    }\n+                    _ => {}\n+                }\n+                visit::walk_item(self, item);\n+            }\n+            ast::Item_::ItemImpl(..) => {\n+                self.block_indent += TAB_SPACES;\n+                visit::walk_item(self, item);\n+                self.block_indent -= TAB_SPACES;\n+            }\n+            _ => {\n+                visit::walk_item(self, item);\n+            }\n+        }\n+    }\n+\n+    fn visit_mac(&mut self, mac: &'v ast::Mac) {\n+        visit::walk_mac(self, mac)\n+    }\n+\n+    fn visit_mod(&mut self, m: &'v ast::Mod, s: Span, _: ast::NodeId) {\n+        // Only visit inline mods here.\n+        if self.codemap.lookup_char_pos(s.lo).file.name !=\n+           self.codemap.lookup_char_pos(m.inner.lo).file.name {\n+            return;\n+        }\n+        visit::walk_mod(self, m);\n+    }\n+}\n+\n+impl<'a> FmtVisitor<'a> {\n+    pub fn from_codemap<'b>(codemap: &'b CodeMap) -> FmtVisitor<'b> {\n+        FmtVisitor {\n+            codemap: codemap,\n+            changes: ChangeSet::from_codemap(codemap),\n+            last_pos: BytePos(0),\n+            block_indent: 0,\n+        }\n+    }\n+\n+    pub fn snippet(&self, span: Span) -> String {\n+        match self.codemap.span_to_snippet(span) {\n+            Ok(s) => s,\n+            Err(_) => {\n+                println!(\"Couldn't make snippet for span {:?}->{:?}\",\n+                         self.codemap.lookup_char_pos(span.lo),\n+                         self.codemap.lookup_char_pos(span.hi));\n+                \"\".to_string()\n+            }\n+        }\n+    }\n+}"}]}