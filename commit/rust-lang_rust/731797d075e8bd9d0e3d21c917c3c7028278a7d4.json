{"sha": "731797d075e8bd9d0e3d21c917c3c7028278a7d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMTc5N2QwNzVlOGJkOWQwZTNkMjFjOTE3YzNjNzAyODI3OGE3ZDQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-08-03T00:21:28Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-08-03T00:36:41Z"}, "message": " In trans, don't assume both sides of a binop have the same type\n\n    This was at least partially responsible for Issue 777.\n\n    The only solution I can think of is for trans to just not generate\n    code for a comparison if one or both sides has type _|_. Since\n    that means evaluating that subexpression diverges, it should be ok\n    to never do the comparison. Actually generating code for the\n    comparison would trip an LLVM assertion failure.", "tree": {"sha": "d63414cf252d8398f7b6b8423ee1c16fb026d4cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d63414cf252d8398f7b6b8423ee1c16fb026d4cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/731797d075e8bd9d0e3d21c917c3c7028278a7d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/731797d075e8bd9d0e3d21c917c3c7028278a7d4", "html_url": "https://github.com/rust-lang/rust/commit/731797d075e8bd9d0e3d21c917c3c7028278a7d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/731797d075e8bd9d0e3d21c917c3c7028278a7d4/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "430a28bb495fc5702970eacbd8427d965502775e", "url": "https://api.github.com/repos/rust-lang/rust/commits/430a28bb495fc5702970eacbd8427d965502775e", "html_url": "https://github.com/rust-lang/rust/commit/430a28bb495fc5702970eacbd8427d965502775e"}], "stats": {"total": 67, "additions": 49, "deletions": 18}, "files": [{"sha": "3a25b84e8d209613892911b5b2186f7edafd9435", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/731797d075e8bd9d0e3d21c917c3c7028278a7d4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/731797d075e8bd9d0e3d21c917c3c7028278a7d4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=731797d075e8bd9d0e3d21c917c3c7028278a7d4", "patch": "@@ -1707,7 +1707,7 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n         }\n       }\n       ty::ty_type. {\n-        trans_fail(cx, none[span], \"attempt to compare values of type type\");\n+        trans_fail(cx, none, \"attempt to compare values of type type\");\n \n         // This is a bit lame, because we return a dummy block to the\n         // caller that's actually unreachable, but I don't think it\n@@ -2702,15 +2702,18 @@ fn trans_unary(cx: &@block_ctxt, op: ast::unop, e: &@ast::expr,\n     }\n }\n \n-fn trans_compare(cx0: &@block_ctxt, op: ast::binop, t0: &ty::t,\n-                 lhs0: ValueRef, rhs0: ValueRef) -> result {\n+// Important to get types for both lhs and rhs, because one might be _|_\n+// and the other not.\n+fn trans_compare(cx0: &@block_ctxt, op: ast::binop,\n+                 lhs0: ValueRef, lhs_t: ty::t, rhs0: ValueRef,\n+                rhs_t: ty::t) -> result {\n     // Autoderef both sides.\n \n     let cx = cx0;\n-    let lhs_r = autoderef(cx, lhs0, t0);\n+    let lhs_r = autoderef(cx, lhs0, lhs_t);\n     let lhs = lhs_r.val;\n     cx = lhs_r.bcx;\n-    let rhs_r = autoderef(cx, rhs0, t0);\n+    let rhs_r = autoderef(cx, rhs0, rhs_t);\n     let rhs = rhs_r.val;\n     cx = rhs_r.bcx;\n     // Determine the operation we need.\n@@ -2721,15 +2724,23 @@ fn trans_compare(cx0: &@block_ctxt, op: ast::binop, t0: &ty::t,\n       ast::lt. | ast::ge. { llop = C_u8(abi::cmp_glue_op_lt); }\n       ast::le. | ast::gt. { llop = C_u8(abi::cmp_glue_op_le); }\n     }\n-    let rs = compare(cx, lhs, rhs, rhs_r.ty, llop);\n \n+    if (! ty::type_is_bot(bcx_tcx(cx0), rhs_r.ty) &&\n+        ! ty::type_is_bot(bcx_tcx(cx0), lhs_r.ty)) {\n+        let rs = compare(cx, lhs, rhs, rhs_r.ty, llop);\n \n-    // Invert the result if necessary.\n-    alt op {\n-      ast::eq. | ast::lt. | ast::le. { ret rslt(rs.bcx, rs.val); }\n-      ast::ne. | ast::ge. | ast::gt. {\n-        ret rslt(rs.bcx, rs.bcx.build.Not(rs.val));\n-      }\n+        // Invert the result if necessary.\n+        alt op {\n+          ast::eq. | ast::lt. | ast::le. { ret rslt(rs.bcx, rs.val); }\n+          ast::ne. | ast::ge. | ast::gt. {\n+            ret rslt(rs.bcx, rs.bcx.build.Not(rs.val));\n+          }\n+        }\n+    }\n+    else {\n+        // If either is bottom, it diverges. So no need to do the\n+        // actual comparison.\n+        ret rslt(cx, cx.build.Unreachable());\n     }\n }\n \n@@ -3372,9 +3383,16 @@ fn trans_vec_add(cx: &@block_ctxt, t: &ty::t, lhs: ValueRef, rhs: ValueRef) ->\n     ret rslt(bcx, tmp);\n }\n \n-fn trans_eager_binop(cx: &@block_ctxt, op: ast::binop, intype: &ty::t,\n-                     lhs: ValueRef, rhs: ValueRef) -> result {\n+// Important to get types for both lhs and rhs, because one might be _|_\n+// and the other not.\n+fn trans_eager_binop(cx: &@block_ctxt, op: ast::binop, lhs: ValueRef,\n+                     lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t) -> result {\n     let is_float = false;\n+    let intype = lhs_t;\n+    if ty::type_is_bot(bcx_tcx(cx), intype) {\n+        intype = rhs_t;\n+    }\n+\n     alt ty::struct(bcx_tcx(cx), intype) {\n       ty::ty_float. { is_float = true; }\n       _ { is_float = false; }\n@@ -3419,7 +3437,7 @@ fn trans_eager_binop(cx: &@block_ctxt, op: ast::binop, intype: &ty::t,\n       ast::lsl. { ret rslt(cx, cx.build.Shl(lhs, rhs)); }\n       ast::lsr. { ret rslt(cx, cx.build.LShr(lhs, rhs)); }\n       ast::asr. { ret rslt(cx, cx.build.AShr(lhs, rhs)); }\n-      _ { ret trans_compare(cx, op, intype, lhs, rhs); }\n+      _ { ret trans_compare(cx, op, lhs, lhs_t, rhs, rhs_t); }\n     }\n }\n \n@@ -3525,7 +3543,8 @@ fn trans_binary(cx: &@block_ctxt, op: ast::binop, a: &@ast::expr,\n         let rhs_expr = trans_expr(lhs.bcx, b);\n         let rhty = ty::expr_ty(bcx_tcx(cx), b);\n         let rhs = autoderef(rhs_expr.bcx, rhs_expr.val, rhty);\n-        ret trans_eager_binop(rhs.bcx, op, lhs.ty, lhs.val, rhs.val);\n+\n+        ret trans_eager_binop(rhs.bcx, op, lhs.val, lhs.ty, rhs.val, rhs.ty);\n       }\n     }\n }\n@@ -5206,7 +5225,8 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n             }\n         }\n         let lhs_val = load_if_immediate(rhs_res.bcx, lhs_res.res.val, t);\n-        let v = trans_eager_binop(rhs_res.bcx, op, t, lhs_val, rhs_res.val);\n+        let v = trans_eager_binop(rhs_res.bcx, op, lhs_val, t,\n+                                  rhs_res.val, t);\n         // FIXME: calculate copy init-ness in typestate.\n         // This is always a temporary, so can always be safely moved\n         let move_res ="}, {"sha": "024f29224559f130a723980c5f82bd227673e721", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/731797d075e8bd9d0e3d21c917c3c7028278a7d4/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/731797d075e8bd9d0e3d21c917c3c7028278a7d4/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=731797d075e8bd9d0e3d21c917c3c7028278a7d4", "patch": "@@ -360,7 +360,8 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: ValueRef[],\n             let r = trans_opt(bcx, opt);\n             bcx = r.bcx;\n             let t = ty::node_id_to_type(ccx.tcx, pat_id);\n-            let eq = trans::trans_compare(bcx, ast::eq, t, test_val, r.val);\n+            let eq = trans::trans_compare(bcx, ast::eq, test_val, t,\n+                                          r.val, t);\n             bcx = new_sub_block_ctxt(bcx, \"next\");\n             eq.bcx.build.CondBr(eq.val, opt_cx.llbb, bcx.llbb);\n           }"}, {"sha": "0a8b78cc0343545eec8967d7235e7b5fcb292361", "filename": "src/test/run-fail/binop-fail-2.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/731797d075e8bd9d0e3d21c917c3c7028278a7d4/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/731797d075e8bd9d0e3d21c917c3c7028278a7d4/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs?ref=731797d075e8bd9d0e3d21c917c3c7028278a7d4", "patch": "@@ -0,0 +1,3 @@\n+// error-pattern:quux\n+fn my_err(s: str) -> ! { log_err s; fail \"quux\"; }\n+fn main() { 3u == my_err(\"bye\"); }"}, {"sha": "062c04ff67aea1d27984732bd8b7e359c7e1437c", "filename": "src/test/run-fail/binop-fail.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/731797d075e8bd9d0e3d21c917c3c7028278a7d4/src%2Ftest%2Frun-fail%2Fbinop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/731797d075e8bd9d0e3d21c917c3c7028278a7d4/src%2Ftest%2Frun-fail%2Fbinop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbinop-fail.rs?ref=731797d075e8bd9d0e3d21c917c3c7028278a7d4", "patch": "@@ -0,0 +1,3 @@\n+// error-pattern:quux\n+fn my_err(s: str) -> ! { log_err s; fail \"quux\"; }\n+fn main() { my_err(\"bye\") == 3u; }"}, {"sha": "682bf502ce342bca5a2640dace0a05e2d22760d2", "filename": "src/test/run-pass/early-ret-binop.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/731797d075e8bd9d0e3d21c917c3c7028278a7d4/src%2Ftest%2Frun-pass%2Fearly-ret-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/731797d075e8bd9d0e3d21c917c3c7028278a7d4/src%2Ftest%2Frun-pass%2Fearly-ret-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fearly-ret-binop.rs?ref=731797d075e8bd9d0e3d21c917c3c7028278a7d4", "patch": "@@ -0,0 +1,4 @@\n+fn wsucc(n: int) -> int {\n+    { ret n + 1 } == 0;\n+}\n+fn main() {}"}]}