{"sha": "fd906c043f0569b3500ee8d34ae640977aab0671", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkOTA2YzA0M2YwNTY5YjM1MDBlZThkMzRhZTY0MDk3N2FhYjA2NzE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-02-01T11:00:03Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-02-01T11:00:03Z"}, "message": "Merge pull request #579 from oli-obk/single_match_else\n\nSingle match else", "tree": {"sha": "17302e4e8263a2af84a6ca8bdb2dce929422544b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17302e4e8263a2af84a6ca8bdb2dce929422544b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd906c043f0569b3500ee8d34ae640977aab0671", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd906c043f0569b3500ee8d34ae640977aab0671", "html_url": "https://github.com/rust-lang/rust/commit/fd906c043f0569b3500ee8d34ae640977aab0671", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd906c043f0569b3500ee8d34ae640977aab0671/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a61a95d31c9937b01b3ef847b114e8829f5da7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a61a95d31c9937b01b3ef847b114e8829f5da7d", "html_url": "https://github.com/rust-lang/rust/commit/5a61a95d31c9937b01b3ef847b114e8829f5da7d"}, {"sha": "07ace32ac91875be65c40a8957eb0982c027bd16", "url": "https://api.github.com/repos/rust-lang/rust/commits/07ace32ac91875be65c40a8957eb0982c027bd16", "html_url": "https://github.com/rust-lang/rust/commit/07ace32ac91875be65c40a8957eb0982c027bd16"}], "stats": {"total": 215, "additions": 130, "deletions": 85}, "files": [{"sha": "360370361475fd9bec2105a12d7a3acf5e17bd0c", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd906c043f0569b3500ee8d34ae640977aab0671/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd906c043f0569b3500ee8d34ae640977aab0671/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=fd906c043f0569b3500ee8d34ae640977aab0671", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 104 lints included in this crate:\n+There are 105 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -89,6 +89,7 @@ name\n [shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                           | allow   | The name is re-bound without even using the original value\n [should_implement_trait](https://github.com/Manishearth/rust-clippy/wiki#should_implement_trait)               | warn    | defining a method that should be implementing a std trait\n [single_match](https://github.com/Manishearth/rust-clippy/wiki#single_match)                                   | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n+[single_match_else](https://github.com/Manishearth/rust-clippy/wiki#single_match_else)                         | allow   | a match statement with a two arms where the second arm's pattern is a wildcard; recommends `if let` instead\n [str_to_string](https://github.com/Manishearth/rust-clippy/wiki#str_to_string)                                 | warn    | using `to_string()` on a str, which should be `to_owned()`\n [string_add](https://github.com/Manishearth/rust-clippy/wiki#string_add)                                       | allow   | using `x + ..` where x is a `String`; suggests using `push_str()` instead\n [string_add_assign](https://github.com/Manishearth/rust-clippy/wiki#string_add_assign)                         | allow   | using `x = x + ..` where x is a `String`; suggests using `push_str()` instead"}, {"sha": "4b3c4174df7258778ab2ee25676c53142e3329f9", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/fd906c043f0569b3500ee8d34ae640977aab0671/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd906c043f0569b3500ee8d34ae640977aab0671/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=fd906c043f0569b3500ee8d34ae640977aab0671", "patch": "@@ -54,43 +54,38 @@ impl LateLintPass for CollapsibleIf {\n \n fn check_if(cx: &LateContext, e: &Expr) {\n     if let ExprIf(ref check, ref then, ref else_) = e.node {\n-        match *else_ {\n-            Some(ref else_) => {\n-                if_let_chain! {[\n-                    let ExprBlock(ref block) = else_.node,\n-                    block.stmts.is_empty(),\n-                    block.rules == BlockCheckMode::DefaultBlock,\n-                    let Some(ref else_) = block.expr,\n-                    let ExprIf(_, _, _) = else_.node\n-                ], {\n-                    span_lint_and_then(cx,\n-                                       COLLAPSIBLE_IF,\n-                                       block.span,\n-                                       \"this `else { if .. }` block can be collapsed\", |db| {\n-                        db.span_suggestion(block.span, \"try\",\n-                                           format!(\"else {}\",\n-                                                   snippet_block(cx, else_.span, \"..\")));\n-                    });\n-                }}\n-            }\n-            None => {\n-                if let Some(&Expr{ node: ExprIf(ref check_inner, ref content, None), span: sp, ..}) =\n+        if let Some(ref else_) = *else_ {\n+            if_let_chain! {[\n+                let ExprBlock(ref block) = else_.node,\n+                block.stmts.is_empty(),\n+                block.rules == BlockCheckMode::DefaultBlock,\n+                let Some(ref else_) = block.expr,\n+                let ExprIf(_, _, _) = else_.node\n+            ], {\n+                span_lint_and_then(cx,\n+                                   COLLAPSIBLE_IF,\n+                                   block.span,\n+                                   \"this `else { if .. }` block can be collapsed\", |db| {\n+                    db.span_suggestion(block.span, \"try\",\n+                                       format!(\"else {}\",\n+                                               snippet_block(cx, else_.span, \"..\")));\n+                });\n+            }}\n+        } else if let Some(&Expr{ node: ExprIf(ref check_inner, ref content, None), span: sp, ..}) =\n                        single_stmt_of_block(then) {\n-                    if e.span.expn_id != sp.expn_id {\n-                        return;\n-                    }\n-                    span_lint_and_then(cx,\n-                                       COLLAPSIBLE_IF,\n-                                       e.span,\n-                                       \"this if statement can be collapsed\", |db| {\n-                        db.span_suggestion(e.span, \"try\",\n-                                           format!(\"if {} && {} {}\",\n-                                                   check_to_string(cx, check),\n-                                                   check_to_string(cx, check_inner),\n-                                                   snippet_block(cx, content.span, \"..\")));\n-                    });\n-                }\n+            if e.span.expn_id != sp.expn_id {\n+                return;\n             }\n+            span_lint_and_then(cx,\n+                               COLLAPSIBLE_IF,\n+                               e.span,\n+                               \"this if statement can be collapsed\", |db| {\n+                db.span_suggestion(e.span, \"try\",\n+                                   format!(\"if {} && {} {}\",\n+                                           check_to_string(cx, check),\n+                                           check_to_string(cx, check_inner),\n+                                           snippet_block(cx, content.span, \"..\")));\n+            });\n         }\n     }\n }"}, {"sha": "6d8ea99ebcccf7f6a86040f028d27b60d9b3e654", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd906c043f0569b3500ee8d34ae640977aab0671/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd906c043f0569b3500ee8d34ae640977aab0671/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=fd906c043f0569b3500ee8d34ae640977aab0671", "patch": "@@ -149,6 +149,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n \n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n+        matches::SINGLE_MATCH_ELSE,\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n         methods::WRONG_PUB_SELF_CONVENTION,"}, {"sha": "c866a48d223b2e83f605f000c9e9df867992be54", "filename": "src/matches.rs", "status": "modified", "additions": 61, "deletions": 15, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/fd906c043f0569b3500ee8d34ae640977aab0671/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd906c043f0569b3500ee8d34ae640977aab0671/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=fd906c043f0569b3500ee8d34ae640977aab0671", "patch": "@@ -28,6 +28,23 @@ declare_lint!(pub SINGLE_MATCH, Warn,\n               \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n                is `_ => {}`) is used; recommends `if let` instead\");\n \n+/// **What it does:** This lint checks for matches with a two arms where an `if let` will usually suffice. It is `Allow` by default.\n+///\n+/// **Why is this bad?** Just readability \u2013 `if let` nests less than a `match`.\n+///\n+/// **Known problems:** Personal style preferences may differ\n+///\n+/// **Example:**\n+/// ```\n+/// match x {\n+///     Some(ref foo) -> bar(foo),\n+///     _ => bar(other_ref),\n+/// }\n+/// ```\n+declare_lint!(pub SINGLE_MATCH_ELSE, Allow,\n+             \"a match statement with a two arms where the second arm's pattern is a wildcard; \\\n+              recommends `if let` instead\");\n+\n /// **What it does:** This lint checks for matches where all arms match a reference, suggesting to remove the reference and deref the matched expression instead. It also checks for `if let &foo = bar` blocks. It is `Warn` by default.\n ///\n /// **Why is this bad?** It just makes the code less readable. That reference destructuring adds nothing to the code.\n@@ -89,7 +106,7 @@ pub struct MatchPass;\n \n impl LintPass for MatchPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(SINGLE_MATCH, MATCH_REF_PATS, MATCH_BOOL)\n+        lint_array!(SINGLE_MATCH, MATCH_REF_PATS, MATCH_BOOL, SINGLE_MATCH_ELSE)\n     }\n }\n \n@@ -112,34 +129,49 @@ impl LateLintPass for MatchPass {\n fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if arms.len() == 2 &&\n        arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n-       arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n-       is_unit_expr(&arms[1].body) {\n+       arms[1].pats.len() == 1 && arms[1].guard.is_none() {\n+           let els = if is_unit_expr(&arms[1].body) {\n+               None\n+           } else if let ExprBlock(_) = arms[1].body.node {\n+               // matches with blocks that contain statements are prettier as `if let + else`\n+               Some(&*arms[1].body)\n+           } else {\n+               // allow match arms with just expressions\n+               return;\n+           };\n            let ty = cx.tcx.expr_ty(ex);\n            if ty.sty != ty::TyBool || cx.current_level(MATCH_BOOL) == Allow {\n-                check_single_match_single_pattern(cx, ex, arms, expr);\n-                check_single_match_opt_like(cx, ex, arms, expr, ty);\n+                check_single_match_single_pattern(cx, ex, arms, expr, els);\n+                check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n            }\n     }\n }\n \n-fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n     if arms[1].pats[0].node == PatWild {\n+        let lint = if els.is_some() {\n+            SINGLE_MATCH_ELSE\n+        } else {\n+            SINGLE_MATCH\n+        };\n+        let els_str = els.map_or(String::new(), |els| format!(\" else {}\", expr_block(cx, els, None, \"..\")));\n         span_lint_and_then(cx,\n-                           SINGLE_MATCH,\n+                           lint,\n                            expr.span,\n                            \"you seem to be trying to use match for destructuring a single pattern. \\\n                            Consider using `if let`\", |db| {\n                 db.span_suggestion(expr.span, \"try this\",\n-                                   format!(\"if let {} = {} {}\",\n+                                   format!(\"if let {} = {} {}{}\",\n                                            snippet(cx, arms[0].pats[0].span, \"..\"),\n                                            snippet(cx, ex.span, \"..\"),\n-                                           expr_block(cx, &arms[0].body, None, \"..\")));\n+                                           expr_block(cx, &arms[0].body, None, \"..\"),\n+                                           els_str));\n             });\n     }\n }\n \n-fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: ty::Ty) {\n-    // list of candidate Enums we know will never get any more membre\n+fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: ty::Ty, els: Option<&Expr>) {\n+    // list of candidate Enums we know will never get any more members\n     let candidates = &[\n         (&COW_PATH, \"Borrowed\"),\n         (&COW_PATH, \"Cow::Borrowed\"),\n@@ -151,23 +183,37 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n     ];\n \n     let path = match arms[1].pats[0].node {\n-        PatEnum(ref path, _) => path.to_string(),\n+        PatEnum(ref path, Some(ref inner)) => {\n+            // contains any non wildcard patterns? e.g. Err(err)\n+            if inner.iter().any(|pat| if let PatWild = pat.node { false } else { true }) {\n+                return;\n+            }\n+            path.to_string()\n+        },\n+        PatEnum(ref path, None) => path.to_string(),\n         PatIdent(BindByValue(MutImmutable), ident, None) => ident.node.to_string(),\n         _ => return\n     };\n \n     for &(ty_path, pat_path) in candidates {\n         if &path == pat_path && match_type(cx, ty, ty_path) {\n+            let lint = if els.is_some() {\n+                SINGLE_MATCH_ELSE\n+            } else {\n+                SINGLE_MATCH\n+            };\n+            let els_str = els.map_or(String::new(), |els| format!(\" else {}\", expr_block(cx, els, None, \"..\")));\n             span_lint_and_then(cx,\n-                               SINGLE_MATCH,\n+                               lint,\n                                expr.span,\n                                \"you seem to be trying to use match for destructuring a single pattern. \\\n                                Consider using `if let`\", |db| {\n                 db.span_suggestion(expr.span, \"try this\",\n-                                   format!(\"if let {} = {} {}\",\n+                                   format!(\"if let {} = {} {}{}\",\n                                            snippet(cx, arms[0].pats[0].span, \"..\"),\n                                            snippet(cx, ex.span, \"..\"),\n-                                           expr_block(cx, &arms[0].body, None, \"..\")));\n+                                           expr_block(cx, &arms[0].body, None, \"..\"),\n+                                           els_str));\n             });\n         }\n     }"}, {"sha": "15e8d310cd6336e3ea80077f38e548942482cee2", "filename": "src/mut_reference.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fd906c043f0569b3500ee8d34ae640977aab0671/src%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd906c043f0569b3500ee8d34ae640977aab0671/src%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_reference.rs?ref=fd906c043f0569b3500ee8d34ae640977aab0671", "patch": "@@ -33,27 +33,19 @@ impl LateLintPass for UnnecessaryMutPassed {\n         let borrowed_table = cx.tcx.tables.borrow();\n         match e.node {\n             ExprCall(ref fn_expr, ref arguments) => {\n-                match borrowed_table.node_types.get(&fn_expr.id) {\n-                    Some(function_type) => {\n-                        if let ExprPath(_, ref path) = fn_expr.node {\n-                            check_arguments(cx, &arguments, function_type, &format!(\"{}\", path));\n-                        }\n-                    }\n-                    None => unreachable!(), // A function with unknown type is called.\n-                    // If this happened the compiler would have aborted the\n-                    // compilation long ago.\n-                };\n-\n-\n+                let function_type = borrowed_table.node_types\n+                                                  .get(&fn_expr.id)\n+                                                  .expect(\"A function with an unknown type is called. \\\n+                                                           If this happened, the compiler would have \\\n+                                                           aborted the compilation long ago\");\n+                if let ExprPath(_, ref path) = fn_expr.node {\n+                    check_arguments(cx, &arguments, function_type, &format!(\"{}\", path));\n+                }\n             }\n             ExprMethodCall(ref name, _, ref arguments) => {\n                 let method_call = MethodCall::expr(e.id);\n-                match borrowed_table.method_map.get(&method_call) {\n-                    Some(method_type) => {\n-                        check_arguments(cx, &arguments, method_type.ty, &format!(\"{}\", name.node.as_str()))\n-                    }\n-                    None => unreachable!(), // Just like above, this should never happen.\n-                };\n+                let method_type = borrowed_table.method_map.get(&method_call).expect(\"This should never happen.\");\n+                check_arguments(cx, &arguments, method_type.ty, &format!(\"{}\", name.node.as_str()))\n             }\n             _ => {}\n         }"}, {"sha": "ff0c59ab290d8f6a7e8a7cbe957c8022f0a54b15", "filename": "src/utils.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fd906c043f0569b3500ee8d34ae640977aab0671/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd906c043f0569b3500ee8d34ae640977aab0671/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=fd906c043f0569b3500ee8d34ae640977aab0671", "patch": "@@ -657,20 +657,10 @@ pub fn is_expn_of(cx: &LateContext, mut span: Span, name: &str) -> Option<Span>\n                 (ei.callee.name(), ei.call_site)\n             })\n         });\n-\n-        return match span_name_span {\n-            Some((mac_name, new_span)) => {\n-                if mac_name.as_str() == name {\n-                    Some(new_span)\n-                }\n-                else {\n-                    span = new_span;\n-                    continue;\n-                }\n-            }\n-            None => {\n-                None\n-            }\n-        };\n+        match span_name_span {\n+            Some((mac_name, new_span)) if mac_name.as_str() == name => return Some(new_span),\n+            None => return None,\n+            Some((_, new_span)) => span = new_span,\n+        }\n     }\n }"}, {"sha": "71cc7c59f8fdf93007c5e749a49d317043c3424e", "filename": "tests/compile-fail/matches.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fd906c043f0569b3500ee8d34ae640977aab0671/tests%2Fcompile-fail%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd906c043f0569b3500ee8d34ae640977aab0671/tests%2Fcompile-fail%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatches.rs?ref=fd906c043f0569b3500ee8d34ae640977aab0671", "patch": "@@ -3,12 +3,32 @@\n #![plugin(clippy)]\n #![deny(clippy)]\n #![allow(unused)]\n+#![deny(single_match_else)]\n \n use std::borrow::Cow;\n \n enum Foo { Bar, Baz(u8) }\n use Foo::*;\n \n+enum ExprNode {\n+    ExprAddrOf,\n+    Butterflies,\n+    Unicorns,\n+}\n+\n+static NODE: ExprNode = ExprNode::Unicorns;\n+\n+fn unwrap_addr() -> Option<&'static ExprNode> {\n+    match ExprNode::Butterflies {   //~ ERROR you seem to be trying to use match\n+                                    //~^ HELP try\n+        ExprNode::ExprAddrOf => Some(&NODE),\n+        _ => {\n+            let x = 5;\n+            None\n+        },\n+    }\n+}\n+\n fn single_match(){\n     let x = Some(1u8);\n \n@@ -33,7 +53,7 @@ fn single_match(){\n         _ => ()\n     }\n \n-    // Not linted (content in the else)\n+    // Not linted (no block with statements in the single arm)\n     match z {\n         (2...3, 7...9) => println!(\"{:?}\", z),\n         _ => println!(\"nope\"),"}]}