{"sha": "03b8c8df0174967206d1d65c1ac311e205050e1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYjhjOGRmMDE3NDk2NzIwNmQxZDY1YzFhYzMxMWUyMDUwNTBlMWM=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-01-31T03:52:38Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-31T22:29:10Z"}, "message": "Rename str::from_byte(s) to str::unsafe::from_byte(s),\nmark them as unsafe,\nmake comp/driver/driver.rs use str::from_bytes...", "tree": {"sha": "40ef7b5b384f08ac49a4130643ceb3204a46cf1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40ef7b5b384f08ac49a4130643ceb3204a46cf1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03b8c8df0174967206d1d65c1ac311e205050e1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03b8c8df0174967206d1d65c1ac311e205050e1c", "html_url": "https://github.com/rust-lang/rust/commit/03b8c8df0174967206d1d65c1ac311e205050e1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03b8c8df0174967206d1d65c1ac311e205050e1c/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24668d7578d89406eaf1a6db4502360e73e2a8fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/24668d7578d89406eaf1a6db4502360e73e2a8fd", "html_url": "https://github.com/rust-lang/rust/commit/24668d7578d89406eaf1a6db4502360e73e2a8fd"}], "stats": {"total": 89, "additions": 47, "deletions": 42}, "files": [{"sha": "8781c07b4aa4879d9dc9e4a4f0a949f1916367eb", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b8c8df0174967206d1d65c1ac311e205050e1c/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b8c8df0174967206d1d65c1ac311e205050e1c/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=03b8c8df0174967206d1d65c1ac311e205050e1c", "patch": "@@ -80,7 +80,7 @@ fn parse_input(sess: session, cfg: ast::crate_cfg, input: str)\n     if !input_is_stdin(input) {\n         parser::parse_crate_from_file(input, cfg, sess.parse_sess)\n     } else {\n-        let src = @str::unsafe_from_bytes(io::stdin().read_whole_stream());\n+        let src = @str::from_bytes(io::stdin().read_whole_stream());\n         parser::parse_crate_from_source_str(input, src, cfg, sess.parse_sess)\n     }\n }"}, {"sha": "5ca66e427ea5b52fe5c2e34479e34e740d039aab", "filename": "src/libcore/str.rs", "status": "modified", "additions": 46, "deletions": 41, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/03b8c8df0174967206d1d65c1ac311e205050e1c/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b8c8df0174967206d1d65c1ac311e205050e1c/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=03b8c8df0174967206d1d65c1ac311e205050e1c", "patch": "@@ -12,9 +12,7 @@ For some heavy-duty uses, we recommend trying std::rope.\n export\n    // Creating a string\n    from_bytes,\n-   unsafe_from_bytes,\n    from_byte,\n-   unsafe_from_byte,\n    //push_utf8_bytes,\n    from_char,\n    from_chars,\n@@ -120,37 +118,11 @@ Function: from_bytes\n \n Convert a vector of bytes to a UTF-8 string.  Fails if invalid UTF-8.\n */\n-fn from_bytes(vv: [u8]) -> str {\n+fn from_bytes(vv: [u8]) -> str unsafe {\n    assert is_utf8(vv);\n-   ret unsafe_from_bytes(vv);\n+   ret unsafe::from_bytes(vv);\n }\n \n-/*\n-Function: unsafe_from_bytes\n-\n-Converts a vector of bytes to a string. Does not verify that the\n-vector contains valid UTF-8.\n-\n-FIXME: stop exporting\n-*/\n-fn unsafe_from_bytes(v: [const u8]) -> str unsafe {\n-    let vcopy: [u8] = v + [0u8];\n-    let scopy: str = unsafe::reinterpret_cast(vcopy);\n-    unsafe::leak(vcopy);\n-    ret scopy;\n-}\n-\n-/*\n-Function: unsafe_from_byte\n-\n-Converts a byte to a string. Does not verify that the byte is\n-valid UTF-8.\n-\n-FIXME: stop exporting\n-*/\n-fn unsafe_from_byte(u: u8) -> str { unsafe_from_bytes([u]) }\n-\n-\n /*\n Function: from_byte\n \n@@ -211,6 +183,7 @@ fn from_chars(chs: [char]) -> str {\n     ret buf;\n }\n \n+// FIXME: not unsafe now\n /*\n Function: from_cstr\n \n@@ -413,9 +386,9 @@ Converts a string to a vector of bytes. The result vector is not\n null-terminated.\n */\n fn bytes(s: str) -> [u8] unsafe {\n-    let v = unsafe::reinterpret_cast(s);\n+    let v = ::unsafe::reinterpret_cast(s);\n     let vcopy = vec::slice(v, 0u, vec::len(v) - 1u);\n-    unsafe::leak(v);\n+    ::unsafe::leak(v);\n     ret vcopy;\n }\n \n@@ -492,12 +465,12 @@ fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n     assert (begin <= end);\n     assert (end <= byte_len(s));\n \n-    let v: [u8] = unsafe::reinterpret_cast(s);\n+    let v: [u8] = ::unsafe::reinterpret_cast(s);\n     let v2 = vec::slice(v, begin, end);\n-    unsafe::leak(v);\n+    ::unsafe::leak(v);\n     v2 += [0u8];\n-    let s2: str = unsafe::reinterpret_cast(v2);\n-    unsafe::leak(v2);\n+    let s2: str = ::unsafe::reinterpret_cast(v2);\n+    ::unsafe::leak(v2);\n     ret s2;\n }\n \n@@ -1093,9 +1066,9 @@ Returns the length in bytes of a string\n FIXME: rename to 'len_bytes'?\n */\n pure fn byte_len(s: str) -> uint unsafe {\n-    let v: [u8] = unsafe::reinterpret_cast(s);\n+    let v: [u8] = ::unsafe::reinterpret_cast(s);\n     let vlen = vec::len(v);\n-    unsafe::leak(v);\n+    ::unsafe::leak(v);\n     // There should always be a null terminator\n     assert (vlen > 0u);\n     ret vlen - 1u;\n@@ -1371,7 +1344,7 @@ const tag_six_b: uint = 252u;\n // no guarantee that the string is rooted). Instead, use as_buf below.\n unsafe fn buf(s: str) -> sbuf {\n     let saddr = ptr::addr_of(s);\n-    let vaddr: *[u8] = unsafe::reinterpret_cast(saddr);\n+    let vaddr: *[u8] = ::unsafe::reinterpret_cast(saddr);\n     let buf = vec::to_ptr(*vaddr);\n     ret buf;\n }\n@@ -1398,6 +1371,38 @@ An unsafe buffer of bytes. Corresponds to a C char pointer.\n */\n type sbuf = *u8;\n \n+mod unsafe {\n+   export\n+      // UNSAFE\n+      from_bytes,\n+      from_byte;\n+\n+   /*\n+   Function: unsafe::from_bytes\n+\n+   Converts a vector of bytes to a string. Does not verify that the\n+   vector contains valid UTF-8.\n+\n+   FIXME: stop exporting\n+   */\n+   unsafe fn from_bytes(v: [const u8]) -> str unsafe {\n+       let vcopy: [u8] = v + [0u8];\n+       let scopy: str = ::unsafe::reinterpret_cast(vcopy);\n+       ::unsafe::leak(vcopy);\n+       ret scopy;\n+   }\n+\n+   /*\n+   Function: unsafe::from_byte\n+\n+   Converts a byte to a string. Does not verify that the byte is\n+   valid UTF-8.\n+\n+   FIXME: stop exporting\n+   */\n+   unsafe fn from_byte(u: u8) -> str { unsafe::from_bytes([u]) }\n+}\n+\n \n #[cfg(test)]\n mod tests {\n@@ -1771,9 +1776,9 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_unsafe_from_bytes() {\n+    fn test_unsafe_from_bytes() unsafe {\n         let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n-        let b = unsafe_from_bytes(a);\n+        let b = unsafe::from_bytes(a);\n         assert (b == \"AAAAAAA\");\n     }\n "}]}