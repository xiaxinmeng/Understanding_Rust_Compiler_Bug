{"sha": "5d359db9cf003ac05e989460e202137a0afa5cce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMzU5ZGI5Y2YwMDNhYzA1ZTk4OTQ2MGUyMDIxMzdhMGFmYTVjY2U=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-09-26T14:23:56Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-09-26T14:23:56Z"}, "message": "Remove all unstable feature support in the `missing_const_for_fn` lint", "tree": {"sha": "82ab0e5bb6e1b63fdfd5fddc5c6b28eb0fb70100", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82ab0e5bb6e1b63fdfd5fddc5c6b28eb0fb70100"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d359db9cf003ac05e989460e202137a0afa5cce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d359db9cf003ac05e989460e202137a0afa5cce", "html_url": "https://github.com/rust-lang/rust/commit/5d359db9cf003ac05e989460e202137a0afa5cce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d359db9cf003ac05e989460e202137a0afa5cce/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b843896c8b0a994835e933e67ca4e3de042ce9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b843896c8b0a994835e933e67ca4e3de042ce9f", "html_url": "https://github.com/rust-lang/rust/commit/1b843896c8b0a994835e933e67ca4e3de042ce9f"}], "stats": {"total": 122, "additions": 25, "deletions": 97}, "files": [{"sha": "6809b1fa88d35fa68f6e82597f18e64ba40c1cc3", "filename": "src/tools/clippy/clippy_lints/src/utils/qualify_min_const_fn.rs", "status": "modified", "additions": 25, "deletions": 97, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/5d359db9cf003ac05e989460e202137a0afa5cce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d359db9cf003ac05e989460e202137a0afa5cce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs?ref=5d359db9cf003ac05e989460e202137a0afa5cce", "patch": "@@ -3,22 +3,14 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, adjustment::PointerCast, Ty, TyCtxt};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym};\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi::RustIntrinsic;\n use std::borrow::Cow;\n \n type McfResult = Result<(), (Span, Cow<'static, str>)>;\n \n pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -> McfResult {\n-    // Prevent const trait methods from being annotated as `stable`.\n-    if tcx.features().staged_api {\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-        if rustc_mir::const_eval::is_parent_const_impl_raw(tcx, hir_id) {\n-            return Err((body.span, \"trait methods cannot be stable const fn\".into()));\n-        }\n-    }\n-\n     let mut current = def_id;\n     loop {\n         let predicates = tcx.predicates_of(current);\n@@ -40,19 +32,12 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n                 ty::PredicateAtom::Subtype(_) => {\n                     panic!(\"subtype predicate on function: {:#?}\", predicate)\n                 }\n-                ty::PredicateAtom::Trait(pred, constness) => {\n+                ty::PredicateAtom::Trait(pred, _) => {\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;\n                     }\n                     match pred.self_ty().kind() {\n                         ty::Param(ref p) => {\n-                            // Allow `T: ?const Trait`\n-                            if constness == hir::Constness::NotConst\n-                                && feature_allowed(tcx, def_id, sym::const_trait_bound_opt_out)\n-                            {\n-                                continue;\n-                            }\n-\n                             let generics = tcx.generics_of(current);\n                             let def = generics.type_param(p, tcx);\n                             let span = tcx.def_span(def.def_id);\n@@ -77,26 +62,25 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n     }\n \n     for local in &body.local_decls {\n-        check_ty(tcx, local.ty, local.source_info.span, def_id)?;\n+        check_ty(tcx, local.ty, local.source_info.span)?;\n     }\n     // impl trait is gone in MIR, so check the return type manually\n     check_ty(\n         tcx,\n         tcx.fn_sig(def_id).output().skip_binder(),\n         body.local_decls.iter().next().unwrap().source_info.span,\n-        def_id,\n     )?;\n \n     for bb in body.basic_blocks() {\n-        check_terminator(tcx, body, def_id, bb.terminator())?;\n+        check_terminator(tcx, body, bb.terminator())?;\n         for stmt in &bb.statements {\n             check_statement(tcx, body, def_id, stmt)?;\n         }\n     }\n     Ok(())\n }\n \n-fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> McfResult {\n+fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n     for arg in ty.walk() {\n         let ty = match arg.unpack() {\n             GenericArgKind::Type(ty) => ty,\n@@ -108,15 +92,11 @@ fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> Mc\n \n         match ty.kind() {\n             ty::Ref(_, _, hir::Mutability::Mut) => {\n-                if !feature_allowed(tcx, fn_def_id, sym::const_mut_refs) {\n                     return Err((span, \"mutable references in const fn are unstable\".into()));\n-                }\n             }\n             ty::Opaque(..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n             ty::FnPtr(..) => {\n-                if !tcx.const_fn_is_allowed_fn_ptr(fn_def_id) {\n                     return Err((span, \"function pointers in const fn are unstable\".into()));\n-                }\n             }\n             ty::Dynamic(preds, _) => {\n                 for pred in preds.iter() {\n@@ -161,12 +141,12 @@ fn check_rvalue(\n             Err((span, \"cannot access thread local storage in const fn\".into()))\n         }\n         Rvalue::Repeat(operand, _) | Rvalue::Use(operand) => {\n-            check_operand(tcx, operand, span, def_id, body)\n+            check_operand(tcx, operand, span, body)\n         }\n         Rvalue::Len(place)\n         | Rvalue::Discriminant(place)\n         | Rvalue::Ref(_, _, place)\n-        | Rvalue::AddressOf(_, place) => check_place(tcx, *place, span, def_id, body),\n+        | Rvalue::AddressOf(_, place) => check_place(tcx, *place, span,  body),\n         Rvalue::Cast(CastKind::Misc, operand, cast_ty) => {\n             use rustc_middle::ty::cast::CastTy;\n             let cast_in = CastTy::from_ty(operand.ty(body, tcx)).expect(\"bad input type for cast\");\n@@ -175,14 +155,14 @@ fn check_rvalue(\n                 (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) => {\n                     Err((span, \"casting pointers to ints is unstable in const fn\".into()))\n                 }\n-                _ => check_operand(tcx, operand, span, def_id, body),\n+                _ => check_operand(tcx, operand, span, body),\n             }\n         }\n         Rvalue::Cast(\n             CastKind::Pointer(PointerCast::MutToConstPointer | PointerCast::ArrayToPointer),\n             operand,\n             _,\n-        ) => check_operand(tcx, operand, span, def_id, body),\n+        ) => check_operand(tcx, operand, span, body),\n         Rvalue::Cast(\n             CastKind::Pointer(\n                 PointerCast::UnsafeFnPointer\n@@ -204,7 +184,7 @@ fn check_rvalue(\n             };\n             let unsized_ty = tcx.struct_tail_erasing_lifetimes(pointee_ty, tcx.param_env(def_id));\n             if let ty::Slice(_) | ty::Str = unsized_ty.kind() {\n-                check_operand(tcx, op, span, def_id, body)?;\n+                check_operand(tcx, op, span, body)?;\n                 // Casting/coercing things to slices is fine.\n                 Ok(())\n             } else {\n@@ -214,8 +194,8 @@ fn check_rvalue(\n         }\n         // binops are fine on integers\n         Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n-            check_operand(tcx, lhs, span, def_id, body)?;\n-            check_operand(tcx, rhs, span, def_id, body)?;\n+            check_operand(tcx, lhs, span, body)?;\n+            check_operand(tcx, rhs, span, body)?;\n             let ty = lhs.ty(body, tcx);\n             if ty.is_integral() || ty.is_bool() || ty.is_char() {\n                 Ok(())\n@@ -230,14 +210,14 @@ fn check_rvalue(\n         Rvalue::UnaryOp(_, operand) => {\n             let ty = operand.ty(body, tcx);\n             if ty.is_integral() || ty.is_bool() {\n-                check_operand(tcx, operand, span, def_id, body)\n+                check_operand(tcx, operand, span, body)\n             } else {\n                 Err((span, \"only int and `bool` operations are stable in const fn\".into()))\n             }\n         }\n         Rvalue::Aggregate(_, operands) => {\n             for operand in operands {\n-                check_operand(tcx, operand, span, def_id, body)?;\n+                check_operand(tcx, operand, span, body)?;\n             }\n             Ok(())\n         }\n@@ -253,15 +233,15 @@ fn check_statement(\n     let span = statement.source_info.span;\n     match &statement.kind {\n         StatementKind::Assign(box (place, rval)) => {\n-            check_place(tcx, *place, span, def_id, body)?;\n+            check_place(tcx, *place, span,  body)?;\n             check_rvalue(tcx, body, def_id, rval, span)\n         }\n \n-        StatementKind::FakeRead(_, place) => check_place(tcx, **place, span, def_id, body),\n+        StatementKind::FakeRead(_, place) => check_place(tcx, **place, span, body),\n \n         // just an assignment\n         StatementKind::SetDiscriminant { place, .. } => {\n-            check_place(tcx, **place, span, def_id, body)\n+            check_place(tcx, **place, span,  body)\n         }\n \n         StatementKind::LlvmInlineAsm { .. } => {\n@@ -282,11 +262,10 @@ fn check_operand(\n     tcx: TyCtxt<'tcx>,\n     operand: &Operand<'tcx>,\n     span: Span,\n-    def_id: DefId,\n     body: &Body<'tcx>,\n ) -> McfResult {\n     match operand {\n-        Operand::Move(place) | Operand::Copy(place) => check_place(tcx, *place, span, def_id, body),\n+        Operand::Move(place) | Operand::Copy(place) => check_place(tcx, *place, span, body),\n         Operand::Constant(c) => match c.check_static_ptr(tcx) {\n             Some(_) => Err((span, \"cannot access `static` items in const fn\".into())),\n             None => Ok(()),\n@@ -298,7 +277,6 @@ fn check_place(\n     tcx: TyCtxt<'tcx>,\n     place: Place<'tcx>,\n     span: Span,\n-    def_id: DefId,\n     body: &Body<'tcx>,\n ) -> McfResult {\n     let mut cursor = place.projection.as_ref();\n@@ -310,9 +288,7 @@ fn check_place(\n                 if let Some(def) = base_ty.ty_adt_def() {\n                     // No union field accesses in `const fn`\n                     if def.is_union() {\n-                        if !feature_allowed(tcx, def_id, sym::const_fn_union) {\n                             return Err((span, \"accessing union fields is unstable\".into()));\n-                        }\n                     }\n                 }\n             }\n@@ -327,48 +303,9 @@ fn check_place(\n     Ok(())\n }\n \n-/// Returns `true` if the given feature gate is allowed within the function with the given `DefId`.\n-fn feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bool {\n-    // All features require that the corresponding gate be enabled,\n-    // even if the function has `#[allow_internal_unstable(the_gate)]`.\n-    if !tcx.features().enabled(feature_gate) {\n-        return false;\n-    }\n-\n-    // If this crate is not using stability attributes, or this function is not claiming to be a\n-    // stable `const fn`, that is all that is required.\n-    if !tcx.features().staged_api || tcx.has_attr(def_id, sym::rustc_const_unstable) {\n-        return true;\n-    }\n-\n-    // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n-    // opt-in via `allow_internal_unstable`.\n-    rustc_mir::transform::check_consts::allow_internal_unstable(tcx, def_id, feature_gate)\n-}\n-\n-/// Returns `true` if the given library feature gate is allowed within the function with the given `DefId`.\n-pub fn lib_feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bool {\n-    // All features require that the corresponding gate be enabled,\n-    // even if the function has `#[allow_internal_unstable(the_gate)]`.\n-    if !tcx.features().declared_lib_features.iter().any(|&(sym, _)| sym == feature_gate) {\n-        return false;\n-    }\n-\n-    // If this crate is not using stability attributes, or this function is not claiming to be a\n-    // stable `const fn`, that is all that is required.\n-    if !tcx.features().staged_api || tcx.has_attr(def_id, sym::rustc_const_unstable) {\n-        return true;\n-    }\n-\n-    // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n-    // opt-in via `allow_internal_unstable`.\n-    rustc_mir::transform::check_consts::allow_internal_unstable(tcx, def_id, feature_gate)\n-}\n-\n fn check_terminator(\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n-    def_id: DefId,\n     terminator: &Terminator<'tcx>,\n ) -> McfResult {\n     let span = terminator.source_info.span;\n@@ -380,14 +317,14 @@ fn check_terminator(\n         | TerminatorKind::Resume\n         | TerminatorKind::Unreachable => Ok(()),\n \n-        TerminatorKind::Drop { place, .. } => check_place(tcx, *place, span, def_id, body),\n+        TerminatorKind::Drop { place, .. } => check_place(tcx, *place, span,  body),\n         TerminatorKind::DropAndReplace { place, value, .. } => {\n-            check_place(tcx, *place, span, def_id, body)?;\n-            check_operand(tcx, value, span, def_id, body)\n+            check_place(tcx, *place, span,  body)?;\n+            check_operand(tcx, value, span, body)\n         }\n \n         TerminatorKind::SwitchInt { discr, switch_ty: _, values: _, targets: _ } => {\n-            check_operand(tcx, discr, span, def_id, body)\n+            check_operand(tcx, discr, span, body)\n         }\n \n         TerminatorKind::Abort => Err((span, \"abort is not stable in const fn\".into())),\n@@ -405,15 +342,7 @@ fn check_terminator(\n         } => {\n             let fn_ty = func.ty(body, tcx);\n             if let ty::FnDef(fn_def_id, _) = *fn_ty.kind() {\n-                // Allow unstable const if we opt in by using #[allow_internal_unstable]\n-                // on function or macro declaration.\n                 if !rustc_mir::const_eval::is_min_const_fn(tcx, fn_def_id)\n-                    && !rustc_mir::const_eval::is_unstable_const_fn(tcx, fn_def_id)\n-                        .map(|feature| {\n-                            span.allows_unstable(feature)\n-                                || lib_feature_allowed(tcx, def_id, feature)\n-                        })\n-                        .unwrap_or(false)\n                 {\n                     return Err((\n                         span,\n@@ -432,18 +361,17 @@ fn check_terminator(\n                 // transmutes in const fn before we add more hacks to this.\n                 if tcx.fn_sig(fn_def_id).abi() == RustIntrinsic\n                     && tcx.item_name(fn_def_id) == sym::transmute\n-                    && !feature_allowed(tcx, def_id, sym::const_fn_transmute)\n                 {\n                     return Err((\n                         span,\n                         \"can only call `transmute` from const items, not `const fn`\".into(),\n                     ));\n                 }\n \n-                check_operand(tcx, func, span, fn_def_id, body)?;\n+                check_operand(tcx, func, span, body)?;\n \n                 for arg in args {\n-                    check_operand(tcx, arg, span, fn_def_id, body)?;\n+                    check_operand(tcx, arg, span, body)?;\n                 }\n                 Ok(())\n             } else {\n@@ -452,7 +380,7 @@ fn check_terminator(\n         }\n \n         TerminatorKind::Assert { cond, expected: _, msg: _, target: _, cleanup: _ } => {\n-            check_operand(tcx, cond, span, def_id, body)\n+            check_operand(tcx, cond, span, body)\n         }\n \n         TerminatorKind::InlineAsm { .. } => {"}]}