{"sha": "9fd4f3ea8fd1bbf392f91d727d83ea645fdc6a84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmZDRmM2VhOGZkMWJiZjM5MmY5MWQ3MjdkODNlYTY0NWZkYzZhODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-02T16:56:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-02T16:56:39Z"}, "message": "Auto merge of #6664 - camsteffen:path-to-res, r=Manishearth\n\nRemove Option from `path_to_res` return type\n\nchangelog: none\n\nTiny cleanup for `path_to_res` to return `Res` instead of `Option<Res>`.", "tree": {"sha": "4bf554de3343151d31b1d958a02071b1dc7dc159", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bf554de3343151d31b1d958a02071b1dc7dc159"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fd4f3ea8fd1bbf392f91d727d83ea645fdc6a84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fd4f3ea8fd1bbf392f91d727d83ea645fdc6a84", "html_url": "https://github.com/rust-lang/rust/commit/9fd4f3ea8fd1bbf392f91d727d83ea645fdc6a84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fd4f3ea8fd1bbf392f91d727d83ea645fdc6a84/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28794e956e2c344094d0dab1f1551eac9cb2f6d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/28794e956e2c344094d0dab1f1551eac9cb2f6d6", "html_url": "https://github.com/rust-lang/rust/commit/28794e956e2c344094d0dab1f1551eac9cb2f6d6"}, {"sha": "939136d1bc512e4acb3a91bbec2d5f7db311d4d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/939136d1bc512e4acb3a91bbec2d5f7db311d4d8", "html_url": "https://github.com/rust-lang/rust/commit/939136d1bc512e4acb3a91bbec2d5f7db311d4d8"}], "stats": {"total": 34, "additions": 18, "deletions": 16}, "files": [{"sha": "cccad243e1b5917a1c52b4d34979a9fdc4626345", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fd4f3ea8fd1bbf392f91d727d83ea645fdc6a84/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fd4f3ea8fd1bbf392f91d727d83ea645fdc6a84/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=9fd4f3ea8fd1bbf392f91d727d83ea645fdc6a84", "patch": "@@ -760,7 +760,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n             // Extract the path to the matched type\n             if let Some(segments) = path_to_matched_type(cx, ty_path);\n             let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n-            if let Some(ty_did) = path_to_res(cx, &segments[..]).and_then(|res| res.opt_def_id());\n+            if let Some(ty_did) = path_to_res(cx, &segments[..]).opt_def_id();\n             // Check if the matched type is a diagnostic item\n             let diag_items = cx.tcx.diagnostic_items(ty_did.krate);\n             if let Some(item_name) = diag_items.iter().find_map(|(k, v)| if *v == ty_did { Some(k) } else { None });\n@@ -833,7 +833,7 @@ fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Ve\n // This is not a complete resolver for paths. It works on all the paths currently used in the paths\n // module.  That's all it does and all it needs to do.\n pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n-    if path_to_res(cx, path).is_some() {\n+    if path_to_res(cx, path) != Res::Err {\n         return true;\n     }\n \n@@ -906,7 +906,7 @@ impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n         }\n \n         for &module in &[&paths::KW_MODULE, &paths::SYM_MODULE] {\n-            if let Some(Res::Def(_, def_id)) = path_to_res(cx, module) {\n+            if let Some(def_id) = path_to_res(cx, module).opt_def_id() {\n                 for item in cx.tcx.item_children(def_id).iter() {\n                     if_chain! {\n                         if let Res::Def(DefKind::Const, item_def_id) = item.res;"}, {"sha": "ef45f9fdcd5d49a29e1836ad784351c5f88fe48c", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9fd4f3ea8fd1bbf392f91d727d83ea645fdc6a84/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fd4f3ea8fd1bbf392f91d727d83ea645fdc6a84/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=9fd4f3ea8fd1bbf392f91d727d83ea645fdc6a84", "patch": "@@ -309,7 +309,15 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n \n /// Gets the definition associated to a path.\n #[allow(clippy::shadow_unrelated)] // false positive #6563\n-pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Option<Res> {\n+pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n+    macro_rules! try_res {\n+        ($e:expr) => {\n+            match $e {\n+                Some(e) => e,\n+                None => return Res::Err,\n+            }\n+        };\n+    }\n     fn item_child_by_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, name: &str) -> Option<&'tcx Export<HirId>> {\n         tcx.item_children(def_id)\n             .iter()\n@@ -318,12 +326,12 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Option<Res> {\n \n     let (krate, first, path) = match *path {\n         [krate, first, ref path @ ..] => (krate, first, path),\n-        _ => return None,\n+        _ => return Res::Err,\n     };\n     let tcx = cx.tcx;\n     let crates = tcx.crates();\n-    let krate = crates.iter().find(|&&num| tcx.crate_name(num).as_str() == krate)?;\n-    let first = item_child_by_name(tcx, krate.as_def_id(), first)?;\n+    let krate = try_res!(crates.iter().find(|&&num| tcx.crate_name(num).as_str() == krate));\n+    let first = try_res!(item_child_by_name(tcx, krate.as_def_id(), first));\n     let last = path\n         .iter()\n         .copied()\n@@ -343,21 +351,15 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Option<Res> {\n             } else {\n                 None\n             }\n-        })?;\n-    Some(last.res)\n+        });\n+    try_res!(last).res\n }\n \n /// Convenience function to get the `DefId` of a trait by path.\n /// It could be a trait or trait alias.\n pub fn get_trait_def_id(cx: &LateContext<'_>, path: &[&str]) -> Option<DefId> {\n-    let res = match path_to_res(cx, path) {\n-        Some(res) => res,\n-        None => return None,\n-    };\n-\n-    match res {\n+    match path_to_res(cx, path) {\n         Res::Def(DefKind::Trait | DefKind::TraitAlias, trait_id) => Some(trait_id),\n-        Res::Err => unreachable!(\"this trait resolution is impossible: {:?}\", &path),\n         _ => None,\n     }\n }"}]}