{"sha": "4f29814f2a2503f9abb2ccb1e3c286dbf8e8a0d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMjk4MTRmMmEyNTAzZjlhYmIyY2NiMWUzYzI4NmRiZjhlOGEwZDA=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-23T18:28:38Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-25T19:12:25Z"}, "message": "Hand-written bounded pingpong implementation.", "tree": {"sha": "37be6a72f25c2f7c99af4292ba52bcb2ad5261d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37be6a72f25c2f7c99af4292ba52bcb2ad5261d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f29814f2a2503f9abb2ccb1e3c286dbf8e8a0d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f29814f2a2503f9abb2ccb1e3c286dbf8e8a0d0", "html_url": "https://github.com/rust-lang/rust/commit/4f29814f2a2503f9abb2ccb1e3c286dbf8e8a0d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f29814f2a2503f9abb2ccb1e3c286dbf8e8a0d0/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d74fb9875bc01a96359127837c5f2b71de7af93a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d74fb9875bc01a96359127837c5f2b71de7af93a", "html_url": "https://github.com/rust-lang/rust/commit/d74fb9875bc01a96359127837c5f2b71de7af93a"}], "stats": {"total": 183, "additions": 176, "deletions": 7}, "files": [{"sha": "3bb2467f3df4cc66f905b8bccc3f5dadde8db84d", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 70, "deletions": 7, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4f29814f2a2503f9abb2ccb1e3c286dbf8e8a0d0/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f29814f2a2503f9abb2ccb1e3c286dbf8e8a0d0/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=4f29814f2a2503f9abb2ccb1e3c286dbf8e8a0d0", "patch": "@@ -7,6 +7,12 @@ import arc::methods;\n \n // Things used by code generated by the pipe compiler.\n export entangle, get_buffer, drop_buffer;\n+export send_packet_buffered, recv_packet_buffered;\n+export mk_packet;\n+\n+// export these so we can find them in the buffer_resource\n+// destructor. This is probably another metadata bug.\n+export atomic_add_acq, atomic_sub_rel;\n \n // User-level things\n export send_packet, recv_packet, send, recv, try_recv, peek;\n@@ -71,7 +77,7 @@ higher level buffer structure. Packets can maintain a pointer to their\n buffer, and this is the part that gets freed.\n \n It might be helpful to have some idea of a semi-unique pointer (like\n-being partially pregnant, also like an ARC). \n+being partially pregnant, also like an ARC).\n \n */\n \n@@ -87,7 +93,7 @@ class buffer_header {\n     // get away with restricting it to 0 or 1, if we're careful.\n     let mut ref_count: int;\n \n-    new() { self.ref_count = 1; }\n+    new() { self.ref_count = 0; }\n \n     // We may want a drop, and to be careful about stringing this\n     // thing along.\n@@ -134,13 +140,24 @@ class packet_header {\n         assert self.buffer.is_not_null();\n         reinterpret_cast(self.buffer)\n     }\n+\n+    fn set_buffer<T: send>(b: ~buffer<T>) unsafe {\n+        self.buffer = reinterpret_cast(b);\n+    }\n }\n \n type packet<T: send> = {\n     header: packet_header,\n     mut payload: option<T>,\n };\n \n+fn mk_packet<T: send>() -> packet<T> {\n+    {\n+        header: packet_header(),\n+        mut payload: none\n+    }\n+}\n+\n fn unibuffer<T: send>() -> ~buffer<packet<T>> {\n     let b = ~{\n         header: buffer_header(),\n@@ -170,12 +187,25 @@ extern mod rusti {\n     fn atomic_xchng(&dst: int, src: int) -> int;\n     fn atomic_xchng_acq(&dst: int, src: int) -> int;\n     fn atomic_xchng_rel(&dst: int, src: int) -> int;\n+\n+    fn atomic_add_acq(&dst: int, src: int) -> int;\n+    fn atomic_sub_rel(&dst: int, src: int) -> int;\n }\n \n+// If I call the rusti versions directly from a polymorphic function,\n+// I get link errors. This is a bug that needs investigated more.\n fn atomic_xchng_rel(&dst: int, src: int) -> int {\n     rusti::atomic_xchng_rel(dst, src)\n }\n \n+fn atomic_add_acq(&dst: int, src: int) -> int {\n+    rusti::atomic_add_acq(dst, src)\n+}\n+\n+fn atomic_sub_rel(&dst: int, src: int) -> int {\n+    rusti::atomic_sub_rel(dst, src)\n+}\n+\n type rust_task = libc::c_void;\n \n extern mod rustrt {\n@@ -222,13 +252,21 @@ unsafe fn get_buffer<T: send>(p: *packet_header) -> ~buffer<T> {\n class buffer_resource<T: send> {\n     let buffer: ~buffer<T>;\n     new(+b: ~buffer<T>) {\n+        let p = ptr::addr_of(*b);\n+        #error(\"take %?\", p);\n+        atomic_add_acq(b.header.ref_count, 1);\n         self.buffer = b;\n     }\n \n     drop unsafe {\n         let b = move!{self.buffer};\n-        let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n-        if old_count == 0 {\n+        let p = ptr::addr_of(*b);\n+        #error(\"drop %?\", p);\n+        let old_count = atomic_sub_rel(b.header.ref_count, 1);\n+        //let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n+        if old_count == 1 {\n+            // The new count is 0.\n+\n             // go go gadget drop glue\n         }\n         else {\n@@ -237,7 +275,8 @@ class buffer_resource<T: send> {\n     }\n }\n \n-fn send<T: send>(-p: send_packet<T>, -payload: T) {\n+fn send<T: send, Tbuffer: send>(-p: send_packet_buffered<T, Tbuffer>,\n+                                -payload: T) {\n     let header = p.header();\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n@@ -273,11 +312,13 @@ fn send<T: send>(-p: send_packet<T>, -payload: T) {\n     }\n }\n \n-fn recv<T: send>(-p: recv_packet<T>) -> T {\n+fn recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>) -> T {\n     option::unwrap(try_recv(p))\n }\n \n-fn try_recv<T: send>(-p: recv_packet<T>) -> option<T> {\n+fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n+    -> option<T>\n+{\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n     let this = rustrt::rust_get_task();\n@@ -498,6 +539,10 @@ class send_packet_buffered<T: send, Tbuffer: send> {\n             p <-> self.p;\n             sender_terminate(option::unwrap(p))\n         }\n+        unsafe { #error(\"send_drop: %?\",\n+                        if self.buffer == none {\n+                            \"none\"\n+                        } else { \"some\" }); }\n     }\n     fn unwrap() -> *packet<T> {\n         let mut p = none;\n@@ -518,6 +563,13 @@ class send_packet_buffered<T: send, Tbuffer: send> {\n           none { fail ~\"packet already consumed\" }\n         }\n     }\n+\n+    fn reuse_buffer() -> buffer_resource<Tbuffer> {\n+        #error(\"send reuse_buffer\");\n+        let mut tmp = none;\n+        tmp <-> self.buffer;\n+        option::unwrap(tmp)\n+    }\n }\n \n type recv_packet<T: send> = recv_packet_buffered<T, packet<T>>;\n@@ -547,6 +599,10 @@ class recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n             p <-> self.p;\n             receiver_terminate(option::unwrap(p))\n         }\n+        unsafe { #error(\"recv_drop: %?\",\n+                        if self.buffer == none {\n+                            \"none\"\n+                        } else { \"some\" }); }\n     }\n     fn unwrap() -> *packet<T> {\n         let mut p = none;\n@@ -567,6 +623,13 @@ class recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n           none { fail ~\"packet already consumed\" }\n         }\n     }\n+\n+    fn reuse_buffer() -> buffer_resource<Tbuffer> {\n+        #error(\"recv reuse_buffer\");\n+        let mut tmp = none;\n+        tmp <-> self.buffer;\n+        option::unwrap(tmp)\n+    }\n }\n \n fn entangle<T: send>() -> (send_packet<T>, recv_packet<T>) {"}, {"sha": "bad605b8929e3bfbafa960de8455bf8c217285ce", "filename": "src/test/run-pass/pipe-pingpong-bounded.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4f29814f2a2503f9abb2ccb1e3c286dbf8e8a0d0/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f29814f2a2503f9abb2ccb1e3c286dbf8e8a0d0/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs?ref=4f29814f2a2503f9abb2ccb1e3c286dbf8e8a0d0", "patch": "@@ -0,0 +1,106 @@\n+// Ping-pong is a bounded protocol. This is place where I can\n+// experiment with what code the compiler should generate for bounded\n+// protocols.\n+\n+// xfail-pretty\n+\n+// This was generated initially by the pipe compiler, but it's been\n+// modified in hopefully straightforward ways.\n+mod pingpong {\n+    import pipes::*;\n+\n+    type packets = {\n+        ping: packet<ping>,\n+        pong: packet<pong>,\n+    };\n+\n+    fn init() -> (client::ping, server::ping) {\n+        let buffer = ~{\n+            header: buffer_header(),\n+            data: {\n+                ping: mk_packet::<ping>(),\n+                pong: mk_packet::<pong>()\n+            }\n+        };\n+        unsafe {\n+            buffer.data.ping.header.set_buffer(buffer);\n+            buffer.data.pong.header.set_buffer(buffer);\n+        }\n+        let client = send_packet_buffered(ptr::addr_of(buffer.data.ping));\n+        let server = recv_packet_buffered(ptr::addr_of(buffer.data.ping));\n+        (client, server)\n+    }\n+    enum ping = server::pong;\n+    enum pong = client::ping;\n+    mod client {\n+        fn ping(+pipe: ping) -> pong {\n+            {\n+                let b = pipe.reuse_buffer();\n+                let s = send_packet_buffered(ptr::addr_of(b.buffer.data.pong));\n+                let c = recv_packet_buffered(ptr::addr_of(b.buffer.data.pong));\n+                let message = pingpong::ping(s);\n+                pipes::send(pipe, message);\n+                c\n+            }\n+        }\n+        type ping = pipes::send_packet_buffered<pingpong::ping,\n+        pingpong::packets>;\n+        type pong = pipes::recv_packet_buffered<pingpong::pong,\n+        pingpong::packets>;\n+    }\n+    mod server {\n+        type ping = pipes::recv_packet_buffered<pingpong::ping,\n+        pingpong::packets>;\n+        fn pong(+pipe: pong) -> ping {\n+            {\n+                let b = pipe.reuse_buffer();\n+                let s = send_packet_buffered(ptr::addr_of(b.buffer.data.ping));\n+                let c = recv_packet_buffered(ptr::addr_of(b.buffer.data.ping));\n+                let message = pingpong::pong(s);\n+                pipes::send(pipe, message);\n+                c\n+            }\n+        }\n+        type pong = pipes::send_packet_buffered<pingpong::pong,\n+        pingpong::packets>;\n+    }\n+}\n+\n+mod test {\n+    import pipes::recv;\n+    import pingpong::{ping, pong};\n+\n+    fn client(-chan: pingpong::client::ping) {\n+        import pingpong::client;\n+\n+        let chan = client::ping(chan); ret;\n+        log(error, \"Sent ping\");\n+        let pong(_chan) = recv(chan);\n+        log(error, \"Received pong\");\n+    }\n+    \n+    fn server(-chan: pingpong::server::ping) {\n+        import pingpong::server;\n+\n+        let ping(chan) = recv(chan); ret;\n+        log(error, \"Received ping\");\n+        let _chan = server::pong(chan);\n+        log(error, \"Sent pong\");\n+    }\n+}\n+\n+fn main() {\n+    let (client_, server_) = pingpong::init();\n+    let client_ = ~mut some(client_);\n+    let server_ = ~mut some(server_);\n+    do task::spawn |move client_| {\n+        let mut client__ = none;\n+        *client_ <-> client__;\n+        test::client(option::unwrap(client__));\n+    };\n+    do task::spawn |move server_| {\n+        let mut server_\u02ca = none;\n+        *server_ <-> server_\u02ca;\n+        test::server(option::unwrap(server_\u02ca));\n+    };\n+}"}]}