{"sha": "6877240fdf597533e2d3349454f62fdc40aaae54", "node_id": "C_kwDOAAsO6NoAKDY4NzcyNDBmZGY1OTc1MzNlMmQzMzQ5NDU0ZjYyZmRjNDBhYWFlNTQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-20T21:02:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-20T21:02:46Z"}, "message": "Merge #10563\n\n10563: feat: Make \"Generate getter\" assist use semantic info r=agluszak a=agluszak\n\nThis PR makes \"Generate getter\" assist use semantic info instead of dealing with types encoded as strings.\r\nGetters for types which are:\r\n- `Copy` no longer return references\r\n- `AsRef<str>` (i.e. `String`) return `&str` (instead of `&String`)\r\n- `AsRef<[T]>` (i.e. `Vec<T>`) return `&[T]` (instead of `&Vec<T>`)\r\n- `AsRef<T>` (i.e. `Box<T>`) return `&T` (instead of `&Box<T>`)\r\n- `Option<T>` return `Option<&T>` (instead of `&Option<T>`)\r\n- `Result<T, E>` return `Result<&T, &E>` (instead of `&Result<T, E>`)\r\n\r\nString, Vec, Box and Option were previously handled as special cases.\r\n\r\nCloses #10295\r\n\n\nCo-authored-by: Andrzej G\u0142uszak <gluszak.andrzej@gmail.com>", "tree": {"sha": "40a9803a4080ea144c35c9b550c7c4cb8211bfe7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40a9803a4080ea144c35c9b550c7c4cb8211bfe7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6877240fdf597533e2d3349454f62fdc40aaae54", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhcIP2CRBK7hj4Ov3rIwAAzl4IAKL0gntPZxyKoZjcydjdwLml\nTa7dNJyk752w3nYZydzHhhzRIt3jfsmzj4Wv3s0k4M0MLRX4eym2ccbR/VbKiRle\nSQOizLwD4pqG5+RWUyOh80iSa94uJiBf4bCO8Rz6Xui3+yl2ElfCF2dqcwrrcmlR\nFHuuUp0VGECoXn/2Hy/pzgbNuXo6Dkcrsx7CMAMyTwu+dWWRCxQd+h/aU7aySMXU\nX4z71SZTcaiK5eepGo76Vqi4hzc/iEtwkz7m2W83+Dbxsgv9m2dfGRRYJNU7wrQM\nXnZd6RMIsKwjQz80xj7+tPLAvG7eOrrgfJQUDinqQSBX5VeQOXlLw5HL9Qtn6Sc=\n=Kk8T\n-----END PGP SIGNATURE-----\n", "payload": "tree 40a9803a4080ea144c35c9b550c7c4cb8211bfe7\nparent 11326a6847f7fd43afef1806779082f96264d9c6\nparent 88e2f0782693b73d71d7bbf13d584c4aa37fd834\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1634763766 +0000\ncommitter GitHub <noreply@github.com> 1634763766 +0000\n\nMerge #10563\n\n10563: feat: Make \"Generate getter\" assist use semantic info r=agluszak a=agluszak\n\nThis PR makes \"Generate getter\" assist use semantic info instead of dealing with types encoded as strings.\r\nGetters for types which are:\r\n- `Copy` no longer return references\r\n- `AsRef<str>` (i.e. `String`) return `&str` (instead of `&String`)\r\n- `AsRef<[T]>` (i.e. `Vec<T>`) return `&[T]` (instead of `&Vec<T>`)\r\n- `AsRef<T>` (i.e. `Box<T>`) return `&T` (instead of `&Box<T>`)\r\n- `Option<T>` return `Option<&T>` (instead of `&Option<T>`)\r\n- `Result<T, E>` return `Result<&T, &E>` (instead of `&Result<T, E>`)\r\n\r\nString, Vec, Box and Option were previously handled as special cases.\r\n\r\nCloses #10295\r\n\n\nCo-authored-by: Andrzej G\u0142uszak <gluszak.andrzej@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6877240fdf597533e2d3349454f62fdc40aaae54", "html_url": "https://github.com/rust-lang/rust/commit/6877240fdf597533e2d3349454f62fdc40aaae54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6877240fdf597533e2d3349454f62fdc40aaae54/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11326a6847f7fd43afef1806779082f96264d9c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/11326a6847f7fd43afef1806779082f96264d9c6", "html_url": "https://github.com/rust-lang/rust/commit/11326a6847f7fd43afef1806779082f96264d9c6"}, {"sha": "88e2f0782693b73d71d7bbf13d584c4aa37fd834", "url": "https://api.github.com/repos/rust-lang/rust/commits/88e2f0782693b73d71d7bbf13d584c4aa37fd834", "html_url": "https://github.com/rust-lang/rust/commit/88e2f0782693b73d71d7bbf13d584c4aa37fd834"}], "stats": {"total": 442, "additions": 383, "deletions": 59}, "files": [{"sha": "9e3dc998bf51da4541604201db8d410073966240", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=6877240fdf597533e2d3349454f62fdc40aaae54", "patch": "@@ -1574,6 +1574,10 @@ pub struct BuiltinType {\n }\n \n impl BuiltinType {\n+    pub fn str() -> BuiltinType {\n+        BuiltinType { inner: hir_def::builtin_type::BuiltinType::Str }\n+    }\n+\n     pub fn ty(self, db: &dyn HirDatabase, module: Module) -> Type {\n         let resolver = module.id.resolver(db.upcast());\n         Type::new_with_resolver(db, &resolver, TyBuilder::builtin(self.inner))\n@@ -2263,6 +2267,10 @@ impl Type {\n         Type::new(db, krate, def, ty)\n     }\n \n+    pub fn new_slice(ty: Type) -> Type {\n+        Type { krate: ty.krate, env: ty.env, ty: TyBuilder::slice(ty.ty) }\n+    }\n+\n     pub fn is_unit(&self) -> bool {\n         matches!(self.ty.kind(&Interner), TyKind::Tuple(0, ..))\n     }"}, {"sha": "add0390c9477f4f9627a44e2063149fef7ac863c", "filename": "crates/hir_ty/src/builder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs?ref=6877240fdf597533e2d3349454f62fdc40aaae54", "patch": "@@ -97,6 +97,10 @@ impl TyBuilder<()> {\n         }\n     }\n \n+    pub fn slice(argument: Ty) -> Ty {\n+        TyKind::Slice(argument).intern(&Interner)\n+    }\n+\n     pub fn type_params_subst(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> Substitution {\n         let params = generics(db.upcast(), def.into());\n         params.type_params_subst(db)"}, {"sha": "b6cec50038debf643cc4a70bedbf69b7d1b04ddd", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=6877240fdf597533e2d3349454f62fdc40aaae54", "patch": "@@ -2268,8 +2268,8 @@ fn foo() {\n                                     file_id: FileId(\n                                         1,\n                                     ),\n-                                    full_range: 254..436,\n-                                    focus_range: 293..299,\n+                                    full_range: 276..458,\n+                                    focus_range: 315..321,\n                                     name: \"Future\",\n                                     kind: Trait,\n                                     description: \"pub trait Future\","}, {"sha": "edc4697f2ca37e245b1429073024d3581d089e92", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=6877240fdf597533e2d3349454f62fdc40aaae54", "patch": "@@ -1,11 +1,13 @@\n+use rustc_hash::{FxHashMap, FxHashSet};\n+\n use hir::{HasSource, HirDisplay, Module, ModuleDef, Semantics, TypeInfo};\n+use ide_db::helpers::FamousDefs;\n use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameRefClass},\n     helpers::SnippetCap,\n     RootDatabase,\n };\n-use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::to_lower_snake_case;\n use syntax::{\n     ast::{\n@@ -17,7 +19,7 @@ use syntax::{\n };\n \n use crate::{\n-    utils::useless_type_special_case,\n+    utils::convert_reference_type,\n     utils::{find_struct_impl, render_snippet, Cursor},\n     AssistContext, AssistId, AssistKind, Assists,\n };\n@@ -424,19 +426,7 @@ fn fn_args(\n     let mut arg_types = Vec::new();\n     for arg in call.arg_list()?.args() {\n         arg_names.push(fn_arg_name(&ctx.sema, &arg));\n-        arg_types.push(match fn_arg_type(ctx, target_module, &arg) {\n-            Some(ty) => {\n-                if !ty.is_empty() && ty.starts_with('&') {\n-                    match useless_type_special_case(\"\", &ty[1..].to_owned()) {\n-                        Some((new_ty, _)) => new_ty,\n-                        None => ty,\n-                    }\n-                } else {\n-                    ty\n-                }\n-            }\n-            None => String::from(\"_\"),\n-        });\n+        arg_types.push(fn_arg_type(ctx, target_module, &arg));\n     }\n     deduplicate_arg_names(&mut arg_names);\n     let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| {\n@@ -511,17 +501,28 @@ fn fn_arg_name(sema: &Semantics<RootDatabase>, arg_expr: &ast::Expr) -> String {\n     }\n }\n \n-fn fn_arg_type(\n-    ctx: &AssistContext,\n-    target_module: hir::Module,\n-    fn_arg: &ast::Expr,\n-) -> Option<String> {\n-    let ty = ctx.sema.type_of_expr(fn_arg)?.adjusted();\n-    if ty.is_unknown() {\n-        return None;\n+fn fn_arg_type(ctx: &AssistContext, target_module: hir::Module, fn_arg: &ast::Expr) -> String {\n+    fn maybe_displayed_type(\n+        ctx: &AssistContext,\n+        target_module: hir::Module,\n+        fn_arg: &ast::Expr,\n+    ) -> Option<String> {\n+        let ty = ctx.sema.type_of_expr(fn_arg)?.adjusted();\n+        if ty.is_unknown() {\n+            return None;\n+        }\n+\n+        if ty.is_reference() || ty.is_mutable_reference() {\n+            let famous_defs = &FamousDefs(&ctx.sema, ctx.sema.scope(fn_arg.syntax()).krate());\n+            convert_reference_type(ty.strip_references(), ctx.db(), famous_defs)\n+                .map(|conversion| conversion.convert_type(ctx.db()))\n+                .or_else(|| ty.display_source_code(ctx.db(), target_module.into()).ok())\n+        } else {\n+            ty.display_source_code(ctx.db(), target_module.into()).ok()\n+        }\n     }\n \n-    ty.display_source_code(ctx.db(), target_module.into()).ok()\n+    maybe_displayed_type(ctx, target_module, fn_arg).unwrap_or_else(|| String::from(\"_\"))\n }\n \n /// Returns the position inside the current mod or file"}, {"sha": "81cf72dd713be5d30b1dd7629705e2f71de384f1", "filename": "crates/ide_assists/src/handlers/generate_getter.rs", "status": "modified", "additions": 163, "deletions": 8, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs?ref=6877240fdf597533e2d3349454f62fdc40aaae54", "patch": "@@ -1,9 +1,9 @@\n+use ide_db::helpers::FamousDefs;\n use stdx::{format_to, to_lower_snake_case};\n use syntax::ast::{self, AstNode, HasName, HasVisibility};\n \n use crate::{\n-    utils::useless_type_special_case,\n-    utils::{find_impl_block_end, find_struct_impl, generate_impl_text},\n+    utils::{convert_reference_type, find_impl_block_end, find_struct_impl, generate_impl_text},\n     AssistContext, AssistId, AssistKind, Assists, GroupLabel,\n };\n \n@@ -12,20 +12,35 @@ use crate::{\n // Generate a getter method.\n //\n // ```\n+// # //- minicore: as_ref\n+// # pub struct String;\n+// # impl AsRef<str> for String {\n+// #     fn as_ref(&self) -> &str {\n+// #         \"\"\n+// #     }\n+// # }\n+// #\n // struct Person {\n //     nam$0e: String,\n // }\n // ```\n // ->\n // ```\n+// # pub struct String;\n+// # impl AsRef<str> for String {\n+// #     fn as_ref(&self) -> &str {\n+// #         \"\"\n+// #     }\n+// # }\n+// #\n // struct Person {\n //     name: String,\n // }\n //\n // impl Person {\n //     /// Get a reference to the person's name.\n //     fn $0name(&self) -> &str {\n-//         self.name.as_str()\n+//         self.name.as_ref()\n //     }\n // }\n // ```\n@@ -100,7 +115,17 @@ pub(crate) fn generate_getter_impl(\n             let (ty, body) = if mutable {\n                 (format!(\"&mut {}\", field_ty), format!(\"&mut self.{}\", field_name))\n             } else {\n-                useless_type_special_case(&field_name.to_string(), &field_ty.to_string())\n+                let famous_defs = &FamousDefs(&ctx.sema, ctx.sema.scope(field_ty.syntax()).krate());\n+                ctx.sema\n+                    .resolve_type(&field_ty)\n+                    .and_then(|ty| convert_reference_type(ty, ctx.db(), famous_defs))\n+                    .map(|conversion| {\n+                        cov_mark::hit!(convert_reference_type);\n+                        (\n+                            conversion.convert_type(ctx.db()),\n+                            conversion.getter(field_name.to_string()),\n+                        )\n+                    })\n                     .unwrap_or_else(|| (format!(\"&{}\", field_ty), format!(\"&self.{}\", field_name)))\n             };\n \n@@ -284,30 +309,113 @@ impl Context {\n     }\n \n     #[test]\n-    fn test_special_cases() {\n-        cov_mark::check!(useless_type_special_case);\n+    fn test_not_a_special_case() {\n+        cov_mark::check_count!(convert_reference_type, 0);\n+        // Fake string which doesn't implement AsRef<str>\n         check_assist(\n             generate_getter,\n             r#\"\n+pub struct String;\n+\n struct S { foo: $0String }\n \"#,\n             r#\"\n+pub struct String;\n+\n+struct S { foo: String }\n+\n+impl S {\n+    /// Get a reference to the s's foo.\n+    fn $0foo(&self) -> &String {\n+        &self.foo\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_convert_reference_type() {\n+        cov_mark::check_count!(convert_reference_type, 6);\n+\n+        // Copy\n+        check_assist(\n+            generate_getter,\n+            r#\"\n+//- minicore: copy\n+struct S { foo: $0bool }\n+\"#,\n+            r#\"\n+struct S { foo: bool }\n+\n+impl S {\n+    /// Get a reference to the s's foo.\n+    fn $0foo(&self) -> bool {\n+        self.foo\n+    }\n+}\n+\"#,\n+        );\n+\n+        // AsRef<str>\n+        check_assist(\n+            generate_getter,\n+            r#\"\n+//- minicore: as_ref\n+pub struct String;\n+impl AsRef<str> for String {\n+    fn as_ref(&self) -> &str {\n+        \"\"\n+    }\n+}\n+\n+struct S { foo: $0String }\n+\"#,\n+            r#\"\n+pub struct String;\n+impl AsRef<str> for String {\n+    fn as_ref(&self) -> &str {\n+        \"\"\n+    }\n+}\n+\n struct S { foo: String }\n \n impl S {\n     /// Get a reference to the s's foo.\n     fn $0foo(&self) -> &str {\n-        self.foo.as_str()\n+        self.foo.as_ref()\n     }\n }\n \"#,\n         );\n+\n+        // AsRef<T>\n         check_assist(\n             generate_getter,\n             r#\"\n+//- minicore: as_ref\n+struct Sweets;\n+\n+pub struct Box<T>(T);\n+impl<T> AsRef<T> for Box<T> {\n+    fn as_ref(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n struct S { foo: $0Box<Sweets> }\n \"#,\n             r#\"\n+struct Sweets;\n+\n+pub struct Box<T>(T);\n+impl<T> AsRef<T> for Box<T> {\n+    fn as_ref(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n struct S { foo: Box<Sweets> }\n \n impl S {\n@@ -318,28 +426,52 @@ impl S {\n }\n \"#,\n         );\n+\n+        // AsRef<[T]>\n         check_assist(\n             generate_getter,\n             r#\"\n+//- minicore: as_ref\n+pub struct Vec<T>;\n+impl<T> AsRef<[T]> for Vec<T> {\n+    fn as_ref(&self) -> &[T] {\n+        &[]\n+    }\n+}\n+\n struct S { foo: $0Vec<()> }\n \"#,\n             r#\"\n+pub struct Vec<T>;\n+impl<T> AsRef<[T]> for Vec<T> {\n+    fn as_ref(&self) -> &[T] {\n+        &[]\n+    }\n+}\n+\n struct S { foo: Vec<()> }\n \n impl S {\n     /// Get a reference to the s's foo.\n     fn $0foo(&self) -> &[()] {\n-        self.foo.as_slice()\n+        self.foo.as_ref()\n     }\n }\n \"#,\n         );\n+\n+        // Option\n         check_assist(\n             generate_getter,\n             r#\"\n+//- minicore: option\n+struct Failure;\n+\n struct S { foo: $0Option<Failure> }\n \"#,\n             r#\"\n+struct Failure;\n+\n struct S { foo: Option<Failure> }\n \n impl S {\n@@ -348,6 +480,29 @@ impl S {\n         self.foo.as_ref()\n     }\n }\n+\"#,\n+        );\n+\n+        // Result\n+        check_assist(\n+            generate_getter,\n+            r#\"\n+//- minicore: result\n+struct Context {\n+    dat$0a: Result<bool, i32>,\n+}\n+\"#,\n+            r#\"\n+struct Context {\n+    data: Result<bool, i32>,\n+}\n+\n+impl Context {\n+    /// Get a reference to the context's data.\n+    fn $0data(&self) -> Result<&bool, &i32> {\n+        self.data.as_ref()\n+    }\n+}\n \"#,\n         );\n     }"}, {"sha": "6c5eaf310c51e42cdf8d0ee546667680e4b6c3fc", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=6877240fdf597533e2d3349454f62fdc40aaae54", "patch": "@@ -951,19 +951,34 @@ fn doctest_generate_getter() {\n     check_doc_test(\n         \"generate_getter\",\n         r#####\"\n+//- minicore: as_ref\n+pub struct String;\n+impl AsRef<str> for String {\n+    fn as_ref(&self) -> &str {\n+        \"\"\n+    }\n+}\n+\n struct Person {\n     nam$0e: String,\n }\n \"#####,\n         r#####\"\n+pub struct String;\n+impl AsRef<str> for String {\n+    fn as_ref(&self) -> &str {\n+        \"\"\n+    }\n+}\n+\n struct Person {\n     name: String,\n }\n \n impl Person {\n     /// Get a reference to the person's name.\n     fn $0name(&self) -> &str {\n-        self.name.as_str()\n+        self.name.as_ref()\n     }\n }\n \"#####,"}, {"sha": "fd0ff2f5cbf852a20a0dbc2d3d392ecb899f99c6", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 146, "deletions": 22, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=6877240fdf597533e2d3349454f62fdc40aaae54", "patch": "@@ -1,13 +1,14 @@\n //! Assorted functions shared by several assists.\n \n-pub(crate) mod suggest_name;\n-mod gen_trait_fn_body;\n-\n use std::ops;\n \n-use hir::HasSource;\n-use ide_db::{helpers::SnippetCap, path_transform::PathTransform, RootDatabase};\n use itertools::Itertools;\n+\n+pub(crate) use gen_trait_fn_body::gen_trait_fn_body;\n+use hir::{db::HirDatabase, HasSource, HirDisplay};\n+use ide_db::{\n+    helpers::FamousDefs, helpers::SnippetCap, path_transform::PathTransform, RootDatabase,\n+};\n use stdx::format_to;\n use syntax::{\n     ast::{\n@@ -23,7 +24,8 @@ use syntax::{\n \n use crate::assist_context::{AssistBuilder, AssistContext};\n \n-pub(crate) use gen_trait_fn_body::gen_trait_fn_body;\n+pub(crate) mod suggest_name;\n+mod gen_trait_fn_body;\n \n pub(crate) fn unwrap_trivial_block(block_expr: ast::BlockExpr) -> ast::Expr {\n     extract_trivial_expression(&block_expr)\n@@ -507,27 +509,149 @@ pub(crate) fn add_method_to_adt(\n     builder.insert(start_offset, buf);\n }\n \n-pub fn useless_type_special_case(field_name: &str, field_ty: &String) -> Option<(String, String)> {\n-    if field_ty == \"String\" {\n-        cov_mark::hit!(useless_type_special_case);\n-        return Some((\"&str\".to_string(), format!(\"self.{}.as_str()\", field_name)));\n-    }\n-    if let Some(arg) = ty_ctor(field_ty, \"Vec\") {\n-        return Some((format!(\"&[{}]\", arg), format!(\"self.{}.as_slice()\", field_name)));\n+#[derive(Debug)]\n+pub(crate) struct ReferenceConversion {\n+    conversion: ReferenceConversionType,\n+    ty: hir::Type,\n+}\n+\n+#[derive(Debug)]\n+enum ReferenceConversionType {\n+    // reference can be stripped if the type is Copy\n+    Copy,\n+    // &String -> &str\n+    AsRefStr,\n+    // &Vec<T> -> &[T]\n+    AsRefSlice,\n+    // &Box<T> -> &T\n+    Dereferenced,\n+    // &Option<T> -> Option<&T>\n+    Option,\n+    // &Result<T, E> -> Result<&T, &E>\n+    Result,\n+}\n+\n+impl ReferenceConversion {\n+    pub(crate) fn convert_type(&self, db: &dyn HirDatabase) -> String {\n+        match self.conversion {\n+            ReferenceConversionType::Copy => self.ty.display(db).to_string(),\n+            ReferenceConversionType::AsRefStr => \"&str\".to_string(),\n+            ReferenceConversionType::AsRefSlice => {\n+                let type_argument_name =\n+                    self.ty.type_arguments().next().unwrap().display(db).to_string();\n+                format!(\"&[{}]\", type_argument_name)\n+            }\n+            ReferenceConversionType::Dereferenced => {\n+                let type_argument_name =\n+                    self.ty.type_arguments().next().unwrap().display(db).to_string();\n+                format!(\"&{}\", type_argument_name)\n+            }\n+            ReferenceConversionType::Option => {\n+                let type_argument_name =\n+                    self.ty.type_arguments().next().unwrap().display(db).to_string();\n+                format!(\"Option<&{}>\", type_argument_name)\n+            }\n+            ReferenceConversionType::Result => {\n+                let mut type_arguments = self.ty.type_arguments();\n+                let first_type_argument_name =\n+                    type_arguments.next().unwrap().display(db).to_string();\n+                let second_type_argument_name =\n+                    type_arguments.next().unwrap().display(db).to_string();\n+                format!(\"Result<&{}, &{}>\", first_type_argument_name, second_type_argument_name)\n+            }\n+        }\n     }\n-    if let Some(arg) = ty_ctor(field_ty, \"Box\") {\n-        return Some((format!(\"&{}\", arg), format!(\"self.{}.as_ref()\", field_name)));\n+\n+    pub(crate) fn getter(&self, field_name: String) -> String {\n+        match self.conversion {\n+            ReferenceConversionType::Copy => format!(\"self.{}\", field_name),\n+            ReferenceConversionType::AsRefStr\n+            | ReferenceConversionType::AsRefSlice\n+            | ReferenceConversionType::Dereferenced\n+            | ReferenceConversionType::Option\n+            | ReferenceConversionType::Result => format!(\"self.{}.as_ref()\", field_name),\n+        }\n     }\n-    if let Some(arg) = ty_ctor(field_ty, \"Option\") {\n-        return Some((format!(\"Option<&{}>\", arg), format!(\"self.{}.as_ref()\", field_name)));\n+}\n+\n+// FIXME: It should return a new hir::Type, but currently constructing new types is too cumbersome\n+//        and all users of this function operate on string type names, so they can do the conversion\n+//        itself themselves.\n+pub(crate) fn convert_reference_type(\n+    ty: hir::Type,\n+    db: &RootDatabase,\n+    famous_defs: &FamousDefs,\n+) -> Option<ReferenceConversion> {\n+    handle_copy(&ty, db)\n+        .or_else(|| handle_as_ref_str(&ty, db, famous_defs))\n+        .or_else(|| handle_as_ref_slice(&ty, db, famous_defs))\n+        .or_else(|| handle_dereferenced(&ty, db, famous_defs))\n+        .or_else(|| handle_option_as_ref(&ty, db, famous_defs))\n+        .or_else(|| handle_result_as_ref(&ty, db, famous_defs))\n+        .map(|conversion| ReferenceConversion { ty, conversion })\n+}\n+\n+fn handle_copy(ty: &hir::Type, db: &dyn HirDatabase) -> Option<ReferenceConversionType> {\n+    ty.is_copy(db).then(|| ReferenceConversionType::Copy)\n+}\n+\n+fn handle_as_ref_str(\n+    ty: &hir::Type,\n+    db: &dyn HirDatabase,\n+    famous_defs: &FamousDefs,\n+) -> Option<ReferenceConversionType> {\n+    let module = famous_defs.1?.root_module(db);\n+    let str_type = hir::BuiltinType::str().ty(db, module);\n+\n+    ty.impls_trait(db, famous_defs.core_convert_AsRef()?, &[str_type])\n+        .then(|| ReferenceConversionType::AsRefStr)\n+}\n+\n+fn handle_as_ref_slice(\n+    ty: &hir::Type,\n+    db: &dyn HirDatabase,\n+    famous_defs: &FamousDefs,\n+) -> Option<ReferenceConversionType> {\n+    let type_argument = ty.type_arguments().next()?;\n+    let slice_type = hir::Type::new_slice(type_argument);\n+\n+    ty.impls_trait(db, famous_defs.core_convert_AsRef()?, &[slice_type])\n+        .then(|| ReferenceConversionType::AsRefSlice)\n+}\n+\n+fn handle_dereferenced(\n+    ty: &hir::Type,\n+    db: &dyn HirDatabase,\n+    famous_defs: &FamousDefs,\n+) -> Option<ReferenceConversionType> {\n+    let type_argument = ty.type_arguments().next()?;\n+\n+    ty.impls_trait(db, famous_defs.core_convert_AsRef()?, &[type_argument])\n+        .then(|| ReferenceConversionType::Dereferenced)\n+}\n+\n+fn handle_option_as_ref(\n+    ty: &hir::Type,\n+    db: &dyn HirDatabase,\n+    famous_defs: &FamousDefs,\n+) -> Option<ReferenceConversionType> {\n+    if ty.as_adt() == famous_defs.core_option_Option()?.ty(db).as_adt() {\n+        Some(ReferenceConversionType::Option)\n+    } else {\n+        None\n     }\n-    None\n }\n \n-// FIXME: This should rely on semantic info.\n-fn ty_ctor(ty: &String, ctor: &str) -> Option<String> {\n-    let res = ty.to_string().strip_prefix(ctor)?.strip_prefix('<')?.strip_suffix('>')?.to_string();\n-    Some(res)\n+fn handle_result_as_ref(\n+    ty: &hir::Type,\n+    db: &dyn HirDatabase,\n+    famous_defs: &FamousDefs,\n+) -> Option<ReferenceConversionType> {\n+    if ty.as_adt() == famous_defs.core_result_Result()?.ty(db).as_adt() {\n+        Some(ReferenceConversionType::Result)\n+    } else {\n+        None\n+    }\n }\n \n pub(crate) fn get_methods(items: &ast::AssocItemList) -> Vec<ast::Fn> {"}, {"sha": "b5e3907cfa746e2bc6d402f699457f434d812b54", "filename": "crates/ide_db/src/helpers/famous_defs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fide_db%2Fsrc%2Fhelpers%2Ffamous_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Fide_db%2Fsrc%2Fhelpers%2Ffamous_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Ffamous_defs.rs?ref=6877240fdf597533e2d3349454f62fdc40aaae54", "patch": "@@ -68,10 +68,18 @@ impl FamousDefs<'_, '_> {\n         self.find_trait(\"core:ops:Deref\")\n     }\n \n+    pub fn core_convert_AsRef(&self) -> Option<Trait> {\n+        self.find_trait(\"core:convert:AsRef\")\n+    }\n+\n     pub fn core_ops_ControlFlow(&self) -> Option<Enum> {\n         self.find_enum(\"core:ops:ControlFlow\")\n     }\n \n+    pub fn core_marker_Copy(&self) -> Option<Trait> {\n+        self.find_trait(\"core:marker:Copy\")\n+    }\n+\n     pub fn alloc(&self) -> Option<Crate> {\n         self.find_crate(\"alloc\")\n     }"}, {"sha": "8801567fa5d7f91185e1b8cd11bc6aad455bae22", "filename": "crates/test_utils/src/minicore.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6877240fdf597533e2d3349454f62fdc40aaae54/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fminicore.rs?ref=6877240fdf597533e2d3349454f62fdc40aaae54", "patch": "@@ -35,6 +35,7 @@\n //!     fmt: result\n //!     bool_impl: option, fn\n //!     add:\n+//!     as_ref: sized\n \n pub mod marker {\n     // region:sized\n@@ -117,8 +118,9 @@ pub mod clone {\n }\n // endregion:clone\n \n-// region:from\n+\n pub mod convert {\n+    // region:from\n     pub trait From<T>: Sized {\n         fn from(_: T) -> Self;\n     }\n@@ -140,8 +142,14 @@ pub mod convert {\n             t\n         }\n     }\n+    // endregion:from\n+\n+    // region:as_ref\n+    pub trait AsRef<T: ?Sized> {\n+        fn as_ref(&self) -> &T;\n+    }\n+    // endregion:as_ref\n }\n-// endregion:from\n \n pub mod ops {\n     // region:coerce_unsized\n@@ -613,6 +621,7 @@ pub mod prelude {\n             cmp::{Eq, PartialEq},               // :eq\n             cmp::{Ord, PartialOrd},             // :ord\n             convert::{From, Into},              // :from\n+            convert::AsRef,                     // :as_ref\n             default::Default,                   // :default\n             iter::{IntoIterator, Iterator},     // :iterator\n             macros::builtin::derive,            // :derive"}]}