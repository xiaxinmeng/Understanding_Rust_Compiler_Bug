{"sha": "2d8651a92761421b0437ffb44ba5670bea5ee1df", "node_id": "C_kwDOAAsO6NoAKDJkODY1MWE5Mjc2MTQyMWIwNDM3ZmZiNDRiYTU2NzBiZWE1ZWUxZGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-22T11:06:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-22T11:06:51Z"}, "message": "Auto merge of #106034 - matthiaskrgr:rollup-2zpql33, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #104741 (Switch `#[track_caller]` back to a no-op unless feature gate is enabled)\n - #105769 (add function to tell the identical errors for ambiguity_errors)\n - #105843 (Suggest associated const on possible capitalization mistake)\n - #105966 (Re-enable `Fn` trait call notation error for non-tuple argument)\n - #106002 (codegen tests: adapt patterns to also work with v0 symbol mangling)\n - #106010 (Give opaque types a better coherence error)\n - #106016 (rustdoc: simplify link anchor to section expand JS)\n - #106024 (Fix ICE due to `todo!()` in `rustdoc` for `Term`s)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "eaeaa01be5cc193d6bdc3cbcf302484992bd879a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaeaa01be5cc193d6bdc3cbcf302484992bd879a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d8651a92761421b0437ffb44ba5670bea5ee1df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d8651a92761421b0437ffb44ba5670bea5ee1df", "html_url": "https://github.com/rust-lang/rust/commit/2d8651a92761421b0437ffb44ba5670bea5ee1df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d8651a92761421b0437ffb44ba5670bea5ee1df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cce9e72c55994335f8d1dac892cca755b65c8f43", "url": "https://api.github.com/repos/rust-lang/rust/commits/cce9e72c55994335f8d1dac892cca755b65c8f43", "html_url": "https://github.com/rust-lang/rust/commit/cce9e72c55994335f8d1dac892cca755b65c8f43"}, {"sha": "d2130e42749ae6144edead4427eb66fa458d8a67", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2130e42749ae6144edead4427eb66fa458d8a67", "html_url": "https://github.com/rust-lang/rust/commit/d2130e42749ae6144edead4427eb66fa458d8a67"}], "stats": {"total": 540, "additions": 414, "deletions": 126}, "files": [{"sha": "3634e6e47ce12e220d3b64f2fa4e6be9eb8b004d", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -656,18 +656,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir::ExprKind::Closure(c)\n         };\n \n-        let track_caller = self\n-            .attrs\n-            .get(&outer_hir_id.local_id)\n-            .map_or(false, |attrs| attrs.into_iter().any(|attr| attr.has_name(sym::track_caller)));\n-\n         let hir_id = self.lower_node_id(closure_node_id);\n-        if track_caller {\n-            let unstable_span = self.mark_span_with_reason(\n-                DesugaringKind::Async,\n-                span,\n-                self.allow_gen_future.clone(),\n-            );\n+        let unstable_span =\n+            self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n+\n+        if self.tcx.features().closure_track_caller\n+            && let Some(attrs) = self.attrs.get(&outer_hir_id.local_id)\n+            && attrs.into_iter().any(|attr| attr.has_name(sym::track_caller))\n+        {\n             self.lower_attrs(\n                 hir_id,\n                 &[Attribute {"}, {"sha": "2eb409a5ddd5e12297262ade97e6bb20ce48dd06", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -350,6 +350,9 @@ lint_builtin_mutable_transmutes =\n \n lint_builtin_unstable_features = unstable feature\n \n+lint_ungated_async_fn_track_caller = `#[track_caller]` on async functions is a no-op\n+     .label = this function will not propagate the caller location\n+\n lint_builtin_unreachable_pub = unreachable `pub` {$what}\n     .suggestion = consider restricting its visibility\n     .help = or consider exporting it for use by other crates"}, {"sha": "c6d4aeefc80e5e7883862065b6b6fe5fd63ba6d0", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -184,11 +184,19 @@ fn emit_orphan_check_error<'tcx>(\n                     ty::Adt(def, _) => tcx.mk_adt(*def, ty::List::empty()),\n                     _ => ty,\n                 };\n-                let this = \"this\".to_string();\n-                let (ty, postfix) = match &ty.kind() {\n-                    ty::Slice(_) => (this, \" because slices are always foreign\"),\n-                    ty::Array(..) => (this, \" because arrays are always foreign\"),\n-                    ty::Tuple(..) => (this, \" because tuples are always foreign\"),\n+                let msg = |ty: &str, postfix: &str| {\n+                    format!(\"{ty} is not defined in the current crate{postfix}\")\n+                };\n+                let this = |name: &str| msg(\"this\", &format!(\" because {name} are always foreign\"));\n+                let msg = match &ty.kind() {\n+                    ty::Slice(_) => this(\"slices\"),\n+                    ty::Array(..) => this(\"arrays\"),\n+                    ty::Tuple(..) => this(\"tuples\"),\n+                    ty::Alias(ty::Opaque, ..) => {\n+                        \"type alias impl trait is treated as if it were foreign, \\\n+                        because its hidden type could be from a foreign crate\"\n+                            .to_string()\n+                    }\n                     ty::RawPtr(ptr_ty) => {\n                         emit_newtype_suggestion_for_raw_ptr(\n                             full_impl_span,\n@@ -198,12 +206,11 @@ fn emit_orphan_check_error<'tcx>(\n                             &mut err,\n                         );\n \n-                        (format!(\"`{}`\", ty), \" because raw pointers are always foreign\")\n+                        msg(&format!(\"`{ty}`\"), \" because raw pointers are always foreign\")\n                     }\n-                    _ => (format!(\"`{}`\", ty), \"\"),\n+                    _ => msg(&format!(\"`{ty}`\"), \"\"),\n                 };\n \n-                let msg = format!(\"{} is not defined in the current crate{}\", ty, postfix);\n                 if is_target_ty {\n                     // Point at `D<A>` in `impl<A, B> for C<B> in D<A>`\n                     err.span_label(self_ty_span, &msg);"}, {"sha": "e68bd1297c87865d58574f933ec4b5e138d885ad", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -23,24 +23,24 @@ use std::cmp::min;\n use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn emit_coerce_suggestions(\n+    pub fn emit_type_mismatch_suggestions(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'tcx>,\n         expr_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n-        error: Option<TypeError<'tcx>>,\n+        _error: Option<TypeError<'tcx>>,\n     ) {\n         if expr_ty == expected {\n             return;\n         }\n \n-        self.annotate_expected_due_to_let_ty(err, expr, error);\n-\n         // Use `||` to give these suggestions a precedence\n         let _ = self.suggest_missing_parentheses(err, expr)\n+            || self.suggest_associated_const(err, expr, expected)\n             || self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr)\n+            || self.suggest_option_to_bool(err, expr, expr_ty, expected)\n             || self.suggest_compatible_variants(err, expr, expected, expr_ty)\n             || self.suggest_non_zero_new_unwrap(err, expr, expected, expr_ty)\n             || self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty)\n@@ -49,9 +49,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected)\n             || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n             || self.suggest_into(err, expr, expr_ty, expected)\n-            || self.suggest_option_to_bool(err, expr, expr_ty, expected)\n             || self.suggest_floating_point_literal(err, expr, expected);\n+    }\n \n+    pub fn emit_coerce_suggestions(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'tcx>,\n+        expr_ty: Ty<'tcx>,\n+        expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n+        error: Option<TypeError<'tcx>>,\n+    ) {\n+        if expr_ty == expected {\n+            return;\n+        }\n+\n+        self.annotate_expected_due_to_let_ty(err, expr, error);\n+        self.emit_type_mismatch_suggestions(err, expr, expr_ty, expected, expected_ty_expr, error);\n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);"}, {"sha": "ae641b26eeedbb48898bb1019e747c217b57833a", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -104,16 +104,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            // FIXME(compiler-errors): We probably should fold some of the\n-            // `suggest_` functions from  `emit_coerce_suggestions` into here,\n-            // since some of those aren't necessarily just coerce suggestions.\n-            let _ = self.suggest_deref_ref_or_into(\n+            let _ = self.emit_type_mismatch_suggestions(\n                 &mut err,\n                 expr.peel_drop_temps(),\n-                expected_ty,\n                 ty,\n+                expected_ty,\n                 None,\n-            ) || self.suggest_option_to_bool(&mut err, expr, ty, expected_ty);\n+                None,\n+            );\n             extend_err(&mut err);\n             err.emit();\n         }"}, {"sha": "877680053f09061e3966a480f9ad5b68ae5bbe12", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -214,7 +214,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \"cannot use call notation; the first type parameter \\\n                          for the function trait is neither a tuple nor unit\"\n                     )\n-                    .delay_as_bug();\n+                    .emit();\n                     (self.err_args(provided_args.len()), None)\n                 }\n             }"}, {"sha": "efec0244633340e6947783902d2b1db102ba1bea", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 82, "deletions": 2, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -1,6 +1,7 @@\n use super::FnCtxt;\n \n use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n+use crate::method::probe::{IsSuggestion, Mode, ProbeScope};\n use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n@@ -15,10 +16,11 @@ use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{\n     self, suggest_constraining_type_params, Binder, DefIdTree, IsSuggestable, ToPredicate, Ty,\n+    TypeVisitable,\n };\n use rustc_session::errors::ExprParenthesesNeeded;\n-use rustc_span::symbol::sym;\n-use rustc_span::Span;\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::DefIdOrName;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -1236,6 +1238,84 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub(crate) fn suggest_associated_const(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> bool {\n+        let Some((DefKind::AssocFn, old_def_id)) = self.typeck_results.borrow().type_dependent_def(expr.hir_id) else {\n+            return false;\n+        };\n+        let old_item_name = self.tcx.item_name(old_def_id);\n+        let capitalized_name = Symbol::intern(&old_item_name.as_str().to_uppercase());\n+        if old_item_name == capitalized_name {\n+            return false;\n+        }\n+        let (item, segment) = match expr.kind {\n+            hir::ExprKind::Path(QPath::Resolved(\n+                Some(ty),\n+                hir::Path { segments: [segment], .. },\n+            ))\n+            | hir::ExprKind::Path(QPath::TypeRelative(ty, segment)) => {\n+                let self_ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n+                if let Ok(pick) = self.probe_for_name(\n+                    Mode::Path,\n+                    Ident::new(capitalized_name, segment.ident.span),\n+                    IsSuggestion(true),\n+                    self_ty,\n+                    expr.hir_id,\n+                    ProbeScope::TraitsInScope,\n+                ) {\n+                    (pick.item, segment)\n+                } else {\n+                    return false;\n+                }\n+            }\n+            hir::ExprKind::Path(QPath::Resolved(\n+                None,\n+                hir::Path { segments: [.., segment], .. },\n+            )) => {\n+                // we resolved through some path that doesn't end in the item name,\n+                // better not do a bad suggestion by accident.\n+                if old_item_name != segment.ident.name {\n+                    return false;\n+                }\n+                if let Some(item) = self\n+                    .tcx\n+                    .associated_items(self.tcx.parent(old_def_id))\n+                    .filter_by_name_unhygienic(capitalized_name)\n+                    .next()\n+                {\n+                    (*item, segment)\n+                } else {\n+                    return false;\n+                }\n+            }\n+            _ => return false,\n+        };\n+        if item.def_id == old_def_id || self.tcx.def_kind(item.def_id) != DefKind::AssocConst {\n+            // Same item\n+            return false;\n+        }\n+        let item_ty = self.tcx.type_of(item.def_id);\n+        // FIXME(compiler-errors): This check is *so* rudimentary\n+        if item_ty.needs_subst() {\n+            return false;\n+        }\n+        if self.can_coerce(item_ty, expected_ty) {\n+            err.span_suggestion_verbose(\n+                segment.ident.span,\n+                format!(\"try referring to the associated const `{capitalized_name}` instead\",),\n+                capitalized_name,\n+                Applicability::MachineApplicable,\n+            );\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     fn is_loop(&self, id: hir::HirId) -> bool {\n         let node = self.tcx.hir().get(id);\n         matches!(node, Node::Expr(Expr { kind: ExprKind::Loop(..), .. }))"}, {"sha": "d6de6e70ead808a888d8a56a611a424c3f36e2f4", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -25,6 +25,7 @@ use crate::{\n     types::{transparent_newtype_field, CItemKind},\n     EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n };\n+use hir::IsAsync;\n use rustc_ast::attr;\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::visit::{FnCtxt, FnKind};\n@@ -40,7 +41,10 @@ use rustc_feature::{deprecated_attributes, AttributeGate, BuiltinAttribute, Gate\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet, CRATE_DEF_ID};\n-use rustc_hir::{ForeignItemKind, GenericParamKind, HirId, Node, PatKind, PredicateOrigin};\n+use rustc_hir::intravisit::FnKind as HirFnKind;\n+use rustc_hir::{\n+    Body, FnDecl, ForeignItemKind, GenericParamKind, HirId, Node, PatKind, PredicateOrigin,\n+};\n use rustc_index::vec::Idx;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n@@ -1370,6 +1374,72 @@ impl<'tcx> LateLintPass<'tcx> for UnstableFeatures {\n     }\n }\n \n+declare_lint! {\n+    /// The `ungated_async_fn_track_caller` lint warns when the\n+    /// `#[track_caller]` attribute is used on an async function, method, or\n+    /// closure, without enabling the corresponding unstable feature flag.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #[track_caller]\n+    /// async fn foo() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The attribute must be used in conjunction with the\n+    /// [`closure_track_caller` feature flag]. Otherwise, the `#[track_caller]`\n+    /// annotation will function as as no-op.\n+    ///\n+    /// [`closure_track_caller` feature flag]: https://doc.rust-lang.org/beta/unstable-book/language-features/closure-track-caller.html\n+    UNGATED_ASYNC_FN_TRACK_CALLER,\n+    Warn,\n+    \"enabling track_caller on an async fn is a no-op unless the closure_track_caller feature is enabled\"\n+}\n+\n+declare_lint_pass!(\n+    /// Explains corresponding feature flag must be enabled for the `#[track_caller] attribute to\n+    /// do anything\n+    UngatedAsyncFnTrackCaller => [UNGATED_ASYNC_FN_TRACK_CALLER]\n+);\n+\n+impl<'tcx> LateLintPass<'tcx> for UngatedAsyncFnTrackCaller {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'_>,\n+        fn_kind: HirFnKind<'_>,\n+        _: &'tcx FnDecl<'_>,\n+        _: &'tcx Body<'_>,\n+        span: Span,\n+        hir_id: HirId,\n+    ) {\n+        if fn_kind.asyncness() == IsAsync::Async\n+            && !cx.tcx.features().closure_track_caller\n+            && let attrs = cx.tcx.hir().attrs(hir_id)\n+            // Now, check if the function has the `#[track_caller]` attribute\n+            && let Some(attr) = attrs.iter().find(|attr| attr.has_name(sym::track_caller))\n+            {\n+                cx.struct_span_lint(\n+                    UNGATED_ASYNC_FN_TRACK_CALLER,\n+                    attr.span,\n+                    fluent::lint_ungated_async_fn_track_caller,\n+                    |lint| {\n+                        lint.span_label(span, fluent::label);\n+                        rustc_session::parse::add_feature_diagnostics(\n+                            lint,\n+                            &cx.tcx.sess.parse_sess,\n+                            sym::closure_track_caller,\n+                        );\n+                        lint\n+                    },\n+                );\n+            }\n+    }\n+}\n+\n declare_lint! {\n     /// The `unreachable_pub` lint triggers for `pub` items not reachable from\n     /// the crate root."}, {"sha": "1275d6f223c7a38ebe5fbfd42cc50c04c4990149", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -219,6 +219,7 @@ late_lint_methods!(\n             // May Depend on constants elsewhere\n             UnusedBrokenConst: UnusedBrokenConst,\n             UnstableFeatures: UnstableFeatures,\n+            UngatedAsyncFnTrackCaller: UngatedAsyncFnTrackCaller,\n             ArrayIntoIter: ArrayIntoIter::default(),\n             DropTraitConstraints: DropTraitConstraints,\n             TemporaryCStringAsPtr: TemporaryCStringAsPtr,"}, {"sha": "2182b73693774638c46a5f91f3f51fdaaf109956", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -1686,21 +1686,43 @@ impl<'a> Resolver<'a> {\n             .or_insert_with(|| self.arenas.alloc_name_resolution())\n     }\n \n+    /// Test if AmbiguityError ambi is any identical to any one inside ambiguity_errors\n+    fn matches_previous_ambiguity_error(&mut self, ambi: &AmbiguityError<'_>) -> bool {\n+        for ambiguity_error in &self.ambiguity_errors {\n+            // if the span location and ident as well as its span are the same\n+            if ambiguity_error.kind == ambi.kind\n+                && ambiguity_error.ident == ambi.ident\n+                && ambiguity_error.ident.span == ambi.ident.span\n+                && ambiguity_error.b1.span == ambi.b1.span\n+                && ambiguity_error.b2.span == ambi.b2.span\n+                && ambiguity_error.misc1 == ambi.misc1\n+                && ambiguity_error.misc2 == ambi.misc2\n+            {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n     fn record_use(\n         &mut self,\n         ident: Ident,\n         used_binding: &'a NameBinding<'a>,\n         is_lexical_scope: bool,\n     ) {\n         if let Some((b2, kind)) = used_binding.ambiguity {\n-            self.ambiguity_errors.push(AmbiguityError {\n+            let ambiguity_error = AmbiguityError {\n                 kind,\n                 ident,\n                 b1: used_binding,\n                 b2,\n                 misc1: AmbiguityErrorMisc::None,\n                 misc2: AmbiguityErrorMisc::None,\n-            });\n+            };\n+            if !self.matches_previous_ambiguity_error(&ambiguity_error) {\n+                // avoid dumplicated span information to be emitt out\n+                self.ambiguity_errors.push(ambiguity_error);\n+            }\n         }\n         if let NameBindingKind::Import { import, binding, ref used } = used_binding.kind {\n             // Avoid marking `extern crate` items that refer to a name from extern prelude,"}, {"sha": "5ad24bf2681332b83efb73a192b345bfa4993113", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -1655,10 +1655,10 @@ impl clean::types::Term {\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n-        match self {\n-            clean::types::Term::Type(ty) => ty.print(cx),\n-            _ => todo!(),\n-        }\n+        display_fn(move |f| match self {\n+            clean::types::Term::Type(ty) => fmt::Display::fmt(&ty.print(cx), f),\n+            clean::types::Term::Constant(ct) => fmt::Display::fmt(&ct.print(cx.tcx()), f),\n+        })\n     }\n }\n "}, {"sha": "60e4e7492240c09c52d44012f5dda6defd2435ed", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -813,16 +813,14 @@ function loadCss(cssUrl) {\n         hideSidebar();\n     });\n \n-    onEachLazy(document.getElementsByTagName(\"a\"), el => {\n+    onEachLazy(document.querySelectorAll(\"a[href^='#']\"), el => {\n         // For clicks on internal links (<A> tags with a hash property), we expand the section we're\n         // jumping to *before* jumping there. We can't do this in onHashChange, because it changes\n         // the height of the document so we wind up scrolled to the wrong place.\n-        if (el.hash) {\n-            el.addEventListener(\"click\", () => {\n-                expandSection(el.hash.slice(1));\n-                hideSidebar();\n-            });\n-        }\n+        el.addEventListener(\"click\", () => {\n+            expandSection(el.hash.slice(1));\n+            hideSidebar();\n+        });\n     });\n \n     onEachLazy(document.querySelectorAll(\".rustdoc-toggle > summary:not(.hideme)\"), el => {"}, {"sha": "34fd401f9e42ba5dd2035dc04841e2da5a60d7e2", "filename": "src/test/codegen/unwind-abis/c-unwind-abi-panic-abort.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fcodegen%2Funwind-abis%2Fc-unwind-abi-panic-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fcodegen%2Funwind-abis%2Fc-unwind-abi-panic-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-abis%2Fc-unwind-abi-panic-abort.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -9,7 +9,8 @@\n // CHECK: @rust_item_that_can_unwind() unnamed_addr [[ATTR0:#[0-9]+]]\n #[no_mangle]\n pub unsafe extern \"C-unwind\" fn rust_item_that_can_unwind() {\n-    // CHECK: call void @_ZN4core9panicking15panic_no_unwind\n+    // Handle both legacy and v0 symbol mangling.\n+    // CHECK: call void @{{.*core9panicking15panic_no_unwind}}\n     may_unwind();\n }\n "}, {"sha": "b370191bf8c82dfee4833c6b3223899fb9aa5bce", "filename": "src/test/codegen/unwind-and-panic-abort.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fcodegen%2Funwind-and-panic-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fcodegen%2Funwind-and-panic-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-and-panic-abort.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -9,7 +9,8 @@ extern \"C-unwind\" {\n \n // CHECK: Function Attrs:{{.*}}nounwind\n // CHECK-NEXT: define{{.*}}void @foo\n-// CHECK: call void @_ZN4core9panicking15panic_no_unwind\n+// Handle both legacy and v0 symbol mangling.\n+// CHECK: call void @{{.*core9panicking15panic_no_unwind}}\n #[no_mangle]\n pub unsafe extern \"C\" fn foo() {\n     bar();"}, {"sha": "e3f1df0063dfb1ccc103857f180eba94695233ce", "filename": "src/test/rustdoc/issue-105952.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Frustdoc%2Fissue-105952.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Frustdoc%2Fissue-105952.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-105952.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -0,0 +1,14 @@\n+#![crate_name = \"foo\"]\n+\n+#![feature(associated_const_equality)]\n+pub enum ParseMode {\n+    Raw,\n+}\n+pub trait Parse {\n+    const PARSE_MODE: ParseMode;\n+}\n+pub trait RenderRaw {}\n+\n+// @hasraw foo/trait.RenderRaw.html 'impl'\n+// @hasraw foo/trait.RenderRaw.html 'ParseMode::Raw'\n+impl<T: Parse<PARSE_MODE = { ParseMode::Raw }>> RenderRaw for T {}"}, {"sha": "d9d556855991b881b5d8b4237263e947d5cdbd13", "filename": "src/test/ui/async-await/track-caller/async-closure-gate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-closure-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-closure-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-closure-gate.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -5,6 +5,5 @@\n fn main() {\n     let _ = #[track_caller] async || {\n         //~^ ERROR `#[track_caller]` on closures is currently unstable [E0658]\n-        //~| ERROR `#[track_caller]` on closures is currently unstable [E0658]\n     };\n }"}, {"sha": "498f1b43b9bca4f587f1121fc593dac62920e8b1", "filename": "src/test/ui/async-await/track-caller/async-closure-gate.stderr", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-closure-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-closure-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-closure-gate.stderr?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -7,19 +7,6 @@ LL |     let _ = #[track_caller] async || {\n    = note: see issue #87417 <https://github.com/rust-lang/rust/issues/87417> for more information\n    = help: add `#![feature(closure_track_caller)]` to the crate attributes to enable\n \n-error[E0658]: `#[track_caller]` on closures is currently unstable\n-  --> $DIR/async-closure-gate.rs:6:38\n-   |\n-LL |       let _ = #[track_caller] async || {\n-   |  ______________________________________^\n-LL | |\n-LL | |\n-LL | |     };\n-   | |_____^\n-   |\n-   = note: see issue #87417 <https://github.com/rust-lang/rust/issues/87417> for more information\n-   = help: add `#![feature(closure_track_caller)]` to the crate attributes to enable\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "51ea225f4cbd45d56be94c0ed874515dd30b1cc6", "filename": "src/test/ui/async-await/track-caller/panic-track-caller.nofeat.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fpanic-track-caller.nofeat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fpanic-track-caller.nofeat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fpanic-track-caller.nofeat.stderr?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -0,0 +1,29 @@\n+warning: `#[track_caller]` on async functions is a no-op\n+  --> $DIR/panic-track-caller.rs:50:1\n+   |\n+LL |   #[track_caller]\n+   |   ^^^^^^^^^^^^^^^\n+LL | / async fn bar_track_caller() {\n+LL | |     panic!()\n+LL | | }\n+   | |_- this function will not propagate the caller location\n+   |\n+   = note: see issue #87417 <https://github.com/rust-lang/rust/issues/87417> for more information\n+   = help: add `#![feature(closure_track_caller)]` to the crate attributes to enable\n+   = note: `#[warn(ungated_async_fn_track_caller)]` on by default\n+\n+warning: `#[track_caller]` on async functions is a no-op\n+  --> $DIR/panic-track-caller.rs:62:5\n+   |\n+LL |       #[track_caller]\n+   |       ^^^^^^^^^^^^^^^\n+LL | /     async fn bar_assoc() {\n+LL | |         panic!();\n+LL | |     }\n+   | |_____- this function will not propagate the caller location\n+   |\n+   = note: see issue #87417 <https://github.com/rust-lang/rust/issues/87417> for more information\n+   = help: add `#![feature(closure_track_caller)]` to the crate attributes to enable\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "f45243b0ea6f59815367bf575969b25735cee9ae", "filename": "src/test/ui/async-await/track-caller/panic-track-caller.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fpanic-track-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fpanic-track-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fpanic-track-caller.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -1,7 +1,9 @@\n // run-pass\n // edition:2021\n+// revisions: feat nofeat\n // needs-unwind\n-#![feature(closure_track_caller, async_closure, stmt_expr_attributes)]\n+#![feature(async_closure, stmt_expr_attributes)]\n+#![cfg_attr(feat, feature(closure_track_caller))]\n \n use std::future::Future;\n use std::panic;\n@@ -45,7 +47,7 @@ async fn foo() {\n     bar().await\n }\n \n-#[track_caller]\n+#[track_caller] //[nofeat]~ WARN `#[track_caller]` on async functions is a no-op\n async fn bar_track_caller() {\n     panic!()\n }\n@@ -57,7 +59,7 @@ async fn foo_track_caller() {\n struct Foo;\n \n impl Foo {\n-    #[track_caller]\n+    #[track_caller] //[nofeat]~ WARN `#[track_caller]` on async functions is a no-op\n     async fn bar_assoc() {\n         panic!();\n     }\n@@ -67,6 +69,9 @@ async fn foo_assoc() {\n     Foo::bar_assoc().await\n }\n \n+// Since compilation is expected to fail for this fn when using\n+// `nofeat`, we test that separately in `async-closure-gate.rs`\n+#[cfg(feat)]\n async fn foo_closure() {\n     let c = #[track_caller] async || {\n         panic!();\n@@ -91,8 +96,18 @@ fn panicked_at(f: impl FnOnce() + panic::UnwindSafe) -> u32 {\n }\n \n fn main() {\n-    assert_eq!(panicked_at(|| block_on(foo())), 41);\n-    assert_eq!(panicked_at(|| block_on(foo_track_caller())), 54);\n-    assert_eq!(panicked_at(|| block_on(foo_assoc())), 67);\n-    assert_eq!(panicked_at(|| block_on(foo_closure())), 74);\n+    assert_eq!(panicked_at(|| block_on(foo())), 43);\n+\n+    #[cfg(feat)]\n+    assert_eq!(panicked_at(|| block_on(foo_track_caller())), 56);\n+    #[cfg(nofeat)]\n+    assert_eq!(panicked_at(|| block_on(foo_track_caller())), 52);\n+\n+    #[cfg(feat)]\n+    assert_eq!(panicked_at(|| block_on(foo_assoc())), 69);\n+    #[cfg(nofeat)]\n+    assert_eq!(panicked_at(|| block_on(foo_assoc())), 64);\n+\n+    #[cfg(feat)]\n+    assert_eq!(panicked_at(|| block_on(foo_closure())), 79);\n }"}, {"sha": "29e9b8ec841f54661233112fcbb236606490a9df", "filename": "src/test/ui/imports/local-modularized-tricky-fail-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -26,7 +26,6 @@ mod inner1 {\n }\n \n exported!(); //~ ERROR `exported` is ambiguous\n-             //~| ERROR `exported` is ambiguous\n \n mod inner2 {\n     define_exported!();"}, {"sha": "20eadaaaa56b8732012505ffba5928e771275fd2", "filename": "src/test/ui/imports/local-modularized-tricky-fail-1.stderr", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -23,33 +23,8 @@ LL | use inner1::*;\n    = help: consider adding an explicit import of `exported` to disambiguate\n    = note: this error originates in the macro `define_exported` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error[E0659]: `exported` is ambiguous\n-  --> $DIR/local-modularized-tricky-fail-1.rs:28:1\n-   |\n-LL | exported!();\n-   | ^^^^^^^^ ambiguous name\n-   |\n-   = note: ambiguous because of a conflict between a name from a glob import and a macro-expanded name in the same module during import or macro resolution\n-note: `exported` could refer to the macro defined here\n-  --> $DIR/local-modularized-tricky-fail-1.rs:5:5\n-   |\n-LL | /     macro_rules! exported {\n-LL | |         () => ()\n-LL | |     }\n-   | |_____^\n-...\n-LL |       define_exported!();\n-   |       ------------------ in this macro invocation\n-note: `exported` could also refer to the macro imported here\n-  --> $DIR/local-modularized-tricky-fail-1.rs:22:5\n-   |\n-LL | use inner1::*;\n-   |     ^^^^^^^^^\n-   = help: consider adding an explicit import of `exported` to disambiguate\n-   = note: this error originates in the macro `define_exported` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n error[E0659]: `panic` is ambiguous\n-  --> $DIR/local-modularized-tricky-fail-1.rs:36:5\n+  --> $DIR/local-modularized-tricky-fail-1.rs:35:5\n    |\n LL |     panic!();\n    |     ^^^^^ ambiguous name\n@@ -70,7 +45,7 @@ LL |       define_panic!();\n    = note: this error originates in the macro `define_panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0659]: `include` is ambiguous\n-  --> $DIR/local-modularized-tricky-fail-1.rs:47:1\n+  --> $DIR/local-modularized-tricky-fail-1.rs:46:1\n    |\n LL | include!();\n    | ^^^^^^^ ambiguous name\n@@ -90,6 +65,6 @@ LL |       define_include!();\n    = help: use `crate::include` to refer to this macro unambiguously\n    = note: this error originates in the macro `define_include` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0659`."}, {"sha": "f2a22ad620b1111004fe4893436494d2b13fe7a8", "filename": "src/test/ui/imports/macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fimports%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fimports%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fmacros.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -14,7 +14,6 @@ mod m1 {\n mod m2 {\n     use two_macros::*;\n     m! { //~ ERROR ambiguous\n-         //~| ERROR ambiguous\n         use foo::m;\n     }\n }"}, {"sha": "e34e5359b48faac1832a308ff7d61e036de5a1bb", "filename": "src/test/ui/imports/macros.stderr", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -6,7 +6,7 @@ LL |     m! {\n    |\n    = note: ambiguous because of a conflict between a name from a glob import and a macro-expanded name in the same module during import or macro resolution\n note: `m` could refer to the macro imported here\n-  --> $DIR/macros.rs:18:13\n+  --> $DIR/macros.rs:17:13\n    |\n LL |         use foo::m;\n    |             ^^^^^^\n@@ -18,43 +18,24 @@ LL |     use two_macros::*;\n    = help: consider adding an explicit import of `m` to disambiguate\n \n error[E0659]: `m` is ambiguous\n-  --> $DIR/macros.rs:16:5\n-   |\n-LL |     m! {\n-   |     ^ ambiguous name\n-   |\n-   = note: ambiguous because of a conflict between a name from a glob import and a macro-expanded name in the same module during import or macro resolution\n-note: `m` could refer to the macro imported here\n-  --> $DIR/macros.rs:18:13\n-   |\n-LL |         use foo::m;\n-   |             ^^^^^^\n-note: `m` could also refer to the macro imported here\n-  --> $DIR/macros.rs:15:9\n-   |\n-LL |     use two_macros::*;\n-   |         ^^^^^^^^^^^^^\n-   = help: consider adding an explicit import of `m` to disambiguate\n-\n-error[E0659]: `m` is ambiguous\n-  --> $DIR/macros.rs:30:9\n+  --> $DIR/macros.rs:29:9\n    |\n LL |         m! {\n    |         ^ ambiguous name\n    |\n    = note: ambiguous because of a conflict between a macro-expanded name and a less macro-expanded name from outer scope during import or macro resolution\n note: `m` could refer to the macro imported here\n-  --> $DIR/macros.rs:31:17\n+  --> $DIR/macros.rs:30:17\n    |\n LL |             use two_macros::n as m;\n    |                 ^^^^^^^^^^^^^^^^^^\n note: `m` could also refer to the macro imported here\n-  --> $DIR/macros.rs:23:9\n+  --> $DIR/macros.rs:22:9\n    |\n LL |     use two_macros::m;\n    |         ^^^^^^^^^^^^^\n    = help: use `self::m` to refer to this macro unambiguously\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0659`."}, {"sha": "fe2227769894c066cd11960ff6dd05d1643028ce", "filename": "src/test/ui/suggestions/assoc-ct-for-assoc-method.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-ct-for-assoc-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-ct-for-assoc-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-ct-for-assoc-method.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -0,0 +1,25 @@\n+struct MyS;\n+\n+impl MyS {\n+    const FOO: i32 = 1;\n+    fn foo() -> MyS {\n+        MyS\n+    }\n+}\n+\n+fn main() {\n+    let x: i32 = MyS::foo;\n+    //~^ ERROR mismatched types\n+    //~| HELP try referring to the\n+\n+    let z: i32 = i32::max;\n+    //~^ ERROR mismatched types\n+    //~| HELP try referring to the\n+\n+    // This example is still broken though... This is a hard suggestion to make,\n+    // because we don't have access to the associated const probing code to make\n+    // this suggestion where it's emitted, i.e. in trait selection.\n+    let y: i32 = i32::max - 42;\n+    //~^ ERROR cannot subtract\n+    //~| HELP use parentheses\n+}"}, {"sha": "afef38f12967493a3916ab8d6bb4591c5cc81a7f", "filename": "src/test/ui/suggestions/assoc-ct-for-assoc-method.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-ct-for-assoc-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-ct-for-assoc-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-ct-for-assoc-method.stderr?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -0,0 +1,47 @@\n+error[E0308]: mismatched types\n+  --> $DIR/assoc-ct-for-assoc-method.rs:11:18\n+   |\n+LL |     let x: i32 = MyS::foo;\n+   |            ---   ^^^^^^^^ expected `i32`, found fn item\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected type `i32`\n+           found fn item `fn() -> MyS {MyS::foo}`\n+help: try referring to the associated const `FOO` instead\n+   |\n+LL |     let x: i32 = MyS::FOO;\n+   |                       ~~~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assoc-ct-for-assoc-method.rs:15:18\n+   |\n+LL |     let z: i32 = i32::max;\n+   |            ---   ^^^^^^^^ expected `i32`, found fn item\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected type `i32`\n+           found fn item `fn(i32, i32) -> i32 {<i32 as Ord>::max}`\n+help: try referring to the associated const `MAX` instead\n+   |\n+LL |     let z: i32 = i32::MAX;\n+   |                       ~~~\n+\n+error[E0369]: cannot subtract `{integer}` from `fn(i32, i32) -> i32 {<i32 as Ord>::max}`\n+  --> $DIR/assoc-ct-for-assoc-method.rs:22:27\n+   |\n+LL |     let y: i32 = i32::max - 42;\n+   |                  -------- ^ -- {integer}\n+   |                  |\n+   |                  fn(i32, i32) -> i32 {<i32 as Ord>::max}\n+   |\n+help: use parentheses to call this associated function\n+   |\n+LL |     let y: i32 = i32::max(/* i32 */, /* i32 */) - 42;\n+   |                          ++++++++++++++++++++++\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0308, E0369.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "00b0dbbb583fd8724034ebefb11323b9a1a29f7a", "filename": "src/test/ui/type-alias-impl-trait/coherence.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -4,7 +4,7 @@ error[E0117]: only traits defined in the current crate can be implemented for ar\n LL | impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---------------------\n    | |                                       |\n-   | |                                       `AliasOfForeignType<T>` is not defined in the current crate\n+   | |                                       type alias impl trait is treated as if it were foreign, because its hidden type could be from a foreign crate\n    | impl doesn't use only types from inside the current crate\n    |\n    = note: define and implement a trait or new type instead"}, {"sha": "08bea4f1678b67467a00716e6aeffd8235108c9e", "filename": "src/test/ui/unboxed-closures/non-tupled-call.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Funboxed-closures%2Fnon-tupled-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Funboxed-closures%2Fnon-tupled-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Fnon-tupled-call.rs?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -0,0 +1,17 @@\n+#![feature(fn_traits, unboxed_closures, tuple_trait)]\n+\n+use std::default::Default;\n+use std::marker::Tuple;\n+\n+fn wrap<P: Tuple + Default, T>(func: impl Fn<P, Output = T>) {\n+    let x: P = Default::default();\n+    // Should be: `func.call(x);`\n+    func(x);\n+    //~^ ERROR cannot use call notation; the first type parameter for the function trait is neither a tuple nor unit\n+}\n+\n+fn foo() {}\n+\n+fn main() {\n+    wrap(foo);\n+}"}, {"sha": "35ac9ebe291037dde68e0bd0595714c6af14aedc", "filename": "src/test/ui/unboxed-closures/non-tupled-call.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Funboxed-closures%2Fnon-tupled-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Funboxed-closures%2Fnon-tupled-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Fnon-tupled-call.stderr?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -0,0 +1,9 @@\n+error[E0059]: cannot use call notation; the first type parameter for the function trait is neither a tuple nor unit\n+  --> $DIR/non-tupled-call.rs:9:5\n+   |\n+LL |     func(x);\n+   |     ^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0059`."}]}