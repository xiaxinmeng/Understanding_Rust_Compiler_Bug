{"sha": "fa5a7e7453ee6aae73c639e16db7d208b5949b4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNWE3ZTc0NTNlZTZhYWU3M2M2MzllMTZkYjdkMjA4YjU5NDliNGQ=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-15T19:18:02Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-15T19:18:52Z"}, "message": "Simple anonymous objects get through translation.", "tree": {"sha": "2ec49d3e79d5d42d37c46fef76e8fef635ac86f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ec49d3e79d5d42d37c46fef76e8fef635ac86f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa5a7e7453ee6aae73c639e16db7d208b5949b4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa5a7e7453ee6aae73c639e16db7d208b5949b4d", "html_url": "https://github.com/rust-lang/rust/commit/fa5a7e7453ee6aae73c639e16db7d208b5949b4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa5a7e7453ee6aae73c639e16db7d208b5949b4d/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59a254ae32ef9e3878c5b1c11ab5a3beef0a12ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/59a254ae32ef9e3878c5b1c11ab5a3beef0a12ff", "html_url": "https://github.com/rust-lang/rust/commit/59a254ae32ef9e3878c5b1c11ab5a3beef0a12ff"}], "stats": {"total": 300, "additions": 105, "deletions": 195}, "files": [{"sha": "3b27c8597ed7747f43d8e404d488a19f4636231b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 67, "deletions": 182, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/fa5a7e7453ee6aae73c639e16db7d208b5949b4d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5a7e7453ee6aae73c639e16db7d208b5949b4d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=fa5a7e7453ee6aae73c639e16db7d208b5949b4d", "patch": "@@ -113,13 +113,18 @@ type stats =\n         mutable uint n_null_glues,\n         mutable uint n_real_glues);\n \n+// Crate context.  Every crate we compile has one of these.\n type crate_ctxt =\n     rec(session::session sess,\n         ModuleRef llmod,\n         target_data td,\n         type_names tn,\n         hashmap[str, ValueRef] externs,\n         hashmap[str, ValueRef] intrinsics,\n+\n+        // A mapping from the def_id of each item in this crate to the address\n+        // of the first instruction of the item's definition in the executable\n+        // we're generating.\n         hashmap[ast::def_id, ValueRef] item_ids,\n         hashmap[ast::def_id, @ast::item] items,\n         hashmap[ast::def_id, @ast::native_item] native_items,\n@@ -5966,24 +5971,26 @@ fn recv_val(&@block_ctxt cx, ValueRef lhs, &@ast::expr rhs, &ty::t unit_ty,\n \n */\n \n-// trans_anon_obj: create (and return!) an LLVM function that is the object\n-// constructor for the anonymous object being translated.  \n-//\n-// This code differs from trans_obj in that, rather than creating an object\n-// constructor function and putting it in the generated code as an object\n-// item, we are instead \"inlining\" the construction of the object.\n-fn trans_anon_obj(@block_ctxt cx, &span sp, &ast::anon_obj anon_obj,\n+// trans_anon_obj: create and return a pointer to an object.  This code\n+// differs from trans_obj in that, rather than creating an object constructor\n+// function and putting it in the generated code as an object item, we are\n+// instead \"inlining\" the construction of the object and returning the object\n+// itself.\n+fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj, \n                   &vec[ast::ty_param] ty_params, ast::def_id oid,\n                   &ast::ann ann) -> result {\n-    auto ccx = cx.fcx.lcx.ccx;\n-    // A crate_ctxt has an item_ids hashmap, which has all of the def_ids of\n-    // everything in the crate.  By looking up a def_id, you can get the\n-    // ValueRef of that item.\n \n-    auto llctor_decl = ccx.item_ids.get(oid);\n+    // Right now, we're assuming that anon objs don't take ty params, even\n+    // though the AST supports it.  It's nonsensical to write an expression\n+    // like \"obj[T](){ ... with ... }\", since T is never instantiated;\n+    // nevertheless, such an expression will parse.  FIXME for the future:\n+    // support typarams (issue #n).\n+    assert vec::len(ty_params) == 0u;\n+\n+    auto ccx = bcx.fcx.lcx.ccx;\n+\n     // If with_obj (the object being extended) exists, translate it, producing\n     // a result.\n-\n     let option::t[result] with_obj_val = none[result];\n     alt (anon_obj.with_obj) {\n         case (none) { }\n@@ -5992,81 +5999,44 @@ fn trans_anon_obj(@block_ctxt cx, &span sp, &ast::anon_obj anon_obj,\n             // value) wrapped in a result.  We want to allocate space for this\n             // value in our outer object, then copy it into the outer object.\n \n-            with_obj_val = some[result](trans_expr(cx, e));\n+            with_obj_val = some[result](trans_expr(bcx, e));\n         }\n     }\n-    // If the anonymous object we're translating adds any additional fields,\n-    // they'll become the arguments to the function we're creating.\n \n     // FIXME (part of issue #417): all of the following code is copypasta from\n     // trans_obj for translating the anonymous wrapper object.  Eventually we\n     // should abstract this code out of trans_anon_obj and trans_obj.\n \n-    // For the anon obj's additional fields, if any exist, translate object\n-    // constructor arguments to function arguments.\n-\n-    let vec[ast::obj_field] addtl_fields = [];\n-    let vec[ast::arg] addtl_fn_args = [];\n-    alt (anon_obj.fields) {\n-        case (none) { }\n-        case (some(?fields)) {\n-            addtl_fields = fields;\n-            for (ast::obj_field f in fields) {\n-                addtl_fn_args +=\n-                    [rec(mode=ast::alias(false),\n-                         ty=f.ty,\n-                         ident=f.ident,\n-                         id=f.id)];\n-            }\n-        }\n-    }\n-    auto fcx = new_fn_ctxt(cx.fcx.lcx, sp, llctor_decl);\n-    // Both regular arguments and type parameters are handled here.\n-\n-    create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty_self_pair],\n-                              ret_ty_of_fn(ccx, ann), addtl_fn_args,\n-                              ty_params);\n-    let vec[ty::arg] arg_tys = arg_tys_of_fn(ccx, ann);\n-    copy_args_to_allocas(fcx, addtl_fn_args, arg_tys);\n-    //  Create the first block context in the function and keep a handle on it\n-    //  to pass to finish_fn later.\n-\n-    auto bcx = new_top_block_ctxt(fcx);\n-    auto lltop = bcx.llbb;\n-    // Pick up the type of this object by looking at our own output type, that\n-    // is, the output type of the object constructor we're building.\n-\n-    auto self_ty = ret_ty_of_fn(ccx, ann);\n+    auto self_ty = ty::ann_to_type(ccx.tcx, ann);\n     auto llself_ty = type_of(ccx, sp, self_ty);\n-    // Set up the two-word pair that we're going to return from the object\n-    // constructor we're building.  The two elements of this pair will be a\n-    // vtable pointer and a body pointer.  (llretptr already points to the\n-    // place where this two-word pair should go; it was pre-allocated by the\n-    // caller of the function.)\n \n-    auto pair = bcx.fcx.llretptr;\n+    // Allocate the object that we're going to return.  It's a two-word pair\n+    // containing a vtable pointer and a body pointer.\n+    auto pair = alloca(bcx, llself_ty);\n+\n     // Grab onto the first and second elements of the pair.\n     // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n     // of 'pair'.\n-\n     auto pair_vtbl =\n         bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n     auto pair_box =\n         bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_box)]);\n-    // Make a vtable for this object: a static array of pointers to functions.\n-    // It will be located in the read-only memory of the executable we're\n-    // creating and will contain ValueRefs for all of this object's methods.\n-    // create_vtbl returns a pointer to the vtable, which we store.\n \n-    // create_vtbl() wants an ast::_obj and all we have is an\n-    // ast::anon_obj, so we need to roll our own.\n+    // Make a vtable for the outer object.  create_vtbl() wants an ast::_obj\n+    // and all we have is an ast::anon_obj, so we need to roll our own.\n+    let vec[ast::obj_field] addtl_fields = [];\n+    alt (anon_obj.fields) {\n+        case (none) { }\n+        case (some(?fields)) { addtl_fields = fields; }\n+    }\n+    let ast::_obj wrapper_obj = rec(\n+        fields = addtl_fields,\n+        methods = anon_obj.methods,\n+        dtor = none[@ast::method]);\n+\n+    auto vtbl = create_vtbl(bcx.fcx.lcx, llself_ty, self_ty, wrapper_obj, \n+                            ty_params);\n \n-    let ast::_obj wrapper_obj =\n-        rec(fields=addtl_fields,\n-            methods=anon_obj.methods,\n-            dtor=none[@ast::method]);\n-    auto vtbl =\n-        create_vtbl(cx.fcx.lcx, llself_ty, self_ty, wrapper_obj, ty_params);\n     bcx.build.Store(vtbl, pair_vtbl);\n     // FIXME (part of issue #417): This vtable needs to contain \"forwarding\n     // slots\" for the methods that exist in the with_obj, as well.  How do we\n@@ -6080,127 +6050,29 @@ fn trans_anon_obj(@block_ctxt cx, &span sp, &ast::anon_obj anon_obj,\n     // also have to fill in the with_obj field of this tuple.\n \n     let TypeRef llbox_ty = T_opaque_obj_ptr(ccx.tn);\n-    // FIXME: we should probably also allocate a box for empty objs that have\n-    // a dtor, since otherwise they are never dropped, and the dtor never\n-    // runs.\n-\n-    if (vec::len[ast::ty_param](ty_params) == 0u &&\n-            vec::len[ty::arg](arg_tys) == 0u) {\n-        // If the object we're translating has no fields or type parameters,\n-        // there's not much to do.\n-\n-        // Store null into pair, if no args or typarams.\n-\n-        bcx.build.Store(C_null(llbox_ty), pair_box);\n-    } else {\n-        // Otherwise, we have to synthesize a big structural type for the\n-        // object body.\n-\n-        let vec[ty::t] obj_fields = [];\n-        for (ty::arg a in arg_tys) { vec::push[ty::t](obj_fields, a.ty); }\n-        // Tuple type for fields: [field, ...]\n+    \n+    alt (anon_obj.fields) {\n+        case (none) { \n+            // If the object we're translating has no fields or type\n+            // parameters, there's not much to do.\n \n-        let ty::t fields_ty = ty::mk_imm_tup(ccx.tcx, obj_fields);\n-        // Tuple type for typarams: [typaram, ...]\n+            // Store null into pair, if no args or typarams.\n+            bcx.build.Store(C_null(llbox_ty), pair_box);\n \n-        auto tydesc_ty = ty::mk_type(ccx.tcx);\n-        let vec[ty::t] tps = [];\n-        for (ast::ty_param tp in ty_params) {\n-            vec::push[ty::t](tps, tydesc_ty);\n         }\n-        let ty::t typarams_ty = ty::mk_imm_tup(ccx.tcx, tps);\n-        // Tuple type for body: [tydesc_ty, [typaram, ...], [field, ...]]\n-\n-        let ty::t body_ty =\n-            ty::mk_imm_tup(ccx.tcx, [tydesc_ty, typarams_ty, fields_ty]);\n-        // Hand this type we've synthesized off to trans_malloc_boxed, which\n-        // allocates a box, including space for a refcount.\n \n-        auto box = trans_malloc_boxed(bcx, body_ty);\n-        bcx = box.bcx;\n-        // mk_imm_box throws a refcount into the type we're synthesizing, so\n-        // that it looks like: [rc, [tydesc_ty, [typaram, ...], [field, ...]]]\n-\n-        let ty::t boxed_body_ty = ty::mk_imm_box(ccx.tcx, body_ty);\n-        // Grab onto the refcount and body parts of the box we allocated.\n-\n-        auto rc =\n-            GEP_tup_like(bcx, boxed_body_ty, box.val,\n-                         [0, abi::box_rc_field_refcnt]);\n-        bcx = rc.bcx;\n-        auto body =\n-            GEP_tup_like(bcx, boxed_body_ty, box.val,\n-                         [0, abi::box_rc_field_body]);\n-        bcx = body.bcx;\n-        bcx.build.Store(C_int(1), rc.val);\n-        // Put together a tydesc for the body, so that the object can later be\n-        // freed by calling through its tydesc.\n-\n-        // Every object (not just those with type parameters) needs to have a\n-        // tydesc to describe its body, since all objects have unknown type to\n-        // the user of the object.  So the tydesc is needed to keep track of\n-        // the types of the object's fields, so that the fields can be freed\n-        // later.\n-\n-        auto body_tydesc =\n-            GEP_tup_like(bcx, body_ty, body.val,\n-                         [0, abi::obj_body_elt_tydesc]);\n-        bcx = body_tydesc.bcx;\n-        auto ti = none[@tydesc_info];\n-        auto body_td = get_tydesc(bcx, body_ty, true, ti);\n-        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n-        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n-        bcx = body_td.bcx;\n-        bcx.build.Store(body_td.val, body_tydesc.val);\n-        // Copy the object's type parameters and fields into the space we\n-        // allocated for the object body.  (This is something like saving the\n-        // lexical environment of a function in its closure: the \"captured\n-        // typarams\" are any type parameters that are passed to the object\n-        // constructor and are then available to the object's methods.\n-        // Likewise for the object's fields.)\n-\n-        // Copy typarams into captured typarams.\n-\n-        auto body_typarams =\n-            GEP_tup_like(bcx, body_ty, body.val,\n-                         [0, abi::obj_body_elt_typarams]);\n-        bcx = body_typarams.bcx;\n-        let int i = 0;\n-        for (ast::ty_param tp in ty_params) {\n-            auto typaram = bcx.fcx.lltydescs.(i);\n-            auto capture =\n-                GEP_tup_like(bcx, typarams_ty, body_typarams.val, [0, i]);\n-            bcx = capture.bcx;\n-            bcx = copy_val(bcx, INIT, capture.val, typaram, tydesc_ty).bcx;\n-            i += 1;\n-        }\n-        // Copy args into body fields.\n+        case (some(?fields)) {\n+            // For the moment let's pretend that there are no additional\n+            // fields.\n+            bcx.fcx.lcx.ccx.sess.unimpl(\"anon objs don't support \"\n+                                        + \"adding fields yet\");\n \n-        auto body_fields =\n-            GEP_tup_like(bcx, body_ty, body.val,\n-                         [0, abi::obj_body_elt_fields]);\n-        bcx = body_fields.bcx;\n-        i = 0;\n-        for (ast::obj_field f in wrapper_obj.fields) {\n-            auto arg = bcx.fcx.llargs.get(f.id);\n-            arg = load_if_immediate(bcx, arg, arg_tys.(i).ty);\n-            auto field =\n-                GEP_tup_like(bcx, fields_ty, body_fields.val, [0, i]);\n-            bcx = field.bcx;\n-            bcx = copy_val(bcx, INIT, field.val, arg, arg_tys.(i).ty).bcx;\n-            i += 1;\n+            // FIXME (issue #417): drop these fields into the newly created\n+            // object.\n         }\n-        // Store box ptr in outer pair.\n-\n-        auto p = bcx.build.PointerCast(box.val, llbox_ty);\n-        bcx.build.Store(p, pair_box);\n     }\n-    bcx.build.RetVoid();\n-    // Insert the mandatory first few basic blocks before lltop.\n \n-    finish_fn(fcx, lltop);\n     // Return the object we built.\n-\n     ret res(bcx, pair);\n }\n \n@@ -6657,6 +6529,10 @@ fn arg_tys_of_fn(&@crate_ctxt ccx, ast::ann ann) -> vec[ty::arg] {\n fn ret_ty_of_fn_ty(&@crate_ctxt ccx, ty::t t) -> ty::t {\n     alt (ty::struct(ccx.tcx, t)) {\n         case (ty::ty_fn(_, _, ?ret_ty, _, _)) { ret ret_ty; }\n+        case (_) {\n+            ccx.sess.bug(\"ret_ty_of_fn_ty() called on non-function type: \"\n+                         + ty_to_str(ccx.tcx, t));\n+        }\n     }\n }\n \n@@ -6806,6 +6682,10 @@ fn create_vtbl(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n         let str s = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n         let ValueRef llfn =\n             decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n+\n+        // Every method on an object gets its def_id inserted into the\n+        // crate-wide item_ids map, together with the ValueRef that points to\n+        // where that method's definition will be in the executable.\n         cx.ccx.item_ids.insert(m.node.id, llfn);\n         cx.ccx.item_symbols.insert(m.node.id, s);\n         trans_fn(mcx, m.span, m.node.meth, llfn,\n@@ -7156,6 +7036,11 @@ fn trans_item(@local_ctxt cx, &ast::item item) {\n     }\n }\n \n+// Translate a module.  Doing this amounts to translating the items in the\n+// module; there ends up being no artifact (aside from linkage names) of\n+// separate modules in the compiled program.  That's because modules exist\n+// only as a convenience for humans working with the code, to organize names\n+// and control visibility.\n fn trans_mod(@local_ctxt cx, &ast::_mod m) {\n     for (@ast::item item in m.items) { trans_item(cx, *item); }\n }"}, {"sha": "5c7df451bf2f324281fe7dce138ce6fe03e8f10c", "filename": "src/test/run-pass/anon-objs.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fa5a7e7453ee6aae73c639e16db7d208b5949b4d/src%2Ftest%2Frun-pass%2Fanon-objs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5a7e7453ee6aae73c639e16db7d208b5949b4d/src%2Ftest%2Frun-pass%2Fanon-objs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-objs.rs?ref=fa5a7e7453ee6aae73c639e16db7d208b5949b4d", "patch": "@@ -5,18 +5,30 @@\n use std;\n \n fn main() {\n+\n     obj a() {\n-        fn foo() -> int { ret 2; }\n-        fn bar() -> int { ret self.foo(); }\n+        fn foo() -> int {\n+            ret 2;\n+        }\n+        fn bar() -> int {\n+            ret self.foo();\n+        }\n     }\n+\n     auto my_a = a();\n+\n     // Extending an object with a new method\n+    auto my_b = obj { \n+        fn baz() -> int { \n+            ret self.foo(); \n+        } \n+        with my_a \n+    };\n \n-    auto my_b = anon obj;\n     // Extending an object with a new field\n+    auto my_c = obj(int quux) { with my_a } ;\n \n-    auto my_c = anon obj;\n     // Should this be legal?\n-\n-    auto my_d = anon obj;\n-}\n\\ No newline at end of file\n+    auto my_d = obj() { with my_a } ;\n+    \n+}"}, {"sha": "df56f4810ee5c55b38cfc58b62913408a6e3fd62", "filename": "src/test/run-pass/simple-anon-objs.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fa5a7e7453ee6aae73c639e16db7d208b5949b4d/src%2Ftest%2Frun-pass%2Fsimple-anon-objs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5a7e7453ee6aae73c639e16db7d208b5949b4d/src%2Ftest%2Frun-pass%2Fsimple-anon-objs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimple-anon-objs.rs?ref=fa5a7e7453ee6aae73c639e16db7d208b5949b4d", "patch": "@@ -1,7 +1,6 @@\n \n \n // xfail-stage0\n-// xfail-stage1\n use std;\n \n fn main() {\n@@ -11,10 +10,24 @@ fn main() {\n     auto my_a = a();\n     // Extending an object with a new method\n \n-    auto my_b = anon obj;\n-    assert (my_a.foo() == 2);\n-    // FIXME: these raise a runtime error\n-    //assert my_b.foo() == 2;\n+    auto my_b = obj { \n+        fn bar() -> int { \n+            ret 3;\n+        }\n+        with my_a \n+    };\n \n+    assert (my_a.foo() == 2);\n     assert (my_b.bar() == 3);\n-}\n\\ No newline at end of file\n+\n+    auto my_c = obj {\n+        fn baz() -> int {\n+            ret 4;\n+        }\n+        with my_b\n+    };\n+\n+    assert (my_c.baz() == 4);\n+\n+}\n+"}]}