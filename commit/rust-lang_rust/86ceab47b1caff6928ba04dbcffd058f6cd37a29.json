{"sha": "86ceab47b1caff6928ba04dbcffd058f6cd37a29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2Y2VhYjQ3YjFjYWZmNjkyOGJhMDRkYmNmZmQwNThmNmNkMzdhMjk=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-08-11T19:18:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-11T19:18:47Z"}, "message": "Rollup merge of #63453 - Mark-Simulacrum:rustdoc-clean-2, r=GuillaumeGomez\n\nrustdoc: general cleanup\n\nAlmost all commits stand alone; but all commits can be reviewed individually.", "tree": {"sha": "140989dc20dead69cf71d0701459298d658f704d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/140989dc20dead69cf71d0701459298d658f704d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86ceab47b1caff6928ba04dbcffd058f6cd37a29", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdUGoYCRBK7hj4Ov3rIwAAdHIIAFE3Z1Qrt7SXlqsTh7T+R8Mo\ncB55dSaHkf0+B7Ne3vfwAj3BE4a5mksO+3gK9mSt/p0ErehQhZn+ZsaeJNUW/8x1\nfefOKE5QQuu/GnPUuIA4dP8fbI5noTw4c6Yi9+5BtMx600OOrY2q5eM9fKksdCfU\n6tbLqWgi+38WlCieMHUTI34QJZDdkl3GAFIOX1tj8mIU1/547jWDFe4y5w+P7lb2\n/ZarAfuX0Gv8lx+zkLjKRGIsJLEcCSccd/JuVIiPiPTeOoEk8aX6DZURIr5bCIWM\ndfXUPTL9lYigxkV6NJ75gmQMv6zYCdzFJ4dgRA1ziMR/VHKAAVgiVLw/yPihyac=\n=wyv9\n-----END PGP SIGNATURE-----\n", "payload": "tree 140989dc20dead69cf71d0701459298d658f704d\nparent e16b12fd49748a5aa7fbdabd6cea13fffbc3bb3d\nparent 3b8a24d193a3b2d9e7a888338d0c2bb478892ec2\nauthor Mark Rousskov <mark.simulacrum@gmail.com> 1565551127 -0400\ncommitter GitHub <noreply@github.com> 1565551127 -0400\n\nRollup merge of #63453 - Mark-Simulacrum:rustdoc-clean-2, r=GuillaumeGomez\n\nrustdoc: general cleanup\n\nAlmost all commits stand alone; but all commits can be reviewed individually.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86ceab47b1caff6928ba04dbcffd058f6cd37a29", "html_url": "https://github.com/rust-lang/rust/commit/86ceab47b1caff6928ba04dbcffd058f6cd37a29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86ceab47b1caff6928ba04dbcffd058f6cd37a29/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e16b12fd49748a5aa7fbdabd6cea13fffbc3bb3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e16b12fd49748a5aa7fbdabd6cea13fffbc3bb3d", "html_url": "https://github.com/rust-lang/rust/commit/e16b12fd49748a5aa7fbdabd6cea13fffbc3bb3d"}, {"sha": "3b8a24d193a3b2d9e7a888338d0c2bb478892ec2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b8a24d193a3b2d9e7a888338d0c2bb478892ec2", "html_url": "https://github.com/rust-lang/rust/commit/3b8a24d193a3b2d9e7a888338d0c2bb478892ec2"}], "stats": {"total": 670, "additions": 322, "deletions": 348}, "files": [{"sha": "ab6731e4d433d583bcfa0c7dccbeff6c631216bf", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -3252,7 +3252,6 @@ name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n  \"minifier 0.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "0eb8b73016d1048493b682d6b33f86cee31ed05f", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -13,4 +13,3 @@ pulldown-cmark = { version = \"0.5.3\", default-features = false }\n minifier = \"0.0.33\"\n rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n tempfile = \"3\"\n-parking_lot = \"0.7\""}, {"sha": "490d4107c51abf325cb65d0212b663d3a68f7008", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -3,6 +3,7 @@ use rustc::traits;\n use rustc::ty::ToPredicate;\n use rustc::ty::subst::Subst;\n use rustc::infer::InferOk;\n+use rustc::hir::def_id::LOCAL_CRATE;\n use syntax_pos::DUMMY_SP;\n \n use super::*;\n@@ -27,7 +28,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n \n         debug!(\"get_blanket_impls({:?})\", ty);\n         let mut impls = Vec::new();\n-        for &trait_def_id in self.cx.all_traits.iter() {\n+        for &trait_def_id in self.cx.tcx.all_traits(LOCAL_CRATE).iter() {\n             if !self.cx.renderinfo.borrow().access_levels.is_public(trait_def_id) ||\n                self.cx.generated_synthetics\n                       .borrow_mut()"}, {"sha": "6f93c95edef08713d5a625ac8b3a1a46b576e455", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -163,10 +163,7 @@ pub fn load_attrs<'hir>(cx: &DocContext<'hir>, did: DefId) -> Attrs<'hir> {\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n pub fn record_extern_fqn(cx: &DocContext<'_>, did: DefId, kind: clean::TypeKind) {\n-    let mut crate_name = cx.tcx.crate_name(did.krate).to_string();\n-    if did.is_local() {\n-        crate_name = cx.crate_name.clone().unwrap_or(crate_name);\n-    }\n+    let crate_name = cx.tcx.crate_name(did.krate).to_string();\n \n     let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n         // extern blocks have an empty name\n@@ -577,22 +574,18 @@ pub fn record_extern_trait(cx: &DocContext<'_>, did: DefId) {\n     }\n \n     {\n-        let external_traits = cx.external_traits.lock();\n-        if external_traits.borrow().contains_key(&did) ||\n+        if cx.external_traits.borrow().contains_key(&did) ||\n             cx.active_extern_traits.borrow().contains(&did)\n         {\n             return;\n         }\n     }\n \n-    cx.active_extern_traits.borrow_mut().push(did);\n+    cx.active_extern_traits.borrow_mut().insert(did);\n \n     debug!(\"record_extern_trait: {:?}\", did);\n     let trait_ = build_external_trait(cx, did);\n \n-    {\n-        let external_traits = cx.external_traits.lock();\n-        external_traits.borrow_mut().insert(did, trait_);\n-    }\n-    cx.active_extern_traits.borrow_mut().remove_item(&did);\n+    cx.external_traits.borrow_mut().insert(did, trait_);\n+    cx.active_extern_traits.borrow_mut().remove(&did);\n }"}, {"sha": "b281505956d6ab3a807377b310da379ad76b972b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -39,14 +39,12 @@ use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::default::Default;\n use std::{mem, slice, vec};\n-use std::iter::{FromIterator, once};\n+use std::iter::FromIterator;\n use std::rc::Rc;\n use std::cell::RefCell;\n use std::sync::Arc;\n use std::u32;\n \n-use parking_lot::ReentrantMutex;\n-\n use crate::core::{self, DocContext};\n use crate::doctree;\n use crate::html::render::{cache, ExternalLocation};\n@@ -133,8 +131,9 @@ pub struct Crate {\n     pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n     // These are later on moved into `CACHEKEY`, leaving the map empty.\n     // Only here so that they can be filtered through the rustdoc passes.\n-    pub external_traits: Arc<ReentrantMutex<RefCell<FxHashMap<DefId, Trait>>>>,\n+    pub external_traits: Rc<RefCell<FxHashMap<DefId, Trait>>>,\n     pub masked_crates: FxHashSet<CrateNum>,\n+    pub collapsed: bool,\n }\n \n impl Clean<Crate> for hir::Crate {\n@@ -223,6 +222,7 @@ impl Clean<Crate> for hir::Crate {\n             primitives,\n             external_traits: cx.external_traits.clone(),\n             masked_crates,\n+            collapsed: false,\n         }\n     }\n }\n@@ -4398,24 +4398,6 @@ impl Clean<TypeBindingKind> for hir::TypeBindingKind {\n     }\n }\n \n-pub fn def_id_to_path(\n-    cx: &DocContext<'_>,\n-    did: DefId,\n-    name: Option<String>\n-) -> Vec<String> {\n-    let crate_name = name.unwrap_or_else(|| cx.tcx.crate_name(did.krate).to_string());\n-    let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n-        // extern blocks have an empty name\n-        let s = elem.data.to_string();\n-        if !s.is_empty() {\n-            Some(s)\n-        } else {\n-            None\n-        }\n-    });\n-    once(crate_name).chain(relative).collect()\n-}\n-\n pub fn enter_impl_trait<F, R>(cx: &DocContext<'_>, f: F) -> R\n where\n     F: FnOnce() -> R,"}, {"sha": "98ab957ecbb38078a3b5fea1af8d3e21c9d03235", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -220,22 +220,22 @@ impl Options {\n                 println!(\"{:>20} - {}\", pass.name, pass.description);\n             }\n             println!(\"\\nDefault passes for rustdoc:\");\n-            for &name in passes::DEFAULT_PASSES {\n-                println!(\"{:>20}\", name);\n+            for pass in passes::DEFAULT_PASSES {\n+                println!(\"{:>20}\", pass.name);\n             }\n             println!(\"\\nPasses run with `--document-private-items`:\");\n-            for &name in passes::DEFAULT_PRIVATE_PASSES {\n-                println!(\"{:>20}\", name);\n+            for pass in passes::DEFAULT_PRIVATE_PASSES {\n+                println!(\"{:>20}\", pass.name);\n             }\n \n             if nightly_options::is_nightly_build() {\n                 println!(\"\\nPasses run with `--show-coverage`:\");\n-                for &name in passes::DEFAULT_COVERAGE_PASSES {\n-                    println!(\"{:>20}\", name);\n+                for pass in passes::DEFAULT_COVERAGE_PASSES {\n+                    println!(\"{:>20}\", pass.name);\n                 }\n                 println!(\"\\nPasses run with `--show-coverage --document-private-items`:\");\n-                for &name in passes::PRIVATE_COVERAGE_PASSES {\n-                    println!(\"{:>20}\", name);\n+                for pass in passes::PRIVATE_COVERAGE_PASSES {\n+                    println!(\"{:>20}\", pass.name);\n                 }\n             }\n \n@@ -378,7 +378,7 @@ impl Options {\n                 &matches.opt_strs(\"html-after-content\"),\n                 &matches.opt_strs(\"markdown-before-content\"),\n                 &matches.opt_strs(\"markdown-after-content\"),\n-                &diag, &mut id_map, edition) {\n+                &diag, &mut id_map, edition, &None) {\n             Some(eh) => eh,\n             None => return Err(3),\n         };"}, {"sha": "87381f224d0bb424482d1c6f409599da3a84f81b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -22,12 +22,10 @@ use syntax::json::JsonEmitter;\n use syntax::symbol::sym;\n use errors;\n use errors::emitter::{Emitter, EmitterWriter};\n-use parking_lot::ReentrantMutex;\n \n use std::cell::RefCell;\n use std::mem;\n use rustc_data_structures::sync::{self, Lrc};\n-use std::sync::Arc;\n use std::rc::Rc;\n \n use crate::config::{Options as RustdocOptions, RenderOptions};\n@@ -46,16 +44,14 @@ pub struct DocContext<'tcx> {\n \n     pub tcx: TyCtxt<'tcx>,\n     pub resolver: Rc<RefCell<interface::BoxedResolver>>,\n-    /// The stack of module NodeIds up till this point\n-    pub crate_name: Option<String>,\n     pub cstore: Lrc<CStore>,\n     /// Later on moved into `html::render::CACHE_KEY`\n     pub renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n-    pub external_traits: Arc<ReentrantMutex<RefCell<FxHashMap<DefId, clean::Trait>>>>,\n+    pub external_traits: Rc<RefCell<FxHashMap<DefId, clean::Trait>>>,\n     /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n     /// the same time.\n-    pub active_extern_traits: RefCell<Vec<DefId>>,\n+    pub active_extern_traits: RefCell<FxHashSet<DefId>>,\n     // The current set of type and lifetime substitutions,\n     // for expanding type aliases at the HIR level:\n \n@@ -72,7 +68,6 @@ pub struct DocContext<'tcx> {\n     /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n     // FIXME(eddyb) make this a `ty::TraitRef<'tcx>` set.\n     pub generated_synthetics: RefCell<FxHashSet<(Ty<'tcx>, DefId)>>,\n-    pub all_traits: Vec<DefId>,\n     pub auto_traits: Vec<DefId>,\n }\n \n@@ -227,7 +222,7 @@ pub fn new_handler(error_format: ErrorOutputType,\n     )\n }\n \n-pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOptions, Vec<String>) {\n+pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOptions) {\n     // Parse, resolve, and typecheck the given crate.\n \n     let RustdocOptions {\n@@ -332,7 +327,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         file_loader: None,\n         diagnostic_output: DiagnosticOutput::Default,\n         stderr: None,\n-        crate_name: crate_name.clone(),\n+        crate_name,\n         lint_caps,\n     };\n \n@@ -368,11 +363,9 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             let mut renderinfo = RenderInfo::default();\n             renderinfo.access_levels = access_levels;\n \n-            let all_traits = tcx.all_traits(LOCAL_CRATE).to_vec();\n             let ctxt = DocContext {\n                 tcx,\n                 resolver,\n-                crate_name,\n                 cstore: compiler.cstore().clone(),\n                 external_traits: Default::default(),\n                 active_extern_traits: Default::default(),\n@@ -384,10 +377,9 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                 fake_def_ids: Default::default(),\n                 all_fake_def_ids: Default::default(),\n                 generated_synthetics: Default::default(),\n-                auto_traits: all_traits.iter().cloned().filter(|trait_def_id| {\n+                auto_traits: tcx.all_traits(LOCAL_CRATE).iter().cloned().filter(|trait_def_id| {\n                     tcx.trait_is_auto(*trait_def_id)\n                 }).collect(),\n-                all_traits,\n             };\n             debug!(\"crate: {:?}\", tcx.hir().krate());\n \n@@ -432,8 +424,8 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                         },\n                         _ => continue,\n                     };\n-                    for p in value.as_str().split_whitespace() {\n-                        sink.push(p.to_string());\n+                    for name in value.as_str().split_whitespace() {\n+                        sink.push(name.to_string());\n                     }\n                 }\n \n@@ -444,25 +436,26 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                 }\n             }\n \n-            let mut passes: Vec<String> =\n-                passes::defaults(default_passes).iter().map(|p| p.to_string()).collect();\n-            passes.extend(manual_passes);\n+            let passes = passes::defaults(default_passes).iter().chain(manual_passes.into_iter()\n+                .flat_map(|name| {\n+                    if let Some(pass) = passes::find_pass(&name) {\n+                        Some(pass)\n+                    } else {\n+                        error!(\"unknown pass {}, skipping\", name);\n+                        None\n+                    }\n+                }));\n \n             info!(\"Executing passes\");\n \n-            for pass_name in &passes {\n-                match passes::find_pass(pass_name).map(|p| p.pass) {\n-                    Some(pass) => {\n-                        debug!(\"running pass {}\", pass_name);\n-                        krate = pass(krate, &ctxt);\n-                    }\n-                    None => error!(\"unknown pass {}, skipping\", *pass_name),\n-                }\n+            for pass in passes {\n+                debug!(\"running pass {}\", pass.name);\n+                krate = (pass.pass)(krate, &ctxt);\n             }\n \n             ctxt.sess().abort_if_errors();\n \n-            (krate, ctxt.renderinfo.into_inner(), render_options, passes)\n+            (krate, ctxt.renderinfo.into_inner(), render_options)\n         })\n     })\n }"}, {"sha": "6e453561f6da20f06d283b1e666dbc958f4a3032", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -13,7 +13,7 @@ use rustc::hir::ptr::P;\n \n pub struct Module<'hir> {\n     pub name: Option<Name>,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub where_outer: Span,\n     pub where_inner: Span,\n     pub extern_crates: Vec<ExternCrate<'hir>>,\n@@ -41,7 +41,7 @@ pub struct Module<'hir> {\n impl Module<'hir> {\n     pub fn new(\n         name: Option<Name>,\n-        attrs: &'hir hir::HirVec<ast::Attribute>,\n+        attrs: &'hir [ast::Attribute],\n         vis: &'hir hir::Visibility,\n     ) -> Module<'hir> {\n         Module {\n@@ -89,7 +89,7 @@ pub struct Struct<'hir> {\n     pub struct_type: StructType,\n     pub name: Name,\n     pub generics: &'hir hir::Generics,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub fields: &'hir [hir::StructField],\n     pub whence: Span,\n }\n@@ -100,7 +100,7 @@ pub struct Union<'hir> {\n     pub struct_type: StructType,\n     pub name: Name,\n     pub generics: &'hir hir::Generics,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub fields: &'hir [hir::StructField],\n     pub whence: Span,\n }\n@@ -109,7 +109,7 @@ pub struct Enum<'hir> {\n     pub vis: &'hir hir::Visibility,\n     pub variants: Vec<Variant<'hir>>,\n     pub generics: &'hir hir::Generics,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub whence: Span,\n     pub name: Name,\n@@ -118,14 +118,14 @@ pub struct Enum<'hir> {\n pub struct Variant<'hir> {\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub def: &'hir hir::VariantData,\n     pub whence: Span,\n }\n \n pub struct Function<'hir> {\n     pub decl: &'hir hir::FnDecl,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub name: Name,\n     pub vis: &'hir hir::Visibility,\n@@ -140,7 +140,7 @@ pub struct Typedef<'hir> {\n     pub gen: &'hir hir::Generics,\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n     pub vis: &'hir hir::Visibility,\n }\n@@ -149,7 +149,7 @@ pub struct OpaqueTy<'hir> {\n     pub opaque_ty: &'hir hir::OpaqueTy,\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n     pub vis: &'hir hir::Visibility,\n }\n@@ -160,7 +160,7 @@ pub struct Static<'hir> {\n     pub mutability: hir::Mutability,\n     pub expr: hir::BodyId,\n     pub name: Name,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub vis: &'hir hir::Visibility,\n     pub id: hir::HirId,\n     pub whence: Span,\n@@ -170,7 +170,7 @@ pub struct Constant<'hir> {\n     pub type_: &'hir P<hir::Ty>,\n     pub expr: hir::BodyId,\n     pub name: Name,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub vis: &'hir hir::Visibility,\n     pub id: hir::HirId,\n     pub whence: Span,\n@@ -182,8 +182,8 @@ pub struct Trait<'hir> {\n     pub name: Name,\n     pub items: Vec<&'hir hir::TraitItem>,\n     pub generics: &'hir hir::Generics,\n-    pub bounds: &'hir hir::HirVec<hir::GenericBound>,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub bounds: &'hir [hir::GenericBound],\n+    pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub whence: Span,\n     pub vis: &'hir hir::Visibility,\n@@ -192,8 +192,8 @@ pub struct Trait<'hir> {\n pub struct TraitAlias<'hir> {\n     pub name: Name,\n     pub generics: &'hir hir::Generics,\n-    pub bounds: &'hir hir::HirVec<hir::GenericBound>,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub bounds: &'hir [hir::GenericBound],\n+    pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub whence: Span,\n     pub vis: &'hir hir::Visibility,\n@@ -208,7 +208,7 @@ pub struct Impl<'hir> {\n     pub trait_: &'hir Option<hir::TraitRef>,\n     pub for_: &'hir P<hir::Ty>,\n     pub items: Vec<&'hir hir::ImplItem>,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n     pub vis: &'hir hir::Visibility,\n     pub id: hir::HirId,\n@@ -219,7 +219,7 @@ pub struct ForeignItem<'hir> {\n     pub id: hir::HirId,\n     pub name: Name,\n     pub kind: &'hir hir::ForeignItemKind,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n }\n \n@@ -229,7 +229,7 @@ pub struct Macro<'hir> {\n     pub name: Name,\n     pub hid: hir::HirId,\n     pub def_id: hir::def_id::DefId,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n     pub matchers: hir::HirVec<Span>,\n     pub imported_from: Option<Name>,\n@@ -240,15 +240,15 @@ pub struct ExternCrate<'hir> {\n     pub cnum: CrateNum,\n     pub path: Option<String>,\n     pub vis: &'hir hir::Visibility,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n }\n \n pub struct Import<'hir> {\n     pub name: Name,\n     pub id: hir::HirId,\n     pub vis: &'hir hir::Visibility,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub path: &'hir hir::Path,\n     pub glob: bool,\n     pub whence: Span,\n@@ -259,7 +259,7 @@ pub struct ProcMacro<'hir> {\n     pub id: hir::HirId,\n     pub kind: MacroKind,\n     pub helpers: Vec<Name>,\n-    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n }\n "}, {"sha": "56f1191feed0bb7cca9da143bc25605d2b4a7e05", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -4,9 +4,7 @@ use std::str;\n use errors;\n use crate::syntax::feature_gate::UnstableFeatures;\n use crate::syntax::edition::Edition;\n-use crate::html::markdown::{IdMap, ErrorCodes, Markdown};\n-\n-use std::cell::RefCell;\n+use crate::html::markdown::{IdMap, ErrorCodes, Markdown, Playground};\n \n #[derive(Clone, Debug)]\n pub struct ExternalHtml {\n@@ -24,37 +22,23 @@ pub struct ExternalHtml {\n impl ExternalHtml {\n     pub fn load(in_header: &[String], before_content: &[String], after_content: &[String],\n                 md_before_content: &[String], md_after_content: &[String], diag: &errors::Handler,\n-                id_map: &mut IdMap, edition: Edition)\n+                id_map: &mut IdMap, edition: Edition, playground: &Option<Playground>)\n             -> Option<ExternalHtml> {\n         let codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n-        load_external_files(in_header, diag)\n-            .and_then(|ih|\n-                load_external_files(before_content, diag)\n-                    .map(|bc| (ih, bc))\n-            )\n-            .and_then(|(ih, bc)|\n-                load_external_files(md_before_content, diag)\n-                    .map(|m_bc| (ih,\n-                            format!(\"{}{}\", bc, Markdown(&m_bc, &[], RefCell::new(id_map),\n-                                    codes, edition))))\n-            )\n-            .and_then(|(ih, bc)|\n-                load_external_files(after_content, diag)\n-                    .map(|ac| (ih, bc, ac))\n-            )\n-            .and_then(|(ih, bc, ac)|\n-                load_external_files(md_after_content, diag)\n-                    .map(|m_ac| (ih, bc,\n-                            format!(\"{}{}\", ac, Markdown(&m_ac, &[], RefCell::new(id_map),\n-                                    codes, edition))))\n-            )\n-            .map(|(ih, bc, ac)|\n-                ExternalHtml {\n-                    in_header: ih,\n-                    before_content: bc,\n-                    after_content: ac,\n-                }\n-            )\n+        let ih = load_external_files(in_header, diag)?;\n+        let bc = load_external_files(before_content, diag)?;\n+        let m_bc = load_external_files(md_before_content, diag)?;\n+        let bc = format!(\"{}{}\", bc, Markdown(&m_bc, &[], id_map,\n+                                    codes, edition, playground).to_string());\n+        let ac = load_external_files(after_content, diag)?;\n+        let m_ac = load_external_files(md_after_content, diag)?;\n+        let ac = format!(\"{}{}\", ac, Markdown(&m_ac, &[], id_map,\n+                                    codes, edition, playground).to_string());\n+        Some(ExternalHtml {\n+            in_header: ih,\n+            before_content: bc,\n+            after_content: ac,\n+        })\n     }\n }\n "}, {"sha": "5482239c7ce28dd2b1ac3da5be0ba57f341b82f8", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -105,12 +105,12 @@ pub trait DocFolder : Sized {\n         c.module = c.module.take().and_then(|module| self.fold_item(module));\n \n         {\n-            let guard = c.external_traits.lock();\n-            let traits = guard.replace(Default::default());\n-            guard.borrow_mut().extend(traits.into_iter().map(|(k, mut v)| {\n+            let mut guard = c.external_traits.borrow_mut();\n+            let external_traits = std::mem::replace(&mut *guard, Default::default());\n+            *guard = external_traits.into_iter().map(|(k, mut v)| {\n                 v.items = v.items.into_iter().filter_map(|i| self.fold_item(i)).collect();\n                 (k, v)\n-            }));\n+            }).collect();\n         }\n         c\n     }"}, {"sha": "5a7deb651b00d8e9866fde5c3dd3b133621f1319", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 133, "deletions": 126, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -1,9 +1,6 @@\n //! Markdown formatting for rustdoc.\n //!\n-//! This module implements markdown formatting through the pulldown-cmark\n-//! rust-library. This module exposes all of the\n-//! functionality through a unit struct, `Markdown`, which has an implementation\n-//! of `fmt::Display`. Example usage:\n+//! This module implements markdown formatting through the pulldown-cmark library.\n //!\n //! ```\n //! #![feature(rustc_private)]\n@@ -12,12 +9,11 @@\n //!\n //! use syntax::edition::Edition;\n //! use rustdoc::html::markdown::{IdMap, Markdown, ErrorCodes};\n-//! use std::cell::RefCell;\n //!\n //! let s = \"My *markdown* _text_\";\n //! let mut id_map = IdMap::new();\n-//! let html = format!(\"{}\", Markdown(s, &[], RefCell::new(&mut id_map),\n-//!                                   ErrorCodes::Yes, Edition::Edition2015));\n+//! let md = Markdown(s, &[], &mut id_map, ErrorCodes::Yes, Edition::Edition2015, &None);\n+//! let html = md.to_string();\n //! // ... something using html\n //! ```\n \n@@ -27,7 +23,7 @@ use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n use std::collections::VecDeque;\n use std::default::Default;\n-use std::fmt::{self, Write};\n+use std::fmt::Write;\n use std::borrow::Cow;\n use std::ops::Range;\n use std::str;\n@@ -46,29 +42,36 @@ fn opts() -> Options {\n     Options::ENABLE_TABLES | Options::ENABLE_FOOTNOTES\n }\n \n-/// A tuple struct that has the `fmt::Display` trait implemented.\n-/// When formatted, this struct will emit the HTML corresponding to the rendered\n-/// version of the contained markdown string.\n+/// When `to_string` is called, this struct will emit the HTML corresponding to\n+/// the rendered version of the contained markdown string.\n pub struct Markdown<'a>(\n     pub &'a str,\n     /// A list of link replacements.\n     pub &'a [(String, String)],\n     /// The current list of used header IDs.\n-    pub RefCell<&'a mut IdMap>,\n+    pub &'a mut IdMap,\n     /// Whether to allow the use of explicit error codes in doctest lang strings.\n     pub ErrorCodes,\n     /// Default edition to use when parsing doctests (to add a `fn main`).\n     pub Edition,\n+    pub &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders the markdown with a table of contents.\n pub struct MarkdownWithToc<'a>(\n     pub &'a str,\n-    pub RefCell<&'a mut IdMap>,\n+    pub &'a mut IdMap,\n     pub ErrorCodes,\n     pub Edition,\n+    pub &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders the markdown escaping HTML tags.\n-pub struct MarkdownHtml<'a>(pub &'a str, pub RefCell<&'a mut IdMap>, pub ErrorCodes, pub Edition);\n+pub struct MarkdownHtml<'a>(\n+    pub &'a str,\n+    pub &'a mut IdMap,\n+    pub ErrorCodes,\n+    pub Edition,\n+    pub &'a Option<Playground>,\n+);\n /// A tuple struct like `Markdown` that renders only the first paragraph.\n pub struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [(String, String)]);\n \n@@ -155,30 +158,39 @@ fn slugify(c: char) -> Option<char> {\n     }\n }\n \n-// Information about the playground if a URL has been specified, containing an\n-// optional crate name and the URL.\n-thread_local!(pub static PLAYGROUND: RefCell<Option<(Option<String>, String)>> = {\n-    RefCell::new(None)\n-});\n+#[derive(Clone, Debug)]\n+pub struct Playground {\n+    pub crate_name: Option<String>,\n+    pub url: String,\n+}\n \n /// Adds syntax highlighting and playground Run buttons to Rust code blocks.\n-struct CodeBlocks<'a, I: Iterator<Item = Event<'a>>> {\n+struct CodeBlocks<'p, 'a, I: Iterator<Item = Event<'a>>> {\n     inner: I,\n     check_error_codes: ErrorCodes,\n     edition: Edition,\n+    // Information about the playground if a URL has been specified, containing an\n+    // optional crate name and the URL.\n+    playground: &'p Option<Playground>,\n }\n \n-impl<'a, I: Iterator<Item = Event<'a>>> CodeBlocks<'a, I> {\n-    fn new(iter: I, error_codes: ErrorCodes, edition: Edition) -> Self {\n+impl<'p, 'a, I: Iterator<Item = Event<'a>>> CodeBlocks<'p, 'a, I> {\n+    fn new(\n+        iter: I,\n+        error_codes: ErrorCodes,\n+        edition: Edition,\n+        playground: &'p Option<Playground>,\n+    ) -> Self {\n         CodeBlocks {\n             inner: iter,\n             check_error_codes: error_codes,\n             edition,\n+            playground,\n         }\n     }\n }\n \n-impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n+impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n     type Item = Event<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -213,86 +225,86 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n         }\n         let lines = origtext.lines().filter_map(|l| map_line(l).for_html());\n         let text = lines.collect::<Vec<Cow<'_, str>>>().join(\"\\n\");\n-        PLAYGROUND.with(|play| {\n-            // insert newline to clearly separate it from the\n-            // previous block so we can shorten the html output\n-            let mut s = String::from(\"\\n\");\n-            let playground_button = play.borrow().as_ref().and_then(|&(ref krate, ref url)| {\n-                if url.is_empty() {\n-                    return None;\n-                }\n-                let test = origtext.lines()\n-                    .map(|l| map_line(l).for_code())\n-                    .collect::<Vec<Cow<'_, str>>>().join(\"\\n\");\n-                let krate = krate.as_ref().map(|s| &**s);\n-                let (test, _) = test::make_test(&test, krate, false,\n-                                           &Default::default(), edition);\n-                let channel = if test.contains(\"#![feature(\") {\n-                    \"&amp;version=nightly\"\n-                } else {\n-                    \"\"\n-                };\n-\n-                let edition_string = format!(\"&amp;edition={}\", edition);\n-\n-                // These characters don't need to be escaped in a URI.\n-                // FIXME: use a library function for percent encoding.\n-                fn dont_escape(c: u8) -> bool {\n-                    (b'a' <= c && c <= b'z') ||\n-                    (b'A' <= c && c <= b'Z') ||\n-                    (b'0' <= c && c <= b'9') ||\n-                    c == b'-' || c == b'_' || c == b'.' ||\n-                    c == b'~' || c == b'!' || c == b'\\'' ||\n-                    c == b'(' || c == b')' || c == b'*'\n-                }\n-                let mut test_escaped = String::new();\n-                for b in test.bytes() {\n-                    if dont_escape(b) {\n-                        test_escaped.push(char::from(b));\n-                    } else {\n-                        write!(test_escaped, \"%{:02X}\", b).unwrap();\n-                    }\n-                }\n-                Some(format!(\n-                    r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}{}\">Run</a>\"#,\n-                    url, test_escaped, channel, edition_string\n-                ))\n-            });\n-\n-            let tooltip = if ignore {\n-                Some((\"This example is not tested\".to_owned(), \"ignore\"))\n-            } else if compile_fail {\n-                Some((\"This example deliberately fails to compile\".to_owned(), \"compile_fail\"))\n-            } else if explicit_edition {\n-                Some((format!(\"This code runs with edition {}\", edition), \"edition\"))\n+        // insert newline to clearly separate it from the\n+        // previous block so we can shorten the html output\n+        let mut s = String::from(\"\\n\");\n+        let playground_button = self.playground.as_ref().and_then(|playground| {\n+            let krate = &playground.crate_name;\n+            let url = &playground.url;\n+            if url.is_empty() {\n+                return None;\n+            }\n+            let test = origtext.lines()\n+                .map(|l| map_line(l).for_code())\n+                .collect::<Vec<Cow<'_, str>>>().join(\"\\n\");\n+            let krate = krate.as_ref().map(|s| &**s);\n+            let (test, _) = test::make_test(&test, krate, false,\n+                                        &Default::default(), edition);\n+            let channel = if test.contains(\"#![feature(\") {\n+                \"&amp;version=nightly\"\n             } else {\n-                None\n+                \"\"\n             };\n \n-            if let Some((s1, s2)) = tooltip {\n-                s.push_str(&highlight::render_with_highlighting(\n-                    &text,\n-                    Some(&format!(\"rust-example-rendered{}\",\n-                                  if ignore { \" ignore\" }\n-                                  else if compile_fail { \" compile_fail\" }\n-                                  else if explicit_edition { \" edition \" }\n-                                  else { \"\" })),\n-                    playground_button.as_ref().map(String::as_str),\n-                    Some((s1.as_str(), s2))));\n-                Some(Event::Html(s.into()))\n-            } else {\n-                s.push_str(&highlight::render_with_highlighting(\n-                    &text,\n-                    Some(&format!(\"rust-example-rendered{}\",\n-                                  if ignore { \" ignore\" }\n-                                  else if compile_fail { \" compile_fail\" }\n-                                  else if explicit_edition { \" edition \" }\n-                                  else { \"\" })),\n-                    playground_button.as_ref().map(String::as_str),\n-                    None));\n-                Some(Event::Html(s.into()))\n+            let edition_string = format!(\"&amp;edition={}\", edition);\n+\n+            // These characters don't need to be escaped in a URI.\n+            // FIXME: use a library function for percent encoding.\n+            fn dont_escape(c: u8) -> bool {\n+                (b'a' <= c && c <= b'z') ||\n+                (b'A' <= c && c <= b'Z') ||\n+                (b'0' <= c && c <= b'9') ||\n+                c == b'-' || c == b'_' || c == b'.' ||\n+                c == b'~' || c == b'!' || c == b'\\'' ||\n+                c == b'(' || c == b')' || c == b'*'\n+            }\n+            let mut test_escaped = String::new();\n+            for b in test.bytes() {\n+                if dont_escape(b) {\n+                    test_escaped.push(char::from(b));\n+                } else {\n+                    write!(test_escaped, \"%{:02X}\", b).unwrap();\n+                }\n             }\n-        })\n+            Some(format!(\n+                r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}{}\">Run</a>\"#,\n+                url, test_escaped, channel, edition_string\n+            ))\n+        });\n+\n+        let tooltip = if ignore {\n+            Some((\"This example is not tested\".to_owned(), \"ignore\"))\n+        } else if compile_fail {\n+            Some((\"This example deliberately fails to compile\".to_owned(), \"compile_fail\"))\n+        } else if explicit_edition {\n+            Some((format!(\"This code runs with edition {}\", edition), \"edition\"))\n+        } else {\n+            None\n+        };\n+\n+        if let Some((s1, s2)) = tooltip {\n+            s.push_str(&highlight::render_with_highlighting(\n+                &text,\n+                Some(&format!(\"rust-example-rendered{}\",\n+                                if ignore { \" ignore\" }\n+                                else if compile_fail { \" compile_fail\" }\n+                                else if explicit_edition { \" edition \" }\n+                                else { \"\" })),\n+                playground_button.as_ref().map(String::as_str),\n+                Some((s1.as_str(), s2))));\n+            Some(Event::Html(s.into()))\n+        } else {\n+            s.push_str(&highlight::render_with_highlighting(\n+                &text,\n+                Some(&format!(\"rust-example-rendered{}\",\n+                                if ignore { \" ignore\" }\n+                                else if compile_fail { \" compile_fail\" }\n+                                else if explicit_edition { \" edition \" }\n+                                else { \"\" })),\n+                playground_button.as_ref().map(String::as_str),\n+                None));\n+            Some(Event::Html(s.into()))\n+        }\n     }\n }\n \n@@ -674,13 +686,12 @@ impl LangString {\n     }\n }\n \n-impl<'a> fmt::Display for Markdown<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let Markdown(md, links, ref ids, codes, edition) = *self;\n-        let mut ids = ids.borrow_mut();\n+impl Markdown<'_> {\n+    pub fn to_string(self) -> String {\n+        let Markdown(md, links, mut ids, codes, edition, playground) = self;\n \n         // This is actually common enough to special-case\n-        if md.is_empty() { return Ok(()) }\n+        if md.is_empty() { return String::new(); }\n         let replacer = |_: &str, s: &str| {\n             if let Some(&(_, ref replace)) = links.into_iter().find(|link| &*link.0 == s) {\n                 Some((replace.clone(), s.to_owned()))\n@@ -695,18 +706,17 @@ impl<'a> fmt::Display for Markdown<'a> {\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n         let p = LinkReplacer::new(p, links);\n-        let p = CodeBlocks::new(p, codes, edition);\n+        let p = CodeBlocks::new(p, codes, edition, playground);\n         let p = Footnotes::new(p);\n         html::push_html(&mut s, p);\n \n-        fmt.write_str(&s)\n+        s\n     }\n }\n \n-impl<'a> fmt::Display for MarkdownWithToc<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let MarkdownWithToc(md, ref ids, codes, edition) = *self;\n-        let mut ids = ids.borrow_mut();\n+impl MarkdownWithToc<'_> {\n+    pub fn to_string(self) -> String {\n+        let MarkdownWithToc(md, mut ids, codes, edition, playground) = self;\n \n         let p = Parser::new_ext(md, opts());\n \n@@ -716,24 +726,21 @@ impl<'a> fmt::Display for MarkdownWithToc<'a> {\n \n         {\n             let p = HeadingLinks::new(p, Some(&mut toc), &mut ids);\n-            let p = CodeBlocks::new(p, codes, edition);\n+            let p = CodeBlocks::new(p, codes, edition, playground);\n             let p = Footnotes::new(p);\n             html::push_html(&mut s, p);\n         }\n \n-        write!(fmt, \"<nav id=\\\"TOC\\\">{}</nav>\", toc.into_toc())?;\n-\n-        fmt.write_str(&s)\n+        format!(\"<nav id=\\\"TOC\\\">{}</nav>{}\", toc.into_toc(), s)\n     }\n }\n \n-impl<'a> fmt::Display for MarkdownHtml<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let MarkdownHtml(md, ref ids, codes, edition) = *self;\n-        let mut ids = ids.borrow_mut();\n+impl MarkdownHtml<'_> {\n+    pub fn to_string(self) -> String {\n+        let MarkdownHtml(md, mut ids, codes, edition, playground) = self;\n \n         // This is actually common enough to special-case\n-        if md.is_empty() { return Ok(()) }\n+        if md.is_empty() { return String::new(); }\n         let p = Parser::new_ext(md, opts());\n \n         // Treat inline HTML as plain text.\n@@ -745,19 +752,19 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n-        let p = CodeBlocks::new(p, codes, edition);\n+        let p = CodeBlocks::new(p, codes, edition, playground);\n         let p = Footnotes::new(p);\n         html::push_html(&mut s, p);\n \n-        fmt.write_str(&s)\n+        s\n     }\n }\n \n-impl<'a> fmt::Display for MarkdownSummaryLine<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let MarkdownSummaryLine(md, links) = *self;\n+impl MarkdownSummaryLine<'_> {\n+    pub fn to_string(self) -> String {\n+        let MarkdownSummaryLine(md, links) = self;\n         // This is actually common enough to special-case\n-        if md.is_empty() { return Ok(()) }\n+        if md.is_empty() { return String::new(); }\n \n         let replacer = |_: &str, s: &str| {\n             if let Some(&(_, ref replace)) = links.into_iter().find(|link| &*link.0 == s) {\n@@ -773,7 +780,7 @@ impl<'a> fmt::Display for MarkdownSummaryLine<'a> {\n \n         html::push_html(&mut s, LinkReplacer::new(SummaryLine::new(p), links));\n \n-        fmt.write_str(&s)\n+        s\n     }\n }\n "}, {"sha": "a95c29038d46f77cced598d2b3c959db0ae4bac4", "filename": "src/librustdoc/html/markdown/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -73,8 +73,8 @@ fn test_lang_string_parse() {\n fn test_header() {\n     fn t(input: &str, expect: &str) {\n         let mut map = IdMap::new();\n-        let output = Markdown(input, &[], RefCell::new(&mut map),\n-                              ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n+        let output = Markdown(\n+            input, &[], &mut map, ErrorCodes::Yes, DEFAULT_EDITION, &None).to_string();\n         assert_eq!(output, expect, \"original: {}\", input);\n     }\n \n@@ -96,8 +96,8 @@ fn test_header() {\n fn test_header_ids_multiple_blocks() {\n     let mut map = IdMap::new();\n     fn t(map: &mut IdMap, input: &str, expect: &str) {\n-        let output = Markdown(input, &[], RefCell::new(map),\n-                              ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n+        let output = Markdown(input, &[], map,\n+                              ErrorCodes::Yes, DEFAULT_EDITION, &None).to_string();\n         assert_eq!(output, expect, \"original: {}\", input);\n     }\n \n@@ -134,8 +134,8 @@ fn test_plain_summary_line() {\n fn test_markdown_html_escape() {\n     fn t(input: &str, expect: &str) {\n         let mut idmap = IdMap::new();\n-        let output = MarkdownHtml(input, RefCell::new(&mut idmap),\n-                                  ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n+        let output = MarkdownHtml(input, &mut idmap,\n+                                  ErrorCodes::Yes, DEFAULT_EDITION, &None).to_string();\n         assert_eq!(output, expect, \"original: {}\", input);\n     }\n "}, {"sha": "ea97cea942820a61266789fe4159f29cfd96cf1a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -170,6 +170,7 @@ struct Context {\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     id_map: Rc<RefCell<IdMap>>,\n     pub shared: Arc<SharedContext>,\n+    playground: Option<markdown::Playground>,\n }\n \n struct SharedContext {\n@@ -185,8 +186,8 @@ struct SharedContext {\n     pub include_sources: bool,\n     /// The local file sources we've emitted and their respective url-paths.\n     pub local_sources: FxHashMap<PathBuf, String>,\n-    /// All the passes that were run on this crate.\n-    pub passes: FxHashSet<String>,\n+    /// Whether the collapsed pass ran\n+    pub collapsed: bool,\n     /// The base-URL of the issue tracker for when an item has been tagged with\n     /// an issue number.\n     pub issue_tracker_base_url: Option<String>,\n@@ -229,15 +230,10 @@ impl SharedContext {\n }\n \n impl SharedContext {\n-    /// Returns `true` if the `collapse-docs` pass was run on this crate.\n-    pub fn was_collapsed(&self) -> bool {\n-        self.passes.contains(\"collapse-docs\")\n-    }\n-\n     /// Based on whether the `collapse-docs` pass was run, return either the `doc_value` or the\n     /// `collapsed_doc_value` of the given item.\n     pub fn maybe_collapsed_doc_value<'a>(&self, item: &'a clean::Item) -> Option<Cow<'a, str>> {\n-        if self.was_collapsed() {\n+        if self.collapsed {\n             item.collapsed_doc_value().map(|s| s.into())\n         } else {\n             item.doc_value().map(|s| s.into())\n@@ -526,7 +522,6 @@ pub fn initial_ids() -> Vec<String> {\n /// Generates the documentation for `crate` into the directory `dst`\n pub fn run(mut krate: clean::Crate,\n            options: RenderOptions,\n-           passes: FxHashSet<String>,\n            renderinfo: RenderInfo,\n            diag: &errors::Handler,\n            edition: Edition) -> Result<(), Error> {\n@@ -557,8 +552,8 @@ pub fn run(mut krate: clean::Crate,\n     };\n     let mut errors = Arc::new(ErrorStorage::new());\n     let mut scx = SharedContext {\n+        collapsed: krate.collapsed,\n         src_root,\n-        passes,\n         include_sources: true,\n         local_sources: Default::default(),\n         issue_tracker_base_url: None,\n@@ -580,9 +575,11 @@ pub fn run(mut krate: clean::Crate,\n     };\n \n     // If user passed in `--playground-url` arg, we fill in crate name here\n+    let mut playground = None;\n     if let Some(url) = playground_url {\n-        markdown::PLAYGROUND.with(|slot| {\n-            *slot.borrow_mut() = Some((Some(krate.name.clone()), url));\n+        playground = Some(markdown::Playground {\n+            crate_name: Some(krate.name.clone()),\n+            url,\n         });\n     }\n \n@@ -598,9 +595,9 @@ pub fn run(mut krate: clean::Crate,\n                     scx.layout.logo = s.to_string();\n                 }\n                 (sym::html_playground_url, Some(s)) => {\n-                    markdown::PLAYGROUND.with(|slot| {\n-                        let name = krate.name.clone();\n-                        *slot.borrow_mut() = Some((Some(name), s.to_string()));\n+                    playground = Some(markdown::Playground {\n+                        crate_name: Some(krate.name.clone()),\n+                        url: s.to_string(),\n                     });\n                 }\n                 (sym::issue_tracker_base_url, Some(s)) => {\n@@ -624,6 +621,7 @@ pub fn run(mut krate: clean::Crate,\n         edition,\n         id_map: Rc::new(RefCell::new(id_map)),\n         shared: Arc::new(scx),\n+        playground,\n     };\n \n     // Crawl the crate to build various caches used for the output\n@@ -659,7 +657,7 @@ pub fn run(mut krate: clean::Crate,\n         crate_version: krate.version.take(),\n         orphan_impl_items: Vec::new(),\n         orphan_trait_impls: Vec::new(),\n-        traits: krate.external_traits.lock().replace(Default::default()),\n+        traits: krate.external_traits.replace(Default::default()),\n         deref_trait_did,\n         deref_mut_trait_did,\n         owned_box_did,\n@@ -2597,8 +2595,8 @@ fn render_markdown(w: &mut fmt::Formatter<'_>,\n     write!(w, \"<div class='docblock{}'>{}{}</div>\",\n            if is_hidden { \" hidden\" } else { \"\" },\n            prefix,\n-           Markdown(md_text, &links, RefCell::new(&mut ids),\n-           cx.codes, cx.edition))\n+           Markdown(md_text, &links, &mut ids,\n+           cx.codes, cx.edition, &cx.playground).to_string())\n }\n \n fn document_short(\n@@ -2868,7 +2866,7 @@ fn item_module(w: &mut fmt::Formatter<'_>, cx: &Context,\n                        </tr>\",\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_tags = stability_tags(myitem),\n-                       docs = MarkdownSummaryLine(doc_value, &myitem.links()),\n+                       docs = MarkdownSummaryLine(doc_value, &myitem.links()).to_string(),\n                        class = myitem.type_(),\n                        add = add,\n                        stab = stab.unwrap_or_else(|| String::new()),\n@@ -2963,8 +2961,8 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n \n         if let Some(note) = note {\n             let mut ids = cx.id_map.borrow_mut();\n-            let html = MarkdownHtml(&note, RefCell::new(&mut ids), error_codes, cx.edition);\n-            message.push_str(&format!(\": {}\", html));\n+            let html = MarkdownHtml(&note, &mut ids, error_codes, cx.edition, &cx.playground);\n+            message.push_str(&format!(\": {}\", html.to_string()));\n         }\n         stability.push(format!(\"<div class='stab deprecated'>{}</div>\", message));\n     }\n@@ -3012,7 +3010,13 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n             message = format!(\n                 \"<details><summary>{}</summary>{}</details>\",\n                 message,\n-                MarkdownHtml(&unstable_reason, RefCell::new(&mut ids), error_codes, cx.edition)\n+                MarkdownHtml(\n+                    &unstable_reason,\n+                    &mut ids,\n+                    error_codes,\n+                    cx.edition,\n+                    &cx.playground,\n+                ).to_string()\n             );\n         }\n \n@@ -4242,8 +4246,8 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n         if let Some(ref dox) = cx.shared.maybe_collapsed_doc_value(&i.impl_item) {\n             let mut ids = cx.id_map.borrow_mut();\n             write!(w, \"<div class='docblock'>{}</div>\",\n-                   Markdown(&*dox, &i.impl_item.links(), RefCell::new(&mut ids),\n-                            cx.codes, cx.edition))?;\n+                   Markdown(&*dox, &i.impl_item.links(), &mut ids,\n+                            cx.codes, cx.edition, &cx.playground).to_string())?;\n         }\n     }\n "}, {"sha": "e30b35937db9fbf55f518b43273401287f8b48fa", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -44,7 +44,6 @@ use std::default::Default;\n use std::env;\n use std::panic;\n use std::process;\n-use std::sync::mpsc::channel;\n \n use rustc::session::{early_warn, early_error};\n use rustc::session::config::{ErrorOutputType, RustcOptGroup};\n@@ -80,7 +79,6 @@ struct Output {\n     krate: clean::Crate,\n     renderinfo: html::render::RenderInfo,\n     renderopts: config::RenderOptions,\n-    passes: Vec<String>,\n }\n \n pub fn main() {\n@@ -419,14 +417,13 @@ fn main_options(options: config::Options) -> i32 {\n             return rustc_driver::EXIT_SUCCESS;\n         }\n \n-        let Output { krate, passes, renderinfo, renderopts } = out;\n+        let Output { krate, renderinfo, renderopts } = out;\n         info!(\"going to format\");\n         let (error_format, treat_err_as_bug, ui_testing, edition) = diag_opts;\n         let diag = core::new_handler(error_format, None, treat_err_as_bug, ui_testing);\n         match html::render::run(\n             krate,\n             renderopts,\n-            passes.into_iter().collect(),\n             renderinfo,\n             &diag,\n             edition,\n@@ -454,12 +451,10 @@ where R: 'static + Send,\n     // First, parse the crate and extract all relevant information.\n     info!(\"starting to run rustc\");\n \n-    let (tx, rx) = channel();\n-\n     let result = rustc_driver::report_ices_to_stderr_if_any(move || {\n         let crate_name = options.crate_name.clone();\n         let crate_version = options.crate_version.clone();\n-        let (mut krate, renderinfo, renderopts, passes) = core::run_core(options);\n+        let (mut krate, renderinfo, renderopts) = core::run_core(options);\n \n         info!(\"finished with rustc\");\n \n@@ -469,16 +464,15 @@ where R: 'static + Send,\n \n         krate.version = crate_version;\n \n-        tx.send(f(Output {\n+        f(Output {\n             krate: krate,\n             renderinfo: renderinfo,\n             renderopts,\n-            passes: passes\n-        })).unwrap();\n+        })\n     });\n \n     match result {\n-        Ok(()) => rx.recv().unwrap(),\n+        Ok(output) => output,\n         Err(_) => panic::resume_unwind(Box::new(errors::FatalErrorMarker)),\n     }\n }"}, {"sha": "eaaae3261c728950bca315aa2745c584f4af8e4d", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -1,7 +1,6 @@\n use std::fs::File;\n use std::io::prelude::*;\n use std::path::PathBuf;\n-use std::cell::RefCell;\n \n use errors;\n use testing;\n@@ -60,9 +59,10 @@ pub fn render(\n     };\n     let playground_url = options.markdown_playground_url\n                             .or(options.playground_url);\n-    if let Some(playground) = playground_url {\n-        markdown::PLAYGROUND.with(|s| { *s.borrow_mut() = Some((None, playground)); });\n-    }\n+    let playground = playground_url.map(|url| markdown::Playground {\n+        crate_name: None,\n+        url,\n+    });\n \n     let mut out = match File::create(&output) {\n         Err(e) => {\n@@ -82,9 +82,9 @@ pub fn render(\n     let mut ids = IdMap::new();\n     let error_codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n     let text = if !options.markdown_no_toc {\n-        MarkdownWithToc(text, RefCell::new(&mut ids), error_codes, edition).to_string()\n+        MarkdownWithToc(text, &mut ids, error_codes, edition, &playground).to_string()\n     } else {\n-        Markdown(text, &[], RefCell::new(&mut ids), error_codes, edition).to_string()\n+        Markdown(text, &[], &mut ids, error_codes, edition, &playground).to_string()\n     };\n \n     let err = write!("}, {"sha": "31288345ce57b1b6a735311ddfa8385b15a4427b", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -30,7 +30,9 @@ impl DocFragment {\n }\n \n pub fn collapse_docs(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n-    Collapser.fold_crate(krate)\n+    let mut krate = Collapser.fold_crate(krate);\n+    krate.collapsed = true;\n+    krate\n }\n \n struct Collapser;"}, {"sha": "86e4e9fd95637c208fe02c2b1a269774b2f75f67", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -4,7 +4,7 @@ use crate::fold::DocFolder;\n use super::Pass;\n \n use rustc::util::nodemap::FxHashSet;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{LOCAL_CRATE, DefId};\n use syntax::symbol::sym;\n \n pub const COLLECT_TRAIT_IMPLS: Pass = Pass {\n@@ -116,7 +116,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n \n     // `tcx.crates()` doesn't include the local crate, and `tcx.all_trait_implementations`\n     // doesn't work with it anyway, so pull them from the HIR map instead\n-    for &trait_did in cx.all_traits.iter() {\n+    for &trait_did in cx.tcx.all_traits(LOCAL_CRATE).iter() {\n         for &impl_node in cx.tcx.hir().trait_impls(trait_did) {\n             let impl_did = cx.tcx.hir().local_def_id(impl_node);\n             inline::build_impl(cx, impl_did, None, &mut new_items);"}, {"sha": "641a6df2214462ed6a51db76a8284a200b21bcf7", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -57,8 +57,9 @@ pub struct Pass {\n     pub description: &'static str,\n }\n \n+\n /// The full list of passes.\n-pub const PASSES: &'static [Pass] = &[\n+pub const PASSES: &[Pass] = &[\n     CHECK_PRIVATE_ITEMS_DOC_TESTS,\n     STRIP_HIDDEN,\n     UNINDENT_COMMENTS,\n@@ -73,43 +74,43 @@ pub const PASSES: &'static [Pass] = &[\n ];\n \n /// The list of passes run by default.\n-pub const DEFAULT_PASSES: &[&str] = &[\n-    \"collect-trait-impls\",\n-    \"collapse-docs\",\n-    \"unindent-comments\",\n-    \"check-private-items-doc-tests\",\n-    \"strip-hidden\",\n-    \"strip-private\",\n-    \"collect-intra-doc-links\",\n-    \"check-code-block-syntax\",\n-    \"propagate-doc-cfg\",\n+pub const DEFAULT_PASSES: &[Pass] = &[\n+    COLLECT_TRAIT_IMPLS,\n+    COLLAPSE_DOCS,\n+    UNINDENT_COMMENTS,\n+    CHECK_PRIVATE_ITEMS_DOC_TESTS,\n+    STRIP_HIDDEN,\n+    STRIP_PRIVATE,\n+    COLLECT_INTRA_DOC_LINKS,\n+    CHECK_CODE_BLOCK_SYNTAX,\n+    PROPAGATE_DOC_CFG,\n ];\n \n /// The list of default passes run with `--document-private-items` is passed to rustdoc.\n-pub const DEFAULT_PRIVATE_PASSES: &[&str] = &[\n-    \"collect-trait-impls\",\n-    \"collapse-docs\",\n-    \"unindent-comments\",\n-    \"check-private-items-doc-tests\",\n-    \"strip-priv-imports\",\n-    \"collect-intra-doc-links\",\n-    \"check-code-block-syntax\",\n-    \"propagate-doc-cfg\",\n+pub const DEFAULT_PRIVATE_PASSES: &[Pass] = &[\n+    COLLECT_TRAIT_IMPLS,\n+    COLLAPSE_DOCS,\n+    UNINDENT_COMMENTS,\n+    CHECK_PRIVATE_ITEMS_DOC_TESTS,\n+    STRIP_PRIV_IMPORTS,\n+    COLLECT_INTRA_DOC_LINKS,\n+    CHECK_CODE_BLOCK_SYNTAX,\n+    PROPAGATE_DOC_CFG,\n ];\n \n /// The list of default passes run when `--doc-coverage` is passed to rustdoc.\n-pub const DEFAULT_COVERAGE_PASSES: &'static [&'static str] = &[\n-    \"collect-trait-impls\",\n-    \"strip-hidden\",\n-    \"strip-private\",\n-    \"calculate-doc-coverage\",\n+pub const DEFAULT_COVERAGE_PASSES: &[Pass] = &[\n+    COLLECT_TRAIT_IMPLS,\n+    STRIP_HIDDEN,\n+    STRIP_PRIVATE,\n+    CALCULATE_DOC_COVERAGE,\n ];\n \n /// The list of default passes run when `--doc-coverage --document-private-items` is passed to\n /// rustdoc.\n-pub const PRIVATE_COVERAGE_PASSES: &'static [&'static str] = &[\n-    \"collect-trait-impls\",\n-    \"calculate-doc-coverage\",\n+pub const PRIVATE_COVERAGE_PASSES: &[Pass] = &[\n+    COLLECT_TRAIT_IMPLS,\n+    CALCULATE_DOC_COVERAGE,\n ];\n \n /// A shorthand way to refer to which set of passes to use, based on the presence of\n@@ -124,7 +125,7 @@ pub enum DefaultPassOption {\n }\n \n /// Returns the given default set of passes.\n-pub fn defaults(default_set: DefaultPassOption) -> &'static [&'static str] {\n+pub fn defaults(default_set: DefaultPassOption) -> &'static [Pass] {\n     match default_set {\n         DefaultPassOption::Default => DEFAULT_PASSES,\n         DefaultPassOption::Private => DEFAULT_PRIVATE_PASSES,"}, {"sha": "35b6d9972da06a2c96e2ce875b85b49f509a43b9", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -6,6 +6,7 @@ use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevel;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n+use rustc::ty::TyCtxt;\n use syntax::ast;\n use syntax::ext::base::MacroKind;\n use syntax::source_map::Spanned;\n@@ -15,9 +16,26 @@ use syntax_pos::{self, Span};\n use std::mem;\n \n use crate::core;\n-use crate::clean::{self, AttributesExt, NestedAttributesExt, def_id_to_path};\n+use crate::clean::{self, AttributesExt, NestedAttributesExt};\n use crate::doctree::*;\n \n+// FIXME: Should this be replaced with tcx.def_path_str?\n+fn def_id_to_path(\n+    tcx: TyCtxt<'_>,\n+    did: DefId,\n+) -> Vec<String> {\n+    let crate_name = tcx.crate_name(did.krate).to_string();\n+    let relative = tcx.def_path(did).data.into_iter().filter_map(|elem| {\n+        // extern blocks have an empty name\n+        let s = elem.data.to_string();\n+        if !s.is_empty() {\n+            Some(s)\n+        } else {\n+            None\n+        }\n+    });\n+    std::iter::once(crate_name).chain(relative).collect()\n+}\n \n // Also, is there some reason that this doesn't use the 'visit'\n // framework from syntax?.\n@@ -48,12 +66,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     fn store_path(&mut self, did: DefId) {\n-        // We can't use the entry API, as that keeps the mutable borrow of `self` active\n-        // when we try to use `cx`.\n-        if self.exact_paths.get(&did).is_none() {\n-            let path = def_id_to_path(self.cx, did, self.cx.crate_name.clone());\n-            self.exact_paths.insert(did, path);\n-        }\n+        let tcx = self.cx.tcx;\n+        self.exact_paths.entry(did).or_insert_with(|| def_id_to_path(tcx, did));\n     }\n \n     pub fn visit(mut self, krate: &'tcx hir::Crate) -> Module<'tcx> {"}, {"sha": "a9d1d9997f6ef3f7cfc18ce3ce052e3fc2a24a52", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ceab47b1caff6928ba04dbcffd058f6cd37a29/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=86ceab47b1caff6928ba04dbcffd058f6cd37a29", "patch": "@@ -16,7 +16,7 @@ use std::cell::RefCell;\n use syntax::edition::DEFAULT_EDITION;\n use syntax::diagnostics::metadata::{get_metadata_dir, ErrorMetadataMap, ErrorMetadata};\n \n-use rustdoc::html::markdown::{Markdown, IdMap, ErrorCodes, PLAYGROUND};\n+use rustdoc::html::markdown::{Markdown, IdMap, ErrorCodes, Playground};\n use rustc_serialize::json;\n \n enum OutputFormat {\n@@ -95,9 +95,13 @@ impl Formatter for HTMLFormatter {\n         match info.description {\n             Some(ref desc) => {\n                 let mut id_map = self.0.borrow_mut();\n+                let playground = Playground {\n+                    crate_name: None,\n+                    url: String::from(\"https://play.rust-lang.org/\"),\n+                };\n                 write!(output, \"{}\",\n-                    Markdown(desc, &[], RefCell::new(&mut id_map),\n-                             ErrorCodes::Yes, DEFAULT_EDITION))?\n+                    Markdown(desc, &[], &mut id_map,\n+                             ErrorCodes::Yes, DEFAULT_EDITION, &Some(playground)).to_string())?\n             },\n             None => write!(output, \"<p>No description.</p>\\n\")?,\n         }\n@@ -260,9 +264,6 @@ fn parse_args() -> (OutputFormat, PathBuf) {\n \n fn main() {\n     env_logger::init();\n-    PLAYGROUND.with(|slot| {\n-        *slot.borrow_mut() = Some((None, String::from(\"https://play.rust-lang.org/\")));\n-    });\n     let (format, dst) = parse_args();\n     let result = syntax::with_default_globals(move || {\n         main_with_result(format, &dst)"}]}