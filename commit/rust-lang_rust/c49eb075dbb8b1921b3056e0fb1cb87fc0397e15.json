{"sha": "c49eb075dbb8b1921b3056e0fb1cb87fc0397e15", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0OWViMDc1ZGJiOGIxOTIxYjMwNTZlMGZiMWNiODdmYzAzOTdlMTU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-09-03T16:23:59Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-09-04T16:38:46Z"}, "message": "debuginfo: Much improved handling of captured variables and by-value arguments.", "tree": {"sha": "4209787541f255b56e418d25b13f60056e8fd9b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4209787541f255b56e418d25b13f60056e8fd9b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c49eb075dbb8b1921b3056e0fb1cb87fc0397e15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c49eb075dbb8b1921b3056e0fb1cb87fc0397e15", "html_url": "https://github.com/rust-lang/rust/commit/c49eb075dbb8b1921b3056e0fb1cb87fc0397e15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c49eb075dbb8b1921b3056e0fb1cb87fc0397e15/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0b63b0e2a83e9c5dca884ddaf1c745e49a597f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0b63b0e2a83e9c5dca884ddaf1c745e49a597f7", "html_url": "https://github.com/rust-lang/rust/commit/e0b63b0e2a83e9c5dca884ddaf1c745e49a597f7"}], "stats": {"total": 186, "additions": 124, "deletions": 62}, "files": [{"sha": "39e3e97b48947a7ecb306dc2f3e75bffece05e92", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c49eb075dbb8b1921b3056e0fb1cb87fc0397e15/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49eb075dbb8b1921b3056e0fb1cb87fc0397e15/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=c49eb075dbb8b1921b3056e0fb1cb87fc0397e15", "patch": "@@ -2000,6 +2000,9 @@ pub fn store_arg(mut bcx: @mut Block,\n     let arg_ty = node_id_type(bcx, pat.id);\n     add_clean(bcx, llval, arg_ty);\n \n+    // Debug information (the llvm.dbg.declare intrinsic to be precise) always expects to get an\n+    // alloca, which only is the case on the general path, so lets disable the optimized path when\n+    // debug info is enabled.\n     let fast_path = !bcx.ccx().sess.opts.extra_debuginfo && simple_identifier(pat).is_some();\n \n     if fast_path {"}, {"sha": "690d7343489e299909091845e09a8cf9cfb47c47", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c49eb075dbb8b1921b3056e0fb1cb87fc0397e15/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49eb075dbb8b1921b3056e0fb1cb87fc0397e15/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=c49eb075dbb8b1921b3056e0fb1cb87fc0397e15", "patch": "@@ -308,7 +308,17 @@ pub fn load_environment(fcx: @mut FunctionContext,\n     // Load a pointer to the closure data, skipping over the box header:\n     let llcdata = opaque_box_body(bcx, cdata_ty, fcx.llenv);\n \n-    // Populate the upvars from the environment.\n+    // Store the pointer to closure data in an alloca for debug info because that's what the\n+    // llvm.dbg.declare intrinsic expects\n+    let env_pointer_alloca = if fcx.ccx.sess.opts.extra_debuginfo {\n+        let alloc = alloc_ty(bcx, ty::mk_mut_ptr(bcx.tcx(), cdata_ty), \"__debuginfo_env_ptr\");\n+        Store(bcx, llcdata, alloc);\n+        Some(alloc)\n+    } else {\n+        None\n+    };\n+\n+    // Populate the upvars from the environment\n     let mut i = 0u;\n     for cap_var in cap_vars.iter() {\n         let mut upvarptr = GEPi(bcx, llcdata, [0u, i]);\n@@ -319,8 +329,15 @@ pub fn load_environment(fcx: @mut FunctionContext,\n         let def_id = ast_util::def_id_of_def(cap_var.def);\n         fcx.llupvars.insert(def_id.node, upvarptr);\n \n-        if fcx.ccx.sess.opts.extra_debuginfo {\n-            debuginfo::create_captured_var_metadata(bcx, def_id.node, upvarptr, cap_var.span);\n+        for &env_pointer_alloca in env_pointer_alloca.iter() {\n+            debuginfo::create_captured_var_metadata(\n+                bcx,\n+                def_id.node,\n+                cdata_ty,\n+                env_pointer_alloca,\n+                i,\n+                sigil,\n+                cap_var.span);\n         }\n \n         i += 1u;"}, {"sha": "112595d5576b87a4c34ed89d30ebfcd7fcbe5a95", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 83, "deletions": 54, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/c49eb075dbb8b1921b3056e0fb1cb87fc0397e15/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49eb075dbb8b1921b3056e0fb1cb87fc0397e15/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c49eb075dbb8b1921b3056e0fb1cb87fc0397e15", "patch": "@@ -163,11 +163,12 @@ struct FunctionDebugContextData {\n     source_locations_enabled: bool,\n }\n \n-enum VariableAccess {\n-    // The value given is a pointer to the data (T*)\n-    DirectVariable,\n-    // The value given has to be dereferenced once to get the pointer to data (T**)\n-    IndirectVariable\n+enum VariableAccess<'self> {\n+    // The llptr given is an alloca containing the variable's value\n+    DirectVariable { alloca: ValueRef },\n+    // The llptr given is an alloca containing the start of some pointer chain leading to the\n+    // variable's content.\n+    IndirectVariable { alloca: ValueRef, address_operations: &'self [ValueRef] }\n }\n \n enum VariableKind {\n@@ -213,11 +214,10 @@ pub fn create_local_var_metadata(bcx: @mut Block,\n         let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n \n         declare_local(bcx,\n-                      llptr,\n                       var_ident,\n                       var_type,\n                       scope_metadata,\n-                      DirectVariable,\n+                      DirectVariable { alloca: llptr },\n                       LocalVariable,\n                       span);\n     }\n@@ -228,7 +228,10 @@ pub fn create_local_var_metadata(bcx: @mut Block,\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_captured_var_metadata(bcx: @mut Block,\n                                     node_id: ast::NodeId,\n-                                    llptr: ValueRef,\n+                                    env_data_type: ty::t,\n+                                    env_pointer: ValueRef,\n+                                    env_index: uint,\n+                                    closure_sigil: ast::Sigil,\n                                     span: Span) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n@@ -250,15 +253,39 @@ pub fn create_captured_var_metadata(bcx: @mut Block,\n                 Captured var-id refers to unexpected ast_map variant: %?\", ast_item));\n         }\n     };\n+\n     let variable_type = node_id_type(bcx, node_id);\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, span).fn_metadata;\n \n+    let llvm_env_data_type = type_of::type_of(cx, env_data_type);\n+    let byte_offset_of_var_in_env = machine::llelement_offset(cx, llvm_env_data_type, env_index);\n+\n+    let address_operations = unsafe {\n+        [llvm::LLVMDIBuilderCreateOpDeref(Type::i64().to_ref()),\n+         llvm::LLVMDIBuilderCreateOpPlus(Type::i64().to_ref()),\n+         C_i64(byte_offset_of_var_in_env as i64),\n+         llvm::LLVMDIBuilderCreateOpDeref(Type::i64().to_ref())]\n+    };\n+\n+    let address_op_count = match closure_sigil {\n+        ast::BorrowedSigil => {\n+            address_operations.len()\n+        }\n+        ast::ManagedSigil | ast::OwnedSigil => {\n+            address_operations.len() - 1\n+        }\n+    };\n+\n+    let variable_access = IndirectVariable {\n+        alloca: env_pointer,\n+        address_operations: address_operations.slice_to(address_op_count)\n+    };\n+\n     declare_local(bcx,\n-                  llptr,\n                   variable_ident,\n                   variable_type,\n                   scope_metadata,\n-                  IndirectVariable,\n+                  variable_access,\n                   CapturedVariable,\n                   span);\n }\n@@ -285,11 +312,10 @@ pub fn create_match_binding_metadata(bcx: @mut Block,\n     let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n \n     declare_local(bcx,\n-                  llptr,\n                   variable_ident,\n                   variable_type,\n                   scope_metadata,\n-                  DirectVariable,\n+                  DirectVariable { alloca: llptr },\n                   LocalVariable,\n                   span);\n }\n@@ -333,14 +359,17 @@ pub fn create_self_argument_metadata(bcx: @mut Block,\n         argument_index\n     };\n \n+    let address_operations = &[unsafe { llvm::LLVMDIBuilderCreateOpDeref(Type::i64().to_ref()) }];\n+\n     let variable_access = if unsafe { llvm::LLVMIsAAllocaInst(llptr) } != ptr::null() {\n-        DirectVariable\n+        DirectVariable { alloca: llptr }\n     } else {\n-        IndirectVariable\n+        // This is not stable and may break with future LLVM versions. llptr should really always\n+        // be an alloca. Anything else is not supported and just works by chance.\n+        IndirectVariable { alloca: llptr, address_operations: address_operations }\n     };\n \n     declare_local(bcx,\n-                  llptr,\n                   special_idents::self_,\n                   type_of_self,\n                   scope_metadata,\n@@ -373,11 +402,10 @@ pub fn create_argument_metadata(bcx: @mut Block,\n             }\n         };\n \n-        let variable_access = if unsafe { llvm::LLVMIsAAllocaInst(llptr) } != ptr::null() {\n-            DirectVariable\n-        } else {\n-            IndirectVariable\n-        };\n+        if unsafe { llvm::LLVMIsAAllocaInst(llptr) } == ptr::null() {\n+            cx.sess.span_bug(span, \"debuginfo::create_argument_metadata() - \\\n+                                    Referenced variable location is not an alloca!\");\n+        }\n \n         let argument_type = node_id_type(bcx, node_id);\n         let argument_ident = ast_util::path_to_ident(path_ref);\n@@ -390,11 +418,10 @@ pub fn create_argument_metadata(bcx: @mut Block,\n         };\n \n         declare_local(bcx,\n-                      llptr,\n                       argument_ident,\n                       argument_type,\n                       scope_metadata,\n-                      variable_access,\n+                      DirectVariable { alloca: llptr },\n                       ArgumentVariable(argument_index),\n                       span);\n     }\n@@ -783,7 +810,6 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n }\n \n fn declare_local(bcx: @mut Block,\n-                 llptr: ValueRef,\n                  variable_ident: ast::Ident,\n                  variable_type: ty::t,\n                  scope_metadata: DIScope,\n@@ -805,45 +831,48 @@ fn declare_local(bcx: @mut Block,\n         CapturedVariable => 0\n     } as c_uint;\n \n-    let var_metadata = do name.with_c_str |name| {\n+    let (var_alloca, var_metadata) = do name.with_c_str |name| {\n         match variable_access {\n-            DirectVariable => unsafe {\n-                llvm::LLVMDIBuilderCreateLocalVariable(\n-                    DIB(cx),\n-                    DW_TAG_auto_variable,\n-                    scope_metadata,\n-                    name,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    type_metadata,\n-                    cx.sess.opts.optimize != session::No,\n-                    0,\n-                    argument_index)\n-            },\n-            IndirectVariable => unsafe {\n-                let address_op = llvm::LLVMDIBuilderCreateOpDeref(Type::i64().to_ref());\n-                let address_op_count = 1;\n-\n-                llvm::LLVMDIBuilderCreateComplexVariable(\n-                    DIB(cx),\n-                    DW_TAG_auto_variable,\n-                    scope_metadata,\n-                    name,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    type_metadata,\n-                    ptr::to_unsafe_ptr(&address_op),\n-                    address_op_count,\n-                    argument_index)\n-            }\n+            DirectVariable { alloca } => (\n+                alloca,\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateLocalVariable(\n+                        DIB(cx),\n+                        DW_TAG_auto_variable,\n+                        scope_metadata,\n+                        name,\n+                        file_metadata,\n+                        loc.line as c_uint,\n+                        type_metadata,\n+                        cx.sess.opts.optimize != session::No,\n+                        0,\n+                        argument_index)\n+                }\n+            ),\n+            IndirectVariable { alloca, address_operations } => (\n+                alloca,\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateComplexVariable(\n+                        DIB(cx),\n+                        DW_TAG_auto_variable,\n+                        scope_metadata,\n+                        name,\n+                        file_metadata,\n+                        loc.line as c_uint,\n+                        type_metadata,\n+                        vec::raw::to_ptr(address_operations),\n+                        address_operations.len() as c_uint,\n+                        argument_index)\n+                }\n+            )\n         }\n     };\n \n     set_debug_location(cx, DebugLocation::new(scope_metadata, loc.line, *loc.col));\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n             DIB(cx),\n-            llptr,\n+            var_alloca,\n             var_metadata,\n             bcx.llbb);\n "}, {"sha": "cd20209ddfd0263594940b83715225ae69ad98eb", "filename": "src/test/debug-info/var-captured-in-nested-closure.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c49eb075dbb8b1921b3056e0fb1cb87fc0397e15/src%2Ftest%2Fdebug-info%2Fvar-captured-in-nested-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49eb075dbb8b1921b3056e0fb1cb87fc0397e15/src%2Ftest%2Fdebug-info%2Fvar-captured-in-nested-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvar-captured-in-nested-closure.rs?ref=c49eb075dbb8b1921b3056e0fb1cb87fc0397e15", "patch": "@@ -29,6 +29,23 @@\n // check:$7 = 8\n // debugger:continue\n \n+// debugger:finish\n+// debugger:print variable\n+// check:$8 = 1\n+// debugger:print constant\n+// check:$9 = 2\n+// debugger:print a_struct\n+// check:$10 = {a = -3, b = 4.5, c = 5}\n+// debugger:print *struct_ref\n+// check:$11 = {a = -3, b = 4.5, c = 5}\n+// debugger:print *owned\n+// check:$12 = 6\n+// debugger:print managed->val\n+// check:$13 = 7\n+// debugger:print closure_local\n+// check:$14 = 8\n+// debugger:continue\n+\n #[allow(unused_variable)];\n \n struct Struct {\n@@ -59,11 +76,7 @@ fn main() {\n             variable = constant + a_struct.a + struct_ref.a + *owned + *managed + closure_local;\n         };\n \n-        // breaking here will yield a wrong value for 'constant'. In particular, GDB will\n-        // read the value of the register that supposedly contains the pointer to 'constant'\n-        // and try derefence it. The register, however, already contains the actual value, and\n-        // not a pointer to it. -mw\n-        // zzz();\n+        zzz();\n \n         nested_closure();\n     };"}]}