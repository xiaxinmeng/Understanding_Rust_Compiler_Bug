{"sha": "fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNWY0MmNkYjg4ZDhjZTMxZjc0NjEzMDA5OTMyMWU3Yzk1ZTFlZjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-13T00:28:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-13T00:28:38Z"}, "message": "Auto merge of #60630 - nnethercote:use-Symbol-more, r=petrochenkov\n\nUse `Symbol` more\n\nA `Symbol` can be equated with a string (e.g. `&str`). This involves a\nTLS lookup to get the chars (and a Mutex lock in a parallel compiler)\nand then a char-by-char comparison. This functionality is convenient but\navoids one of the main benefits of `Symbol`s, which is fast equality\ncomparisons.\n\nThis PR removes the `Symbol`/string equality operations, forcing a lot\nof existing string occurrences to become `Symbol`s. Fortunately, these\nare almost all static strings (many are attribute names) and we can add\nstatic `Symbol`s as necessary, and very little extra interning occurs.\nThe benefits are (a) a slight speedup (possibly greater in a parallel\ncompiler), and (b) the code is a lot more principled about `Symbol` use.\nThe main downside is verbosity, particularly with more `use\nsyntax::symbol::symbols` items.\n\nr? @Zoxc", "tree": {"sha": "d895b0ba0c1aca391e69c34a3b96b3eba48d9dd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d895b0ba0c1aca391e69c34a3b96b3eba48d9dd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "html_url": "https://github.com/rust-lang/rust/commit/fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4443957f272e304e083a8d98583e608d65a712aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/4443957f272e304e083a8d98583e608d65a712aa", "html_url": "https://github.com/rust-lang/rust/commit/4443957f272e304e083a8d98583e608d65a712aa"}, {"sha": "ea9fac5687c24abad493caf4ec5042af47458af9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea9fac5687c24abad493caf4ec5042af47458af9", "html_url": "https://github.com/rust-lang/rust/commit/ea9fac5687c24abad493caf4ec5042af47458af9"}], "stats": {"total": 2548, "additions": 1507, "deletions": 1041}, "files": [{"sha": "b199eee6dad87a2285f099fac8a22274264fdedb", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -12,6 +12,7 @@ use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use std::fmt::{self, Display};\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -95,18 +96,18 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n         if target == Target::Fn || target == Target::Const {\n             self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n-        } else if let Some(a) = item.attrs.iter().find(|a| a.check_name(\"target_feature\")) {\n+        } else if let Some(a) = item.attrs.iter().find(|a| a.check_name(sym::target_feature)) {\n             self.tcx.sess.struct_span_err(a.span, \"attribute should be applied to a function\")\n                 .span_label(item.span, \"not a function\")\n                 .emit();\n         }\n \n         for attr in &item.attrs {\n-            if attr.check_name(\"inline\") {\n+            if attr.check_name(sym::inline) {\n                 self.check_inline(attr, &item.span, target)\n-            } else if attr.check_name(\"non_exhaustive\") {\n+            } else if attr.check_name(sym::non_exhaustive) {\n                 self.check_non_exhaustive(attr, item, target)\n-            } else if attr.check_name(\"marker\") {\n+            } else if attr.check_name(sym::marker) {\n                 self.check_marker(attr, item, target)\n             }\n         }\n@@ -166,7 +167,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         // ```\n         let hints: Vec<_> = item.attrs\n             .iter()\n-            .filter(|attr| attr.check_name(\"repr\"))\n+            .filter(|attr| attr.check_name(sym::repr))\n             .filter_map(|attr| attr.meta_item_list())\n             .flatten()\n             .collect();\n@@ -177,9 +178,9 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         let mut is_transparent = false;\n \n         for hint in &hints {\n-            let (article, allowed_targets) = match hint.name_or_empty().get() {\n-                name @ \"C\" | name @ \"align\" => {\n-                    is_c |= name == \"C\";\n+            let (article, allowed_targets) = match hint.name_or_empty() {\n+                name @ sym::C | name @ sym::align => {\n+                    is_c |= name == sym::C;\n                     if target != Target::Struct &&\n                             target != Target::Union &&\n                             target != Target::Enum {\n@@ -188,33 +189,33 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n                         continue\n                     }\n                 }\n-                \"packed\" => {\n+                sym::packed => {\n                     if target != Target::Struct &&\n                             target != Target::Union {\n                                 (\"a\", \"struct or union\")\n                     } else {\n                         continue\n                     }\n                 }\n-                \"simd\" => {\n+                sym::simd => {\n                     is_simd = true;\n                     if target != Target::Struct {\n                         (\"a\", \"struct\")\n                     } else {\n                         continue\n                     }\n                 }\n-                \"transparent\" => {\n+                sym::transparent => {\n                     is_transparent = true;\n                     if target != Target::Struct {\n                         (\"a\", \"struct\")\n                     } else {\n                         continue\n                     }\n                 }\n-                \"i8\"  | \"u8\"  | \"i16\" | \"u16\" |\n-                \"i32\" | \"u32\" | \"i64\" | \"u64\" |\n-                \"isize\" | \"usize\" => {\n+                sym::i8  | sym::u8  | sym::i16 | sym::u16 |\n+                sym::i32 | sym::u32 | sym::i64 | sym::u64 |\n+                sym::isize | sym::usize => {\n                     int_reprs += 1;\n                     if target != Target::Enum {\n                         (\"an\", \"enum\")\n@@ -268,10 +269,10 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         // When checking statements ignore expressions, they will be checked later\n         if let hir::StmtKind::Local(ref l) = stmt.node {\n             for attr in l.attrs.iter() {\n-                if attr.check_name(\"inline\") {\n+                if attr.check_name(sym::inline) {\n                     self.check_inline(attr, &stmt.span, Target::Statement);\n                 }\n-                if attr.check_name(\"repr\") {\n+                if attr.check_name(sym::repr) {\n                     self.emit_repr_error(\n                         attr.span,\n                         stmt.span,\n@@ -289,10 +290,10 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n             _ => Target::Expression,\n         };\n         for attr in expr.attrs.iter() {\n-            if attr.check_name(\"inline\") {\n+            if attr.check_name(sym::inline) {\n                 self.check_inline(attr, &expr.span, target);\n             }\n-            if attr.check_name(\"repr\") {\n+            if attr.check_name(sym::repr) {\n                 self.emit_repr_error(\n                     attr.span,\n                     expr.span,\n@@ -305,7 +306,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n \n     fn check_used(&self, item: &hir::Item, target: Target) {\n         for attr in &item.attrs {\n-            if attr.check_name(\"used\") && target != Target::Static {\n+            if attr.check_name(sym::used) && target != Target::Static {\n                 self.tcx.sess\n                     .span_err(attr.span, \"attribute must be applied to a `static` variable\");\n             }"}, {"sha": "dd0d13d8f5a6aea74ae0498538285a36463d4209", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -64,7 +64,7 @@ use syntax::ptr::P;\n use syntax::source_map::{respan, CompilerDesugaringKind, Spanned};\n use syntax::source_map::CompilerDesugaringKind::IfTemporary;\n use syntax::std_inject;\n-use syntax::symbol::{keywords, Symbol};\n+use syntax::symbol::{keywords, Symbol, sym};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::Token;\n use syntax::visit::{self, Visitor};\n@@ -73,7 +73,7 @@ use syntax_pos::Span;\n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n pub struct LoweringContext<'a> {\n-    crate_root: Option<&'static str>,\n+    crate_root: Option<Symbol>,\n \n     /// Used to assign ids to HIR nodes that do not directly correspond to an AST node.\n     sess: &'a Session,\n@@ -164,8 +164,8 @@ pub trait Resolver {\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n-        crate_root: Option<&str>,\n-        components: &[&str],\n+        crate_root: Option<Symbol>,\n+        components: &[Symbol],\n         is_value: bool,\n     ) -> hir::Path;\n }\n@@ -228,7 +228,7 @@ pub fn lower_crate(\n     dep_graph.assert_ignored();\n \n     LoweringContext {\n-        crate_root: std_inject::injected_crate_name(),\n+        crate_root: std_inject::injected_crate_name().map(Symbol::intern),\n         sess,\n         cstore,\n         resolver,\n@@ -1149,7 +1149,7 @@ impl<'a> LoweringContext<'a> {\n             ].into()),\n         );\n         let gen_future = self.expr_std_path(\n-            unstable_span, &[\"future\", \"from_generator\"], None, ThinVec::new());\n+            unstable_span, &[sym::future, sym::from_generator], None, ThinVec::new());\n         hir::ExprKind::Call(P(gen_future), hir_vec![generator])\n     }\n \n@@ -2548,7 +2548,7 @@ impl<'a> LoweringContext<'a> {\n \n         // ::std::future::Future<future_params>\n         let future_path =\n-            self.std_path(span, &[\"future\", \"Future\"], Some(future_params), false);\n+            self.std_path(span, &[sym::future, sym::Future], Some(future_params), false);\n \n         hir::GenericBound::Trait(\n             hir::PolyTraitRef {\n@@ -2727,7 +2727,7 @@ impl<'a> LoweringContext<'a> {\n                         self.lower_ty(x, ImplTraitContext::disallowed())\n                     }),\n                     synthetic: param.attrs.iter()\n-                                          .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n+                                          .filter(|attr| attr.check_name(sym::rustc_synthetic))\n                                           .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n                                           .next(),\n                 };\n@@ -2745,7 +2745,7 @@ impl<'a> LoweringContext<'a> {\n             hir_id: self.lower_node_id(param.id),\n             name,\n             span: param.ident.span,\n-            pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n+            pure_wrt_drop: attr::contains_name(&param.attrs, sym::may_dangle),\n             attrs: self.lower_attrs(&param.attrs),\n             bounds,\n             kind,\n@@ -3773,8 +3773,8 @@ impl<'a> LoweringContext<'a> {\n         let mut vis = self.lower_visibility(&i.vis, None);\n         let attrs = self.lower_attrs(&i.attrs);\n         if let ItemKind::MacroDef(ref def) = i.node {\n-            if !def.legacy || attr::contains_name(&i.attrs, \"macro_export\") ||\n-                              attr::contains_name(&i.attrs, \"rustc_doc_only_macro\") {\n+            if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) ||\n+                              attr::contains_name(&i.attrs, sym::rustc_doc_only_macro) {\n                 let body = self.lower_token_stream(def.stream());\n                 let hir_id = self.lower_node_id(i.id);\n                 self.exported_macros.push(hir::MacroDef {\n@@ -4194,7 +4194,7 @@ impl<'a> LoweringContext<'a> {\n                         |x: P<hir::Expr>| x.into_inner(),\n                     );\n                     block.expr = Some(this.wrap_in_try_constructor(\n-                        \"from_ok\", tail, unstable_span));\n+                        sym::from_ok, tail, unstable_span));\n                     hir::ExprKind::Block(P(block), None)\n                 })\n             }\n@@ -4336,7 +4336,7 @@ impl<'a> LoweringContext<'a> {\n                 self.expr_call_std_assoc_fn(\n                     id,\n                     e.span,\n-                    &[\"ops\", \"RangeInclusive\"],\n+                    &[sym::ops, sym::RangeInclusive],\n                     \"new\",\n                     hir_vec![e1, e2],\n                 )\n@@ -4345,11 +4345,11 @@ impl<'a> LoweringContext<'a> {\n                 use syntax::ast::RangeLimits::*;\n \n                 let path = match (e1, e2, lims) {\n-                    (&None, &None, HalfOpen) => \"RangeFull\",\n-                    (&Some(..), &None, HalfOpen) => \"RangeFrom\",\n-                    (&None, &Some(..), HalfOpen) => \"RangeTo\",\n-                    (&Some(..), &Some(..), HalfOpen) => \"Range\",\n-                    (&None, &Some(..), Closed) => \"RangeToInclusive\",\n+                    (&None, &None, HalfOpen) => sym::RangeFull,\n+                    (&Some(..), &None, HalfOpen) => sym::RangeFrom,\n+                    (&None, &Some(..), HalfOpen) => sym::RangeTo,\n+                    (&Some(..), &Some(..), HalfOpen) => sym::Range,\n+                    (&None, &Some(..), Closed) => sym::RangeToInclusive,\n                     (&Some(..), &Some(..), Closed) => unreachable!(),\n                     (_, &None, Closed) => self.diagnostic()\n                         .span_fatal(e.span, \"inclusive range with no end\")\n@@ -4367,7 +4367,7 @@ impl<'a> LoweringContext<'a> {\n                     .collect::<P<[hir::Field]>>();\n \n                 let is_unit = fields.is_empty();\n-                let struct_path = [\"ops\", path];\n+                let struct_path = [sym::ops, path];\n                 let struct_path = self.std_path(e.span, &struct_path, None, is_unit);\n                 let struct_path = hir::QPath::Resolved(None, P(struct_path));\n \n@@ -4656,7 +4656,7 @@ impl<'a> LoweringContext<'a> {\n                 let match_expr = {\n                     let iter = P(self.expr_ident(head_sp, iter, iter_pat_nid));\n                     let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n-                    let next_path = &[\"iter\", \"Iterator\", \"next\"];\n+                    let next_path = &[sym::iter, sym::Iterator, sym::next];\n                     let next_expr = P(self.expr_call_std_path(\n                         head_sp,\n                         next_path,\n@@ -4723,7 +4723,8 @@ impl<'a> LoweringContext<'a> {\n \n                 // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n                 let into_iter_expr = {\n-                    let into_iter_path = &[\"iter\", \"IntoIterator\", \"into_iter\"];\n+                    let into_iter_path =\n+                        &[sym::iter, sym::IntoIterator, sym::into_iter];\n                     P(self.expr_call_std_path(\n                         head_sp,\n                         into_iter_path,\n@@ -4780,7 +4781,7 @@ impl<'a> LoweringContext<'a> {\n                     // expand <expr>\n                     let sub_expr = self.lower_expr(sub_expr);\n \n-                    let path = &[\"ops\", \"Try\", \"into_result\"];\n+                    let path = &[sym::ops, sym::Try, sym::into_result];\n                     P(self.expr_call_std_path(\n                         unstable_span,\n                         path,\n@@ -4822,12 +4823,12 @@ impl<'a> LoweringContext<'a> {\n                     let err_ident = self.str_to_ident(\"err\");\n                     let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n                     let from_expr = {\n-                        let from_path = &[\"convert\", \"From\", \"from\"];\n+                        let from_path = &[sym::convert, sym::From, sym::from];\n                         let err_expr = self.expr_ident(try_span, err_ident, err_local_nid);\n                         self.expr_call_std_path(try_span, from_path, hir_vec![err_expr])\n                     };\n                     let from_err_expr =\n-                        self.wrap_in_try_constructor(\"from_error\", from_expr, unstable_span);\n+                        self.wrap_in_try_constructor(sym::from_error, from_expr, unstable_span);\n                     let thin_attrs = ThinVec::from(attrs);\n                     let catch_scope = self.catch_scopes.last().map(|x| *x);\n                     let ret_expr = if let Some(catch_node) = catch_scope {\n@@ -5057,7 +5058,7 @@ impl<'a> LoweringContext<'a> {\n     fn expr_call_std_path(\n         &mut self,\n         span: Span,\n-        path_components: &[&str],\n+        path_components: &[Symbol],\n         args: hir::HirVec<hir::Expr>,\n     ) -> hir::Expr {\n         let path = P(self.expr_std_path(span, path_components, None, ThinVec::new()));\n@@ -5077,7 +5078,7 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         ty_path_id: hir::HirId,\n         span: Span,\n-        ty_path_components: &[&str],\n+        ty_path_components: &[Symbol],\n         assoc_fn_name: &str,\n         args: hir::HirVec<hir::Expr>,\n     ) -> hir::ExprKind {\n@@ -5119,7 +5120,7 @@ impl<'a> LoweringContext<'a> {\n     fn expr_std_path(\n         &mut self,\n         span: Span,\n-        components: &[&str],\n+        components: &[Symbol],\n         params: Option<P<hir::GenericArgs>>,\n         attrs: ThinVec<Attribute>,\n     ) -> hir::Expr {\n@@ -5250,25 +5251,25 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn pat_ok(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[\"result\", \"Result\", \"Ok\"], hir_vec![pat])\n+        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Ok], hir_vec![pat])\n     }\n \n     fn pat_err(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[\"result\", \"Result\", \"Err\"], hir_vec![pat])\n+        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Err], hir_vec![pat])\n     }\n \n     fn pat_some(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[\"option\", \"Option\", \"Some\"], hir_vec![pat])\n+        self.pat_std_enum(span, &[sym::option, sym::Option, sym::Some], hir_vec![pat])\n     }\n \n     fn pat_none(&mut self, span: Span) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[\"option\", \"Option\", \"None\"], hir_vec![])\n+        self.pat_std_enum(span, &[sym::option, sym::Option, sym::None], hir_vec![])\n     }\n \n     fn pat_std_enum(\n         &mut self,\n         span: Span,\n-        components: &[&str],\n+        components: &[Symbol],\n         subpats: hir::HirVec<P<hir::Pat>>,\n     ) -> P<hir::Pat> {\n         let path = self.std_path(span, components, None, true);\n@@ -5321,7 +5322,7 @@ impl<'a> LoweringContext<'a> {\n     fn std_path(\n         &mut self,\n         span: Span,\n-        components: &[&str],\n+        components: &[Symbol],\n         params: Option<P<hir::GenericArgs>>,\n         is_value: bool,\n     ) -> hir::Path {\n@@ -5520,11 +5521,11 @@ impl<'a> LoweringContext<'a> {\n \n     fn wrap_in_try_constructor(\n         &mut self,\n-        method: &'static str,\n+        method: Symbol,\n         e: hir::Expr,\n         unstable_span: Span,\n     ) -> P<hir::Expr> {\n-        let path = &[\"ops\", \"Try\", method];\n+        let path = &[sym::ops, sym::Try, method];\n         let from_err = P(self.expr_std_path(unstable_span, path, None,\n                                             ThinVec::new()));\n         P(self.expr_call(e.span, from_err, hir_vec![e]))\n@@ -5594,15 +5595,15 @@ impl<'a> LoweringContext<'a> {\n             let new_unchecked_expr_kind = self.expr_call_std_assoc_fn(\n                 pin_ty_id,\n                 span,\n-                &[\"pin\", \"Pin\"],\n+                &[sym::pin, sym::Pin],\n                 \"new_unchecked\",\n                 hir_vec![ref_mut_pinned],\n             );\n             let new_unchecked = P(self.expr(span, new_unchecked_expr_kind, ThinVec::new()));\n             let unsafe_expr = self.expr_unsafe(new_unchecked);\n             P(self.expr_call_std_path(\n                 gen_future_span,\n-                &[\"future\", \"poll_with_tls_context\"],\n+                &[sym::future, sym::poll_with_tls_context],\n                 hir_vec![unsafe_expr],\n             ))\n         };\n@@ -5616,7 +5617,7 @@ impl<'a> LoweringContext<'a> {\n             let x_expr = P(self.expr_ident(span, x_ident, x_pat_hid));\n             let ready_pat = self.pat_std_enum(\n                 span,\n-                &[\"task\", \"Poll\", \"Ready\"],\n+                &[sym::task, sym::Poll, sym::Ready],\n                 hir_vec![x_pat],\n             );\n             let break_x = self.with_loop_scope(loop_node_id, |this| {\n@@ -5633,7 +5634,7 @@ impl<'a> LoweringContext<'a> {\n         let pending_arm = {\n             let pending_pat = self.pat_std_enum(\n                 span,\n-                &[\"task\", \"Poll\", \"Pending\"],\n+                &[sym::task, sym::Poll, sym::Pending],\n                 hir_vec![],\n             );\n             let empty_block = P(self.expr_block_empty(span));"}, {"sha": "b8ee98551a20e758f4b025f7fc54167a87bd2309", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -1146,7 +1146,7 @@ impl<'a> NodesMatchingSuffix<'a> {\n                 None => return false,\n                 Some((node_id, name)) => (node_id, name),\n             };\n-            if mod_name != &**part {\n+            if mod_name.as_str() != *part {\n                 return false;\n             }\n             cursor = self.map.get_parent_item(mod_id);\n@@ -1183,7 +1183,7 @@ impl<'a> NodesMatchingSuffix<'a> {\n     // We are looking at some node `n` with a given name and parent\n     // id; do their names match what I am seeking?\n     fn matches_names(&self, parent_of_n: HirId, name: Name) -> bool {\n-        name == &**self.item_name && self.suffix_matches(parent_of_n)\n+        name.as_str() == *self.item_name && self.suffix_matches(parent_of_n)\n     }\n \n     fn matches_suffix(&self, hir: HirId) -> bool {"}, {"sha": "8be610e8bf7af715691b4dd36bcd7fe1f432af6f", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -28,7 +28,7 @@ use smallvec::SmallVec;\n \n fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n     debug_assert!(ich::IGNORED_ATTRIBUTES.len() > 0);\n-    ich::IGNORED_ATTRIBUTES.iter().map(|&s| Symbol::intern(s)).collect()\n+    ich::IGNORED_ATTRIBUTES.iter().map(|&s| s).collect()\n }\n \n /// This is the context state available during incr. comp. hashing. It contains"}, {"sha": "f3fc7ec8fda1530b4d9fe6295e01ce1967c818d0", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -4,6 +4,8 @@ crate use rustc_data_structures::fingerprint::Fingerprint;\n pub use self::caching_source_map_view::CachingSourceMapView;\n pub use self::hcx::{StableHashingContextProvider, StableHashingContext, NodeIdHashingMode,\n                     hash_stable_trait_impls};\n+use syntax::symbol::{Symbol, sym};\n+\n mod caching_source_map_view;\n mod hcx;\n \n@@ -12,16 +14,16 @@ mod impls_misc;\n mod impls_ty;\n mod impls_syntax;\n \n-pub const ATTR_DIRTY: &str = \"rustc_dirty\";\n-pub const ATTR_CLEAN: &str = \"rustc_clean\";\n-pub const ATTR_IF_THIS_CHANGED: &str = \"rustc_if_this_changed\";\n-pub const ATTR_THEN_THIS_WOULD_NEED: &str = \"rustc_then_this_would_need\";\n-pub const ATTR_PARTITION_REUSED: &str = \"rustc_partition_reused\";\n-pub const ATTR_PARTITION_CODEGENED: &str = \"rustc_partition_codegened\";\n-pub const ATTR_EXPECTED_CGU_REUSE: &str = \"rustc_expected_cgu_reuse\";\n+pub const ATTR_DIRTY: Symbol = sym::rustc_dirty;\n+pub const ATTR_CLEAN: Symbol = sym::rustc_clean;\n+pub const ATTR_IF_THIS_CHANGED: Symbol = sym::rustc_if_this_changed;\n+pub const ATTR_THEN_THIS_WOULD_NEED: Symbol = sym::rustc_then_this_would_need;\n+pub const ATTR_PARTITION_REUSED: Symbol = sym::rustc_partition_reused;\n+pub const ATTR_PARTITION_CODEGENED: Symbol = sym::rustc_partition_codegened;\n+pub const ATTR_EXPECTED_CGU_REUSE: Symbol = sym::rustc_expected_cgu_reuse;\n \n-pub const IGNORED_ATTRIBUTES: &[&str] = &[\n-    \"cfg\",\n+pub const IGNORED_ATTRIBUTES: &[Symbol] = &[\n+    sym::cfg,\n     ATTR_IF_THIS_CHANGED,\n     ATTR_THEN_THIS_WOULD_NEED,\n     ATTR_DIRTY,"}, {"sha": "9c926dff325bfb5a270f090d283c43c656660d1e", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -14,7 +14,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate;\n use syntax::source_map::MultiSpan;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n \n pub struct LintLevelSets {\n     list: Vec<LintSet>,\n@@ -194,7 +194,7 @@ impl<'a> LintLevelsBuilder<'a> {\n             struct_span_err!(sess, span, E0452, \"malformed lint attribute\")\n         };\n         for attr in attrs {\n-            let level = match Level::from_str(&attr.name_or_empty()) {\n+            let level = match Level::from_symbol(attr.name_or_empty()) {\n                 None => continue,\n                 Some(lvl) => lvl,\n             };\n@@ -221,7 +221,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                 match item.node {\n                     ast::MetaItemKind::Word => {}  // actual lint names handled later\n                     ast::MetaItemKind::NameValue(ref name_value) => {\n-                        if item.path == \"reason\" {\n+                        if item.path == sym::reason {\n                             // found reason, reslice meta list to exclude it\n                             metas = &metas[0..metas.len()-1];\n                             // FIXME (#55112): issue unused-attributes lint if we thereby\n@@ -230,7 +230,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                                 if !self.sess.features_untracked().lint_reasons {\n                                     feature_gate::emit_feature_err(\n                                         &self.sess.parse_sess,\n-                                        \"lint_reasons\",\n+                                        sym::lint_reasons,\n                                         item.span,\n                                         feature_gate::GateIssue::Language,\n                                         \"lint reasons are experimental\"\n@@ -261,7 +261,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                         let mut err = bad_attr(li.span());\n                         if let Some(item) = li.meta_item() {\n                             if let ast::MetaItemKind::NameValue(_) = item.node {\n-                                if item.path == \"reason\" {\n+                                if item.path == sym::reason {\n                                     err.help(\"reason in lint attribute must come last\");\n                                 }\n                             }"}, {"sha": "68b65f9b4a1ccfa9c948d76a4f1b8310e209f9a3", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -38,7 +38,7 @@ use syntax::ast;\n use syntax::source_map::{MultiSpan, ExpnFormat};\n use syntax::early_buffered_lints::BufferedEarlyLintId;\n use syntax::edition::Edition;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n \n pub use crate::lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n@@ -570,6 +570,17 @@ impl Level {\n             _ => None,\n         }\n     }\n+\n+    /// Converts a symbol to a level.\n+    pub fn from_symbol(x: Symbol) -> Option<Level> {\n+        match x {\n+            sym::allow => Some(Allow),\n+            sym::warn => Some(Warn),\n+            sym::deny => Some(Deny),\n+            sym::forbid => Some(Forbid),\n+            _ => None,\n+        }\n+    }\n }\n \n /// How a lint level was set.\n@@ -752,7 +763,7 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n \n pub fn maybe_lint_level_root(tcx: TyCtxt<'_, '_, '_>, id: hir::HirId) -> bool {\n     let attrs = tcx.hir().attrs_by_hir_id(id);\n-    attrs.iter().any(|attr| Level::from_str(&attr.name_or_empty()).is_some())\n+    attrs.iter().any(|attr| Level::from_symbol(attr.name_or_empty()).is_some())\n }\n \n fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)"}, {"sha": "2a9928567f4dcfa2fed79a3dd44afba6ed765089", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -19,6 +19,7 @@ use rustc_data_structures::fx::FxHashMap;\n \n use syntax::{ast, source_map};\n use syntax::attr;\n+use syntax::symbol::sym;\n use syntax_pos;\n \n // Any local node that may call something in its body block should be\n@@ -304,22 +305,22 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n                                     id: hir::HirId,\n                                     attrs: &[ast::Attribute]) -> bool {\n-    if attr::contains_name(attrs, \"lang\") {\n+    if attr::contains_name(attrs, sym::lang) {\n         return true;\n     }\n \n     // Stable attribute for #[lang = \"panic_impl\"]\n-    if attr::contains_name(attrs, \"panic_handler\") {\n+    if attr::contains_name(attrs, sym::panic_handler) {\n         return true;\n     }\n \n     // (To be) stable attribute for #[lang = \"oom\"]\n-    if attr::contains_name(attrs, \"alloc_error_handler\") {\n+    if attr::contains_name(attrs, sym::alloc_error_handler) {\n         return true;\n     }\n \n     // Don't lint about global allocators\n-    if attr::contains_name(attrs, \"global_allocator\") {\n+    if attr::contains_name(attrs, sym::global_allocator) {\n         return true;\n     }\n "}, {"sha": "67db2ec2481566e512869beff6b1c6e48dee2b03", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -4,6 +4,7 @@ use crate::session::{config, Session};\n use crate::session::config::EntryFnType;\n use syntax::attr;\n use syntax::entry::EntryPointType;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n use crate::hir::{HirId, Item, ItemKind, ImplItem, TraitItem};\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n@@ -58,7 +59,7 @@ fn entry_fn(tcx: TyCtxt<'_, '_, '_>, cnum: CrateNum) -> Option<(DefId, EntryFnTy\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if attr::contains_name(&tcx.hir().krate().attrs, \"no_main\") {\n+    if attr::contains_name(&tcx.hir().krate().attrs, sym::no_main) {\n         return None;\n     }\n \n@@ -81,11 +82,11 @@ fn entry_fn(tcx: TyCtxt<'_, '_, '_>, cnum: CrateNum) -> Option<(DefId, EntryFnTy\n fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n     match item.node {\n         ItemKind::Fn(..) => {\n-            if attr::contains_name(&item.attrs, \"start\") {\n+            if attr::contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start\n-            } else if attr::contains_name(&item.attrs, \"main\") {\n+            } else if attr::contains_name(&item.attrs, sym::main) {\n                 EntryPointType::MainAttr\n-            } else if item.ident.name == \"main\" {\n+            } else if item.ident.name == sym::main {\n                 if at_root {\n                     // This is a top-level function so can be 'main'.\n                     EntryPointType::MainNamed"}, {"sha": "103580a598fcd9cea61e1c2804894fc985bf3d46", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -18,7 +18,7 @@ use crate::middle::weak_lang_items;\n use crate::util::nodemap::FxHashMap;\n \n use syntax::ast;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n use rustc_macros::HashStable;\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n@@ -209,9 +209,9 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n /// are also extracted out when found.\n pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n     attrs.iter().find_map(|attr| Some(match attr {\n-        _ if attr.check_name(\"lang\") => (attr.value_str()?, attr.span),\n-        _ if attr.check_name(\"panic_handler\") => (Symbol::intern(\"panic_impl\"), attr.span),\n-        _ if attr.check_name(\"alloc_error_handler\") => (Symbol::intern(\"oom\"), attr.span),\n+        _ if attr.check_name(sym::lang) => (attr.value_str()?, attr.span),\n+        _ if attr.check_name(sym::panic_handler) => (Symbol::intern(\"panic_impl\"), attr.span),\n+        _ if attr.check_name(sym::alloc_error_handler) => (Symbol::intern(\"oom\"), attr.span),\n         _ => return None,\n     }))\n }"}, {"sha": "76934ddd69b1bb7d9efab259f58e669fba61a630", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -8,7 +8,7 @@ use crate::ty::TyCtxt;\n use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use syntax::symbol::Symbol;\n use syntax::ast::{Attribute, MetaItem, MetaItemKind};\n-use syntax_pos::{Span, symbols};\n+use syntax_pos::{Span, sym};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_macros::HashStable;\n use errors::DiagnosticId;\n@@ -51,7 +51,7 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n     }\n \n     fn extract(&self, attr: &Attribute) -> Option<(Symbol, Option<Symbol>, Span)> {\n-        let stab_attrs = [symbols::stable, symbols::unstable, symbols::rustc_const_unstable];\n+        let stab_attrs = [sym::stable, sym::unstable, sym::rustc_const_unstable];\n \n         // Find a stability attribute (i.e., `#[stable (..)]`, `#[unstable (..)]`,\n         // `#[rustc_const_unstable (..)]`).\n@@ -65,9 +65,9 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n                 for meta in metas {\n                     if let Some(mi) = meta.meta_item() {\n                         // Find the `feature = \"..\"` meta-item.\n-                        match (mi.name_or_empty().get(), mi.value_str()) {\n-                            (\"feature\", val) => feature = val,\n-                            (\"since\", val) => since = val,\n+                        match (mi.name_or_empty(), mi.value_str()) {\n+                            (sym::feature, val) => feature = val,\n+                            (sym::since, val) => since = val,\n                             _ => {}\n                         }\n                     }\n@@ -76,7 +76,7 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n                     // This additional check for stability is to make sure we\n                     // don't emit additional, irrelevant errors for malformed\n                     // attributes.\n-                    if *stab_attr != \"stable\" || since.is_some() {\n+                    if *stab_attr != sym::stable || since.is_some() {\n                         return Some((feature, since, attr.span));\n                     }\n                 }"}, {"sha": "cb333b5b0cba23e808ed1d3f6257c5aaef1ac081", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -112,7 +112,7 @@ use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId};\n use syntax::ptr::P;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax_pos::Span;\n \n use crate::hir;\n@@ -362,7 +362,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     if let FnKind::Method(..) = fk {\n         let parent = ir.tcx.hir().get_parent_item(id);\n         if let Some(Node::Item(i)) = ir.tcx.hir().find_by_hir_id(parent) {\n-            if i.attrs.iter().any(|a| a.check_name(\"automatically_derived\")) {\n+            if i.attrs.iter().any(|a| a.check_name(sym::automatically_derived)) {\n                 return;\n             }\n         }"}, {"sha": "c7f8cf684e6b16c28c56408e92bc55b1999da574", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -72,6 +72,7 @@ use crate::hir::{MutImmutable, MutMutable, PatKind};\n use crate::hir::pat_util::EnumerateAndAdjustIterator;\n use crate::hir;\n use syntax::ast::{self, Name};\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n use std::borrow::Cow;\n@@ -714,7 +715,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 // they also cannot be moved out of.\n                 let is_thread_local = self.tcx.get_attrs(def_id)[..]\n                     .iter()\n-                    .any(|attr| attr.check_name(\"thread_local\"));\n+                    .any(|attr| attr.check_name(sym::thread_local));\n \n                 let cat = if is_thread_local {\n                     let re = self.temporary_scope(hir_id.local_id);"}, {"sha": "5f355d17072b8705682073bd7377fdd681e26405", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -7,15 +7,16 @@\n \n use crate::session::Session;\n use syntax::ast;\n+use syntax::symbol::{Symbol, sym};\n \n use rustc_data_structures::sync::Once;\n \n pub fn update_limits(sess: &Session, krate: &ast::Crate) {\n-    update_limit(krate, &sess.recursion_limit, \"recursion_limit\", 64);\n-    update_limit(krate, &sess.type_length_limit, \"type_length_limit\", 1048576);\n+    update_limit(krate, &sess.recursion_limit, sym::recursion_limit, 64);\n+    update_limit(krate, &sess.type_length_limit, sym::type_length_limit, 1048576);\n }\n \n-fn update_limit(krate: &ast::Crate, limit: &Once<usize>, name: &str, default: usize) {\n+fn update_limit(krate: &ast::Crate, limit: &Once<usize>, name: Symbol, default: usize) {\n     for attr in &krate.attrs {\n         if !attr.check_name(name) {\n             continue;"}, {"sha": "2402d0eefde4886e0bdc5e8e077a487753b58c8b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -23,7 +23,7 @@ use std::mem::replace;\n use syntax::ast;\n use syntax::attr;\n use syntax::ptr::P;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax_pos::Span;\n \n use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -1285,7 +1285,7 @@ fn compute_object_lifetime_defaults(\n                 let result = object_lifetime_defaults_for_item(tcx, generics);\n \n                 // Debugging aid.\n-                if attr::contains_name(&item.attrs, \"rustc_object_lifetime_default\") {\n+                if attr::contains_name(&item.attrs, sym::rustc_object_lifetime_default) {\n                     let object_lifetime_default_reprs: String = result\n                         .iter()\n                         .map(|set| match *set {"}, {"sha": "abcf164cda6d46f783eec9251c3311f79a9c73be", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -11,7 +11,7 @@ use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::ty::query::Providers;\n use crate::middle::privacy::AccessLevels;\n use crate::session::{DiagnosticMessageId, Session};\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::{Span, MultiSpan};\n use syntax::ast::Attribute;\n use syntax::errors::Applicability;\n@@ -195,7 +195,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n             // Emit errors for non-staged-api crates.\n             for attr in attrs {\n                 let name = attr.name_or_empty();\n-                if [\"unstable\", \"stable\", \"rustc_deprecated\"].contains(&name.get()) {\n+                if [sym::unstable, sym::stable, sym::rustc_deprecated].contains(&name) {\n                     attr::mark_used(attr);\n                     self.tcx.sess.span_err(attr.span, \"stability attributes may not be used \\\n                                                         outside of the standard library\");\n@@ -669,7 +669,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         match stability {\n             Some(&Stability { level: attr::Unstable { reason, issue }, feature, .. }) => {\n-                if span.allows_unstable(&feature.as_str()) {\n+                if span.allows_unstable(feature) {\n                     debug!(\"stability: skipping span={:?} since it is internal\", span);\n                     return EvalResult::Allow;\n                 }\n@@ -686,7 +686,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // the `-Z force-unstable-if-unmarked` flag present (we're\n                 // compiling a compiler crate), then let this missing feature\n                 // annotation slide.\n-                if feature == \"rustc_private\" && issue == 27812 {\n+                if feature == sym::rustc_private && issue == 27812 {\n                     if self.sess.opts.debugging_opts.force_unstable_if_unmarked {\n                         return EvalResult::Allow;\n                     }\n@@ -739,7 +739,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 let error_id = (DiagnosticMessageId::StabilityId(issue), span_key, msg.clone());\n                 let fresh = self.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n                 if fresh {\n-                    emit_feature_err(&self.sess.parse_sess, &feature.as_str(), span,\n+                    emit_feature_err(&self.sess.parse_sess, feature, span,\n                                      GateIssue::Library(Some(issue)), &msg);\n                 }\n             }\n@@ -802,13 +802,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n                 if adt_def.has_dtor(self.tcx) {\n                     emit_feature_err(&self.tcx.sess.parse_sess,\n-                                     \"untagged_unions\", item.span, GateIssue::Language,\n+                                     sym::untagged_unions, item.span, GateIssue::Language,\n                                      \"unions with `Drop` implementations are unstable\");\n                 } else {\n                     let param_env = self.tcx.param_env(def_id);\n                     if !param_env.can_type_implement_copy(self.tcx, ty).is_ok() {\n                         emit_feature_err(&self.tcx.sess.parse_sess,\n-                                         \"untagged_unions\", item.span, GateIssue::Language,\n+                                         sym::untagged_unions, item.span, GateIssue::Language,\n                                          \"unions with non-`Copy` fields are unstable\");\n                     }\n                 }"}, {"sha": "75c21c738f7a07ae9e0da2de1d5ffcfa77c7d92f", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -6,7 +6,7 @@ use crate::middle::lang_items;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_target::spec::PanicStrategy;\n use syntax::ast;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n use crate::hir::def_id::DefId;\n use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n@@ -46,8 +46,8 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     lang_items::extract(attrs).and_then(|(name, _)| {\n-        $(if name == stringify!($name) {\n-            Some(Symbol::intern(stringify!($sym)))\n+        $(if name == sym::$name {\n+            Some(sym::$sym)\n         } else)* {\n             None\n         }"}, {"sha": "2fff4c3f109b103565cbcd910653252f57758d5e", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -1052,7 +1052,7 @@ rustc_queries! {\n     }\n \n     Other {\n-        query target_features_whitelist(_: CrateNum) -> Lrc<FxHashMap<String, Option<String>>> {\n+        query target_features_whitelist(_: CrateNum) -> Lrc<FxHashMap<String, Option<Symbol>>> {\n             eval_always\n             desc { \"looking up the whitelist of target features\" }\n         }"}, {"sha": "f61ffac15d5f92acfa78a13f4c98bf69c054f26a", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -2753,6 +2753,7 @@ mod tests {\n     // another --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n+        use syntax::symbol::sym;\n         syntax::with_globals(|| {\n             let matches = &match optgroups().parse(&[\"--test\".to_string(),\n                                                      \"--cfg=test\".to_string()]) {\n@@ -2763,7 +2764,7 @@ mod tests {\n             let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n             let sess = build_session(sessopts, None, registry);\n             let cfg = build_configuration(&sess, to_crate_config(cfg));\n-            let mut test_items = cfg.iter().filter(|&&(name, _)| name == \"test\");\n+            let mut test_items = cfg.iter().filter(|&&(name, _)| name == sym::test);\n             assert!(test_items.next().is_some());\n             assert!(test_items.next().is_none());\n         });"}, {"sha": "4d47491661e8639fba50b6752de90e7eaa5bae4d", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -29,6 +29,7 @@ use syntax::feature_gate::{self, AttributeType};\n use syntax::json::JsonEmitter;\n use syntax::source_map;\n use syntax::parse::{self, ParseSess};\n+use syntax::symbol::Symbol;\n use syntax_pos::{MultiSpan, Span};\n use crate::util::profiling::SelfProfiler;\n \n@@ -86,7 +87,7 @@ pub struct Session {\n     /// in order to avoid redundantly verbose output (Issue #24690, #44953).\n     pub one_time_diagnostics: Lock<FxHashSet<(DiagnosticMessageId, Option<Span>, String)>>,\n     pub plugin_llvm_passes: OneThread<RefCell<Vec<String>>>,\n-    pub plugin_attributes: Lock<Vec<(String, AttributeType)>>,\n+    pub plugin_attributes: Lock<Vec<(Symbol, AttributeType)>>,\n     pub crate_types: Once<Vec<config::CrateType>>,\n     pub dependency_formats: Once<dependency_format::Dependencies>,\n     /// The crate_disambiguator is constructed out of all the `-C metadata`"}, {"sha": "afbce5a4f0a49170e83fd41347281b9eeca6e368", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -4,17 +4,16 @@\n //! [trait-resolution]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n //! [trait-specialization]: https://rust-lang.github.io/rustc-guide/traits/specialization.html\n \n-use crate::infer::CombinedSnapshot;\n+use crate::infer::{CombinedSnapshot, InferOk};\n use crate::hir::def_id::{DefId, LOCAL_CRATE};\n-use syntax_pos::DUMMY_SP;\n use crate::traits::{self, Normalized, SelectionContext, Obligation, ObligationCause};\n use crate::traits::IntercrateMode;\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::Subst;\n-\n-use crate::infer::{InferOk};\n+use syntax::symbol::sym;\n+use syntax_pos::DUMMY_SP;\n \n /// Whether we do the orphan check relative to this crate or\n /// to some remote crate.\n@@ -233,7 +232,7 @@ pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n pub fn trait_ref_is_local_or_fundamental<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                          trait_ref: ty::TraitRef<'tcx>)\n                                                          -> bool {\n-    trait_ref.def_id.krate == LOCAL_CRATE || tcx.has_attr(trait_ref.def_id, \"fundamental\")\n+    trait_ref.def_id.krate == LOCAL_CRATE || tcx.has_attr(trait_ref.def_id, sym::fundamental)\n }\n \n pub enum OrphanCheckErr<'tcx> {"}, {"sha": "df2688397102299ab0c1602a27fd53a27e714cea", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -35,6 +35,7 @@ use crate::util::nodemap::{FxHashMap, FxHashSet};\n use errors::{Applicability, DiagnosticBuilder};\n use std::fmt;\n use syntax::ast;\n+use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, Span, ExpnInfo, ExpnFormat};\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n@@ -329,7 +330,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             return None\n         };\n \n-        if tcx.has_attr(impl_def_id, \"rustc_on_unimplemented\") {\n+        if tcx.has_attr(impl_def_id, sym::rustc_on_unimplemented) {\n             Some(impl_def_id)\n         } else {\n             None"}, {"sha": "7ba7429f465a6642604d307dc05bd0b30b40d3a1", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -7,6 +7,7 @@ use crate::util::nodemap::FxHashMap;\n \n use syntax::ast::{MetaItem, NestedMetaItem};\n use syntax::attr;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n use syntax_pos::symbol::LocalInternedString;\n \n@@ -84,25 +85,25 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n         let mut note = None;\n         let mut subcommands = vec![];\n         for item in item_iter {\n-            if item.check_name(\"message\") && message.is_none() {\n+            if item.check_name(sym::message) && message.is_none() {\n                 if let Some(message_) = item.value_str() {\n                     message = Some(OnUnimplementedFormatString::try_parse(\n                         tcx, trait_def_id, message_.as_str(), span)?);\n                     continue;\n                 }\n-            } else if item.check_name(\"label\") && label.is_none() {\n+            } else if item.check_name(sym::label) && label.is_none() {\n                 if let Some(label_) = item.value_str() {\n                     label = Some(OnUnimplementedFormatString::try_parse(\n                         tcx, trait_def_id, label_.as_str(), span)?);\n                     continue;\n                 }\n-            } else if item.check_name(\"note\") && note.is_none() {\n+            } else if item.check_name(sym::note) && note.is_none() {\n                 if let Some(note_) = item.value_str() {\n                     note = Some(OnUnimplementedFormatString::try_parse(\n                         tcx, trait_def_id, note_.as_str(), span)?);\n                     continue;\n                 }\n-            } else if item.check_name(\"on\") && is_root &&\n+            } else if item.check_name(sym::on) && is_root &&\n                 message.is_none() && label.is_none() && note.is_none()\n             {\n                 if let Some(items) = item.meta_item_list() {\n@@ -139,7 +140,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n     {\n         let attrs = tcx.get_attrs(impl_def_id);\n \n-        let attr = if let Some(item) = attr::find_by_name(&attrs, \"rustc_on_unimplemented\") {\n+        let attr = if let Some(item) = attr::find_by_name(&attrs, sym::rustc_on_unimplemented) {\n             item\n         } else {\n             return Ok(None);"}, {"sha": "f05a19372918edd3e1b062d59fbefd20730af8d8", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -19,6 +19,7 @@ use crate::mir::interpret::{GlobalId, ConstValue};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use rustc_macros::HashStable;\n use syntax::ast::Ident;\n+use syntax::symbol::sym;\n use crate::ty::subst::{Subst, InternalSubsts};\n use crate::ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n@@ -1318,9 +1319,9 @@ fn confirm_generator_candidate<'cx, 'gcx, 'tcx>(\n                                             gen_sig)\n         .map_bound(|(trait_ref, yield_ty, return_ty)| {\n             let name = tcx.associated_item(obligation.predicate.item_def_id).ident.name;\n-            let ty = if name == \"Return\" {\n+            let ty = if name == sym::Return {\n                 return_ty\n-            } else if name == \"Yield\" {\n+            } else if name == sym::Yield {\n                 yield_ty\n             } else {\n                 bug!()"}, {"sha": "c9fee02f66bbdf19970bd270fddf25bbfda9bda0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -74,7 +74,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map::MultiSpan;\n use syntax::feature_gate;\n-use syntax::symbol::{Symbol, keywords, InternedString};\n+use syntax::symbol::{Symbol, keywords, InternedString, sym};\n use syntax_pos::Span;\n \n use crate::hir;\n@@ -1213,7 +1213,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n             span_bug!(attr.span, \"no arguments to `rustc_layout_scalar_valid_range` attribute\");\n         };\n-        (get(\"rustc_layout_scalar_valid_range_start\"), get(\"rustc_layout_scalar_valid_range_end\"))\n+        (get(sym::rustc_layout_scalar_valid_range_start),\n+         get(sym::rustc_layout_scalar_valid_range_end))\n     }\n \n     pub fn lift<T: ?Sized + Lift<'tcx>>(self, value: &T) -> Option<T::Lifted> {\n@@ -3102,10 +3103,10 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n     providers.is_panic_runtime = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        attr::contains_name(tcx.hir().krate_attrs(), \"panic_runtime\")\n+        attr::contains_name(tcx.hir().krate_attrs(), sym::panic_runtime)\n     };\n     providers.is_compiler_builtins = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        attr::contains_name(tcx.hir().krate_attrs(), \"compiler_builtins\")\n+        attr::contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins)\n     };\n }"}, {"sha": "2f71861d4dc0df57d8de5e9e87da1036af49eec2", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -47,7 +47,7 @@ use std::ops::Range;\n use syntax::ast::{self, Name, Ident, NodeId};\n use syntax::attr;\n use syntax::ext::hygiene::Mark;\n-use syntax::symbol::{keywords, Symbol, LocalInternedString, InternedString};\n+use syntax::symbol::{keywords, sym, Symbol, LocalInternedString, InternedString};\n use syntax_pos::Span;\n \n use smallvec;\n@@ -1875,11 +1875,11 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n         );\n \n         let mut flags = VariantFlags::NO_VARIANT_FLAGS;\n-        if adt_kind == AdtKind::Struct && tcx.has_attr(parent_did, \"non_exhaustive\") {\n+        if adt_kind == AdtKind::Struct && tcx.has_attr(parent_did, sym::non_exhaustive) {\n             debug!(\"found non-exhaustive field list for {:?}\", parent_did);\n             flags = flags | VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE;\n         } else if let Some(variant_did) = variant_did {\n-            if tcx.has_attr(variant_did, \"non_exhaustive\") {\n+            if tcx.has_attr(variant_did, sym::non_exhaustive) {\n                 debug!(\"found non-exhaustive field list for {:?}\", variant_did);\n                 flags = flags | VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE;\n             }\n@@ -2156,7 +2156,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n \n-        if kind == AdtKind::Enum && tcx.has_attr(did, \"non_exhaustive\") {\n+        if kind == AdtKind::Enum && tcx.has_attr(did, sym::non_exhaustive) {\n             debug!(\"found non-exhaustive variant list for {:?}\", did);\n             flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n         }\n@@ -2172,7 +2172,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n \n         let attrs = tcx.get_attrs(did);\n-        if attr::contains_name(&attrs, \"fundamental\") {\n+        if attr::contains_name(&attrs, sym::fundamental) {\n             flags |= AdtFlags::IS_FUNDAMENTAL;\n         }\n         if Some(did) == tcx.lang_items().phantom_data() {\n@@ -3030,7 +3030,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Determines whether an item is annotated with an attribute.\n-    pub fn has_attr(self, did: DefId, attr: &str) -> bool {\n+    pub fn has_attr(self, did: DefId, attr: Symbol) -> bool {\n         attr::contains_name(&self.get_attrs(did), attr)\n     }\n "}, {"sha": "926c0f8b949193cc9376b75259d7bf936df00bca", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -22,6 +22,7 @@ use rustc_macros::HashStable;\n use std::{cmp, fmt};\n use syntax::ast;\n use syntax::attr::{self, SignedInt, UnsignedInt};\n+use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Copy, Clone, Debug)]\n@@ -447,7 +448,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Such access can be in plain sight (e.g., dereferencing\n         // `*foo.0` of `Foo<'a>(&'a u32)`) or indirectly hidden\n         // (e.g., calling `foo.0.clone()` of `Foo<T:Clone>`).\n-        if self.has_attr(dtor, \"unsafe_destructor_blind_to_params\") {\n+        if self.has_attr(dtor, sym::unsafe_destructor_blind_to_params) {\n             debug!(\"destructor_constraint({:?}) - blind\", def.did);\n             return vec![];\n         }"}, {"sha": "0200e6c53b69cc1742bdbfae1379654e8ff1a218", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -19,7 +19,7 @@ use syntax::{\n     mut_visit::{self, MutVisitor},\n     parse::ParseSess,\n     ptr::P,\n-    symbol::Symbol\n+    symbol::{Symbol, sym}\n };\n use syntax_pos::Span;\n \n@@ -58,7 +58,7 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n     fn flat_map_item(&mut self, item: P<Item>) -> SmallVec<[P<Item>; 1]> {\n         debug!(\"in submodule {}\", self.in_submod);\n \n-        let name = if attr::contains_name(&item.attrs, \"global_allocator\") {\n+        let name = if attr::contains_name(&item.attrs, sym::global_allocator) {\n             \"global_allocator\"\n         } else {\n             return mut_visit::noop_flat_map_item(item, self);"}, {"sha": "f26684d9ef04ae4a46c4ee87f1884a1f33af350b", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -321,12 +321,12 @@ pub fn provide(providers: &mut Providers<'_>) {\n             // rustdoc needs to be able to document functions that use all the features, so\n             // whitelist them all\n             Lrc::new(llvm_util::all_known_features()\n-                .map(|(a, b)| (a.to_string(), b.map(|s| s.to_string())))\n+                .map(|(a, b)| (a.to_string(), b))\n                 .collect())\n         } else {\n             Lrc::new(llvm_util::target_feature_whitelist(tcx.sess)\n                 .iter()\n-                .map(|&(a, b)| (a.to_string(), b.map(|s| s.to_string())))\n+                .map(|&(a, b)| (a.to_string(), b))\n                 .collect())\n         }\n     };"}, {"sha": "5f47108309fbfdac3749da165bba96e0682c90c5", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -14,6 +14,7 @@ use rustc::mir::interpret::{ConstValue, Allocation, read_target_uint,\n use rustc::hir::Node;\n use syntax_pos::Span;\n use rustc_target::abi::HasDataLayout;\n+use syntax::symbol::sym;\n use syntax_pos::symbol::LocalInternedString;\n use rustc::ty::{self, Ty};\n use rustc_codegen_ssa::traits::*;\n@@ -248,7 +249,7 @@ impl CodegenCx<'ll, 'tcx> {\n             debug!(\"get_static: sym={} attrs={:?}\", sym, attrs);\n \n             for attr in attrs {\n-                if attr.check_name(\"thread_local\") {\n+                if attr.check_name(sym::thread_local) {\n                     llvm::set_thread_local_mode(g, self.tls_model);\n                 }\n             }"}, {"sha": "04c9e93c7a527cf79c41c18d035706cc740ca987", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -9,6 +9,7 @@ use rustc::session::config::DebugInfo;\n use rustc_codegen_ssa::traits::*;\n \n use syntax::attr;\n+use syntax::symbol::sym;\n \n \n /// Inserts a side-effect free instruction sequence that makes sure that the\n@@ -66,8 +67,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n \n pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx<'_, '_>) -> bool {\n     let omit_gdb_pretty_printer_section =\n-        attr::contains_name(&cx.tcx.hir().krate_attrs(),\n-                            \"omit_gdb_pretty_printer_section\");\n+        attr::contains_name(&cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n \n     !omit_gdb_pretty_printer_section &&\n     cx.sess().opts.debuginfo != DebugInfo::None &&"}, {"sha": "274c89659628d207125710f69cc65b72af37eb0a", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 68, "deletions": 67, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -7,6 +7,7 @@ use rustc_target::spec::MergeFunctions;\n use libc::c_int;\n use std::ffi::CString;\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::symbol::sym;\n \n use std::str;\n use std::slice;\n@@ -93,114 +94,114 @@ unsafe fn configure_llvm(sess: &Session) {\n // to LLVM or the feature detection code will walk past the end of the feature\n // array, leading to crashes.\n \n-const ARM_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"aclass\", Some(\"arm_target_feature\")),\n-    (\"mclass\", Some(\"arm_target_feature\")),\n-    (\"rclass\", Some(\"arm_target_feature\")),\n-    (\"dsp\", Some(\"arm_target_feature\")),\n-    (\"neon\", Some(\"arm_target_feature\")),\n-    (\"v5te\", Some(\"arm_target_feature\")),\n-    (\"v6\", Some(\"arm_target_feature\")),\n-    (\"v6k\", Some(\"arm_target_feature\")),\n-    (\"v6t2\", Some(\"arm_target_feature\")),\n-    (\"v7\", Some(\"arm_target_feature\")),\n-    (\"v8\", Some(\"arm_target_feature\")),\n-    (\"vfp2\", Some(\"arm_target_feature\")),\n-    (\"vfp3\", Some(\"arm_target_feature\")),\n-    (\"vfp4\", Some(\"arm_target_feature\")),\n+const ARM_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"aclass\", Some(sym::arm_target_feature)),\n+    (\"mclass\", Some(sym::arm_target_feature)),\n+    (\"rclass\", Some(sym::arm_target_feature)),\n+    (\"dsp\", Some(sym::arm_target_feature)),\n+    (\"neon\", Some(sym::arm_target_feature)),\n+    (\"v5te\", Some(sym::arm_target_feature)),\n+    (\"v6\", Some(sym::arm_target_feature)),\n+    (\"v6k\", Some(sym::arm_target_feature)),\n+    (\"v6t2\", Some(sym::arm_target_feature)),\n+    (\"v7\", Some(sym::arm_target_feature)),\n+    (\"v8\", Some(sym::arm_target_feature)),\n+    (\"vfp2\", Some(sym::arm_target_feature)),\n+    (\"vfp3\", Some(sym::arm_target_feature)),\n+    (\"vfp4\", Some(sym::arm_target_feature)),\n ];\n \n-const AARCH64_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"fp\", Some(\"aarch64_target_feature\")),\n-    (\"neon\", Some(\"aarch64_target_feature\")),\n-    (\"sve\", Some(\"aarch64_target_feature\")),\n-    (\"crc\", Some(\"aarch64_target_feature\")),\n-    (\"crypto\", Some(\"aarch64_target_feature\")),\n-    (\"ras\", Some(\"aarch64_target_feature\")),\n-    (\"lse\", Some(\"aarch64_target_feature\")),\n-    (\"rdm\", Some(\"aarch64_target_feature\")),\n-    (\"fp16\", Some(\"aarch64_target_feature\")),\n-    (\"rcpc\", Some(\"aarch64_target_feature\")),\n-    (\"dotprod\", Some(\"aarch64_target_feature\")),\n-    (\"v8.1a\", Some(\"aarch64_target_feature\")),\n-    (\"v8.2a\", Some(\"aarch64_target_feature\")),\n-    (\"v8.3a\", Some(\"aarch64_target_feature\")),\n+const AARCH64_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"fp\", Some(sym::aarch64_target_feature)),\n+    (\"neon\", Some(sym::aarch64_target_feature)),\n+    (\"sve\", Some(sym::aarch64_target_feature)),\n+    (\"crc\", Some(sym::aarch64_target_feature)),\n+    (\"crypto\", Some(sym::aarch64_target_feature)),\n+    (\"ras\", Some(sym::aarch64_target_feature)),\n+    (\"lse\", Some(sym::aarch64_target_feature)),\n+    (\"rdm\", Some(sym::aarch64_target_feature)),\n+    (\"fp16\", Some(sym::aarch64_target_feature)),\n+    (\"rcpc\", Some(sym::aarch64_target_feature)),\n+    (\"dotprod\", Some(sym::aarch64_target_feature)),\n+    (\"v8.1a\", Some(sym::aarch64_target_feature)),\n+    (\"v8.2a\", Some(sym::aarch64_target_feature)),\n+    (\"v8.3a\", Some(sym::aarch64_target_feature)),\n ];\n \n-const X86_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"adx\", Some(\"adx_target_feature\")),\n+const X86_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"adx\", Some(sym::adx_target_feature)),\n     (\"aes\", None),\n     (\"avx\", None),\n     (\"avx2\", None),\n-    (\"avx512bw\", Some(\"avx512_target_feature\")),\n-    (\"avx512cd\", Some(\"avx512_target_feature\")),\n-    (\"avx512dq\", Some(\"avx512_target_feature\")),\n-    (\"avx512er\", Some(\"avx512_target_feature\")),\n-    (\"avx512f\", Some(\"avx512_target_feature\")),\n-    (\"avx512ifma\", Some(\"avx512_target_feature\")),\n-    (\"avx512pf\", Some(\"avx512_target_feature\")),\n-    (\"avx512vbmi\", Some(\"avx512_target_feature\")),\n-    (\"avx512vl\", Some(\"avx512_target_feature\")),\n-    (\"avx512vpopcntdq\", Some(\"avx512_target_feature\")),\n+    (\"avx512bw\", Some(sym::avx512_target_feature)),\n+    (\"avx512cd\", Some(sym::avx512_target_feature)),\n+    (\"avx512dq\", Some(sym::avx512_target_feature)),\n+    (\"avx512er\", Some(sym::avx512_target_feature)),\n+    (\"avx512f\", Some(sym::avx512_target_feature)),\n+    (\"avx512ifma\", Some(sym::avx512_target_feature)),\n+    (\"avx512pf\", Some(sym::avx512_target_feature)),\n+    (\"avx512vbmi\", Some(sym::avx512_target_feature)),\n+    (\"avx512vl\", Some(sym::avx512_target_feature)),\n+    (\"avx512vpopcntdq\", Some(sym::avx512_target_feature)),\n     (\"bmi1\", None),\n     (\"bmi2\", None),\n-    (\"cmpxchg16b\", Some(\"cmpxchg16b_target_feature\")),\n-    (\"f16c\", Some(\"f16c_target_feature\")),\n+    (\"cmpxchg16b\", Some(sym::cmpxchg16b_target_feature)),\n+    (\"f16c\", Some(sym::f16c_target_feature)),\n     (\"fma\", None),\n     (\"fxsr\", None),\n     (\"lzcnt\", None),\n-    (\"mmx\", Some(\"mmx_target_feature\")),\n-    (\"movbe\", Some(\"movbe_target_feature\")),\n+    (\"mmx\", Some(sym::mmx_target_feature)),\n+    (\"movbe\", Some(sym::movbe_target_feature)),\n     (\"pclmulqdq\", None),\n     (\"popcnt\", None),\n     (\"rdrand\", None),\n     (\"rdseed\", None),\n-    (\"rtm\", Some(\"rtm_target_feature\")),\n+    (\"rtm\", Some(sym::rtm_target_feature)),\n     (\"sha\", None),\n     (\"sse\", None),\n     (\"sse2\", None),\n     (\"sse3\", None),\n     (\"sse4.1\", None),\n     (\"sse4.2\", None),\n-    (\"sse4a\", Some(\"sse4a_target_feature\")),\n+    (\"sse4a\", Some(sym::sse4a_target_feature)),\n     (\"ssse3\", None),\n-    (\"tbm\", Some(\"tbm_target_feature\")),\n+    (\"tbm\", Some(sym::tbm_target_feature)),\n     (\"xsave\", None),\n     (\"xsavec\", None),\n     (\"xsaveopt\", None),\n     (\"xsaves\", None),\n ];\n \n-const HEXAGON_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"hvx\", Some(\"hexagon_target_feature\")),\n-    (\"hvx-double\", Some(\"hexagon_target_feature\")),\n+const HEXAGON_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"hvx\", Some(sym::hexagon_target_feature)),\n+    (\"hvx-double\", Some(sym::hexagon_target_feature)),\n ];\n \n-const POWERPC_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"altivec\", Some(\"powerpc_target_feature\")),\n-    (\"power8-altivec\", Some(\"powerpc_target_feature\")),\n-    (\"power9-altivec\", Some(\"powerpc_target_feature\")),\n-    (\"power8-vector\", Some(\"powerpc_target_feature\")),\n-    (\"power9-vector\", Some(\"powerpc_target_feature\")),\n-    (\"vsx\", Some(\"powerpc_target_feature\")),\n+const POWERPC_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power8-altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power9-altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power8-vector\", Some(sym::powerpc_target_feature)),\n+    (\"power9-vector\", Some(sym::powerpc_target_feature)),\n+    (\"vsx\", Some(sym::powerpc_target_feature)),\n ];\n \n-const MIPS_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"fp64\", Some(\"mips_target_feature\")),\n-    (\"msa\", Some(\"mips_target_feature\")),\n+const MIPS_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"fp64\", Some(sym::mips_target_feature)),\n+    (\"msa\", Some(sym::mips_target_feature)),\n ];\n \n-const WASM_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"simd128\", Some(\"wasm_target_feature\")),\n-    (\"atomics\", Some(\"wasm_target_feature\")),\n+const WASM_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"simd128\", Some(sym::wasm_target_feature)),\n+    (\"atomics\", Some(sym::wasm_target_feature)),\n ];\n \n /// When rustdoc is running, provide a list of all known features so that all their respective\n /// primitives may be documented.\n ///\n /// IMPORTANT: If you're adding another whitelist to the above lists, make sure to add it to this\n /// iterator!\n-pub fn all_known_features() -> impl Iterator<Item=(&'static str, Option<&'static str>)> {\n+pub fn all_known_features() -> impl Iterator<Item=(&'static str, Option<Symbol>)> {\n     ARM_WHITELIST.iter().cloned()\n         .chain(AARCH64_WHITELIST.iter().cloned())\n         .chain(X86_WHITELIST.iter().cloned())\n@@ -247,7 +248,7 @@ pub fn target_features(sess: &Session) -> Vec<Symbol> {\n }\n \n pub fn target_feature_whitelist(sess: &Session)\n-    -> &'static [(&'static str, Option<&'static str>)]\n+    -> &'static [(&'static str, Option<Symbol>)]\n {\n     match &*sess.target.target.arch {\n         \"arm\" => ARM_WHITELIST,"}, {"sha": "6320d8a671ddbfd66f87de8060b86e9641839956", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -28,7 +28,7 @@ use rustc_target::spec::MergeFunctions;\n use syntax::attr;\n use syntax::ext::hygiene::Mark;\n use syntax_pos::MultiSpan;\n-use syntax_pos::symbol::Symbol;\n+use syntax_pos::symbol::{Symbol, sym};\n use jobserver::{Client, Acquired};\n \n use std::any::Any;\n@@ -382,11 +382,11 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let sess = tcx.sess;\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n-    let no_builtins = attr::contains_name(&tcx.hir().krate().attrs, \"no_builtins\");\n+    let no_builtins = attr::contains_name(&tcx.hir().krate().attrs, sym::no_builtins);\n     let subsystem = attr::first_attr_value_str_by_name(&tcx.hir().krate().attrs,\n-                                                       \"windows_subsystem\");\n+                                                       sym::windows_subsystem);\n     let windows_subsystem = subsystem.map(|subsystem| {\n-        if subsystem != \"windows\" && subsystem != \"console\" {\n+        if subsystem != sym::windows && subsystem != sym::console {\n             tcx.sess.fatal(&format!(\"invalid windows subsystem `{}`, only \\\n                                      `windows` and `console` are allowed\",\n                                     subsystem));"}, {"sha": "586db5cfabea44c83c1e4bafdeffca034818b86d", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -5,6 +5,7 @@ use rustc::mir;\n use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use rustc_apfloat::{ieee, Float, Status, Round};\n use std::{u128, i128};\n+use syntax::symbol::sym;\n \n use crate::base;\n use crate::MemFlags;\n@@ -181,9 +182,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     mir::CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n                         match operand.layout.ty.sty {\n                             ty::FnDef(def_id, substs) => {\n-                                if bx.cx().tcx().has_attr(def_id, \"rustc_args_required_const\") {\n-                                    bug!(\"reifying a fn ptr that requires \\\n-                                          const arguments\");\n+                                if bx.cx().tcx().has_attr(def_id, sym::rustc_args_required_const) {\n+                                    bug!(\"reifying a fn ptr that requires const arguments\");\n                                 }\n                                 OperandValue::Immediate(\n                                     callee::resolve_and_get_fn(bx.cx(), def_id, substs))"}, {"sha": "b4ba90c61f65054fb2242d9825eba54466f96227", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -23,6 +23,7 @@ extern crate rustc;\n \n use rustc::ty::TyCtxt;\n use rustc::hir::def_id::LOCAL_CRATE;\n+use syntax::symbol::sym;\n \n pub mod link;\n pub mod codegen_backend;\n@@ -35,7 +36,7 @@ pub mod symbol_names_test;\n /// reporting an error.\n pub fn check_for_rustc_errors_attr(tcx: TyCtxt<'_, '_, '_>) {\n     if let Some((def_id, _)) = tcx.entry_fn(LOCAL_CRATE) {\n-        if tcx.has_attr(def_id, \"rustc_error\") {\n+        if tcx.has_attr(def_id, sym::rustc_error) {\n             tcx.sess.span_fatal(tcx.def_span(def_id), \"compilation successful\");\n         }\n     }"}, {"sha": "a2ac64fa7e0c659501ed309b202d20e9326b0561", "filename": "src/librustc_codegen_utils/link.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flink.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -2,6 +2,7 @@ use rustc::session::config::{self, OutputFilenames, Input, OutputType};\n use rustc::session::Session;\n use std::path::{Path, PathBuf};\n use syntax::{ast, attr};\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n pub fn out_filename(sess: &Session,\n@@ -49,13 +50,13 @@ pub fn find_crate_name(sess: Option<&Session>,\n     // as used. After doing this, however, we still prioritize a crate name from\n     // the command line over one found in the #[crate_name] attribute. If we\n     // find both we ensure that they're the same later on as well.\n-    let attr_crate_name = attr::find_by_name(attrs, \"crate_name\")\n+    let attr_crate_name = attr::find_by_name(attrs, sym::crate_name)\n         .and_then(|at| at.value_str().map(|s| (at, s)));\n \n     if let Some(sess) = sess {\n         if let Some(ref s) = sess.opts.crate_name {\n             if let Some((attr, name)) = attr_crate_name {\n-                if name != &**s {\n+                if name.as_str() != *s {\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);"}, {"sha": "27ae0b97e59452f406c34d87ecfb133f74d7e8c4", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -6,11 +6,11 @@\n \n use rustc::hir;\n use rustc::ty::TyCtxt;\n-\n use rustc_mir::monomorphize::Instance;\n+use syntax::symbol::{Symbol, sym};\n \n-const SYMBOL_NAME: &'static str = \"rustc_symbol_name\";\n-const DEF_PATH: &'static str = \"rustc_def_path\";\n+const SYMBOL_NAME: Symbol = sym::rustc_symbol_name;\n+const DEF_PATH: Symbol = sym::rustc_def_path;\n \n pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // if the `rustc_attrs` feature is not enabled, then the"}, {"sha": "02f8eee67b15118ffed36a9b0b19f79054a286f7", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -63,6 +63,7 @@ use syntax::ast;\n use syntax::source_map::FileLoader;\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n+use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, MultiSpan, FileName};\n \n pub mod pretty;\n@@ -669,7 +670,7 @@ impl RustcDefaultCalls {\n                         // through to build scripts.\n                         let value = value.as_ref().map(|s| s.as_str());\n                         let value = value.as_ref().map(|s| s.as_ref());\n-                        if name != \"target_feature\" || value != Some(\"crt-static\") {\n+                        if name != sym::target_feature || value != Some(\"crt-static\") {\n                             if !allow_unstable_cfg && gated_cfg.is_some() {\n                                 return None\n                             }"}, {"sha": "04dad9c5355c5b6028416a6a8cac8633660d8335", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -27,12 +27,13 @@ use rustc::mir::mono::CodegenUnitNameBuilder;\n use rustc::ty::TyCtxt;\n use std::collections::BTreeSet;\n use syntax::ast;\n+use syntax::symbol::{Symbol, sym};\n use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_CODEGENED,\n                  ATTR_EXPECTED_CGU_REUSE};\n \n-const MODULE: &str = \"module\";\n-const CFG: &str = \"cfg\";\n-const KIND: &str = \"kind\";\n+const MODULE: Symbol = sym::module;\n+const CFG: Symbol = sym::cfg;\n+const KIND: Symbol = sym::kind;\n \n pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.dep_graph.with_ignore(|| {\n@@ -146,7 +147,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n                                                         comp_kind);\n     }\n \n-    fn field(&self, attr: &ast::Attribute, name: &str) -> ast::Name {\n+    fn field(&self, attr: &ast::Attribute, name: Symbol) -> ast::Name {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(name) {\n                 if let Some(value) = item.value_str() {"}, {"sha": "f404a4f82e672a1e76958d45b3b72bb31ddac777", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -23,14 +23,15 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit;\n use rustc::ich::{ATTR_DIRTY, ATTR_CLEAN};\n-use syntax::ast::{self, Attribute, NestedMetaItem};\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashSet;\n+use syntax::ast::{self, Attribute, NestedMetaItem};\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n-use rustc::ty::TyCtxt;\n \n-const EXCEPT: &str = \"except\";\n-const LABEL: &str = \"label\";\n-const CFG: &str = \"cfg\";\n+const EXCEPT: Symbol = sym::except;\n+const LABEL: Symbol = sym::label;\n+const CFG: Symbol = sym::cfg;\n \n // Base and Extra labels to build up the labels\n \n@@ -591,7 +592,7 @@ fn expect_associated_value(tcx: TyCtxt<'_, '_, '_>, item: &NestedMetaItem) -> as\n // nodes.\n pub struct FindAllAttrs<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    attr_names: Vec<&'static str>,\n+    attr_names: Vec<Symbol>,\n     found_attrs: Vec<&'tcx Attribute>,\n }\n "}, {"sha": "c5ac8860ccd9b079db0146dc386df0c92fa398f8", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -230,7 +230,7 @@ impl BoxedResolver {\n \n pub struct PluginInfo {\n     syntax_exts: Vec<NamedSyntaxExtension>,\n-    attributes: Vec<(String, AttributeType)>,\n+    attributes: Vec<(Symbol, AttributeType)>,\n }\n \n pub fn register_plugins<'a>("}, {"sha": "e9f2f0410d440bb7889e27bcdc0eee798dfc3d52", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -4,6 +4,7 @@ use rustc::hir;\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n use syntax::attr;\n+use syntax::symbol::sym;\n \n pub fn find<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> Option<DefId> {\n     tcx.proc_macro_decls_static(LOCAL_CRATE)\n@@ -27,7 +28,7 @@ struct Finder {\n \n impl<'v> ItemLikeVisitor<'v> for Finder {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if attr::contains_name(&item.attrs, \"rustc_proc_macro_decls\") {\n+        if attr::contains_name(&item.attrs, sym::rustc_proc_macro_decls) {\n             self.decls = Some(item.hir_id);\n         }\n     }"}, {"sha": "d2d0d19180783bfd5b8fc557553514bbf0fb6731", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -35,7 +35,7 @@ use syntax::mut_visit::{*, MutVisitor, visit_clobber};\n use syntax::ast::BlockCheckMode;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::source_map::{FileLoader, RealFileLoader, SourceMap};\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::{self, ast, attr};\n #[cfg(not(parallel_compiler))]\n use std::{thread, panic};\n@@ -495,24 +495,24 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n     let attr_types: Vec<config::CrateType> = attrs\n         .iter()\n         .filter_map(|a| {\n-            if a.check_name(\"crate_type\") {\n+            if a.check_name(sym::crate_type) {\n                 match a.value_str() {\n-                    Some(ref n) if *n == \"rlib\" => Some(config::CrateType::Rlib),\n-                    Some(ref n) if *n == \"dylib\" => Some(config::CrateType::Dylib),\n-                    Some(ref n) if *n == \"cdylib\" => Some(config::CrateType::Cdylib),\n-                    Some(ref n) if *n == \"lib\" => Some(config::default_lib_output()),\n-                    Some(ref n) if *n == \"staticlib\" => Some(config::CrateType::Staticlib),\n-                    Some(ref n) if *n == \"proc-macro\" => Some(config::CrateType::ProcMacro),\n-                    Some(ref n) if *n == \"bin\" => Some(config::CrateType::Executable),\n-                    Some(ref n) => {\n+                    Some(sym::rlib) => Some(config::CrateType::Rlib),\n+                    Some(sym::dylib) => Some(config::CrateType::Dylib),\n+                    Some(sym::cdylib) => Some(config::CrateType::Cdylib),\n+                    Some(sym::lib) => Some(config::default_lib_output()),\n+                    Some(sym::staticlib) => Some(config::CrateType::Staticlib),\n+                    Some(sym::proc_dash_macro) => Some(config::CrateType::ProcMacro),\n+                    Some(sym::bin) => Some(config::CrateType::Executable),\n+                    Some(n) => {\n                         let crate_types = vec![\n-                            Symbol::intern(\"rlib\"),\n-                            Symbol::intern(\"dylib\"),\n-                            Symbol::intern(\"cdylib\"),\n-                            Symbol::intern(\"lib\"),\n-                            Symbol::intern(\"staticlib\"),\n-                            Symbol::intern(\"proc-macro\"),\n-                            Symbol::intern(\"bin\")\n+                            sym::rlib,\n+                            sym::dylib,\n+                            sym::cdylib,\n+                            sym::lib,\n+                            sym::staticlib,\n+                            sym::proc_dash_macro,\n+                            sym::bin\n                         ];\n \n                         if let ast::MetaItemKind::NameValue(spanned) = a.meta().unwrap().node {"}, {"sha": "af4f1b88b0fb0ac8e8e6938c545f58d8b70b3f2e", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -42,7 +42,7 @@ use syntax::edition::Edition;\n use syntax::feature_gate::{AttributeGate, AttributeTemplate, AttributeType};\n use syntax::feature_gate::{Stability, deprecated_attributes};\n use syntax_pos::{BytePos, Span, SyntaxContext};\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::{Symbol, keywords, sym};\n use syntax::errors::{Applicability, DiagnosticBuilder};\n use syntax::print::pprust::expr_to_string;\n use syntax::visit::FnKind;\n@@ -207,7 +207,7 @@ impl UnsafeCode {\n \n impl EarlyLintPass for UnsafeCode {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n-        if attr.check_name(\"allow_internal_unsafe\") {\n+        if attr.check_name(sym::allow_internal_unsafe) {\n             self.report_unsafe(cx, attr.span, \"`allow_internal_unsafe` allows defining \\\n                                                macros using unsafe without triggering \\\n                                                the `unsafe_code` lint at their call site\");\n@@ -285,7 +285,7 @@ pub struct MissingDoc {\n impl_lint_pass!(MissingDoc => [MISSING_DOCS]);\n \n fn has_doc(attr: &ast::Attribute) -> bool {\n-    if !attr.check_name(\"doc\") {\n+    if !attr.check_name(sym::doc) {\n         return false;\n     }\n \n@@ -295,7 +295,7 @@ fn has_doc(attr: &ast::Attribute) -> bool {\n \n     if let Some(list) = attr.meta_item_list() {\n         for meta in list {\n-            if meta.check_name(\"include\") || meta.check_name(\"hidden\") {\n+            if meta.check_name(sym::include) || meta.check_name(sym::hidden) {\n                 return true;\n             }\n         }\n@@ -355,10 +355,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext<'_, '_>, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden() ||\n                          attrs.iter().any(|attr| {\n-            attr.check_name(\"doc\") &&\n+            attr.check_name(sym::doc) &&\n             match attr.meta_item_list() {\n                 None => false,\n-                Some(l) => attr::list_contains_name(&l, \"hidden\"),\n+                Some(l) => attr::list_contains_name(&l, sym::hidden),\n             }\n         });\n         self.doc_hidden_stack.push(doc_hidden);\n@@ -723,7 +723,7 @@ impl UnusedDocComment {\n \n             let span = sugared_span.take().unwrap_or_else(|| attr.span);\n \n-            if attr.check_name(\"doc\") {\n+            if attr.check_name(sym::doc) {\n                 let mut err = cx.struct_span_lint(UNUSED_DOC_COMMENTS, span, \"unused doc comment\");\n \n                 err.span_label(\n@@ -829,7 +829,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         match it.node {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n-                if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, \"no_mangle\") {\n+                if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n                     for param in &generics.params {\n                         match param.kind {\n                             GenericParamKind::Lifetime { .. } => {}\n@@ -856,7 +856,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                 }\n             }\n             hir::ItemKind::Const(..) => {\n-                if attr::contains_name(&it.attrs, \"no_mangle\") {\n+                if attr::contains_name(&it.attrs, sym::no_mangle) {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n                     let msg = \"const items should never be #[no_mangle]\";\n@@ -947,7 +947,7 @@ declare_lint_pass!(\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n     fn check_attribute(&mut self, ctx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n-        if attr.check_name(\"feature\") {\n+        if attr.check_name(sym::feature) {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n                     ctx.span_lint(UNSTABLE_FEATURES, item.span(), \"unstable feature\");\n@@ -1382,7 +1382,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n             return;\n         }\n \n-        if let Some(attr) = attr::find_by_name(&it.attrs, \"rustc_test_marker\") {\n+        if let Some(attr) = attr::find_by_name(&it.attrs, sym::rustc_test_marker) {\n             cx.struct_span_lint(\n                 UNNAMEABLE_TEST_ITEMS,\n                 attr.span,"}, {"sha": "551eded9858a35021fb31d24ccf9a6bdc860f442", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -9,6 +9,7 @@ use lint::{EarlyLintPass, LintPass, LateLintPass};\n use syntax::ast;\n use syntax::attr;\n use syntax::errors::Applicability;\n+use syntax::symbol::sym;\n use syntax_pos::{BytePos, symbol::Ident, Span};\n \n #[derive(PartialEq)]\n@@ -253,7 +254,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         let crate_ident = if let Some(name) = &cx.tcx.sess.opts.crate_name {\n             Some(Ident::from_str(name))\n         } else {\n-            attr::find_by_name(&cx.tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID), \"crate_name\")\n+            attr::find_by_name(&cx.tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID), sym::crate_name)\n                 .and_then(|attr| attr.meta())\n                 .and_then(|meta| {\n                     meta.name_value_literal().and_then(|lit| {\n@@ -315,7 +316,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n             }\n             FnKind::ItemFn(ident, _, header, _, attrs) => {\n                 // Skip foreign-ABI #[no_mangle] functions (Issue #31924)\n-                if header.abi != Abi::Rust && attr::contains_name(attrs, \"no_mangle\") {\n+                if header.abi != Abi::Rust && attr::contains_name(attrs, sym::no_mangle) {\n                     return;\n                 }\n                 self.check_snake_case(cx, \"function\", ident);\n@@ -390,7 +391,7 @@ impl NonUpperCaseGlobals {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         match it.node {\n-            hir::ItemKind::Static(..) if !attr::contains_name(&it.attrs, \"no_mangle\") => {\n+            hir::ItemKind::Static(..) if !attr::contains_name(&it.attrs, sym::no_mangle) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", &it.ident);\n             }\n             hir::ItemKind::Const(..) => {"}, {"sha": "c3dfd44ad8572f46ebc4ebc67411296924d30c59", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -12,7 +12,7 @@ use syntax::attr;\n use syntax::errors::Applicability;\n use syntax::feature_gate::{AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use syntax::print::pprust;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax::symbol::Symbol;\n use syntax::util::parser;\n use syntax_pos::Span;\n@@ -170,7 +170,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             descr_post_path: &str,\n         ) -> bool {\n             for attr in cx.tcx.get_attrs(def_id).iter() {\n-                if attr.check_name(\"must_use\") {\n+                if attr.check_name(sym::must_use) {\n                     let msg = format!(\"unused {}`{}`{} that must be used\",\n                         descr_pre_path, cx.tcx.def_path_str(def_id), descr_post_path);\n                     let mut err = cx.struct_span_lint(UNUSED_MUST_USE, sp, &msg);\n@@ -243,8 +243,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n         }\n \n         let plugin_attributes = cx.sess().plugin_attributes.borrow_mut();\n-        for &(ref name, ty) in plugin_attributes.iter() {\n-            if ty == AttributeType::Whitelisted && attr.check_name(&**name) {\n+        for &(name, ty) in plugin_attributes.iter() {\n+            if ty == AttributeType::Whitelisted && attr.check_name(name) {\n                 debug!(\"{:?} (plugin attr) is whitelisted with ty {:?}\", name, ty);\n                 break;\n             }\n@@ -262,7 +262,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n             // Has a plugin registered this attribute as one that must be used at\n             // the crate level?\n             let plugin_crate = plugin_attributes.iter()\n-                .find(|&&(ref x, t)| name == x.as_str() && AttributeType::CrateLevel == t)\n+                .find(|&&(x, t)| name == x && AttributeType::CrateLevel == t)\n                 .is_some();\n             if known_crate || plugin_crate {\n                 let msg = match attr.style {"}, {"sha": "a4c7daf088ff2c9e14e052bcd9cd21ffad50f64a", "filename": "src/librustc_macros/src/symbols.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -11,7 +11,7 @@ use quote::quote;\n #[allow(non_camel_case_types)]\n mod kw {\n     syn::custom_keyword!(Keywords);\n-    syn::custom_keyword!(Other);\n+    syn::custom_keyword!(Symbols);\n }\n \n struct Keyword {\n@@ -33,14 +33,24 @@ impl Parse for Keyword {\n     }\n }\n \n-struct Symbol(Ident);\n+struct Symbol {\n+    name: Ident,\n+    value: Option<LitStr>,\n+}\n \n impl Parse for Symbol {\n     fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        let ident: Ident = input.parse()?;\n+        let name = input.parse()?;\n+        let value = match input.parse::<Token![:]>() {\n+            Ok(_) => Some(input.parse()?),\n+            Err(_) => None,\n+        };\n         input.parse::<Token![,]>()?;\n \n-        Ok(Symbol(ident))\n+        Ok(Symbol {\n+            name,\n+            value,\n+        })\n     }\n }\n \n@@ -69,7 +79,7 @@ impl Parse for Input {\n         braced!(content in input);\n         let keywords = content.parse()?;\n \n-        input.parse::<kw::Other>()?;\n+        input.parse::<kw::Symbols>()?;\n         let content;\n         braced!(content in input);\n         let symbols = content.parse()?;\n@@ -116,19 +126,22 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n     }\n \n     for symbol in &input.symbols.0 {\n-        let value = &symbol.0;\n-        let value_str = value.to_string();\n-        check_dup(&value_str);\n+        let name = &symbol.name;\n+        let value = match &symbol.value {\n+            Some(value) => value.value(),\n+            None => name.to_string(),\n+        };\n+        check_dup(&value);\n         prefill_stream.extend(quote! {\n-            #value_str,\n+            #value,\n         });\n         symbols_stream.extend(quote! {\n-            pub const #value: Symbol = Symbol::new(#counter);\n+            pub const #name: Symbol = Symbol::new(#counter);\n         });\n         counter += 1;\n     }\n \n-    TokenStream::from(quote! {\n+    let tt = TokenStream::from(quote! {\n         macro_rules! keywords {\n             () => {\n                 #keyword_stream\n@@ -159,5 +172,11 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n                 ])\n             }\n         }\n-    })\n+    });\n+\n+    // To see the generated code generated, uncomment this line, recompile, and\n+    // run the resulting output through `rustfmt`.\n+    //eprintln!(\"{}\", tt);\n+\n+    tt\n }"}, {"sha": "7f2a1c0b4b1d11d6f28a1fe96c60e1a920a23020", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -27,7 +27,7 @@ use std::{cmp, fs};\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::visit;\n use syntax::{span_err, span_fatal};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -650,9 +650,8 @@ impl<'a> CrateLoader<'a> {\n     /// SVH and DefIndex of the registrar function.\n     pub fn find_plugin_registrar(&mut self,\n                                  span: Span,\n-                                 name: &str)\n+                                 name: Symbol)\n                                  -> Option<(PathBuf, CrateDisambiguator)> {\n-        let name = Symbol::intern(name);\n         let ekrate = self.read_extension_crate(span, name, name);\n \n         if ekrate.target_only {\n@@ -704,7 +703,7 @@ impl<'a> CrateLoader<'a> {\n         let desired_strategy = self.sess.panic_strategy();\n         let mut runtime_found = false;\n         let mut needs_panic_runtime = attr::contains_name(&krate.attrs,\n-                                                          \"needs_panic_runtime\");\n+                                                          sym::needs_panic_runtime);\n \n         self.cstore.iter_crate_data(|cnum, data| {\n             needs_panic_runtime = needs_panic_runtime ||\n@@ -837,7 +836,7 @@ impl<'a> CrateLoader<'a> {\n \n             let mut uses_std = false;\n             self.cstore.iter_crate_data(|_, data| {\n-                if data.name == \"std\" {\n+                if data.name == sym::std {\n                     uses_std = true;\n                 }\n             });\n@@ -898,7 +897,7 @@ impl<'a> CrateLoader<'a> {\n         // about through the `#![needs_allocator]` attribute and is typically\n         // written down in liballoc.\n         let mut needs_allocator = attr::contains_name(&krate.attrs,\n-                                                      \"needs_allocator\");\n+                                                      sym::needs_allocator);\n         self.cstore.iter_crate_data(|_, data| {\n             needs_allocator = needs_allocator || data.root.needs_allocator;\n         });\n@@ -964,7 +963,7 @@ impl<'a> CrateLoader<'a> {\n         // allocator. At this point our allocator request is typically fulfilled\n         // by the standard library, denoted by the `#![default_lib_allocator]`\n         // attribute.\n-        let mut has_default = attr::contains_name(&krate.attrs, \"default_lib_allocator\");\n+        let mut has_default = attr::contains_name(&krate.attrs, sym::default_lib_allocator);\n         self.cstore.iter_crate_data(|_, data| {\n             if data.root.has_default_lib_allocator {\n                 has_default = true;\n@@ -987,7 +986,7 @@ impl<'a> CrateLoader<'a> {\n \n             impl<'ast> visit::Visitor<'ast> for Finder {\n                 fn visit_item(&mut self, i: &'ast ast::Item) {\n-                    if attr::contains_name(&i.attrs, \"global_allocator\") {\n+                    if attr::contains_name(&i.attrs, sym::global_allocator) {\n                         self.0 = true;\n                     }\n                     visit::walk_item(self, i)\n@@ -1065,7 +1064,7 @@ impl<'a> CrateLoader<'a> {\n                     }\n                     None => item.ident.name,\n                 };\n-                let dep_kind = if attr::contains_name(&item.attrs, \"no_link\") {\n+                let dep_kind = if attr::contains_name(&item.attrs, sym::no_link) {\n                     DepKind::UnexportedMacrosOnly\n                 } else {\n                     DepKind::Explicit"}, {"sha": "087256a971056ba410d58fdf9fe7b357e277ae55", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -31,7 +31,7 @@ use syntax::source_map;\n use syntax::edition::Edition;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n use rustc_data_structures::bit_set::BitSet;\n \n@@ -432,7 +432,7 @@ impl cstore::CStore {\n         let data = self.get_crate_data(id.krate);\n         if let Some(ref proc_macros) = data.proc_macros {\n             return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n-        } else if data.name == \"proc_macro\" && data.item_name(id.index) == \"quote\" {\n+        } else if data.name == sym::proc_macro && data.item_name(id.index) == \"quote\" {\n             use syntax::ext::base::SyntaxExtension;\n             use syntax_ext::proc_macro_impl::BangProcMacro;\n "}, {"sha": "e950c2815e9b4547f60a0ecf25b4a9b0964bad76", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -29,7 +29,7 @@ use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast::{self, Ident};\n use syntax::source_map;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::{InternedString, sym};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::hygiene::Mark;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n@@ -841,7 +841,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                 // for other constructors correct visibilities\n                                 // were already encoded in metadata.\n                                 let attrs = self.get_item_attrs(def_id.index, sess);\n-                                if attr::contains_name(&attrs, \"non_exhaustive\") {\n+                                if attr::contains_name(&attrs, sym::non_exhaustive) {\n                                     let crate_def_id = self.local_def_id(CRATE_DEF_INDEX);\n                                     vis = ty::Visibility::Restricted(crate_def_id);\n                                 }"}, {"sha": "0ac03526832b7506c969c00e20318f4008c64157", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -33,7 +33,7 @@ use std::u32;\n use syntax::ast;\n use syntax::attr;\n use syntax::source_map::Spanned;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax_pos::{self, hygiene, FileName, SourceFile, Span};\n use log::{debug, trace};\n \n@@ -469,7 +469,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let attrs = tcx.hir().krate_attrs();\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n-        let has_default_lib_allocator = attr::contains_name(&attrs, \"default_lib_allocator\");\n+        let has_default_lib_allocator = attr::contains_name(&attrs, sym::default_lib_allocator);\n         let has_global_allocator = *tcx.sess.has_global_allocator.get();\n         let has_panic_handler = *tcx.sess.has_panic_handler.try_get().unwrap_or(&false);\n \n@@ -496,13 +496,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             } else {\n                 None\n             },\n-            compiler_builtins: attr::contains_name(&attrs, \"compiler_builtins\"),\n-            needs_allocator: attr::contains_name(&attrs, \"needs_allocator\"),\n-            needs_panic_runtime: attr::contains_name(&attrs, \"needs_panic_runtime\"),\n-            no_builtins: attr::contains_name(&attrs, \"no_builtins\"),\n-            panic_runtime: attr::contains_name(&attrs, \"panic_runtime\"),\n-            profiler_runtime: attr::contains_name(&attrs, \"profiler_runtime\"),\n-            sanitizer_runtime: attr::contains_name(&attrs, \"sanitizer_runtime\"),\n+            compiler_builtins: attr::contains_name(&attrs, sym::compiler_builtins),\n+            needs_allocator: attr::contains_name(&attrs, sym::needs_allocator),\n+            needs_panic_runtime: attr::contains_name(&attrs, sym::needs_panic_runtime),\n+            no_builtins: attr::contains_name(&attrs, sym::no_builtins),\n+            panic_runtime: attr::contains_name(&attrs, sym::panic_runtime),\n+            profiler_runtime: attr::contains_name(&attrs, sym::profiler_runtime),\n+            sanitizer_runtime: attr::contains_name(&attrs, sym::sanitizer_runtime),\n \n             crate_deps,\n             dylib_dependency_formats,"}, {"sha": "f4682465a659ae32bbaaba0dc4799ab9b6f5f3fa", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -2,6 +2,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir;\n use rustc::ty::TyCtxt;\n use rustc_target::spec::abi::Abi;\n+use syntax::symbol::sym;\n \n pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<String> {\n     let mut collector = Collector {\n@@ -10,7 +11,7 @@ pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<String> {\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n \n     for attr in tcx.hir().krate().attrs.iter() {\n-        if attr.path == \"link_args\" {\n+        if attr.path == sym::link_args {\n             if let Some(linkarg) = attr.value_str() {\n                 collector.add_link_args(&linkarg.as_str());\n             }\n@@ -37,7 +38,7 @@ impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n         }\n \n         // First, add all of the custom #[link_args] attributes\n-        for m in it.attrs.iter().filter(|a| a.check_name(\"link_args\")) {\n+        for m in it.attrs.iter().filter(|a| a.check_name(sym::link_args)) {\n             if let Some(linkarg) = m.value_str() {\n                 self.add_link_args(&linkarg.as_str());\n             }"}, {"sha": "7d7dd1061a959db19aa1b8571db02167691c78a2", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -225,7 +225,7 @@ use rustc::session::search_paths::PathKind;\n use rustc::util::nodemap::FxHashMap;\n \n use errors::DiagnosticBuilder;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::struct_span_err;\n use syntax_pos::Span;\n use rustc_target::spec::{Target, TargetTriple};\n@@ -408,7 +408,7 @@ impl<'a> Context<'a> {\n                                            self.ident,\n                                            add);\n \n-            if (self.ident == \"std\" || self.ident == \"core\")\n+            if (self.ident == sym::std || self.ident == sym::core)\n                 && self.triple != TargetTriple::from_triple(config::host_triple()) {\n                 err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n             }"}, {"sha": "fee08f421549dc9811954d6af4ec85d84a282744", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -8,7 +8,7 @@ use rustc_target::spec::abi::Abi;\n use syntax::attr;\n use syntax::source_map::Span;\n use syntax::feature_gate::{self, GateIssue};\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::{span_err, struct_span_err};\n \n pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<NativeLibrary> {\n@@ -47,7 +47,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n         }\n \n         // Process all of the #[link(..)]-style arguments\n-        for m in it.attrs.iter().filter(|a| a.check_name(\"link\")) {\n+        for m in it.attrs.iter().filter(|a| a.check_name(sym::link)) {\n             let items = match m.meta_item_list() {\n                 Some(item) => item,\n                 None => continue,\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n             let mut kind_specified = false;\n \n             for item in items.iter() {\n-                if item.check_name(\"kind\") {\n+                if item.check_name(sym::kind) {\n                     kind_specified = true;\n                     let kind = match item.value_str() {\n                         Some(name) => name,\n@@ -81,9 +81,9 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n                             cstore::NativeUnknown\n                         }\n                     };\n-                } else if item.check_name(\"name\") {\n+                } else if item.check_name(sym::name) {\n                     lib.name = item.value_str();\n-                } else if item.check_name(\"cfg\") {\n+                } else if item.check_name(sym::cfg) {\n                     let cfg = match item.meta_item_list() {\n                         Some(list) => list,\n                         None => continue, // skip like historical compilers\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n                     } else {\n                         self.tcx.sess.span_err(cfg[0].span(), \"invalid argument for `cfg(..)`\");\n                     }\n-                } else if item.check_name(\"wasm_import_module\") {\n+                } else if item.check_name(sym::wasm_import_module) {\n                     match item.value_str() {\n                         Some(s) => lib.wasm_import_module = Some(s),\n                         None => {\n@@ -156,15 +156,15 @@ impl<'a, 'tcx> Collector<'a, 'tcx> {\n         }\n         if lib.cfg.is_some() && !self.tcx.features().link_cfg {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n-                                           \"link_cfg\",\n+                                           sym::link_cfg,\n                                            span.unwrap(),\n                                            GateIssue::Language,\n                                            \"is feature gated\");\n         }\n         if lib.kind == cstore::NativeStaticNobundle &&\n            !self.tcx.features().static_nobundle {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n-                                           \"static_nobundle\",\n+                                           sym::static_nobundle,\n                                            span.unwrap_or_else(|| syntax_pos::DUMMY_SP),\n                                            GateIssue::Language,\n                                            \"kind=\\\"static-nobundle\\\" is feature gated\");\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> Collector<'a, 'tcx> {\n                 let any_duplicate = self.libs\n                     .iter()\n                     .filter_map(|lib| lib.name.as_ref())\n-                    .any(|n| n == name);\n+                    .any(|n| n.as_str() == *name);\n                 if new_name.is_empty() {\n                     self.tcx.sess.err(\n                         &format!(\"an empty renaming target was specified for library `{}`\",name));\n@@ -212,7 +212,7 @@ impl<'a, 'tcx> Collector<'a, 'tcx> {\n             // can move them to the end of the list below.\n             let mut existing = self.libs.drain_filter(|lib| {\n                 if let Some(lib_name) = lib.name {\n-                    if lib_name == name as &str {\n+                    if lib_name.as_str() == *name {\n                         if let Some(k) = kind {\n                             lib.kind = k;\n                         }"}, {"sha": "1068305a1134c2b6b5f936ab9b3bd5f3a12aceac", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -20,6 +20,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::Span;\n use syntax::source_map::CompilerDesugaringKind;\n+use syntax::symbol::sym;\n \n use super::borrow_set::BorrowData;\n use super::{MirBorrowckCtxt};\n@@ -1839,7 +1840,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })\n         ) = place {\n             let attrs = self.infcx.tcx.get_attrs(*def_id);\n-            let is_thread_local = attrs.iter().any(|attr| attr.check_name(\"thread_local\"));\n+            let is_thread_local = attrs.iter().any(|attr| attr.check_name(sym::thread_local));\n \n             debug!(\n                 \"is_place_thread_local: attrs={:?} is_thread_local={:?}\","}, {"sha": "fa490c108c8965f647caaa8a6c7509834d45fc14", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -20,6 +20,7 @@ use std::io;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::str::FromStr;\n+use syntax::symbol::sym;\n \n use self::mir_util::PassWhere;\n use polonius_engine::{Algorithm, Output};\n@@ -280,7 +281,7 @@ fn dump_annotation<'a, 'gcx, 'tcx>(\n ) {\n     let tcx = infcx.tcx;\n     let base_def_id = tcx.closure_base_def_id(mir_def_id);\n-    if !tcx.has_attr(base_def_id, \"rustc_regions\") {\n+    if !tcx.has_attr(base_def_id, sym::rustc_regions) {\n         return;\n     }\n "}, {"sha": "a9d23a0afeabcc3a6ef79a0fd9ddd1ccea0ac1ad", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -1,4 +1,5 @@\n use syntax::ast::{self, MetaItem};\n+use syntax::symbol::{Symbol, sym};\n \n use rustc_data_structures::bit_set::{BitSet, BitSetOperator, HybridBitSet};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -100,9 +101,9 @@ where\n     fn propagate(&mut self) { self.flow_state.propagate(); }\n }\n \n-pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<MetaItem> {\n+pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: Symbol) -> Option<MetaItem> {\n     for attr in attrs {\n-        if attr.check_name(\"rustc_mir\") {\n+        if attr.check_name(sym::rustc_mir) {\n             let items = attr.meta_item_list();\n             for item in items.iter().flat_map(|l| l.iter()) {\n                 match item.meta_item() {\n@@ -158,10 +159,8 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitD\n             return None;\n         };\n \n-        let print_preflow_to =\n-            name_found(tcx.sess, attributes, \"borrowck_graphviz_preflow\");\n-        let print_postflow_to =\n-            name_found(tcx.sess, attributes, \"borrowck_graphviz_postflow\");\n+        let print_preflow_to = name_found(tcx.sess, attributes, sym::borrowck_graphviz_preflow);\n+        let print_postflow_to = name_found(tcx.sess, attributes, sym::borrowck_graphviz_postflow);\n \n         let mut mbcx = DataflowBuilder {\n             def_id,"}, {"sha": "e8070b21bb8c7d9e0350fc244b391ca9439dae6a", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::subst::{Kind, InternalSubsts};\n use rustc::ty::layout::VariantIdx;\n use syntax::ast;\n use syntax::attr;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use rustc::hir;\n use crate::hair::constant::{lit_to_const, LitToConstError};\n \n@@ -67,7 +67,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n         // the settings for the crate they are codegened in.\n-        let mut check_overflow = attr::contains_name(attrs, \"rustc_inherit_overflow_checks\");\n+        let mut check_overflow = attr::contains_name(attrs, sym::rustc_inherit_overflow_checks);\n \n         // Respect -C overflow-checks.\n         check_overflow |= tcx.sess.overflow_checks();"}, {"sha": "0576bb53d8f4219268ff2e1eb02dd97abe500723", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -27,6 +27,7 @@ use std::cmp::Ordering;\n use std::fmt;\n use syntax::ast;\n use syntax::ptr::P;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n #[derive(Clone, Debug)]\n@@ -978,7 +979,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n                 PatternKind::Wild\n             }\n-            ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n+            ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n                 let path = self.tcx.def_path_str(adt_def.did);\n                 let msg = format!(\n                     \"to use a constant of type `{}` in a pattern, \\\n@@ -990,7 +991,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 PatternKind::Wild\n             }\n             ty::Ref(_, ty::TyS { sty: ty::Adt(adt_def, _), .. }, _)\n-            if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n+            if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n                 // HACK(estebank): Side-step ICE #53708, but anything other than erroring here\n                 // would be wrong. Returnging `PatternKind::Wild` is not technically correct.\n                 let path = self.tcx.def_path_str(adt_def.did);"}, {"sha": "2512525b4bb7e56ffff5caf4384f65870625d77d", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -2,6 +2,7 @@ use rustc::ty::{self, Ty, TypeAndMut};\n use rustc::ty::layout::{self, TyLayout, Size};\n use rustc::ty::adjustment::{PointerCast};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n+use syntax::symbol::sym;\n \n use rustc_apfloat::ieee::{Single, Double};\n use rustc::mir::interpret::{\n@@ -76,9 +77,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.sty {\n                     ty::FnDef(def_id, substs) => {\n-                        if self.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n-                            bug!(\"reifying a fn ptr that requires \\\n-                                    const arguments\");\n+                        if self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n+                            bug!(\"reifying a fn ptr that requires const arguments\");\n                         }\n                         let instance: EvalResult<'tcx, _> = ty::Instance::resolve(\n                             *self.tcx,"}, {"sha": "fab07a2290eb5a31efc5bebf8a33aede8a6c7269", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -12,7 +12,7 @@ use rustc::lint::builtin::{SAFE_EXTERN_STATICS, SAFE_PACKED_BORROWS, UNUSED_UNSA\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext};\n \n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n \n use std::ops::Bound;\n \n@@ -612,7 +612,7 @@ fn report_unused_unsafe(tcx: TyCtxt<'_, '_, '_>,\n fn builtin_derive_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId> {\n     debug!(\"builtin_derive_def_id({:?})\", def_id);\n     if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n-        if tcx.has_attr(impl_def_id, \"automatically_derived\") {\n+        if tcx.has_attr(impl_def_id, sym::automatically_derived) {\n             debug!(\"builtin_derive_def_id({:?}) - is {:?}\", def_id, impl_def_id);\n             Some(impl_def_id)\n         } else {"}, {"sha": "579f75ba516571a9ece7da2a60285c10efd77191", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -22,6 +22,7 @@ use rustc::middle::lang_items;\n use rustc::session::config::nightly_options;\n use syntax::ast::LitKind;\n use syntax::feature_gate::{emit_feature_err, GateIssue};\n+use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::fmt;\n@@ -380,8 +381,8 @@ impl Qualif for IsNotPromotable {\n \n                 !allowed ||\n                     cx.tcx.get_attrs(def_id).iter().any(\n-                        |attr| attr.check_name(\"thread_local\"\n-                    ))\n+                        |attr| attr.check_name(sym::thread_local)\n+                    )\n             }\n         }\n     }\n@@ -939,7 +940,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 if self.tcx\n                        .get_attrs(def_id)\n                        .iter()\n-                       .any(|attr| attr.check_name(\"thread_local\")) {\n+                       .any(|attr| attr.check_name(sym::thread_local)) {\n                     if self.mode != Mode::Fn {\n                         span_err!(self.tcx.sess, self.span, E0625,\n                                   \"thread-local statics cannot be \\\n@@ -994,7 +995,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                 if let ty::RawPtr(_) = base_ty.sty {\n                                     if !self.tcx.features().const_raw_ptr_deref {\n                                         emit_feature_err(\n-                                            &self.tcx.sess.parse_sess, \"const_raw_ptr_deref\",\n+                                            &self.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n                                             self.span, GateIssue::Language,\n                                             &format!(\n                                                 \"dereferencing raw pointers in {}s is unstable\",\n@@ -1018,7 +1019,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     Mode::ConstFn => {\n                                         if !self.tcx.features().const_fn_union {\n                                             emit_feature_err(\n-                                                &self.tcx.sess.parse_sess, \"const_fn_union\",\n+                                                &self.tcx.sess.parse_sess, sym::const_fn_union,\n                                                 self.span, GateIssue::Language,\n                                                 \"unions in const fn are unstable\",\n                                             );\n@@ -1123,7 +1124,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                             // in const fn and constants require the feature gate\n                             // FIXME: make it unsafe inside const fn and constants\n                             emit_feature_err(\n-                                &self.tcx.sess.parse_sess, \"const_raw_ptr_to_usize_cast\",\n+                                &self.tcx.sess.parse_sess, sym::const_raw_ptr_to_usize_cast,\n                                 self.span, GateIssue::Language,\n                                 &format!(\n                                     \"casting pointers to integers in {}s is unstable\",\n@@ -1149,7 +1150,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                         // FIXME: make it unsafe to use these operations\n                         emit_feature_err(\n                             &self.tcx.sess.parse_sess,\n-                            \"const_compare_raw_pointers\",\n+                            sym::const_compare_raw_pointers,\n                             self.span,\n                             GateIssue::Language,\n                             &format!(\"comparing raw pointers inside {}\", self.mode),\n@@ -1210,7 +1211,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                         // const eval transmute calls only with the feature gate\n                                         if !self.tcx.features().const_transmute {\n                                             emit_feature_err(\n-                                                &self.tcx.sess.parse_sess, \"const_transmute\",\n+                                                &self.tcx.sess.parse_sess, sym::const_transmute,\n                                                 self.span, GateIssue::Language,\n                                                 &format!(\"The use of std::mem::transmute() \\\n                                                 is gated in {}s\", self.mode));\n@@ -1249,7 +1250,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                         // Don't allow panics in constants without the feature gate.\n                                         emit_feature_err(\n                                             &self.tcx.sess.parse_sess,\n-                                            \"const_panic\",\n+                                            sym::const_panic,\n                                             self.span,\n                                             GateIssue::Language,\n                                             &format!(\"panicking in {}s is unstable\", self.mode),\n@@ -1260,7 +1261,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     // Check `#[unstable]` const fns or `#[rustc_const_unstable]`\n                                     // functions without the feature gate active in this crate in\n                                     // order to report a better error message than the one below.\n-                                    if !self.span.allows_unstable(&feature.as_str()) {\n+                                    if !self.span.allows_unstable(feature) {\n                                         let mut err = self.tcx.sess.struct_span_err(self.span,\n                                             &format!(\"`{}` is not yet stable as a const fn\",\n                                                     self.tcx.def_path_str(def_id)));\n@@ -1592,7 +1593,7 @@ impl MirPass for QualifyAndPromoteConstants {\n         if mode == Mode::Static {\n             // `#[thread_local]` statics don't have to be `Sync`.\n             for attr in &tcx.get_attrs(def_id)[..] {\n-                if attr.check_name(\"thread_local\") {\n+                if attr.check_name(sym::thread_local) {\n                     return;\n                 }\n             }\n@@ -1616,7 +1617,7 @@ impl MirPass for QualifyAndPromoteConstants {\n \n fn args_required_const(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<FxHashSet<usize>> {\n     let attrs = tcx.get_attrs(def_id);\n-    let attr = attrs.iter().find(|a| a.check_name(\"rustc_args_required_const\"))?;\n+    let attr = attrs.iter().find(|a| a.check_name(sym::rustc_args_required_const))?;\n     let mut ret = FxHashSet::default();\n     for meta in attr.meta_item_list()? {\n         match meta.literal()?.node {"}, {"sha": "815821f6ff0337eb6bf72906485e398917d9d41a", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -1,5 +1,6 @@\n use rustc_target::spec::abi::{Abi};\n use syntax::ast;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n use rustc::ty::{self, TyCtxt};\n@@ -27,7 +28,7 @@ impl MirPass for SanityCheck {\n     fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           src: MirSource<'tcx>, mir: &mut Mir<'tcx>) {\n         let def_id = src.def_id();\n-        if !tcx.has_attr(def_id, \"rustc_mir\") {\n+        if !tcx.has_attr(def_id, sym::rustc_mir) {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n             return;\n         } else {\n@@ -52,16 +53,16 @@ impl MirPass for SanityCheck {\n                         DefinitelyInitializedPlaces::new(tcx, mir, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n \n-        if has_rustc_mir_with(&attributes, \"rustc_peek_maybe_init\").is_some() {\n+        if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_init).is_some() {\n             sanity_check_via_rustc_peek(tcx, mir, def_id, &attributes, &flow_inits);\n         }\n-        if has_rustc_mir_with(&attributes, \"rustc_peek_maybe_uninit\").is_some() {\n+        if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_uninit).is_some() {\n             sanity_check_via_rustc_peek(tcx, mir, def_id, &attributes, &flow_uninits);\n         }\n-        if has_rustc_mir_with(&attributes, \"rustc_peek_definite_init\").is_some() {\n+        if has_rustc_mir_with(&attributes, sym::rustc_peek_definite_init).is_some() {\n             sanity_check_via_rustc_peek(tcx, mir, def_id, &attributes, &flow_def_inits);\n         }\n-        if has_rustc_mir_with(&attributes, \"stop_after_dataflow\").is_some() {\n+        if has_rustc_mir_with(&attributes, sym::stop_after_dataflow).is_some() {\n             tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n         }\n     }"}, {"sha": "2bea1db841ae918db916e9e2ba15f6f67255ddf9", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -15,7 +15,7 @@ use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::source_map::Spanned;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n use syntax::{span_err, struct_span_err, walk_list};\n@@ -565,7 +565,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.has_proc_macro_decls = true;\n         }\n \n-        if attr::contains_name(&item.attrs, \"global_allocator\") {\n+        if attr::contains_name(&item.attrs, sym::global_allocator) {\n             self.has_global_allocator = true;\n         }\n \n@@ -676,8 +676,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n-                attr::first_attr_value_str_by_name(&item.attrs, \"path\");\n-                if attr::contains_name(&item.attrs, \"warn_directory_ownership\") {\n+                attr::first_attr_value_str_by_name(&item.attrs, sym::path);\n+                if attr::contains_name(&item.attrs, sym::warn_directory_ownership) {\n                     let lint = lint::builtin::LEGACY_DIRECTORY_OWNERSHIP;\n                     let msg = \"cannot declare a new module at this location\";\n                     self.session.buffer_lint(lint, item.id, item.span, msg);"}, {"sha": "dea5774aa6eb7c64a00f39545bcf1aece4f9c293", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -12,6 +12,7 @@ use rustc::ty::ParamEnv;\n use rustc::ty::Ty;\n use rustc::ty::TyCtxt;\n use syntax::ast::Attribute;\n+use syntax::symbol::sym;\n \n pub fn test_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     if tcx.features().rustc_attrs {\n@@ -32,7 +33,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n \n         if let ItemKind::Ty(..) = item.node {\n             for attr in self.tcx.get_attrs(item_def_id).iter() {\n-                if attr.check_name(\"rustc_layout\") {\n+                if attr.check_name(sym::rustc_layout) {\n                     self.dump_layout_of(item_def_id, item, attr);\n                 }\n             }\n@@ -54,26 +55,26 @@ impl<'a, 'tcx> VarianceTest<'a, 'tcx> {\n                 // The `..` are the names of fields to dump.\n                 let meta_items = attr.meta_item_list().unwrap_or_default();\n                 for meta_item in meta_items {\n-                    match meta_item.name_or_empty().get() {\n-                        \"abi\" => {\n+                    match meta_item.name_or_empty() {\n+                        sym::abi => {\n                             self.tcx\n                                 .sess\n                                 .span_err(item.span, &format!(\"abi: {:?}\", ty_layout.abi));\n                         }\n \n-                        \"align\" => {\n+                        sym::align => {\n                             self.tcx\n                                 .sess\n                                 .span_err(item.span, &format!(\"align: {:?}\", ty_layout.align));\n                         }\n \n-                        \"size\" => {\n+                        sym::size => {\n                             self.tcx\n                                 .sess\n                                 .span_err(item.span, &format!(\"size: {:?}\", ty_layout.size));\n                         }\n \n-                        \"homogeneous_aggregate\" => {\n+                        sym::homogeneous_aggregate => {\n                             self.tcx.sess.span_err(\n                                 item.span,\n                                 &format!("}, {"sha": "37917aaa4a80f4c2c7b39adcf6a2edee2319d60f", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -25,6 +25,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::util::nodemap::{ItemLocalSet, HirIdSet};\n use rustc::hir;\n+use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n use log::debug;\n use Promotability::*;\n@@ -335,7 +336,7 @@ fn check_expr_kind<'a, 'tcx>(\n \n                     if v.in_static {\n                         for attr in &v.tcx.get_attrs(did)[..] {\n-                            if attr.check_name(\"thread_local\") {\n+                            if attr.check_name(sym::thread_local) {\n                                 debug!(\"Reference to Static(id={:?}) is unpromotable \\\n                                        due to a #[thread_local] attribute\", did);\n                                 return NotPromotable;"}, {"sha": "8259419c64aeb17d67baed9a87ce70d6e243b374", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -1,6 +1,7 @@\n //! Used by `rustc` when compiling a plugin crate.\n \n use syntax::attr;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir;\n@@ -15,8 +16,7 @@ struct RegistrarFinder {\n impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemKind::Fn(..) = item.node {\n-            if attr::contains_name(&item.attrs,\n-                                   \"plugin_registrar\") {\n+            if attr::contains_name(&item.attrs, sym::plugin_registrar) {\n                 self.registrars.push((item.hir_id, item.span));\n             }\n         }"}, {"sha": "680bdcc4bbe9763f687b3c97685198f8705500ff", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -11,6 +11,7 @@ use std::mem;\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::span_err;\n+use syntax::symbol::{Symbol, keywords, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n /// Pointer to a registrar function.\n@@ -45,7 +46,7 @@ pub fn load_plugins(sess: &Session,\n     // the feature enabled will result in an error later...\n     if sess.features_untracked().plugin {\n         for attr in &krate.attrs {\n-            if !attr.check_name(\"plugin\") {\n+            if !attr.check_name(sym::plugin) {\n                 continue;\n             }\n \n@@ -57,9 +58,9 @@ pub fn load_plugins(sess: &Session,\n             for plugin in plugins {\n                 // plugins must have a name and can't be key = value\n                 let name = plugin.name_or_empty();\n-                if !name.is_empty() && !plugin.is_value_str() {\n+                if name != keywords::Invalid.name() && !plugin.is_value_str() {\n                     let args = plugin.meta_item_list().map(ToOwned::to_owned);\n-                    loader.load_plugin(plugin.span(), &name, args.unwrap_or_default());\n+                    loader.load_plugin(plugin.span(), name, args.unwrap_or_default());\n                 } else {\n                     call_malformed_plugin_attribute(sess, attr.span);\n                 }\n@@ -69,7 +70,7 @@ pub fn load_plugins(sess: &Session,\n \n     if let Some(plugins) = addl_plugins {\n         for plugin in plugins {\n-            loader.load_plugin(DUMMY_SP, &plugin, vec![]);\n+            loader.load_plugin(DUMMY_SP, Symbol::intern(&plugin), vec![]);\n         }\n     }\n \n@@ -85,7 +86,7 @@ impl<'a> PluginLoader<'a> {\n         }\n     }\n \n-    fn load_plugin(&mut self, span: Span, name: &str, args: Vec<ast::NestedMetaItem>) {\n+    fn load_plugin(&mut self, span: Span, name: Symbol, args: Vec<ast::NestedMetaItem>) {\n         let registrar = self.reader.find_plugin_registrar(span, name);\n \n         if let Some((lib, disambiguator)) = registrar {"}, {"sha": "c2d1d5fa65af299b242b708009a9d0f0878499c8", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -7,7 +7,7 @@ use rustc::util::nodemap::FxHashMap;\n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT, IdentTT};\n use syntax::ext::base::MacroExpanderFn;\n use syntax::ext::hygiene;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n use syntax_pos::Span;\n@@ -49,7 +49,7 @@ pub struct Registry<'a> {\n     pub llvm_passes: Vec<String>,\n \n     #[doc(hidden)]\n-    pub attributes: Vec<(String, AttributeType)>,\n+    pub attributes: Vec<(Symbol, AttributeType)>,\n }\n \n impl<'a> Registry<'a> {\n@@ -86,7 +86,7 @@ impl<'a> Registry<'a> {\n     ///\n     /// This is the most general hook into `libsyntax`'s expansion behavior.\n     pub fn register_syntax_extension(&mut self, name: ast::Name, extension: SyntaxExtension) {\n-        if name == \"macro_rules\" {\n+        if name == sym::macro_rules {\n             panic!(\"user-defined macros may not be named `macro_rules`\");\n         }\n         self.syntax_exts.push((name, match extension {\n@@ -169,7 +169,7 @@ impl<'a> Registry<'a> {\n     /// Registered attributes will bypass the `custom_attribute` feature gate.\n     /// `Whitelisted` attributes will additionally not trigger the `unused_attribute`\n     /// lint. `CrateLevel` attributes will not be allowed on anything other than a crate.\n-    pub fn register_attribute(&mut self, name: String, ty: AttributeType) {\n+    pub fn register_attribute(&mut self, name: Symbol, ty: AttributeType) {\n         self.attributes.push((name, ty));\n     }\n }"}, {"sha": "cd21713cddf97364da7657f09c16a375b416f452", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -27,7 +27,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::Ident;\n use syntax::attr;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax_pos::Span;\n \n use std::{cmp, fmt, mem};\n@@ -260,7 +260,8 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                                 ctor_vis = ty::Visibility::Restricted(\n                                     DefId::local(CRATE_DEF_INDEX));\n                                 let attrs = tcx.get_attrs(variant.def_id);\n-                                span = attr::find_by_name(&attrs, \"non_exhaustive\").unwrap().span;\n+                                span = attr::find_by_name(&attrs, sym::non_exhaustive)\n+                                    .unwrap().span;\n                                 descr = \"crate-visible\";\n                             }\n \n@@ -291,7 +292,7 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                                 if adt_def.non_enum_variant().is_field_list_non_exhaustive() {\n                                     ctor_vis =\n                                         ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-                                    span = attr::find_by_name(&item.attrs, \"non_exhaustive\")\n+                                    span = attr::find_by_name(&item.attrs, sym::non_exhaustive)\n                                                 .unwrap().span;\n                                     descr = \"crate-visible\";\n                                 }"}, {"sha": "f70ca6f859b98b71a41ae308681d300f273079a6", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -37,7 +37,7 @@ use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n use syntax::span_err;\n use syntax::std_inject::injected_crate_name;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -257,7 +257,7 @@ impl<'a> Resolver<'a> {\n             }\n             ast::UseTreeKind::Glob => {\n                 let subclass = GlobImport {\n-                    is_prelude: attr::contains_name(&item.attrs, \"prelude_import\"),\n+                    is_prelude: attr::contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(ty::Visibility::Invisible),\n                 };\n                 self.add_import_directive(\n@@ -369,7 +369,7 @@ impl<'a> Resolver<'a> {\n                 };\n \n                 self.populate_module_if_necessary(module);\n-                if injected_crate_name().map_or(false, |name| ident.name == name) {\n+                if injected_crate_name().map_or(false, |name| ident.name.as_str() == name) {\n                     self.injected_crate = Some(module);\n                 }\n \n@@ -427,7 +427,7 @@ impl<'a> Resolver<'a> {\n                 let module_kind = ModuleKind::Def(DefKind::Mod, def_id, ident.name);\n                 let module = self.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n-                        attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n+                        attr::contains_name(&item.attrs, sym::no_implicit_prelude)\n                     },\n                     ..ModuleData::new(Some(parent), module_kind, def_id, expansion, item.span)\n                 });\n@@ -456,12 +456,12 @@ impl<'a> Resolver<'a> {\n \n                 // Functions introducing procedural macros reserve a slot\n                 // in the macro namespace as well (see #52225).\n-                if attr::contains_name(&item.attrs, \"proc_macro\") ||\n-                   attr::contains_name(&item.attrs, \"proc_macro_attribute\") {\n+                if attr::contains_name(&item.attrs, sym::proc_macro) ||\n+                   attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n                     let res = Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), res.def_id());\n                     self.define(parent, ident, MacroNS, (res, vis, sp, expansion));\n                 }\n-                if let Some(attr) = attr::find_by_name(&item.attrs, \"proc_macro_derive\") {\n+                if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n                     if let Some(trait_attr) =\n                             attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n                         if let Some(ident) = trait_attr.ident() {\n@@ -518,7 +518,7 @@ impl<'a> Resolver<'a> {\n \n                 let mut ctor_vis = vis;\n \n-                let has_non_exhaustive = attr::contains_name(&item.attrs, \"non_exhaustive\");\n+                let has_non_exhaustive = attr::contains_name(&item.attrs, sym::non_exhaustive);\n \n                 // If the structure is marked as non_exhaustive then lower the visibility\n                 // to within the crate.\n@@ -599,7 +599,7 @@ impl<'a> Resolver<'a> {\n         // If the variant is marked as non_exhaustive then lower the visibility to within the\n         // crate.\n         let mut ctor_vis = vis;\n-        let has_non_exhaustive = attr::contains_name(&variant.node.attrs, \"non_exhaustive\");\n+        let has_non_exhaustive = attr::contains_name(&variant.node.attrs, sym::non_exhaustive);\n         if has_non_exhaustive && vis == ty::Visibility::Public {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n@@ -825,7 +825,7 @@ impl<'a> Resolver<'a> {\n         let mut import_all = None;\n         let mut single_imports = Vec::new();\n         for attr in &item.attrs {\n-            if attr.check_name(\"macro_use\") {\n+            if attr.check_name(sym::macro_use) {\n                 if self.current_module.parent.is_some() {\n                     span_err!(self.session, item.span, E0468,\n                         \"an `extern crate` loading macros must be at the crate root\");\n@@ -908,15 +908,15 @@ impl<'a> Resolver<'a> {\n     /// Returns `true` if this attribute list contains `macro_use`.\n     fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n         for attr in attrs {\n-            if attr.check_name(\"macro_escape\") {\n+            if attr.check_name(sym::macro_escape) {\n                 let msg = \"macro_escape is a deprecated synonym for macro_use\";\n                 let mut err = self.session.struct_span_warn(attr.span, msg);\n                 if let ast::AttrStyle::Inner = attr.style {\n                     err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n                 } else {\n                     err.emit();\n                 }\n-            } else if !attr.check_name(\"macro_use\") {\n+            } else if !attr.check_name(sym::macro_use) {\n                 continue;\n             }\n "}, {"sha": "678f4c23d3e9ebf8e6ca9622df91b0d6d957774a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -43,7 +43,7 @@ use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::base::MacroKind;\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::{Symbol, keywords, sym};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use syntax::visit::{self, FnKind, Visitor};\n@@ -1812,8 +1812,8 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n-        crate_root: Option<&str>,\n-        components: &[&str],\n+        crate_root: Option<Symbol>,\n+        components: &[Symbol],\n         is_value: bool\n     ) -> hir::Path {\n         let root = if crate_root.is_some() {\n@@ -1825,7 +1825,7 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n             .chain(\n                 crate_root.into_iter()\n                     .chain(components.iter().cloned())\n-                    .map(Ident::from_str)\n+                    .map(Ident::with_empty_ctxt)\n             ).map(|i| self.new_ast_path_segment(i)).collect::<Vec<_>>();\n \n \n@@ -1964,7 +1964,7 @@ impl<'a> Resolver<'a> {\n             keywords::Invalid.name(),\n         );\n         let graph_root = arenas.alloc_module(ModuleData {\n-            no_implicit_prelude: attr::contains_name(&krate.attrs, \"no_implicit_prelude\"),\n+            no_implicit_prelude: attr::contains_name(&krate.attrs, sym::no_implicit_prelude),\n             ..ModuleData::new(None, root_module_kind, root_def_id, Mark::root(), krate.span)\n         });\n         let mut module_map = FxHashMap::default();\n@@ -1978,9 +1978,9 @@ impl<'a> Resolver<'a> {\n             session.opts.externs.iter().map(|kv| (Ident::from_str(kv.0), Default::default()))\n                                        .collect();\n \n-        if !attr::contains_name(&krate.attrs, \"no_core\") {\n+        if !attr::contains_name(&krate.attrs, sym::no_core) {\n             extern_prelude.insert(Ident::from_str(\"core\"), Default::default());\n-            if !attr::contains_name(&krate.attrs, \"no_std\") {\n+            if !attr::contains_name(&krate.attrs, sym::no_std) {\n                 extern_prelude.insert(Ident::from_str(\"std\"), Default::default());\n                 if session.rust_2018() {\n                     extern_prelude.insert(Ident::from_str(\"meta\"), Default::default());"}, {"sha": "9f3e1c308f6379e9c591b7530381098459057b0a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -22,7 +22,7 @@ use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{\n     feature_err, is_builtin_attr_name, AttributeGate, GateIssue, Stability, BUILTIN_ATTRIBUTES,\n };\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::{Symbol, keywords, sym};\n use syntax::visit::Visitor;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -313,7 +313,8 @@ impl<'a> Resolver<'a> {\n                             if !features.rustc_attrs {\n                                 let msg = \"unless otherwise specified, attributes with the prefix \\\n                                            `rustc_` are reserved for internal compiler diagnostics\";\n-                                self.report_unknown_attribute(path.span, &name, msg, \"rustc_attrs\");\n+                                self.report_unknown_attribute(path.span, &name, msg,\n+                                                              sym::rustc_attrs);\n                             }\n                         } else if !features.custom_attribute {\n                             let msg = format!(\"The attribute `{}` is currently unknown to the \\\n@@ -323,7 +324,7 @@ impl<'a> Resolver<'a> {\n                                 path.span,\n                                 &name,\n                                 &msg,\n-                                \"custom_attribute\",\n+                                sym::custom_attribute,\n                             );\n                         }\n                     }\n@@ -345,7 +346,7 @@ impl<'a> Resolver<'a> {\n         Ok((res, self.get_macro(res)))\n     }\n \n-    fn report_unknown_attribute(&self, span: Span, name: &str, msg: &str, feature: &str) {\n+    fn report_unknown_attribute(&self, span: Span, name: &str, msg: &str, feature: Symbol) {\n         let mut err = feature_err(\n             &self.session.parse_sess,\n             feature,\n@@ -693,7 +694,7 @@ impl<'a> Resolver<'a> {\n                 WhereToResolve::LegacyPluginHelpers => {\n                     if (use_prelude || rust_2015) &&\n                        self.session.plugin_attributes.borrow().iter()\n-                                                     .any(|(name, _)| ident.name == &**name) {\n+                                                     .any(|(name, _)| ident.name == *name) {\n                         let binding = (Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n                                        ty::Visibility::Public, DUMMY_SP, Mark::root())\n                                        .to_name_binding(self.arenas);\n@@ -981,7 +982,7 @@ impl<'a> Resolver<'a> {\n                     let msg =\n                         format!(\"cannot find {} `{}{}` in this scope\", kind.descr(), ident, bang);\n                     let mut err = self.session.struct_span_err(ident.span, &msg);\n-                    self.suggest_macro_name(&ident.as_str(), kind, &mut err, ident.span);\n+                    self.suggest_macro_name(ident.name, kind, &mut err, ident.span);\n                     err.emit();\n                 }\n             }\n@@ -1009,11 +1010,12 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn suggest_macro_name(&mut self, name: &str, kind: MacroKind,\n+    fn suggest_macro_name(&mut self, name: Symbol, kind: MacroKind,\n                           err: &mut DiagnosticBuilder<'a>, span: Span) {\n         // First check if this is a locally-defined bang macro.\n         let suggestion = if let MacroKind::Bang = kind {\n-            find_best_match_for_name(self.macro_names.iter().map(|ident| &ident.name), name, None)\n+            find_best_match_for_name(\n+                self.macro_names.iter().map(|ident| &ident.name), &name.as_str(), None)\n         } else {\n             None\n         // Then check global macros.\n@@ -1022,7 +1024,7 @@ impl<'a> Resolver<'a> {\n                                                   .filter_map(|(name, binding)| {\n                 if binding.macro_kind() == Some(kind) { Some(name) } else { None }\n             });\n-            find_best_match_for_name(names, name, None)\n+            find_best_match_for_name(names, &name.as_str(), None)\n         // Then check modules.\n         }).or_else(|| {\n             let is_macro = |res| {\n@@ -1032,7 +1034,7 @@ impl<'a> Resolver<'a> {\n                     false\n                 }\n             };\n-            let ident = Ident::new(Symbol::intern(name), span);\n+            let ident = Ident::new(name, span);\n             self.lookup_typo_candidate(&[Segment::from_ident(ident)], MacroNS, is_macro, span)\n                 .map(|suggestion| suggestion.candidate)\n         });\n@@ -1091,7 +1093,7 @@ impl<'a> Resolver<'a> {\n                         current_legacy_scope: &mut LegacyScope<'a>) {\n         self.local_macro_def_scopes.insert(item.id, self.current_module);\n         let ident = item.ident;\n-        if ident.name == \"macro_rules\" {\n+        if ident.name == sym::macro_rules {\n             self.session.span_err(item.span, \"user-defined macros may not be named `macro_rules`\");\n         }\n \n@@ -1106,7 +1108,7 @@ impl<'a> Resolver<'a> {\n             let ident = ident.modern();\n             self.macro_names.insert(ident);\n             let res = Res::Def(DefKind::Macro(MacroKind::Bang), def_id);\n-            let is_macro_export = attr::contains_name(&item.attrs, \"macro_export\");\n+            let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n             } else {\n@@ -1124,7 +1126,7 @@ impl<'a> Resolver<'a> {\n                 self.define(module, ident, MacroNS,\n                             (res, vis, item.span, expansion, IsMacroExport));\n             } else {\n-                if !attr::contains_name(&item.attrs, \"rustc_doc_only_macro\") {\n+                if !attr::contains_name(&item.attrs, sym::rustc_doc_only_macro) {\n                     self.check_reserved_macro_name(ident, MacroNS);\n                 }\n                 self.unused_macros.insert(def_id);"}, {"sha": "4058f0bce0f9544e1eceb207a647b102a080d932", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -29,7 +29,7 @@ use rustc::{bug, span_bug};\n use syntax::ast::{self, Ident, Name, NodeId, CRATE_NODE_ID};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::{struct_span_err, unwrap_or};\n use syntax_pos::{MultiSpan, Span};\n@@ -496,7 +496,8 @@ impl<'a> Resolver<'a> {\n         // Reserve some names that are not quite covered by the general check\n         // performed on `Resolver::builtin_attrs`.\n         if ns == MacroNS &&\n-           (ident.name == \"cfg\" || ident.name == \"cfg_attr\" || ident.name == \"derive\") {\n+           (ident.name == sym::cfg || ident.name == sym::cfg_attr ||\n+            ident.name == sym::derive) {\n             self.session.span_err(ident.span,\n                                   &format!(\"name `{}` is reserved in macro namespace\", ident));\n         }\n@@ -706,7 +707,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 has_errors = true;\n \n                 if let SingleImport { source, ref source_bindings, .. } = import.subclass {\n-                    if source.name == \"self\" {\n+                    if source.name == keywords::SelfLower.name() {\n                         // Silence `unresolved import` error if E0429 is already emitted\n                         if let Err(Determined) = source_bindings.value_ns.get() {\n                             continue;\n@@ -1041,7 +1042,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     let initial_res = source_bindings[ns].get().map(|initial_binding| {\n                         all_ns_err = false;\n                         if let Some(target_binding) = target_bindings[ns].get() {\n-                            if target.name == \"_\" &&\n+                            // Note that as_str() de-gensyms the Symbol\n+                            if target.name.as_str() == \"_\" &&\n                                initial_binding.is_extern_crate() && !initial_binding.is_import() {\n                                 this.record_use(ident, ns, target_binding,\n                                                 directive.module_path.is_empty());\n@@ -1392,7 +1394,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             // (e.g. implicitly injected `std`) cannot be properly encoded in metadata,\n             // so they can cause name conflict errors downstream.\n             let is_good_import = binding.is_import() && !binding.is_ambiguity() &&\n-                                 !(ident.name.is_gensymed() && ident.name != \"_\");\n+                                 // Note that as_str() de-gensyms the Symbol\n+                                 !(ident.name.is_gensymed() && ident.name.as_str() != \"_\");\n             if is_good_import || binding.is_macro_def() {\n                 let res = binding.res();\n                 if res != Res::Err {"}, {"sha": "e03da2ed608be02f02d3137dd1d9af17412ac6bb", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -879,7 +879,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let mut result = String::new();\n \n         for attr in attrs {\n-            if attr.check_name(\"doc\") {\n+            if attr.check_name(sym::doc) {\n                 if let Some(val) = attr.value_str() {\n                     if attr.is_sugared_doc {\n                         result.push_str(&strip_doc_comment_decoration(&val.as_str()));\n@@ -889,10 +889,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     result.push('\\n');\n                 } else if let Some(meta_list) = attr.meta_item_list() {\n                     meta_list.into_iter()\n-                             .filter(|it| it.check_name(\"include\"))\n+                             .filter(|it| it.check_name(sym::include))\n                              .filter_map(|it| it.meta_item_list().map(|l| l.to_owned()))\n                              .flat_map(|it| it)\n-                             .filter(|meta| meta.check_name(\"contents\"))\n+                             .filter(|meta| meta.check_name(sym::contents))\n                              .filter_map(|meta| meta.value_str())\n                              .for_each(|val| {\n                                  result.push_str(&val.as_str());\n@@ -1197,7 +1197,7 @@ fn null_id() -> rls_data::Id {\n fn lower_attributes(attrs: Vec<Attribute>, scx: &SaveContext<'_, '_>) -> Vec<rls_data::Attribute> {\n     attrs.into_iter()\n     // Only retain real attributes. Doc comments are lowered separately.\n-    .filter(|attr| attr.path != \"doc\")\n+    .filter(|attr| attr.path != sym::doc)\n     .map(|mut attr| {\n         // Remove the surrounding '#[..]' or '#![..]' of the pretty printed\n         // attribute. First normalize all inner attribute (#![..]) to outer"}, {"sha": "580b1571e52bb1dd55bc5254ecf05e87806b9e20", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -21,6 +21,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::{self, List, TyCtxt};\n use rustc::ty::subst::{Subst, InternalSubsts};\n use syntax::ast;\n+use syntax::symbol::sym;\n \n use std::iter;\n \n@@ -640,11 +641,11 @@ impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n         for attr in attrs {\n             let mut clauses = None;\n \n-            if attr.check_name(\"rustc_dump_program_clauses\") {\n+            if attr.check_name(sym::rustc_dump_program_clauses) {\n                 clauses = Some(self.tcx.program_clauses_for(def_id));\n             }\n \n-            if attr.check_name(\"rustc_dump_env_program_clauses\") {\n+            if attr.check_name(sym::rustc_dump_env_program_clauses) {\n                 let environment = self.tcx.environment(def_id);\n                 clauses = Some(self.tcx.program_clauses_for_env(environment));\n             }"}, {"sha": "caefe1242115508ddec3ef0c70499a83e6f1ea3e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -25,6 +25,7 @@ use syntax::ast;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, Span, MultiSpan};\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::FxHashMap;\n@@ -802,7 +803,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             } else {\n                 \"parenthetical notation is only stable when used with `Fn`-family traits\"\n             };\n-            emit_feature_err(&self.tcx().sess.parse_sess, \"unboxed_closures\",\n+            emit_feature_err(&self.tcx().sess.parse_sess, sym::unboxed_closures,\n                              span, GateIssue::Language, msg);\n         }\n "}, {"sha": "90b2643d165bea7f2ab6e23cfacbb56ae5a53a85", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -68,6 +68,7 @@ use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n use syntax::feature_gate;\n use syntax::ptr::P;\n+use syntax::symbol::sym;\n use syntax_pos;\n \n struct Coerce<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -620,7 +621,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         if has_unsized_tuple_coercion && !self.tcx.features().unsized_tuple_coercion {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n-                                           \"unsized_tuple_coercion\",\n+                                           sym::unsized_tuple_coercion,\n                                            self.cause.span,\n                                            feature_gate::GateIssue::Language,\n                                            feature_gate::EXPLAIN_UNSIZED_TUPLE_COERCION);"}, {"sha": "8d68179b495c6015738344919f05b2af1a07daca", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -2,6 +2,7 @@ use crate::check::FnCtxt;\n use rustc::infer::InferOk;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n \n+use syntax::symbol::sym;\n use syntax::util::parser::PREC_POSTFIX;\n use syntax_pos::Span;\n use rustc::hir;\n@@ -197,7 +198,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 //\n                 // FIXME? Other potential candidate methods: `as_ref` and\n                 // `as_mut`?\n-                .find(|a| a.check_name(\"rustc_conversion_suggestion\")).is_some()\n+                .find(|a| a.check_name(sym::rustc_conversion_suggestion)).is_some()\n         });\n \n         methods"}, {"sha": "362b6f0504d99aed306f7bba354acad944a04182", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -123,7 +123,7 @@ use syntax::attr;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::source_map::{DUMMY_SP, original_sp};\n-use syntax::symbol::{Symbol, LocalInternedString, keywords};\n+use syntax::symbol::{Symbol, LocalInternedString, keywords, sym};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use std::cell::{Cell, RefCell, Ref, RefMut};\n@@ -1840,7 +1840,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if vs.is_empty() {\n         let attributes = tcx.get_attrs(def_id);\n-        if let Some(attr) = attr::find_by_name(&attributes, \"repr\") {\n+        if let Some(attr) = attr::find_by_name(&attributes, sym::repr) {\n             struct_span_err!(\n                 tcx.sess, attr.span, E0084,\n                 \"unsupported representation for zero-variant enum\")\n@@ -1853,7 +1853,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if repr_type_ty == tcx.types.i128 || repr_type_ty == tcx.types.u128 {\n         if !tcx.features().repr128 {\n             emit_feature_err(&tcx.sess.parse_sess,\n-                             \"repr128\",\n+                             sym::repr128,\n                              sp,\n                              GateIssue::Language,\n                              \"repr with 128-bit type is unstable\");\n@@ -4197,7 +4197,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // ... except when we try to 'break rust;'.\n                         // ICE this expression in particular (see #43162).\n                         if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n-                            if path.segments.len() == 1 && path.segments[0].ident.name == \"rust\" {\n+                            if path.segments.len() == 1 &&\n+                               path.segments[0].ident.name == sym::rust {\n                                 fatally_break_rust(self.tcx.sess);\n                             }\n                         }\n@@ -5499,7 +5500,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                       span: Span) {\n         // We're only interested in functions tagged with\n         // #[rustc_args_required_const], so ignore anything that's not.\n-        if !self.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n+        if !self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n             return\n         }\n "}, {"sha": "b009c8ea6dce17a3d28b22da83ac9f2eb1fab053", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -13,6 +13,7 @@ use rustc::infer::opaque_types::may_define_existential_type;\n use syntax::ast;\n use syntax::feature_gate::{self, GateIssue};\n use syntax_pos::Span;\n+use syntax::symbol::sym;\n use errors::{DiagnosticBuilder, DiagnosticId};\n \n use rustc::hir::itemlikevisit::ParItemLikeVisitor;\n@@ -796,7 +797,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                 // report error, would have worked with arbitrary_self_types\n                 feature_gate::feature_err(\n                     &fcx.tcx.sess.parse_sess,\n-                    \"arbitrary_self_types\",\n+                    sym::arbitrary_self_types,\n                     span,\n                     GateIssue::Language,\n                     &format!("}, {"sha": "ecb8e09ec2461ee918e4d6295aa84b15ae366ee1", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -16,6 +16,7 @@ use rustc::mir::interpret::ConstValue;\n use rustc::util::nodemap::DefIdSet;\n use rustc_data_structures::sync::Lrc;\n use std::mem;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -36,8 +37,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let item_def_id = self.tcx.hir().local_def_id(item_id);\n \n         // This attribute causes us to dump some writeback information\n-        // in the form of errors, which is used for unit tests.\n-        let rustc_dump_user_substs = self.tcx.has_attr(item_def_id, \"rustc_dump_user_substs\");\n+        // in the form of errors, which is uSymbolfor unit tests.\n+        let rustc_dump_user_substs = self.tcx.has_attr(item_def_id, sym::rustc_dump_user_substs);\n \n         let mut wbcx = WritebackCx::new(self, body, rustc_dump_user_substs);\n         for arg in &body.arguments {"}, {"sha": "ffba9403743a311fc9a45c7b8c1a6217b45bd062", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -39,7 +39,7 @@ use syntax::ast::{Ident, MetaItemKind};\n use syntax::attr::{InlineAttr, OptimizeAttr, list_contains_name, mark_used};\n use syntax::source_map::Spanned;\n use syntax::feature_gate;\n-use syntax::symbol::{keywords, Symbol};\n+use syntax::symbol::{keywords, Symbol, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir::def::{CtorKind, Res, DefKind};\n@@ -750,7 +750,7 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::\n         _ => span_bug!(item.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n \n-    let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n+    let paren_sugar = tcx.has_attr(def_id, sym::rustc_paren_sugar);\n     if paren_sugar && !tcx.features().unboxed_closures {\n         let mut err = tcx.sess.struct_span_err(\n             item.span,\n@@ -765,7 +765,7 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::\n         err.emit();\n     }\n \n-    let is_marker = tcx.has_attr(def_id, \"marker\");\n+    let is_marker = tcx.has_attr(def_id, sym::marker);\n     let def_path_hash = tcx.def_path_hash(def_id);\n     let def = ty::TraitDef::new(def_id, unsafety, paren_sugar, is_auto, is_marker, def_path_hash);\n     tcx.alloc_trait_def(def)\n@@ -2382,7 +2382,7 @@ fn from_target_feature(\n     tcx: TyCtxt<'_, '_, '_>,\n     id: DefId,\n     attr: &ast::Attribute,\n-    whitelist: &FxHashMap<String, Option<String>>,\n+    whitelist: &FxHashMap<String, Option<Symbol>>,\n     target_features: &mut Vec<Symbol>,\n ) {\n     let list = match attr.meta_item_list() {\n@@ -2392,7 +2392,7 @@ fn from_target_feature(\n     let rust_features = tcx.features();\n     for item in list {\n         // Only `enable = ...` is accepted in the meta item list\n-        if !item.check_name(\"enable\") {\n+        if !item.check_name(sym::enable) {\n             let msg = \"#[target_feature(..)] only accepts sub-keys of `enable` \\\n                        currently\";\n             tcx.sess.span_err(item.span(), &msg);\n@@ -2435,29 +2435,29 @@ fn from_target_feature(\n             };\n \n             // Only allow features whose feature gates have been enabled\n-            let allowed = match feature_gate.as_ref().map(|s| &**s) {\n-                Some(\"arm_target_feature\") => rust_features.arm_target_feature,\n-                Some(\"aarch64_target_feature\") => rust_features.aarch64_target_feature,\n-                Some(\"hexagon_target_feature\") => rust_features.hexagon_target_feature,\n-                Some(\"powerpc_target_feature\") => rust_features.powerpc_target_feature,\n-                Some(\"mips_target_feature\") => rust_features.mips_target_feature,\n-                Some(\"avx512_target_feature\") => rust_features.avx512_target_feature,\n-                Some(\"mmx_target_feature\") => rust_features.mmx_target_feature,\n-                Some(\"sse4a_target_feature\") => rust_features.sse4a_target_feature,\n-                Some(\"tbm_target_feature\") => rust_features.tbm_target_feature,\n-                Some(\"wasm_target_feature\") => rust_features.wasm_target_feature,\n-                Some(\"cmpxchg16b_target_feature\") => rust_features.cmpxchg16b_target_feature,\n-                Some(\"adx_target_feature\") => rust_features.adx_target_feature,\n-                Some(\"movbe_target_feature\") => rust_features.movbe_target_feature,\n-                Some(\"rtm_target_feature\") => rust_features.rtm_target_feature,\n-                Some(\"f16c_target_feature\") => rust_features.f16c_target_feature,\n+            let allowed = match feature_gate.as_ref().map(|s| *s) {\n+                Some(sym::arm_target_feature) => rust_features.arm_target_feature,\n+                Some(sym::aarch64_target_feature) => rust_features.aarch64_target_feature,\n+                Some(sym::hexagon_target_feature) => rust_features.hexagon_target_feature,\n+                Some(sym::powerpc_target_feature) => rust_features.powerpc_target_feature,\n+                Some(sym::mips_target_feature) => rust_features.mips_target_feature,\n+                Some(sym::avx512_target_feature) => rust_features.avx512_target_feature,\n+                Some(sym::mmx_target_feature) => rust_features.mmx_target_feature,\n+                Some(sym::sse4a_target_feature) => rust_features.sse4a_target_feature,\n+                Some(sym::tbm_target_feature) => rust_features.tbm_target_feature,\n+                Some(sym::wasm_target_feature) => rust_features.wasm_target_feature,\n+                Some(sym::cmpxchg16b_target_feature) => rust_features.cmpxchg16b_target_feature,\n+                Some(sym::adx_target_feature) => rust_features.adx_target_feature,\n+                Some(sym::movbe_target_feature) => rust_features.movbe_target_feature,\n+                Some(sym::rtm_target_feature) => rust_features.rtm_target_feature,\n+                Some(sym::f16c_target_feature) => rust_features.f16c_target_feature,\n                 Some(name) => bug!(\"unknown target feature gate {}\", name),\n                 None => true,\n             };\n             if !allowed && id.is_local() {\n                 feature_gate::emit_feature_err(\n                     &tcx.sess.parse_sess,\n-                    feature_gate.as_ref().unwrap(),\n+                    feature_gate.unwrap(),\n                     item.span(),\n                     feature_gate::GateIssue::Language,\n                     &format!(\"the target feature `{}` is currently unstable\", feature),\n@@ -2512,13 +2512,13 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n \n     let mut inline_span = None;\n     for attr in attrs.iter() {\n-        if attr.check_name(\"cold\") {\n+        if attr.check_name(sym::cold) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n-        } else if attr.check_name(\"allocator\") {\n+        } else if attr.check_name(sym::allocator) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n-        } else if attr.check_name(\"unwind\") {\n+        } else if attr.check_name(sym::unwind) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::UNWIND;\n-        } else if attr.check_name(\"ffi_returns_twice\") {\n+        } else if attr.check_name(sym::ffi_returns_twice) {\n             if tcx.is_foreign_item(id) {\n                 codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n             } else {\n@@ -2530,21 +2530,21 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                     \"`#[ffi_returns_twice]` may only be used on foreign functions\"\n                 ).emit();\n             }\n-        } else if attr.check_name(\"rustc_allocator_nounwind\") {\n+        } else if attr.check_name(sym::rustc_allocator_nounwind) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND;\n-        } else if attr.check_name(\"naked\") {\n+        } else if attr.check_name(sym::naked) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n-        } else if attr.check_name(\"no_mangle\") {\n+        } else if attr.check_name(sym::no_mangle) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n-        } else if attr.check_name(\"rustc_std_internal_symbol\") {\n+        } else if attr.check_name(sym::rustc_std_internal_symbol) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n-        } else if attr.check_name(\"no_debug\") {\n+        } else if attr.check_name(sym::no_debug) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_DEBUG;\n-        } else if attr.check_name(\"used\") {\n+        } else if attr.check_name(sym::used) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n-        } else if attr.check_name(\"thread_local\") {\n+        } else if attr.check_name(sym::thread_local) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n-        } else if attr.check_name(\"export_name\") {\n+        } else if attr.check_name(sym::export_name) {\n             if let Some(s) = attr.value_str() {\n                 if s.as_str().contains(\"\\0\") {\n                     // `#[export_name = ...]` will be converted to a null-terminated string,\n@@ -2558,7 +2558,7 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                 }\n                 codegen_fn_attrs.export_name = Some(s);\n             }\n-        } else if attr.check_name(\"target_feature\") {\n+        } else if attr.check_name(sym::target_feature) {\n             if tcx.fn_sig(id).unsafety() == Unsafety::Normal {\n                 let msg = \"#[target_feature(..)] can only be applied to \\\n                            `unsafe` function\";\n@@ -2571,11 +2571,11 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                 &whitelist,\n                 &mut codegen_fn_attrs.target_features,\n             );\n-        } else if attr.check_name(\"linkage\") {\n+        } else if attr.check_name(sym::linkage) {\n             if let Some(val) = attr.value_str() {\n                 codegen_fn_attrs.linkage = Some(linkage_by_name(tcx, id, &val.as_str()));\n             }\n-        } else if attr.check_name(\"link_section\") {\n+        } else if attr.check_name(sym::link_section) {\n             if let Some(val) = attr.value_str() {\n                 if val.as_str().bytes().any(|b| b == 0) {\n                     let msg = format!(\n@@ -2588,13 +2588,13 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                     codegen_fn_attrs.link_section = Some(val);\n                 }\n             }\n-        } else if attr.check_name(\"link_name\") {\n+        } else if attr.check_name(sym::link_name) {\n             codegen_fn_attrs.link_name = attr.value_str();\n         }\n     }\n \n     codegen_fn_attrs.inline = attrs.iter().fold(InlineAttr::None, |ia, attr| {\n-        if attr.path != \"inline\" {\n+        if attr.path != sym::inline {\n             return ia;\n         }\n         match attr.meta().map(|i| i.node) {\n@@ -2613,9 +2613,9 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                         \"expected one argument\"\n                     );\n                     InlineAttr::None\n-                } else if list_contains_name(&items[..], \"always\") {\n+                } else if list_contains_name(&items[..], sym::always) {\n                     InlineAttr::Always\n-                } else if list_contains_name(&items[..], \"never\") {\n+                } else if list_contains_name(&items[..], sym::never) {\n                     InlineAttr::Never\n                 } else {\n                     span_err!(\n@@ -2634,7 +2634,7 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n     });\n \n     codegen_fn_attrs.optimize = attrs.iter().fold(OptimizeAttr::None, |ia, attr| {\n-        if attr.path != \"optimize\" {\n+        if attr.path != sym::optimize {\n             return ia;\n         }\n         let err = |sp, s| span_err!(tcx.sess.diagnostic(), sp, E0722, \"{}\", s);\n@@ -2649,9 +2649,9 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                 if items.len() != 1 {\n                     err(attr.span, \"expected one argument\");\n                     OptimizeAttr::None\n-                } else if list_contains_name(&items[..], \"size\") {\n+                } else if list_contains_name(&items[..], sym::size) {\n                     OptimizeAttr::Size\n-                } else if list_contains_name(&items[..], \"speed\") {\n+                } else if list_contains_name(&items[..], sym::speed) {\n                     OptimizeAttr::Speed\n                 } else {\n                     err(items[0].span(), \"invalid argument\");"}, {"sha": "a6b5b99982ec6b5ba8a4cb72b36446268a17999c", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -5,6 +5,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::subst::UnpackedKind;\n use rustc::ty::{self, CratePredicatesMap, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n+use syntax::symbol::sym;\n \n mod explicit;\n mod implicit_infer;\n@@ -40,7 +41,7 @@ fn inferred_outlives_of<'a, 'tcx>(\n                     .map(|p| *p)\n                     .unwrap_or(&[]);\n \n-                if tcx.has_attr(item_def_id, \"rustc_outlives\") {\n+                if tcx.has_attr(item_def_id, sym::rustc_outlives) {\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n                         .map(|out_pred| match out_pred {"}, {"sha": "54fd4fad1d1956c95284e8a2a5287f8c2c8008ac", "filename": "src/librustc_typeck/outlives/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -1,6 +1,7 @@\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::TyCtxt;\n+use syntax::symbol::sym;\n \n pub fn test_inferred_outlives<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.hir()\n@@ -18,7 +19,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for OutlivesTest<'a, 'tcx> {\n \n         // For unit testing: check for a special \"rustc_outlives\"\n         // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item_def_id, \"rustc_outlives\") {\n+        if self.tcx.has_attr(item_def_id, sym::rustc_outlives) {\n             let inferred_outlives_of = self.tcx.inferred_outlives_of(item_def_id);\n             span_err!(\n                 self.tcx.sess,"}, {"sha": "b5195826b8631a4a6278660107442ff309c14590", "filename": "src/librustc_typeck/variance/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -1,6 +1,7 @@\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::TyCtxt;\n+use syntax::symbol::sym;\n \n pub fn test_variance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.hir().krate().visit_all_item_likes(&mut VarianceTest { tcx });\n@@ -16,7 +17,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n \n         // For unit testing: check for a special \"rustc_variance\"\n         // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item_def_id, \"rustc_variance\") {\n+        if self.tcx.has_attr(item_def_id, sym::rustc_variance) {\n             let variances_of = self.tcx.variances_of(item_def_id);\n             span_err!(self.tcx.sess,\n                       item.span,"}, {"sha": "c795b2dcd7a4385f9ba0ff2afccf292afef6869a", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -7,7 +7,7 @@ use std::mem;\n use std::fmt::{self, Write};\n use std::ops;\n \n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::ast::{MetaItem, MetaItemKind, NestedMetaItem, LitKind};\n use syntax::parse::ParseSess;\n use syntax::feature_gate::Features;\n@@ -186,7 +186,7 @@ impl Cfg {\n \n     fn should_use_with_in_description(&self) -> bool {\n         match *self {\n-            Cfg::Cfg(ref name, _) if name == &\"target_feature\" => true,\n+            Cfg::Cfg(name, _) if name == sym::target_feature => true,\n             _ => false,\n         }\n     }"}, {"sha": "15108a7dbb91c392836ea59e926961ce55f79721", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -4,6 +4,7 @@ use std::iter::once;\n \n use syntax::ast;\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n use rustc::hir;\n@@ -186,7 +187,7 @@ pub fn build_external_trait(cx: &DocContext<'_>, did: DefId) -> clean::Trait {\n     let generics = (cx.tcx.generics_of(did), &predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n-    let is_spotlight = load_attrs(cx, did).has_doc_flag(\"spotlight\");\n+    let is_spotlight = load_attrs(cx, did).has_doc_flag(sym::spotlight);\n     let is_auto = cx.tcx.trait_is_auto(did);\n     clean::Trait {\n         auto: auto_trait,"}, {"sha": "f9a43ccfbace182f71b5e5f9dd824338d17f986a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -32,6 +32,7 @@ use syntax::ext::base::MacroKind;\n use syntax::source_map::{dummy_spanned, Spanned};\n use syntax::ptr::P;\n use syntax::symbol::keywords::{self, Keyword};\n+use syntax::symbol::{Symbol, sym};\n use syntax::symbol::InternedString;\n use syntax_pos::{self, Pos, FileName};\n \n@@ -170,7 +171,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                     // `compiler_builtins` should be masked too, but we can't apply\n                     // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n                     if it.is_extern_crate()\n-                        && (it.attrs.has_doc_flag(\"masked\")\n+                        && (it.attrs.has_doc_flag(sym::masked)\n                             || self.cx.tcx.is_compiler_builtins(it.def_id.krate))\n                     {\n                         masked_crates.insert(it.def_id.krate);\n@@ -261,9 +262,9 @@ impl Clean<ExternalCrate> for CrateNum {\n             if let Res::Def(DefKind::Mod, def_id) = res {\n                 let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n                 let mut prim = None;\n-                for attr in attrs.lists(\"doc\") {\n+                for attr in attrs.lists(sym::doc) {\n                     if let Some(v) = attr.value_str() {\n-                        if attr.check_name(\"primitive\") {\n+                        if attr.check_name(sym::primitive) {\n                             prim = PrimitiveType::from_str(&v.as_str());\n                             if prim.is_some() {\n                                 break;\n@@ -305,9 +306,9 @@ impl Clean<ExternalCrate> for CrateNum {\n             if let Res::Def(DefKind::Mod, def_id) = res {\n                 let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n                 let mut keyword = None;\n-                for attr in attrs.lists(\"doc\") {\n+                for attr in attrs.lists(sym::doc) {\n                     if let Some(v) = attr.value_str() {\n-                        if attr.check_name(\"keyword\") {\n+                        if attr.check_name(sym::keyword) {\n                             keyword = Keyword::from_str(&v.as_str()).ok()\n                                                                     .map(|x| x.name().to_string());\n                             if keyword.is_some() {\n@@ -501,7 +502,7 @@ impl Item {\n \n     pub fn is_non_exhaustive(&self) -> bool {\n         self.attrs.other_attrs.iter()\n-            .any(|a| a.check_name(\"non_exhaustive\"))\n+            .any(|a| a.check_name(sym::non_exhaustive))\n     }\n \n     /// Returns a documentation-level item type from the item.\n@@ -669,7 +670,7 @@ impl Clean<Item> for doctree::Module {\n pub struct ListAttributesIter<'a> {\n     attrs: slice::Iter<'a, ast::Attribute>,\n     current_list: vec::IntoIter<ast::NestedMetaItem>,\n-    name: &'a str\n+    name: Symbol,\n }\n \n impl<'a> Iterator for ListAttributesIter<'a> {\n@@ -702,11 +703,11 @@ impl<'a> Iterator for ListAttributesIter<'a> {\n \n pub trait AttributesExt {\n     /// Finds an attribute as List and returns the list of attributes nested inside.\n-    fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a>;\n+    fn lists<'a>(&'a self, name: Symbol) -> ListAttributesIter<'a>;\n }\n \n impl AttributesExt for [ast::Attribute] {\n-    fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a> {\n+    fn lists<'a>(&'a self, name: Symbol) -> ListAttributesIter<'a> {\n         ListAttributesIter {\n             attrs: self.iter(),\n             current_list: Vec::new().into_iter(),\n@@ -717,11 +718,11 @@ impl AttributesExt for [ast::Attribute] {\n \n pub trait NestedAttributesExt {\n     /// Returns `true` if the attribute list contains a specific `Word`\n-    fn has_word(self, word: &str) -> bool;\n+    fn has_word(self, word: Symbol) -> bool;\n }\n \n impl<I: IntoIterator<Item=ast::NestedMetaItem>> NestedAttributesExt for I {\n-    fn has_word(self, word: &str) -> bool {\n+    fn has_word(self, word: Symbol) -> bool {\n         self.into_iter().any(|attr| attr.is_word() && attr.check_name(word))\n     }\n }\n@@ -803,7 +804,7 @@ impl Attributes {\n         if let ast::MetaItemKind::List(ref nmis) = mi.node {\n             if nmis.len() == 1 {\n                 if let MetaItem(ref cfg_mi) = nmis[0] {\n-                    if cfg_mi.check_name(\"cfg\") {\n+                    if cfg_mi.check_name(sym::cfg) {\n                         if let ast::MetaItemKind::List(ref cfg_nmis) = cfg_mi.node {\n                             if cfg_nmis.len() == 1 {\n                                 if let MetaItem(ref content_mi) = cfg_nmis[0] {\n@@ -827,7 +828,7 @@ impl Attributes {\n     {\n         mi.meta_item_list().and_then(|list| {\n             for meta in list {\n-                if meta.check_name(\"include\") {\n+                if meta.check_name(sym::include) {\n                     // the actual compiled `#[doc(include=\"filename\")]` gets expanded to\n                     // `#[doc(include(file=\"filename\", contents=\"file contents\")]` so we need to\n                     // look for that instead\n@@ -836,11 +837,11 @@ impl Attributes {\n                         let mut contents: Option<String> = None;\n \n                         for it in list {\n-                            if it.check_name(\"file\") {\n+                            if it.check_name(sym::file) {\n                                 if let Some(name) = it.value_str() {\n                                     filename = Some(name.to_string());\n                                 }\n-                            } else if it.check_name(\"contents\") {\n+                            } else if it.check_name(sym::contents) {\n                                 if let Some(docs) = it.value_str() {\n                                     contents = Some(docs.to_string());\n                                 }\n@@ -860,9 +861,9 @@ impl Attributes {\n         })\n     }\n \n-    pub fn has_doc_flag(&self, flag: &str) -> bool {\n+    pub fn has_doc_flag(&self, flag: Symbol) -> bool {\n         for attr in &self.other_attrs {\n-            if !attr.check_name(\"doc\") { continue; }\n+            if !attr.check_name(sym::doc) { continue; }\n \n             if let Some(items) = attr.meta_item_list() {\n                 if items.iter().filter_map(|i| i.meta_item()).any(|it| it.check_name(flag)) {\n@@ -883,7 +884,7 @@ impl Attributes {\n \n         let other_attrs = attrs.iter().filter_map(|attr| {\n             attr.with_desugared_doc(|attr| {\n-                if attr.check_name(\"doc\") {\n+                if attr.check_name(sym::doc) {\n                     if let Some(mi) = attr.meta() {\n                         if let Some(value) = mi.value_str() {\n                             // Extracted #[doc = \"...\"]\n@@ -925,8 +926,8 @@ impl Attributes {\n \n         // treat #[target_feature(enable = \"feat\")] attributes as if they were\n         // #[doc(cfg(target_feature = \"feat\"))] attributes as well\n-        for attr in attrs.lists(\"target_feature\") {\n-            if attr.check_name(\"enable\") {\n+        for attr in attrs.lists(sym::target_feature) {\n+            if attr.check_name(sym::enable) {\n                 if let Some(feat) = attr.value_str() {\n                     let meta = attr::mk_name_value_item_str(Ident::from_str(\"target_feature\"),\n                                                             dummy_spanned(feat));\n@@ -938,7 +939,7 @@ impl Attributes {\n         }\n \n         let inner_docs = attrs.iter()\n-                              .filter(|a| a.check_name(\"doc\"))\n+                              .filter(|a| a.check_name(sym::doc))\n                               .next()\n                               .map_or(true, |a| a.style == AttrStyle::Inner);\n \n@@ -1039,7 +1040,7 @@ impl Hash for Attributes {\n }\n \n impl AttributesExt for Attributes {\n-    fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a> {\n+    fn lists<'a>(&'a self, name: Symbol) -> ListAttributesIter<'a> {\n         self.other_attrs.lists(name)\n     }\n }\n@@ -2133,7 +2134,7 @@ pub struct Trait {\n impl Clean<Item> for doctree::Trait {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n-        let is_spotlight = attrs.has_doc_flag(\"spotlight\");\n+        let is_spotlight = attrs.has_doc_flag(sym::spotlight);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: attrs,\n@@ -3893,8 +3894,8 @@ impl Clean<Vec<Item>> for doctree::ExternCrate {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n \n         let please_inline = self.vis.node.is_pub() && self.attrs.iter().any(|a| {\n-            a.check_name(\"doc\") && match a.meta_item_list() {\n-                Some(l) => attr::list_contains_name(&l, \"inline\"),\n+            a.check_name(sym::doc) && match a.meta_item_list() {\n+                Some(l) => attr::list_contains_name(&l, sym::inline),\n                 None => false,\n             }\n         });\n@@ -3935,15 +3936,15 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // #[doc(no_inline)] attribute is present.\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let mut denied = !self.vis.node.is_pub() || self.attrs.iter().any(|a| {\n-            a.check_name(\"doc\") && match a.meta_item_list() {\n-                Some(l) => attr::list_contains_name(&l, \"no_inline\") ||\n-                           attr::list_contains_name(&l, \"hidden\"),\n+            a.check_name(sym::doc) && match a.meta_item_list() {\n+                Some(l) => attr::list_contains_name(&l, sym::no_inline) ||\n+                           attr::list_contains_name(&l, sym::hidden),\n                 None => false,\n             }\n         });\n         // Also check whether imports were asked to be inlined, in case we're trying to re-export a\n         // crate in Rust 2018+\n-        let please_inline = self.attrs.lists(\"doc\").has_word(\"inline\");\n+        let please_inline = self.attrs.lists(sym::doc).has_word(sym::inline);\n         let path = self.path.clean(cx);\n         let inner = if self.glob {\n             if !denied {\n@@ -4382,7 +4383,7 @@ where\n \n // Start of code copied from rust-clippy\n \n-pub fn path_to_def_local(tcx: TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n+pub fn path_to_def_local(tcx: TyCtxt<'_, '_, '_>, path: &[Symbol]) -> Option<DefId> {\n     let krate = tcx.hir().krate();\n     let mut items = krate.module.item_ids.clone();\n     let mut path_it = path.iter().peekable();\n@@ -4407,7 +4408,7 @@ pub fn path_to_def_local(tcx: TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId\n     }\n }\n \n-pub fn path_to_def(tcx: TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n+pub fn path_to_def(tcx: TyCtxt<'_, '_, '_>, path: &[Symbol]) -> Option<DefId> {\n     let crates = tcx.crates();\n \n     let krate = crates"}, {"sha": "428f4f328b907987356c418a09511b582e205c3b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -18,6 +18,7 @@ use rustc_target::spec::TargetTriple;\n use syntax::source_map;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::json::JsonEmitter;\n+use syntax::symbol::sym;\n use errors;\n use errors::emitter::{Emitter, EmitterWriter};\n use parking_lot::ReentrantMutex;\n@@ -367,9 +368,9 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             };\n \n             let send_trait = if crate_name == Some(\"core\".to_string()) {\n-                clean::path_to_def_local(tcx, &[\"marker\", \"Send\"])\n+                clean::path_to_def_local(tcx, &[sym::marker, sym::Send])\n             } else {\n-                clean::path_to_def(tcx, &[\"core\", \"marker\", \"Send\"])\n+                clean::path_to_def(tcx, &[sym::core, sym::marker, sym::Send])\n             };\n \n             let mut renderinfo = RenderInfo::default();\n@@ -415,24 +416,24 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n             // Process all of the crate attributes, extracting plugin metadata along\n             // with the passes which we are supposed to run.\n-            for attr in krate.module.as_ref().unwrap().attrs.lists(\"doc\") {\n+            for attr in krate.module.as_ref().unwrap().attrs.lists(sym::doc) {\n                 let diag = ctxt.sess().diagnostic();\n \n                 let name = attr.name_or_empty();\n                 if attr.is_word() {\n-                    if name == \"no_default_passes\" {\n+                    if name == sym::no_default_passes {\n                         report_deprecated_attr(\"no_default_passes\", diag);\n                         if default_passes == passes::DefaultPassOption::Default {\n                             default_passes = passes::DefaultPassOption::None;\n                         }\n                     }\n                 } else if let Some(value) = attr.value_str() {\n-                    let sink = match name.get() {\n-                        \"passes\" => {\n+                    let sink = match name {\n+                        sym::passes => {\n                             report_deprecated_attr(\"passes = \\\"...\\\"\", diag);\n                             &mut manual_passes\n                         },\n-                        \"plugins\" => {\n+                        sym::plugins => {\n                             report_deprecated_attr(\"plugins = \\\"...\\\"\", diag);\n                             eprintln!(\"WARNING: #![doc(plugins = \\\"...\\\")] no longer functions; \\\n                                       see CVE-2018-1000622\");\n@@ -445,7 +446,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                     }\n                 }\n \n-                if attr.is_word() && name == \"document_private_items\" {\n+                if attr.is_word() && name == sym::document_private_items {\n                     if default_passes == passes::DefaultPassOption::Default {\n                         default_passes = passes::DefaultPassOption::Private;\n                     }"}, {"sha": "0207fcda9e880ea6525550ae6b8f3d8a176ca0b3", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -50,6 +50,7 @@ use syntax::ast;\n use syntax::ext::base::MacroKind;\n use syntax::source_map::FileName;\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::symbol::{Symbol, sym};\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n@@ -571,24 +572,24 @@ pub fn run(mut krate: clean::Crate,\n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n     if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n-        for attr in attrs.lists(\"doc\") {\n-            match (attr.name_or_empty().get(), attr.value_str()) {\n-                (\"html_favicon_url\", Some(s)) => {\n+        for attr in attrs.lists(sym::doc) {\n+            match (attr.name_or_empty(), attr.value_str()) {\n+                (sym::html_favicon_url, Some(s)) => {\n                     scx.layout.favicon = s.to_string();\n                 }\n-                (\"html_logo_url\", Some(s)) => {\n+                (sym::html_logo_url, Some(s)) => {\n                     scx.layout.logo = s.to_string();\n                 }\n-                (\"html_playground_url\", Some(s)) => {\n+                (sym::html_playground_url, Some(s)) => {\n                     markdown::PLAYGROUND.with(|slot| {\n                         let name = krate.name.clone();\n                         *slot.borrow_mut() = Some((Some(name), s.to_string()));\n                     });\n                 }\n-                (\"issue_tracker_base_url\", Some(s)) => {\n+                (sym::issue_tracker_base_url, Some(s)) => {\n                     scx.issue_tracker_base_url = Some(s.to_string());\n                 }\n-                (\"html_no_source\", None) if attr.is_word() => {\n+                (sym::html_no_source, None) if attr.is_word() => {\n                     scx.include_sources = false;\n                 }\n                 _ => {}\n@@ -1388,8 +1389,8 @@ fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Pat\n \n     // Failing that, see if there's an attribute specifying where to find this\n     // external crate\n-    e.attrs.lists(\"doc\")\n-     .filter(|a| a.check_name(\"html_root_url\"))\n+    e.attrs.lists(sym::doc)\n+     .filter(|a| a.check_name(sym::html_root_url))\n      .filter_map(|a| a.value_str())\n      .map(|url| {\n         let mut url = url.to_string();\n@@ -1779,8 +1780,8 @@ impl<'a> Cache {\n             let path = self.paths.get(&item.def_id)\n                                  .map(|p| p.0[..p.0.len() - 1].join(\"::\"))\n                                  .unwrap_or(\"std\".to_owned());\n-            for alias in item.attrs.lists(\"doc\")\n-                                   .filter(|a| a.check_name(\"alias\"))\n+            for alias in item.attrs.lists(sym::doc)\n+                                   .filter(|a| a.check_name(sym::alias))\n                                    .filter_map(|a| a.value_str()\n                                                     .map(|s| s.to_string().replace(\"\\\"\", \"\")))\n                                    .filter(|v| !v.is_empty())\n@@ -3761,22 +3762,22 @@ fn render_attribute(attr: &ast::MetaItem) -> Option<String> {\n     }\n }\n \n-const ATTRIBUTE_WHITELIST: &'static [&'static str] = &[\n-    \"export_name\",\n-    \"lang\",\n-    \"link_section\",\n-    \"must_use\",\n-    \"no_mangle\",\n-    \"repr\",\n-    \"unsafe_destructor_blind_to_params\",\n-    \"non_exhaustive\"\n+const ATTRIBUTE_WHITELIST: &'static [Symbol] = &[\n+    sym::export_name,\n+    sym::lang,\n+    sym::link_section,\n+    sym::must_use,\n+    sym::no_mangle,\n+    sym::repr,\n+    sym::unsafe_destructor_blind_to_params,\n+    sym::non_exhaustive\n ];\n \n fn render_attributes(w: &mut dyn fmt::Write, it: &clean::Item) -> fmt::Result {\n     let mut attrs = String::new();\n \n     for attr in &it.attrs.other_attrs {\n-        if !ATTRIBUTE_WHITELIST.contains(&attr.name_or_empty().get()) {\n+        if !ATTRIBUTE_WHITELIST.contains(&attr.name_or_empty()) {\n             continue;\n         }\n         if let Some(s) = render_attribute(&attr.meta().unwrap()) {"}, {"sha": "4ee09f7096b6163a90162d7057085d80b3aa658f", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -5,6 +5,7 @@ use crate::passes::Pass;\n \n use syntax::attr;\n use syntax_pos::FileName;\n+use syntax::symbol::sym;\n \n use std::collections::BTreeMap;\n use std::ops;\n@@ -131,7 +132,7 @@ impl fold::DocFolder for CoverageCalculator {\n                 return Some(i);\n             }\n             clean::ImplItem(ref impl_)\n-                if attr::contains_name(&i.attrs.other_attrs, \"automatically_derived\")\n+                if attr::contains_name(&i.attrs.other_attrs, sym::automatically_derived)\n                     || impl_.synthetic || impl_.blanket_impl.is_some() =>\n             {\n                 // built-in derives get the `#[automatically_derived]` attribute, and"}, {"sha": "9e108e605c8bba9fc42a9f57cb2a22a519fe911d", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             // Try looking for methods and associated items.\n             let mut split = path_str.rsplitn(2, \"::\");\n             let item_name = if let Some(first) = split.next() {\n-                first\n+                Symbol::intern(first)\n             } else {\n                 return Err(())\n             };"}, {"sha": "70cd4b72199bca2f73a97531f38fd02c9201032b", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -5,6 +5,7 @@ use super::Pass;\n \n use rustc::util::nodemap::FxHashSet;\n use rustc::hir::def_id::DefId;\n+use syntax::symbol::sym;\n \n pub const COLLECT_TRAIT_IMPLS: Pass = Pass {\n     name: \"collect-trait-impls\",\n@@ -68,7 +69,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n             inline::build_impl(cx, def_id, &mut new_items);\n \n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n-            if !cx.tcx.get_attrs(def_id).lists(\"doc\").has_word(\"hidden\") {\n+            if !cx.tcx.get_attrs(def_id).lists(sym::doc).has_word(sym::hidden) {\n                 let self_ty = cx.tcx.type_of(def_id);\n                 let impls = get_auto_trait_and_blanket_impls(cx, self_ty, def_id);\n                 let mut renderinfo = cx.renderinfo.borrow_mut();\n@@ -154,7 +155,7 @@ impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.is_struct() || i.is_enum() || i.is_union() {\n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n-            if !self.cx.tcx.get_attrs(i.def_id).lists(\"doc\").has_word(\"hidden\") {\n+            if !self.cx.tcx.get_attrs(i.def_id).lists(sym::doc).has_word(sym::hidden) {\n                 self.impls.extend(get_auto_trait_and_blanket_impls(\n                     self.cx,\n                     self.cx.tcx.type_of(i.def_id),"}, {"sha": "da8977544f64bc17da8a968c0252ad2f03581607", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -1,5 +1,6 @@\n use rustc::util::nodemap::DefIdSet;\n use std::mem;\n+use syntax::symbol::sym;\n \n use crate::clean::{self, AttributesExt, NestedAttributesExt};\n use crate::clean::Item;\n@@ -37,7 +38,7 @@ struct Stripper<'a> {\n \n impl<'a> DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        if i.attrs.lists(\"doc\").has_word(\"hidden\") {\n+        if i.attrs.lists(sym::doc).has_word(sym::hidden) {\n             debug!(\"strip_hidden: stripping {} {:?}\", i.type_(), i.name);\n             // use a dedicated hidden item for given item type if any\n             match i.inner {"}, {"sha": "e40dbe52ffe6423ecb9e259e7bfcd8b931a98088", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -11,10 +11,6 @@ use syntax::ast;\n use syntax::source_map::SourceMap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax_pos::{BytePos, DUMMY_SP, Pos, Span, FileName};\n-use tempfile::Builder as TempFileBuilder;\n-use testing;\n-\n use std::env;\n use std::io::prelude::*;\n use std::io;\n@@ -23,6 +19,10 @@ use std::path::PathBuf;\n use std::process::Command;\n use std::str;\n use std::sync::{Arc, Mutex};\n+use syntax::symbol::sym;\n+use syntax_pos::{BytePos, DUMMY_SP, Pos, Span, FileName};\n+use tempfile::Builder as TempFileBuilder;\n+use testing;\n \n use crate::clean::Attributes;\n use crate::config::Options;\n@@ -137,17 +137,17 @@ fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n     };\n \n     let test_attrs: Vec<_> = krate.attrs.iter()\n-        .filter(|a| a.check_name(\"doc\"))\n+        .filter(|a| a.check_name(sym::doc))\n         .flat_map(|a| a.meta_item_list().unwrap_or_else(Vec::new))\n-        .filter(|a| a.check_name(\"test\"))\n+        .filter(|a| a.check_name(sym::test))\n         .collect();\n     let attrs = test_attrs.iter().flat_map(|a| a.meta_item_list().unwrap_or(&[]));\n \n     for attr in attrs {\n-        if attr.check_name(\"no_crate_inject\") {\n+        if attr.check_name(sym::no_crate_inject) {\n             opts.no_crate_inject = true;\n         }\n-        if attr.check_name(\"attr\") {\n+        if attr.check_name(sym::attr) {\n             if let Some(l) = attr.meta_item_list() {\n                 for item in l {\n                     opts.attrs.push(pprust::meta_list_item_to_string(item));"}, {"sha": "eb9de43e388618ab67736d4812da305bf3832817", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -10,6 +10,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::MacroKind;\n use syntax::source_map::Spanned;\n+use syntax::symbol::sym;\n use syntax_pos::{self, Span};\n \n use std::mem;\n@@ -165,11 +166,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     body: hir::BodyId) {\n         debug!(\"Visiting fn\");\n         let macro_kind = item.attrs.iter().filter_map(|a| {\n-            if a.check_name(\"proc_macro\") {\n+            if a.check_name(sym::proc_macro) {\n                 Some(MacroKind::Bang)\n-            } else if a.check_name(\"proc_macro_derive\") {\n+            } else if a.check_name(sym::proc_macro_derive) {\n                 Some(MacroKind::Derive)\n-            } else if a.check_name(\"proc_macro_attribute\") {\n+            } else if a.check_name(sym::proc_macro_attribute) {\n                 Some(MacroKind::Attr)\n             } else {\n                 None\n@@ -178,7 +179,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         match macro_kind {\n             Some(kind) => {\n                 let name = if kind == MacroKind::Derive {\n-                    item.attrs.lists(\"proc_macro_derive\")\n+                    item.attrs.lists(sym::proc_macro_derive)\n                               .filter_map(|mi| mi.ident())\n                               .next()\n                               .expect(\"proc-macro derives require a name\")\n@@ -188,8 +189,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n \n                 let mut helpers = Vec::new();\n-                for mi in item.attrs.lists(\"proc_macro_derive\") {\n-                    if !mi.check_name(\"attributes\") {\n+                for mi in item.attrs.lists(sym::proc_macro_derive) {\n+                    if !mi.check_name(sym::attributes) {\n                         continue;\n                     }\n \n@@ -274,7 +275,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         fn inherits_doc_hidden(cx: &core::DocContext<'_>, mut node: hir::HirId) -> bool {\n             while let Some(id) = cx.tcx.hir().get_enclosing_scope(node) {\n                 node = id;\n-                if cx.tcx.hir().attrs_by_hir_id(node).lists(\"doc\").has_word(\"hidden\") {\n+                if cx.tcx.hir().attrs_by_hir_id(node)\n+                    .lists(sym::doc).has_word(sym::hidden) {\n                     return true;\n                 }\n                 if node == hir::CRATE_HIR_ID {\n@@ -295,16 +297,16 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         let use_attrs = tcx.hir().attrs_by_hir_id(id);\n         // Don't inline `doc(hidden)` imports so they can be stripped at a later stage.\n-        let is_no_inline = use_attrs.lists(\"doc\").has_word(\"no_inline\") ||\n-                           use_attrs.lists(\"doc\").has_word(\"hidden\");\n+        let is_no_inline = use_attrs.lists(sym::doc).has_word(sym::no_inline) ||\n+                           use_attrs.lists(sym::doc).has_word(sym::hidden);\n \n         // For cross-crate impl inlining we need to know whether items are\n         // reachable in documentation -- a previously nonreachable item can be\n         // made reachable by cross-crate inlining which we're checking here.\n         // (this is done here because we need to know this upfront).\n         if !res_did.is_local() && !is_no_inline {\n             let attrs = clean::inline::load_attrs(self.cx, res_did);\n-            let self_is_hidden = attrs.lists(\"doc\").has_word(\"hidden\");\n+            let self_is_hidden = attrs.lists(sym::doc).has_word(sym::hidden);\n             match res {\n                 Res::Def(DefKind::Trait, did) |\n                 Res::Def(DefKind::Struct, did) |\n@@ -432,8 +434,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 if item.vis.node.is_pub() && self.inside_public_path {\n                     let please_inline = item.attrs.iter().any(|item| {\n                         match item.meta_item_list() {\n-                            Some(ref list) if item.check_name(\"doc\") => {\n-                                list.iter().any(|i| i.check_name(\"inline\"))\n+                            Some(ref list) if item.check_name(sym::doc) => {\n+                                list.iter().any(|i| i.check_name(sym::inline))\n                             }\n                             _ => false,\n                         }"}, {"sha": "2547e3a06e9efbbe71b1e309c23cc9ecb1679fe0", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -3,6 +3,7 @@ use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::ty::Visibility;\n use rustc::util::nodemap::FxHashSet;\n+use syntax::symbol::sym;\n \n use std::cell::RefMut;\n \n@@ -42,7 +43,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n \n     // Updates node level and returns the updated level\n     fn update(&mut self, did: DefId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n-        let is_hidden = self.cx.tcx.get_attrs(did).lists(\"doc\").has_word(\"hidden\");\n+        let is_hidden = self.cx.tcx.get_attrs(did).lists(sym::doc).has_word(sym::hidden);\n \n         let old_level = self.access_levels.map.get(&did).cloned();\n         // Accessibility levels can only grow"}, {"sha": "d12240655e6289abf36f3ac437870eb4be5c4458", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -81,12 +81,6 @@ impl PartialEq<Symbol> for Path {\n     }\n }\n \n-impl<'a> PartialEq<&'a str> for Path {\n-    fn eq(&self, string: &&'a str) -> bool {\n-        self.segments.len() == 1 && self.segments[0].ident.name == *string\n-    }\n-}\n-\n impl fmt::Debug for Path {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"path({})\", pprust::path_to_string(self))"}, {"sha": "65ca96afab1292be47cf18688b1f0708ec6da054", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 59, "deletions": 62, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -5,7 +5,7 @@ use crate::feature_gate::{Features, GatedCfg};\n use crate::parse::ParseSess;\n \n use errors::{Applicability, Handler};\n-use syntax_pos::{symbol::Symbol, Span};\n+use syntax_pos::{symbol::Symbol, symbol::sym, Span};\n \n use super::{mark_used, MetaItemKind};\n \n@@ -80,13 +80,13 @@ pub enum UnwindAttr {\n /// Determine what `#[unwind]` attribute is present in `attrs`, if any.\n pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Option<UnwindAttr> {\n     attrs.iter().fold(None, |ia, attr| {\n-        if attr.check_name(\"unwind\") {\n+        if attr.check_name(sym::unwind) {\n             if let Some(meta) = attr.meta() {\n                 if let MetaItemKind::List(items) = meta.node {\n                     if items.len() == 1 {\n-                        if items[0].check_name(\"allowed\") {\n+                        if items[0].check_name(sym::allowed) {\n                             return Some(UnwindAttr::Allowed);\n-                        } else if items[0].check_name(\"aborts\") {\n+                        } else if items[0].check_name(sym::aborts) {\n                             return Some(UnwindAttr::Aborts);\n                         }\n                     }\n@@ -153,9 +153,9 @@ pub struct RustcDeprecation {\n \n /// Checks if `attrs` contains an attribute like `#![feature(feature_name)]`.\n /// This will not perform any \"sanity checks\" on the form of the attributes.\n-pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n+pub fn contains_feature_attr(attrs: &[Attribute], feature_name: Symbol) -> bool {\n     attrs.iter().any(|item| {\n-        item.check_name(\"feature\") &&\n+        item.check_name(sym::feature) &&\n         item.meta_item_list().map(|list| {\n             list.iter().any(|mi| mi.is_word() && mi.check_name(feature_name))\n         }).unwrap_or(false)\n@@ -185,12 +185,12 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n \n     'outer: for attr in attrs_iter {\n         if ![\n-            \"rustc_deprecated\",\n-            \"rustc_const_unstable\",\n-            \"unstable\",\n-            \"stable\",\n-            \"rustc_promotable\",\n-            \"rustc_allow_const_fn_ptr\",\n+            sym::rustc_deprecated,\n+            sym::rustc_const_unstable,\n+            sym::unstable,\n+            sym::stable,\n+            sym::rustc_promotable,\n+            sym::rustc_allow_const_fn_ptr,\n         ].iter().any(|&s| attr.path == s) {\n             continue // not a stability level\n         }\n@@ -199,10 +199,10 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n \n         let meta = attr.meta();\n \n-        if attr.path == \"rustc_promotable\" {\n+        if attr.path == sym::rustc_promotable {\n             promotable = true;\n         }\n-        if attr.path == \"rustc_allow_const_fn_ptr\" {\n+        if attr.path == sym::rustc_allow_const_fn_ptr {\n             allow_const_fn_ptr = true;\n         }\n         // attributes with data\n@@ -229,10 +229,9 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                     )+\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match mi.name_or_empty().get() {\n+                            match mi.name_or_empty() {\n                                 $(\n-                                    stringify!($name)\n-                                        => if !get(mi, &mut $name) { continue 'outer },\n+                                    sym::$name => if !get(mi, &mut $name) { continue 'outer },\n                                 )+\n                                 _ => {\n                                     let expected = &[ $( stringify!($name) ),+ ];\n@@ -259,8 +258,8 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                 }\n             }\n \n-            match meta.name_or_empty().get() {\n-                \"rustc_deprecated\" => {\n+            match meta.name_or_empty() {\n+                sym::rustc_deprecated => {\n                     if rustc_depr.is_some() {\n                         span_err!(diagnostic, item_sp, E0540,\n                                   \"multiple rustc_deprecated attributes\");\n@@ -287,7 +286,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                         }\n                     }\n                 }\n-                \"rustc_const_unstable\" => {\n+                sym::rustc_const_unstable => {\n                     if rustc_const_unstable.is_some() {\n                         span_err!(diagnostic, item_sp, E0553,\n                                   \"multiple rustc_const_unstable attributes\");\n@@ -302,7 +301,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                         continue\n                     }\n                 }\n-                \"unstable\" => {\n+                sym::unstable => {\n                     if stab.is_some() {\n                         handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n                         break\n@@ -313,10 +312,10 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                     let mut issue = None;\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match mi.name_or_empty().get() {\n-                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n-                                \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n-                                \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n+                            match mi.name_or_empty() {\n+                                sym::feature => if !get(mi, &mut feature) { continue 'outer },\n+                                sym::reason => if !get(mi, &mut reason) { continue 'outer },\n+                                sym::issue => if !get(mi, &mut issue) { continue 'outer },\n                                 _ => {\n                                     handle_errors(\n                                         sess,\n@@ -374,7 +373,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                         }\n                     }\n                 }\n-                \"stable\" => {\n+                sym::stable => {\n                     if stab.is_some() {\n                         handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n                         break\n@@ -385,11 +384,9 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                     for meta in metas {\n                         match meta {\n                             NestedMetaItem::MetaItem(mi) => {\n-                                match mi.name_or_empty().get() {\n-                                    \"feature\" =>\n-                                        if !get(mi, &mut feature) { continue 'outer },\n-                                    \"since\" =>\n-                                        if !get(mi, &mut since) { continue 'outer },\n+                                match mi.name_or_empty() {\n+                                    sym::feature => if !get(mi, &mut feature) { continue 'outer },\n+                                    sym::since => if !get(mi, &mut since) { continue 'outer },\n                                     _ => {\n                                         handle_errors(\n                                             sess,\n@@ -482,7 +479,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n }\n \n pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n-    super::first_attr_value_str_by_name(attrs, \"crate_name\")\n+    super::first_attr_value_str_by_name(attrs, sym::crate_name)\n }\n \n /// Tests if a cfg-pattern matches the cfg set\n@@ -542,14 +539,14 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n \n             // The unwraps below may look dangerous, but we've already asserted\n             // that they won't fail with the loop above.\n-            match cfg.name_or_empty().get() {\n-                \"any\" => mis.iter().any(|mi| {\n+            match cfg.name_or_empty() {\n+                sym::any => mis.iter().any(|mi| {\n                     eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n-                \"all\" => mis.iter().all(|mi| {\n+                sym::all => mis.iter().all(|mi| {\n                     eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n-                \"not\" => {\n+                sym::not => {\n                     if mis.len() != 1 {\n                         span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n                         return false;\n@@ -593,7 +590,7 @@ fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n     let diagnostic = &sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n-        if !attr.check_name(\"deprecated\") {\n+        if !attr.check_name(sym::deprecated) {\n             continue;\n         }\n \n@@ -645,9 +642,9 @@ fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n                 for meta in list {\n                     match meta {\n                         NestedMetaItem::MetaItem(mi) => {\n-                            match mi.name_or_empty().get() {\n-                                \"since\" => if !get(mi, &mut since) { continue 'outer },\n-                                \"note\" => if !get(mi, &mut note) { continue 'outer },\n+                            match mi.name_or_empty() {\n+                                sym::since => if !get(mi, &mut since) { continue 'outer },\n+                                sym::note => if !get(mi, &mut note) { continue 'outer },\n                                 _ => {\n                                     handle_errors(\n                                         sess,\n@@ -721,7 +718,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n \n     let mut acc = Vec::new();\n     let diagnostic = &sess.span_diagnostic;\n-    if attr.path == \"repr\" {\n+    if attr.path == sym::repr {\n         if let Some(items) = attr.meta_item_list() {\n             mark_used(attr);\n             for item in items {\n@@ -739,11 +736,11 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n \n                 let mut recognised = false;\n                 if item.is_word() {\n-                    let hint = match item.name_or_empty().get() {\n-                        \"C\" => Some(ReprC),\n-                        \"packed\" => Some(ReprPacked(1)),\n-                        \"simd\" => Some(ReprSimd),\n-                        \"transparent\" => Some(ReprTransparent),\n+                    let hint = match item.name_or_empty() {\n+                        sym::C => Some(ReprC),\n+                        sym::packed => Some(ReprPacked(1)),\n+                        sym::simd => Some(ReprSimd),\n+                        sym::transparent => Some(ReprTransparent),\n                         name => int_type_of_word(name).map(ReprInt),\n                     };\n \n@@ -770,14 +767,14 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                     };\n \n                     let mut literal_error = None;\n-                    if name == \"align\" {\n+                    if name == sym::align {\n                         recognised = true;\n                         match parse_alignment(&value.node) {\n                             Ok(literal) => acc.push(ReprAlign(literal)),\n                             Err(message) => literal_error = Some(message)\n                         };\n                     }\n-                    else if name == \"packed\" {\n+                    else if name == sym::packed {\n                         recognised = true;\n                         match parse_alignment(&value.node) {\n                             Ok(literal) => acc.push(ReprPacked(literal)),\n@@ -790,7 +787,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                     }\n                 } else {\n                     if let Some(meta_item) = item.meta_item() {\n-                        if meta_item.check_name(\"align\") {\n+                        if meta_item.check_name(sym::align) {\n                             if let MetaItemKind::NameValue(ref value) = meta_item.node {\n                                 recognised = true;\n                                 let mut err = struct_span_err!(diagnostic, item.span(), E0693,\n@@ -830,22 +827,22 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n     acc\n }\n \n-fn int_type_of_word(s: &str) -> Option<IntType> {\n+fn int_type_of_word(s: Symbol) -> Option<IntType> {\n     use IntType::*;\n \n     match s {\n-        \"i8\" => Some(SignedInt(ast::IntTy::I8)),\n-        \"u8\" => Some(UnsignedInt(ast::UintTy::U8)),\n-        \"i16\" => Some(SignedInt(ast::IntTy::I16)),\n-        \"u16\" => Some(UnsignedInt(ast::UintTy::U16)),\n-        \"i32\" => Some(SignedInt(ast::IntTy::I32)),\n-        \"u32\" => Some(UnsignedInt(ast::UintTy::U32)),\n-        \"i64\" => Some(SignedInt(ast::IntTy::I64)),\n-        \"u64\" => Some(UnsignedInt(ast::UintTy::U64)),\n-        \"i128\" => Some(SignedInt(ast::IntTy::I128)),\n-        \"u128\" => Some(UnsignedInt(ast::UintTy::U128)),\n-        \"isize\" => Some(SignedInt(ast::IntTy::Isize)),\n-        \"usize\" => Some(UnsignedInt(ast::UintTy::Usize)),\n+        sym::i8 => Some(SignedInt(ast::IntTy::I8)),\n+        sym::u8 => Some(UnsignedInt(ast::UintTy::U8)),\n+        sym::i16 => Some(SignedInt(ast::IntTy::I16)),\n+        sym::u16 => Some(UnsignedInt(ast::UintTy::U16)),\n+        sym::i32 => Some(SignedInt(ast::IntTy::I32)),\n+        sym::u32 => Some(UnsignedInt(ast::UintTy::U32)),\n+        sym::i64 => Some(SignedInt(ast::IntTy::I64)),\n+        sym::u64 => Some(UnsignedInt(ast::UintTy::U64)),\n+        sym::i128 => Some(SignedInt(ast::IntTy::I128)),\n+        sym::u128 => Some(UnsignedInt(ast::UintTy::U128)),\n+        sym::isize => Some(SignedInt(ast::IntTy::Isize)),\n+        sym::usize => Some(UnsignedInt(ast::UintTy::Usize)),\n         _ => None\n     }\n }"}, {"sha": "d94a3165b0f1d1fdd50ca3da6f166ab28a56bec0", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -22,7 +22,7 @@ use crate::parse::parser::Parser;\n use crate::parse::{self, ParseSess, PResult};\n use crate::parse::token::{self, Token};\n use crate::ptr::P;\n-use crate::symbol::{keywords, LocalInternedString, Symbol};\n+use crate::symbol::{keywords, Symbol};\n use crate::ThinVec;\n use crate::tokenstream::{TokenStream, TokenTree, DelimSpan};\n use crate::GLOBALS;\n@@ -81,19 +81,16 @@ impl NestedMetaItem {\n     }\n \n     /// Returns `true` if this list item is a MetaItem with a name of `name`.\n-    pub fn check_name<T>(&self, name: T) -> bool\n-    where\n-        Path: PartialEq<T>,\n-    {\n+    pub fn check_name(&self, name: Symbol) -> bool {\n         self.meta_item().map_or(false, |meta_item| meta_item.check_name(name))\n     }\n \n     /// For a single-segment meta-item returns its name, otherwise returns `None`.\n     pub fn ident(&self) -> Option<Ident> {\n         self.meta_item().and_then(|meta_item| meta_item.ident())\n     }\n-    pub fn name_or_empty(&self) -> LocalInternedString {\n-        self.ident().unwrap_or(keywords::Invalid.ident()).name.as_str()\n+    pub fn name_or_empty(&self) -> Symbol {\n+        self.ident().unwrap_or(keywords::Invalid.ident()).name\n     }\n \n     /// Gets the string value if self is a MetaItem and the MetaItem is a\n@@ -154,10 +151,7 @@ impl Attribute {\n     /// attribute is marked as used.\n     ///\n     /// To check the attribute name without marking it used, use the `path` field directly.\n-    pub fn check_name<T>(&self, name: T) -> bool\n-    where\n-        Path: PartialEq<T>,\n-    {\n+    pub fn check_name(&self, name: Symbol) -> bool {\n         let matches = self.path == name;\n         if matches {\n             mark_used(self);\n@@ -173,8 +167,8 @@ impl Attribute {\n             None\n         }\n     }\n-    pub fn name_or_empty(&self) -> LocalInternedString {\n-        self.ident().unwrap_or(keywords::Invalid.ident()).name.as_str()\n+    pub fn name_or_empty(&self) -> Symbol {\n+        self.ident().unwrap_or(keywords::Invalid.ident()).name\n     }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n@@ -211,8 +205,8 @@ impl MetaItem {\n             None\n         }\n     }\n-    pub fn name_or_empty(&self) -> LocalInternedString {\n-        self.ident().unwrap_or(keywords::Invalid.ident()).name.as_str()\n+    pub fn name_or_empty(&self) -> Symbol {\n+        self.ident().unwrap_or(keywords::Invalid.ident()).name\n     }\n \n     // #[attribute(name = \"value\")]\n@@ -250,10 +244,7 @@ impl MetaItem {\n         }\n     }\n \n-    pub fn check_name<T>(&self, name: T) -> bool\n-    where\n-        Path: PartialEq<T>,\n-    {\n+    pub fn check_name(&self, name: Symbol) -> bool {\n         self.path == name\n     }\n \n@@ -430,28 +421,28 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, span: Span) -> Attribute {\n     }\n }\n \n-pub fn list_contains_name(items: &[NestedMetaItem], name: &str) -> bool {\n+pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n     items.iter().any(|item| {\n         item.check_name(name)\n     })\n }\n \n-pub fn contains_name(attrs: &[Attribute], name: &str) -> bool {\n+pub fn contains_name(attrs: &[Attribute], name: Symbol) -> bool {\n     attrs.iter().any(|item| {\n         item.check_name(name)\n     })\n }\n \n-pub fn find_by_name<'a>(attrs: &'a [Attribute], name: &str) -> Option<&'a Attribute> {\n+pub fn find_by_name<'a>(attrs: &'a [Attribute], name: Symbol) -> Option<&'a Attribute> {\n     attrs.iter().find(|attr| attr.check_name(name))\n }\n \n-pub fn filter_by_name<'a>(attrs: &'a [Attribute], name: &'a str)\n+pub fn filter_by_name<'a>(attrs: &'a [Attribute], name: Symbol)\n     -> impl Iterator<Item = &'a Attribute> {\n     attrs.iter().filter(move |attr| attr.check_name(name))\n }\n \n-pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str) -> Option<Symbol> {\n+pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: Symbol) -> Option<Symbol> {\n     attrs.iter()\n         .find(|at| at.check_name(name))\n         .and_then(|at| at.value_str())"}, {"sha": "c82936afa3d9f0f96d815a36eddb05c326901a2c", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -12,6 +12,7 @@ use crate::edition::Edition;\n use crate::mut_visit::*;\n use crate::parse::{token, ParseSess};\n use crate::ptr::P;\n+use crate::symbol::sym;\n use crate::util::map_in_place::MapInPlace;\n \n use errors::Applicability;\n@@ -90,7 +91,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// is in the original source file. Gives a compiler error if the syntax of\n     /// the attribute is incorrect.\n     fn process_cfg_attr(&mut self, attr: ast::Attribute) -> Vec<ast::Attribute> {\n-        if !attr.check_name(\"cfg_attr\") {\n+        if !attr.check_name(sym::cfg_attr) {\n             return vec![attr];\n         }\n \n@@ -205,7 +206,7 @@ impl<'a> StripUnconfigured<'a> {\n     pub fn maybe_emit_expr_attr_err(&self, attr: &ast::Attribute) {\n         if !self.features.map(|features| features.stmt_expr_attributes).unwrap_or(true) {\n             let mut err = feature_err(self.sess,\n-                                      \"stmt_expr_attributes\",\n+                                      sym::stmt_expr_attributes,\n                                       attr.span,\n                                       GateIssue::Language,\n                                       EXPLAIN_STMT_ATTR_SYNTAX);\n@@ -285,9 +286,9 @@ impl<'a> StripUnconfigured<'a> {\n     /// See issue #51279.\n     pub fn disallow_cfg_on_generic_param(&mut self, param: &ast::GenericParam) {\n         for attr in param.attrs() {\n-            let offending_attr = if attr.check_name(\"cfg\") {\n+            let offending_attr = if attr.check_name(sym::cfg) {\n                 \"cfg\"\n-            } else if attr.check_name(\"cfg_attr\") {\n+            } else if attr.check_name(sym::cfg_attr) {\n                 \"cfg_attr\"\n             } else {\n                 continue;\n@@ -350,5 +351,5 @@ impl<'a> MutVisitor for StripUnconfigured<'a> {\n }\n \n fn is_cfg(attr: &ast::Attribute) -> bool {\n-    attr.check_name(\"cfg\")\n+    attr.check_name(sym::cfg)\n }"}, {"sha": "0b6cf30bd27d248207397ef3338ae9f62e4faff9", "filename": "src/libsyntax/entry.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fentry.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -1,5 +1,6 @@\n use crate::attr;\n use crate::ast::{Item, ItemKind};\n+use crate::symbol::sym;\n \n pub enum EntryPointType {\n     None,\n@@ -14,11 +15,11 @@ pub enum EntryPointType {\n pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n     match item.node {\n         ItemKind::Fn(..) => {\n-            if attr::contains_name(&item.attrs, \"start\") {\n+            if attr::contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start\n-            } else if attr::contains_name(&item.attrs, \"main\") {\n+            } else if attr::contains_name(&item.attrs, sym::main) {\n                 EntryPointType::MainAttr\n-            } else if item.ident.name == \"main\" {\n+            } else if item.ident.name == sym::main {\n                 if depth == 1 {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed"}, {"sha": "0a88d2f8824d3f3d34ad908dff6c9ada3a299201", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -10,7 +10,7 @@ use crate::mut_visit::{self, MutVisitor};\n use crate::parse::{self, parser, DirectoryOwnership};\n use crate::parse::token;\n use crate::ptr::P;\n-use crate::symbol::{keywords, Ident, Symbol};\n+use crate::symbol::{keywords, Ident, Symbol, sym};\n use crate::ThinVec;\n use crate::tokenstream::{self, TokenStream};\n \n@@ -871,7 +871,7 @@ impl<'a> ExtCtxt<'a> {\n         let mut last_macro = None;\n         loop {\n             if ctxt.outer().expn_info().map_or(None, |info| {\n-                if info.format.name() == \"include\" {\n+                if info.format.name() == sym::include {\n                     // Stop going up the backtrace once include! is encountered\n                     return None;\n                 }"}, {"sha": "a24e09f127eaeef07012848accc355eb46d3951f", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -4,7 +4,7 @@ use crate::source_map::{hygiene, ExpnInfo, ExpnFormat};\n use crate::ext::base::ExtCtxt;\n use crate::ext::build::AstBuilder;\n use crate::parse::parser::PathStyle;\n-use crate::symbol::Symbol;\n+use crate::symbol::{Symbol, sym};\n \n use syntax_pos::Span;\n \n@@ -13,7 +13,7 @@ use rustc_data_structures::fx::FxHashSet;\n pub fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n     let mut result = Vec::new();\n     attrs.retain(|attr| {\n-        if attr.path != \"derive\" {\n+        if attr.path != sym::derive {\n             return true;\n         }\n         if !attr.is_meta_item_list() {"}, {"sha": "a286fd83e3c208ff8b5d802e816f188006241e48", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -14,7 +14,7 @@ use crate::parse::token::{self, Token};\n use crate::parse::parser::Parser;\n use crate::ptr::P;\n use crate::symbol::Symbol;\n-use crate::symbol::keywords;\n+use crate::symbol::{keywords, sym};\n use crate::tokenstream::{TokenStream, TokenTree};\n use crate::visit::{self, Visitor};\n use crate::util::map_in_place::MapInPlace;\n@@ -356,7 +356,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     self.collect_invocations(fragment, &[])\n                 } else if let InvocationKind::Attr { attr: None, traits, item, .. } = invoc.kind {\n                     if !item.derive_allowed() {\n-                        let attr = attr::find_by_name(item.attrs(), \"derive\")\n+                        let attr = attr::find_by_name(item.attrs(), sym::derive)\n                             .expect(\"`derive` attribute should exist\");\n                         let span = attr.span;\n                         let mut err = self.cx.mut_span_err(span,\n@@ -376,7 +376,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     }\n \n                     let mut item = self.fully_configure(item);\n-                    item.visit_attrs(|attrs| attrs.retain(|a| a.path != \"derive\"));\n+                    item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n                     let mut item_with_markers = item.clone();\n                     add_derived_markers(&mut self.cx, item.span(), &traits, &mut item_with_markers);\n                     let derives = derives.entry(invoc.expansion_data.mark).or_default();\n@@ -510,7 +510,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         if invoc.fragment_kind == AstFragmentKind::ForeignItems &&\n            !self.cx.ecfg.macros_in_extern_enabled() {\n             if let SyntaxExtension::NonMacroAttr { .. } = *ext {} else {\n-                emit_feature_err(&self.cx.parse_sess, \"macros_in_extern\",\n+                emit_feature_err(&self.cx.parse_sess, sym::macros_in_extern,\n                                  invoc.span(), GateIssue::Language,\n                                  \"macro invocations in `extern {}` blocks are experimental\");\n             }\n@@ -636,7 +636,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             Annotatable::Item(ref item) => {\n                 match item.node {\n                     ItemKind::Mod(_) if self.cx.ecfg.proc_macro_hygiene() => return,\n-                    ItemKind::Mod(_) => (\"modules\", \"proc_macro_hygiene\"),\n+                    ItemKind::Mod(_) => (\"modules\", sym::proc_macro_hygiene),\n                     _ => return,\n                 }\n             }\n@@ -645,8 +645,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             Annotatable::ForeignItem(_) => return,\n             Annotatable::Stmt(_) |\n             Annotatable::Expr(_) if self.cx.ecfg.proc_macro_hygiene() => return,\n-            Annotatable::Stmt(_) => (\"statements\", \"proc_macro_hygiene\"),\n-            Annotatable::Expr(_) => (\"expressions\", \"proc_macro_hygiene\"),\n+            Annotatable::Stmt(_) => (\"statements\", sym::proc_macro_hygiene),\n+            Annotatable::Expr(_) => (\"expressions\", sym::proc_macro_hygiene),\n         };\n         emit_feature_err(\n             self.cx.parse_sess,\n@@ -681,7 +681,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 if let ast::ItemKind::MacroDef(_) = i.node {\n                     emit_feature_err(\n                         self.parse_sess,\n-                        \"proc_macro_hygiene\",\n+                        sym::proc_macro_hygiene,\n                         self.span,\n                         GateIssue::Language,\n                         \"procedural macros cannot expand to macro definitions\",\n@@ -724,13 +724,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 // don't stability-check macros in the same crate\n                 // (the only time this is null is for syntax extensions registered as macros)\n                 if def_site_span.map_or(false, |def_span| !crate_span.contains(def_span))\n-                    && !span.allows_unstable(&feature.as_str())\n+                    && !span.allows_unstable(feature)\n                     && this.cx.ecfg.features.map_or(true, |feats| {\n                     // macro features will count as lib features\n                     !feats.declared_lib_features.iter().any(|&(feat, _)| feat == feature)\n                 }) {\n                     let explain = format!(\"macro {}! is unstable\", path);\n-                    emit_feature_err(this.cx.parse_sess, &*feature.as_str(), span,\n+                    emit_feature_err(this.cx.parse_sess, feature, span,\n                                      GateIssue::Library(Some(issue)), &explain);\n                     this.cx.trace_macros_diag();\n                 }\n@@ -885,7 +885,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n         emit_feature_err(\n             self.cx.parse_sess,\n-            \"proc_macro_hygiene\",\n+            sym::proc_macro_hygiene,\n             span,\n             GateIssue::Language,\n             &format!(\"procedural macros cannot be expanded to {}\", kind),\n@@ -1109,16 +1109,16 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                        -> Option<ast::Attribute> {\n         let attr = attrs.iter()\n                         .position(|a| {\n-                            if a.path == \"derive\" {\n+                            if a.path == sym::derive {\n                                 *after_derive = true;\n                             }\n                             !attr::is_known(a) && !is_builtin_attr(a)\n                         })\n                         .map(|i| attrs.remove(i));\n         if let Some(attr) = &attr {\n             if !self.cx.ecfg.enable_custom_inner_attributes() &&\n-               attr.style == ast::AttrStyle::Inner && attr.path != \"test\" {\n-                emit_feature_err(&self.cx.parse_sess, \"custom_inner_attributes\",\n+               attr.style == ast::AttrStyle::Inner && attr.path != sym::test {\n+                emit_feature_err(&self.cx.parse_sess, sym::custom_inner_attributes,\n                                  attr.span, GateIssue::Language,\n                                  \"non-builtin inner attributes are unstable\");\n             }\n@@ -1167,7 +1167,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             self.check_attribute_inner(attr, features);\n \n             // macros are expanded before any lint passes so this warning has to be hardcoded\n-            if attr.path == \"derive\" {\n+            if attr.path == sym::derive {\n                 self.cx.struct_span_warn(attr.span, \"`#[derive]` does nothing on macro invocations\")\n                     .note(\"this may become a hard error in a future release\")\n                     .emit();\n@@ -1352,7 +1352,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 let inline_module = item.span.contains(inner) || inner.is_dummy();\n \n                 if inline_module {\n-                    if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, \"path\") {\n+                    if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, sym::path) {\n                         self.cx.current_expansion.directory_ownership =\n                             DirectoryOwnership::Owned { relative: None };\n                         module.directory.push(&*path.as_str());\n@@ -1485,19 +1485,19 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn visit_attribute(&mut self, at: &mut ast::Attribute) {\n         // turn `#[doc(include=\"filename\")]` attributes into `#[doc(include(file=\"filename\",\n         // contents=\"file contents\")]` attributes\n-        if !at.check_name(\"doc\") {\n+        if !at.check_name(sym::doc) {\n             return noop_visit_attribute(at, self);\n         }\n \n         if let Some(list) = at.meta_item_list() {\n-            if !list.iter().any(|it| it.check_name(\"include\")) {\n+            if !list.iter().any(|it| it.check_name(sym::include)) {\n                 return noop_visit_attribute(at, self);\n             }\n \n             let mut items = vec![];\n \n             for mut it in list {\n-                if !it.check_name(\"include\") {\n+                if !it.check_name(sym::include) {\n                     items.push({ noop_visit_meta_list_item(&mut it, self); it });\n                     continue;\n                 }"}, {"sha": "e1cb90d9e71d652033ad2bb4c250516d0e34b055", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -4,7 +4,7 @@ use crate::ext::build::AstBuilder;\n use crate::parse::{self, token, DirectoryOwnership};\n use crate::print::pprust;\n use crate::ptr::P;\n-use crate::symbol::Symbol;\n+use crate::symbol::{Symbol, sym};\n use crate::tokenstream;\n \n use smallvec::SmallVec;\n@@ -44,7 +44,7 @@ pub fn expand_column(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::TokenTr\n /* __rust_unstable_column!(): expands to the current column number */\n pub fn expand_column_gated(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::TokenTree])\n                   -> Box<dyn base::MacResult+'static> {\n-    if sp.allows_unstable(\"__rust_unstable_column\") {\n+    if sp.allows_unstable(sym::__rust_unstable_column) {\n         expand_column(cx, sp, tts)\n     } else {\n         cx.span_fatal(sp, \"the __rust_unstable_column macro is unstable\");"}, {"sha": "06651750de74198c31ce8f66ea5cd88b3ea85969", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -13,7 +13,7 @@ use crate::parse::{Directory, ParseSess};\n use crate::parse::parser::Parser;\n use crate::parse::token::{self, NtTT};\n use crate::parse::token::Token::*;\n-use crate::symbol::Symbol;\n+use crate::symbol::{Symbol, keywords, sym};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n \n use errors::FatalError;\n@@ -376,7 +376,7 @@ pub fn compile(\n     });\n \n     if body.legacy {\n-        let allow_internal_unstable = attr::find_by_name(&def.attrs, \"allow_internal_unstable\")\n+        let allow_internal_unstable = attr::find_by_name(&def.attrs, sym::allow_internal_unstable)\n             .map(|attr| attr\n                 .meta_item_list()\n                 .map(|list| list.iter()\n@@ -399,11 +399,11 @@ pub fn compile(\n                     vec![Symbol::intern(\"allow_internal_unstable_backcompat_hack\")].into()\n                 })\n             );\n-        let allow_internal_unsafe = attr::contains_name(&def.attrs, \"allow_internal_unsafe\");\n+        let allow_internal_unsafe = attr::contains_name(&def.attrs, sym::allow_internal_unsafe);\n         let mut local_inner_macros = false;\n-        if let Some(macro_export) = attr::find_by_name(&def.attrs, \"macro_export\") {\n+        if let Some(macro_export) = attr::find_by_name(&def.attrs, sym::macro_export) {\n             if let Some(l) = macro_export.meta_item_list() {\n-                local_inner_macros = attr::list_contains_name(&l, \"local_inner_macros\");\n+                local_inner_macros = attr::list_contains_name(&l, sym::local_inner_macros);\n             }\n         }\n \n@@ -426,7 +426,7 @@ pub fn compile(\n             edition,\n         }\n     } else {\n-        let is_transparent = attr::contains_name(&def.attrs, \"rustc_transparent_macro\");\n+        let is_transparent = attr::contains_name(&def.attrs, sym::rustc_transparent_macro);\n \n         SyntaxExtension::DeclMacro {\n             expander,\n@@ -467,7 +467,7 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[quoted::TokenTree]) -> bool {\n             TokenTree::Sequence(span, ref seq) => {\n                 if seq.separator.is_none() && seq.tts.iter().all(|seq_tt| {\n                     match *seq_tt {\n-                        TokenTree::MetaVarDecl(_, _, id) => id.name == \"vis\",\n+                        TokenTree::MetaVarDecl(_, _, id) => id.name == sym::vis,\n                         TokenTree::Sequence(_, ref sub_seq) =>\n                             sub_seq.op == quoted::KleeneOp::ZeroOrMore\n                             || sub_seq.op == quoted::KleeneOp::ZeroOrOne,\n@@ -1046,7 +1046,8 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                 match *tok {\n                     TokenTree::Token(_, ref tok) => match *tok {\n                         FatArrow | Comma | Eq | BinOp(token::Or) => IsInFollow::Yes,\n-                        Ident(i, false) if i.name == \"if\" || i.name == \"in\" => IsInFollow::Yes,\n+                        Ident(i, false) if i.name == keywords::If.name() ||\n+                                           i.name == keywords::In.name() => IsInFollow::Yes,\n                         _ => IsInFollow::No(tokens),\n                     },\n                     _ => IsInFollow::No(tokens),\n@@ -1063,10 +1064,12 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                         OpenDelim(token::DelimToken::Bracket) |\n                         Comma | FatArrow | Colon | Eq | Gt | BinOp(token::Shr) | Semi |\n                         BinOp(token::Or) => IsInFollow::Yes,\n-                        Ident(i, false) if i.name == \"as\" || i.name == \"where\" => IsInFollow::Yes,\n+                        Ident(i, false) if i.name == keywords::As.name() ||\n+                                           i.name == keywords::Where.name() => IsInFollow::Yes,\n                         _ => IsInFollow::No(tokens),\n                     },\n-                    TokenTree::MetaVarDecl(_, _, frag) if frag.name == \"block\" => IsInFollow::Yes,\n+                    TokenTree::MetaVarDecl(_, _, frag) if frag.name == sym::block =>\n+                        IsInFollow::Yes,\n                     _ => IsInFollow::No(tokens),\n                 }\n             },\n@@ -1089,16 +1092,18 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                 match *tok {\n                     TokenTree::Token(_, ref tok) => match *tok {\n                         Comma => IsInFollow::Yes,\n-                        Ident(i, is_raw) if is_raw || i.name != \"priv\" => IsInFollow::Yes,\n+                        Ident(i, is_raw) if is_raw || i.name != keywords::Priv.name() =>\n+                            IsInFollow::Yes,\n                         ref tok => if tok.can_begin_type() {\n                             IsInFollow::Yes\n                         } else {\n                             IsInFollow::No(tokens)\n                         }\n                     },\n-                    TokenTree::MetaVarDecl(_, _, frag) if frag.name == \"ident\"\n-                                                       || frag.name == \"ty\"\n-                                                       || frag.name == \"path\" => IsInFollow::Yes,\n+                    TokenTree::MetaVarDecl(_, _, frag) if frag.name == sym::ident\n+                                                       || frag.name == sym::ty\n+                                                       || frag.name == sym::path =>\n+                        IsInFollow::Yes,\n                     _ => IsInFollow::No(tokens),\n                 }\n             },"}, {"sha": "a49926158de1d6aedcb2c9fd8dedddfbfa9cb0f9", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 235, "deletions": 234, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -22,13 +22,13 @@ use crate::source_map::Spanned;\n use crate::edition::{ALL_EDITIONS, Edition};\n use crate::visit::{self, FnKind, Visitor};\n use crate::parse::{token, ParseSess};\n-use crate::symbol::Symbol;\n+use crate::symbol::{Symbol, keywords, sym};\n use crate::tokenstream::TokenTree;\n \n use errors::{DiagnosticBuilder, Handler};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_target::spec::abi::Abi;\n-use syntax_pos::{Span, DUMMY_SP, symbols};\n+use syntax_pos::{Span, DUMMY_SP};\n use log::debug;\n use lazy_static::lazy_static;\n \n@@ -48,8 +48,8 @@ macro_rules! declare_features {\n         /// Represents active features that are currently being implemented or\n         /// currently being considered for addition/removal.\n         const ACTIVE_FEATURES:\n-            &[(&str, &str, Option<u32>, Option<Edition>, fn(&mut Features, Span))] =\n-            &[$((stringify!($feature), $ver, $issue, $edition, set!($feature))),+];\n+            &[(Symbol, &str, Option<u32>, Option<Edition>, fn(&mut Features, Span))] =\n+            &[$((sym::$feature, $ver, $issue, $edition, set!($feature))),+];\n \n         /// A set of features to be used by later passes.\n         #[derive(Clone)]\n@@ -80,22 +80,22 @@ macro_rules! declare_features {\n \n     ($((removed, $feature: ident, $ver: expr, $issue: expr, None, $reason: expr),)+) => {\n         /// Represents unstable features which have since been removed (it was once Active)\n-        const REMOVED_FEATURES: &[(&str, &str, Option<u32>, Option<&str>)] = &[\n-            $((stringify!($feature), $ver, $issue, $reason)),+\n+        const REMOVED_FEATURES: &[(Symbol, &str, Option<u32>, Option<&str>)] = &[\n+            $((sym::$feature, $ver, $issue, $reason)),+\n         ];\n     };\n \n     ($((stable_removed, $feature: ident, $ver: expr, $issue: expr, None),)+) => {\n         /// Represents stable features which have since been removed (it was once Accepted)\n-        const STABLE_REMOVED_FEATURES: &[(&str, &str, Option<u32>, Option<&str>)] = &[\n-            $((stringify!($feature), $ver, $issue, None)),+\n+        const STABLE_REMOVED_FEATURES: &[(Symbol, &str, Option<u32>, Option<&str>)] = &[\n+            $((sym::$feature, $ver, $issue, None)),+\n         ];\n     };\n \n     ($((accepted, $feature: ident, $ver: expr, $issue: expr, None),)+) => {\n         /// Those language feature has since been Accepted (it was once Active)\n-        const ACCEPTED_FEATURES: &[(&str, &str, Option<u32>, Option<&str>)] = &[\n-            $((stringify!($feature), $ver, $issue, None)),+\n+        const ACCEPTED_FEATURES: &[(Symbol, &str, Option<u32>, Option<&str>)] = &[\n+            $((sym::$feature, $ver, $issue, None)),+\n         ];\n     }\n }\n@@ -562,9 +562,9 @@ declare_features! (\n // Some features are known to be incomplete and using them is likely to have\n // unanticipated results, such as compiler crashes. We warn the user about these\n // to alert them.\n-const INCOMPLETE_FEATURES: &[&str] = &[\n-    \"generic_associated_types\",\n-    \"const_generics\"\n+const INCOMPLETE_FEATURES: &[Symbol] = &[\n+    sym::generic_associated_types,\n+    sym::const_generics\n ];\n \n declare_features! (\n@@ -860,7 +860,7 @@ pub enum AttributeType {\n pub enum AttributeGate {\n     /// Is gated by a given feature gate, reason\n     /// and function to check if enabled\n-    Gated(Stability, &'static str, &'static str, fn(&Features) -> bool),\n+    Gated(Stability, Symbol, &'static str, fn(&Features) -> bool),\n \n     /// Ungated attribute, can be used on all release channels\n     Ungated,\n@@ -962,286 +962,286 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Normal attributes\n \n     (\n-        symbols::warn,\n+        sym::warn,\n         Normal,\n         template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n         Ungated\n     ),\n     (\n-        symbols::allow,\n+        sym::allow,\n         Normal,\n         template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n         Ungated\n     ),\n     (\n-        symbols::forbid,\n+        sym::forbid,\n         Normal,\n         template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n         Ungated\n     ),\n     (\n-        symbols::deny,\n+        sym::deny,\n         Normal,\n         template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n         Ungated\n     ),\n \n-    (symbols::macro_use, Normal, template!(Word, List: \"name1, name2, ...\"), Ungated),\n-    (symbols::macro_export, Normal, template!(Word, List: \"local_inner_macros\"), Ungated),\n-    (symbols::plugin_registrar, Normal, template!(Word), Ungated),\n-\n-    (symbols::cfg, Normal, template!(List: \"predicate\"), Ungated),\n-    (symbols::cfg_attr, Normal, template!(List: \"predicate, attr1, attr2, ...\"), Ungated),\n-    (symbols::main, Normal, template!(Word), Ungated),\n-    (symbols::start, Normal, template!(Word), Ungated),\n-    (symbols::repr, Normal, template!(List: \"C, packed, ...\"), Ungated),\n-    (symbols::path, Normal, template!(NameValueStr: \"file\"), Ungated),\n-    (symbols::automatically_derived, Normal, template!(Word), Ungated),\n-    (symbols::no_mangle, Normal, template!(Word), Ungated),\n-    (symbols::no_link, Normal, template!(Word), Ungated),\n-    (symbols::derive, Normal, template!(List: \"Trait1, Trait2, ...\"), Ungated),\n+    (sym::macro_use, Normal, template!(Word, List: \"name1, name2, ...\"), Ungated),\n+    (sym::macro_export, Normal, template!(Word, List: \"local_inner_macros\"), Ungated),\n+    (sym::plugin_registrar, Normal, template!(Word), Ungated),\n+\n+    (sym::cfg, Normal, template!(List: \"predicate\"), Ungated),\n+    (sym::cfg_attr, Normal, template!(List: \"predicate, attr1, attr2, ...\"), Ungated),\n+    (sym::main, Normal, template!(Word), Ungated),\n+    (sym::start, Normal, template!(Word), Ungated),\n+    (sym::repr, Normal, template!(List: \"C, packed, ...\"), Ungated),\n+    (sym::path, Normal, template!(NameValueStr: \"file\"), Ungated),\n+    (sym::automatically_derived, Normal, template!(Word), Ungated),\n+    (sym::no_mangle, Normal, template!(Word), Ungated),\n+    (sym::no_link, Normal, template!(Word), Ungated),\n+    (sym::derive, Normal, template!(List: \"Trait1, Trait2, ...\"), Ungated),\n     (\n-        symbols::should_panic,\n+        sym::should_panic,\n         Normal,\n         template!(Word, List: r#\"expected = \"reason\"#, NameValueStr: \"reason\"),\n         Ungated\n     ),\n-    (symbols::ignore, Normal, template!(Word, NameValueStr: \"reason\"), Ungated),\n-    (symbols::no_implicit_prelude, Normal, template!(Word), Ungated),\n-    (symbols::reexport_test_harness_main, Normal, template!(NameValueStr: \"name\"), Ungated),\n-    (symbols::link_args, Normal, template!(NameValueStr: \"args\"), Gated(Stability::Unstable,\n-                                \"link_args\",\n+    (sym::ignore, Normal, template!(Word, NameValueStr: \"reason\"), Ungated),\n+    (sym::no_implicit_prelude, Normal, template!(Word), Ungated),\n+    (sym::reexport_test_harness_main, Normal, template!(NameValueStr: \"name\"), Ungated),\n+    (sym::link_args, Normal, template!(NameValueStr: \"args\"), Gated(Stability::Unstable,\n+                                sym::link_args,\n                                 \"the `link_args` attribute is experimental and not \\\n                                 portable across platforms, it is recommended to \\\n                                 use `#[link(name = \\\"foo\\\")] instead\",\n                                 cfg_fn!(link_args))),\n-    (symbols::macro_escape, Normal, template!(Word), Ungated),\n+    (sym::macro_escape, Normal, template!(Word), Ungated),\n \n     // RFC #1445.\n-    (symbols::structural_match, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            \"structural_match\",\n+    (sym::structural_match, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                            sym::structural_match,\n                                             \"the semantics of constant patterns is \\\n                                             not yet settled\",\n                                             cfg_fn!(structural_match))),\n \n     // RFC #2008\n-    (symbols::non_exhaustive, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                        \"non_exhaustive\",\n+    (sym::non_exhaustive, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                        sym::non_exhaustive,\n                                         \"non exhaustive is an experimental feature\",\n                                         cfg_fn!(non_exhaustive))),\n \n     // RFC #1268\n-    (symbols::marker, Normal, template!(Word), Gated(Stability::Unstable,\n-                            \"marker_trait_attr\",\n+    (sym::marker, Normal, template!(Word), Gated(Stability::Unstable,\n+                            sym::marker_trait_attr,\n                             \"marker traits is an experimental feature\",\n                             cfg_fn!(marker_trait_attr))),\n \n-    (symbols::plugin, CrateLevel, template!(List: \"name|name(args)\"), Gated(Stability::Unstable,\n-                                \"plugin\",\n+    (sym::plugin, CrateLevel, template!(List: \"name|name(args)\"), Gated(Stability::Unstable,\n+                                sym::plugin,\n                                 \"compiler plugins are experimental \\\n                                 and possibly buggy\",\n                                 cfg_fn!(plugin))),\n \n-    (symbols::no_std, CrateLevel, template!(Word), Ungated),\n-    (symbols::no_core, CrateLevel, template!(Word), Gated(Stability::Unstable,\n-                                \"no_core\",\n+    (sym::no_std, CrateLevel, template!(Word), Ungated),\n+    (sym::no_core, CrateLevel, template!(Word), Gated(Stability::Unstable,\n+                                sym::no_core,\n                                 \"no_core is experimental\",\n                                 cfg_fn!(no_core))),\n-    (symbols::lang, Normal, template!(NameValueStr: \"name\"), Gated(Stability::Unstable,\n-                        \"lang_items\",\n+    (sym::lang, Normal, template!(NameValueStr: \"name\"), Gated(Stability::Unstable,\n+                        sym::lang_items,\n                         \"language items are subject to change\",\n                         cfg_fn!(lang_items))),\n-    (symbols::linkage, Whitelisted, template!(NameValueStr: \"external|internal|...\"),\n+    (sym::linkage, Whitelisted, template!(NameValueStr: \"external|internal|...\"),\n                                 Gated(Stability::Unstable,\n-                                \"linkage\",\n+                                sym::linkage,\n                                 \"the `linkage` attribute is experimental \\\n                                     and not portable across platforms\",\n                                 cfg_fn!(linkage))),\n-    (symbols::thread_local, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                        \"thread_local\",\n+    (sym::thread_local, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                        sym::thread_local,\n                                         \"`#[thread_local]` is an experimental feature, and does \\\n                                          not currently handle destructors\",\n                                         cfg_fn!(thread_local))),\n \n-    (symbols::rustc_on_unimplemented, Whitelisted, template!(List:\n+    (sym::rustc_on_unimplemented, Whitelisted, template!(List:\n                         r#\"/*opt*/ message = \"...\", /*opt*/ label = \"...\", /*opt*/ note = \"...\"\"#,\n                         NameValueStr: \"message\"),\n                                             Gated(Stability::Unstable,\n-                                            \"on_unimplemented\",\n+                                            sym::on_unimplemented,\n                                             \"the `#[rustc_on_unimplemented]` attribute \\\n                                             is an experimental feature\",\n                                             cfg_fn!(on_unimplemented))),\n-    (symbols::rustc_const_unstable, Normal, template!(List: r#\"feature = \"name\"\"#),\n+    (sym::rustc_const_unstable, Normal, template!(List: r#\"feature = \"name\"\"#),\n                                             Gated(Stability::Unstable,\n-                                            \"rustc_const_unstable\",\n+                                            sym::rustc_const_unstable,\n                                             \"the `#[rustc_const_unstable]` attribute \\\n                                             is an internal feature\",\n                                             cfg_fn!(rustc_const_unstable))),\n-    (symbols::global_allocator, Normal, template!(Word), Ungated),\n-    (symbols::default_lib_allocator, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            \"allocator_internals\",\n+    (sym::global_allocator, Normal, template!(Word), Ungated),\n+    (sym::default_lib_allocator, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                            sym::allocator_internals,\n                                             \"the `#[default_lib_allocator]` \\\n                                             attribute is an experimental feature\",\n                                             cfg_fn!(allocator_internals))),\n-    (symbols::needs_allocator, Normal, template!(Word), Gated(Stability::Unstable,\n-                                    \"allocator_internals\",\n+    (sym::needs_allocator, Normal, template!(Word), Gated(Stability::Unstable,\n+                                    sym::allocator_internals,\n                                     \"the `#[needs_allocator]` \\\n                                     attribute is an experimental \\\n                                     feature\",\n                                     cfg_fn!(allocator_internals))),\n-    (symbols::panic_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                        \"panic_runtime\",\n+    (sym::panic_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                        sym::panic_runtime,\n                                         \"the `#[panic_runtime]` attribute is \\\n                                         an experimental feature\",\n                                         cfg_fn!(panic_runtime))),\n-    (symbols::needs_panic_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            \"needs_panic_runtime\",\n+    (sym::needs_panic_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                            sym::needs_panic_runtime,\n                                             \"the `#[needs_panic_runtime]` \\\n                                                 attribute is an experimental \\\n                                                 feature\",\n                                             cfg_fn!(needs_panic_runtime))),\n-    (symbols::rustc_outlives, Normal, template!(Word), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+    (sym::rustc_outlives, Normal, template!(Word), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_outlives]` attribute \\\n                                     is just used for rustc unit tests \\\n                                     and will never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_variance, Normal, template!(Word), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+    (sym::rustc_variance, Normal, template!(Word), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_variance]` attribute \\\n                                     is just used for rustc unit tests \\\n                                     and will never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_layout, Normal, template!(List: \"field1, field2, ...\"),\n+    (sym::rustc_layout, Normal, template!(List: \"field1, field2, ...\"),\n     Gated(Stability::Unstable,\n-        \"rustc_attrs\",\n+        sym::rustc_attrs,\n         \"the `#[rustc_layout]` attribute \\\n             is just used for rustc unit tests \\\n             and will never be stable\",\n         cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_layout_scalar_valid_range_start, Whitelisted, template!(List: \"value\"),\n+    (sym::rustc_layout_scalar_valid_range_start, Whitelisted, template!(List: \"value\"),\n     Gated(Stability::Unstable,\n-        \"rustc_attrs\",\n+        sym::rustc_attrs,\n         \"the `#[rustc_layout_scalar_valid_range_start]` attribute \\\n             is just used to enable niche optimizations in libcore \\\n             and will never be stable\",\n         cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_layout_scalar_valid_range_end, Whitelisted, template!(List: \"value\"),\n+    (sym::rustc_layout_scalar_valid_range_end, Whitelisted, template!(List: \"value\"),\n     Gated(Stability::Unstable,\n-        \"rustc_attrs\",\n+        sym::rustc_attrs,\n         \"the `#[rustc_layout_scalar_valid_range_end]` attribute \\\n             is just used to enable niche optimizations in libcore \\\n             and will never be stable\",\n         cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_regions, Normal, template!(Word), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+    (sym::rustc_regions, Normal, template!(Word), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_regions]` attribute \\\n                                     is just used for rustc unit tests \\\n                                     and will never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_error, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+    (sym::rustc_error, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_error]` attribute \\\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_dump_user_substs, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+    (sym::rustc_dump_user_substs, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n                                     \"this attribute \\\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_if_this_changed, Whitelisted, template!(Word, List: \"DepNode\"),\n+    (sym::rustc_if_this_changed, Whitelisted, template!(Word, List: \"DepNode\"),\n                                                 Gated(Stability::Unstable,\n-                                                \"rustc_attrs\",\n+                                                sym::rustc_attrs,\n                                                 \"the `#[rustc_if_this_changed]` attribute \\\n                                                 is just used for rustc unit tests \\\n                                                 and will never be stable\",\n                                                 cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_then_this_would_need, Whitelisted, template!(List: \"DepNode\"),\n+    (sym::rustc_then_this_would_need, Whitelisted, template!(List: \"DepNode\"),\n                                                     Gated(Stability::Unstable,\n-                                                    \"rustc_attrs\",\n+                                                    sym::rustc_attrs,\n                                                     \"the `#[rustc_if_this_changed]` attribute \\\n                                                     is just used for rustc unit tests \\\n                                                     and will never be stable\",\n                                                     cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_dirty, Whitelisted, template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\",\n+    (sym::rustc_dirty, Whitelisted, template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\",\n                                                     /*opt*/ except = \"...\"\"#),\n                                     Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_dirty]` attribute \\\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_clean, Whitelisted, template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\",\n+    (sym::rustc_clean, Whitelisted, template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\",\n                                                     /*opt*/ except = \"...\"\"#),\n                                     Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_clean]` attribute \\\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n     (\n-        symbols::rustc_partition_reused,\n+        sym::rustc_partition_reused,\n         Whitelisted,\n         template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n         Gated(\n             Stability::Unstable,\n-            \"rustc_attrs\",\n+            sym::rustc_attrs,\n             \"this attribute \\\n             is just used for rustc unit tests \\\n             and will never be stable\",\n             cfg_fn!(rustc_attrs)\n         )\n     ),\n     (\n-        symbols::rustc_partition_codegened,\n+        sym::rustc_partition_codegened,\n         Whitelisted,\n         template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n         Gated(\n             Stability::Unstable,\n-            \"rustc_attrs\",\n+            sym::rustc_attrs,\n             \"this attribute \\\n             is just used for rustc unit tests \\\n             and will never be stable\",\n             cfg_fn!(rustc_attrs),\n         )\n     ),\n-    (symbols::rustc_expected_cgu_reuse, Whitelisted, template!(List: r#\"cfg = \"...\", module = \"...\",\n+    (sym::rustc_expected_cgu_reuse, Whitelisted, template!(List: r#\"cfg = \"...\", module = \"...\",\n                                                             kind = \"...\"\"#),\n                                                     Gated(Stability::Unstable,\n-                                                    \"rustc_attrs\",\n+                                                    sym::rustc_attrs,\n                                                     \"this attribute \\\n                                                     is just used for rustc unit tests \\\n                                                     and will never be stable\",\n                                                     cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_synthetic, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                    \"rustc_attrs\",\n+    (sym::rustc_synthetic, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                    sym::rustc_attrs,\n                                                     \"this attribute \\\n                                                     is just used for rustc unit tests \\\n                                                     and will never be stable\",\n                                                     cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_symbol_name, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            \"rustc_attrs\",\n+    (sym::rustc_symbol_name, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                            sym::rustc_attrs,\n                                             \"internal rustc attributes will never be stable\",\n                                             cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_def_path, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                        \"rustc_attrs\",\n+    (sym::rustc_def_path, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                        sym::rustc_attrs,\n                                         \"internal rustc attributes will never be stable\",\n                                         cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_mir, Whitelisted, template!(List: \"arg1, arg2, ...\"), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+    (sym::rustc_mir, Whitelisted, template!(List: \"arg1, arg2, ...\"), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_mir]` attribute \\\n                                     is just used for rustc unit tests \\\n                                     and will never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n     (\n-        symbols::rustc_inherit_overflow_checks,\n+        sym::rustc_inherit_overflow_checks,\n         Whitelisted,\n         template!(Word),\n         Gated(\n             Stability::Unstable,\n-            \"rustc_attrs\",\n+            sym::rustc_attrs,\n             \"the `#[rustc_inherit_overflow_checks]` \\\n             attribute is just used to control \\\n             overflow checking behavior of several \\\n@@ -1251,166 +1251,166 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         )\n     ),\n \n-    (symbols::rustc_dump_program_clauses, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                    \"rustc_attrs\",\n+    (sym::rustc_dump_program_clauses, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                    sym::rustc_attrs,\n                                                     \"the `#[rustc_dump_program_clauses]` \\\n                                                     attribute is just used for rustc unit \\\n                                                     tests and will never be stable\",\n                                                     cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_test_marker, Normal, template!(Word), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+    (sym::rustc_test_marker, Normal, template!(Word), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_test_marker]` attribute \\\n                                     is used internally to track tests\",\n                                     cfg_fn!(rustc_attrs))),\n-    (symbols::rustc_transparent_macro, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                \"rustc_attrs\",\n+    (sym::rustc_transparent_macro, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                sym::rustc_attrs,\n                                                 \"used internally for testing macro hygiene\",\n                                                     cfg_fn!(rustc_attrs))),\n-    (symbols::compiler_builtins, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            \"compiler_builtins\",\n+    (sym::compiler_builtins, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                            sym::compiler_builtins,\n                                             \"the `#[compiler_builtins]` attribute is used to \\\n                                             identify the `compiler_builtins` crate which \\\n                                             contains compiler-rt intrinsics and will never be \\\n                                             stable\",\n                                         cfg_fn!(compiler_builtins))),\n-    (symbols::sanitizer_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            \"sanitizer_runtime\",\n+    (sym::sanitizer_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                            sym::sanitizer_runtime,\n                                             \"the `#[sanitizer_runtime]` attribute is used to \\\n                                             identify crates that contain the runtime of a \\\n                                             sanitizer and will never be stable\",\n                                             cfg_fn!(sanitizer_runtime))),\n-    (symbols::profiler_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            \"profiler_runtime\",\n+    (sym::profiler_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                            sym::profiler_runtime,\n                                             \"the `#[profiler_runtime]` attribute is used to \\\n                                             identify the `profiler_builtins` crate which \\\n                                             contains the profiler runtime and will never be \\\n                                             stable\",\n                                             cfg_fn!(profiler_runtime))),\n \n-    (symbols::allow_internal_unstable, Normal, template!(Word, List: \"feat1, feat2, ...\"),\n+    (sym::allow_internal_unstable, Normal, template!(Word, List: \"feat1, feat2, ...\"),\n                                             Gated(Stability::Unstable,\n-                                            \"allow_internal_unstable\",\n+                                            sym::allow_internal_unstable,\n                                             EXPLAIN_ALLOW_INTERNAL_UNSTABLE,\n                                             cfg_fn!(allow_internal_unstable))),\n \n-    (symbols::allow_internal_unsafe, Normal, template!(Word), Gated(Stability::Unstable,\n-                                            \"allow_internal_unsafe\",\n+    (sym::allow_internal_unsafe, Normal, template!(Word), Gated(Stability::Unstable,\n+                                            sym::allow_internal_unsafe,\n                                             EXPLAIN_ALLOW_INTERNAL_UNSAFE,\n                                             cfg_fn!(allow_internal_unsafe))),\n \n-    (symbols::fundamental, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                    \"fundamental\",\n+    (sym::fundamental, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                    sym::fundamental,\n                                     \"the `#[fundamental]` attribute \\\n                                         is an experimental feature\",\n                                     cfg_fn!(fundamental))),\n \n-    (symbols::proc_macro_derive, Normal, template!(List: \"TraitName, \\\n+    (sym::proc_macro_derive, Normal, template!(List: \"TraitName, \\\n                                                 /*opt*/ attributes(name1, name2, ...)\"),\n                                     Ungated),\n \n-    (symbols::rustc_copy_clone_marker, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                \"rustc_attrs\",\n+    (sym::rustc_copy_clone_marker, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                sym::rustc_attrs,\n                                                 \"internal implementation detail\",\n                                                 cfg_fn!(rustc_attrs))),\n \n     // FIXME: #14408 whitelist docs since rustdoc looks at them\n     (\n-        symbols::doc,\n+        sym::doc,\n         Whitelisted,\n         template!(List: \"hidden|inline|...\", NameValueStr: \"string\"),\n         Ungated\n     ),\n \n     // FIXME: #14406 these are processed in codegen, which happens after the\n     // lint pass\n-    (symbols::cold, Whitelisted, template!(Word), Ungated),\n-    (symbols::naked, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                \"naked_functions\",\n+    (sym::cold, Whitelisted, template!(Word), Ungated),\n+    (sym::naked, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                sym::naked_functions,\n                                 \"the `#[naked]` attribute \\\n                                 is an experimental feature\",\n                                 cfg_fn!(naked_functions))),\n-    (symbols::ffi_returns_twice, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                \"ffi_returns_twice\",\n+    (sym::ffi_returns_twice, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                sym::ffi_returns_twice,\n                                 \"the `#[ffi_returns_twice]` attribute \\\n                                 is an experimental feature\",\n                                 cfg_fn!(ffi_returns_twice))),\n-    (symbols::target_feature, Whitelisted, template!(List: r#\"enable = \"name\"\"#), Ungated),\n-    (symbols::export_name, Whitelisted, template!(NameValueStr: \"name\"), Ungated),\n-    (symbols::inline, Whitelisted, template!(Word, List: \"always|never\"), Ungated),\n-    (symbols::link, Whitelisted, template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\",\n+    (sym::target_feature, Whitelisted, template!(List: r#\"enable = \"name\"\"#), Ungated),\n+    (sym::export_name, Whitelisted, template!(NameValueStr: \"name\"), Ungated),\n+    (sym::inline, Whitelisted, template!(Word, List: \"always|never\"), Ungated),\n+    (sym::link, Whitelisted, template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\",\n                                                /*opt*/ cfg = \"...\"\"#), Ungated),\n-    (symbols::link_name, Whitelisted, template!(NameValueStr: \"name\"), Ungated),\n-    (symbols::link_section, Whitelisted, template!(NameValueStr: \"name\"), Ungated),\n-    (symbols::no_builtins, Whitelisted, template!(Word), Ungated),\n-    (symbols::no_debug, Whitelisted, template!(Word), Gated(\n+    (sym::link_name, Whitelisted, template!(NameValueStr: \"name\"), Ungated),\n+    (sym::link_section, Whitelisted, template!(NameValueStr: \"name\"), Ungated),\n+    (sym::no_builtins, Whitelisted, template!(Word), Ungated),\n+    (sym::no_debug, Whitelisted, template!(Word), Gated(\n         Stability::Deprecated(\"https://github.com/rust-lang/rust/issues/29721\", None),\n-        \"no_debug\",\n+        sym::no_debug,\n         \"the `#[no_debug]` attribute was an experimental feature that has been \\\n         deprecated due to lack of demand\",\n         cfg_fn!(no_debug))),\n     (\n-        symbols::omit_gdb_pretty_printer_section,\n+        sym::omit_gdb_pretty_printer_section,\n         Whitelisted,\n         template!(Word),\n         Gated(\n             Stability::Unstable,\n-            \"omit_gdb_pretty_printer_section\",\n+            sym::omit_gdb_pretty_printer_section,\n             \"the `#[omit_gdb_pretty_printer_section]` \\\n                 attribute is just used for the Rust test \\\n                 suite\",\n             cfg_fn!(omit_gdb_pretty_printer_section)\n         )\n     ),\n-    (symbols::unsafe_destructor_blind_to_params,\n+    (sym::unsafe_destructor_blind_to_params,\n     Normal,\n     template!(Word),\n     Gated(Stability::Deprecated(\"https://github.com/rust-lang/rust/issues/34761\",\n                                 Some(\"replace this attribute with `#[may_dangle]`\")),\n-        \"dropck_parametricity\",\n+        sym::dropck_parametricity,\n         \"unsafe_destructor_blind_to_params has been replaced by \\\n             may_dangle and will be removed in the future\",\n         cfg_fn!(dropck_parametricity))),\n-    (symbols::may_dangle,\n+    (sym::may_dangle,\n     Normal,\n     template!(Word),\n     Gated(Stability::Unstable,\n-        \"dropck_eyepatch\",\n+        sym::dropck_eyepatch,\n         \"may_dangle has unstable semantics and may be removed in the future\",\n         cfg_fn!(dropck_eyepatch))),\n-    (symbols::unwind, Whitelisted, template!(List: \"allowed|aborts\"), Gated(Stability::Unstable,\n-                                \"unwind_attributes\",\n+    (sym::unwind, Whitelisted, template!(List: \"allowed|aborts\"), Gated(Stability::Unstable,\n+                                sym::unwind_attributes,\n                                 \"#[unwind] is experimental\",\n                                 cfg_fn!(unwind_attributes))),\n-    (symbols::used, Whitelisted, template!(Word), Ungated),\n+    (sym::used, Whitelisted, template!(Word), Ungated),\n \n     // used in resolve\n-    (symbols::prelude_import, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                        \"prelude_import\",\n+    (sym::prelude_import, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                        sym::prelude_import,\n                                         \"`#[prelude_import]` is for use by rustc only\",\n                                         cfg_fn!(prelude_import))),\n \n     // FIXME: #14407 these are only looked at on-demand so we can't\n     // guarantee they'll have already been checked\n     (\n-        symbols::rustc_deprecated,\n+        sym::rustc_deprecated,\n         Whitelisted,\n         template!(List: r#\"since = \"version\", reason = \"...\"\"#),\n         Ungated\n     ),\n-    (symbols::must_use, Whitelisted, template!(Word, NameValueStr: \"reason\"), Ungated),\n+    (sym::must_use, Whitelisted, template!(Word, NameValueStr: \"reason\"), Ungated),\n     (\n-        symbols::stable,\n+        sym::stable,\n         Whitelisted,\n         template!(List: r#\"feature = \"name\", since = \"version\"\"#),\n         Ungated\n     ),\n     (\n-        symbols::unstable,\n+        sym::unstable,\n         Whitelisted,\n         template!(List: r#\"feature = \"name\", reason = \"...\", issue = \"N\"\"#),\n         Ungated\n     ),\n-    (symbols::deprecated,\n+    (sym::deprecated,\n         Normal,\n         template!(\n             Word,\n@@ -1420,70 +1420,71 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         Ungated\n     ),\n \n-    (symbols::rustc_paren_sugar, Normal, template!(Word), Gated(Stability::Unstable,\n-                                        \"unboxed_closures\",\n+    (sym::rustc_paren_sugar, Normal, template!(Word), Gated(Stability::Unstable,\n+                                        sym::unboxed_closures,\n                                         \"unboxed_closures are still evolving\",\n                                         cfg_fn!(unboxed_closures))),\n \n-    (symbols::windows_subsystem, Whitelisted, template!(NameValueStr: \"windows|console\"), Ungated),\n+    (sym::windows_subsystem, Whitelisted, template!(NameValueStr: \"windows|console\"), Ungated),\n \n-    (symbols::proc_macro_attribute, Normal, template!(Word), Ungated),\n-    (symbols::proc_macro, Normal, template!(Word), Ungated),\n+    (sym::proc_macro_attribute, Normal, template!(Word), Ungated),\n+    (sym::proc_macro, Normal, template!(Word), Ungated),\n \n-    (symbols::rustc_proc_macro_decls, Normal, template!(Word), Gated(Stability::Unstable,\n-                                            \"rustc_attrs\",\n+    (sym::rustc_proc_macro_decls, Normal, template!(Word), Gated(Stability::Unstable,\n+                                            sym::rustc_attrs,\n                                             \"used internally by rustc\",\n                                             cfg_fn!(rustc_attrs))),\n \n-    (symbols::allow_fail, Normal, template!(Word), Gated(Stability::Unstable,\n-                                \"allow_fail\",\n+    (sym::allow_fail, Normal, template!(Word), Gated(Stability::Unstable,\n+                                sym::allow_fail,\n                                 \"allow_fail attribute is currently unstable\",\n                                 cfg_fn!(allow_fail))),\n \n-    (symbols::rustc_std_internal_symbol, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+    (sym::rustc_std_internal_symbol, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n                                     \"this is an internal attribute that will \\\n                                     never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n \n     // whitelists \"identity-like\" conversion methods to suggest on type mismatch\n-    (symbols::rustc_conversion_suggestion, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                    \"rustc_attrs\",\n+    (sym::rustc_conversion_suggestion, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                    sym::rustc_attrs,\n                                                     \"this is an internal attribute that will \\\n                                                         never be stable\",\n                                                     cfg_fn!(rustc_attrs))),\n \n     (\n-        symbols::rustc_args_required_const,\n+        sym::rustc_args_required_const,\n         Whitelisted,\n         template!(List: \"N\"),\n-        Gated(Stability::Unstable, \"rustc_attrs\", \"never will be stable\", cfg_fn!(rustc_attrs))\n+        Gated(Stability::Unstable, sym::rustc_attrs, \"never will be stable\",\n+           cfg_fn!(rustc_attrs))\n     ),\n     // RFC 2070\n-    (symbols::panic_handler, Normal, template!(Word), Ungated),\n+    (sym::panic_handler, Normal, template!(Word), Ungated),\n \n-    (symbols::alloc_error_handler, Normal, template!(Word), Gated(Stability::Unstable,\n-                        \"alloc_error_handler\",\n+    (sym::alloc_error_handler, Normal, template!(Word), Gated(Stability::Unstable,\n+                        sym::alloc_error_handler,\n                         \"#[alloc_error_handler] is an unstable feature\",\n                         cfg_fn!(alloc_error_handler))),\n \n     // RFC 2412\n-    (symbols::optimize, Whitelisted, template!(List: \"size|speed\"), Gated(Stability::Unstable,\n-                            \"optimize_attribute\",\n+    (sym::optimize, Whitelisted, template!(List: \"size|speed\"), Gated(Stability::Unstable,\n+                            sym::optimize_attribute,\n                             \"#[optimize] attribute is an unstable feature\",\n                             cfg_fn!(optimize_attribute))),\n \n     // Crate level attributes\n-    (symbols::crate_name, CrateLevel, template!(NameValueStr: \"name\"), Ungated),\n-    (symbols::crate_type, CrateLevel, template!(NameValueStr: \"bin|lib|...\"), Ungated),\n-    (symbols::crate_id, CrateLevel, template!(NameValueStr: \"ignored\"), Ungated),\n-    (symbols::feature, CrateLevel, template!(List: \"name1, name1, ...\"), Ungated),\n-    (symbols::no_start, CrateLevel, template!(Word), Ungated),\n-    (symbols::no_main, CrateLevel, template!(Word), Ungated),\n-    (symbols::recursion_limit, CrateLevel, template!(NameValueStr: \"N\"), Ungated),\n-    (symbols::type_length_limit, CrateLevel, template!(NameValueStr: \"N\"), Ungated),\n-    (symbols::test_runner, CrateLevel, template!(List: \"path\"), Gated(Stability::Unstable,\n-                    \"custom_test_frameworks\",\n+    (sym::crate_name, CrateLevel, template!(NameValueStr: \"name\"), Ungated),\n+    (sym::crate_type, CrateLevel, template!(NameValueStr: \"bin|lib|...\"), Ungated),\n+    (sym::crate_id, CrateLevel, template!(NameValueStr: \"ignored\"), Ungated),\n+    (sym::feature, CrateLevel, template!(List: \"name1, name1, ...\"), Ungated),\n+    (sym::no_start, CrateLevel, template!(Word), Ungated),\n+    (sym::no_main, CrateLevel, template!(Word), Ungated),\n+    (sym::recursion_limit, CrateLevel, template!(NameValueStr: \"N\"), Ungated),\n+    (sym::type_length_limit, CrateLevel, template!(NameValueStr: \"N\"), Ungated),\n+    (sym::test_runner, CrateLevel, template!(List: \"path\"), Gated(Stability::Unstable,\n+                    sym::custom_test_frameworks,\n                     EXPLAIN_CUSTOM_TEST_FRAMEWORKS,\n                     cfg_fn!(custom_test_frameworks))),\n ];\n@@ -1503,11 +1504,11 @@ lazy_static! {\n }\n \n // cfg(...)'s that are feature gated\n-const GATED_CFGS: &[(&str, &str, fn(&Features) -> bool)] = &[\n+const GATED_CFGS: &[(Symbol, Symbol, fn(&Features) -> bool)] = &[\n     // (name in cfg, feature, function to check if the feature is enabled)\n-    (\"target_thread_local\", \"cfg_target_thread_local\", cfg_fn!(cfg_target_thread_local)),\n-    (\"target_has_atomic\", \"cfg_target_has_atomic\", cfg_fn!(cfg_target_has_atomic)),\n-    (\"rustdoc\", \"doc_cfg\", cfg_fn!(doc_cfg)),\n+    (sym::target_thread_local, sym::cfg_target_thread_local, cfg_fn!(cfg_target_thread_local)),\n+    (sym::target_has_atomic, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n+    (sym::rustdoc, sym::doc_cfg, cfg_fn!(doc_cfg)),\n ];\n \n #[derive(Debug)]\n@@ -1540,7 +1541,7 @@ impl GatedCfg {\n struct Context<'a> {\n     features: &'a Features,\n     parse_sess: &'a ParseSess,\n-    plugin_attributes: &'a [(String, AttributeType)],\n+    plugin_attributes: &'a [(Symbol, AttributeType)],\n }\n \n macro_rules! gate_feature_fn {\n@@ -1559,11 +1560,11 @@ macro_rules! gate_feature_fn {\n macro_rules! gate_feature {\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {\n         gate_feature_fn!($cx, |x:&Features| x.$feature, $span,\n-                         stringify!($feature), $explain, GateStrength::Hard)\n+                         sym::$feature, $explain, GateStrength::Hard)\n     };\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {\n         gate_feature_fn!($cx, |x:&Features| x.$feature, $span,\n-                         stringify!($feature), $explain, $level)\n+                         sym::$feature, $explain, $level)\n     };\n }\n \n@@ -1582,9 +1583,9 @@ impl<'a> Context<'a> {\n                         self, has_feature, attr.span, name, desc, GateStrength::Hard\n                     );\n                 }\n-            } else if name == symbols::doc {\n+            } else if name == sym::doc {\n                 if let Some(content) = attr.meta_item_list() {\n-                    if content.iter().any(|c| c.check_name(symbols::include)) {\n+                    if content.iter().any(|c| c.check_name(sym::include)) {\n                         gate_feature!(self, external_doc, attr.span,\n                             \"#[doc(include = \\\"...\\\")] is experimental\"\n                         );\n@@ -1594,8 +1595,8 @@ impl<'a> Context<'a> {\n             debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", attr.path, ty, gateage);\n             return;\n         }\n-        for &(ref n, ref ty) in self.plugin_attributes {\n-            if attr.path == &**n {\n+        for &(n, ty) in self.plugin_attributes {\n+            if attr.path == n {\n                 // Plugins can't gate attributes, so we don't check for it\n                 // unlike the code above; we only use this loop to\n                 // short-circuit to avoid the checks below.\n@@ -1604,7 +1605,7 @@ impl<'a> Context<'a> {\n             }\n         }\n         if !attr::is_known(attr) {\n-            if attr.name_or_empty().starts_with(\"rustc_\") {\n+            if attr.name_or_empty().as_str().starts_with(\"rustc_\") {\n                 let msg = \"unless otherwise specified, attributes with the prefix `rustc_` \\\n                            are reserved for internal compiler diagnostics\";\n                 gate_feature!(self, rustc_attrs, attr.span, msg);\n@@ -1629,7 +1630,7 @@ pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features:\n     );\n }\n \n-fn find_lang_feature_issue(feature: &str) -> Option<u32> {\n+fn find_lang_feature_issue(feature: Symbol) -> Option<u32> {\n     if let Some(info) = ACTIVE_FEATURES.iter().find(|t| t.0 == feature) {\n         let issue = info.2;\n         // FIXME (#28244): enforce that active features have issue numbers\n@@ -1661,7 +1662,7 @@ pub enum GateStrength {\n \n pub fn emit_feature_err(\n     sess: &ParseSess,\n-    feature: &str,\n+    feature: Symbol,\n     span: Span,\n     issue: GateIssue,\n     explain: &str,\n@@ -1671,7 +1672,7 @@ pub fn emit_feature_err(\n \n pub fn feature_err<'a>(\n     sess: &'a ParseSess,\n-    feature: &str,\n+    feature: Symbol,\n     span: Span,\n     issue: GateIssue,\n     explain: &str,\n@@ -1681,7 +1682,7 @@ pub fn feature_err<'a>(\n \n fn leveled_feature_err<'a>(\n     sess: &'a ParseSess,\n-    feature: &str,\n+    feature: Symbol,\n     span: Span,\n     issue: GateIssue,\n     explain: &str,\n@@ -1769,13 +1770,13 @@ struct PostExpansionVisitor<'a> {\n macro_rules! gate_feature_post {\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {{\n         let (cx, span) = ($cx, $span);\n-        if !span.allows_unstable(stringify!($feature)) {\n+        if !span.allows_unstable(sym::$feature) {\n             gate_feature!(cx.context, $feature, span, $explain)\n         }\n     }};\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {{\n         let (cx, span) = ($cx, $span);\n-        if !span.allows_unstable(stringify!($feature)) {\n+        if !span.allows_unstable(sym::$feature) {\n             gate_feature!(cx.context, $feature, span, $explain, $level)\n         }\n     }}\n@@ -1841,11 +1842,11 @@ impl<'a> PostExpansionVisitor<'a> {\n                                template: AttributeTemplate) {\n         // Some special attributes like `cfg` must be checked\n         // before the generic check, so we skip them here.\n-        let should_skip = |name| name == symbols::cfg;\n+        let should_skip = |name| name == sym::cfg;\n         // Some of previously accepted forms were used in practice,\n         // report them as warnings for now.\n-        let should_warn = |name| name == symbols::doc || name == symbols::ignore ||\n-                                 name == symbols::inline || name == symbols::link;\n+        let should_warn = |name| name == sym::doc || name == sym::ignore ||\n+                                 name == sym::inline || name == sym::link;\n \n         match attr.parse_meta(self.context.parse_sess) {\n             Ok(meta) => if !should_skip(name) && !template.compatible(&meta.node) {\n@@ -1893,25 +1894,25 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         // check for gated attributes\n         self.context.check_attribute(attr, attr_info, false);\n \n-        if attr.check_name(symbols::doc) {\n+        if attr.check_name(sym::doc) {\n             if let Some(content) = attr.meta_item_list() {\n-                if content.len() == 1 && content[0].check_name(symbols::cfg) {\n+                if content.len() == 1 && content[0].check_name(sym::cfg) {\n                     gate_feature_post!(&self, doc_cfg, attr.span,\n                         \"#[doc(cfg(...))] is experimental\"\n                     );\n-                } else if content.iter().any(|c| c.check_name(symbols::masked)) {\n+                } else if content.iter().any(|c| c.check_name(sym::masked)) {\n                     gate_feature_post!(&self, doc_masked, attr.span,\n                         \"#[doc(masked)] is experimental\"\n                     );\n-                } else if content.iter().any(|c| c.check_name(symbols::spotlight)) {\n+                } else if content.iter().any(|c| c.check_name(sym::spotlight)) {\n                     gate_feature_post!(&self, doc_spotlight, attr.span,\n                         \"#[doc(spotlight)] is experimental\"\n                     );\n-                } else if content.iter().any(|c| c.check_name(symbols::alias)) {\n+                } else if content.iter().any(|c| c.check_name(sym::alias)) {\n                     gate_feature_post!(&self, doc_alias, attr.span,\n                         \"#[doc(alias = \\\"...\\\")] is experimental\"\n                     );\n-                } else if content.iter().any(|c| c.check_name(symbols::keyword)) {\n+                } else if content.iter().any(|c| c.check_name(sym::keyword)) {\n                     gate_feature_post!(&self, doc_keyword, attr.span,\n                         \"#[doc(keyword = \\\"...\\\")] is experimental\"\n                     );\n@@ -1946,7 +1947,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_item(&mut self, i: &'a ast::Item) {\n         match i.node {\n             ast::ItemKind::Const(_,_) => {\n-                if i.ident.name == \"_\" {\n+                if i.ident.name == keywords::Underscore.name() {\n                     gate_feature_post!(&self, underscore_const_names, i.span,\n                                         \"naming constants with `_` is unstable\");\n                 }\n@@ -1957,17 +1958,17 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Fn(..) => {\n-                if attr::contains_name(&i.attrs[..], \"plugin_registrar\") {\n+                if attr::contains_name(&i.attrs[..], sym::plugin_registrar) {\n                     gate_feature_post!(&self, plugin_registrar, i.span,\n                                        \"compiler plugins are experimental and possibly buggy\");\n                 }\n-                if attr::contains_name(&i.attrs[..], \"start\") {\n+                if attr::contains_name(&i.attrs[..], sym::start) {\n                     gate_feature_post!(&self, start, i.span,\n                                       \"a #[start] function is an experimental \\\n                                        feature whose signature may change \\\n                                        over time\");\n                 }\n-                if attr::contains_name(&i.attrs[..], \"main\") {\n+                if attr::contains_name(&i.attrs[..], sym::main) {\n                     gate_feature_post!(&self, main, i.span,\n                                        \"declaration of a nonstandard #[main] \\\n                                         function may change over time, for now \\\n@@ -1976,9 +1977,9 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Struct(..) => {\n-                for attr in attr::filter_by_name(&i.attrs[..], \"repr\") {\n+                for attr in attr::filter_by_name(&i.attrs[..], sym::repr) {\n                     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-                        if item.check_name(symbols::simd) {\n+                        if item.check_name(sym::simd) {\n                             gate_feature_post!(&self, repr_simd, attr.span,\n                                                \"SIMD types are experimental and possibly buggy\");\n                         }\n@@ -1987,9 +1988,9 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Enum(..) => {\n-                for attr in attr::filter_by_name(&i.attrs[..], \"repr\") {\n+                for attr in attr::filter_by_name(&i.attrs[..], sym::repr) {\n                     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-                        if item.check_name(symbols::align) {\n+                        if item.check_name(sym::align) {\n                             gate_feature_post!(&self, repr_align_enum, attr.span,\n                                                \"`#[repr(align(x))]` on enums is experimental\");\n                         }\n@@ -2051,7 +2052,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         match i.node {\n             ast::ForeignItemKind::Fn(..) |\n             ast::ForeignItemKind::Static(..) => {\n-                let link_name = attr::first_attr_value_str_by_name(&i.attrs, \"link_name\");\n+                let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n                 let links_to_llvm = match link_name {\n                     Some(val) => val.as_str().starts_with(\"llvm.\"),\n                     _ => false\n@@ -2303,23 +2304,23 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n         if edition <= crate_edition {\n             // The `crate_edition` implies its respective umbrella feature-gate\n             // (i.e., `#![feature(rust_20XX_preview)]` isn't needed on edition 20XX).\n-            edition_enabled_features.insert(Symbol::intern(edition.feature_name()), edition);\n+            edition_enabled_features.insert(edition.feature_name(), edition);\n         }\n     }\n \n     for &(name, .., f_edition, set) in ACTIVE_FEATURES {\n         if let Some(f_edition) = f_edition {\n             if f_edition <= crate_edition {\n                 set(&mut features, DUMMY_SP);\n-                edition_enabled_features.insert(Symbol::intern(name), crate_edition);\n+                edition_enabled_features.insert(name, crate_edition);\n             }\n         }\n     }\n \n     // Process the edition umbrella feature-gates first, to ensure\n     // `edition_enabled_features` is completed before it's queried.\n     for attr in krate_attrs {\n-        if !attr.check_name(symbols::feature) {\n+        if !attr.check_name(sym::feature) {\n             continue\n         }\n \n@@ -2355,7 +2356,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n                             // FIXME(Manishearth) there is currently no way to set\n                             // lib features by edition\n                             set(&mut features, DUMMY_SP);\n-                            edition_enabled_features.insert(Symbol::intern(name), *edition);\n+                            edition_enabled_features.insert(name, *edition);\n                         }\n                     }\n                 }\n@@ -2364,7 +2365,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n     }\n \n     for attr in krate_attrs {\n-        if !attr.check_name(symbols::feature) {\n+        if !attr.check_name(sym::feature) {\n             continue\n         }\n \n@@ -2438,7 +2439,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n pub fn check_crate(krate: &ast::Crate,\n                    sess: &ParseSess,\n                    features: &Features,\n-                   plugin_attributes: &[(String, AttributeType)],\n+                   plugin_attributes: &[(Symbol, AttributeType)],\n                    unstable: UnstableFeatures) {\n     maybe_stage_features(&sess.span_diagnostic, krate, unstable);\n     let ctx = Context {\n@@ -2496,7 +2497,7 @@ fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate,\n     };\n     if !allow_features {\n         for attr in &krate.attrs {\n-            if attr.check_name(symbols::feature) {\n+            if attr.check_name(sym::feature) {\n                 let release_channel = option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\");\n                 span_err!(span_handler, attr.span, E0554,\n                           \"#![feature] may not be used on the {} release channel\","}, {"sha": "655baafcd2d5da34fb68303152b337efd8cfa064", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -391,6 +391,8 @@ mod tests {\n     #[test]\n     fn string_to_tts_macro () {\n         with_globals(|| {\n+            use crate::symbol::sym;\n+\n             let tts: Vec<_> =\n                 string_to_stream(\"macro_rules! zip (($a)=>($a))\".to_string()).trees().collect();\n             let tts: &[TokenTree] = &tts[..];\n@@ -403,8 +405,8 @@ mod tests {\n                     Some(&TokenTree::Token(_, token::Ident(name_zip, false))),\n                     Some(&TokenTree::Delimited(_, macro_delim, ref macro_tts)),\n                 )\n-                if name_macro_rules.name == \"macro_rules\"\n-                && name_zip.name == \"zip\" => {\n+                if name_macro_rules.name == sym::macro_rules\n+                && name_zip.name.as_str() == \"zip\" => {\n                     let tts = &macro_tts.trees().collect::<Vec<_>>();\n                     match (tts.len(), tts.get(0), tts.get(1), tts.get(2)) {\n                         (\n@@ -421,7 +423,7 @@ mod tests {\n                                     Some(&TokenTree::Token(_, token::Dollar)),\n                                     Some(&TokenTree::Token(_, token::Ident(ident, false))),\n                                 )\n-                                if first_delim == token::Paren && ident.name == \"a\" => {},\n+                                if first_delim == token::Paren && ident.name.as_str() == \"a\" => {},\n                                 _ => panic!(\"value 3: {:?} {:?}\", first_delim, first_tts),\n                             }\n                             let tts = &second_tts.trees().collect::<Vec<_>>();\n@@ -431,7 +433,7 @@ mod tests {\n                                     Some(&TokenTree::Token(_, token::Dollar)),\n                                     Some(&TokenTree::Token(_, token::Ident(ident, false))),\n                                 )\n-                                if second_delim == token::Paren && ident.name == \"a\" => {},\n+                                if second_delim == token::Paren && ident.name.as_str() == \"a\" => {},\n                                 _ => panic!(\"value 4: {:?} {:?}\", second_delim, second_tts),\n                             }\n                         },\n@@ -575,29 +577,31 @@ mod tests {\n \n     #[test] fn crlf_doc_comments() {\n         with_globals(|| {\n+            use crate::symbol::sym;\n+\n             let sess = ParseSess::new(FilePathMapping::empty());\n \n             let name_1 = FileName::Custom(\"crlf_source_1\".to_string());\n             let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n             let item = parse_item_from_source_str(name_1, source, &sess)\n                 .unwrap().unwrap();\n-            let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n-            assert_eq!(doc, \"/// doc comment\");\n+            let doc = first_attr_value_str_by_name(&item.attrs, sym::doc).unwrap();\n+            assert_eq!(doc.as_str(), \"/// doc comment\");\n \n             let name_2 = FileName::Custom(\"crlf_source_2\".to_string());\n             let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n             let item = parse_item_from_source_str(name_2, source, &sess)\n                 .unwrap().unwrap();\n-            let docs = item.attrs.iter().filter(|a| a.path == \"doc\")\n+            let docs = item.attrs.iter().filter(|a| a.path == sym::doc)\n                         .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n             let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n             assert_eq!(&docs[..], b);\n \n             let name_3 = FileName::Custom(\"clrf_source_3\".to_string());\n             let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n             let item = parse_item_from_source_str(name_3, source, &sess).unwrap().unwrap();\n-            let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n-            assert_eq!(doc, \"/** doc comment\\n *  with CRLF */\");\n+            let doc = first_attr_value_str_by_name(&item.attrs, sym::doc).unwrap();\n+            assert_eq!(doc.as_str(), \"/** doc comment\\n *  with CRLF */\");\n         });\n     }\n "}, {"sha": "2d6c8c540758322cd83924e180f78f59e99cc408", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -46,7 +46,7 @@ use crate::ptr::P;\n use crate::parse::PResult;\n use crate::ThinVec;\n use crate::tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n-use crate::symbol::{keywords, Symbol};\n+use crate::symbol::{keywords, sym, Symbol};\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n use rustc_target::spec::abi::{self, Abi};\n@@ -5084,7 +5084,7 @@ impl<'a> Parser<'a> {\n \n                 (ident, ast::MacroDef { tokens: tokens.into(), legacy: false })\n             }\n-            token::Ident(ident, _) if ident.name == \"macro_rules\" &&\n+            token::Ident(ident, _) if ident.name == sym::macro_rules &&\n                                    self.look_ahead(1, |t| *t == token::Not) => {\n                 let prev_span = self.prev_span;\n                 self.complain_if_pub_macro(&vis.node, prev_span);\n@@ -7244,7 +7244,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n-        if let Some(path) = attr::first_attr_value_str_by_name(attrs, \"path\") {\n+        if let Some(path) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n             self.directory.path.to_mut().push(&path.as_str());\n             self.directory.ownership = DirectoryOwnership::Owned { relative: None };\n         } else {\n@@ -7264,7 +7264,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn submod_path_from_attr(attrs: &[Attribute], dir_path: &Path) -> Option<PathBuf> {\n-        if let Some(s) = attr::first_attr_value_str_by_name(attrs, \"path\") {\n+        if let Some(s) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n             let s = s.as_str();\n \n             // On windows, the base path might have the form"}, {"sha": "f08fdcc6fb53cd9a58b898b78a9000a9ece7532b", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -2,7 +2,7 @@ use crate::ast;\n use crate::attr;\n use crate::edition::Edition;\n use crate::ext::hygiene::{Mark, SyntaxContext};\n-use crate::symbol::{Symbol, keywords};\n+use crate::symbol::{Symbol, keywords, sym};\n use crate::source_map::{ExpnInfo, MacroAttribute, dummy_spanned, hygiene, respan};\n use crate::ptr::P;\n use crate::tokenstream::TokenStream;\n@@ -35,6 +35,9 @@ pub fn injected_crate_name() -> Option<&'static str> {\n }\n \n thread_local! {\n+    // A `Symbol` might make more sense here, but it doesn't work, probably for\n+    // reasons relating to the use of thread-local storage for the Symbol\n+    // interner.\n     static INJECTED_CRATE_NAME: Cell<Option<&'static str>> = Cell::new(None);\n }\n \n@@ -46,10 +49,10 @@ pub fn maybe_inject_crates_ref(\n     let rust_2018 = edition >= Edition::Edition2018;\n \n     // the first name in this list is the crate name of the crate with the prelude\n-    let names: &[&str] = if attr::contains_name(&krate.attrs, \"no_core\") {\n+    let names: &[&str] = if attr::contains_name(&krate.attrs, sym::no_core) {\n         return krate;\n-    } else if attr::contains_name(&krate.attrs, \"no_std\") {\n-        if attr::contains_name(&krate.attrs, \"compiler_builtins\") {\n+    } else if attr::contains_name(&krate.attrs, sym::no_std) {\n+        if attr::contains_name(&krate.attrs, sym::compiler_builtins) {\n             &[\"core\"]\n         } else {\n             &[\"core\", \"compiler_builtins\"]"}, {"sha": "21bc236d00e6b805dd62ec546460598d0c90849b", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -29,7 +29,7 @@ use crate::parse::{token, ParseSess};\n use crate::print::pprust;\n use crate::ast::{self, Ident};\n use crate::ptr::P;\n-use crate::symbol::{self, Symbol, keywords};\n+use crate::symbol::{self, Symbol, keywords, sym};\n use crate::ThinVec;\n \n struct Test {\n@@ -65,8 +65,7 @@ pub fn modify_for_testing(sess: &ParseSess,\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n-        attr::first_attr_value_str_by_name(&krate.attrs,\n-                                           \"reexport_test_harness_main\");\n+        attr::first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n \n     // Do this here so that the test_runner crate attribute gets marked as used\n     // even in non-test builds\n@@ -185,7 +184,7 @@ impl MutVisitor for EntryPointCleaner {\n                         ident,\n                         attrs: attrs.into_iter()\n                             .filter(|attr| {\n-                                !attr.check_name(\"main\") && !attr.check_name(\"start\")\n+                                !attr.check_name(sym::main) && !attr.check_name(sym::start)\n                             })\n                             .chain(iter::once(allow_dead_code))\n                             .collect(),\n@@ -273,7 +272,8 @@ fn generate_test_harness(sess: &ParseSess,\n         test_cases: Vec::new(),\n         reexport_test_harness_main,\n         // N.B., doesn't consider the value of `--crate-name` passed on the command line.\n-        is_libtest: attr::find_crate_name(&krate.attrs).map(|s| s == \"test\").unwrap_or(false),\n+        is_libtest: attr::find_crate_name(&krate.attrs)\n+            .map(|s| s == sym::test).unwrap_or(false),\n         toplevel_reexport: None,\n         ctxt: SyntaxContext::empty().apply_mark(mark),\n         features,\n@@ -428,11 +428,11 @@ fn visible_path(cx: &TestCtxt<'_>, path: &[Ident]) -> Vec<Ident>{\n }\n \n fn is_test_case(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, \"rustc_test_marker\")\n+    attr::contains_name(&i.attrs, sym::rustc_test_marker)\n }\n \n fn get_test_runner(sd: &errors::Handler, krate: &ast::Crate) -> Option<ast::Path> {\n-    let test_attr = attr::find_by_name(&krate.attrs, \"test_runner\")?;\n+    let test_attr = attr::find_by_name(&krate.attrs, sym::test_runner)?;\n     test_attr.meta_item_list().map(|meta_list| {\n         if meta_list.len() != 1 {\n             sd.span_fatal(test_attr.span,"}, {"sha": "b8e89c3ecf8762191b77c84cd88ca3416f98a956", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -11,7 +11,7 @@ use syntax::ext::base::{self, *};\n use syntax::feature_gate;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::ast::AsmDialect;\n use syntax_pos::Span;\n use syntax::tokenstream;\n@@ -39,15 +39,15 @@ impl State {\n     }\n }\n \n-const OPTIONS: &[&str] = &[\"volatile\", \"alignstack\", \"intel\"];\n+const OPTIONS: &[Symbol] = &[sym::volatile, sym::alignstack, sym::intel];\n \n pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                        sp: Span,\n                        tts: &[tokenstream::TokenTree])\n                        -> Box<dyn base::MacResult + 'cx> {\n     if !cx.ecfg.enable_asm() {\n         feature_gate::emit_feature_err(&cx.parse_sess,\n-                                       \"asm\",\n+                                       sym::asm,\n                                        sp,\n                                        feature_gate::GateIssue::Language,\n                                        feature_gate::EXPLAIN_ASM);\n@@ -233,13 +233,13 @@ fn parse_inline_asm<'a>(\n             Options => {\n                 let (option, _) = p.parse_str()?;\n \n-                if option == \"volatile\" {\n+                if option == sym::volatile {\n                     // Indicates that the inline assembly has side effects\n                     // and must not be optimized out along with its outputs.\n                     volatile = true;\n-                } else if option == \"alignstack\" {\n+                } else if option == sym::alignstack {\n                     alignstack = true;\n-                } else if option == \"intel\" {\n+                } else if option == sym::intel {\n                     dialect = AsmDialect::Intel;\n                 } else {\n                     cx.span_warn(p.prev_span, \"unrecognized option\");"}, {"sha": "77c53f402cc9f03b7f21bdea386aa457ac368d2d", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -6,7 +6,7 @@ use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::Span;\n-use syntax_pos::symbol::Symbol;\n+use syntax_pos::symbol::{Symbol, sym};\n use syntax::tokenstream::TokenTree;\n \n pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt<'_>,\n@@ -15,7 +15,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                               -> Box<dyn base::MacResult + 'cx> {\n     if !cx.ecfg.enable_concat_idents() {\n         feature_gate::emit_feature_err(&cx.parse_sess,\n-                                       \"concat_idents\",\n+                                       sym::concat_idents,\n                                        sp,\n                                        feature_gate::GateIssue::Language,\n                                        feature_gate::EXPLAIN_CONCAT_IDENTS);"}, {"sha": "1b0d572324a7924dada216e2d413e2dfd9aedee6", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -7,7 +7,7 @@ use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::{Symbol, keywords, sym};\n use syntax_pos::Span;\n \n pub fn expand_deriving_clone(cx: &mut ExtCtxt<'_>,\n@@ -37,7 +37,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt<'_>,\n             match annitem.node {\n                 ItemKind::Struct(_, Generics { ref params, .. }) |\n                 ItemKind::Enum(_, Generics { ref params, .. }) => {\n-                    if attr::contains_name(&annitem.attrs, \"rustc_copy_clone_marker\") &&\n+                    if attr::contains_name(&annitem.attrs, sym::rustc_copy_clone_marker) &&\n                         !params.iter().any(|param| match param.kind {\n                             ast::GenericParamKind::Type { .. } => true,\n                             _ => false,"}, {"sha": "a13dc07085f809403946684e4c03c129fa0858a6", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -191,7 +191,7 @@ use syntax::ext::build::AstBuilder;\n use syntax::source_map::{self, respan};\n use syntax::util::map_in_place::MapInPlace;\n use syntax::ptr::P;\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::{Symbol, keywords, sym};\n use syntax::parse::ParseSess;\n use syntax_pos::{DUMMY_SP, Span};\n \n@@ -426,7 +426,7 @@ impl<'a> TraitDef<'a> {\n                     }\n                 };\n                 let is_always_copy =\n-                    attr::contains_name(&item.attrs, \"rustc_copy_clone_marker\") &&\n+                    attr::contains_name(&item.attrs, sym::rustc_copy_clone_marker) &&\n                     has_no_type_params;\n                 let use_temporaries = is_packed && is_always_copy;\n \n@@ -464,8 +464,8 @@ impl<'a> TraitDef<'a> {\n                 attrs.extend(item.attrs\n                     .iter()\n                     .filter(|a| {\n-                        [\"allow\", \"warn\", \"deny\", \"forbid\", \"stable\", \"unstable\"]\n-                            .contains(&a.name_or_empty().get())\n+                        [sym::allow, sym::warn, sym::deny, sym::forbid, sym::stable, sym::unstable]\n+                            .contains(&a.name_or_empty())\n                     })\n                     .cloned());\n                 push(Annotatable::Item(P(ast::Item { attrs: attrs, ..(*newitem).clone() })))"}, {"sha": "c27de692d887cc050114ac6d7d4d3ec69410817c", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -6,7 +6,7 @@ use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n \n macro path_local($x:ident) {\n@@ -139,7 +139,7 @@ fn call_intrinsic(cx: &ExtCtxt<'_>,\n     let intrinsic_allowed_via_allow_internal_unstable = cx\n         .current_expansion.mark.expn_info().unwrap()\n         .allow_internal_unstable.map_or(false, |features| features.iter().any(|&s|\n-            s == \"core_intrinsics\"\n+            s == sym::core_intrinsics\n         ));\n     if intrinsic_allowed_via_allow_internal_unstable {\n         span = span.with_ctxt(cx.backtrace());"}, {"sha": "9e54c0634b666b43a4bae4f333f27bc8fe774646", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -12,7 +12,7 @@ use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::tokenstream;\n use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n \n@@ -711,12 +711,12 @@ pub fn expand_format_args_nl<'cx>(\n     //if !ecx.ecfg.enable_allow_internal_unstable() {\n \n     // For some reason, the only one that actually works for `println` is the first check\n-    if !sp.allows_unstable(\"format_args_nl\") // the span is marked as `#[allow_insternal_unsable]`\n+    if !sp.allows_unstable(sym::format_args_nl) // the span is marked `#[allow_insternal_unsable]`\n         && !ecx.ecfg.enable_allow_internal_unstable()  // NOTE: when is this enabled?\n         && !ecx.ecfg.enable_format_args_nl()  // enabled using `#[feature(format_args_nl]`\n     {\n         feature_gate::emit_feature_err(&ecx.parse_sess,\n-                                       \"format_args_nl\",\n+                                       sym::format_args_nl,\n                                        sp,\n                                        feature_gate::GateIssue::Language,\n                                        feature_gate::EXPLAIN_FORMAT_ARGS_NL);"}, {"sha": "3f2853e4b0e20b3025d411eed2d8ddb8a2ea7ffc", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -16,12 +16,12 @@ use syntax::ext::base::{self, *};\n use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n use syntax::tokenstream;\n use smallvec::smallvec;\n \n-pub const MACRO: &str = \"global_asm\";\n+pub const MACRO: Symbol = sym::global_asm;\n \n pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                               sp: Span,"}, {"sha": "1be3990837cfe3cd6950e79307db6f1a7b6a3fa2", "filename": "src/libsyntax_ext/log_syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flog_syntax.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -2,6 +2,7 @@ use syntax::ext::base;\n use syntax::feature_gate;\n use syntax::print;\n use syntax::tokenstream;\n+use syntax::symbol::sym;\n use syntax_pos;\n \n pub fn expand_syntax_ext<'cx>(cx: &'cx mut base::ExtCtxt<'_>,\n@@ -10,7 +11,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut base::ExtCtxt<'_>,\n                               -> Box<dyn base::MacResult + 'cx> {\n     if !cx.ecfg.enable_log_syntax() {\n         feature_gate::emit_feature_err(&cx.parse_sess,\n-                                       \"log_syntax\",\n+                                       sym::log_syntax,\n                                        sp,\n                                        feature_gate::GateIssue::Language,\n                                        feature_gate::EXPLAIN_LOG_SYNTAX);"}, {"sha": "5ced1400acb0ec66b110119749cdd518d032e93e", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -13,12 +13,16 @@ use syntax::mut_visit::MutVisitor;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n \n-const PROC_MACRO_KINDS: [&str; 3] = [\"proc_macro_derive\", \"proc_macro_attribute\", \"proc_macro\"];\n+const PROC_MACRO_KINDS: [Symbol; 3] = [\n+    sym::proc_macro_derive,\n+    sym::proc_macro_attribute,\n+    sym::proc_macro\n+];\n \n struct ProcMacroDerive {\n     trait_name: ast::Name,\n@@ -139,7 +143,7 @@ impl<'a> CollectProcMacros<'a> {\n \n         let attributes_attr = list.get(1);\n         let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n-            if !attr.check_name(\"attributes\") {\n+            if !attr.check_name(sym::attributes) {\n                 self.handler.span_err(attr.span(), \"second argument must be `attributes`\")\n             }\n             attr.meta_item_list().unwrap_or_else(|| {\n@@ -231,7 +235,7 @@ impl<'a> CollectProcMacros<'a> {\n impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n         if let ast::ItemKind::MacroDef(..) = item.node {\n-            if self.is_proc_macro_crate && attr::contains_name(&item.attrs, \"macro_export\") {\n+            if self.is_proc_macro_crate && attr::contains_name(&item.attrs, sym::macro_export) {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n                 self.handler.span_err(item.span, msg);\n@@ -304,11 +308,11 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n             return;\n         }\n \n-        if attr.check_name(\"proc_macro_derive\") {\n+        if attr.check_name(sym::proc_macro_derive) {\n             self.collect_custom_derive(item, attr);\n-        } else if attr.check_name(\"proc_macro_attribute\") {\n+        } else if attr.check_name(sym::proc_macro_attribute) {\n             self.collect_attr_proc_macro(item);\n-        } else if attr.check_name(\"proc_macro\") {\n+        } else if attr.check_name(sym::proc_macro) {\n             self.collect_bang_proc_macro(item);\n         };\n "}, {"sha": "86ae6ab5fece5cbef9b2ae6be24e8dabed05799b", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -7,7 +7,7 @@ use syntax::ext::hygiene::{self, Mark, SyntaxContext};\n use syntax::attr;\n use syntax::ast;\n use syntax::print::pprust;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::{DUMMY_SP, Span};\n use syntax::source_map::{ExpnInfo, MacroAttribute};\n use std::iter;\n@@ -206,23 +206,23 @@ enum ShouldPanic {\n }\n \n fn should_ignore(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, \"ignore\")\n+    attr::contains_name(&i.attrs, sym::ignore)\n }\n \n fn should_fail(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, \"allow_fail\")\n+    attr::contains_name(&i.attrs, sym::allow_fail)\n }\n \n fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n-    match attr::find_by_name(&i.attrs, \"should_panic\") {\n+    match attr::find_by_name(&i.attrs, sym::should_panic) {\n         Some(attr) => {\n             let ref sd = cx.parse_sess.span_diagnostic;\n \n             match attr.meta_item_list() {\n                 // Handle #[should_panic(expected = \"foo\")]\n                 Some(list) => {\n                     let msg = list.iter()\n-                        .find(|mi| mi.check_name(\"expected\"))\n+                        .find(|mi| mi.check_name(sym::expected))\n                         .and_then(|mi| mi.meta_item())\n                         .and_then(|mi| mi.value_str());\n                     if list.len() != 1 || msg.is_none() {\n@@ -247,7 +247,7 @@ fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n }\n \n fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n-    let has_should_panic_attr = attr::contains_name(&i.attrs, \"should_panic\");\n+    let has_should_panic_attr = attr::contains_name(&i.attrs, sym::should_panic);\n     let ref sd = cx.parse_sess.span_diagnostic;\n     if let ast::ItemKind::Fn(ref decl, ref header, ref generics, _) = i.node {\n         if header.unsafety == ast::Unsafety::Unsafe {"}, {"sha": "802037f6d22bbb16f7211268d6a91c9bca497213", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -14,7 +14,7 @@ use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::{self, Mark, SyntaxContext};\n use syntax::ast;\n use syntax::source_map::respan;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::{DUMMY_SP, Span};\n use syntax::source_map::{ExpnInfo, MacroAttribute};\n use syntax::feature_gate;\n@@ -27,7 +27,7 @@ pub fn expand(\n ) -> Vec<Annotatable> {\n     if !ecx.ecfg.enable_custom_test_frameworks() {\n         feature_gate::emit_feature_err(&ecx.parse_sess,\n-                                       \"custom_test_frameworks\",\n+                                       sym::custom_test_frameworks,\n                                        attr_sp,\n                                        feature_gate::GateIssue::Language,\n                                        feature_gate::EXPLAIN_CUSTOM_TEST_FRAMEWORKS);"}, {"sha": "eca658cb5473e2fb30d3a24ca5c43edda152d2e3", "filename": "src/libsyntax_ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_ext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftrace_macros.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -1,6 +1,6 @@\n use syntax::ext::base::{self, ExtCtxt};\n use syntax::feature_gate;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax_pos::Span;\n use syntax::tokenstream::TokenTree;\n \n@@ -10,7 +10,7 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt<'_>,\n                            -> Box<dyn base::MacResult + 'static> {\n     if !cx.ecfg.enable_trace_macros() {\n         feature_gate::emit_feature_err(&cx.parse_sess,\n-                                       \"trace_macros\",\n+                                       sym::trace_macros,\n                                        sp,\n                                        feature_gate::GateIssue::Language,\n                                        feature_gate::EXPLAIN_TRACE_MACROS);"}, {"sha": "00cd00f2837849b10cbe646f4b7fcfc28796fada", "filename": "src/libsyntax_pos/edition.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_pos%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_pos%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fedition.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -1,3 +1,4 @@\n+use crate::symbol::{Symbol, sym};\n use std::fmt;\n use std::str::FromStr;\n \n@@ -44,10 +45,10 @@ impl Edition {\n         }\n     }\n \n-    pub fn feature_name(&self) -> &'static str {\n+    pub fn feature_name(&self) -> Symbol {\n         match *self {\n-            Edition::Edition2015 => \"rust_2015_preview\",\n-            Edition::Edition2018 => \"rust_2018_preview\",\n+            Edition::Edition2015 => sym::rust_2015_preview,\n+            Edition::Edition2018 => sym::rust_2018_preview,\n         }\n     }\n "}, {"sha": "39859f25f97fb87b867d3abff651dc808c18d8c1", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -33,7 +33,7 @@ mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n \n pub mod symbol;\n-pub use symbol::symbols;\n+pub use symbol::{Symbol, sym};\n \n mod analyze_source_file;\n \n@@ -388,12 +388,12 @@ impl Span {\n     /// Checks if a span is \"internal\" to a macro in which `#[unstable]`\n     /// items can be used (that is, a macro marked with\n     /// `#[allow_internal_unstable]`).\n-    pub fn allows_unstable(&self, feature: &str) -> bool {\n+    pub fn allows_unstable(&self, feature: Symbol) -> bool {\n         match self.ctxt().outer().expn_info() {\n             Some(info) => info\n                 .allow_internal_unstable\n                 .map_or(false, |features| features.iter().any(|&f|\n-                    f == feature || f == \"allow_internal_unstable_backcompat_hack\"\n+                    f == feature || f == sym::allow_internal_unstable_backcompat_hack\n                 )),\n             None => false,\n         }"}, {"sha": "ec0ce4253fa2d397cef8f1b85795267f090d7e68", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 386, "deletions": 11, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -99,88 +99,375 @@ symbols! {\n         Union:              \"union\",\n     }\n \n-    // Other symbols that can be referred to with syntax_pos::symbols::*\n-    Other {\n+    // Symbols that can be referred to with syntax_pos::sym::*. The symbol is\n+    // the stringified identifier unless otherwise specified (e.g.\n+    // `proc_dash_macro` represents \"proc-macro\").\n+    Symbols {\n+        aarch64_target_feature,\n+        abi,\n+        abi_amdgpu_kernel,\n+        abi_msp430_interrupt,\n+        abi_ptx,\n+        abi_sysv64,\n+        abi_thiscall,\n+        abi_unadjusted,\n+        abi_vectorcall,\n+        abi_x86_interrupt,\n+        aborts,\n+        advanced_slice_patterns,\n+        adx_target_feature,\n         alias,\n         align,\n+        alignstack,\n+        all,\n+        allocator,\n+        allocator_internals,\n         alloc_error_handler,\n         allow,\n+        allowed,\n         allow_fail,\n         allow_internal_unsafe,\n         allow_internal_unstable,\n+        allow_internal_unstable_backcompat_hack,\n+        always,\n+        any,\n+        arbitrary_self_types,\n+        arm_target_feature,\n+        asm,\n+        associated_consts,\n+        associated_type_defaults,\n+        associated_types,\n+        async_await,\n+        attr,\n+        attributes,\n+        attr_literals,\n+        augmented_assignments,\n         automatically_derived,\n+        avx512_target_feature,\n+        await_macro,\n+        bin,\n+        bind_by_move_pattern_guards,\n+        block,\n+        borrowck_graphviz_postflow,\n+        borrowck_graphviz_preflow,\n+        box_patterns,\n+        box_syntax,\n+        braced_empty_structs,\n+        C,\n+        cdylib,\n         cfg,\n         cfg_attr,\n+        cfg_attr_multi,\n+        cfg_target_feature,\n+        cfg_target_has_atomic,\n+        cfg_target_thread_local,\n+        cfg_target_vendor,\n+        clone,\n+        clone_closures,\n+        clone_from,\n+        closure_to_fn_coercion,\n+        cmpxchg16b_target_feature,\n         cold,\n+        compile_error,\n         compiler_builtins,\n+        concat_idents,\n+        conservative_impl_trait,\n+        console,\n+        const_compare_raw_pointers,\n+        const_fn,\n+        const_fn_union,\n+        const_generics,\n+        const_indexing,\n+        const_let,\n+        const_panic,\n+        const_raw_ptr_deref,\n+        const_raw_ptr_to_usize_cast,\n+        const_transmute,\n+        contents,\n+        convert,\n+        copy_closures,\n+        core,\n+        core_intrinsics,\n         crate_id,\n+        crate_in_paths,\n         crate_name,\n         crate_type,\n+        crate_visibility_modifier,\n+        custom_attribute,\n+        custom_derive,\n+        custom_inner_attributes,\n+        custom_test_frameworks,\n+        c_variadic,\n+        decl_macro,\n         default_lib_allocator,\n+        default_type_parameter_fallback,\n+        default_type_params,\n         deny,\n         deprecated,\n         derive,\n         doc,\n+        doc_alias,\n+        doc_cfg,\n+        doc_keyword,\n+        doc_masked,\n+        doc_spotlight,\n+        document_private_items,\n+        dotdoteq_in_patterns,\n+        dotdot_in_tuple_patterns,\n+        dropck_eyepatch,\n+        dropck_parametricity,\n+        drop_types_in_const,\n+        dylib,\n+        dyn_trait,\n+        eh_personality,\n+        eh_unwind_resume,\n+        enable,\n+        Err,\n+        except,\n+        exclusive_range_pattern,\n+        exhaustive_integer_patterns,\n+        exhaustive_patterns,\n+        existential_type,\n+        expected,\n         export_name,\n+        extern_absolute_paths,\n+        external_doc,\n+        extern_crate_item_prelude,\n+        extern_crate_self,\n+        extern_in_paths,\n+        extern_prelude,\n+        extern_types,\n+        f16c_target_feature,\n         feature,\n         ffi_returns_twice,\n+        field_init_shorthand,\n+        file,\n+        fn_must_use,\n         forbid,\n+        format_args_nl,\n+        from,\n+        From,\n+        from_error,\n+        from_generator,\n+        from_ok,\n         fundamental,\n+        future,\n+        Future,\n+        generators,\n+        generic_associated_types,\n+        generic_param_attrs,\n         global_allocator,\n+        global_asm,\n+        globs,\n+        hexagon_target_feature,\n+        hidden,\n+        homogeneous_aggregate,\n+        html_favicon_url,\n+        html_logo_url,\n+        html_no_source,\n+        html_playground_url,\n+        html_root_url,\n+        i128,\n+        i128_type,\n+        i16,\n+        i32,\n+        i64,\n+        i8,\n+        ident,\n+        if_let,\n+        if_while_or_patterns,\n         ignore,\n+        impl_header_lifetime_elision,\n+        impl_trait_in_bindings,\n+        import_shadowing,\n+        in_band_lifetimes,\n         include,\n+        inclusive_range_syntax,\n+        infer_outlives_requirements,\n+        infer_static_outlives_requirements,\n         inline,\n+        intel,\n+        into_iter,\n+        IntoIterator,\n+        into_result,\n+        intrinsics,\n+        irrefutable_let_patterns,\n+        isize,\n+        issue,\n+        issue_5723_bootstrap,\n+        issue_tracker_base_url,\n+        item_like_imports,\n+        iter,\n+        Iterator,\n         keyword,\n+        kind,\n+        label,\n+        label_break_value,\n         lang,\n+        lang_items,\n+        lib,\n         link,\n+        linkage,\n         link_args,\n+        link_cfg,\n+        link_llvm_intrinsics,\n         link_name,\n         link_section,\n-        linkage,\n+        lint_reasons,\n+        local_inner_macros,\n+        log_syntax,\n+        loop_break_value,\n+        macro_at_most_once_rep,\n         macro_escape,\n         macro_export,\n+        macro_lifetime_matcher,\n+        macro_literal_matcher,\n+        macro_reexport,\n+        macro_rules,\n+        macros_in_extern,\n         macro_use,\n+        macro_vis_matcher,\n         main,\n+        managed_boxes,\n         marker,\n+        marker_trait_attr,\n         masked,\n+        match_beginning_vert,\n+        match_default_bindings,\n         may_dangle,\n+        message,\n+        min_const_fn,\n+        min_const_unsafe_fn,\n+        mips_target_feature,\n+        mmx_target_feature,\n+        module,\n+        more_struct_aliases,\n+        movbe_target_feature,\n         must_use,\n         naked,\n+        naked_functions,\n+        name,\n         needs_allocator,\n         needs_panic_runtime,\n+        negate_unsigned,\n+        never,\n+        never_type,\n+        next,\n+        nll,\n         no_builtins,\n         no_core,\n+        no_crate_inject,\n         no_debug,\n+        no_default_passes,\n         no_implicit_prelude,\n+        no_inline,\n         no_link,\n         no_main,\n         no_mangle,\n+        non_ascii_idents,\n+        None,\n+        non_exhaustive,\n+        non_modrs_mods,\n+        no_stack_check,\n         no_start,\n         no_std,\n-        non_exhaustive,\n+        not,\n+        note,\n+        Ok,\n         omit_gdb_pretty_printer_section,\n+        on,\n+        on_unimplemented,\n+        oom,\n+        ops,\n         optimize,\n+        optimize_attribute,\n+        optin_builtin_traits,\n+        option,\n+        Option,\n+        opt_out_copy,\n+        overlapping_marker_traits,\n+        packed,\n         panic_handler,\n+        panic_impl,\n+        panic_implementation,\n         panic_runtime,\n+        passes,\n         path,\n+        pattern_parentheses,\n+        Pending,\n+        pin,\n+        Pin,\n+        platform_intrinsics,\n         plugin,\n         plugin_registrar,\n+        plugins,\n+        Poll,\n+        poll_with_tls_context,\n+        powerpc_target_feature,\n+        precise_pointer_size_matching,\n+        prelude,\n         prelude_import,\n+        primitive,\n+        proc_dash_macro: \"proc-macro\",\n         proc_macro,\n         proc_macro_attribute,\n         proc_macro_derive,\n+        proc_macro_expr,\n+        proc_macro_gen,\n+        proc_macro_hygiene,\n+        proc_macro_mod,\n+        proc_macro_non_items,\n+        proc_macro_path_invoc,\n         profiler_runtime,\n+        pub_restricted,\n+        pushpop_unsafe,\n+        quad_precision_float,\n+        question_mark,\n+        quote,\n+        Range,\n+        RangeFrom,\n+        RangeFull,\n+        RangeInclusive,\n+        RangeTo,\n+        RangeToInclusive,\n+        raw_identifiers,\n+        Ready,\n+        reason,\n         recursion_limit,\n         reexport_test_harness_main,\n+        reflect,\n+        relaxed_adts,\n         repr,\n+        repr128,\n+        repr_align,\n+        repr_align_enum,\n+        repr_packed,\n+        repr_simd,\n+        repr_transparent,\n+        re_rebalance_coherence,\n+        result,\n+        Result,\n+        Return,\n+        rlib,\n+        rtm_target_feature,\n+        rust,\n+        rust_2015_preview,\n+        rust_2018_preview,\n+        rust_begin_unwind,\n+        rustc_allocator_nounwind,\n+        rustc_allow_const_fn_ptr,\n         rustc_args_required_const,\n+        rustc_attrs,\n         rustc_clean,\n         rustc_const_unstable,\n         rustc_conversion_suggestion,\n         rustc_copy_clone_marker,\n         rustc_def_path,\n         rustc_deprecated,\n+        rustc_diagnostic_macros,\n         rustc_dirty,\n+        rustc_doc_only_macro,\n+        rustc_dump_env_program_clauses,\n         rustc_dump_program_clauses,\n         rustc_dump_user_substs,\n         rustc_error,\n@@ -191,37 +478,130 @@ symbols! {\n         rustc_layout_scalar_valid_range_end,\n         rustc_layout_scalar_valid_range_start,\n         rustc_mir,\n+        rustc_object_lifetime_default,\n         rustc_on_unimplemented,\n         rustc_outlives,\n         rustc_paren_sugar,\n         rustc_partition_codegened,\n         rustc_partition_reused,\n+        rustc_peek,\n+        rustc_peek_definite_init,\n+        rustc_peek_maybe_init,\n+        rustc_peek_maybe_uninit,\n+        rustc_private,\n         rustc_proc_macro_decls,\n+        rustc_promotable,\n         rustc_regions,\n+        rustc_stable,\n         rustc_std_internal_symbol,\n         rustc_symbol_name,\n         rustc_synthetic,\n         rustc_test_marker,\n         rustc_then_this_would_need,\n         rustc_transparent_macro,\n         rustc_variance,\n+        rustdoc,\n+        rust_eh_personality,\n+        rust_eh_unwind_resume,\n+        rust_oom,\n+        __rust_unstable_column,\n+        rvalue_static_promotion,\n         sanitizer_runtime,\n+        self_in_typedefs,\n+        self_struct_ctor,\n+        Send,\n         should_panic,\n         simd,\n+        simd_ffi,\n+        since,\n+        size,\n+        slice_patterns,\n+        slicing_syntax,\n+        Some,\n+        specialization,\n+        speed,\n         spotlight,\n+        sse4a_target_feature,\n         stable,\n+        staged_api,\n         start,\n+        static_in_const,\n+        staticlib,\n+        static_nobundle,\n+        static_recursion,\n+        std,\n+        stmt_expr_attributes,\n+        stop_after_dataflow,\n+        struct_field_attributes,\n+        struct_inherit,\n         structural_match,\n+        struct_variant,\n+        suggestion,\n         target_feature,\n+        target_has_atomic,\n+        target_thread_local,\n+        task,\n+        tbm_target_feature,\n+        termination_trait,\n+        termination_trait_test,\n+        test,\n+        test_2018_feature,\n+        test_accepted_feature,\n+        test_removed_feature,\n         test_runner,\n         thread_local,\n+        tool_attributes,\n+        tool_lints,\n+        trace_macros,\n+        trait_alias,\n+        transmute,\n+        transparent,\n+        trivial_bounds,\n+        Try,\n+        try_blocks,\n+        tuple_indexing,\n+        ty,\n+        type_alias_enum_variants,\n+        type_ascription,\n         type_length_limit,\n+        type_macros,\n+        u128,\n+        u16,\n+        u32,\n+        u64,\n+        u8,\n+        unboxed_closures,\n+        underscore_const_names,\n+        underscore_imports,\n+        underscore_lifetimes,\n+        uniform_paths,\n+        universal_impl_trait,\n+        unmarked_api,\n+        unrestricted_attribute_tokens,\n         unsafe_destructor_blind_to_params,\n+        unsafe_no_drop_flag,\n+        unsized_locals,\n+        unsized_tuple_coercion,\n         unstable,\n+        untagged_unions,\n         unwind,\n+        unwind_attributes,\n         used,\n+        use_extern_macros,\n+        use_nested_groups,\n+        usize,\n+        v1,\n+        vis,\n+        visible_private_types,\n+        volatile,\n         warn,\n+        warn_directory_ownership,\n+        wasm_import_module,\n+        wasm_target_feature,\n+        while_let,\n+        windows,\n         windows_subsystem,\n+        Yield,\n     }\n }\n \n@@ -442,12 +822,6 @@ impl Decodable for Symbol {\n     }\n }\n \n-impl<T: std::ops::Deref<Target=str>> PartialEq<T> for Symbol {\n-    fn eq(&self, other: &T) -> bool {\n-        self.as_str() == other.deref()\n-    }\n-}\n-\n // The `&'static str`s in this type actually point into the arena.\n //\n // Note that normal symbols are indexed upward from 0, and gensyms are indexed\n@@ -557,7 +931,8 @@ pub mod keywords {\n     keywords!();\n }\n \n-pub mod symbols {\n+// This module has a very short name because it's used a lot.\n+pub mod sym {\n     use super::Symbol;\n     symbols!();\n }"}, {"sha": "c6b33fbc75ee23dbd29e30c3a5c2ff325eea6a95", "filename": "src/test/run-pass-fulldeps/auxiliary/custom-derive-plugin-attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin-attr.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -14,7 +14,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::ptr::P;\n use syntax_ext::deriving::generic::{TraitDef, MethodDef, combine_substructure};\n use syntax_ext::deriving::generic::{Substructure, Struct, EnumMatching};\n@@ -71,7 +71,7 @@ fn totalsum_substructure(cx: &mut ExtCtxt, trait_span: Span,\n     };\n \n     fields.iter().fold(cx.expr_isize(trait_span, 0), |acc, ref item| {\n-        if attr::contains_name(&item.attrs, \"ignore\") {\n+        if attr::contains_name(&item.attrs, sym::ignore) {\n             acc\n         } else {\n             cx.expr_binary(item.span, ast::BinOpKind::Add, acc,"}, {"sha": "40e0115c623eeca63f4858335bc8d0874b5f636e", "filename": "src/test/run-pass-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -23,7 +23,7 @@ use syntax::{ast, source_map};\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box MissingWhitelistedAttrPass);\n-    reg.register_attribute(\"whitelisted_attr\".to_string(), Whitelisted);\n+    reg.register_attribute(Symbol::intern(\"whitelisted_attr\"), Whitelisted);\n }\n \n declare_lint! {\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingWhitelistedAttrPass {\n             _ => cx.tcx.hir().expect_item_by_hir_id(cx.tcx.hir().get_parent_item(id)),\n         };\n \n-        if !attr::contains_name(&item.attrs, \"whitelisted_attr\") {\n+        if !attr::contains_name(&item.attrs, Symbol::intern(\"whitelisted_attr\")) {\n             cx.span_lint(MISSING_WHITELISTED_ATTR, span,\n                          \"Missing 'whitelisted_attr' attribute\");\n         }"}, {"sha": "8c7bd7222e73cb5294594c32fa854d10f4b8c863", "filename": "src/test/run-pass-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -11,6 +11,7 @@ use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPass\n use rustc_plugin::Registry;\n use rustc::hir;\n use syntax::attr;\n+use syntax::symbol::Symbol;\n \n macro_rules! fake_lint_pass {\n     ($struct:ident, $lints:expr, $($attr:expr),*) => {\n@@ -49,19 +50,19 @@ declare_lint!(CRATE_NOT_GREEN, Warn, \"crate not marked with #![crate_green]\");\n fake_lint_pass! {\n     PassOkay,\n     lint_array!(CRATE_NOT_OKAY), // Single lint\n-    \"rustc_crate_okay\"\n+    Symbol::intern(\"rustc_crate_okay\")\n }\n \n fake_lint_pass! {\n     PassRedBlue,\n     lint_array!(CRATE_NOT_RED, CRATE_NOT_BLUE), // Multiple lints\n-    \"rustc_crate_red\", \"rustc_crate_blue\"\n+    Symbol::intern(\"rustc_crate_red\"), Symbol::intern(\"rustc_crate_blue\")\n }\n \n fake_lint_pass! {\n     PassGreyGreen,\n     lint_array!(CRATE_NOT_GREY, CRATE_NOT_GREEN, ), // Trailing comma\n-    \"rustc_crate_grey\", \"rustc_crate_green\"\n+    Symbol::intern(\"rustc_crate_grey\"), Symbol::intern(\"rustc_crate_green\")\n }\n \n #[plugin_registrar]"}, {"sha": "039124f31ff4233bb59dfdc01652ff3f4eaae38b", "filename": "src/test/ui-fulldeps/auxiliary/attr-plugin-test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fattr-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fattr-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fattr-plugin-test.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -8,14 +8,14 @@ extern crate syntax;\n extern crate rustc;\n extern crate rustc_plugin;\n \n+use syntax::symbol::Symbol;\n use syntax::feature_gate::AttributeType;\n use rustc_plugin::Registry;\n \n \n-\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_attribute(\"foo\".to_owned(), AttributeType::Normal);\n-    reg.register_attribute(\"bar\".to_owned(), AttributeType::CrateLevel);\n-    reg.register_attribute(\"baz\".to_owned(), AttributeType::Whitelisted);\n+    reg.register_attribute(Symbol::intern(\"foo\"), AttributeType::Normal);\n+    reg.register_attribute(Symbol::intern(\"bar\"), AttributeType::CrateLevel);\n+    reg.register_attribute(Symbol::intern(\"baz\"), AttributeType::Whitelisted);\n }"}, {"sha": "7656b15721adafb03db8ff576d84d1b5c1c745dc", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -11,6 +11,7 @@ use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPass\n use rustc_plugin::Registry;\n use rustc::hir;\n use syntax::attr;\n+use syntax::symbol::Symbol;\n \n declare_lint! {\n     CRATE_NOT_OKAY,\n@@ -22,7 +23,7 @@ declare_lint_pass!(Pass => [CRATE_NOT_OKAY]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n-        if !attr::contains_name(&krate.attrs, \"crate_okay\") {\n+        if !attr::contains_name(&krate.attrs, Symbol::intern(\"crate_okay\")) {\n             cx.span_lint(CRATE_NOT_OKAY, krate.span,\n                          \"crate is not marked with #![crate_okay]\");\n         }"}, {"sha": "0deb1bf091508d01c951f4d61891e7cc2c6f4a3b", "filename": "src/test/ui-fulldeps/auxiliary/lint-plugin-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -20,7 +20,7 @@ declare_lint_pass!(Pass => [TEST_LINT]);\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n-        if it.ident.name == \"lintme\" {\n+        if it.ident.name.as_str() == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n     }"}, {"sha": "64664377cd9435c05b6e07336d0c60c64f26e998", "filename": "src/test/ui-fulldeps/auxiliary/lint-tool-test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe5f42cdb88d8ce31f746130099321e7c95e1ef0/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs?ref=fe5f42cdb88d8ce31f746130099321e7c95e1ef0", "patch": "@@ -23,10 +23,10 @@ declare_lint_pass!(Pass => [TEST_LINT, TEST_GROUP]);\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n-        if it.ident.name == \"lintme\" {\n+        if it.ident.name.as_str() == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n-        if it.ident.name == \"lintmetoo\" {\n+        if it.ident.name.as_str() == \"lintmetoo\" {\n             cx.span_lint(TEST_GROUP, it.span, \"item is named 'lintmetoo'\");\n         }\n     }"}]}