{"sha": "dda4a881e006c808093543eece098565c3142c46", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYTRhODgxZTAwNmM4MDgwOTM1NDNlZWNlMDk4NTY1YzMxNDJjNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-08T01:05:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-08T01:05:48Z"}, "message": "Auto merge of #83515 - tamird:string-remove-matches-rev, r=m-ou-se\n\nString::remove_matches O(n^2) -> O(n)\n\nCopy only non-matching bytes. Replace collection of matches into a\nvector with iteration over rejections, exploiting the guarantee that we\nmutate parts of the haystack that have already been searched over.\n\nr? `@joshtriplett`", "tree": {"sha": "75379b125b7e468b4349c9cef963a37ee72c92e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75379b125b7e468b4349c9cef963a37ee72c92e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dda4a881e006c808093543eece098565c3142c46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dda4a881e006c808093543eece098565c3142c46", "html_url": "https://github.com/rust-lang/rust/commit/dda4a881e006c808093543eece098565c3142c46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dda4a881e006c808093543eece098565c3142c46/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4a60327063e82413eed50a10df3b7d19b77bda0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4a60327063e82413eed50a10df3b7d19b77bda0", "html_url": "https://github.com/rust-lang/rust/commit/e4a60327063e82413eed50a10df3b7d19b77bda0"}, {"sha": "977903bb1135e22dc7c33aee0096c383f93aa719", "url": "https://api.github.com/repos/rust-lang/rust/commits/977903bb1135e22dc7c33aee0096c383f93aa719", "html_url": "https://github.com/rust-lang/rust/commit/977903bb1135e22dc7c33aee0096c383f93aa719"}], "stats": {"total": 61, "additions": 39, "deletions": 22}, "files": [{"sha": "1fb645a302e76eb91bd4c0f104bb95ebc4f08147", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/dda4a881e006c808093543eece098565c3142c46/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dda4a881e006c808093543eece098565c3142c46/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=dda4a881e006c808093543eece098565c3142c46", "patch": "@@ -48,7 +48,7 @@ use core::fmt;\n use core::hash;\n #[cfg(not(no_global_oom_handling))]\n use core::iter::FromIterator;\n-use core::iter::FusedIterator;\n+use core::iter::{from_fn, FusedIterator};\n #[cfg(not(no_global_oom_handling))]\n use core::ops::Add;\n #[cfg(not(no_global_oom_handling))]\n@@ -1290,32 +1290,49 @@ impl String {\n     {\n         use core::str::pattern::Searcher;\n \n-        let matches = {\n+        let rejections = {\n             let mut searcher = pat.into_searcher(self);\n-            let mut matches = Vec::new();\n-\n-            while let Some(m) = searcher.next_match() {\n-                matches.push(m);\n-            }\n-\n-            matches\n+            // Per Searcher::next:\n+            //\n+            // A Match result needs to contain the whole matched pattern,\n+            // however Reject results may be split up into arbitrary many\n+            // adjacent fragments. Both ranges may have zero length.\n+            //\n+            // In practice the implementation of Searcher::next_match tends to\n+            // be more efficient, so we use it here and do some work to invert\n+            // matches into rejections since that's what we want to copy below.\n+            let mut front = 0;\n+            let rejections: Vec<_> = from_fn(|| {\n+                let (start, end) = searcher.next_match()?;\n+                let prev_front = front;\n+                front = end;\n+                Some((prev_front, start))\n+            })\n+            .collect();\n+            rejections.into_iter().chain(core::iter::once((front, self.len())))\n         };\n \n-        let len = self.len();\n-        let mut shrunk_by = 0;\n+        let mut len = 0;\n+        let ptr = self.vec.as_mut_ptr();\n+\n+        for (start, end) in rejections {\n+            let count = end - start;\n+            if start != len {\n+                // SAFETY: per Searcher::next:\n+                //\n+                // The stream of Match and Reject values up to a Done will\n+                // contain index ranges that are adjacent, non-overlapping,\n+                // covering the whole haystack, and laying on utf8\n+                // boundaries.\n+                unsafe {\n+                    ptr::copy(ptr.add(start), ptr.add(len), count);\n+                }\n+            }\n+            len += count;\n+        }\n \n-        // SAFETY: start and end will be on utf8 byte boundaries per\n-        // the Searcher docs\n         unsafe {\n-            for (start, end) in matches {\n-                ptr::copy(\n-                    self.vec.as_mut_ptr().add(end - shrunk_by),\n-                    self.vec.as_mut_ptr().add(start - shrunk_by),\n-                    len - end,\n-                );\n-                shrunk_by += end - start;\n-            }\n-            self.vec.set_len(len - shrunk_by);\n+            self.vec.set_len(len);\n         }\n     }\n "}]}