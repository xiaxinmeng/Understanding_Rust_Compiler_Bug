{"sha": "498bdc9b42e1de6db051a24be0a4318f075a5562", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5OGJkYzliNDJlMWRlNmRiMDUxYTI0YmUwYTQzMThmMDc1YTU1NjI=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-03-15T11:17:11Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-07-10T15:04:42Z"}, "message": "Add an AtomicCell abstraction", "tree": {"sha": "e488a7805c8bc1502f63d3b1bf7e4ecbaf3aecf7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e488a7805c8bc1502f63d3b1bf7e4ecbaf3aecf7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/498bdc9b42e1de6db051a24be0a4318f075a5562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/498bdc9b42e1de6db051a24be0a4318f075a5562", "html_url": "https://github.com/rust-lang/rust/commit/498bdc9b42e1de6db051a24be0a4318f075a5562", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/498bdc9b42e1de6db051a24be0a4318f075a5562/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "html_url": "https://github.com/rust-lang/rust/commit/d4e15655092d1bdae79619eb0ff2c3cb5468fc36"}], "stats": {"total": 57, "additions": 56, "deletions": 1}, "files": [{"sha": "6a194bd52ab037ea3b3d3d7fad3f50a0e73e455e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/498bdc9b42e1de6db051a24be0a4318f075a5562/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/498bdc9b42e1de6db051a24be0a4318f075a5562/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=498bdc9b42e1de6db051a24be0a4318f075a5562", "patch": "@@ -3019,6 +3019,7 @@ name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n  \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n  \"indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "79cbe26e73e836f36c75f20b85b1659b8d6798a8", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/498bdc9b42e1de6db051a24be0a4318f075a5562/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/498bdc9b42e1de6db051a24be0a4318f075a5562/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=498bdc9b42e1de6db051a24be0a4318f075a5562", "patch": "@@ -18,6 +18,7 @@ lazy_static = \"1\"\n serialize = { path = \"../libserialize\" }\n graphviz = { path = \"../libgraphviz\" }\n cfg-if = \"0.1.2\"\n+crossbeam-utils = { version = \"0.6.5\", features = [\"nightly\"] }\n stable_deref_trait = \"1.0.0\"\n rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n rayon-core = { version = \"0.2.0\", package = \"rustc-rayon-core\" }"}, {"sha": "3277b85c281443278329629b81c1d6d7f859acae", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/498bdc9b42e1de6db051a24be0a4318f075a5562/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498bdc9b42e1de6db051a24be0a4318f075a5562/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=498bdc9b42e1de6db051a24be0a4318f075a5562", "patch": "@@ -67,6 +67,51 @@ cfg_if! {\n         use std::ops::Add;\n         use std::panic::{resume_unwind, catch_unwind, AssertUnwindSafe};\n \n+        /// This is a single threaded variant of AtomicCell provided by crossbeam.\n+        /// Unlike `Atomic` this is intended for all `Copy` types,\n+        /// but it lacks the explicit ordering arguments.\n+        #[derive(Debug)]\n+        pub struct AtomicCell<T: Copy>(Cell<T>);\n+\n+        impl<T: Copy> AtomicCell<T> {\n+            #[inline]\n+            pub fn new(v: T) -> Self {\n+                AtomicCell(Cell::new(v))\n+            }\n+\n+            #[inline]\n+            pub fn get_mut(&mut self) -> &mut T {\n+                self.0.get_mut()\n+            }\n+        }\n+\n+        impl<T: Copy> AtomicCell<T> {\n+            #[inline]\n+            pub fn into_inner(self) -> T {\n+                self.0.into_inner()\n+            }\n+\n+            #[inline]\n+            pub fn load(&self) -> T {\n+                self.0.get()\n+            }\n+\n+            #[inline]\n+            pub fn store(&self, val: T) {\n+                self.0.set(val)\n+            }\n+\n+            #[inline]\n+            pub fn swap(&self, val: T) -> T {\n+                self.0.replace(val)\n+            }\n+        }\n+\n+        /// This is a single threaded variant of `AtomicU64`, `AtomicUsize`, etc.\n+        /// It differs from `AtomicCell` in that it has explicit ordering arguments\n+        /// and is only intended for use with the native atomic types.\n+        /// You should use this type through the `AtomicU64`, `AtomicUsize`, etc, type aliases\n+        /// as it's not intended to be used separately.\n         #[derive(Debug)]\n         pub struct Atomic<T: Copy>(Cell<T>);\n \n@@ -77,7 +122,8 @@ cfg_if! {\n             }\n         }\n \n-        impl<T: Copy + PartialEq> Atomic<T> {\n+        impl<T: Copy> Atomic<T> {\n+            #[inline]\n             pub fn into_inner(self) -> T {\n                 self.0.into_inner()\n             }\n@@ -92,10 +138,14 @@ cfg_if! {\n                 self.0.set(val)\n             }\n \n+            #[inline]\n             pub fn swap(&self, val: T, _: Ordering) -> T {\n                 self.0.replace(val)\n             }\n+        }\n \n+        impl<T: Copy + PartialEq> Atomic<T> {\n+            #[inline]\n             pub fn compare_exchange(&self,\n                                     current: T,\n                                     new: T,\n@@ -113,6 +163,7 @@ cfg_if! {\n         }\n \n         impl<T: Add<Output=T> + Copy> Atomic<T> {\n+            #[inline]\n             pub fn fetch_add(&self, val: T, _: Ordering) -> T {\n                 let old = self.0.get();\n                 self.0.set(old + val);\n@@ -271,6 +322,8 @@ cfg_if! {\n \n         pub use std::sync::atomic::{AtomicBool, AtomicUsize, AtomicU32, AtomicU64};\n \n+        pub use crossbeam_utils::atomic::AtomicCell;\n+\n         pub use std::sync::Arc as Lrc;\n         pub use std::sync::Weak as Weak;\n "}]}