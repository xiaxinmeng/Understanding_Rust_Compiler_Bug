{"sha": "6f09d80f97457fd69fa736d71c491042b2c945df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmMDlkODBmOTc0NTdmZDY5ZmE3MzZkNzFjNDkxMDQyYjJjOTQ1ZGY=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2013-09-28T00:03:34Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-01-07T03:37:26Z"}, "message": "Add Pointer tutorial, rename borrowed pointer tutorial.", "tree": {"sha": "4cc51612ee97840e6be9429b6c643b3a2358114c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cc51612ee97840e6be9429b6c643b3a2358114c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f09d80f97457fd69fa736d71c491042b2c945df", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f09d80f97457fd69fa736d71c491042b2c945df", "html_url": "https://github.com/rust-lang/rust/commit/6f09d80f97457fd69fa736d71c491042b2c945df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f09d80f97457fd69fa736d71c491042b2c945df/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4639ade00afe39b41182e0cde7b999ada185f22", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4639ade00afe39b41182e0cde7b999ada185f22", "html_url": "https://github.com/rust-lang/rust/commit/d4639ade00afe39b41182e0cde7b999ada185f22"}], "stats": {"total": 510, "additions": 497, "deletions": 13}, "files": [{"sha": "b40d303fe7ff640ea4574f44e72dbe693ee0c0b5", "filename": "configure", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f09d80f97457fd69fa736d71c491042b2c945df/configure", "raw_url": "https://github.com/rust-lang/rust/raw/6f09d80f97457fd69fa736d71c491042b2c945df/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=6f09d80f97457fd69fa736d71c491042b2c945df", "patch": "@@ -800,7 +800,8 @@ do\n     make_dir $h/test/doc-tutorial\n     make_dir $h/test/doc-guide-ffi\n     make_dir $h/test/doc-guide-macros\n-    make_dir $h/test/doc-guide-borrowed-ptr\n+    make_dir $h/test/doc-guide-lifetimes\n+    make_dir $h/test/doc-guide-pointers\n     make_dir $h/test/doc-guide-container\n     make_dir $h/test/doc-guide-tasks\n     make_dir $h/test/doc-guide-conditions"}, {"sha": "7ad1ee27729bc9d336bfcf72b0c0b1b54e347fab", "filename": "doc/guide-lifetimes.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6f09d80f97457fd69fa736d71c491042b2c945df/doc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/6f09d80f97457fd69fa736d71c491042b2c945df/doc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-lifetimes.md?ref=6f09d80f97457fd69fa736d71c491042b2c945df", "previous_filename": "doc/guide-borrowed-ptr.md"}, {"sha": "4028ed203cd5f5527add7cfd8041550a45a08dee", "filename": "doc/guide-pointers.md", "status": "added", "additions": 475, "deletions": 0, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/6f09d80f97457fd69fa736d71c491042b2c945df/doc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/6f09d80f97457fd69fa736d71c491042b2c945df/doc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-pointers.md?ref=6f09d80f97457fd69fa736d71c491042b2c945df", "patch": "@@ -0,0 +1,475 @@\n+% The Rust Pointer Guide\n+\n+Rust's pointers are one of its more unique and compelling features. Pointers\n+are also one of the more confusing topics for newcomers to Rust. They can also\n+be confusing for people coming from other languages that support pointers, such\n+as C++. This tutorial will help you understand this important topic.\n+\n+# You don't actually need pointers\n+\n+I have good news for you: you probably don't need to care about pointers,\n+especially as you're getting started. Think of it this way: Rust is a language\n+that emphasizes safety. Pointers, as the joke goes, are very pointy: it's easy\n+to accidentally stab yourself. Therefore, Rust is made in a way such that you\n+don't need them very often.\n+\n+\"But tutorial!\" you may cry. \"My co-worker wrote a function that looks like\n+this:\n+\n+```rust\n+fn succ(x: &int) -> int { *x + 1 }\n+```\n+\n+So I wrote this code to try it out:\n+\n+```rust\n+fn main() {\n+    let number = 5;\n+    let succ_number = succ(number);\n+    println!(\"{}\", succ_number);\n+}\n+```\n+\n+And now I get an error:\n+\n+```\n+error: mismatched types: expected `&int` but found `<VI0>` (expected &-ptr but found integral variable)\n+```\n+\n+What gives? It needs a pointer! Therefore I have to use pointers!\"\n+\n+Turns out, you don't. All you need is a reference. Try this on for size:\n+\n+```rust\n+fn main() {\n+    let number = 5;\n+    let succ_number = succ(&number);\n+    println!(\"{}\", succ_number);\n+}\n+```\n+\n+It's that easy! One extra little `&` there. This code will run, and print `6`.\n+\n+That's all you need to know. Your co-worker could have written the function\n+like this:\n+\n+```rust\n+fn succ(x: int) -> int { x + 1 }\n+\n+fn main() {\n+    let number = 5;\n+    let succ_number = succ(number);\n+    println!(\"{}\", succ_number);\n+}\n+```\n+\n+No pointers even needed. Then again, this is a simple example. I assume that\n+your real-world `succ` function is more complicated, and maybe your co-worker\n+had a good reason for `x` to be a pointer of some kind. In that case, references\n+are your best friend. Don't worry about it, life is too short.\n+\n+However.\n+\n+Here are the use-cases for pointers. I've prefixed them with the name of the\n+pointer that satisfies that use-case:\n+\n+1. Owned: ~Trait must be a pointer, becuase you don't know the size of the\n+object, so indirection is mandatory.\n+2. Owned: You need a recursive data structure. These can be infinite sized, so\n+indirection is mandatory.\n+3. Owned: A very, very, very rare situation in which you have a *huge* chunk of\n+data that you wish to pass to many methods. Passing a pointer will make this\n+more efficient. If you're coming from another language where this technique is\n+common, such as C++, please read \"A note...\" below.\n+4. Managed: Having only a single owner to a piece of data would be inconvenient\n+or impossible. This is only often useful when a program is very large or very\n+complicated. Using a managed pointer will activate Rust's garbage collection\n+mechanism.\n+5: Borrowed: You're writing a function, and you need a pointer, but you don't\n+care about its ownership. If you make the argument a borrowed pointer, callers\n+can send in whatever kind they want.\n+\n+Five exceptions. That's it. Otherwise, you shouldn't need them. Be skeptical\n+of pointers in Rust: use them for a deliberate purpose, not just to make the\n+compiler happy.\n+\n+## A note for those proficient in pointers\n+\n+If you're coming to Rust from a language like C or C++, you may be used to\n+passing things by reference, or passing things by pointer. In some langauges,\n+like Java, you can't even have objects without a pointer to them. Therefore, if\n+you were writing this Rust code:\n+\n+```rust\n+struct Point {\n+    x: int,\n+    y: int,\n+}\n+\n+fn main() {\n+    let p0 = Point { x: 5, y: 10};\n+    let p1 = transform(p0);\n+    println!(\"{:?}\", p1);\n+}\n+\n+```\n+\n+I think you'd implement `transform` like this:\n+\n+```rust\n+fn transform(p: &Point) -> Point {\n+    Point { x: p.x + 1, y: p.y + 1}\n+}\n+\n+// and change this:\n+let p1 = transform(&p0);\n+```\n+\n+This does work, but you don't need to create those references! The better way to write this is simply:\n+\n+```rust\n+struct Point {\n+    x: int,\n+    y: int,\n+}\n+\n+fn transform(p: Point) -> Point {\n+    Point { x: p.x + 1, y: p.y + 1}\n+}\n+\n+fn main() {\n+    let p0 = Point { x: 5, y: 10};\n+    let p1 = transform(p0);\n+    println!(\"{:?}\", p1);\n+}\n+```\n+\n+But won't this be inefficent? Well, that's a complicated question, but it's\n+important to know that Rust, like C and C++, store aggregate data types\n+'unboxed,' whereas languages like Java and Ruby store these types as 'boxed.'\n+For smaller structs, this way will be more efficient. For larger ones, it may\n+be less so. But don't reach for that pointer until you must! Make sure that the\n+struct is large enough by performing some tests before you add in the\n+complexity of pointers.\n+\n+# Owned Pointers\n+\n+Owned pointers are the conceptually simplest kind of pointer in Rust. A rough\n+approximation of owned pointers follows:\n+\n+1. Only one owned pointer may exist to a particular place in memory. It may be\n+borrowed from that owner, however.\n+2. The Rust compiler uses static analysis to determine where the pointer is in\n+scope, and handles allocating and de-allocating that memory. Owned pointers are\n+not garbage collected.\n+\n+These two properties make for three use cases.\n+\n+## References to Traits\n+\n+Traits must be referenced through a pointer, becuase the struct that implements\n+the trait may be a different size than a different struct that implements the\n+trait. Therefore, unboxed traits don't make any sense, and aren't allowed.\n+\n+## Recursive Data Structures\n+\n+Sometimes, you need a recursive data structure. The simplest is known as a 'cons list':\n+\n+```rust\n+enum List<T> {\n+    Nil,\n+    Cons(T, ~List<T>),\n+}\n+    \n+fn main() {\n+    let list: List<int> = Cons(1, ~Cons(2, ~Cons(3, ~Nil)));\n+    println!(\"{:?}\", list);\n+}\n+```\n+\n+This prints:\n+\n+```\n+Cons(1, ~Cons(2, ~Cons(3, ~Nil)))\n+```\n+\n+The inner lists _must_ be an owned pointer, becuase we can't know how many\n+elements are in the list. Without knowing the length, we don't know the size,\n+and therefore require the indirection that pointers offer.\n+\n+## Efficiency\n+\n+This should almost never be a concern, but because creating an owned pointer\n+boxes its value, it therefore makes referring to the value the size of the box.\n+This may make passing an owned pointer to a function less expensive than\n+passing the value itself. Don't worry yourself with this case until you've\n+proved that it's an issue through benchmarks.\n+\n+For example, this will work:\n+\n+```rust\n+struct Point {\n+    x: int,\n+    y: int,\n+}\n+\n+fn main() {\n+    let a = Point { x: 10, y: 20 };\n+    do spawn {\n+        println(a.x.to_str());\n+    }\n+}\n+```\n+\n+This struct is tiny, so it's fine. If `Point` were large, this would be more\n+efficient:\n+\n+```rust\n+struct Point {\n+    x: int,\n+    y: int,\n+}\n+\n+fn main() {\n+    let a = ~Point { x: 10, y: 20 };\n+    do spawn {\n+        println(a.x.to_str());\n+    }\n+}\n+```\n+\n+Now it'll be copying a pointer-sized chunk of memory rather than the whole\n+struct.\n+\n+# Managed Pointers\n+\n+Managed pointers, notated by an `@`, are used when having a single owner for\n+some data isn't convenient or possible. This generally happens when your\n+program is very large and complicated.\n+\n+For example, let's say you're using an owned pointer, and you want to do this:\n+\n+```rust\n+struct Point {\n+    x: int,\n+    y: int,\n+}\n+    \n+fn main() {\n+    let a = ~Point { x: 10, y: 20 };\n+    let b = a;\n+    println(b.x.to_str());\n+    println(a.x.to_str());\n+}\n+```\n+\n+You'll get this error:\n+\n+```\n+test.rs:10:12: 10:13 error: use of moved value: `a`\n+test.rs:10     println(a.x.to_str());\n+                       ^\n+test.rs:8:8: 8:9 note: `a` moved here because it has type `~Point`, which is moved by default (use `ref` to override)\n+test.rs:8     let b = a;\n+                  ^\n+```\n+\n+As the message says, owned pointers only allow for one owner at a time. When you assign `a` to `b`, `a` becomes invalid. Change your code to this, however:\n+\n+```rust\n+struct Point {\n+    x: int,\n+    y: int,\n+}\n+    \n+fn main() {\n+    let a = @Point { x: 10, y: 20 };\n+    let b = a;\n+    println(b.x.to_str());\n+    println(a.x.to_str());\n+}\n+```\n+\n+And it works:\n+\n+```\n+10\n+10\n+```\n+\n+So why not just use managed pointers everywhere? There are two big drawbacks to\n+managed pointers:\n+\n+1. They activate Rust's garbage collector. Other pointer types don't share this\n+drawback.\n+2. You cannot pass this data to another task. Shared ownership across\n+concurrency boundaries is the source of endless pain in other langauges, so\n+Rust does not let you do this.\n+\n+# Borrowed Pointers\n+\n+Borrowed pointers are the third major kind of pointer Rust supports. They are\n+simultaneously the simplest and the most complicated kind. Let me explain:\n+they're called 'borrowed' pointers because they claim no ownership over the\n+data they're pointing to. They're just borrowing it for a while. So in that\n+sense, they're simple: just keep whatever ownership the data already has. For\n+example:\n+\n+```rust\n+use std::num::sqrt;\n+\n+struct Point {\n+    x: float,\n+    y: float,\n+}\n+\n+fn compute_distance(p1: &Point, p2: &Point) -> float {\n+    let x_d = p1.x - p2.x;\n+    let y_d = p1.y - p2.y;\n+\n+    sqrt(x_d * x_d + y_d * y_d)\n+}\n+\n+fn main() {\n+    let origin = @Point { x: 0.0, y: 0.0 };\n+    let p1     = ~Point { x: 5.0, y: 3.0 };\n+\n+    println!(\"{:?}\", compute_distance(origin, p1));\n+}\n+```\n+\n+This prints `5.83095189`. You can see that the `compute_distance` function\n+takes in two borrowed pointers, but we give it a managed and unique pointer. Of\n+course, if this were a real program, we wouldn't have any of these pointers,\n+they're just there to demonstrate the concepts.\n+\n+So how is this hard? Well, because we're igorning ownership, the compiler needs\n+to take great care to make sure that everything is safe. Despite their complete\n+safety, a borrowed pointer's representation at runtime is the same as that of\n+an ordinary pointer in a C program. They introduce zero overhead. The compiler\n+does all safety checks at compile time. \n+\n+This theory is called 'region pointers,' and involve a concept called\n+'lifetimes'. Here's the simple explanation: would you expect this code to\n+compile?\n+\n+```rust\n+fn main() {\n+    println(x.to_str());\n+    let x = 5;\n+}\n+```\n+\n+Probably not. That's becuase you know that the name `x` is valid from where\n+it's declared to when it goes out of scope. In this case, that's the end of\n+the `main` function. So you know this code will cause an error. We call this\n+duration a 'lifetime'. Let's try a more complex example:\n+\n+```rust\n+fn main() {\n+    let mut x = ~5;\n+    if(*x < 10) {\n+        let y = &x;\n+        println!(\"Oh no: {:?}\", y);\n+        return;\n+    }\n+    *x = *x - 1;\n+    println!(\"Oh no: {:?}\", x);\n+}\n+```\n+\n+Here, we're borrowing a pointer to `x` inside of the `if`. The compiler, however,\n+is able to determine that that pointer will go out of scope without `x` being\n+mutated, and therefore, lets us pass. This wouldn't work:\n+\n+```rust\n+fn main() {\n+    let mut x = ~5;\n+    if(*x < 10) {\n+        let y = &x;\n+        *x = *x - 1;\n+\n+        println!(\"Oh no: {:?}\", y);\n+        return;\n+    }\n+    *x = *x - 1;\n+    println!(\"Oh no: {:?}\", x);\n+}\n+```\n+\n+It gives this error:\n+\n+```\n+test.rs:5:8: 5:10 error: cannot assign to `*x` because it is borrowed\n+test.rs:5         *x = *x - 1;\n+                  ^~\n+test.rs:4:16: 4:18 note: borrow of `*x` occurs here\n+test.rs:4         let y = &x;\n+                          ^~\n+```\n+\n+As you might guess, this kind of analysis is complex for a human, and therefore\n+hard for a computer, too! There is an entire [tutorial devoted to borrowed\n+pointers and lifetimes](tutorial-lifetimes.html) that goes into lifetimes in\n+great detail, so if you want the full details, check that out.\n+\n+# Returning Pointers\n+\n+We've talked a lot about funtions that accept various kinds of pointers, but\n+what about returning them? Here's the rule of thumb: only return a unique or\n+managed pointer if you were given one in the first place.\n+\n+What does that mean? Don't do this:\n+\n+```rust\n+fn foo(x: ~int) -> ~int {\n+    return ~*x;\n+}\n+\n+fn main() {\n+    let x = ~5;\n+    let y = foo(x);\n+}\n+```\n+\n+Do this:\n+\n+```rust\n+fn foo(x: ~int) -> int {\n+    return *x;\n+}\n+\n+fn main() {\n+    let x = ~5;\n+    let y = ~foo(x);\n+}\n+```\n+\n+This gives you flexibility, without sacrificing performance. For example, this will\n+also work:\n+\n+```rust\n+fn foo(x: ~int) -> int {\n+    return *x;\n+}\n+\n+fn main() {\n+    let x = ~5;\n+    let y = @foo(x);\n+}\n+```\n+\n+You may think that this gives us terrible performance: return a value and then\n+immediately box it up?!?! Isn't that the worst of both worlds? Rust is smarter\n+than that. There is no copy in this code. `main` allocates enough room for the\n+`@int`, passes it into `foo` as `x`, and then `foo` writes the value into the\n+new box. This writes the return value directly into the allocated box.\n+\n+This is important enough that it bears repeating: pointers are not for optimizing\n+returning values from your code. Allow the caller to choose how they want to\n+use your output.\n+\n+\n+# Related Resources\n+\n+* [Lifetimes tutorial](tutorial-lifetimes.html)"}, {"sha": "f1351c1489cb4ea28e21fca337cec069370e0f64", "filename": "doc/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f09d80f97457fd69fa736d71c491042b2c945df/doc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/6f09d80f97457fd69fa736d71c491042b2c945df/doc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Findex.md?ref=6f09d80f97457fd69fa736d71c491042b2c945df", "patch": "@@ -11,7 +11,7 @@\n \n # Guides\n \n-[Borrowed Pointers](guide-borrowed-ptr.html)  \n+[Pointers](guide-pointers.html)  \n [Lifetimes](guide-lifetimes.html)  \n [Containers and Iterators](guide-container.html)  \n [Tasks and Communication](guide-tasks.html)  "}, {"sha": "18766195ce257216f26aadfda6d801db36bdcd63", "filename": "doc/tutorial.md", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6f09d80f97457fd69fa736d71c491042b2c945df/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/6f09d80f97457fd69fa736d71c491042b2c945df/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=6f09d80f97457fd69fa736d71c491042b2c945df", "patch": "@@ -1423,10 +1423,8 @@ intuitive sense: you must wait for a borrowed value to be returned\n (that is, for the borrowed pointer to go out of scope) before you can\n make full use of it again.\n \n-For a more in-depth explanation of borrowed pointers, read the\n-[borrowed pointer tutorial][borrowtut].\n-\n-[borrowtut]: tutorial-borrowed-ptr.html\n+For a more in-depth explanation of borrowed pointers and lifetimes, read the\n+[lifetimes and borrowed pointer tutorial][lifetimes].\n \n ## Freezing\n \n@@ -3265,7 +3263,8 @@ re-export a bunch of 'officially blessed' crates that get managed with `rustpkg`\n Now that you know the essentials, check out any of the additional\n guides on individual topics.\n \n-* [Borrowed pointers][borrow]\n+* [Pointers][pointers]\n+* [Lifetimes][lifetimes]\n * [Tasks and communication][tasks]\n * [Macros][macros]\n * [The foreign function interface][ffi]\n@@ -3275,9 +3274,10 @@ guides on individual topics.\n * [Documenting Rust code][rustdoc]\n * [Testing Rust code][testing]\n \n-There is further documentation on the [Main Page](index.html).\n+There is further documentation on the [wiki], however those tend to be even more out of date as this document.\n \n-[borrow]: guide-borrowed-ptr.html\n+[pointers]: guide-pointers.html\n+[lifetimes]: guide-lifetimes.html\n [tasks]: guide-tasks.html\n [macros]: guide-macros.html\n [ffi]: guide-ffi.html\n@@ -3286,5 +3286,6 @@ There is further documentation on the [Main Page](index.html).\n [rustpkg]: guide-rustpkg.html\n [testing]: guide-testing.html\n [rustdoc]: rustdoc.html\n+[wiki]: https://github.com/mozilla/rust/wiki/Docs\n \n [wiki-packages]: https://github.com/mozilla/rust/wiki/Doc-packages,-editors,-and-other-tools"}, {"sha": "7859feae5f5498895752caf91dc0333c1ce6dc68", "filename": "mk/docs.mk", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f09d80f97457fd69fa736d71c491042b2c945df/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6f09d80f97457fd69fa736d71c491042b2c945df/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=6f09d80f97457fd69fa736d71c491042b2c945df", "patch": "@@ -194,8 +194,8 @@ doc/guide-testing.html: $(S)doc/guide-testing.md $(HTML_DEPS)\n \t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n \t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n \n-DOCS += doc/guide-borrowed-ptr.html\n-doc/guide-borrowed-ptr.html: $(S)doc/guide-borrowed-ptr.md $(HTML_DEPS)\n+DOCS += doc/guide-lifetimes.html\n+doc/guide-lifetimes.html: $(S)doc/guide-lifetimes.md $(HTML_DEPS)\n \t@$(call E, pandoc: $@)\n \t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n \t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n@@ -218,6 +218,12 @@ doc/guide-rustpkg.html: $(S)doc/guide-rustpkg.md $(HTML_DEPS)\n \t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n \t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n \n+DOCS += doc/guide-pointers.html\n+doc/guide-pointers.html: $(S)doc/guide-pointers.md $(HTML_DEPS)\n+\t@$(call E, pandoc: $@)\n+\t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n+\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n+\n   ifeq ($(CFG_PDFLATEX),)\n     $(info cfg: no pdflatex found, omitting doc/rust.pdf)\n   else"}, {"sha": "8bb6f7be55bec65916d74c839eb7f0e23704c8cc", "filename": "mk/tests.mk", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f09d80f97457fd69fa736d71c491042b2c945df/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6f09d80f97457fd69fa736d71c491042b2c945df/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=6f09d80f97457fd69fa736d71c491042b2c945df", "patch": "@@ -20,8 +20,9 @@ TEST_HOST_CRATES = rustpkg rustc rustdoc syntax\n TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n \n # Markdown files under doc/ that should have their code extracted and run\n-DOC_TEST_NAMES = tutorial guide-ffi guide-macros guide-borrowed-ptr \\\n-                 guide-tasks guide-conditions guide-container rust\n+DOC_TEST_NAMES = tutorial guide-ffi guide-macros guide-lifetimes \\\n+                 guide-tasks guide-conditions guide-container guide-pointers \\\n+                 rust\n \n ######################################################################\n # Environment configuration"}]}