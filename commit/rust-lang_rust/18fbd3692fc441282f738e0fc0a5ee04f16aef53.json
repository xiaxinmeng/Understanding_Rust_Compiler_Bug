{"sha": "18fbd3692fc441282f738e0fc0a5ee04f16aef53", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZmJkMzY5MmZjNDQxMjgyZjczOGUwZmMwYTVlZTA0ZjE2YWVmNTM=", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2021-04-18T05:34:58Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2021-04-18T06:08:28Z"}, "message": "rustdoc: get rid of CURRENT_DEPTH", "tree": {"sha": "698ce4469839f5c645ed1688aa45a4af4288ce93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/698ce4469839f5c645ed1688aa45a4af4288ce93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18fbd3692fc441282f738e0fc0a5ee04f16aef53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18fbd3692fc441282f738e0fc0a5ee04f16aef53", "html_url": "https://github.com/rust-lang/rust/commit/18fbd3692fc441282f738e0fc0a5ee04f16aef53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18fbd3692fc441282f738e0fc0a5ee04f16aef53/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "755b4fb02b2a1fcc7d1e2163d1b4b370699788c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/755b4fb02b2a1fcc7d1e2163d1b4b370699788c9", "html_url": "https://github.com/rust-lang/rust/commit/755b4fb02b2a1fcc7d1e2163d1b4b370699788c9"}], "stats": {"total": 96, "additions": 44, "deletions": 52}, "files": [{"sha": "e39652c6dd5dea08c1ccf10c6caf76c54368e659", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/18fbd3692fc441282f738e0fc0a5ee04f16aef53/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18fbd3692fc441282f738e0fc0a5ee04f16aef53/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=18fbd3692fc441282f738e0fc0a5ee04f16aef53", "patch": "@@ -7,6 +7,7 @@\n \n use std::cell::Cell;\n use std::fmt;\n+use std::iter;\n \n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n@@ -16,12 +17,10 @@ use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_target::spec::abi::Abi;\n \n use crate::clean::{self, utils::find_nearest_parent_module, PrimitiveType};\n-use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n use crate::html::render::cache::ExternalLocation;\n use crate::html::render::Context;\n-use crate::html::render::CURRENT_DEPTH;\n \n crate trait Print {\n     fn print(self, buffer: &mut Buffer);\n@@ -497,7 +496,7 @@ crate fn href_relative_parts<'a>(fqp: &'a [String], relative_to_fqp: &'a [String\n         if f != r {\n             let dissimilar_part_count = relative_to_fqp.len() - i;\n             let fqp_module = fqp[i..fqp.len()].iter().map(String::as_str);\n-            return std::iter::repeat(\"..\").take(dissimilar_part_count).chain(fqp_module).collect();\n+            return iter::repeat(\"..\").take(dissimilar_part_count).chain(fqp_module).collect();\n         }\n     }\n     // e.g. linking to std::sync::atomic from std::sync\n@@ -506,7 +505,7 @@ crate fn href_relative_parts<'a>(fqp: &'a [String], relative_to_fqp: &'a [String\n     // e.g. linking to std::sync from std::sync::atomic\n     } else if fqp.len() < relative_to_fqp.len() {\n         let dissimilar_part_count = relative_to_fqp.len() - fqp.len();\n-        std::iter::repeat(\"..\").take(dissimilar_part_count).collect()\n+        iter::repeat(\"..\").take(dissimilar_part_count).collect()\n     // linking to the same module\n     } else {\n         Vec::new()\n@@ -555,13 +554,14 @@ fn primitive_link(\n     f: &mut fmt::Formatter<'_>,\n     prim: clean::PrimitiveType,\n     name: &str,\n-    m: &Cache,\n+    cx: &Context<'_>,\n ) -> fmt::Result {\n+    let m = &cx.cache();\n     let mut needs_termination = false;\n     if !f.alternate() {\n         match m.primitive_locations.get(&prim) {\n             Some(&def_id) if def_id.is_local() => {\n-                let len = CURRENT_DEPTH.with(|s| s.get());\n+                let len = cx.current.len();\n                 let len = if len == 0 { 0 } else { len - 1 };\n                 write!(\n                     f,\n@@ -572,20 +572,28 @@ fn primitive_link(\n                 needs_termination = true;\n             }\n             Some(&def_id) => {\n+                let cname_str;\n                 let loc = match m.extern_locations[&def_id.krate] {\n-                    (ref cname, _, ExternalLocation::Remote(ref s)) => Some((cname, s.to_string())),\n+                    (ref cname, _, ExternalLocation::Remote(ref s)) => {\n+                        cname_str = cname.as_str();\n+                        Some(vec![s.trim_end_matches('/'), &cname_str[..]])\n+                    }\n                     (ref cname, _, ExternalLocation::Local) => {\n-                        let len = CURRENT_DEPTH.with(|s| s.get());\n-                        Some((cname, \"../\".repeat(len)))\n+                        cname_str = cname.as_str();\n+                        Some(if cx.current.first().map(|x| &x[..]) == Some(&cname_str[..]) {\n+                            iter::repeat(\"..\").take(cx.current.len() - 1).collect()\n+                        } else {\n+                            let cname = iter::once(&cname_str[..]);\n+                            iter::repeat(\"..\").take(cx.current.len()).chain(cname).collect()\n+                        })\n                     }\n                     (.., ExternalLocation::Unknown) => None,\n                 };\n-                if let Some((cname, root)) = loc {\n+                if let Some(loc) = loc {\n                     write!(\n                         f,\n-                        \"<a class=\\\"primitive\\\" href=\\\"{}{}/primitive.{}.html\\\">\",\n-                        root,\n-                        cname,\n+                        \"<a class=\\\"primitive\\\" href=\\\"{}/primitive.{}.html\\\">\",\n+                        loc.join(\"/\"),\n                         prim.to_url_str()\n                     )?;\n                     needs_termination = true;\n@@ -660,7 +668,7 @@ fn fmt_type<'cx>(\n             fmt::Display::fmt(&tybounds(param_names, cx), f)\n         }\n         clean::Infer => write!(f, \"_\"),\n-        clean::Primitive(prim) => primitive_link(f, prim, prim.as_str(), &cx.cache()),\n+        clean::Primitive(prim) => primitive_link(f, prim, prim.as_str(), cx),\n         clean::BareFunction(ref decl) => {\n             if f.alternate() {\n                 write!(\n@@ -679,46 +687,46 @@ fn fmt_type<'cx>(\n                     decl.unsafety.print_with_space(),\n                     print_abi_with_space(decl.abi)\n                 )?;\n-                primitive_link(f, PrimitiveType::Fn, \"fn\", &cx.cache())?;\n+                primitive_link(f, PrimitiveType::Fn, \"fn\", cx)?;\n                 write!(f, \"{}\", decl.decl.print(cx))\n             }\n         }\n         clean::Tuple(ref typs) => {\n             match &typs[..] {\n-                &[] => primitive_link(f, PrimitiveType::Unit, \"()\", &cx.cache()),\n+                &[] => primitive_link(f, PrimitiveType::Unit, \"()\", cx),\n                 &[ref one] => {\n-                    primitive_link(f, PrimitiveType::Tuple, \"(\", &cx.cache())?;\n+                    primitive_link(f, PrimitiveType::Tuple, \"(\", cx)?;\n                     // Carry `f.alternate()` into this display w/o branching manually.\n                     fmt::Display::fmt(&one.print(cx), f)?;\n-                    primitive_link(f, PrimitiveType::Tuple, \",)\", &cx.cache())\n+                    primitive_link(f, PrimitiveType::Tuple, \",)\", cx)\n                 }\n                 many => {\n-                    primitive_link(f, PrimitiveType::Tuple, \"(\", &cx.cache())?;\n+                    primitive_link(f, PrimitiveType::Tuple, \"(\", cx)?;\n                     for (i, item) in many.iter().enumerate() {\n                         if i != 0 {\n                             write!(f, \", \")?;\n                         }\n                         fmt::Display::fmt(&item.print(cx), f)?;\n                     }\n-                    primitive_link(f, PrimitiveType::Tuple, \")\", &cx.cache())\n+                    primitive_link(f, PrimitiveType::Tuple, \")\", cx)\n                 }\n             }\n         }\n         clean::Slice(ref t) => {\n-            primitive_link(f, PrimitiveType::Slice, \"[\", &cx.cache())?;\n+            primitive_link(f, PrimitiveType::Slice, \"[\", cx)?;\n             fmt::Display::fmt(&t.print(cx), f)?;\n-            primitive_link(f, PrimitiveType::Slice, \"]\", &cx.cache())\n+            primitive_link(f, PrimitiveType::Slice, \"]\", cx)\n         }\n         clean::Array(ref t, ref n) => {\n-            primitive_link(f, PrimitiveType::Array, \"[\", &cx.cache())?;\n+            primitive_link(f, PrimitiveType::Array, \"[\", cx)?;\n             fmt::Display::fmt(&t.print(cx), f)?;\n             if f.alternate() {\n-                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n), &cx.cache())\n+                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n), cx)\n             } else {\n-                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", Escape(n)), &cx.cache())\n+                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", Escape(n)), cx)\n             }\n         }\n-        clean::Never => primitive_link(f, PrimitiveType::Never, \"!\", &cx.cache()),\n+        clean::Never => primitive_link(f, PrimitiveType::Never, \"!\", cx),\n         clean::RawPointer(m, ref t) => {\n             let m = match m {\n                 hir::Mutability::Mut => \"mut\",\n@@ -731,24 +739,19 @@ fn fmt_type<'cx>(\n                             f,\n                             clean::PrimitiveType::RawPointer,\n                             &format!(\"*{} {:#}\", m, t.print(cx)),\n-                            &cx.cache(),\n+                            cx,\n                         )\n                     } else {\n                         primitive_link(\n                             f,\n                             clean::PrimitiveType::RawPointer,\n                             &format!(\"*{} {}\", m, t.print(cx)),\n-                            &cx.cache(),\n+                            cx,\n                         )\n                     }\n                 }\n                 _ => {\n-                    primitive_link(\n-                        f,\n-                        clean::PrimitiveType::RawPointer,\n-                        &format!(\"*{} \", m),\n-                        &cx.cache(),\n-                    )?;\n+                    primitive_link(f, clean::PrimitiveType::RawPointer, &format!(\"*{} \", m), cx)?;\n                     fmt::Display::fmt(&t.print(cx), f)\n                 }\n             }\n@@ -770,14 +773,14 @@ fn fmt_type<'cx>(\n                                     f,\n                                     PrimitiveType::Slice,\n                                     &format!(\"{}{}{}[{:#}]\", amp, lt, m, bt.print(cx)),\n-                                    &cx.cache(),\n+                                    cx,\n                                 )\n                             } else {\n                                 primitive_link(\n                                     f,\n                                     PrimitiveType::Slice,\n                                     &format!(\"{}{}{}[{}]\", amp, lt, m, bt.print(cx)),\n-                                    &cx.cache(),\n+                                    cx,\n                                 )\n                             }\n                         }\n@@ -786,14 +789,14 @@ fn fmt_type<'cx>(\n                                 f,\n                                 PrimitiveType::Slice,\n                                 &format!(\"{}{}{}[\", amp, lt, m),\n-                                &cx.cache(),\n+                                cx,\n                             )?;\n                             if f.alternate() {\n                                 write!(f, \"{:#}\", bt.print(cx))?;\n                             } else {\n                                 write!(f, \"{}\", bt.print(cx))?;\n                             }\n-                            primitive_link(f, PrimitiveType::Slice, \"]\", &cx.cache())\n+                            primitive_link(f, PrimitiveType::Slice, \"]\", cx)\n                         }\n                     }\n                 }\n@@ -807,7 +810,7 @@ fn fmt_type<'cx>(\n                         f,\n                         PrimitiveType::Reference,\n                         &format!(\"{}{}{}\", amp, lt, m),\n-                        &cx.cache(),\n+                        cx,\n                     )?;\n                     fmt_type(&ty, f, use_absolute, cx)\n                 }\n@@ -1292,7 +1295,7 @@ impl clean::ImportSource {\n                 }\n                 let name = self.path.last_name();\n                 if let hir::def::Res::PrimTy(p) = self.path.res {\n-                    primitive_link(f, PrimitiveType::from(p), &*name, &cx.cache())?;\n+                    primitive_link(f, PrimitiveType::from(p), &*name, cx)?;\n                 } else {\n                     write!(f, \"{}\", name)?;\n                 }"}, {"sha": "05d2001385929d96beff54a1775f94bb84d5c22e", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18fbd3692fc441282f738e0fc0a5ee04f16aef53/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18fbd3692fc441282f738e0fc0a5ee04f16aef53/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=18fbd3692fc441282f738e0fc0a5ee04f16aef53", "patch": "@@ -16,7 +16,7 @@ use rustc_span::{symbol::sym, Symbol};\n use super::cache::{build_index, ExternalLocation};\n use super::print_item::{full_path, item_path, print_item};\n use super::write_shared::write_shared;\n-use super::{print_sidebar, settings, AllTypes, NameDoc, StylePath, BASIC_KEYWORDS, CURRENT_DEPTH};\n+use super::{print_sidebar, settings, AllTypes, NameDoc, StylePath, BASIC_KEYWORDS};\n \n use crate::clean::{self, AttributesExt};\n use crate::config::RenderOptions;\n@@ -168,12 +168,6 @@ impl<'tcx> Context<'tcx> {\n     }\n \n     fn render_item(&self, it: &clean::Item, pushname: bool) -> String {\n-        // A little unfortunate that this is done like this, but it sure\n-        // does make formatting *a lot* nicer.\n-        CURRENT_DEPTH.with(|slot| {\n-            slot.set(self.current.len());\n-        });\n-\n         let mut title = if it.is_primitive() || it.is_keyword() {\n             // No need to include the namespace for primitive types and keywords\n             String::new()\n@@ -482,8 +476,6 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             cache: Rc::new(cache),\n         };\n \n-        CURRENT_DEPTH.with(|s| s.set(0));\n-\n         // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n         Rc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n         write_shared(&cx, &krate, index, &md_opts)?;"}, {"sha": "8b5e1aa1817d2cd4cb38c80c0b2294bc2b3b398a", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18fbd3692fc441282f738e0fc0a5ee04f16aef53/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18fbd3692fc441282f738e0fc0a5ee04f16aef53/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=18fbd3692fc441282f738e0fc0a5ee04f16aef53", "patch": "@@ -35,7 +35,6 @@ mod write_shared;\n crate use context::*;\n crate use write_shared::FILES_UNVERSIONED;\n \n-use std::cell::Cell;\n use std::collections::VecDeque;\n use std::default::Default;\n use std::fmt;\n@@ -209,8 +208,6 @@ crate struct StylePath {\n     crate disabled: bool,\n }\n \n-thread_local!(crate static CURRENT_DEPTH: Cell<usize> = Cell::new(0));\n-\n fn write_srclink(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer) {\n     if let Some(l) = cx.src_href(item) {\n         write!(buf, \"<a class=\\\"srclink\\\" href=\\\"{}\\\" title=\\\"goto source code\\\">[src]</a>\", l)"}]}