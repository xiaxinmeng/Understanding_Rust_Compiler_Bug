{"sha": "08fb953e1a9ac43720db6cf1d75bd19f5aa3cff5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZmI5NTNlMWE5YWM0MzcyMGRiNmNmMWQ3NWJkMTlmNWFhM2NmZjU=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-01T23:36:37Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-01T23:36:37Z"}, "message": "extended pattern matching", "tree": {"sha": "144f10b0971c9a6a73bc60572db2ef2a93614043", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/144f10b0971c9a6a73bc60572db2ef2a93614043"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08fb953e1a9ac43720db6cf1d75bd19f5aa3cff5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08fb953e1a9ac43720db6cf1d75bd19f5aa3cff5", "html_url": "https://github.com/rust-lang/rust/commit/08fb953e1a9ac43720db6cf1d75bd19f5aa3cff5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08fb953e1a9ac43720db6cf1d75bd19f5aa3cff5/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91c3c978285041005b8002c1587b16c883fc0a0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/91c3c978285041005b8002c1587b16c883fc0a0f", "html_url": "https://github.com/rust-lang/rust/commit/91c3c978285041005b8002c1587b16c883fc0a0f"}], "stats": {"total": 52, "additions": 45, "deletions": 7}, "files": [{"sha": "e7097f9daf675f06585e3398ee45f93368576769", "filename": "src/shadow.rs", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/08fb953e1a9ac43720db6cf1d75bd19f5aa3cff5/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08fb953e1a9ac43720db6cf1d75bd19f5aa3cff5/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=08fb953e1a9ac43720db6cf1d75bd19f5aa3cff5", "patch": "@@ -60,8 +60,12 @@ fn check_decl(cx: &Context, decl: &Decl, bindings: &mut Vec<Name>) {\n     if let DeclLocal(ref local) = decl.node {\n         let Local{ ref pat, ref ty, ref init, id: _, span } = **local;\n         if let &Some(ref t) = ty { check_ty(cx, t, bindings) }\n-        if let &Some(ref o) = init { check_expr(cx, o, bindings) }\n-        check_pat(cx, pat, init, span, bindings);\n+        if let &Some(ref o) = init { \n+            check_expr(cx, o, bindings);\n+            check_pat(cx, pat, &Some(o), span, bindings);\n+        } else {\n+            check_pat(cx, pat, &None, span, bindings);\n+        }\n     }\n }\n \n@@ -72,8 +76,8 @@ fn is_binding(cx: &Context, pat: &Pat) -> bool {\n     }\n }\n \n-fn check_pat<T>(cx: &Context, pat: &Pat, init: &Option<T>, span: Span,\n-        bindings: &mut Vec<Name>) where T: Deref<Target=Expr> {\n+fn check_pat(cx: &Context, pat: &Pat, init: &Option<&Expr>, span: Span,\n+        bindings: &mut Vec<Name>) {\n     //TODO: match more stuff / destructuring\n     match pat.node {\n         PatIdent(_, ref ident, ref inner) => {\n@@ -88,9 +92,43 @@ fn check_pat<T>(cx: &Context, pat: &Pat, init: &Option<T>, span: Span,\n             if let Some(ref p) = *inner { check_pat(cx, p, init, span, bindings); }\n         },\n         //PatEnum(Path, Option<Vec<P<Pat>>>),\n-        //PatQPath(QSelf, Path),\n-        //PatStruct(Path, Vec<Spanned<FieldPat>>, bool),\n-        //PatTup(Vec<P<Pat>>),\n+        PatStruct(_, ref pfields, _) => \n+            if let Some(ref init_struct) = *init { // TODO follow\n+                if let ExprStruct(_, ref efields, ref _base) = init_struct.node {\n+                    // TODO: follow base\n+                    for field in pfields {\n+                        let ident = field.node.ident;\n+                        let efield = efields.iter()\n+                            .find(|ref f| f.ident.node == ident)\n+                            .map(|f| &*f.expr);\n+                        check_pat(cx, &field.node.pat, &efield, span, bindings);\n+                    }\n+                } else {\n+                    for field in pfields {\n+                        check_pat(cx, &field.node.pat, &None, span, bindings);\n+                    }\n+                }\n+            } else {\n+                for field in pfields {\n+                    check_pat(cx, &field.node.pat, &None, span, bindings);\n+                }\n+            },\n+        PatTup(ref inner) =>\n+            if let Some(ref init_tup) = *init { //TODO: follow\n+                if let ExprTup(ref tup) = init_tup.node {\n+                    for (i, p) in inner.iter().enumerate() { \n+                        check_pat(cx, p, &Some(&tup[i]), p.span, bindings);\n+                    }\n+                } else {\n+                    for p in inner {\n+                        check_pat(cx, p, &None, span, bindings);\n+                    }\n+                }\n+            } else {\n+                for p in inner {\n+                    check_pat(cx, p, &None, span, bindings);\n+                }\n+            },\n         PatBox(ref inner) => {\n             if let Some(ref initp) = *init {\n                 match initp.node {"}]}