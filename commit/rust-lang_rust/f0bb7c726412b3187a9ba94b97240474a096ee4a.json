{"sha": "f0bb7c726412b3187a9ba94b97240474a096ee4a", "node_id": "C_kwDOAAsO6NoAKGYwYmI3YzcyNjQxMmIzMTg3YTliYTk0Yjk3MjQwNDc0YTA5NmVlNGE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-12T07:14:22Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-12T07:38:07Z"}, "message": "make eval_libc functions ICE on any problem", "tree": {"sha": "6c0bb4c02e70b88bb87f2d1e2cd1ed7b29780215", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c0bb4c02e70b88bb87f2d1e2cd1ed7b29780215"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0bb7c726412b3187a9ba94b97240474a096ee4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0bb7c726412b3187a9ba94b97240474a096ee4a", "html_url": "https://github.com/rust-lang/rust/commit/f0bb7c726412b3187a9ba94b97240474a096ee4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0bb7c726412b3187a9ba94b97240474a096ee4a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c905ef4a6b8d114af8b97ad37f2adb171c917ea6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c905ef4a6b8d114af8b97ad37f2adb171c917ea6", "html_url": "https://github.com/rust-lang/rust/commit/c905ef4a6b8d114af8b97ad37f2adb171c917ea6"}], "stats": {"total": 379, "additions": 200, "deletions": 179}, "files": [{"sha": "c11c6104c2843474c4a253216daedc471d66ebb0", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=f0bb7c726412b3187a9ba94b97240474a096ee4a", "patch": "@@ -138,55 +138,77 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             .unwrap_or_else(|| panic!(\"failed to find required Rust item: {path:?}\"))\n     }\n \n-    /// Evaluates the scalar at the specified path. Returns Some(val)\n-    /// if the path could be resolved, and None otherwise\n-    fn eval_path_scalar(&self, path: &[&str]) -> InterpResult<'tcx, Scalar<Provenance>> {\n+    /// Evaluates the scalar at the specified path.\n+    fn eval_path_scalar(&self, path: &[&str]) -> Scalar<Provenance> {\n         let this = self.eval_context_ref();\n         let instance = this.resolve_path(path, Namespace::ValueNS);\n         let cid = GlobalId { instance, promoted: None };\n         // We don't give a span -- this isn't actually used directly by the program anyway.\n-        let const_val = this.eval_global(cid, None)?;\n+        let const_val = this\n+            .eval_global(cid, None)\n+            .unwrap_or_else(|err| panic!(\"failed to evaluate required Rust item: {path:?}\\n{err}\"));\n         this.read_scalar(&const_val.into())\n+            .unwrap_or_else(|err| panic!(\"failed to read required Rust item: {path:?}\\n{err}\"))\n     }\n \n     /// Helper function to get a `libc` constant as a `Scalar`.\n-    fn eval_libc(&self, name: &str) -> InterpResult<'tcx, Scalar<Provenance>> {\n+    fn eval_libc(&self, name: &str) -> Scalar<Provenance> {\n         self.eval_path_scalar(&[\"libc\", name])\n     }\n \n     /// Helper function to get a `libc` constant as an `i32`.\n-    fn eval_libc_i32(&self, name: &str) -> InterpResult<'tcx, i32> {\n+    fn eval_libc_i32(&self, name: &str) -> i32 {\n         // TODO: Cache the result.\n-        self.eval_libc(name)?.to_i32()\n+        self.eval_libc(name).to_i32().unwrap_or_else(|_err| {\n+            panic!(\"required libc item has unexpected type (not `i32`): {name}\")\n+        })\n+    }\n+\n+    /// Helper function to get a `libc` constant as an `u32`.\n+    fn eval_libc_u32(&self, name: &str) -> u32 {\n+        // TODO: Cache the result.\n+        self.eval_libc(name).to_u32().unwrap_or_else(|_err| {\n+            panic!(\"required libc item has unexpected type (not `u32`): {name}\")\n+        })\n     }\n \n     /// Helper function to get a `windows` constant as a `Scalar`.\n-    fn eval_windows(&self, module: &str, name: &str) -> InterpResult<'tcx, Scalar<Provenance>> {\n+    fn eval_windows(&self, module: &str, name: &str) -> Scalar<Provenance> {\n         self.eval_context_ref().eval_path_scalar(&[\"std\", \"sys\", \"windows\", module, name])\n     }\n \n+    /// Helper function to get a `windows` constant as a `u32`.\n+    fn eval_windows_u32(&self, module: &str, name: &str) -> u32 {\n+        // TODO: Cache the result.\n+        self.eval_windows(module, name).to_u32().unwrap_or_else(|_err| {\n+            panic!(\"required Windows item has unexpected type (not `u32`): {module}::{name}\")\n+        })\n+    }\n+\n     /// Helper function to get a `windows` constant as a `u64`.\n-    fn eval_windows_u64(&self, module: &str, name: &str) -> InterpResult<'tcx, u64> {\n+    fn eval_windows_u64(&self, module: &str, name: &str) -> u64 {\n         // TODO: Cache the result.\n-        self.eval_windows(module, name)?.to_u64()\n+        self.eval_windows(module, name).to_u64().unwrap_or_else(|_err| {\n+            panic!(\"required Windows item has unexpected type (not `u64`): {module}::{name}\")\n+        })\n     }\n \n     /// Helper function to get the `TyAndLayout` of a `libc` type\n-    fn libc_ty_layout(&self, name: &str) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n+    fn libc_ty_layout(&self, name: &str) -> TyAndLayout<'tcx> {\n         let this = self.eval_context_ref();\n         let ty = this\n             .resolve_path(&[\"libc\", name], Namespace::TypeNS)\n             .ty(*this.tcx, ty::ParamEnv::reveal_all());\n-        this.layout_of(ty)\n+        this.layout_of(ty).unwrap()\n     }\n \n     /// Helper function to get the `TyAndLayout` of a `windows` type\n-    fn windows_ty_layout(&self, name: &str) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n+    fn windows_ty_layout(&self, name: &str) -> TyAndLayout<'tcx> {\n         let this = self.eval_context_ref();\n         let ty = this\n             .resolve_path(&[\"std\", \"sys\", \"windows\", \"c\", name], Namespace::TypeNS)\n             .ty(*this.tcx, ty::ParamEnv::reveal_all());\n-        this.layout_of(ty)\n+        this.layout_of(ty).unwrap()\n     }\n \n     /// Project to the given *named* field of the mplace (which must be a struct or union type).\n@@ -609,14 +631,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         if target.families.iter().any(|f| f == \"unix\") {\n             for &(name, kind) in UNIX_IO_ERROR_TABLE {\n                 if err_kind == kind {\n-                    return this.eval_libc(name);\n+                    return Ok(this.eval_libc(name));\n                 }\n             }\n             throw_unsup_format!(\"io error {:?} cannot be translated into a raw os error\", err_kind)\n         } else if target.families.iter().any(|f| f == \"windows\") {\n             // FIXME: we have to finish implementing the Windows equivalent of this.\n             use std::io::ErrorKind::*;\n-            this.eval_windows(\n+            Ok(this.eval_windows(\n                 \"c\",\n                 match err_kind {\n                     NotFound => \"ERROR_FILE_NOT_FOUND\",\n@@ -627,7 +649,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                             err_kind\n                         ),\n                 },\n-            )\n+            ))\n         } else {\n             throw_unsup_format!(\n                 \"converting io::Error into errnum is unsupported for OS {}\",\n@@ -647,7 +669,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         if target.families.iter().any(|f| f == \"unix\") {\n             let errnum = errnum.to_i32()?;\n             for &(name, kind) in UNIX_IO_ERROR_TABLE {\n-                if errnum == this.eval_libc_i32(name)? {\n+                if errnum == this.eval_libc_i32(name) {\n                     return Ok(Some(kind));\n                 }\n             }"}, {"sha": "054162a4ea9f5a06195850b2c685b829b42a19ac", "filename": "src/tools/miri/src/shims/env.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs?ref=f0bb7c726412b3187a9ba94b97240474a096ee4a", "patch": "@@ -170,7 +170,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 ))\n             }\n             None => {\n-                let envvar_not_found = this.eval_windows(\"c\", \"ERROR_ENVVAR_NOT_FOUND\")?;\n+                let envvar_not_found = this.eval_windows(\"c\", \"ERROR_ENVVAR_NOT_FOUND\");\n                 this.set_last_error(envvar_not_found)?;\n                 Scalar::from_u32(0) // return zero upon failure\n             }\n@@ -240,7 +240,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             Ok(0) // return zero on success\n         } else {\n             // name argument is a null pointer, points to an empty string, or points to a string containing an '=' character.\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             Ok(-1)\n         }\n@@ -274,15 +274,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n                 this.update_environ()?;\n             }\n-            Ok(this.eval_windows(\"c\", \"TRUE\")?)\n+            Ok(this.eval_windows(\"c\", \"TRUE\"))\n         } else {\n             let value = this.read_os_str_from_wide_str(value_ptr)?;\n             let var_ptr = alloc_env_var_as_wide_str(&name, &value, this)?;\n             if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n                 this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n             }\n             this.update_environ()?;\n-            Ok(this.eval_windows(\"c\", \"TRUE\")?)\n+            Ok(this.eval_windows(\"c\", \"TRUE\"))\n         }\n     }\n \n@@ -306,7 +306,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             Ok(0)\n         } else {\n             // name argument is a null pointer, points to an empty string, or points to a string containing an '=' character.\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             Ok(-1)\n         }\n@@ -335,7 +335,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 if this.write_path_to_c_str(&cwd, buf, size)?.0 {\n                     return Ok(buf);\n                 }\n-                let erange = this.eval_libc(\"ERANGE\")?;\n+                let erange = this.eval_libc(\"ERANGE\");\n                 this.set_last_error(erange)?;\n             }\n             Err(e) => this.set_last_error_from_io_error(e.kind())?,\n@@ -411,14 +411,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             this.reject_in_isolation(\"`SetCurrentDirectoryW`\", reject_with)?;\n             this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n \n-            return this.eval_windows(\"c\", \"FALSE\");\n+            return Ok(this.eval_windows(\"c\", \"FALSE\"));\n         }\n \n         match env::set_current_dir(path) {\n-            Ok(()) => this.eval_windows(\"c\", \"TRUE\"),\n+            Ok(()) => Ok(this.eval_windows(\"c\", \"TRUE\")),\n             Err(e) => {\n                 this.set_last_error_from_io_error(e.kind())?;\n-                this.eval_windows(\"c\", \"FALSE\")\n+                Ok(this.eval_windows(\"c\", \"FALSE\"))\n             }\n         }\n     }"}, {"sha": "ef411eb8aa7248bfe0c2028dcdac42b66e44b63b", "filename": "src/tools/miri/src/shims/time.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs?ref=f0bb7c726412b3187a9ba94b97240474a096ee4a", "patch": "@@ -36,26 +36,26 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // Linux further distinguishes regular and \"coarse\" clocks, but the \"coarse\" version\n                 // is just specified to be \"faster and less precise\", so we implement both the same way.\n                 absolute_clocks = vec![\n-                    this.eval_libc_i32(\"CLOCK_REALTIME\")?,\n-                    this.eval_libc_i32(\"CLOCK_REALTIME_COARSE\")?,\n+                    this.eval_libc_i32(\"CLOCK_REALTIME\"),\n+                    this.eval_libc_i32(\"CLOCK_REALTIME_COARSE\"),\n                 ];\n                 // The second kind is MONOTONIC clocks for which 0 is an arbitrary time point, but they are\n                 // never allowed to go backwards. We don't need to do any additonal monotonicity\n                 // enforcement because std::time::Instant already guarantees that it is monotonic.\n                 relative_clocks = vec![\n-                    this.eval_libc_i32(\"CLOCK_MONOTONIC\")?,\n-                    this.eval_libc_i32(\"CLOCK_MONOTONIC_COARSE\")?,\n+                    this.eval_libc_i32(\"CLOCK_MONOTONIC\"),\n+                    this.eval_libc_i32(\"CLOCK_MONOTONIC_COARSE\"),\n                 ];\n             }\n             \"macos\" => {\n-                absolute_clocks = vec![this.eval_libc_i32(\"CLOCK_REALTIME\")?];\n-                relative_clocks = vec![this.eval_libc_i32(\"CLOCK_MONOTONIC\")?];\n+                absolute_clocks = vec![this.eval_libc_i32(\"CLOCK_REALTIME\")];\n+                relative_clocks = vec![this.eval_libc_i32(\"CLOCK_MONOTONIC\")];\n                 // Some clocks only seem to exist in the aarch64 version of the target.\n                 if this.tcx.sess.target.arch == \"aarch64\" {\n                     // `CLOCK_UPTIME_RAW` supposed to not increment while the system is asleep... but\n                     // that's not really something a program running inside Miri can tell, anyway.\n                     // We need to support it because std uses it.\n-                    relative_clocks.push(this.eval_libc_i32(\"CLOCK_UPTIME_RAW\")?);\n+                    relative_clocks.push(this.eval_libc_i32(\"CLOCK_UPTIME_RAW\"));\n                 }\n             }\n             target => throw_unsup_format!(\"`clock_gettime` is not supported on target OS {target}\"),\n@@ -68,7 +68,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             this.machine.clock.now().duration_since(this.machine.clock.anchor())\n         } else {\n             // Unsupported clock.\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             return Ok(Scalar::from_i32(-1));\n         };\n@@ -94,7 +94,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Using tz is obsolete and should always be null\n         let tz = this.read_pointer(tz_op)?;\n         if !this.ptr_is_null(tz)? {\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             return Ok(-1);\n         }\n@@ -118,9 +118,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.assert_target_os(\"windows\", \"GetSystemTimeAsFileTime\");\n         this.check_no_isolation(\"`GetSystemTimeAsFileTime`\")?;\n \n-        let NANOS_PER_SEC = this.eval_windows_u64(\"time\", \"NANOS_PER_SEC\")?;\n-        let INTERVALS_PER_SEC = this.eval_windows_u64(\"time\", \"INTERVALS_PER_SEC\")?;\n-        let INTERVALS_TO_UNIX_EPOCH = this.eval_windows_u64(\"time\", \"INTERVALS_TO_UNIX_EPOCH\")?;\n+        let NANOS_PER_SEC = this.eval_windows_u64(\"time\", \"NANOS_PER_SEC\");\n+        let INTERVALS_PER_SEC = this.eval_windows_u64(\"time\", \"INTERVALS_PER_SEC\");\n+        let INTERVALS_TO_UNIX_EPOCH = this.eval_windows_u64(\"time\", \"INTERVALS_TO_UNIX_EPOCH\");\n         let NANOS_PER_INTERVAL = NANOS_PER_SEC / INTERVALS_PER_SEC;\n         let SECONDS_TO_UNIX_EPOCH = INTERVALS_TO_UNIX_EPOCH / INTERVALS_PER_SEC;\n \n@@ -226,7 +226,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let duration = match this.read_timespec(&this.deref_operand(req_op)?)? {\n             Some(duration) => duration,\n             None => {\n-                let einval = this.eval_libc(\"EINVAL\")?;\n+                let einval = this.eval_libc(\"EINVAL\");\n                 this.set_last_error(einval)?;\n                 return Ok(-1);\n             }"}, {"sha": "7768772338a777b73d709b1dbd68985435ee1643", "filename": "src/tools/miri/src/shims/tls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs?ref=f0bb7c726412b3187a9ba94b97240474a096ee4a", "patch": "@@ -303,12 +303,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             return Ok(());\n         }\n         let thread_callback =\n-            this.eval_windows(\"thread_local_key\", \"p_thread_callback\")?.to_pointer(this)?;\n+            this.eval_windows(\"thread_local_key\", \"p_thread_callback\").to_pointer(this)?;\n         let thread_callback = this.get_ptr_fn(thread_callback)?.as_instance()?;\n \n         // FIXME: Technically, the reason should be `DLL_PROCESS_DETACH` when the main thread exits\n         // but std treats both the same.\n-        let reason = this.eval_windows(\"c\", \"DLL_THREAD_DETACH\")?;\n+        let reason = this.eval_windows(\"c\", \"DLL_THREAD_DETACH\");\n \n         // The signature of this function is `unsafe extern \"system\" fn(h: c::LPVOID, dwReason: c::DWORD, pv: c::LPVOID)`.\n         // FIXME: `h` should be a handle to the current module and what `pv` should be is unknown"}, {"sha": "f155e11241b7015673fdf1842dea9436e8926dfb", "filename": "src/tools/miri/src/shims/unix/foreign_items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs?ref=f0bb7c726412b3187a9ba94b97240474a096ee4a", "patch": "@@ -196,7 +196,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // Align must be power of 2, and also at least ptr-sized (POSIX rules).\n                 // But failure to adhere to this is not UB, it's an error condition.\n                 if !align.is_power_of_two() || align < this.pointer_size().bytes() {\n-                    let einval = this.eval_libc_i32(\"EINVAL\")?;\n+                    let einval = this.eval_libc_i32(\"EINVAL\");\n                     this.write_int(einval, dest)?;\n                 } else {\n                     if size == 0 {\n@@ -243,7 +243,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 ];\n                 let mut result = None;\n                 for &(sysconf_name, value) in sysconfs {\n-                    let sysconf_name = this.eval_libc_i32(sysconf_name)?;\n+                    let sysconf_name = this.eval_libc_i32(sysconf_name);\n                     if sysconf_name == name {\n                         result = Some(value(this));\n                         break;\n@@ -480,7 +480,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     None => format!(\"<unknown errnum in strerror_r: {errnum}>\"),\n                 };\n                 let (complete, _) = this.write_os_str_to_c_str(OsStr::new(&formatted), buf, buflen)?;\n-                let ret = if complete { 0 } else { this.eval_libc_i32(\"ERANGE\")? };\n+                let ret = if complete { 0 } else { this.eval_libc_i32(\"ERANGE\") };\n                 this.write_int(ret, dest)?;\n             }\n             \"getpid\" => {\n@@ -495,7 +495,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             if this.frame_in_std() => {\n                 let [_attr, guard_size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let guard_size = this.deref_operand(guard_size)?;\n-                let guard_size_layout = this.libc_ty_layout(\"size_t\")?;\n+                let guard_size_layout = this.libc_ty_layout(\"size_t\");\n                 this.write_scalar(Scalar::from_uint(this.machine.page_size, guard_size_layout.size), &guard_size.into())?;\n \n                 // Return success (`0`).\n@@ -589,7 +589,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     this.write_null(dest)?;\n                 } else {\n                     this.write_null(&result.into())?;\n-                    this.write_scalar(this.eval_libc(\"ERANGE\")?, dest)?;\n+                    this.write_scalar(this.eval_libc(\"ERANGE\"), dest)?;\n                 }\n             }\n "}, {"sha": "22fbd940e71266a87db977b361adc1cc4624daa1", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 64, "deletions": 65, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=f0bb7c726412b3187a9ba94b97240474a096ee4a", "patch": "@@ -382,7 +382,7 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx\n     /// types (like `read`, that returns an `i64`).\n     fn handle_not_found<T: From<i32>>(&mut self) -> InterpResult<'tcx, T> {\n         let this = self.eval_context_mut();\n-        let ebadf = this.eval_libc(\"EBADF\")?;\n+        let ebadf = this.eval_libc(\"EBADF\");\n         this.set_last_error(ebadf)?;\n         Ok((-1).into())\n     }\n@@ -395,11 +395,11 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx\n         match file_type {\n             Ok(file_type) => {\n                 if file_type.is_dir() {\n-                    Ok(this.eval_libc(\"DT_DIR\")?.to_u8()?.into())\n+                    Ok(this.eval_libc(\"DT_DIR\").to_u8()?.into())\n                 } else if file_type.is_file() {\n-                    Ok(this.eval_libc(\"DT_REG\")?.to_u8()?.into())\n+                    Ok(this.eval_libc(\"DT_REG\").to_u8()?.into())\n                 } else if file_type.is_symlink() {\n-                    Ok(this.eval_libc(\"DT_LNK\")?.to_u8()?.into())\n+                    Ok(this.eval_libc(\"DT_LNK\").to_u8()?.into())\n                 } else {\n                     // Certain file types are only supported when the host is a Unix system.\n                     // (i.e. devices and sockets) If it is, check those cases, if not, fall back to\n@@ -409,19 +409,19 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx\n                     {\n                         use std::os::unix::fs::FileTypeExt;\n                         if file_type.is_block_device() {\n-                            Ok(this.eval_libc(\"DT_BLK\")?.to_u8()?.into())\n+                            Ok(this.eval_libc(\"DT_BLK\").to_u8()?.into())\n                         } else if file_type.is_char_device() {\n-                            Ok(this.eval_libc(\"DT_CHR\")?.to_u8()?.into())\n+                            Ok(this.eval_libc(\"DT_CHR\").to_u8()?.into())\n                         } else if file_type.is_fifo() {\n-                            Ok(this.eval_libc(\"DT_FIFO\")?.to_u8()?.into())\n+                            Ok(this.eval_libc(\"DT_FIFO\").to_u8()?.into())\n                         } else if file_type.is_socket() {\n-                            Ok(this.eval_libc(\"DT_SOCK\")?.to_u8()?.into())\n+                            Ok(this.eval_libc(\"DT_SOCK\").to_u8()?.into())\n                         } else {\n-                            Ok(this.eval_libc(\"DT_UNKNOWN\")?.to_u8()?.into())\n+                            Ok(this.eval_libc(\"DT_UNKNOWN\").to_u8()?.into())\n                         }\n                     }\n                     #[cfg(not(unix))]\n-                    Ok(this.eval_libc(\"DT_UNKNOWN\")?.to_u8()?.into())\n+                    Ok(this.eval_libc(\"DT_UNKNOWN\").to_u8()?.into())\n                 }\n             }\n             Err(e) =>\n@@ -532,9 +532,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let mut options = OpenOptions::new();\n \n-        let o_rdonly = this.eval_libc_i32(\"O_RDONLY\")?;\n-        let o_wronly = this.eval_libc_i32(\"O_WRONLY\")?;\n-        let o_rdwr = this.eval_libc_i32(\"O_RDWR\")?;\n+        let o_rdonly = this.eval_libc_i32(\"O_RDONLY\");\n+        let o_wronly = this.eval_libc_i32(\"O_WRONLY\");\n+        let o_rdwr = this.eval_libc_i32(\"O_RDWR\");\n         // The first two bits of the flag correspond to the access mode in linux, macOS and\n         // windows. We need to check that in fact the access mode flags for the current target\n         // only use these two bits, otherwise we are in an unsupported target and should error.\n@@ -561,17 +561,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // options.\n         let mut mirror = access_mode;\n \n-        let o_append = this.eval_libc_i32(\"O_APPEND\")?;\n+        let o_append = this.eval_libc_i32(\"O_APPEND\");\n         if flag & o_append == o_append {\n             options.append(true);\n             mirror |= o_append;\n         }\n-        let o_trunc = this.eval_libc_i32(\"O_TRUNC\")?;\n+        let o_trunc = this.eval_libc_i32(\"O_TRUNC\");\n         if flag & o_trunc == o_trunc {\n             options.truncate(true);\n             mirror |= o_trunc;\n         }\n-        let o_creat = this.eval_libc_i32(\"O_CREAT\")?;\n+        let o_creat = this.eval_libc_i32(\"O_CREAT\");\n         if flag & o_creat == o_creat {\n             // Get the mode.  On macOS, the argument type `mode_t` is actually `u16`, but\n             // C integer promotion rules mean that on the ABI level, it gets passed as `u32`\n@@ -591,25 +591,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n             mirror |= o_creat;\n \n-            let o_excl = this.eval_libc_i32(\"O_EXCL\")?;\n+            let o_excl = this.eval_libc_i32(\"O_EXCL\");\n             if flag & o_excl == o_excl {\n                 mirror |= o_excl;\n                 options.create_new(true);\n             } else {\n                 options.create(true);\n             }\n         }\n-        let o_cloexec = this.eval_libc_i32(\"O_CLOEXEC\")?;\n+        let o_cloexec = this.eval_libc_i32(\"O_CLOEXEC\");\n         if flag & o_cloexec == o_cloexec {\n             // We do not need to do anything for this flag because `std` already sets it.\n             // (Technically we do not support *not* setting this flag, but we ignore that.)\n             mirror |= o_cloexec;\n         }\n         if this.tcx.sess.target.os == \"linux\" {\n-            let o_tmpfile = this.eval_libc_i32(\"O_TMPFILE\")?;\n+            let o_tmpfile = this.eval_libc_i32(\"O_TMPFILE\");\n             if flag & o_tmpfile == o_tmpfile {\n                 // if the flag contains `O_TMPFILE` then we return a graceful error\n-                let eopnotsupp = this.eval_libc(\"EOPNOTSUPP\")?;\n+                let eopnotsupp = this.eval_libc(\"EOPNOTSUPP\");\n                 this.set_last_error(eopnotsupp)?;\n                 return Ok(-1);\n             }\n@@ -657,18 +657,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         // We only support getting the flags for a descriptor.\n-        if cmd == this.eval_libc_i32(\"F_GETFD\")? {\n+        if cmd == this.eval_libc_i32(\"F_GETFD\") {\n             // Currently this is the only flag that `F_GETFD` returns. It is OK to just return the\n             // `FD_CLOEXEC` value without checking if the flag is set for the file because `std`\n             // always sets this flag when opening a file. However we still need to check that the\n             // file itself is open.\n             if this.machine.file_handler.handles.contains_key(&fd) {\n-                Ok(this.eval_libc_i32(\"FD_CLOEXEC\")?)\n+                Ok(this.eval_libc_i32(\"FD_CLOEXEC\"))\n             } else {\n                 this.handle_not_found()\n             }\n-        } else if cmd == this.eval_libc_i32(\"F_DUPFD\")?\n-            || cmd == this.eval_libc_i32(\"F_DUPFD_CLOEXEC\")?\n+        } else if cmd == this.eval_libc_i32(\"F_DUPFD\")\n+            || cmd == this.eval_libc_i32(\"F_DUPFD_CLOEXEC\")\n         {\n             // Note that we always assume the FD_CLOEXEC flag is set for every open file, in part\n             // because exec() isn't supported. The F_DUPFD and F_DUPFD_CLOEXEC commands only\n@@ -697,7 +697,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 }\n                 None => this.handle_not_found(),\n             }\n-        } else if this.tcx.sess.target.os == \"macos\" && cmd == this.eval_libc_i32(\"F_FULLFSYNC\")? {\n+        } else if this.tcx.sess.target.os == \"macos\" && cmd == this.eval_libc_i32(\"F_FULLFSYNC\") {\n             if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n                 // FIXME: Support fullfsync for all FDs\n                 let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n@@ -830,14 +830,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let offset = this.read_scalar(offset_op)?.to_i64()?;\n         let whence = this.read_scalar(whence_op)?.to_i32()?;\n \n-        let seek_from = if whence == this.eval_libc_i32(\"SEEK_SET\")? {\n+        let seek_from = if whence == this.eval_libc_i32(\"SEEK_SET\") {\n             SeekFrom::Start(u64::try_from(offset).unwrap())\n-        } else if whence == this.eval_libc_i32(\"SEEK_CUR\")? {\n+        } else if whence == this.eval_libc_i32(\"SEEK_CUR\") {\n             SeekFrom::Current(offset)\n-        } else if whence == this.eval_libc_i32(\"SEEK_END\")? {\n+        } else if whence == this.eval_libc_i32(\"SEEK_END\") {\n             SeekFrom::End(offset)\n         } else {\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             return Ok(Scalar::from_i64(-1));\n         };\n@@ -916,7 +916,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`stat`\", reject_with)?;\n-            let eacc = this.eval_libc(\"EACCES\")?;\n+            let eacc = this.eval_libc(\"EACCES\");\n             this.set_last_error(eacc)?;\n             return Ok(Scalar::from_i32(-1));\n         }\n@@ -945,7 +945,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`lstat`\", reject_with)?;\n-            let eacc = this.eval_libc(\"EACCES\")?;\n+            let eacc = this.eval_libc(\"EACCES\");\n             this.set_last_error(eacc)?;\n             return Ok(Scalar::from_i32(-1));\n         }\n@@ -1003,7 +1003,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         // If the statxbuf or pathname pointers are null, the function fails with `EFAULT`.\n         if this.ptr_is_null(statxbuf_ptr)? || this.ptr_is_null(pathname_ptr)? {\n-            let efault = this.eval_libc(\"EFAULT\")?;\n+            let efault = this.eval_libc(\"EFAULT\");\n             this.set_last_error(efault)?;\n             return Ok(-1);\n         }\n@@ -1014,13 +1014,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // as `isize`s instead of having the proper types. Thus, we have to recover the layout of\n         // `statxbuf_op` by using the `libc::statx` struct type.\n         let statxbuf = {\n-            let statx_layout = this.libc_ty_layout(\"statx\")?;\n+            let statx_layout = this.libc_ty_layout(\"statx\");\n             MPlaceTy::from_aligned_ptr(statxbuf_ptr, statx_layout)\n         };\n \n         let path = this.read_path_from_c_str(pathname_ptr)?.into_owned();\n         // See <https://github.com/rust-lang/rust/pull/79196> for a discussion of argument sizes.\n-        let at_ampty_path = this.eval_libc_i32(\"AT_EMPTY_PATH\")?;\n+        let at_ampty_path = this.eval_libc_i32(\"AT_EMPTY_PATH\");\n         let empty_path_flag = flags & at_ampty_path == at_ampty_path;\n         // We only support:\n         // * interpreting `path` as an absolute directory,\n@@ -1030,7 +1030,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Other behaviors cannot be tested from `libstd` and thus are not implemented. If you\n         // found this error, please open an issue reporting it.\n         if !(path.is_absolute()\n-            || dirfd == this.eval_libc_i32(\"AT_FDCWD\")?\n+            || dirfd == this.eval_libc_i32(\"AT_FDCWD\")\n             || (path.as_os_str().is_empty() && empty_path_flag))\n         {\n             throw_unsup_format!(\n@@ -1043,16 +1043,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`statx`\", reject_with)?;\n-            let ecode = if path.is_absolute() || dirfd == this.eval_libc_i32(\"AT_FDCWD\")? {\n+            let ecode = if path.is_absolute() || dirfd == this.eval_libc_i32(\"AT_FDCWD\") {\n                 // since `path` is provided, either absolute or\n                 // relative to CWD, `EACCES` is the most relevant.\n-                this.eval_libc(\"EACCES\")?\n+                this.eval_libc(\"EACCES\")\n             } else {\n                 // `dirfd` is set to target file, and `path` is empty\n                 // (or we would have hit the `throw_unsup_format`\n                 // above). `EACCES` would violate the spec.\n                 assert!(empty_path_flag);\n-                this.eval_libc(\"EBADF\")?\n+                this.eval_libc(\"EBADF\")\n             };\n             this.set_last_error(ecode)?;\n             return Ok(-1);\n@@ -1062,12 +1062,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // However `statx` is allowed to return information that was not requested or to not\n         // return information that was requested. This `mask` represents the information we can\n         // actually provide for any target.\n-        let mut mask =\n-            this.eval_libc(\"STATX_TYPE\")?.to_u32()? | this.eval_libc(\"STATX_SIZE\")?.to_u32()?;\n+        let mut mask = this.eval_libc_u32(\"STATX_TYPE\") | this.eval_libc_u32(\"STATX_SIZE\");\n \n         // If the `AT_SYMLINK_NOFOLLOW` flag is set, we query the file's metadata without following\n         // symbolic links.\n-        let follow_symlink = flags & this.eval_libc(\"AT_SYMLINK_NOFOLLOW\")?.to_i32()? == 0;\n+        let follow_symlink = flags & this.eval_libc_i32(\"AT_SYMLINK_NOFOLLOW\") == 0;\n \n         // If the path is empty, and the AT_EMPTY_PATH flag is set, we query the open file\n         // represented by dirfd, whether it's a directory or otherwise.\n@@ -1096,23 +1095,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let (access_sec, access_nsec) = metadata\n             .accessed\n             .map(|tup| {\n-                mask |= this.eval_libc(\"STATX_ATIME\")?.to_u32()?;\n+                mask |= this.eval_libc_u32(\"STATX_ATIME\");\n                 InterpResult::Ok(tup)\n             })\n             .unwrap_or_else(|| Ok((0, 0)))?;\n \n         let (created_sec, created_nsec) = metadata\n             .created\n             .map(|tup| {\n-                mask |= this.eval_libc(\"STATX_BTIME\")?.to_u32()?;\n+                mask |= this.eval_libc_u32(\"STATX_BTIME\");\n                 InterpResult::Ok(tup)\n             })\n             .unwrap_or_else(|| Ok((0, 0)))?;\n \n         let (modified_sec, modified_nsec) = metadata\n             .modified\n             .map(|tup| {\n-                mask |= this.eval_libc(\"STATX_MTIME\")?.to_u32()?;\n+                mask |= this.eval_libc_u32(\"STATX_MTIME\");\n                 InterpResult::Ok(tup)\n             })\n             .unwrap_or_else(|| Ok((0, 0)))?;\n@@ -1185,7 +1184,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let newpath_ptr = this.read_pointer(newpath_op)?;\n \n         if this.ptr_is_null(oldpath_ptr)? || this.ptr_is_null(newpath_ptr)? {\n-            let efault = this.eval_libc(\"EFAULT\")?;\n+            let efault = this.eval_libc(\"EFAULT\");\n             this.set_last_error(efault)?;\n             return Ok(-1);\n         }\n@@ -1272,7 +1271,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`opendir`\", reject_with)?;\n-            let eacc = this.eval_libc(\"EACCES\")?;\n+            let eacc = this.eval_libc(\"EACCES\");\n             this.set_last_error(eacc)?;\n             return Ok(Scalar::null_ptr(this));\n         }\n@@ -1308,7 +1307,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`readdir`\", reject_with)?;\n-            let eacc = this.eval_libc(\"EBADF\")?;\n+            let eacc = this.eval_libc(\"EBADF\");\n             this.set_last_error(eacc)?;\n             return Ok(Scalar::null_ptr(this));\n         }\n@@ -1337,7 +1336,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let name_bytes = os_str_to_bytes(&name)?;\n                 let name_len = u64::try_from(name_bytes.len()).unwrap();\n \n-                let dirent64_layout = this.libc_ty_layout(\"dirent64\")?;\n+                let dirent64_layout = this.libc_ty_layout(\"dirent64\");\n                 let d_name_offset = dirent64_layout.fields.offset(4 /* d_name */).bytes();\n                 let size = d_name_offset.checked_add(name_len).unwrap();\n \n@@ -1532,13 +1531,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                         let result = file.set_len(length);\n                         this.try_unwrap_io_result(result.map(|_| 0i32))?\n                     } else {\n-                        let einval = this.eval_libc(\"EINVAL\")?;\n+                        let einval = this.eval_libc(\"EINVAL\");\n                         this.set_last_error(einval)?;\n                         -1\n                     }\n                 } else {\n                     // The file is not writable\n-                    let einval = this.eval_libc(\"EINVAL\")?;\n+                    let einval = this.eval_libc(\"EINVAL\");\n                     this.set_last_error(einval)?;\n                     -1\n                 }\n@@ -1612,15 +1611,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let flags = this.read_scalar(flags_op)?.to_i32()?;\n \n         if offset < 0 || nbytes < 0 {\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             return Ok(Scalar::from_i32(-1));\n         }\n-        let allowed_flags = this.eval_libc_i32(\"SYNC_FILE_RANGE_WAIT_BEFORE\")?\n-            | this.eval_libc_i32(\"SYNC_FILE_RANGE_WRITE\")?\n-            | this.eval_libc_i32(\"SYNC_FILE_RANGE_WAIT_AFTER\")?;\n+        let allowed_flags = this.eval_libc_i32(\"SYNC_FILE_RANGE_WAIT_BEFORE\")\n+            | this.eval_libc_i32(\"SYNC_FILE_RANGE_WRITE\")\n+            | this.eval_libc_i32(\"SYNC_FILE_RANGE_WAIT_AFTER\");\n         if flags & allowed_flags != flags {\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             return Ok(Scalar::from_i32(-1));\n         }\n@@ -1657,7 +1656,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`readlink`\", reject_with)?;\n-            let eacc = this.eval_libc(\"EACCES\")?;\n+            let eacc = this.eval_libc(\"EACCES\");\n             this.set_last_error(eacc)?;\n             return Ok(-1);\n         }\n@@ -1702,7 +1701,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n         }\n         // Fallback when the FD was not found or isolation is enabled.\n-        let enotty = this.eval_libc(\"ENOTTY\")?;\n+        let enotty = this.eval_libc(\"ENOTTY\");\n         this.set_last_error(enotty)?;\n         Ok(Scalar::from_i32(0))\n     }\n@@ -1721,7 +1720,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`realpath`\", reject_with)?;\n-            let eacc = this.eval_libc(\"EACCES\")?;\n+            let eacc = this.eval_libc(\"EACCES\");\n             this.set_last_error(eacc)?;\n             return Ok(Scalar::from_machine_usize(0, this));\n         }\n@@ -1730,7 +1729,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         match result {\n             Ok(resolved) => {\n                 let path_max = this\n-                    .eval_libc_i32(\"PATH_MAX\")?\n+                    .eval_libc_i32(\"PATH_MAX\")\n                     .try_into()\n                     .expect(\"PATH_MAX does not fit in u64\");\n                 let dest = if this.ptr_is_null(processed_ptr)? {\n@@ -1752,7 +1751,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                         // Note that we do not explicitly handle `FILENAME_MAX`\n                         // (different from `PATH_MAX` above) as it is Linux-specific and\n                         // seems like a bit of a mess anyway: <https://eklitzke.org/path-max-is-tricky>.\n-                        let enametoolong = this.eval_libc(\"ENAMETOOLONG\")?;\n+                        let enametoolong = this.eval_libc(\"ENAMETOOLONG\");\n                         this.set_last_error(enametoolong)?;\n                         return Ok(Scalar::from_machine_usize(0, this));\n                     }\n@@ -1785,7 +1784,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         //   * The value of `TMP_MAX` is at least 25.\n         //   * On XSI-conformant systems, the value of `TMP_MAX` is at least 10000.\n         // See <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdio.h.html>.\n-        let max_attempts = this.eval_libc(\"TMP_MAX\")?.to_u32()?;\n+        let max_attempts = this.eval_libc_u32(\"TMP_MAX\");\n \n         // Get the raw bytes from the template -- as a byte slice, this is a string in the target\n         // (and the target is unix, so a byte slice is the right representation).\n@@ -1796,7 +1795,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`mkstemp`\", reject_with)?;\n-            let eacc = this.eval_libc(\"EACCES\")?;\n+            let eacc = this.eval_libc(\"EACCES\");\n             this.set_last_error(eacc)?;\n             return Ok(-1);\n         }\n@@ -1814,7 +1813,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         // If we don't find the suffix, it is an error.\n         if last_six_char_bytes != suffix_bytes {\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             return Ok(-1);\n         }\n@@ -1890,7 +1889,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         // We ran out of attempts to create the file, return an error.\n-        let eexist = this.eval_libc(\"EEXIST\")?;\n+        let eexist = this.eval_libc(\"EEXIST\");\n         this.set_last_error(eexist)?;\n         Ok(-1)\n     }\n@@ -1968,7 +1967,7 @@ impl FileMetadata {\n             \"S_IFLNK\"\n         };\n \n-        let mode = ecx.eval_libc(mode_name)?;\n+        let mode = ecx.eval_libc(mode_name);\n \n         let size = metadata.len();\n "}, {"sha": "ff7b2b352f2d17d0fb36c088ae24b5d35d081ca0", "filename": "src/tools/miri/src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=f0bb7c726412b3187a9ba94b97240474a096ee4a", "patch": "@@ -88,11 +88,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // argument, we have to also check all arguments *before* it to ensure that they\n                 // have the right type.\n \n-                let sys_getrandom = this.eval_libc(\"SYS_getrandom\")?.to_machine_usize(this)?;\n+                let sys_getrandom = this.eval_libc(\"SYS_getrandom\").to_machine_usize(this)?;\n \n-                let sys_statx = this.eval_libc(\"SYS_statx\")?.to_machine_usize(this)?;\n+                let sys_statx = this.eval_libc(\"SYS_statx\").to_machine_usize(this)?;\n \n-                let sys_futex = this.eval_libc(\"SYS_futex\")?.to_machine_usize(this)?;\n+                let sys_futex = this.eval_libc(\"SYS_futex\").to_machine_usize(this)?;\n \n                 if args.is_empty() {\n                     throw_ub_format!(\n@@ -150,7 +150,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 this.read_scalar(cpusetsize)?.to_machine_usize(this)?;\n                 this.deref_operand(mask)?;\n                 // FIXME: we just return an error; `num_cpus` then falls back to `sysconf`.\n-                let einval = this.eval_libc(\"EINVAL\")?;\n+                let einval = this.eval_libc(\"EINVAL\");\n                 this.set_last_error(einval)?;\n                 this.write_scalar(Scalar::from_i32(-1), dest)?;\n             }"}, {"sha": "ef43c9b0ff438bca79b8e543d0f8fbfa05357407", "filename": "src/tools/miri/src/shims/unix/linux/sync.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=f0bb7c726412b3187a9ba94b97240474a096ee4a", "patch": "@@ -37,12 +37,12 @@ pub fn futex<'tcx>(\n     let addr = MPlaceTy::from_aligned_ptr(addr, this.machine.layouts.i32);\n     let addr_usize = addr.ptr.addr().bytes();\n \n-    let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\")?;\n-    let futex_wait = this.eval_libc_i32(\"FUTEX_WAIT\")?;\n-    let futex_wait_bitset = this.eval_libc_i32(\"FUTEX_WAIT_BITSET\")?;\n-    let futex_wake = this.eval_libc_i32(\"FUTEX_WAKE\")?;\n-    let futex_wake_bitset = this.eval_libc_i32(\"FUTEX_WAKE_BITSET\")?;\n-    let futex_realtime = this.eval_libc_i32(\"FUTEX_CLOCK_REALTIME\")?;\n+    let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\");\n+    let futex_wait = this.eval_libc_i32(\"FUTEX_WAIT\");\n+    let futex_wait_bitset = this.eval_libc_i32(\"FUTEX_WAIT_BITSET\");\n+    let futex_wake = this.eval_libc_i32(\"FUTEX_WAKE\");\n+    let futex_wake_bitset = this.eval_libc_i32(\"FUTEX_WAKE_BITSET\");\n+    let futex_realtime = this.eval_libc_i32(\"FUTEX_CLOCK_REALTIME\");\n \n     // FUTEX_PRIVATE enables an optimization that stops it from working across processes.\n     // Miri doesn't support that anyway, so we ignore that flag.\n@@ -79,7 +79,7 @@ pub fn futex<'tcx>(\n             };\n \n             if bitset == 0 {\n-                let einval = this.eval_libc(\"EINVAL\")?;\n+                let einval = this.eval_libc(\"EINVAL\");\n                 this.set_last_error(einval)?;\n                 this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n                 return Ok(());\n@@ -99,7 +99,7 @@ pub fn futex<'tcx>(\n                 let duration = match this.read_timespec(&timeout)? {\n                     Some(duration) => duration,\n                     None => {\n-                        let einval = this.eval_libc(\"EINVAL\")?;\n+                        let einval = this.eval_libc(\"EINVAL\");\n                         this.set_last_error(einval)?;\n                         this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n                         return Ok(());\n@@ -194,7 +194,7 @@ pub fn futex<'tcx>(\n                         fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n                             this.unblock_thread(self.thread);\n                             this.futex_remove_waiter(self.addr_usize, self.thread);\n-                            let etimedout = this.eval_libc(\"ETIMEDOUT\")?;\n+                            let etimedout = this.eval_libc(\"ETIMEDOUT\");\n                             this.set_last_error(etimedout)?;\n                             this.write_scalar(Scalar::from_machine_isize(-1, this), &self.dest)?;\n \n@@ -211,7 +211,7 @@ pub fn futex<'tcx>(\n             } else {\n                 // The futex value doesn't match the expected value, so we return failure\n                 // right away without sleeping: -1 and errno set to EAGAIN.\n-                let eagain = this.eval_libc(\"EAGAIN\")?;\n+                let eagain = this.eval_libc(\"EAGAIN\");\n                 this.set_last_error(eagain)?;\n                 this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n             }\n@@ -237,7 +237,7 @@ pub fn futex<'tcx>(\n                 u32::MAX\n             };\n             if bitset == 0 {\n-                let einval = this.eval_libc(\"EINVAL\")?;\n+                let einval = this.eval_libc(\"EINVAL\");\n                 this.set_last_error(einval)?;\n                 this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n                 return Ok(());"}, {"sha": "d616126cb2ab7f6c9d14f5d0ffda114a0b903c0e", "filename": "src/tools/miri/src/shims/unix/macos/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs?ref=f0bb7c726412b3187a9ba94b97240474a096ee4a", "patch": "@@ -176,7 +176,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"pthread_setname_np\" => {\n                 let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let thread = this.pthread_self()?;\n-                let max_len = this.eval_libc(\"MAXTHREADNAMESIZE\")?.to_machine_usize(this)?;\n+                let max_len = this.eval_libc(\"MAXTHREADNAMESIZE\").to_machine_usize(this)?;\n                 let res = this.pthread_setname_np(\n                     thread,\n                     this.read_scalar(name)?,"}, {"sha": "b3c474dd3c9f19ddcedac12142ebaa72a238126b", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=f0bb7c726412b3187a9ba94b97240474a096ee4a", "patch": "@@ -21,14 +21,14 @@ fn is_mutex_kind_default<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     kind: i32,\n ) -> InterpResult<'tcx, bool> {\n-    Ok(kind == ecx.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?)\n+    Ok(kind == ecx.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\"))\n }\n \n fn is_mutex_kind_normal<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     kind: i32,\n ) -> InterpResult<'tcx, bool> {\n-    let mutex_normal_kind = ecx.eval_libc_i32(\"PTHREAD_MUTEX_NORMAL\")?;\n+    let mutex_normal_kind = ecx.eval_libc_i32(\"PTHREAD_MUTEX_NORMAL\");\n     Ok(kind == (mutex_normal_kind | PTHREAD_MUTEX_NORMAL_FLAG))\n }\n \n@@ -217,7 +217,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let default_kind = this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?;\n+        let default_kind = this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\");\n         mutexattr_set_kind(this, attr_op, default_kind)?;\n \n         Ok(0)\n@@ -231,7 +231,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = this.read_scalar(kind_op)?.to_i32()?;\n-        if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_NORMAL\")? {\n+        if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_NORMAL\") {\n             // In `glibc` implementation, the numeric values of\n             // `PTHREAD_MUTEX_NORMAL` and `PTHREAD_MUTEX_DEFAULT` are equal.\n             // However, a mutex created by explicitly passing\n@@ -247,17 +247,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             let normal_kind = kind | PTHREAD_MUTEX_NORMAL_FLAG;\n             // Check that after setting the flag, the kind is distinguishable\n             // from all other kinds.\n-            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?);\n-            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?);\n-            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")?);\n+            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\"));\n+            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\"));\n+            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\"));\n             mutexattr_set_kind(this, attr_op, normal_kind)?;\n-        } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?\n-            || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?\n-            || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")?\n+        } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")\n+            || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")\n+            || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")\n         {\n             mutexattr_set_kind(this, attr_op, kind)?;\n         } else {\n-            let einval = this.eval_libc_i32(\"EINVAL\")?;\n+            let einval = this.eval_libc_i32(\"EINVAL\");\n             return Ok(einval);\n         }\n \n@@ -299,7 +299,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let attr = this.read_pointer(attr_op)?;\n         let kind = if this.ptr_is_null(attr)? {\n-            this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?\n+            this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")\n         } else {\n             mutexattr_get_kind(this, attr_op)?\n         };\n@@ -331,9 +331,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     throw_ub_format!(\"trying to acquire already locked default mutex\");\n                 } else if is_mutex_kind_normal(this, kind)? {\n                     throw_machine_stop!(TerminationInfo::Deadlock);\n-                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n-                    this.eval_libc_i32(\"EDEADLK\")\n-                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")? {\n+                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\") {\n+                    Ok(this.eval_libc_i32(\"EDEADLK\"))\n+                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\") {\n                     this.mutex_lock(id, active_thread);\n                     Ok(0)\n                 } else {\n@@ -362,14 +362,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         if this.mutex_is_locked(id) {\n             let owner_thread = this.mutex_get_owner(id);\n             if owner_thread != active_thread {\n-                this.eval_libc_i32(\"EBUSY\")\n+                Ok(this.eval_libc_i32(\"EBUSY\"))\n             } else {\n                 if is_mutex_kind_default(this, kind)?\n                     || is_mutex_kind_normal(this, kind)?\n-                    || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?\n+                    || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")\n                 {\n-                    this.eval_libc_i32(\"EBUSY\")\n-                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")? {\n+                    Ok(this.eval_libc_i32(\"EBUSY\"))\n+                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\") {\n                     this.mutex_lock(id, active_thread);\n                     Ok(0)\n                 } else {\n@@ -410,10 +410,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 throw_ub_format!(\n                     \"unlocked a PTHREAD_MUTEX_NORMAL mutex that was not locked by the current thread\"\n                 );\n-            } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?\n-                || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")?\n+            } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")\n+                || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")\n             {\n-                this.eval_libc_i32(\"EPERM\")\n+                Ok(this.eval_libc_i32(\"EPERM\"))\n             } else {\n                 throw_unsup_format!(\"called pthread_mutex_unlock on an unsupported type of mutex\");\n             }\n@@ -471,7 +471,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n-            this.eval_libc_i32(\"EBUSY\")\n+            Ok(this.eval_libc_i32(\"EBUSY\"))\n         } else {\n             this.rwlock_reader_lock(id, active_thread);\n             Ok(0)\n@@ -518,7 +518,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n-            this.eval_libc_i32(\"EBUSY\")\n+            Ok(this.eval_libc_i32(\"EBUSY\"))\n         } else {\n             this.rwlock_writer_lock(id, active_thread);\n             Ok(0)\n@@ -575,7 +575,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // The default value of the clock attribute shall refer to the system\n         // clock.\n         // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_condattr_setclock.html\n-        let default_clock_id = this.eval_libc_i32(\"CLOCK_REALTIME\")?;\n+        let default_clock_id = this.eval_libc_i32(\"CLOCK_REALTIME\");\n         condattr_set_clock_id(this, attr_op, default_clock_id)?;\n \n         Ok(0)\n@@ -589,12 +589,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let clock_id = this.read_scalar(clock_id_op)?.to_i32()?;\n-        if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")?\n-            || clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")?\n+        if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")\n+            || clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")\n         {\n             condattr_set_clock_id(this, attr_op, clock_id)?;\n         } else {\n-            let einval = this.eval_libc_i32(\"EINVAL\")?;\n+            let einval = this.eval_libc_i32(\"EINVAL\");\n             return Ok(Scalar::from_i32(einval));\n         }\n \n@@ -638,7 +638,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let attr = this.read_pointer(attr_op)?;\n         let clock_id = if this.ptr_is_null(attr)? {\n-            this.eval_libc_i32(\"CLOCK_REALTIME\")?\n+            this.eval_libc_i32(\"CLOCK_REALTIME\")\n         } else {\n             condattr_get_clock_id(this, attr_op)?\n         };\n@@ -718,16 +718,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let duration = match this.read_timespec(&this.deref_operand(abstime_op)?)? {\n             Some(duration) => duration,\n             None => {\n-                let einval = this.eval_libc(\"EINVAL\")?;\n+                let einval = this.eval_libc(\"EINVAL\");\n                 this.write_scalar(einval, dest)?;\n                 return Ok(());\n             }\n         };\n \n-        let timeout_time = if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")? {\n+        let timeout_time = if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\") {\n             this.check_no_isolation(\"`pthread_cond_timedwait` with `CLOCK_REALTIME`\")?;\n             Time::RealTime(SystemTime::UNIX_EPOCH.checked_add(duration).unwrap())\n-        } else if clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")? {\n+        } else if clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\") {\n             Time::Monotonic(this.machine.clock.anchor().checked_add(duration).unwrap())\n         } else {\n             throw_unsup_format!(\"unsupported clock id: {}\", clock_id);\n@@ -763,7 +763,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 ecx.condvar_remove_waiter(self.id, self.active_thread);\n \n                 // Set the return value: we timed out.\n-                let etimedout = ecx.eval_libc(\"ETIMEDOUT\")?;\n+                let etimedout = ecx.eval_libc(\"ETIMEDOUT\");\n                 ecx.write_scalar(etimedout, &self.dest)?;\n \n                 Ok(())"}, {"sha": "4f7b028d35dbfaf6705c8b05f78933d40f300dd0", "filename": "src/tools/miri/src/shims/unix/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs?ref=f0bb7c726412b3187a9ba94b97240474a096ee4a", "patch": "@@ -84,7 +84,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         // Comparing with `>=` to account for null terminator.\n         if name.len() >= max_name_len {\n-            return this.eval_libc(\"ERANGE\");\n+            return Ok(this.eval_libc(\"ERANGE\"));\n         }\n \n         this.set_thread_name(thread, name);\n@@ -107,7 +107,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let name = this.get_thread_name(thread).to_owned();\n         let (success, _written) = this.write_c_str(&name, name_out, len)?;\n \n-        if success { Ok(Scalar::from_u32(0)) } else { this.eval_libc(\"ERANGE\") }\n+        Ok(if success { Scalar::from_u32(0) } else { this.eval_libc(\"ERANGE\") })\n     }\n \n     fn sched_yield(&mut self) -> InterpResult<'tcx, i32> {"}, {"sha": "61cb3b382b3c3ceca68e458f596a8d525d64d4f8", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=f0bb7c726412b3187a9ba94b97240474a096ee4a", "patch": "@@ -170,7 +170,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         match this.init_once_status(id) {\n             InitOnceStatus::Uninitialized => {\n                 this.init_once_begin(id);\n-                this.write_scalar(this.eval_windows(\"c\", \"TRUE\")?, &pending_place)?;\n+                this.write_scalar(this.eval_windows(\"c\", \"TRUE\"), &pending_place)?;\n             }\n             InitOnceStatus::Begun => {\n                 // Someone else is already on it.\n@@ -195,8 +195,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                                 unreachable!(\n                                     \"status should have either been set to begun or complete\"\n                                 ),\n-                            InitOnceStatus::Begun => this.eval_windows(\"c\", \"TRUE\")?,\n-                            InitOnceStatus::Complete => this.eval_windows(\"c\", \"FALSE\")?,\n+                            InitOnceStatus::Begun => this.eval_windows(\"c\", \"TRUE\"),\n+                            InitOnceStatus::Complete => this.eval_windows(\"c\", \"FALSE\"),\n                         };\n \n                         this.write_scalar(pending, &self.pending_place)?;\n@@ -213,12 +213,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n             InitOnceStatus::Complete => {\n                 this.init_once_observe_completed(id);\n-                this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &pending_place)?;\n+                this.write_scalar(this.eval_windows(\"c\", \"FALSE\"), &pending_place)?;\n             }\n         }\n \n         // This always succeeds (even if the thread is blocked, we will succeed if we ever unblock).\n-        this.eval_windows(\"c\", \"TRUE\")\n+        Ok(this.eval_windows(\"c\", \"TRUE\"))\n     }\n \n     fn InitOnceComplete(\n@@ -235,7 +235,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let success = if flags == 0 {\n             true\n-        } else if flags == this.eval_windows(\"c\", \"INIT_ONCE_INIT_FAILED\")?.to_u32()? {\n+        } else if flags == this.eval_windows_u32(\"c\", \"INIT_ONCE_INIT_FAILED\") {\n             false\n         } else {\n             throw_unsup_format!(\"unsupported `dwFlags` {flags} in `InitOnceBeginInitialize`\");\n@@ -258,7 +258,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             this.init_once_fail(id)?;\n         }\n \n-        this.eval_windows(\"c\", \"TRUE\")\n+        Ok(this.eval_windows(\"c\", \"TRUE\"))\n     }\n \n     fn WaitOnAddress(\n@@ -280,14 +280,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let addr = ptr.addr().bytes();\n \n         if size > 8 || !size.is_power_of_two() {\n-            let invalid_param = this.eval_windows(\"c\", \"ERROR_INVALID_PARAMETER\")?;\n+            let invalid_param = this.eval_windows(\"c\", \"ERROR_INVALID_PARAMETER\");\n             this.set_last_error(invalid_param)?;\n             this.write_scalar(Scalar::from_i32(0), dest)?;\n             return Ok(());\n         };\n         let size = Size::from_bytes(size);\n \n-        let timeout_time = if timeout_ms == this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+        let timeout_time = if timeout_ms == this.eval_windows_u32(\"c\", \"INFINITE\") {\n             None\n         } else {\n             let duration = Duration::from_millis(timeout_ms.into());\n@@ -325,7 +325,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n                         this.unblock_thread(self.thread);\n                         this.futex_remove_waiter(self.addr, self.thread);\n-                        let error_timeout = this.eval_windows(\"c\", \"ERROR_TIMEOUT\")?;\n+                        let error_timeout = this.eval_windows(\"c\", \"ERROR_TIMEOUT\");\n                         this.set_last_error(error_timeout)?;\n                         this.write_scalar(Scalar::from_i32(0), &self.dest)?;\n \n@@ -377,7 +377,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let timeout_ms = this.read_scalar(timeout_op)?.to_u32()?;\n         let flags = this.read_scalar(flags_op)?.to_u32()?;\n \n-        let timeout_time = if timeout_ms == this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+        let timeout_time = if timeout_ms == this.eval_windows_u32(\"c\", \"INFINITE\") {\n             None\n         } else {\n             let duration = Duration::from_millis(timeout_ms.into());\n@@ -431,9 +431,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n                     this.condvar_remove_waiter(self.condvar_id, self.thread);\n \n-                    let error_timeout = this.eval_windows(\"c\", \"ERROR_TIMEOUT\")?;\n+                    let error_timeout = this.eval_windows(\"c\", \"ERROR_TIMEOUT\");\n                     this.set_last_error(error_timeout)?;\n-                    this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &self.dest)?;\n+                    this.write_scalar(this.eval_windows(\"c\", \"FALSE\"), &self.dest)?;\n                     Ok(())\n                 }\n             }\n@@ -451,7 +451,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             );\n         }\n \n-        this.eval_windows(\"c\", \"TRUE\")\n+        Ok(this.eval_windows(\"c\", \"TRUE\"))\n     }\n \n     fn WakeConditionVariable(&mut self, condvar_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {"}, {"sha": "c3a450db48dc763e1fc01f3c28450f53aeb3a8c5", "filename": "src/tools/miri/src/shims/windows/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bb7c726412b3187a9ba94b97240474a096ee4a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs?ref=f0bb7c726412b3187a9ba94b97240474a096ee4a", "patch": "@@ -34,7 +34,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         };\n \n         let stack_size_param_is_a_reservation =\n-            this.eval_windows(\"c\", \"STACK_SIZE_PARAM_IS_A_RESERVATION\")?.to_u32()?;\n+            this.eval_windows_u32(\"c\", \"STACK_SIZE_PARAM_IS_A_RESERVATION\");\n \n         // We ignore the stack size, so we also ignore the\n         // `STACK_SIZE_PARAM_IS_A_RESERVATION` flag.\n@@ -73,7 +73,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             _ => this.invalid_handle(\"WaitForSingleObject\")?,\n         };\n \n-        if timeout != this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+        if timeout != this.eval_windows_u32(\"c\", \"INFINITE\") {\n             throw_unsup_format!(\"`WaitForSingleObject` with non-infinite timeout\");\n         }\n "}]}