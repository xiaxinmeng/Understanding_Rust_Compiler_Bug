{"sha": "a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "node_id": "C_kwDOAAsO6NoAKGEwZmJmMGQwNzc1ZDM3ZDYxYTYyNjQzZjJmM2JkZjQ1Zjg3NjMwNjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-28T20:19:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-28T20:19:28Z"}, "message": "Auto merge of #2630 - RalfJung:windows-parking, r=RalfJung\n\nImplement thread parking for Windows\n\nCc https://github.com/rust-lang/miri/issues/2628\n\nBased on code by `@DrMeepster.` However I adjusted `WakeByAddressSingle`: I don't think the futex value is compared *again* after the thread is woken up. I see nothing in the Windows docs indicating such a comparison, and the Linux futex does not behave like that either. So we only check the value before sleeping, same as on Linux.", "tree": {"sha": "5634da3652944c9bd2eea6fd66a0d930e7b99577", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5634da3652944c9bd2eea6fd66a0d930e7b99577"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "html_url": "https://github.com/rust-lang/rust/commit/a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4827d41466af1e9b5f3a38d55f8f99e66e3f6842", "url": "https://api.github.com/repos/rust-lang/rust/commits/4827d41466af1e9b5f3a38d55f8f99e66e3f6842", "html_url": "https://github.com/rust-lang/rust/commit/4827d41466af1e9b5f3a38d55f8f99e66e3f6842"}, {"sha": "9b0cdf9a6ef71708fbb405d53a64e4e60b2691a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b0cdf9a6ef71708fbb405d53a64e4e60b2691a2", "html_url": "https://github.com/rust-lang/rust/commit/9b0cdf9a6ef71708fbb405d53a64e4e60b2691a2"}], "stats": {"total": 240, "additions": 190, "deletions": 50}, "files": [{"sha": "f55c0b43e39bc8d05f26592f2b8ef5c312afeceb", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "patch": "@@ -98,8 +98,8 @@ pub use crate::eval::{\n pub use crate::helpers::{CurrentSpan, EvalContextExt as _};\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n-    AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind, Provenance,\n-    ProvenanceExtra, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n+    AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind,\n+    PrimitiveLayouts, Provenance, ProvenanceExtra, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as _;"}, {"sha": "231a99c1d034ed0ef9316dc82271b3c471b1a607", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "patch": "@@ -276,10 +276,14 @@ pub struct PrimitiveLayouts<'tcx> {\n     pub i8: TyAndLayout<'tcx>,\n     pub i16: TyAndLayout<'tcx>,\n     pub i32: TyAndLayout<'tcx>,\n+    pub i64: TyAndLayout<'tcx>,\n+    pub i128: TyAndLayout<'tcx>,\n     pub isize: TyAndLayout<'tcx>,\n     pub u8: TyAndLayout<'tcx>,\n     pub u16: TyAndLayout<'tcx>,\n     pub u32: TyAndLayout<'tcx>,\n+    pub u64: TyAndLayout<'tcx>,\n+    pub u128: TyAndLayout<'tcx>,\n     pub usize: TyAndLayout<'tcx>,\n     pub bool: TyAndLayout<'tcx>,\n     pub mut_raw_ptr: TyAndLayout<'tcx>,   // *mut ()\n@@ -296,16 +300,42 @@ impl<'mir, 'tcx: 'mir> PrimitiveLayouts<'tcx> {\n             i8: layout_cx.layout_of(tcx.types.i8)?,\n             i16: layout_cx.layout_of(tcx.types.i16)?,\n             i32: layout_cx.layout_of(tcx.types.i32)?,\n+            i64: layout_cx.layout_of(tcx.types.i64)?,\n+            i128: layout_cx.layout_of(tcx.types.i128)?,\n             isize: layout_cx.layout_of(tcx.types.isize)?,\n             u8: layout_cx.layout_of(tcx.types.u8)?,\n             u16: layout_cx.layout_of(tcx.types.u16)?,\n             u32: layout_cx.layout_of(tcx.types.u32)?,\n+            u64: layout_cx.layout_of(tcx.types.u64)?,\n+            u128: layout_cx.layout_of(tcx.types.u128)?,\n             usize: layout_cx.layout_of(tcx.types.usize)?,\n             bool: layout_cx.layout_of(tcx.types.bool)?,\n             mut_raw_ptr: layout_cx.layout_of(mut_raw_ptr)?,\n             const_raw_ptr: layout_cx.layout_of(const_raw_ptr)?,\n         })\n     }\n+\n+    pub fn uint(&self, size: Size) -> Option<TyAndLayout<'tcx>> {\n+        match size.bits() {\n+            8 => Some(self.u8),\n+            16 => Some(self.u16),\n+            32 => Some(self.u32),\n+            64 => Some(self.u64),\n+            128 => Some(self.u128),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn int(&self, size: Size) -> Option<TyAndLayout<'tcx>> {\n+        match size.bits() {\n+            8 => Some(self.i8),\n+            16 => Some(self.i16),\n+            32 => Some(self.i32),\n+            64 => Some(self.i64),\n+            128 => Some(self.i128),\n+            _ => None,\n+        }\n+    }\n }\n \n /// The machine itself."}, {"sha": "91db30e93d8ea1d812f319357b57b1771fc9bd7c", "filename": "src/tools/miri/src/shims/unix/linux/sync.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "patch": "@@ -1,7 +1,7 @@\n+use std::time::SystemTime;\n+\n use crate::concurrency::thread::{MachineCallback, Time};\n use crate::*;\n-use rustc_target::abi::{Align, Size};\n-use std::time::SystemTime;\n \n /// Implementation of the SYS_futex syscall.\n /// `args` is the arguments *after* the syscall number.\n@@ -28,13 +28,14 @@ pub fn futex<'tcx>(\n     // The first three arguments (after the syscall number itself) are the same to all futex operations:\n     //     (int *addr, int op, int val).\n     // We checked above that these definitely exist.\n-    let addr = this.read_immediate(&args[0])?;\n+    let addr = this.read_pointer(&args[0])?;\n     let op = this.read_scalar(&args[1])?.to_i32()?;\n     let val = this.read_scalar(&args[2])?.to_i32()?;\n \n     let thread = this.get_active_thread();\n-    let addr_scalar = addr.to_scalar();\n-    let addr_usize = addr_scalar.to_machine_usize(this)?;\n+    // This is a vararg function so we have to bring our own type for this pointer.\n+    let addr = MPlaceTy::from_aligned_ptr(addr, this.machine.layouts.i32);\n+    let addr_usize = addr.ptr.addr().bytes();\n \n     let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\")?;\n     let futex_wait = this.eval_libc_i32(\"FUTEX_WAIT\")?;\n@@ -117,15 +118,6 @@ pub fn futex<'tcx>(\n                     }\n                 })\n             };\n-            // Check the pointer for alignment and validity.\n-            // The API requires `addr` to be a 4-byte aligned pointer, and will\n-            // use the 4 bytes at the given address as an (atomic) i32.\n-            this.check_ptr_access_align(\n-                addr_scalar.to_pointer(this)?,\n-                Size::from_bytes(4),\n-                Align::from_bytes(4).unwrap(),\n-                CheckInAllocMsg::MemoryAccessTest,\n-            )?;\n             // There may be a concurrent thread changing the value of addr\n             // and then invoking the FUTEX_WAKE syscall. It is critical that the\n             // effects of this and the other thread are correctly observed,\n@@ -172,14 +164,7 @@ pub fn futex<'tcx>(\n             this.atomic_fence(AtomicFenceOrd::SeqCst)?;\n             // Read an `i32` through the pointer, regardless of any wrapper types.\n             // It's not uncommon for `addr` to be passed as another type than `*mut i32`, such as `*const AtomicI32`.\n-            let futex_val = this\n-                .read_scalar_at_offset_atomic(\n-                    &addr.into(),\n-                    0,\n-                    this.machine.layouts.i32,\n-                    AtomicReadOrd::Relaxed,\n-                )?\n-                .to_i32()?;\n+            let futex_val = this.read_scalar_atomic(&addr, AtomicReadOrd::Relaxed)?.to_i32()?;\n             if val == futex_val {\n                 // The value still matches, so we block the thread make it wait for FUTEX_WAKE.\n                 this.block_thread(thread);\n@@ -214,11 +199,10 @@ pub fn futex<'tcx>(\n                         }\n                     }\n \n-                    let dest = dest.clone();\n                     this.register_timeout_callback(\n                         thread,\n                         timeout_time,\n-                        Box::new(Callback { thread, addr_usize, dest }),\n+                        Box::new(Callback { thread, addr_usize, dest: dest.clone() }),\n                     );\n                 }\n             } else {"}, {"sha": "4b2a90723c79c44ff32e3bdcd4918be4053a2f36", "filename": "src/tools/miri/src/shims/windows/dlsym.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs?ref=a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "patch": "@@ -6,12 +6,15 @@ use log::trace;\n \n use crate::helpers::check_arg_count;\n use crate::shims::windows::handle::{EvalContextExt as _, Handle, PseudoHandle};\n+use crate::shims::windows::sync::EvalContextExt as _;\n use crate::*;\n \n #[derive(Debug, Copy, Clone)]\n pub enum Dlsym {\n     NtWriteFile,\n     SetThreadDescription,\n+    WaitOnAddress,\n+    WakeByAddressSingle,\n }\n \n impl Dlsym {\n@@ -22,6 +25,8 @@ impl Dlsym {\n             \"GetSystemTimePreciseAsFileTime\" => None,\n             \"NtWriteFile\" => Some(Dlsym::NtWriteFile),\n             \"SetThreadDescription\" => Some(Dlsym::SetThreadDescription),\n+            \"WaitOnAddress\" => Some(Dlsym::WaitOnAddress),\n+            \"WakeByAddressSingle\" => Some(Dlsym::WakeByAddressSingle),\n             _ => throw_unsup_format!(\"unsupported Windows dlsym: {}\", name),\n         })\n     }\n@@ -127,6 +132,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n                 this.write_null(dest)?;\n             }\n+            Dlsym::WaitOnAddress => {\n+                let [ptr_op, compare_op, size_op, timeout_op] = check_arg_count(args)?;\n+\n+                this.WaitOnAddress(ptr_op, compare_op, size_op, timeout_op, dest)?;\n+            }\n+            Dlsym::WakeByAddressSingle => {\n+                let [ptr_op] = check_arg_count(args)?;\n+\n+                this.WakeByAddressSingle(ptr_op)?;\n+            }\n         }\n \n         trace!(\"{:?}\", this.dump_place(**dest));"}, {"sha": "336ba7db95f1f41a2d4b92d4c042e247f0b44a5c", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 107, "deletions": 1, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "patch": "@@ -1,3 +1,7 @@\n+use std::time::Duration;\n+\n+use rustc_target::abi::Size;\n+\n use crate::concurrency::init_once::InitOnceStatus;\n use crate::concurrency::thread::MachineCallback;\n use crate::*;\n@@ -6,7 +10,6 @@ const SRWLOCK_ID_OFFSET: u64 = 0;\n const INIT_ONCE_ID_OFFSET: u64 = 0;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n-\n #[allow(non_snake_case)]\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn AcquireSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n@@ -221,4 +224,107 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         this.eval_windows(\"c\", \"TRUE\")\n     }\n+\n+    fn WaitOnAddress(\n+        &mut self,\n+        ptr_op: &OpTy<'tcx, Provenance>,\n+        compare_op: &OpTy<'tcx, Provenance>,\n+        size_op: &OpTy<'tcx, Provenance>,\n+        timeout_op: &OpTy<'tcx, Provenance>,\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let ptr = this.read_pointer(ptr_op)?;\n+        let compare = this.read_pointer(compare_op)?;\n+        let size = this.read_scalar(size_op)?.to_machine_usize(this)?;\n+        let timeout_ms = this.read_scalar(timeout_op)?.to_u32()?;\n+\n+        let thread = this.get_active_thread();\n+        let addr = ptr.addr().bytes();\n+\n+        if size > 8 || !size.is_power_of_two() {\n+            let invalid_param = this.eval_windows(\"c\", \"ERROR_INVALID_PARAMETER\")?;\n+            this.set_last_error(invalid_param)?;\n+            this.write_scalar(Scalar::from_i32(0), dest)?;\n+            return Ok(());\n+        };\n+        let size = Size::from_bytes(size);\n+\n+        let timeout_time = if timeout_ms == this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+            None\n+        } else {\n+            this.check_no_isolation(\"`WaitOnAddress` with non-infinite timeout\")?;\n+\n+            let duration = Duration::from_millis(timeout_ms.into());\n+            Some(Time::Monotonic(this.machine.clock.now().checked_add(duration).unwrap()))\n+        };\n+\n+        // See the Linux futex implementation for why this fence exists.\n+        this.atomic_fence(AtomicFenceOrd::SeqCst)?;\n+\n+        let layout = this.machine.layouts.uint(size).unwrap();\n+        let futex_val = this\n+            .read_scalar_atomic(&MPlaceTy::from_aligned_ptr(ptr, layout), AtomicReadOrd::Relaxed)?;\n+        let compare_val = this.read_scalar(&MPlaceTy::from_aligned_ptr(compare, layout).into())?;\n+\n+        if futex_val == compare_val {\n+            // If the values are the same, we have to block.\n+            this.block_thread(thread);\n+            this.futex_wait(addr, thread, u32::MAX);\n+\n+            if let Some(timeout_time) = timeout_time {\n+                struct Callback<'tcx> {\n+                    thread: ThreadId,\n+                    addr: u64,\n+                    dest: PlaceTy<'tcx, Provenance>,\n+                }\n+\n+                impl<'tcx> VisitTags for Callback<'tcx> {\n+                    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                        let Callback { thread: _, addr: _, dest } = self;\n+                        dest.visit_tags(visit);\n+                    }\n+                }\n+\n+                impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n+                    fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+                        this.unblock_thread(self.thread);\n+                        this.futex_remove_waiter(self.addr, self.thread);\n+                        let error_timeout = this.eval_windows(\"c\", \"ERROR_TIMEOUT\")?;\n+                        this.set_last_error(error_timeout)?;\n+                        this.write_scalar(Scalar::from_i32(0), &self.dest)?;\n+\n+                        Ok(())\n+                    }\n+                }\n+\n+                this.register_timeout_callback(\n+                    thread,\n+                    timeout_time,\n+                    Box::new(Callback { thread, addr, dest: dest.clone() }),\n+                );\n+            }\n+        }\n+\n+        this.write_scalar(Scalar::from_i32(1), dest)?;\n+\n+        Ok(())\n+    }\n+\n+    fn WakeByAddressSingle(&mut self, ptr_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let ptr = this.read_pointer(ptr_op)?;\n+\n+        // See the Linux futex implementation for why this fence exists.\n+        this.atomic_fence(AtomicFenceOrd::SeqCst)?;\n+\n+        if let Some(thread) = this.futex_wake(ptr.addr().bytes(), u32::MAX) {\n+            this.unblock_thread(thread);\n+            this.unregister_timeout_callback_if_exists(thread);\n+        }\n+\n+        Ok(())\n+    }\n }"}, {"sha": "904ae2fb17f9b3080449234ea6c41cc25a6c8aaa", "filename": "src/tools/miri/tests/pass-dep/shims/libc-misc.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs?ref=a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "patch": "@@ -87,7 +87,7 @@ fn test_posix_realpath_errors() {\n     assert_eq!(e.kind(), ErrorKind::NotFound);\n }\n \n-#[cfg(any(target_os = \"linux\"))]\n+#[cfg(target_os = \"linux\")]\n fn test_posix_fadvise() {\n     use std::convert::TryInto;\n     use std::io::Write;\n@@ -115,7 +115,7 @@ fn test_posix_fadvise() {\n     assert_eq!(result, 0);\n }\n \n-#[cfg(any(target_os = \"linux\"))]\n+#[cfg(target_os = \"linux\")]\n fn test_sync_file_range() {\n     use std::io::Write;\n \n@@ -181,7 +181,7 @@ fn test_thread_local_errno() {\n }\n \n /// Tests whether clock support exists at all\n-#[cfg(any(target_os = \"linux\"))]\n+#[cfg(target_os = \"linux\")]\n fn test_clocks() {\n     let mut tp = std::mem::MaybeUninit::<libc::timespec>::uninit();\n     let is_error = unsafe { libc::clock_gettime(libc::CLOCK_REALTIME, tp.as_mut_ptr()) };\n@@ -283,23 +283,21 @@ fn test_posix_mkstemp() {\n }\n \n fn main() {\n-    #[cfg(any(target_os = \"linux\"))]\n-    test_posix_fadvise();\n-\n     test_posix_gettimeofday();\n     test_posix_mkstemp();\n \n     test_posix_realpath_alloc();\n     test_posix_realpath_noalloc();\n     test_posix_realpath_errors();\n \n-    #[cfg(any(target_os = \"linux\"))]\n-    test_sync_file_range();\n-\n     test_thread_local_errno();\n \n-    #[cfg(any(target_os = \"linux\"))]\n-    test_clocks();\n-\n     test_isatty();\n+\n+    #[cfg(target_os = \"linux\")]\n+    {\n+        test_posix_fadvise();\n+        test_sync_file_range();\n+        test_clocks();\n+    }\n }"}, {"sha": "09dd92564d39a42de2a79a140ec36b9b738d978e", "filename": "src/tools/miri/tests/pass-dep/shims/pthreads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Fpthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Fpthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Fpthreads.rs?ref=a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "patch": "@@ -10,7 +10,7 @@ fn main() {\n     test_rwlock_libc_static_initializer();\n     test_named_thread_truncation();\n \n-    #[cfg(any(target_os = \"linux\"))]\n+    #[cfg(target_os = \"linux\")]\n     test_mutex_libc_static_initializer_recursive();\n }\n "}, {"sha": "53b57942d76a4d27bb75e19fa4283bdb8bfc213f", "filename": "src/tools/miri/tests/pass/concurrency/channels.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fchannels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fchannels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fchannels.rs?ref=a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Channels on Windows are not supported yet.\n //@compile-flags: -Zmiri-strict-provenance\n \n use std::sync::mpsc::{channel, sync_channel};"}, {"sha": "44b16e1ac74d46b5efada9acf830bcbe9eea5738", "filename": "src/tools/miri/tests/pass/concurrency/spin_loops_nopreempt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs?ref=a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Channels on Windows are not supported yet.\n // This specifically tests behavior *without* preemption.\n //@compile-flags: -Zmiri-preemption-rate=0\n "}, {"sha": "b1518a49fbb1b8b6e158d4a081aedf8722498a26", "filename": "src/tools/miri/tests/pass/concurrency/sync.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs?ref=a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Condvars on Windows are not supported yet.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-strict-provenance\n \n use std::sync::{Arc, Barrier, Condvar, Mutex, Once, RwLock};\n@@ -225,14 +224,26 @@ fn park_unpark() {\n }\n \n fn main() {\n-    check_barriers();\n-    check_conditional_variables_notify_one();\n-    check_conditional_variables_timed_wait_timeout();\n-    check_conditional_variables_timed_wait_notimeout();\n     check_mutex();\n     check_rwlock_write();\n     check_rwlock_read_no_deadlock();\n     check_once();\n     park_timeout();\n     park_unpark();\n+\n+    if !cfg!(windows) {\n+        // ignore-target-windows: Condvars on Windows are not supported yet\n+        check_barriers();\n+        check_conditional_variables_notify_one();\n+        check_conditional_variables_timed_wait_timeout();\n+        check_conditional_variables_timed_wait_notimeout();\n+    } else {\n+        // We need to fake the same output...\n+        for _ in 0..10 {\n+            println!(\"before wait\");\n+        }\n+        for _ in 0..10 {\n+            println!(\"after wait\");\n+        }\n+    }\n }"}, {"sha": "a5f81573e963d48d50d100a20730470f8cf0d0e0", "filename": "src/tools/miri/tests/pass/threadleak_ignored.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0fbf0d0775d37d61a62643f2f3bdf45f8763067/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.rs?ref=a0fbf0d0775d37d61a62643f2f3bdf45f8763067", "patch": "@@ -1,6 +1,4 @@\n-//@ignore-target-windows: Channels on Windows are not supported yet.\n-// FIXME: disallow preemption to work around https://github.com/rust-lang/rust/issues/55005\n-//@compile-flags: -Zmiri-ignore-leaks -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-ignore-leaks\n \n //! Test that leaking threads works, and that their destructors are not executed.\n "}]}