{"sha": "3a95d01d0cbc5ac2d789b3c70f4472a609fc5af4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhOTVkMDFkMGNiYzVhYzJkNzg5YjNjNzBmNDQ3MmE2MDlmYzVhZjQ=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-12-08T12:33:42Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-12-08T12:33:42Z"}, "message": "Delay legacy macro expansion", "tree": {"sha": "f13aa28f91694b5ea104071858a952318d70f688", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f13aa28f91694b5ea104071858a952318d70f688"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a95d01d0cbc5ac2d789b3c70f4472a609fc5af4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a95d01d0cbc5ac2d789b3c70f4472a609fc5af4", "html_url": "https://github.com/rust-lang/rust/commit/3a95d01d0cbc5ac2d789b3c70f4472a609fc5af4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a95d01d0cbc5ac2d789b3c70f4472a609fc5af4/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b236f6aa499f98985acd07a34eb0c0d147bf8d5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b236f6aa499f98985acd07a34eb0c0d147bf8d5f", "html_url": "https://github.com/rust-lang/rust/commit/b236f6aa499f98985acd07a34eb0c0d147bf8d5f"}], "stats": {"total": 206, "additions": 57, "deletions": 149}, "files": [{"sha": "a80067979fa3dd785975afe695793fdc41708611", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 57, "deletions": 149, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/3a95d01d0cbc5ac2d789b3c70f4472a609fc5af4/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a95d01d0cbc5ac2d789b3c70f4472a609fc5af4/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=3a95d01d0cbc5ac2d789b3c70f4472a609fc5af4", "patch": "@@ -12,7 +12,7 @@ use hir_expand::{\n use ra_cfg::CfgOptions;\n use ra_db::{CrateId, FileId};\n use ra_syntax::ast;\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n use crate::{\n@@ -63,42 +63,12 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         unexpanded_macros: Vec::new(),\n         unexpanded_attribute_macros: Vec::new(),\n         mod_dirs: FxHashMap::default(),\n-        macro_stack_monitor: MacroStackMonitor::default(),\n-        poison_macros: FxHashSet::default(),\n         cfg_options,\n     };\n     collector.collect();\n     collector.finish()\n }\n \n-#[derive(Default)]\n-struct MacroStackMonitor {\n-    counts: FxHashMap<MacroDefId, u32>,\n-\n-    /// Mainly use for test\n-    validator: Option<Box<dyn Fn(u32) -> bool>>,\n-}\n-\n-impl MacroStackMonitor {\n-    fn increase(&mut self, macro_def_id: MacroDefId) {\n-        *self.counts.entry(macro_def_id).or_default() += 1;\n-    }\n-\n-    fn decrease(&mut self, macro_def_id: MacroDefId) {\n-        *self.counts.entry(macro_def_id).or_default() -= 1;\n-    }\n-\n-    fn is_poison(&self, macro_def_id: MacroDefId) -> bool {\n-        let cur = *self.counts.get(&macro_def_id).unwrap_or(&0);\n-\n-        if let Some(validator) = &self.validator {\n-            validator(cur)\n-        } else {\n-            cur > 100\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n enum PartialResolvedImport {\n     /// None of any namespaces is resolved\n@@ -127,32 +97,24 @@ struct ImportDirective {\n     status: PartialResolvedImport,\n }\n \n+#[derive(Clone, Debug, Eq, PartialEq)]\n+struct MacroDirective {\n+    module_id: LocalModuleId,\n+    ast_id: AstId<ast::MacroCall>,\n+    path: Path,\n+    legacy: Option<MacroCallId>,\n+}\n+\n /// Walks the tree of module recursively\n struct DefCollector<'a, DB> {\n     db: &'a DB,\n     def_map: CrateDefMap,\n     glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, LocalImportId)>>,\n     unresolved_imports: Vec<ImportDirective>,\n     resolved_imports: Vec<ImportDirective>,\n-    unexpanded_macros: Vec<(LocalModuleId, AstId<ast::MacroCall>, Path)>,\n+    unexpanded_macros: Vec<MacroDirective>,\n     unexpanded_attribute_macros: Vec<(LocalModuleId, AstId<ast::ModuleItem>, Path)>,\n     mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n-\n-    /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n-    /// To prevent stack overflow, we add a deep counter here for prevent that.\n-    macro_stack_monitor: MacroStackMonitor,\n-    /// Some macros are not well-behavior, which leads to infinite loop\n-    /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n-    /// We mark it down and skip it in collector\n-    ///\n-    /// FIXME:\n-    /// Right now it only handle a poison macro in a single crate,\n-    /// such that if other crate try to call that macro,\n-    /// the whole process will do again until it became poisoned in that crate.\n-    /// We should handle this macro set globally\n-    /// However, do we want to put it as a global variable?\n-    poison_macros: FxHashSet<MacroDefId>,\n-\n     cfg_options: &'a CfgOptions,\n }\n \n@@ -556,18 +518,24 @@ where\n             std::mem::replace(&mut self.unexpanded_attribute_macros, Vec::new());\n         let mut resolved = Vec::new();\n         let mut res = ReachedFixedPoint::Yes;\n-        macros.retain(|(module_id, ast_id, path)| {\n+        macros.retain(|directive| {\n+            if let Some(call_id) = directive.legacy {\n+                res = ReachedFixedPoint::No;\n+                resolved.push((directive.module_id, call_id));\n+                return false;\n+            }\n+\n             let resolved_res = self.def_map.resolve_path_fp_with_macro(\n                 self.db,\n                 ResolveMode::Other,\n-                *module_id,\n-                path,\n+                directive.module_id,\n+                &directive.path,\n                 BuiltinShadowMode::Module,\n             );\n \n             if let Some(def) = resolved_res.resolved_def.take_macros() {\n-                let call_id = def.as_call_id(self.db, MacroCallKind::FnLike(*ast_id));\n-                resolved.push((*module_id, call_id, def));\n+                let call_id = def.as_call_id(self.db, MacroCallKind::FnLike(directive.ast_id));\n+                resolved.push((directive.module_id, call_id));\n                 res = ReachedFixedPoint::No;\n                 return false;\n             }\n@@ -579,7 +547,7 @@ where\n \n             if let Some(def) = resolved_res {\n                 let call_id = def.as_call_id(self.db, MacroCallKind::Attr(*ast_id));\n-                resolved.push((*module_id, call_id, def));\n+                resolved.push((*module_id, call_id));\n                 res = ReachedFixedPoint::No;\n                 return false;\n             }\n@@ -590,8 +558,8 @@ where\n         self.unexpanded_macros = macros;\n         self.unexpanded_attribute_macros = attribute_macros;\n \n-        for (module_id, macro_call_id, macro_def_id) in resolved {\n-            self.collect_macro_expansion(module_id, macro_call_id, macro_def_id);\n+        for (module_id, macro_call_id) in resolved {\n+            self.collect_macro_expansion(module_id, macro_call_id);\n         }\n \n         res\n@@ -611,36 +579,18 @@ where\n         None\n     }\n \n-    fn collect_macro_expansion(\n-        &mut self,\n-        module_id: LocalModuleId,\n-        macro_call_id: MacroCallId,\n-        macro_def_id: MacroDefId,\n-    ) {\n-        if self.poison_macros.contains(&macro_def_id) {\n-            return;\n-        }\n-\n-        self.macro_stack_monitor.increase(macro_def_id);\n-\n-        if !self.macro_stack_monitor.is_poison(macro_def_id) {\n-            let file_id: HirFileId = macro_call_id.as_file();\n-            let raw_items = self.db.raw_items(file_id);\n-            let mod_dir = self.mod_dirs[&module_id].clone();\n-            ModCollector {\n-                def_collector: &mut *self,\n-                file_id,\n-                module_id,\n-                raw_items: &raw_items,\n-                mod_dir,\n-            }\n-            .collect(raw_items.items());\n-        } else {\n-            log::error!(\"Too deep macro expansion: {:?}\", macro_call_id);\n-            self.poison_macros.insert(macro_def_id);\n+    fn collect_macro_expansion(&mut self, module_id: LocalModuleId, macro_call_id: MacroCallId) {\n+        let file_id: HirFileId = macro_call_id.as_file();\n+        let raw_items = self.db.raw_items(file_id);\n+        let mod_dir = self.mod_dirs[&module_id].clone();\n+        ModCollector {\n+            def_collector: &mut *self,\n+            file_id,\n+            module_id,\n+            raw_items: &raw_items,\n+            mod_dir,\n         }\n-\n-        self.macro_stack_monitor.decrease(macro_def_id);\n+        .collect(raw_items.items());\n     }\n \n     fn finish(self) -> CrateDefMap {\n@@ -908,15 +858,20 @@ where\n             return;\n         }\n \n-        // Case 2: try to resolve in legacy scope and expand macro_rules, triggering\n-        // recursive item collection.\n+        // Case 2: try to resolve in legacy scope and expand macro_rules\n         if let Some(macro_def) = mac.path.as_ident().and_then(|name| {\n             self.def_collector.def_map[self.module_id].scope.get_legacy_macro(&name)\n         }) {\n             let macro_call_id =\n                 macro_def.as_call_id(self.def_collector.db, MacroCallKind::FnLike(ast_id));\n \n-            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, macro_def);\n+            self.def_collector.unexpanded_macros.push(MacroDirective {\n+                module_id: self.module_id,\n+                path: mac.path.clone(),\n+                ast_id,\n+                legacy: Some(macro_call_id),\n+            });\n+\n             return;\n         }\n \n@@ -926,7 +881,13 @@ where\n         if path.is_ident() {\n             path.kind = PathKind::Self_;\n         }\n-        self.def_collector.unexpanded_macros.push((self.module_id, ast_id, path));\n+\n+        self.def_collector.unexpanded_macros.push(MacroDirective {\n+            module_id: self.module_id,\n+            path,\n+            ast_id,\n+            legacy: None,\n+        });\n     }\n \n     fn import_all_legacy_macros(&mut self, module_id: LocalModuleId) {\n@@ -951,19 +912,13 @@ fn is_macro_rules(path: &Path) -> bool {\n \n #[cfg(test)]\n mod tests {\n+    use crate::{db::DefDatabase, test_db::TestDB};\n     use ra_arena::Arena;\n     use ra_db::{fixture::WithFixture, SourceDatabase};\n-    use rustc_hash::FxHashSet;\n-\n-    use crate::{db::DefDatabase, test_db::TestDB};\n \n     use super::*;\n \n-    fn do_collect_defs(\n-        db: &impl DefDatabase,\n-        def_map: CrateDefMap,\n-        monitor: MacroStackMonitor,\n-    ) -> (CrateDefMap, FxHashSet<MacroDefId>) {\n+    fn do_collect_defs(db: &impl DefDatabase, def_map: CrateDefMap) -> CrateDefMap {\n         let mut collector = DefCollector {\n             db,\n             def_map,\n@@ -973,19 +928,13 @@ mod tests {\n             unexpanded_macros: Vec::new(),\n             unexpanded_attribute_macros: Vec::new(),\n             mod_dirs: FxHashMap::default(),\n-            macro_stack_monitor: monitor,\n-            poison_macros: FxHashSet::default(),\n             cfg_options: &CfgOptions::default(),\n         };\n         collector.collect();\n-        (collector.def_map, collector.poison_macros)\n+        collector.def_map\n     }\n \n-    fn do_limited_resolve(\n-        code: &str,\n-        limit: u32,\n-        poison_limit: u32,\n-    ) -> (CrateDefMap, FxHashSet<MacroDefId>) {\n+    fn do_resolve(code: &str) -> CrateDefMap {\n         let (db, _file_id) = TestDB::with_single_file(&code);\n         let krate = db.test_crate();\n \n@@ -1003,59 +952,18 @@ mod tests {\n                 diagnostics: Vec::new(),\n             }\n         };\n-\n-        let mut monitor = MacroStackMonitor::default();\n-        monitor.validator = Some(Box::new(move |count| {\n-            assert!(count < limit);\n-            count >= poison_limit\n-        }));\n-\n-        do_collect_defs(&db, def_map, monitor)\n+        do_collect_defs(&db, def_map)\n     }\n \n     #[test]\n-    fn test_macro_expand_limit_width() {\n-        do_limited_resolve(\n+    fn test_macro_expand_will_stop() {\n+        do_resolve(\n             r#\"\n         macro_rules! foo {\n             ($($ty:ty)*) => { foo!($($ty)*, $($ty)*); }\n         }\n foo!(KABOOM);\n         \"#,\n-            16,\n-            1000,\n         );\n     }\n-\n-    #[test]\n-    fn test_macro_expand_poisoned() {\n-        let (_, poison_macros) = do_limited_resolve(\n-            r#\"\n-        macro_rules! foo {\n-            ($ty:ty) => { foo!($ty); }\n-        }\n-foo!(KABOOM);\n-        \"#,\n-            100,\n-            16,\n-        );\n-\n-        assert_eq!(poison_macros.len(), 1);\n-    }\n-\n-    #[test]\n-    fn test_macro_expand_normal() {\n-        let (_, poison_macros) = do_limited_resolve(\n-            r#\"\n-        macro_rules! foo {\n-            ($ident:ident) => { struct $ident {} }\n-        }\n-foo!(Bar);\n-        \"#,\n-            16,\n-            16,\n-        );\n-\n-        assert_eq!(poison_macros.len(), 0);\n-    }\n }"}]}