{"sha": "dbd066a02adac9fb87cea1789b0a31a9355374db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiZDA2NmEwMmFkYWM5ZmI4N2NlYTE3ODliMGEzMWE5MzU1Mzc0ZGI=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-06-04T00:47:38Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-04T01:47:11Z"}, "message": "\"macro\" -> \"syntax extension\" for now", "tree": {"sha": "5331a00bca934955652edfb8a2b4954bf49ea21a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5331a00bca934955652edfb8a2b4954bf49ea21a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbd066a02adac9fb87cea1789b0a31a9355374db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbd066a02adac9fb87cea1789b0a31a9355374db", "html_url": "https://github.com/rust-lang/rust/commit/dbd066a02adac9fb87cea1789b0a31a9355374db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbd066a02adac9fb87cea1789b0a31a9355374db/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79fcd51b4659aabb8cf92bcc69a20207dbd53492", "url": "https://api.github.com/repos/rust-lang/rust/commits/79fcd51b4659aabb8cf92bcc69a20207dbd53492", "html_url": "https://github.com/rust-lang/rust/commit/79fcd51b4659aabb8cf92bcc69a20207dbd53492"}], "stats": {"total": 46, "additions": 23, "deletions": 23}, "files": [{"sha": "eb4742939d3d814e10625ca57877f8a61da5ff69", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/dbd066a02adac9fb87cea1789b0a31a9355374db/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd066a02adac9fb87cea1789b0a31a9355374db/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=dbd066a02adac9fb87cea1789b0a31a9355374db", "patch": "@@ -28,8 +28,8 @@ tag file_type {\n type ty_or_bang = util::common::ty_or_bang[@ast::ty];\n \n // Temporary: to introduce a tag in order to make a recursive type work\n-tag xmacro {\n-    x(macro);\n+tag syntax_extension {\n+    x(syntax_expander);\n }\n \n state type parser =\n@@ -52,15 +52,15 @@ state type parser =\n         fn get_str(token::str_num) -> str;\n         fn get_reader() -> lexer::reader;\n         fn get_filemap() -> codemap::filemap;\n-        fn get_bad_expr_words() -> std::map::hashmap[str, ()];\n-        fn get_macros() -> std::map::hashmap[str, xmacro];\n+        fn get_bad_expr_words() -> hashmap[str, ()];\n+        fn get_syntax_expanders() -> hashmap[str, syntax_extension];\n         fn get_chpos() -> uint;\n         fn get_ann() -> ast::ann;\n         fn next_ann_num() -> uint;\n     };\n \n-type macro = fn(&parser, common::span, &vec[@ast::expr], option::t[str]) \n-    -> @ast::expr;\n+type syntax_expander = fn(&parser, common::span, &vec[@ast::expr], \n+                          option::t[str]) -> @ast::expr;\n \n fn new_parser(session::session sess,\n                      eval::env env,\n@@ -79,8 +79,8 @@ fn new_parser(session::session sess,\n                            lexer::reader rdr,\n                            vec[op_spec] precs,\n                            mutable uint next_ann_var,\n-                           std::map::hashmap[str, ()] bad_words,\n-                           std::map::hashmap[str, xmacro] macros)\n+                           hashmap[str, ()] bad_words,\n+                           hashmap[str, syntax_extension] syntax_expanders)\n         {\n             fn peek() -> token::token {\n                 ret tok;\n@@ -149,12 +149,12 @@ fn new_parser(session::session sess,\n                 ret rdr.get_filemap();\n             }\n \n-            fn get_bad_expr_words() -> std::map::hashmap[str, ()] {\n+            fn get_bad_expr_words() -> hashmap[str, ()] {\n                 ret bad_words;\n             }\n \n-            fn get_macros() -> std::map::hashmap[str, xmacro] {\n-                ret macros;\n+            fn get_syntax_expanders() -> hashmap[str, syntax_extension] {\n+                ret syntax_expanders;\n             }\n \n             fn get_chpos() -> uint {ret rdr.get_chpos();}\n@@ -183,13 +183,13 @@ fn new_parser(session::session sess,\n     ret stdio_parser(sess, env, ftype, lexer::next_token(rdr),\n                      npos, npos, npos, initial_def._1, UNRESTRICTED,\n                      initial_def._0, rdr, prec_table(), next_ann,\n-                     bad_expr_word_table(), macro_table());\n+                     bad_expr_word_table(), syntax_expander_table());\n }\n \n // These are the words that shouldn't be allowed as value identifiers,\n // because, if used at the start of a line, they will cause the line to be\n // interpreted as a specific kind of statement, which would be confusing.\n-fn bad_expr_word_table() -> std::map::hashmap[str, ()] {\n+fn bad_expr_word_table() -> hashmap[str, ()] {\n     auto words = new_str_hash[()]();\n     words.insert(\"mod\", ());\n     words.insert(\"if\", ());\n@@ -227,11 +227,11 @@ fn bad_expr_word_table() -> std::map::hashmap[str, ()] {\n     ret words;\n }\n \n-fn macro_table() -> std::map::hashmap[str, xmacro] {\n-    auto macros = new_str_hash[xmacro]();\n-    macros.insert(\"fmt\", x(extfmt::expand_syntax_ext));\n-    macros.insert(\"env\", x(extenv::expand_syntax_ext));\n-    ret macros;\n+fn syntax_expander_table() -> hashmap[str, syntax_extension] {\n+    auto syntax_expanders = new_str_hash[syntax_extension]();\n+    syntax_expanders.insert(\"fmt\", x(extfmt::expand_syntax_ext));\n+    syntax_expanders.insert(\"env\", x(extenv::expand_syntax_ext));\n+    ret syntax_expanders;\n }\n \n fn unexpected(&parser p, token::token t) -> ! {\n@@ -1059,11 +1059,11 @@ fn expand_syntax_ext(&parser p, common::span sp,\n     assert (vec::len[ast::ident](path.node.idents) > 0u);\n     auto extname = path.node.idents.(0);\n \n-    alt (p.get_macros().find(extname)) {\n-        case (none[xmacro]) {\n-            p.err(\"unknown macro: '\" + extname + \"'\");\n+    alt (p.get_syntax_expanders().find(extname)) {\n+        case (none[syntax_extension]) {\n+            p.err(\"unknown syntax expander: '\" + extname + \"'\");\n         }\n-        case (some[xmacro](x(?ext))) {\n+        case (some[syntax_extension](x(?ext))) {\n             ret ast::expr_ext(path, args, body, ext(p, sp, args, body), \n                               p.get_ann());\n         }"}, {"sha": "e068bb3c4a4d6429028d528a3271e38a2dfb6677", "filename": "src/test/compile-fail/ext-nonexistent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbd066a02adac9fb87cea1789b0a31a9355374db/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd066a02adac9fb87cea1789b0a31a9355374db/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs?ref=dbd066a02adac9fb87cea1789b0a31a9355374db", "patch": "@@ -1,5 +1,5 @@\n \n-// error-pattern:unknown macro\n+// error-pattern:unknown syntax expander\n fn main() {\n   #iamnotanextensionthatexists(\"\");\n }\n\\ No newline at end of file"}]}