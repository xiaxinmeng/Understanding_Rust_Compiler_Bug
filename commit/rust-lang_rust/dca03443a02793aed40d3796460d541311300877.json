{"sha": "dca03443a02793aed40d3796460d541311300877", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjYTAzNDQzYTAyNzkzYWVkNDBkMzc5NjQ2MGQ1NDEzMTEzMDA4Nzc=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-19T13:24:21Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-26T08:38:33Z"}, "message": "Make librustc compile.", "tree": {"sha": "9257d4244f2375757bca799fb8487705e1d517e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9257d4244f2375757bca799fb8487705e1d517e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dca03443a02793aed40d3796460d541311300877", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dca03443a02793aed40d3796460d541311300877", "html_url": "https://github.com/rust-lang/rust/commit/dca03443a02793aed40d3796460d541311300877", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dca03443a02793aed40d3796460d541311300877/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e873c3c646b7739268f139ac140b6ac4218e979", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e873c3c646b7739268f139ac140b6ac4218e979", "html_url": "https://github.com/rust-lang/rust/commit/8e873c3c646b7739268f139ac140b6ac4218e979"}], "stats": {"total": 780, "additions": 773, "deletions": 7}, "files": [{"sha": "8ec07b9fdeb7844820f565350d72f2b102ea6496", "filename": "src/librustc/ty/query/README.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2FREADME.md?ref=dca03443a02793aed40d3796460d541311300877", "patch": "@@ -0,0 +1,3 @@\n+For more information about how the query system works, see the [rustc dev guide].\n+\n+[rustc dev guide]: https://rustc-dev-guide.rust-lang.org/query.html"}, {"sha": "5f7a9e81158e0580809d4133bbde8f60a7471565", "filename": "src/librustc/ty/query/job.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=dca03443a02793aed40d3796460d541311300877", "patch": "@@ -0,0 +1,29 @@\n+use crate::ty::tls;\n+\n+use rustc_query_system::query::deadlock;\n+use rustc_rayon_core as rayon_core;\n+use std::thread;\n+\n+/// Creates a new thread and forwards information in thread locals to it.\n+/// The new thread runs the deadlock handler.\n+/// Must only be called when a deadlock is about to happen.\n+pub unsafe fn handle_deadlock() {\n+    let registry = rayon_core::Registry::current();\n+\n+    let gcx_ptr = tls::GCX_PTR.with(|gcx_ptr| gcx_ptr as *const _);\n+    let gcx_ptr = &*gcx_ptr;\n+\n+    let rustc_span_globals =\n+        rustc_span::GLOBALS.with(|rustc_span_globals| rustc_span_globals as *const _);\n+    let rustc_span_globals = &*rustc_span_globals;\n+    let syntax_globals = rustc_ast::attr::GLOBALS.with(|syntax_globals| syntax_globals as *const _);\n+    let syntax_globals = &*syntax_globals;\n+    thread::spawn(move || {\n+        tls::GCX_PTR.set(gcx_ptr, || {\n+            rustc_ast::attr::GLOBALS.set(syntax_globals, || {\n+                rustc_span::GLOBALS\n+                    .set(rustc_span_globals, || tls::with_global(|tcx| deadlock(tcx, &registry)))\n+            });\n+        })\n+    });\n+}"}, {"sha": "a261e484a85faada4d493a0fc16df0a29f74f62e", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=dca03443a02793aed40d3796460d541311300877", "patch": "@@ -4,10 +4,10 @@ use crate::infer::canonical::Canonical;\n use crate::mir;\n use crate::traits;\n use crate::ty::fast_reject::SimplifiedType;\n-use crate::ty::query::caches::DefaultCacheSelector;\n use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n+use rustc_query_system::query::DefaultCacheSelector;\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n "}, {"sha": "744237520fbfd07eaec63cd9d517b1a4eae5a8db", "filename": "src/librustc/ty/query/mod.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=dca03443a02793aed40d3796460d541311300877", "patch": "@@ -0,0 +1,191 @@\n+use crate::dep_graph::{self, DepConstructor, DepNode, DepNodeParams};\n+use crate::hir::exports::Export;\n+use crate::hir::map;\n+use crate::infer::canonical::{self, Canonical};\n+use crate::lint::LintLevelMap;\n+use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n+use crate::middle::cstore::{CrateSource, DepKind, NativeLibraryKind};\n+use crate::middle::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLibrary};\n+use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n+use crate::middle::lang_items::{LangItem, LanguageItems};\n+use crate::middle::lib_features::LibFeatures;\n+use crate::middle::privacy::AccessLevels;\n+use crate::middle::region;\n+use crate::middle::resolve_lifetime::{ObjectLifetimeDefault, Region, ResolveLifetimes};\n+use crate::middle::stability::{self, DeprecationEntry};\n+use crate::mir;\n+use crate::mir::interpret::GlobalId;\n+use crate::mir::interpret::{ConstEvalRawResult, ConstEvalResult, ConstValue};\n+use crate::mir::interpret::{LitToConstError, LitToConstInput};\n+use crate::mir::mono::CodegenUnit;\n+use crate::traits::query::{\n+    CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n+    CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n+    CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal, NoSolution,\n+};\n+use crate::traits::query::{\n+    DropckOutlivesResult, DtorckConstraint, MethodAutoderefStepsResult, NormalizationResult,\n+    OutlivesBound,\n+};\n+use crate::traits::specialization_graph;\n+use crate::traits::Clauses;\n+use crate::traits::{self, Vtable};\n+use crate::ty::steal::Steal;\n+use crate::ty::subst::{GenericArg, SubstsRef};\n+use crate::ty::util::AlwaysRequiresDrop;\n+use crate::ty::{self, AdtSizedConstraint, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n+use crate::util::common::ErrorReported;\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n+use rustc_data_structures::profiling::ProfileCategory::*;\n+use rustc_data_structures::stable_hasher::StableVec;\n+use rustc_data_structures::svh::Svh;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId};\n+use rustc_hir::{Crate, HirIdSet, ItemLocalId, TraitCandidate};\n+use rustc_index::vec::IndexVec;\n+use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n+use rustc_session::CrateDisambiguator;\n+use rustc_target::spec::PanicStrategy;\n+\n+use rustc_ast::ast;\n+use rustc_attr as attr;\n+use rustc_span::symbol::Symbol;\n+use rustc_span::{Span, DUMMY_SP};\n+use std::borrow::Cow;\n+use std::collections::BTreeMap;\n+use std::ops::Deref;\n+use std::sync::Arc;\n+\n+#[macro_use]\n+mod plumbing;\n+pub(crate) use rustc_query_system::query::CycleError;\n+use rustc_query_system::query::*;\n+\n+mod stats;\n+pub use self::stats::print_stats;\n+\n+#[cfg(parallel_compiler)]\n+mod job;\n+#[cfg(parallel_compiler)]\n+pub use self::job::handle_deadlock;\n+pub use rustc_query_system::query::{QueryInfo, QueryJob, QueryJobId};\n+\n+mod keys;\n+use self::keys::Key;\n+\n+mod values;\n+use self::values::Value;\n+\n+use rustc_query_system::query::QueryAccessors;\n+pub use rustc_query_system::query::QueryConfig;\n+pub(crate) use rustc_query_system::query::QueryDescription;\n+\n+mod on_disk_cache;\n+pub use self::on_disk_cache::OnDiskCache;\n+\n+mod profiling_support;\n+pub use self::profiling_support::{IntoSelfProfilingString, QueryKeyStringBuilder};\n+\n+// Each of these queries corresponds to a function pointer field in the\n+// `Providers` struct for requesting a value of that type, and a method\n+// on `tcx: TyCtxt` (and `tcx.at(span)`) for doing that request in a way\n+// which memoizes and does dep-graph tracking, wrapping around the actual\n+// `Providers` that the driver creates (using several `rustc_*` crates).\n+//\n+// The result type of each query must implement `Clone`, and additionally\n+// `ty::query::values::Value`, which produces an appropriate placeholder\n+// (error) value if the query resulted in a query cycle.\n+// Queries marked with `fatal_cycle` do not need the latter implementation,\n+// as they will raise an fatal error on query cycles instead.\n+\n+rustc_query_append! { [define_queries!][<'tcx>] }\n+\n+/// The red/green evaluation system will try to mark a specific DepNode in the\n+/// dependency graph as green by recursively trying to mark the dependencies of\n+/// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n+/// where we don't know if it is red or green and we therefore actually have\n+/// to recompute its value in order to find out. Since the only piece of\n+/// information that we have at that point is the `DepNode` we are trying to\n+/// re-evaluate, we need some way to re-run a query from just that. This is what\n+/// `force_from_dep_node()` implements.\n+///\n+/// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n+/// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n+/// is usually constructed by computing a stable hash of the query-key that the\n+/// `DepNode` corresponds to. Consequently, it is not in general possible to go\n+/// back from hash to query-key (since hash functions are not reversible). For\n+/// this reason `force_from_dep_node()` is expected to fail from time to time\n+/// because we just cannot find out, from the `DepNode` alone, what the\n+/// corresponding query-key is and therefore cannot re-run the query.\n+///\n+/// The system deals with this case letting `try_mark_green` fail which forces\n+/// the root query to be re-evaluated.\n+///\n+/// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n+/// Fortunately, we can use some contextual information that will allow us to\n+/// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n+/// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n+/// valid `DefPathHash`. Since we also always build a huge table that maps every\n+/// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n+/// everything we need to re-run the query.\n+///\n+/// Take the `mir_validated` query as an example. Like many other queries, it\n+/// just has a single parameter: the `DefId` of the item it will compute the\n+/// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n+/// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n+/// is actually a `DefPathHash`, and can therefore just look up the corresponding\n+/// `DefId` in `tcx.def_path_hash_to_def_id`.\n+///\n+/// When you implement a new query, it will likely have a corresponding new\n+/// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n+/// a rule of thumb, if your query takes a `DefId` or `LocalDefId` as sole parameter,\n+/// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n+/// add it to the \"We don't have enough information to reconstruct...\" group in\n+/// the match below.\n+pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool {\n+    // We must avoid ever having to call `force_from_dep_node()` for a\n+    // `DepNode::codegen_unit`:\n+    // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n+    // would always end up having to evaluate the first caller of the\n+    // `codegen_unit` query that *is* reconstructible. This might very well be\n+    // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n+    // to re-trigger calling the `codegen_unit` query with the right key. At\n+    // that point we would already have re-done all the work we are trying to\n+    // avoid doing in the first place.\n+    // The solution is simple: Just explicitly call the `codegen_unit` query for\n+    // each CGU, right after partitioning. This way `try_mark_green` will always\n+    // hit the cache instead of having to go through `force_from_dep_node`.\n+    // This assertion makes sure, we actually keep applying the solution above.\n+    debug_assert!(\n+        dep_node.kind != crate::dep_graph::DepKind::codegen_unit,\n+        \"calling force_from_dep_node() on DepKind::codegen_unit\"\n+    );\n+\n+    if !dep_node.kind.can_reconstruct_query_key() {\n+        return false;\n+    }\n+\n+    rustc_dep_node_force!([dep_node, tcx]\n+        // These are inputs that are expected to be pre-allocated and that\n+        // should therefore always be red or green already.\n+        crate::dep_graph::DepKind::CrateMetadata |\n+\n+        // These are anonymous nodes.\n+        crate::dep_graph::DepKind::TraitSelect |\n+\n+        // We don't have enough information to reconstruct the query key of\n+        // these.\n+        crate::dep_graph::DepKind::CompileCodegenUnit => {\n+            bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n+        }\n+    );\n+\n+    false\n+}\n+\n+pub(crate) fn try_load_from_on_disk_cache<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) {\n+    rustc_dep_node_try_load_from_on_disk_cache!(dep_node, tcx)\n+}"}, {"sha": "8aecc0e698a8efe4d161b5549de3eb4d5c1b871b", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=dca03443a02793aed40d3796460d541311300877", "patch": "@@ -994,7 +994,7 @@ fn encode_query_results<'a, 'tcx, Q, E>(\n     query_result_index: &mut EncodedQueryResultIndex,\n ) -> Result<(), E::Error>\n where\n-    Q: super::config::QueryDescription<TyCtxt<'tcx>>,\n+    Q: super::QueryDescription<TyCtxt<'tcx>>,\n     Q::Value: Encodable,\n     E: 'a + TyEncoder,\n {"}, {"sha": "ef60ac893d21659c262a698d92c2aba8d5763176", "filename": "src/librustc/ty/query/plumbing.rs", "status": "added", "additions": 543, "deletions": 0, "changes": 543, "blob_url": "https://github.com/rust-lang/rust/blob/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=dca03443a02793aed40d3796460d541311300877", "patch": "@@ -0,0 +1,543 @@\n+//! The implementation of the query system itself. This defines the macros that\n+//! generate the actual methods on tcx which find and execute the provider,\n+//! manage the caches, and so forth.\n+\n+use crate::dep_graph::DepGraph;\n+use crate::ty::query::Query;\n+use crate::ty::tls::{self, ImplicitCtxt};\n+use crate::ty::{self, TyCtxt};\n+use rustc_query_system::query::QueryContext;\n+use rustc_query_system::query::{CycleError, QueryJobId, QueryJobInfo};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder, Handler, Level};\n+use rustc_session::Session;\n+use rustc_span::def_id::DefId;\n+use rustc_span::Span;\n+\n+impl QueryContext for TyCtxt<'tcx> {\n+    type Query = Query<'tcx>;\n+\n+    fn session(&self) -> &Session {\n+        &self.sess\n+    }\n+\n+    fn def_path_str(&self, def_id: DefId) -> String {\n+        TyCtxt::def_path_str(*self, def_id)\n+    }\n+\n+    fn dep_graph(&self) -> &DepGraph {\n+        &self.dep_graph\n+    }\n+\n+    fn read_query_job<R>(&self, op: impl FnOnce(Option<QueryJobId<Self::DepKind>>) -> R) -> R {\n+        tls::with_related_context(*self, move |icx| op(icx.query))\n+    }\n+\n+    fn try_collect_active_jobs(\n+        &self,\n+    ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self>>> {\n+        self.queries.try_collect_active_jobs()\n+    }\n+\n+    /// Executes a job by changing the `ImplicitCtxt` to point to the\n+    /// new query job while it executes. It returns the diagnostics\n+    /// captured during execution and the actual result.\n+    #[inline(always)]\n+    fn start_query<R>(\n+        &self,\n+        token: QueryJobId<Self::DepKind>,\n+        diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n+        compute: impl FnOnce(Self) -> R,\n+    ) -> R {\n+        // The `TyCtxt` stored in TLS has the same global interner lifetime\n+        // as `self`, so we use `with_related_context` to relate the 'tcx lifetimes\n+        // when accessing the `ImplicitCtxt`.\n+        tls::with_related_context(*self, move |current_icx| {\n+            // Update the `ImplicitCtxt` to point to our new query job.\n+            let new_icx = ImplicitCtxt {\n+                tcx: *self,\n+                query: Some(token),\n+                diagnostics,\n+                layout_depth: current_icx.layout_depth,\n+                task_deps: current_icx.task_deps,\n+            };\n+\n+            // Use the `ImplicitCtxt` while we execute the query.\n+            tls::enter_context(&new_icx, |_| compute(*self))\n+        })\n+    }\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    #[inline(never)]\n+    #[cold]\n+    pub(super) fn report_cycle(\n+        self,\n+        CycleError { usage, cycle: stack }: CycleError<Query<'tcx>>,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        assert!(!stack.is_empty());\n+\n+        let fix_span = |span: Span, query: &Query<'tcx>| {\n+            self.sess.source_map().guess_head_span(query.default_span(self, span))\n+        };\n+\n+        // Disable naming impls with types in this path, since that\n+        // sometimes cycles itself, leading to extra cycle errors.\n+        // (And cycle errors around impls tend to occur during the\n+        // collect/coherence phases anyhow.)\n+        ty::print::with_forced_impl_filename_line(|| {\n+            let span = fix_span(stack[1 % stack.len()].span, &stack[0].query);\n+            let mut err = struct_span_err!(\n+                self.sess,\n+                span,\n+                E0391,\n+                \"cycle detected when {}\",\n+                stack[0].query.describe(self)\n+            );\n+\n+            for i in 1..stack.len() {\n+                let query = &stack[i].query;\n+                let span = fix_span(stack[(i + 1) % stack.len()].span, query);\n+                err.span_note(span, &format!(\"...which requires {}...\", query.describe(self)));\n+            }\n+\n+            err.note(&format!(\n+                \"...which again requires {}, completing the cycle\",\n+                stack[0].query.describe(self)\n+            ));\n+\n+            if let Some((span, query)) = usage {\n+                err.span_note(\n+                    fix_span(span, &query),\n+                    &format!(\"cycle used when {}\", query.describe(self)),\n+                );\n+            }\n+\n+            err\n+        })\n+    }\n+\n+    pub fn try_print_query_stack(handler: &Handler) {\n+        eprintln!(\"query stack during panic:\");\n+\n+        // Be careful reyling on global state here: this code is called from\n+        // a panic hook, which means that the global `Handler` may be in a weird\n+        // state if it was responsible for triggering the panic.\n+        ty::tls::with_context_opt(|icx| {\n+            if let Some(icx) = icx {\n+                let query_map = icx.tcx.queries.try_collect_active_jobs();\n+\n+                let mut current_query = icx.query;\n+                let mut i = 0;\n+\n+                while let Some(query) = current_query {\n+                    let query_info =\n+                        if let Some(info) = query_map.as_ref().and_then(|map| map.get(&query)) {\n+                            info\n+                        } else {\n+                            break;\n+                        };\n+                    let mut diag = Diagnostic::new(\n+                        Level::FailureNote,\n+                        &format!(\n+                            \"#{} [{}] {}\",\n+                            i,\n+                            query_info.info.query.name(),\n+                            query_info.info.query.describe(icx.tcx)\n+                        ),\n+                    );\n+                    diag.span = icx.tcx.sess.source_map().guess_head_span(query_info.info.span).into();\n+                    handler.force_print_diagnostic(diag);\n+\n+                    current_query = query_info.job.parent;\n+                    i += 1;\n+                }\n+            }\n+        });\n+\n+        eprintln!(\"end of query stack\");\n+    }\n+}\n+\n+macro_rules! handle_cycle_error {\n+    ([][$tcx: expr, $error:expr]) => {{\n+        $tcx.report_cycle($error).emit();\n+        Value::from_cycle_error($tcx)\n+    }};\n+    ([fatal_cycle $($rest:tt)*][$tcx:expr, $error:expr]) => {{\n+        $tcx.report_cycle($error).emit();\n+        $tcx.sess.abort_if_errors();\n+        unreachable!()\n+    }};\n+    ([cycle_delay_bug $($rest:tt)*][$tcx:expr, $error:expr]) => {{\n+        $tcx.report_cycle($error).delay_as_bug();\n+        Value::from_cycle_error($tcx)\n+    }};\n+    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n+        handle_cycle_error!([$($($modifiers)*)*][$($args)*])\n+    };\n+}\n+\n+macro_rules! is_anon {\n+    ([]) => {{\n+        false\n+    }};\n+    ([anon $($rest:tt)*]) => {{\n+        true\n+    }};\n+    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*]) => {\n+        is_anon!([$($($modifiers)*)*])\n+    };\n+}\n+\n+macro_rules! is_eval_always {\n+    ([]) => {{\n+        false\n+    }};\n+    ([eval_always $($rest:tt)*]) => {{\n+        true\n+    }};\n+    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*]) => {\n+        is_eval_always!([$($($modifiers)*)*])\n+    };\n+}\n+\n+macro_rules! query_storage {\n+    (<$tcx:tt>[][$K:ty, $V:ty]) => {\n+        <<$K as Key>::CacheSelector as CacheSelector<TyCtxt<$tcx>, $K, $V>>::Cache\n+    };\n+    (<$tcx:tt>[storage($ty:ty) $($rest:tt)*][$K:ty, $V:ty]) => {\n+        $ty\n+    };\n+    (<$tcx:tt>[$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n+        query_storage!(<$tcx>[$($($modifiers)*)*][$($args)*])\n+    };\n+}\n+\n+macro_rules! hash_result {\n+    ([][$hcx:expr, $result:expr]) => {{\n+        dep_graph::hash_result($hcx, &$result)\n+    }};\n+    ([no_hash $($rest:tt)*][$hcx:expr, $result:expr]) => {{\n+        None\n+    }};\n+    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n+        hash_result!([$($($modifiers)*)*][$($args)*])\n+    };\n+}\n+\n+macro_rules! define_queries {\n+    (<$tcx:tt> $($category:tt {\n+        $($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*\n+    },)*) => {\n+        define_queries_inner! { <$tcx>\n+            $($( $(#[$attr])* category<$category> [$($modifiers)*] fn $name: $node($K) -> $V,)*)*\n+        }\n+    }\n+}\n+\n+macro_rules! define_queries_inner {\n+    (<$tcx:tt>\n+     $($(#[$attr:meta])* category<$category:tt>\n+        [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n+\n+        use std::mem;\n+        use crate::{\n+            rustc_data_structures::stable_hasher::HashStable,\n+            rustc_data_structures::stable_hasher::StableHasher,\n+            ich::StableHashingContext\n+        };\n+        use rustc_data_structures::profiling::ProfileCategory;\n+\n+        define_queries_struct! {\n+            tcx: $tcx,\n+            input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n+        }\n+\n+        #[allow(nonstandard_style)]\n+        #[derive(Clone, Debug)]\n+        pub enum Query<$tcx> {\n+            $($(#[$attr])* $name($K)),*\n+        }\n+\n+        impl<$tcx> Query<$tcx> {\n+            pub fn name(&self) -> &'static str {\n+                match *self {\n+                    $(Query::$name(_) => stringify!($name),)*\n+                }\n+            }\n+\n+            pub fn describe(&self, tcx: TyCtxt<$tcx>) -> Cow<'static, str> {\n+                let (r, name) = match *self {\n+                    $(Query::$name(key) => {\n+                        (queries::$name::describe(tcx, key), stringify!($name))\n+                    })*\n+                };\n+                if tcx.sess.verbose() {\n+                    format!(\"{} [{}]\", r, name).into()\n+                } else {\n+                    r\n+                }\n+            }\n+\n+            // FIXME(eddyb) Get more valid `Span`s on queries.\n+            pub fn default_span(&self, tcx: TyCtxt<$tcx>, span: Span) -> Span {\n+                if !span.is_dummy() {\n+                    return span;\n+                }\n+                // The `def_span` query is used to calculate `default_span`,\n+                // so exit to avoid infinite recursion.\n+                if let Query::def_span(..) = *self {\n+                    return span\n+                }\n+                match *self {\n+                    $(Query::$name(key) => key.default_span(tcx),)*\n+                }\n+            }\n+        }\n+\n+        impl<'a, $tcx> HashStable<StableHashingContext<'a>> for Query<$tcx> {\n+            fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+                mem::discriminant(self).hash_stable(hcx, hasher);\n+                match *self {\n+                    $(Query::$name(key) => key.hash_stable(hcx, hasher),)*\n+                }\n+            }\n+        }\n+\n+        pub mod queries {\n+            use std::marker::PhantomData;\n+\n+            $(#[allow(nonstandard_style)]\n+            pub struct $name<$tcx> {\n+                data: PhantomData<&$tcx ()>\n+            })*\n+        }\n+\n+        $(impl<$tcx> QueryConfig<TyCtxt<$tcx>> for queries::$name<$tcx> {\n+            type Key = $K;\n+            type Value = $V;\n+            const NAME: &'static str = stringify!($name);\n+            const CATEGORY: ProfileCategory = $category;\n+        }\n+\n+        impl<$tcx> QueryAccessors<TyCtxt<$tcx>> for queries::$name<$tcx> {\n+            const ANON: bool = is_anon!([$($modifiers)*]);\n+            const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n+            const DEP_KIND: dep_graph::DepKind = dep_graph::DepKind::$node;\n+\n+            type Cache = query_storage!(<$tcx>[$($modifiers)*][$K, $V]);\n+\n+            #[inline(always)]\n+            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<TyCtxt<$tcx>, Self::Cache> {\n+                &tcx.queries.$name\n+            }\n+\n+            #[allow(unused)]\n+            #[inline(always)]\n+            fn to_dep_node(tcx: TyCtxt<$tcx>, key: &Self::Key) -> DepNode {\n+                DepConstructor::$node(tcx, *key)\n+            }\n+\n+            #[inline]\n+            fn compute(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n+                let provider = tcx.queries.providers.get(key.query_crate())\n+                    // HACK(eddyb) it's possible crates may be loaded after\n+                    // the query engine is created, and because crate loading\n+                    // is not yet integrated with the query engine, such crates\n+                    // would be missing appropriate entries in `providers`.\n+                    .unwrap_or(&tcx.queries.fallback_extern_providers)\n+                    .$name;\n+                provider(tcx, key)\n+            }\n+\n+            fn hash_result(\n+                _hcx: &mut StableHashingContext<'_>,\n+                _result: &Self::Value\n+            ) -> Option<Fingerprint> {\n+                hash_result!([$($modifiers)*][_hcx, _result])\n+            }\n+\n+            fn handle_cycle_error(\n+                tcx: TyCtxt<'tcx>,\n+                error: CycleError<Query<'tcx>>\n+            ) -> Self::Value {\n+                handle_cycle_error!([$($modifiers)*][tcx, error])\n+            }\n+        })*\n+\n+        #[derive(Copy, Clone)]\n+        pub struct TyCtxtEnsure<'tcx> {\n+            pub tcx: TyCtxt<'tcx>,\n+        }\n+\n+        impl TyCtxtEnsure<$tcx> {\n+            $($(#[$attr])*\n+            #[inline(always)]\n+            pub fn $name(self, key: $K) {\n+                self.tcx.ensure_query::<queries::$name<'_>>(key)\n+            })*\n+        }\n+\n+        #[derive(Copy, Clone)]\n+        pub struct TyCtxtAt<'tcx> {\n+            pub tcx: TyCtxt<'tcx>,\n+            pub span: Span,\n+        }\n+\n+        impl Deref for TyCtxtAt<'tcx> {\n+            type Target = TyCtxt<'tcx>;\n+            #[inline(always)]\n+            fn deref(&self) -> &Self::Target {\n+                &self.tcx\n+            }\n+        }\n+\n+        impl TyCtxt<$tcx> {\n+            /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n+            /// are executed instead of just returning their results.\n+            #[inline(always)]\n+            pub fn ensure(self) -> TyCtxtEnsure<$tcx> {\n+                TyCtxtEnsure {\n+                    tcx: self,\n+                }\n+            }\n+\n+            /// Returns a transparent wrapper for `TyCtxt` which uses\n+            /// `span` as the location of queries performed through it.\n+            #[inline(always)]\n+            pub fn at(self, span: Span) -> TyCtxtAt<$tcx> {\n+                TyCtxtAt {\n+                    tcx: self,\n+                    span\n+                }\n+            }\n+\n+            $($(#[$attr])*\n+            #[inline(always)]\n+            pub fn $name(self, key: $K) -> $V {\n+                self.at(DUMMY_SP).$name(key)\n+            })*\n+\n+            /// All self-profiling events generated by the query engine use\n+            /// virtual `StringId`s for their `event_id`. This method makes all\n+            /// those virtual `StringId`s point to actual strings.\n+            ///\n+            /// If we are recording only summary data, the ids will point to\n+            /// just the query names. If we are recording query keys too, we\n+            /// allocate the corresponding strings here.\n+            pub fn alloc_self_profile_query_strings(self) {\n+                use crate::ty::query::profiling_support::{\n+                    alloc_self_profile_query_strings_for_query_cache,\n+                    QueryKeyStringCache,\n+                };\n+\n+                if !self.prof.enabled() {\n+                    return;\n+                }\n+\n+                let mut string_cache = QueryKeyStringCache::new();\n+\n+                $({\n+                    alloc_self_profile_query_strings_for_query_cache(\n+                        self,\n+                        stringify!($name),\n+                        &self.queries.$name,\n+                        &mut string_cache,\n+                    );\n+                })*\n+            }\n+        }\n+\n+        impl TyCtxtAt<$tcx> {\n+            $($(#[$attr])*\n+            #[inline(always)]\n+            pub fn $name(self, key: $K) -> $V {\n+                self.tcx.get_query::<queries::$name<'_>>(self.span, key)\n+            })*\n+        }\n+\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: ($(([$($modifiers)*] [$name] [$K] [$V]))*)\n+        }\n+\n+        impl<$tcx> Copy for Providers<$tcx> {}\n+        impl<$tcx> Clone for Providers<$tcx> {\n+            fn clone(&self) -> Self { *self }\n+        }\n+    }\n+}\n+\n+macro_rules! define_queries_struct {\n+    (tcx: $tcx:tt,\n+     input: ($(([$($modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n+        pub struct Queries<$tcx> {\n+            /// This provides access to the incrimental comilation on-disk cache for query results.\n+            /// Do not access this directly. It is only meant to be used by\n+            /// `DepGraph::try_mark_green()` and the query infrastructure.\n+            pub(crate) on_disk_cache: OnDiskCache<'tcx>,\n+\n+            providers: IndexVec<CrateNum, Providers<$tcx>>,\n+            fallback_extern_providers: Box<Providers<$tcx>>,\n+\n+            $($(#[$attr])*  $name: QueryState<\n+                TyCtxt<$tcx>,\n+                <queries::$name<$tcx> as QueryAccessors<TyCtxt<'tcx>>>::Cache,\n+            >,)*\n+        }\n+\n+        impl<$tcx> Queries<$tcx> {\n+            pub(crate) fn new(\n+                providers: IndexVec<CrateNum, Providers<$tcx>>,\n+                fallback_extern_providers: Providers<$tcx>,\n+                on_disk_cache: OnDiskCache<'tcx>,\n+            ) -> Self {\n+                Queries {\n+                    providers,\n+                    fallback_extern_providers: Box::new(fallback_extern_providers),\n+                    on_disk_cache,\n+                    $($name: Default::default()),*\n+                }\n+            }\n+\n+            pub(crate) fn try_collect_active_jobs(\n+                &self\n+            ) -> Option<FxHashMap<QueryJobId<crate::dep_graph::DepKind>, QueryJobInfo<TyCtxt<'tcx>>>> {\n+                let mut jobs = FxHashMap::default();\n+\n+                $(\n+                    self.$name.try_collect_active_jobs(\n+                        <queries::$name<'tcx> as QueryAccessors<TyCtxt<'tcx>>>::DEP_KIND,\n+                        Query::$name,\n+                        &mut jobs,\n+                    )?;\n+                )*\n+\n+                Some(jobs)\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! define_provider_struct {\n+    (tcx: $tcx:tt,\n+     input: ($(([$($modifiers:tt)*] [$name:ident] [$K:ty] [$R:ty]))*)) => {\n+        pub struct Providers<$tcx> {\n+            $(pub $name: fn(TyCtxt<$tcx>, $K) -> $R,)*\n+        }\n+\n+        impl<$tcx> Default for Providers<$tcx> {\n+            fn default() -> Self {\n+                $(fn $name<$tcx>(_: TyCtxt<$tcx>, key: $K) -> $R {\n+                    bug!(\"`tcx.{}({:?})` unsupported by its crate\",\n+                         stringify!($name), key);\n+                })*\n+                Providers { $($name),* }\n+            }\n+        }\n+    };\n+}"}, {"sha": "d7972045d12548d7aa6a68e7309fd77642129d58", "filename": "src/librustc/ty/query/profiling_support.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs?ref=dca03443a02793aed40d3796460d541311300877", "patch": "@@ -1,11 +1,11 @@\n use crate::ty::context::TyCtxt;\n-use crate::ty::query::caches::QueryCache;\n-use crate::ty::query::plumbing::QueryState;\n use measureme::{StringComponent, StringId};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfiler;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathData;\n+use rustc_query_system::query::QueryCache;\n+use rustc_query_system::query::QueryState;\n use std::fmt::Debug;\n use std::io::Write;\n "}, {"sha": "12e9094fba61eb45d38d227af9140675278228d4", "filename": "src/librustc/ty/query/stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca03443a02793aed40d3796460d541311300877/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs?ref=dca03443a02793aed40d3796460d541311300877", "patch": "@@ -1,9 +1,9 @@\n-use crate::ty::query::caches::QueryCache;\n-use crate::ty::query::config::{QueryAccessors, QueryContext};\n-use crate::ty::query::plumbing::QueryState;\n use crate::ty::query::queries;\n use crate::ty::TyCtxt;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_query_system::query::QueryCache;\n+use rustc_query_system::query::QueryState;\n+use rustc_query_system::query::{QueryAccessors, QueryContext};\n \n use std::any::type_name;\n use std::mem;"}]}