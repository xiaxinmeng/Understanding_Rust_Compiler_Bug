{"sha": "11ce918c75b05d065ce3bf98b20d62465b5afc55", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExY2U5MThjNzViMDVkMDY1Y2UzYmY5OGIyMGQ2MjQ2NWI1YWZjNTU=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-11-16T16:26:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-16T16:26:27Z"}, "message": "Rollup merge of #78714 - m-ou-se:simplify-local-streams, r=KodrAus\n\nSimplify output capturing\n\nThis is a sequence of incremental improvements to the unstable/internal `set_panic` and `set_print` mechanism used by the `test` crate:\n\n1. Remove the `LocalOutput` trait and use `Arc<Mutex<dyn Write>>` instead of `Box<dyn LocalOutput>`. In practice, all implementations of `LocalOutput` were just `Arc<Mutex<..>>`. This simplifies some logic and removes all custom `Sink` implementations such as `library/test/src/helpers/sink.rs`. Also removes a layer of indirection, as the outermost `Box` is now gone. It also means that locking now happens per `write_fmt`, not per individual `write` within. (So `\"{} {}\\n\"` now results in one `lock()`, not four or more.)\n\n2. Since in all cases the `dyn Write`s were just `Vec<u8>`s, replace the type with `Arc<Mutex<Vec<u8>>>`. This simplifies things more, as error handling and flushing can be removed now. This also removes the hack needed in the default panic handler to make this work with `::realstd`, as (unlike `Write`) `Vec<u8>` is from `alloc`, not `std`.\n\n3. Replace the `RefCell`s by regular `Cell`s. The `RefCell`s were mostly used as `mem::replace(&mut *cell.borrow_mut(), something)`, which is just `Cell::replace`. This removes an unecessary bookkeeping and makes the code a bit easier to read.\n\n4. Merge `set_panic` and `set_print` into a single `set_output_capture`. Neither the test crate nor rustc (the only users of this feature) have a use for using these separately. Merging them simplifies things even more. This uses a new function name and feature name, to make it clearer this is internal and not supposed to be used by other crates.\n\nMight be easier to review per commit.", "tree": {"sha": "3e41668f4a7175b84954344be51fa87e5207fd09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e41668f4a7175b84954344be51fa87e5207fd09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11ce918c75b05d065ce3bf98b20d62465b5afc55", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfsqgzCRBK7hj4Ov3rIwAAdHIIAJFwOb5H4BDU54UxWA6E+9Mj\nkLpBR84vDTvcKwyMNjduvnsVo1Waair9pdYvXP4fbPgbkZvqpNDz71HxrFBlxnHz\nt0jAc2DDmxrUjurkEtiHmXjQOTOMF+JZ+dk7sub3BRDcIKzSabGExHvO9DbywTxQ\ngZzKEjxiLy9Q50SnwA2gs1zUnnhoxFPOUUiS9kOphUpP+QKicXzst+Ls7YNYq0d/\nZ5IUSOGBvZTEF3bLgMfiId9MgJtk99rccR4AJzs4+G2w6HJcGVDLwx03eiy5f6Fp\nwLlUOApYPNtm3A9Qn/bZztoiq8U0ILkL4xM5Q7ydDMCeQU4wLQEtfKlSX16nfgs=\n=dPpc\n-----END PGP SIGNATURE-----\n", "payload": "tree 3e41668f4a7175b84954344be51fa87e5207fd09\nparent 7a1bd805fa50d1fd3f7a4459038819b748424ab9\nparent aff7bd66e8b97a41d34c221007e12e4bbe535322\nauthor Mara Bos <m-ou.se@m-ou.se> 1605543987 +0100\ncommitter GitHub <noreply@github.com> 1605543987 +0100\n\nRollup merge of #78714 - m-ou-se:simplify-local-streams, r=KodrAus\n\nSimplify output capturing\n\nThis is a sequence of incremental improvements to the unstable/internal `set_panic` and `set_print` mechanism used by the `test` crate:\n\n1. Remove the `LocalOutput` trait and use `Arc<Mutex<dyn Write>>` instead of `Box<dyn LocalOutput>`. In practice, all implementations of `LocalOutput` were just `Arc<Mutex<..>>`. This simplifies some logic and removes all custom `Sink` implementations such as `library/test/src/helpers/sink.rs`. Also removes a layer of indirection, as the outermost `Box` is now gone. It also means that locking now happens per `write_fmt`, not per individual `write` within. (So `\"{} {}\\n\"` now results in one `lock()`, not four or more.)\n\n2. Since in all cases the `dyn Write`s were just `Vec<u8>`s, replace the type with `Arc<Mutex<Vec<u8>>>`. This simplifies things more, as error handling and flushing can be removed now. This also removes the hack needed in the default panic handler to make this work with `::realstd`, as (unlike `Write`) `Vec<u8>` is from `alloc`, not `std`.\n\n3. Replace the `RefCell`s by regular `Cell`s. The `RefCell`s were mostly used as `mem::replace(&mut *cell.borrow_mut(), something)`, which is just `Cell::replace`. This removes an unecessary bookkeeping and makes the code a bit easier to read.\n\n4. Merge `set_panic` and `set_print` into a single `set_output_capture`. Neither the test crate nor rustc (the only users of this feature) have a use for using these separately. Merging them simplifies things even more. This uses a new function name and feature name, to make it clearer this is internal and not supposed to be used by other crates.\n\nMight be easier to review per commit.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11ce918c75b05d065ce3bf98b20d62465b5afc55", "html_url": "https://github.com/rust-lang/rust/commit/11ce918c75b05d065ce3bf98b20d62465b5afc55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11ce918c75b05d065ce3bf98b20d62465b5afc55/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a1bd805fa50d1fd3f7a4459038819b748424ab9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a1bd805fa50d1fd3f7a4459038819b748424ab9", "html_url": "https://github.com/rust-lang/rust/commit/7a1bd805fa50d1fd3f7a4459038819b748424ab9"}, {"sha": "aff7bd66e8b97a41d34c221007e12e4bbe535322", "url": "https://api.github.com/repos/rust-lang/rust/commits/aff7bd66e8b97a41d34c221007e12e4bbe535322", "html_url": "https://github.com/rust-lang/rust/commit/aff7bd66e8b97a41d34c221007e12e4bbe535322"}], "stats": {"total": 375, "additions": 85, "deletions": 290}, "files": [{"sha": "0935eb2bd7199cad3d5810684c37767d23993aea", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ce918c75b05d065ce3bf98b20d62465b5afc55/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ce918c75b05d065ce3bf98b20d62465b5afc55/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=11ce918c75b05d065ce3bf98b20d62465b5afc55", "patch": "@@ -1,6 +1,6 @@\n #![feature(bool_to_option)]\n #![feature(box_syntax)]\n-#![feature(set_stdio)]\n+#![feature(internal_output_capture)]\n #![feature(nll)]\n #![feature(generator_trait)]\n #![feature(generators)]"}, {"sha": "20a7b47313ecf5d08e4bf16eb9b01acd260370c1", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/11ce918c75b05d065ce3bf98b20d62465b5afc55/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ce918c75b05d065ce3bf98b20d62465b5afc55/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=11ce918c75b05d065ce3bf98b20d62465b5afc55", "patch": "@@ -25,7 +25,7 @@ use rustc_span::symbol::{sym, Symbol};\n use smallvec::SmallVec;\n use std::env;\n use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n-use std::io::{self, Write};\n+use std::io;\n use std::lazy::SyncOnceCell;\n use std::mem;\n use std::ops::DerefMut;\n@@ -106,21 +106,6 @@ fn get_stack_size() -> Option<usize> {\n     env::var_os(\"RUST_MIN_STACK\").is_none().then_some(STACK_SIZE)\n }\n \n-struct Sink(Arc<Mutex<Vec<u8>>>);\n-impl Write for Sink {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Write::write(&mut *self.0.lock().unwrap(), data)\n-    }\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-impl io::LocalOutput for Sink {\n-    fn clone_box(&self) -> Box<dyn io::LocalOutput> {\n-        Box::new(Self(self.0.clone()))\n-    }\n-}\n-\n /// Like a `thread::Builder::spawn` followed by a `join()`, but avoids the need\n /// for `'static` bounds.\n #[cfg(not(parallel_compiler))]\n@@ -163,9 +148,7 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n \n     let main_handler = move || {\n         rustc_span::with_session_globals(edition, || {\n-            if let Some(stderr) = stderr {\n-                io::set_panic(Some(box Sink(stderr.clone())));\n-            }\n+            io::set_output_capture(stderr.clone());\n             f()\n         })\n     };\n@@ -203,9 +186,7 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n             // on the new threads.\n             let main_handler = move |thread: rayon::ThreadBuilder| {\n                 rustc_span::SESSION_GLOBALS.set(session_globals, || {\n-                    if let Some(stderr) = stderr {\n-                        io::set_panic(Some(box Sink(stderr.clone())));\n-                    }\n+                    io::set_output_capture(stderr.clone());\n                     thread.run()\n                 })\n             };"}, {"sha": "6b3c86cb0df87ae176a17ecc30841279ed8aa241", "filename": "library/std/src/io/impls.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs?ref=11ce918c75b05d065ce3bf98b20d62465b5afc55", "patch": "@@ -209,20 +209,6 @@ impl<B: BufRead + ?Sized> BufRead for Box<B> {\n     }\n }\n \n-// Used by panicking::default_hook\n-#[cfg(test)]\n-/// This impl is only used by printing logic, so any error returned is always\n-/// of kind `Other`, and should be ignored.\n-impl Write for dyn ::realstd::io::LocalOutput {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        (*self).write(buf).map_err(|_| ErrorKind::Other.into())\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        (*self).flush().map_err(|_| ErrorKind::Other.into())\n-    }\n-}\n-\n // =============================================================================\n // In-memory buffer implementations\n "}, {"sha": "703c3755b63836212a841a20b2b949e4e24d307b", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=11ce918c75b05d065ce3bf98b20d62465b5afc55", "patch": "@@ -271,20 +271,18 @@ pub use self::copy::copy;\n pub use self::cursor::Cursor;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::error::{Error, ErrorKind, Result};\n+#[unstable(feature = \"internal_output_capture\", issue = \"none\")]\n+#[doc(no_inline, hidden)]\n+pub use self::stdio::set_output_capture;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::stdio::{stderr, stdin, stdout, Stderr, Stdin, Stdout};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::stdio::{StderrLock, StdinLock, StdoutLock};\n #[unstable(feature = \"print_internals\", issue = \"none\")]\n pub use self::stdio::{_eprint, _print};\n-#[unstable(feature = \"libstd_io_internals\", issue = \"42788\")]\n-#[doc(no_inline, hidden)]\n-pub use self::stdio::{set_panic, set_print, LocalOutput};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::util::{empty, repeat, sink, Empty, Repeat, Sink};\n \n-pub(crate) use self::stdio::clone_io;\n-\n mod buffered;\n pub(crate) mod copy;\n mod cursor;"}, {"sha": "6ea7704d42213463305f877536beff97859c899d", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 44, "deletions": 133, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=11ce918c75b05d065ce3bf98b20d62465b5afc55", "patch": "@@ -5,44 +5,38 @@ mod tests;\n \n use crate::io::prelude::*;\n \n-use crate::cell::RefCell;\n+use crate::cell::{Cell, RefCell};\n use crate::fmt;\n use crate::io::{self, BufReader, Initializer, IoSlice, IoSliceMut, LineWriter};\n use crate::lazy::SyncOnceCell;\n use crate::sync::atomic::{AtomicBool, Ordering};\n-use crate::sync::{Mutex, MutexGuard};\n+use crate::sync::{Arc, Mutex, MutexGuard};\n use crate::sys::stdio;\n use crate::sys_common;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n-use crate::thread::LocalKey;\n \n-thread_local! {\n-    /// Used by the test crate to capture the output of the print! and println! macros.\n-    static LOCAL_STDOUT: RefCell<Option<Box<dyn LocalOutput>>> = {\n-        RefCell::new(None)\n-    }\n-}\n+type LocalStream = Arc<Mutex<Vec<u8>>>;\n \n thread_local! {\n-    /// Used by the test crate to capture the output of the eprint! and eprintln! macros, and panics.\n-    static LOCAL_STDERR: RefCell<Option<Box<dyn LocalOutput>>> = {\n-        RefCell::new(None)\n+    /// Used by the test crate to capture the output of the print macros and panics.\n+    static OUTPUT_CAPTURE: Cell<Option<LocalStream>> = {\n+        Cell::new(None)\n     }\n }\n \n-/// Flag to indicate LOCAL_STDOUT and/or LOCAL_STDERR is used.\n+/// Flag to indicate OUTPUT_CAPTURE is used.\n ///\n-/// If both are None and were never set on any thread, this flag is set to\n-/// false, and both LOCAL_STDOUT and LOCAL_STDOUT can be safely ignored on all\n-/// threads, saving some time and memory registering an unused thread local.\n+/// If it is None and was never set on any thread, this flag is set to false,\n+/// and OUTPUT_CAPTURE can be safely ignored on all threads, saving some time\n+/// and memory registering an unused thread local.\n ///\n-/// Note about memory ordering: This contains information about whether two\n-/// thread local variables might be in use. Although this is a global flag, the\n+/// Note about memory ordering: This contains information about whether a\n+/// thread local variable might be in use. Although this is a global flag, the\n /// memory ordering between threads does not matter: we only want this flag to\n-/// have a consistent order between set_print/set_panic and print_to *within\n+/// have a consistent order between set_output_capture and print_to *within\n /// the same thread*. Within the same thread, things always have a perfectly\n /// consistent order. So Ordering::Relaxed is fine.\n-static LOCAL_STREAMS: AtomicBool = AtomicBool::new(false);\n+static OUTPUT_CAPTURE_USED: AtomicBool = AtomicBool::new(false);\n \n /// A handle to a raw instance of the standard input stream of this process.\n ///\n@@ -896,97 +890,24 @@ impl fmt::Debug for StderrLock<'_> {\n     }\n }\n \n-/// A writer than can be cloned to new threads.\n-#[unstable(\n-    feature = \"set_stdio\",\n-    reason = \"this trait may disappear completely or be replaced \\\n-                     with a more general mechanism\",\n-    issue = \"none\"\n-)]\n-#[doc(hidden)]\n-pub trait LocalOutput: Write + Send {\n-    fn clone_box(&self) -> Box<dyn LocalOutput>;\n-}\n-\n-/// Resets the thread-local stderr handle to the specified writer\n-///\n-/// This will replace the current thread's stderr handle, returning the old\n-/// handle. All future calls to `panic!` and friends will emit their output to\n-/// this specified handle.\n-///\n-/// Note that this does not need to be called for all new threads; the default\n-/// output handle is to the process's stderr stream.\n-#[unstable(\n-    feature = \"set_stdio\",\n-    reason = \"this function may disappear completely or be replaced \\\n-                     with a more general mechanism\",\n-    issue = \"none\"\n-)]\n-#[doc(hidden)]\n-pub fn set_panic(sink: Option<Box<dyn LocalOutput>>) -> Option<Box<dyn LocalOutput>> {\n-    use crate::mem;\n-    if sink.is_none() && !LOCAL_STREAMS.load(Ordering::Relaxed) {\n-        // LOCAL_STDERR is definitely None since LOCAL_STREAMS is false.\n-        return None;\n-    }\n-    let s = LOCAL_STDERR.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(\n-        |mut s| {\n-            let _ = s.flush();\n-            Some(s)\n-        },\n-    );\n-    LOCAL_STREAMS.store(true, Ordering::Relaxed);\n-    s\n-}\n-\n-/// Resets the thread-local stdout handle to the specified writer\n-///\n-/// This will replace the current thread's stdout handle, returning the old\n-/// handle. All future calls to `print!` and friends will emit their output to\n-/// this specified handle.\n-///\n-/// Note that this does not need to be called for all new threads; the default\n-/// output handle is to the process's stdout stream.\n+/// Sets the thread-local output capture buffer and returns the old one.\n #[unstable(\n-    feature = \"set_stdio\",\n-    reason = \"this function may disappear completely or be replaced \\\n-                     with a more general mechanism\",\n+    feature = \"internal_output_capture\",\n+    reason = \"this function is meant for use in the test crate \\\n+        and may disappear in the future\",\n     issue = \"none\"\n )]\n #[doc(hidden)]\n-pub fn set_print(sink: Option<Box<dyn LocalOutput>>) -> Option<Box<dyn LocalOutput>> {\n-    use crate::mem;\n-    if sink.is_none() && !LOCAL_STREAMS.load(Ordering::Relaxed) {\n-        // LOCAL_STDOUT is definitely None since LOCAL_STREAMS is false.\n+pub fn set_output_capture(sink: Option<LocalStream>) -> Option<LocalStream> {\n+    if sink.is_none() && !OUTPUT_CAPTURE_USED.load(Ordering::Relaxed) {\n+        // OUTPUT_CAPTURE is definitely None since OUTPUT_CAPTURE_USED is false.\n         return None;\n     }\n-    let s = LOCAL_STDOUT.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(\n-        |mut s| {\n-            let _ = s.flush();\n-            Some(s)\n-        },\n-    );\n-    LOCAL_STREAMS.store(true, Ordering::Relaxed);\n-    s\n-}\n-\n-pub(crate) fn clone_io() -> (Option<Box<dyn LocalOutput>>, Option<Box<dyn LocalOutput>>) {\n-    // Don't waste time when LOCAL_{STDOUT,STDERR} are definitely None.\n-    if !LOCAL_STREAMS.load(Ordering::Relaxed) {\n-        return (None, None);\n-    }\n-\n-    LOCAL_STDOUT.with(|stdout| {\n-        LOCAL_STDERR.with(|stderr| {\n-            (\n-                stdout.borrow().as_ref().map(|o| o.clone_box()),\n-                stderr.borrow().as_ref().map(|o| o.clone_box()),\n-            )\n-        })\n-    })\n+    OUTPUT_CAPTURE_USED.store(true, Ordering::Relaxed);\n+    OUTPUT_CAPTURE.with(move |slot| slot.replace(sink))\n }\n \n-/// Write `args` to output stream `local_s` if possible, `global_s`\n+/// Write `args` to the capture buffer if enabled and possible, or `global_s`\n /// otherwise. `label` identifies the stream in a panic message.\n ///\n /// This function is used to print error messages, so it takes extra\n@@ -996,36 +917,26 @@ pub(crate) fn clone_io() -> (Option<Box<dyn LocalOutput>>, Option<Box<dyn LocalO\n /// thread, it will just fall back to the global stream.\n ///\n /// However, if the actual I/O causes an error, this function does panic.\n-fn print_to<T>(\n-    args: fmt::Arguments<'_>,\n-    local_s: &'static LocalKey<RefCell<Option<Box<dyn LocalOutput>>>>,\n-    global_s: fn() -> T,\n-    label: &str,\n-) where\n+fn print_to<T>(args: fmt::Arguments<'_>, global_s: fn() -> T, label: &str)\n+where\n     T: Write,\n {\n-    let result = LOCAL_STREAMS\n-        .load(Ordering::Relaxed)\n-        .then(|| {\n-            local_s\n-                .try_with(|s| {\n-                    // Note that we completely remove a local sink to write to in case\n-                    // our printing recursively panics/prints, so the recursive\n-                    // panic/print goes to the global sink instead of our local sink.\n-                    let prev = s.borrow_mut().take();\n-                    if let Some(mut w) = prev {\n-                        let result = w.write_fmt(args);\n-                        *s.borrow_mut() = Some(w);\n-                        return result;\n-                    }\n-                    global_s().write_fmt(args)\n-                })\n-                .ok()\n-        })\n-        .flatten()\n-        .unwrap_or_else(|| global_s().write_fmt(args));\n-\n-    if let Err(e) = result {\n+    if OUTPUT_CAPTURE_USED.load(Ordering::Relaxed)\n+        && OUTPUT_CAPTURE.try_with(|s| {\n+            // Note that we completely remove a local sink to write to in case\n+            // our printing recursively panics/prints, so the recursive\n+            // panic/print goes to the global sink instead of our local sink.\n+            s.take().map(|w| {\n+                let _ = w.lock().unwrap_or_else(|e| e.into_inner()).write_fmt(args);\n+                s.set(Some(w));\n+            })\n+        }) == Ok(Some(()))\n+    {\n+        // Succesfully wrote to capture buffer.\n+        return;\n+    }\n+\n+    if let Err(e) = global_s().write_fmt(args) {\n         panic!(\"failed printing to {}: {}\", label, e);\n     }\n }\n@@ -1038,7 +949,7 @@ fn print_to<T>(\n #[doc(hidden)]\n #[cfg(not(test))]\n pub fn _print(args: fmt::Arguments<'_>) {\n-    print_to(args, &LOCAL_STDOUT, stdout, \"stdout\");\n+    print_to(args, stdout, \"stdout\");\n }\n \n #[unstable(\n@@ -1049,7 +960,7 @@ pub fn _print(args: fmt::Arguments<'_>) {\n #[doc(hidden)]\n #[cfg(not(test))]\n pub fn _eprint(args: fmt::Arguments<'_>) {\n-    print_to(args, &LOCAL_STDERR, stderr, \"stderr\");\n+    print_to(args, stderr, \"stderr\");\n }\n \n #[cfg(test)]"}, {"sha": "ac11fcf73295827d422e360bfaba1fcc1d791788", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=11ce918c75b05d065ce3bf98b20d62465b5afc55", "patch": "@@ -207,7 +207,7 @@\n // std may use features in a platform-specific way\n #![allow(unused_features)]\n #![cfg_attr(not(bootstrap), feature(rustc_allow_const_fn_unstable))]\n-#![cfg_attr(test, feature(print_internals, set_stdio, update_panic_count))]\n+#![cfg_attr(test, feature(internal_output_capture, print_internals, update_panic_count))]\n #![cfg_attr(\n     all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n     feature(slice_index_methods, coerce_unsized, sgx_platform)\n@@ -298,6 +298,7 @@\n #![feature(raw)]\n #![feature(raw_ref_macros)]\n #![feature(ready_macro)]\n+#![feature(refcell_take)]\n #![feature(rustc_attrs)]\n #![feature(rustc_private)]\n #![feature(shrink_to)]"}, {"sha": "8ba3feccb6bcc8f817efa43cd0b373124c27bcd8", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=11ce918c75b05d065ce3bf98b20d62465b5afc55", "patch": "@@ -24,11 +24,11 @@ use crate::sys_common::{thread_info, util};\n use crate::thread;\n \n #[cfg(not(test))]\n-use crate::io::set_panic;\n+use crate::io::set_output_capture;\n // make sure to use the stderr output configured\n // by libtest in the real copy of std\n #[cfg(test)]\n-use realstd::io::set_panic;\n+use realstd::io::set_output_capture;\n \n // Binary interface to the panic runtime that the standard library depends on.\n //\n@@ -218,11 +218,9 @@ fn default_hook(info: &PanicInfo<'_>) {\n         }\n     };\n \n-    if let Some(mut local) = set_panic(None) {\n-        // NB. In `cfg(test)` this uses the forwarding impl\n-        // for `dyn ::realstd::io::LocalOutput`.\n-        write(&mut local);\n-        set_panic(Some(local));\n+    if let Some(local) = set_output_capture(None) {\n+        write(&mut *local.lock().unwrap_or_else(|e| e.into_inner()));\n+        set_output_capture(Some(local));\n     } else if let Some(mut out) = panic_output() {\n         write(&mut out);\n     }"}, {"sha": "5d65f960fcd391eb14c66077bcc48de18a8a2292", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=11ce918c75b05d065ce3bf98b20d62465b5afc55", "patch": "@@ -456,15 +456,15 @@ impl Builder {\n         let my_packet: Arc<UnsafeCell<Option<Result<T>>>> = Arc::new(UnsafeCell::new(None));\n         let their_packet = my_packet.clone();\n \n-        let (stdout, stderr) = crate::io::clone_io();\n+        let output_capture = crate::io::set_output_capture(None);\n+        crate::io::set_output_capture(output_capture.clone());\n \n         let main = move || {\n             if let Some(name) = their_thread.cname() {\n                 imp::Thread::set_name(name);\n             }\n \n-            crate::io::set_print(stdout);\n-            crate::io::set_panic(stderr);\n+            crate::io::set_output_capture(output_capture);\n \n             // SAFETY: the stack guard passed is the one for the current thread.\n             // This means the current thread's stack and the new thread's stack"}, {"sha": "d4b37284ea7749e903988d6e40ee52701316426c", "filename": "library/test/src/bench.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Ftest%2Fsrc%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Ftest%2Fsrc%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fbench.rs?ref=11ce918c75b05d065ce3bf98b20d62465b5afc55", "patch": "@@ -2,8 +2,7 @@\n pub use std::hint::black_box;\n \n use super::{\n-    event::CompletedTest, helpers::sink::Sink, options::BenchMode, test_result::TestResult,\n-    types::TestDesc, Sender,\n+    event::CompletedTest, options::BenchMode, test_result::TestResult, types::TestDesc, Sender,\n };\n \n use crate::stats;\n@@ -185,21 +184,14 @@ where\n     let mut bs = Bencher { mode: BenchMode::Auto, summary: None, bytes: 0 };\n \n     let data = Arc::new(Mutex::new(Vec::new()));\n-    let oldio = if !nocapture {\n-        Some((\n-            io::set_print(Some(Sink::new_boxed(&data))),\n-            io::set_panic(Some(Sink::new_boxed(&data))),\n-        ))\n-    } else {\n-        None\n-    };\n+\n+    if !nocapture {\n+        io::set_output_capture(Some(data.clone()));\n+    }\n \n     let result = catch_unwind(AssertUnwindSafe(|| bs.bench(f)));\n \n-    if let Some((printio, panicio)) = oldio {\n-        io::set_print(printio);\n-        io::set_panic(panicio);\n-    }\n+    io::set_output_capture(None);\n \n     let test_result = match result {\n         //bs.bench(f) {"}, {"sha": "b7f00c4c86cdf27f61416b98c5461276989ee80e", "filename": "library/test/src/helpers/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Ftest%2Fsrc%2Fhelpers%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Ftest%2Fsrc%2Fhelpers%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fhelpers%2Fmod.rs?ref=11ce918c75b05d065ce3bf98b20d62465b5afc55", "patch": "@@ -5,4 +5,3 @@ pub mod concurrency;\n pub mod exit_code;\n pub mod isatty;\n pub mod metrics;\n-pub mod sink;"}, {"sha": "dfbf0a3b72f54cd9d4f744ba937a27b98ce39616", "filename": "library/test/src/helpers/sink.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7a1bd805fa50d1fd3f7a4459038819b748424ab9/library%2Ftest%2Fsrc%2Fhelpers%2Fsink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1bd805fa50d1fd3f7a4459038819b748424ab9/library%2Ftest%2Fsrc%2Fhelpers%2Fsink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fhelpers%2Fsink.rs?ref=7a1bd805fa50d1fd3f7a4459038819b748424ab9", "patch": "@@ -1,31 +0,0 @@\n-//! Module providing a helper structure to capture output in subprocesses.\n-\n-use std::{\n-    io,\n-    io::prelude::Write,\n-    sync::{Arc, Mutex},\n-};\n-\n-#[derive(Clone)]\n-pub struct Sink(Arc<Mutex<Vec<u8>>>);\n-\n-impl Sink {\n-    pub fn new_boxed(data: &Arc<Mutex<Vec<u8>>>) -> Box<Self> {\n-        Box::new(Self(data.clone()))\n-    }\n-}\n-\n-impl io::LocalOutput for Sink {\n-    fn clone_box(&self) -> Box<dyn io::LocalOutput> {\n-        Box::new(self.clone())\n-    }\n-}\n-\n-impl Write for Sink {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Write::write(&mut *self.0.lock().unwrap(), data)\n-    }\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}"}, {"sha": "816b4d51188034cf97afea7097942b04df5113f5", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ce918c75b05d065ce3bf98b20d62465b5afc55/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=11ce918c75b05d065ce3bf98b20d62465b5afc55", "patch": "@@ -25,7 +25,7 @@\n #![feature(nll)]\n #![feature(bool_to_option)]\n #![feature(available_concurrency)]\n-#![feature(set_stdio)]\n+#![feature(internal_output_capture)]\n #![feature(panic_unwind)]\n #![feature(staged_api)]\n #![feature(termination_trait_lib)]\n@@ -89,7 +89,6 @@ mod tests;\n use event::{CompletedTest, TestEvent};\n use helpers::concurrency::get_concurrency;\n use helpers::exit_code::get_exit_code;\n-use helpers::sink::Sink;\n use options::{Concurrent, RunStrategy};\n use test_result::*;\n use time::TestExecTime;\n@@ -531,14 +530,9 @@ fn run_test_in_process(\n     // Buffer for capturing standard I/O\n     let data = Arc::new(Mutex::new(Vec::new()));\n \n-    let oldio = if !nocapture {\n-        Some((\n-            io::set_print(Some(Sink::new_boxed(&data))),\n-            io::set_panic(Some(Sink::new_boxed(&data))),\n-        ))\n-    } else {\n-        None\n-    };\n+    if !nocapture {\n+        io::set_output_capture(Some(data.clone()));\n+    }\n \n     let start = report_time.then(Instant::now);\n     let result = catch_unwind(AssertUnwindSafe(testfn));\n@@ -547,16 +541,13 @@ fn run_test_in_process(\n         TestExecTime(duration)\n     });\n \n-    if let Some((printio, panicio)) = oldio {\n-        io::set_print(printio);\n-        io::set_panic(panicio);\n-    }\n+    io::set_output_capture(None);\n \n     let test_result = match result {\n         Ok(()) => calc_result(&desc, Ok(()), &time_opts, &exec_time),\n         Err(e) => calc_result(&desc, Err(e.as_ref()), &time_opts, &exec_time),\n     };\n-    let stdout = data.lock().unwrap().to_vec();\n+    let stdout = data.lock().unwrap_or_else(|e| e.into_inner()).to_vec();\n     let message = CompletedTest::new(desc, test_result, exec_time, stdout);\n     monitor_ch.send(message).unwrap();\n }"}, {"sha": "7e1241fce985aa2f8544a5eca0ad8795155964b3", "filename": "src/doc/unstable-book/src/library-features/internal-output-capture.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ce918c75b05d065ce3bf98b20d62465b5afc55/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finternal-output-capture.md", "raw_url": "https://github.com/rust-lang/rust/raw/11ce918c75b05d065ce3bf98b20d62465b5afc55/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finternal-output-capture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finternal-output-capture.md?ref=11ce918c75b05d065ce3bf98b20d62465b5afc55", "patch": "@@ -1,4 +1,4 @@\n-# `libstd_io_internals`\n+# `internal_output_capture`\n \n This feature is internal to the Rust compiler and is not intended for general use.\n ", "previous_filename": "src/doc/unstable-book/src/library-features/libstd-io-internals.md"}, {"sha": "7dbdcdaa1a2ff21816e4c7b8a255667b20458057", "filename": "src/doc/unstable-book/src/library-features/set-stdio.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a1bd805fa50d1fd3f7a4459038819b748424ab9/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fset-stdio.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a1bd805fa50d1fd3f7a4459038819b748424ab9/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fset-stdio.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fset-stdio.md?ref=7a1bd805fa50d1fd3f7a4459038819b748424ab9", "patch": "@@ -1,5 +0,0 @@\n-# `set_stdio`\n-\n-This feature is internal to the Rust compiler and is not intended for general use.\n-\n-------------------------"}, {"sha": "96b35e45535a6a4851aa1f032711262f4337fb60", "filename": "src/test/ui/panic-while-printing.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/11ce918c75b05d065ce3bf98b20d62465b5afc55/src%2Ftest%2Fui%2Fpanic-while-printing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ce918c75b05d065ce3bf98b20d62465b5afc55/src%2Ftest%2Fui%2Fpanic-while-printing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-while-printing.rs?ref=11ce918c75b05d065ce3bf98b20d62465b5afc55", "patch": "@@ -1,11 +1,12 @@\n // run-pass\n // ignore-emscripten no subprocess support\n \n-#![feature(set_stdio)]\n+#![feature(internal_output_capture)]\n \n use std::fmt;\n use std::fmt::{Display, Formatter};\n-use std::io::{self, set_panic, LocalOutput, Write};\n+use std::io::set_output_capture;\n+use std::sync::{Arc, Mutex};\n \n pub struct A;\n \n@@ -15,23 +16,8 @@ impl Display for A {\n     }\n }\n \n-struct Sink;\n-impl Write for Sink {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        Ok(buf.len())\n-    }\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-impl LocalOutput for Sink {\n-    fn clone_box(&self) -> Box<dyn LocalOutput> {\n-        Box::new(Sink)\n-    }\n-}\n-\n fn main() {\n-    set_panic(Some(Box::new(Sink)));\n+    set_output_capture(Some(Arc::new(Mutex::new(Vec::new()))));\n     assert!(std::panic::catch_unwind(|| {\n         eprintln!(\"{}\", A);\n     })"}, {"sha": "78145e337dafbc5c91c82eaf15110f9b44388060", "filename": "src/test/ui/threads-sendsync/task-stderr.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/11ce918c75b05d065ce3bf98b20d62465b5afc55/src%2Ftest%2Fui%2Fthreads-sendsync%2Ftask-stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ce918c75b05d065ce3bf98b20d62465b5afc55/src%2Ftest%2Fui%2Fthreads-sendsync%2Ftask-stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fthreads-sendsync%2Ftask-stderr.rs?ref=11ce918c75b05d065ce3bf98b20d62465b5afc55", "patch": "@@ -1,33 +1,21 @@\n // run-pass\n // ignore-emscripten no threads support\n \n-#![feature(box_syntax, set_stdio)]\n+#![feature(internal_output_capture)]\n \n-use std::io::prelude::*;\n use std::io;\n use std::str;\n use std::sync::{Arc, Mutex};\n use std::thread;\n \n-struct Sink(Arc<Mutex<Vec<u8>>>);\n-impl Write for Sink {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Write::write(&mut *self.0.lock().unwrap(), data)\n-    }\n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n-}\n-impl io::LocalOutput for Sink {\n-    fn clone_box(&self) -> Box<dyn io::LocalOutput> {\n-        Box::new(Sink(self.0.clone()))\n-    }\n-}\n-\n fn main() {\n     let data = Arc::new(Mutex::new(Vec::new()));\n-    let sink = Sink(data.clone());\n-    let res = thread::Builder::new().spawn(move|| -> () {\n-        io::set_panic(Some(Box::new(sink)));\n-        panic!(\"Hello, world!\")\n+    let res = thread::Builder::new().spawn({\n+        let data = data.clone();\n+        move || {\n+            io::set_output_capture(Some(data));\n+            panic!(\"Hello, world!\")\n+        }\n     }).unwrap().join();\n     assert!(res.is_err());\n "}]}