{"sha": "df53a3fd55a233cc04ce20d448f64ec70b937b06", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNTNhM2ZkNTVhMjMzY2MwNGNlMjBkNDQ4ZjY0ZWM3MGI5MzdiMDY=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2019-07-04T09:11:15Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2019-07-08T07:34:25Z"}, "message": "Add documentation to float conversion methods", "tree": {"sha": "1bcf36cef776e86f7210f273eaa7fc989362ff23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bcf36cef776e86f7210f273eaa7fc989362ff23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df53a3fd55a233cc04ce20d448f64ec70b937b06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df53a3fd55a233cc04ce20d448f64ec70b937b06", "html_url": "https://github.com/rust-lang/rust/commit/df53a3fd55a233cc04ce20d448f64ec70b937b06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df53a3fd55a233cc04ce20d448f64ec70b937b06/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad47f0874a8161ad0b31d0e8c0d94f39766183d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad47f0874a8161ad0b31d0e8c0d94f39766183d3", "html_url": "https://github.com/rust-lang/rust/commit/ad47f0874a8161ad0b31d0e8c0d94f39766183d3"}], "stats": {"total": 164, "additions": 144, "deletions": 20}, "files": [{"sha": "fc2c431ca0f9ccc00311782ff93798ffbc602ac6", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 62, "deletions": 17, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/df53a3fd55a233cc04ce20d448f64ec70b937b06/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df53a3fd55a233cc04ce20d448f64ec70b937b06/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=df53a3fd55a233cc04ce20d448f64ec70b937b06", "patch": "@@ -450,10 +450,8 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::f32;\n     /// let v = f32::from_bits(0x41480000);\n-    /// let difference = (v - 12.5).abs();\n-    /// assert!(difference <= 1e-5);\n+    /// assert_eq!(v, 12.5);\n     /// ```\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n@@ -462,50 +460,59 @@ impl f32 {\n         unsafe { mem::transmute(v) }\n     }\n \n-    /// Return the floating point value as a byte array in big-endian byte order.\n+    /// Return the memory representation of this floating point number as a byte array in\n+    /// big-endian (network) byte order.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// assert_eq!(0.0f32.to_be_bytes(), [0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000]);\n-    /// assert_eq!(1.0f32.to_be_bytes(), [0b0111_1111, 0b1000_0000, 0b0000_0000, 0b0000_0000]);\n+    /// #![feature(float_to_from_bytes)]\n+    /// let bytes = 12.5f32.to_be_bytes();\n+    /// assert_eq!(bytes, [0x41, 0x48, 0x00, 0x00]);\n     /// ```\n     #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n     #[inline]\n     pub fn to_be_bytes(self) -> [u8; 4] {\n         self.to_bits().to_be_bytes()\n     }\n \n-    /// Return the floating point value as a byte array in little-endian byte order.\n+    /// Return the memory representation of this floating point number as a byte array in\n+    /// little-endian byte order.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// assert_eq!(0.0f32.to_le_bytes(), [0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000]);\n-    /// assert_eq!(1.0f32.to_le_bytes(), [0b0000_0000, 0b0000_0000, 0b1000_0000, 0b0111_1111]);\n+    /// #![feature(float_to_from_bytes)]\n+    /// let bytes = 12.5f32.to_le_bytes();\n+    /// assert_eq!(bytes, [0x00, 0x00, 0x48, 0x41]);\n     /// ```\n     #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n     #[inline]\n     pub fn to_le_bytes(self) -> [u8; 4] {\n         self.to_bits().to_le_bytes()\n     }\n \n-    /// Return the floating point value as a byte array in native byte order.\n-    ///\n+    /// Return the memory representation of this floating point number as a byte array in\n+    /// native byte order.\n     ///\n     /// As the target platform's native endianness is used, portable code\n     /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate, instead.\n     ///\n+    /// [`to_be_bytes`]: #method.to_be_bytes\n+    /// [`to_le_bytes`]: #method.to_le_bytes\n+    ///\n     /// # Examples\n     ///\n     /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let bytes = 12.5f32.to_ne_bytes();\n     /// assert_eq!(\n-    ///     u32::from_ne_bytes(0.0f32.to_ne_bytes()),\n-    ///     0b0000_0000_0000_0000_0000_0000_0000_0000,\n-    /// );\n-    /// assert_eq!(\n-    ///     u32::from_ne_bytes(1.0f32.to_ne_bytes()),\n-    ///     0b0111_1111_1000_0000_0000_0000_0000_0000,\n+    ///     bytes,\n+    ///     if cfg!(target_endian = \"big\") {\n+    ///         [0x41, 0x48, 0x00, 0x00]\n+    ///     } else {\n+    ///         [0x00, 0x00, 0x48, 0x41]\n+    ///     }\n     /// );\n     /// ```\n     #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n@@ -514,18 +521,56 @@ impl f32 {\n         self.to_bits().to_ne_bytes()\n     }\n \n+    /// Create a floating point value from its representation as a byte array in big endian.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let value = f32::from_be_bytes([0x41, 0x48, 0x00, 0x00]);\n+    /// assert_eq!(value, 12.5);\n+    /// ```\n     #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n     #[inline]\n     pub fn from_be_bytes(bytes: [u8; 4]) -> Self {\n         Self::from_bits(u32::from_be_bytes(bytes))\n     }\n \n+    /// Create a floating point value from its representation as a byte array in big endian.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let value = f32::from_le_bytes([0x00, 0x00, 0x48, 0x41]);\n+    /// assert_eq!(value, 12.5);\n+    /// ```\n     #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n     #[inline]\n     pub fn from_le_bytes(bytes: [u8; 4]) -> Self {\n         Self::from_bits(u32::from_le_bytes(bytes))\n     }\n \n+    /// Create a floating point value from its representation as a byte array in big endian.\n+    ///\n+    /// As the target platform's native endianness is used, portable code\n+    /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n+    /// appropriate instead.\n+    ///\n+    /// [`from_be_bytes`]: #method.from_be_bytes\n+    /// [`from_le_bytes`]: #method.from_le_bytes\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let value = f32::from_ne_bytes(if cfg!(target_endian = \"big\") {\n+    ///     [0x41, 0x48, 0x00, 0x00]\n+    /// } else {\n+    ///     [0x00, 0x00, 0x48, 0x41]\n+    /// });\n+    /// assert_eq!(value, 12.5);\n+    /// ```\n     #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n     #[inline]\n     pub fn from_ne_bytes(bytes: [u8; 4]) -> Self {"}, {"sha": "6bd0b6e5c7f77de785f9237db7b7a83ecce82856", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 82, "deletions": 3, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/df53a3fd55a233cc04ce20d448f64ec70b937b06/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df53a3fd55a233cc04ce20d448f64ec70b937b06/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=df53a3fd55a233cc04ce20d448f64ec70b937b06", "patch": "@@ -463,10 +463,8 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::f64;\n     /// let v = f64::from_bits(0x4029000000000000);\n-    /// let difference = (v - 12.5).abs();\n-    /// assert!(difference <= 1e-5);\n+    /// assert_eq!(v, 12.5);\n     /// ```\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n@@ -475,36 +473,117 @@ impl f64 {\n         unsafe { mem::transmute(v) }\n     }\n \n+    /// Return the memory representation of this floating point number as a byte array in\n+    /// big-endian (network) byte order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let bytes = 12.5f64.to_be_bytes();\n+    /// assert_eq!(bytes, [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n+    /// ```\n     #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n     #[inline]\n     pub fn to_be_bytes(self) -> [u8; 8] {\n         self.to_bits().to_be_bytes()\n     }\n \n+    /// Return the memory representation of this floating point number as a byte array in\n+    /// little-endian byte order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let bytes = 12.5f64.to_le_bytes();\n+    /// assert_eq!(bytes, [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]);\n+    /// ```\n     #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n     #[inline]\n     pub fn to_le_bytes(self) -> [u8; 8] {\n         self.to_bits().to_le_bytes()\n     }\n \n+    /// Return the memory representation of this floating point number as a byte array in\n+    /// native byte order.\n+    ///\n+    /// As the target platform's native endianness is used, portable code\n+    /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate, instead.\n+    ///\n+    /// [`to_be_bytes`]: #method.to_be_bytes\n+    /// [`to_le_bytes`]: #method.to_le_bytes\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let bytes = 12.5f64.to_ne_bytes();\n+    /// assert_eq!(\n+    ///     bytes,\n+    ///     if cfg!(target_endian = \"big\") {\n+    ///         [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n+    ///     } else {\n+    ///         [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]\n+    ///     }\n+    /// );\n+    /// ```\n     #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n     #[inline]\n     pub fn to_ne_bytes(self) -> [u8; 8] {\n         self.to_bits().to_ne_bytes()\n     }\n \n+    /// Create a floating point value from its representation as a byte array in big endian.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let value = f64::from_be_bytes([0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n+    /// assert_eq!(value, 12.5);\n+    /// ```\n     #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n     #[inline]\n     pub fn from_be_bytes(bytes: [u8; 8]) -> Self {\n         Self::from_bits(u64::from_be_bytes(bytes))\n     }\n \n+    /// Create a floating point value from its representation as a byte array in big endian.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let value = f64::from_le_bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]);\n+    /// assert_eq!(value, 12.5);\n+    /// ```\n     #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n     #[inline]\n     pub fn from_le_bytes(bytes: [u8; 8]) -> Self {\n         Self::from_bits(u64::from_le_bytes(bytes))\n     }\n \n+    /// Create a floating point value from its representation as a byte array in big endian.\n+    ///\n+    /// As the target platform's native endianness is used, portable code\n+    /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n+    /// appropriate instead.\n+    ///\n+    /// [`from_be_bytes`]: #method.from_be_bytes\n+    /// [`from_le_bytes`]: #method.from_le_bytes\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let value = f64::from_ne_bytes(if cfg!(target_endian = \"big\") {\n+    ///     [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n+    /// } else {\n+    ///     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]\n+    /// });\n+    /// assert_eq!(value, 12.5);\n+    /// ```\n     #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n     #[inline]\n     pub fn from_ne_bytes(bytes: [u8; 8]) -> Self {"}]}