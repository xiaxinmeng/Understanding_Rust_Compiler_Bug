{"sha": "06eb9765fec87dc66e17c97f667e30e6726d133e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ZWI5NzY1ZmVjODdkYzY2ZTE3Yzk3ZjY2N2UzMGU2NzI2ZDEzM2U=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-21T23:41:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-21T23:41:58Z"}, "message": "rustdoc: Show types for traits across crates\n\nRight now, when you look in the \"Implementors\" section for traits, you only see\nimplementors within that crate. This commit modifies that section to include\nimplementors from neighboring crates as well.\n\nFor example, the Container trait currently says that it is only implemented by\nstrings and slices, but it is in fact implemented by nearly all containers.\n\nImplementation-wise, this change generates an \"implementors cache\" similarly to\nthe search index where each crate will append implementors to the files. When\nthe page for a trait is loaded, it will load its specific cache file, rendering\nlinks for all upstream types which implement the trait.", "tree": {"sha": "99550eb190e397ee39d5be42011816578d83a3ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99550eb190e397ee39d5be42011816578d83a3ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06eb9765fec87dc66e17c97f667e30e6726d133e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06eb9765fec87dc66e17c97f667e30e6726d133e", "html_url": "https://github.com/rust-lang/rust/commit/06eb9765fec87dc66e17c97f667e30e6726d133e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06eb9765fec87dc66e17c97f667e30e6726d133e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1edb0e536433056738b7f715dd02ff1de582f2ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/1edb0e536433056738b7f715dd02ff1de582f2ba", "html_url": "https://github.com/rust-lang/rust/commit/1edb0e536433056738b7f715dd02ff1de582f2ba"}], "stats": {"total": 135, "additions": 113, "deletions": 22}, "files": [{"sha": "ed6c25c7c8008863d5ff29c9831e282e2d16ecac", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 91, "deletions": 22, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/06eb9765fec87dc66e17c97f667e30e6726d133e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06eb9765fec87dc66e17c97f667e30e6726d133e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=06eb9765fec87dc66e17c97f667e30e6726d133e", "patch": "@@ -150,7 +150,10 @@ pub struct Cache {\n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n     /// of trait ids to the list of known implementors of the trait\n-    pub implementors: HashMap<ast::NodeId, Vec<Implementor> >,\n+    pub implementors: HashMap<ast::NodeId, Vec<Implementor>>,\n+\n+    /// Implementations of external traits, keyed by the external trait def id.\n+    pub foreign_implementors: HashMap<ast::DefId, Vec<Implementor>>,\n \n     /// Cache of where external crate documentation can be found.\n     pub extern_locations: HashMap<ast::CrateNum, ExternalLocation>,\n@@ -268,6 +271,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         paths: paths,\n         traits: HashMap::new(),\n         implementors: HashMap::new(),\n+        foreign_implementors: HashMap::new(),\n         stack: Vec::new(),\n         parent_stack: Vec::new(),\n         search_index: Vec::new(),\n@@ -396,26 +400,84 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         try!(write(cx.dst.join(\"Heuristica-Bold.woff\"),\n                    include_bin!(\"static/Heuristica-Bold.woff\")));\n \n-        // Update the search index\n-        let dst = cx.dst.join(\"search-index.js\");\n-        let mut all_indexes = Vec::new();\n-        all_indexes.push(index);\n-        if dst.exists() {\n-            for line in BufferedReader::new(File::open(&dst)).lines() {\n-                let line = try!(line);\n-                if !line.starts_with(\"searchIndex\") { continue }\n-                if line.starts_with(format!(\"searchIndex['{}']\", krate.name)) {\n-                    continue\n+        fn collect(path: &Path, krate: &str,\n+                   key: &str) -> io::IoResult<Vec<StrBuf>> {\n+            let mut ret = Vec::new();\n+            if path.exists() {\n+                for line in BufferedReader::new(File::open(path)).lines() {\n+                    let line = try!(line);\n+                    if !line.starts_with(key) { continue }\n+                    if line.starts_with(format!(\"{}['{}']\", key, krate)) {\n+                        continue\n+                    }\n+                    ret.push(line.to_strbuf());\n                 }\n-                all_indexes.push(line);\n             }\n+            return Ok(ret);\n         }\n+\n+        // Update the search index\n+        let dst = cx.dst.join(\"search-index.js\");\n+        let all_indexes = try!(collect(&dst, krate.name.as_slice(),\n+                                       \"searchIndex\"));\n         let mut w = try!(File::create(&dst));\n         try!(writeln!(&mut w, r\"var searchIndex = \\{\\};\"));\n+        try!(writeln!(&mut w, \"{}\", index));\n         for index in all_indexes.iter() {\n             try!(writeln!(&mut w, \"{}\", *index));\n         }\n         try!(writeln!(&mut w, \"initSearch(searchIndex);\"));\n+\n+        // Update the list of all implementors for traits\n+        let dst = cx.dst.join(\"implementors\");\n+        try!(mkdir(&dst));\n+        for (&did, imps) in cache.foreign_implementors.iter() {\n+            let &(ref remote_path, remote_item_type) = cache.paths.get(&did);\n+\n+            let mut mydst = dst.clone();\n+            for part in remote_path.slice_to(remote_path.len() - 1).iter() {\n+                mydst.push(part.as_slice());\n+                try!(mkdir(&mydst));\n+            }\n+            mydst.push(format!(\"{}.{}.js\",\n+                               remote_item_type.to_static_str(),\n+                               *remote_path.get(remote_path.len() - 1)));\n+            let all_implementors = try!(collect(&mydst, krate.name.as_slice(),\n+                                                \"implementors\"));\n+\n+            try!(mkdir(&mydst.dir_path()));\n+            let mut f = BufferedWriter::new(try!(File::create(&mydst)));\n+            try!(writeln!(&mut f, r\"(function() \\{var implementors = \\{\\};\"));\n+\n+            for implementor in all_implementors.iter() {\n+                try!(writeln!(&mut f, \"{}\", *implementor));\n+            }\n+\n+            try!(write!(&mut f, r\"implementors['{}'] = \\{\", krate.name));\n+            for imp in imps.iter() {\n+                let &(ref path, item_type) = match *imp {\n+                    PathType(clean::ResolvedPath { did, .. }) => {\n+                        cache.paths.get(&did)\n+                    }\n+                    PathType(..) | OtherType(..) => continue,\n+                };\n+                try!(write!(&mut f, r#\"{}:\"#, *path.get(path.len() - 1)));\n+                try!(write!(&mut f, r#\"\"{}\"#,\n+                            path.slice_to(path.len() - 1).connect(\"/\")));\n+                try!(write!(&mut f, r#\"/{}.{}.html\",\"#,\n+                            item_type.to_static_str(),\n+                            *path.get(path.len() - 1)));\n+            }\n+            try!(writeln!(&mut f, r\"\\};\"));\n+            try!(writeln!(&mut f, \"{}\", r\"\n+                if (window.register_implementors) {\n+                    window.register_implementors(implementors);\n+                } else {\n+                    window.pending_implementors = implementors;\n+                }\n+            \"));\n+            try!(writeln!(&mut f, r\"\\})()\"));\n+        }\n     }\n \n     // Render all source files (this may turn into a giant no-op)\n@@ -635,13 +697,13 @@ impl DocFolder for Cache {\n                 match i.trait_ {\n                     // FIXME: this is_local() check seems to be losing\n                     // information\n-                    Some(clean::ResolvedPath{ did, .. })\n-                        if ast_util::is_local(did) =>\n-                    {\n-                        let id = did.node;\n-                        let v = self.implementors.find_or_insert_with(id, |_|{\n-                            Vec::new()\n-                        });\n+                    Some(clean::ResolvedPath{ did, .. }) => {\n+                        let v = if ast_util::is_local(did) {\n+                            self.implementors.find_or_insert(did.node, Vec::new())\n+                        } else {\n+                            self.foreign_implementors.find_or_insert(did,\n+                                                                     Vec::new())\n+                        };\n                         match i.for_ {\n                             clean::ResolvedPath{..} => {\n                                 v.unshift(PathType(i.for_.clone()));\n@@ -1050,7 +1112,7 @@ impl<'a> fmt::Show for Item<'a> {\n             }\n             clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) =>\n                 item_function(fmt, self.item, f),\n-            clean::TraitItem(ref t) => item_trait(fmt, self.item, t),\n+            clean::TraitItem(ref t) => item_trait(fmt, self.cx, self.item, t),\n             clean::StructItem(ref s) => item_struct(fmt, self.item, s),\n             clean::EnumItem(ref e) => item_enum(fmt, self.item, e),\n             clean::TypedefItem(ref t) => item_typedef(fmt, self.item, t),\n@@ -1273,7 +1335,7 @@ fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n     document(w, it)\n }\n \n-fn item_trait(w: &mut fmt::Formatter, it: &clean::Item,\n+fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Trait) -> fmt::Result {\n     let mut parents = StrBuf::new();\n     if t.parents.len() > 0 {\n@@ -1353,7 +1415,7 @@ fn item_trait(w: &mut fmt::Formatter, it: &clean::Item,\n         Some(implementors) => {\n             try!(write!(w, \"\n                 <h2 id='implementors'>Implementors</h2>\n-                <ul class='item-list'>\n+                <ul class='item-list' id='implementors-list'>\n             \"));\n             for i in implementors.iter() {\n                 match *i {\n@@ -1367,6 +1429,13 @@ fn item_trait(w: &mut fmt::Formatter, it: &clean::Item,\n                 }\n             }\n             try!(write!(w, \"</ul>\"));\n+            try!(write!(w, r#\"<script type=\"text/javascript\" async\n+                                      src=\"{}/implementors/{}/{}.{}.js\"></script>\"#,\n+                        cx.current.iter().map(|_| \"..\")\n+                                  .collect::<Vec<&str>>().connect(\"/\"),\n+                        cx.current.connect(\"/\"),\n+                        shortty(it).to_static_str(),\n+                        *it.name.get_ref()));\n         }\n         None => {}\n     }"}, {"sha": "c88e6aa586833eb70f7d8781b41226ffb5bed4ac", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06eb9765fec87dc66e17c97f667e30e6726d133e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/06eb9765fec87dc66e17c97f667e30e6726d133e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=06eb9765fec87dc66e17c97f667e30e6726d133e", "patch": "@@ -653,4 +653,26 @@\n     }\n \n     window.initSearch = initSearch;\n+\n+    window.register_implementors = function(imp) {\n+        var list = $('#implementors-list');\n+        var libs = Object.getOwnPropertyNames(imp);\n+        for (var i = 0; i < libs.length; i++) {\n+            var structs = Object.getOwnPropertyNames(imp[libs[i]]);\n+            for (var j = 0; j < structs.length; j++) {\n+                console.log(i, structs[j]);\n+                var path = rootPath + imp[libs[i]][structs[j]];\n+                var klass = path.contains(\"type.\") ? \"type\" : \"struct\";\n+                var link = $('<a>').text(structs[j])\n+                                   .attr('href', path)\n+                                   .attr('class', klass);\n+                var code = $('<code>').append(link);\n+                var li = $('<li>').append(code);\n+                list.append(li);\n+            }\n+        }\n+    };\n+    if (window.pending_implementors) {\n+        window.register_implementors(window.pending_implementors);\n+    }\n }());"}]}