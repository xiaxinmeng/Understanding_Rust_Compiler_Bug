{"sha": "98295e9eb2e9fdc3cf1e9c819865e515a3125bc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4Mjk1ZTllYjJlOWZkYzNjZjFlOWM4MTk4NjVlNTE1YTMxMjViYzQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-02T07:17:40Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-05T08:29:39Z"}, "message": "use more traditional walk_array/visit_array instead of the handle_array hook", "tree": {"sha": "15943fc27d6d6311ed7a5b748a2ed9e17da2b3da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15943fc27d6d6311ed7a5b748a2ed9e17da2b3da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98295e9eb2e9fdc3cf1e9c819865e515a3125bc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98295e9eb2e9fdc3cf1e9c819865e515a3125bc4", "html_url": "https://github.com/rust-lang/rust/commit/98295e9eb2e9fdc3cf1e9c819865e515a3125bc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98295e9eb2e9fdc3cf1e9c819865e515a3125bc4/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aea61e398c4e65b8572d71188cc098e5ec5fab54", "url": "https://api.github.com/repos/rust-lang/rust/commits/aea61e398c4e65b8572d71188cc098e5ec5fab54", "html_url": "https://github.com/rust-lang/rust/commit/aea61e398c4e65b8572d71188cc098e5ec5fab54"}], "stats": {"total": 144, "additions": 73, "deletions": 71}, "files": [{"sha": "45645a714d0aa0d5e336ee6d0b26db5aa1a898a1", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98295e9eb2e9fdc3cf1e9c819865e515a3125bc4/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98295e9eb2e9fdc3cf1e9c819865e515a3125bc4/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=98295e9eb2e9fdc3cf1e9c819865e515a3125bc4", "patch": "@@ -212,19 +212,19 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         // Perform operation\n         self.push_aggregate_field_path_elem(op.layout, field);\n         self.op = val;\n-        self.visit(ectx)?;\n+        self.visit_value(ectx)?;\n         // Undo changes\n         self.path.truncate(path_len);\n         self.op = op;\n         Ok(())\n     }\n \n     #[inline]\n-    fn visit(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n+    fn visit_value(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n         -> EvalResult<'tcx>\n     {\n         // Translate enum discriminant errors to something nicer.\n-        match ectx.walk_value(self) {\n+        match self.walk_value(ectx) {\n             Ok(()) => Ok(()),\n             Err(err) => match err.kind {\n                 EvalErrorKind::InvalidDiscriminant(val) =>\n@@ -479,15 +479,14 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         }\n     }\n \n-    fn handle_array(&mut self, ectx: &EvalContext<'a, 'mir, 'tcx, M>)\n-        -> EvalResult<'tcx, bool>\n+    fn visit_array(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx>\n     {\n-        Ok(match self.op.layout.ty.sty {\n+        match self.op.layout.ty.sty {\n             ty::Str => {\n                 let mplace = self.op.to_mem_place(); // strings are never immediate\n                 try_validation!(ectx.read_str(mplace),\n                     \"uninitialized or non-UTF-8 data in str\", self.path);\n-                true\n             }\n             ty::Array(tys, ..) | ty::Slice(tys) if {\n                 // This optimization applies only for integer and floating point types\n@@ -526,7 +525,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     /*allow_ptr_and_undef*/!self.const_mode,\n                 ) {\n                     // In the happy case, we needn't check anything else.\n-                    Ok(()) => true, // handled these arrays\n+                    Ok(()) => {},\n                     // Some error happened, try to provide a more detailed description.\n                     Err(err) => {\n                         // For some errors we might be able to provide extra information\n@@ -548,8 +547,11 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     }\n                 }\n             }\n-            _ => false, // not handled\n-        })\n+            _ => {\n+                self.walk_array(ectx)? // default handler\n+            }\n+        }\n+        Ok(())\n     }\n }\n \n@@ -580,6 +582,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         };\n \n         // Run it\n-        visitor.visit(self)\n+        visitor.visit_value(self)\n     }\n }"}, {"sha": "8b153e17c1e5d15dbb35666855f6ad85a7606ab7", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/98295e9eb2e9fdc3cf1e9c819865e515a3125bc4/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98295e9eb2e9fdc3cf1e9c819865e515a3125bc4/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=98295e9eb2e9fdc3cf1e9c819865e515a3125bc4", "patch": "@@ -178,77 +178,91 @@ pub trait ValueVisitor<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: fmt::Debug +\n         self.value().layout()\n     }\n \n-    // Replace the value by `val`, which must be the `field`th field of `self`, then call\n-    // `visit_value` and then un-do everything that might have happened to the visitor state.\n-    // The point of this is that some visitors keep a stack of fields that we projected below,\n-    // and this lets us avoid copying that stack; instead they will pop the stack after\n-    // executing `visit_value`.\n-    fn visit_field(\n-        &mut self,\n-        ectx: &mut EvalContext<'a, 'mir, 'tcx, M>,\n-        val: Self::V,\n-        field: usize,\n-    ) -> EvalResult<'tcx>;\n-\n-    // A chance for the visitor to do special (different or more efficient) handling for some\n-    // array types.  Return `true` if the value was handled and we should return.\n+    // Recursie actions, ready to be overloaded.\n+    /// Visit the current value, dispatching as appropriate to more speicalized visitors.\n     #[inline]\n-    fn handle_array(&mut self, _ectx: &EvalContext<'a, 'mir, 'tcx, M>)\n-        -> EvalResult<'tcx, bool>\n+    fn visit_value(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx>\n     {\n-        Ok(false)\n+        self.walk_value(ectx)\n     }\n-\n-    // Execute visitor on the current value.  Used for recursing.\n+    /// Visit the current value as an array.\n     #[inline]\n-    fn visit(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n+    fn visit_array(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n         -> EvalResult<'tcx>\n     {\n-        ectx.walk_value(self)\n+        self.walk_array(ectx)\n     }\n+    /// Called each time we recurse down to a field of the value, to (a) let\n+    /// the visitor change its internal state (recording the new current value),\n+    /// and (b) let the visitor track the \"stack\" of fields that we descended below.\n+    fn visit_field(\n+        &mut self,\n+        ectx: &mut EvalContext<'a, 'mir, 'tcx, M>,\n+        val: Self::V,\n+        field: usize,\n+    ) -> EvalResult<'tcx>;\n \n-    // Actions on the leaves.\n+    // Actions on the leaves, ready to be overloaded.\n+    #[inline]\n     fn visit_uninhabited(&mut self, _ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n         -> EvalResult<'tcx>\n     { Ok(()) }\n+    #[inline]\n     fn visit_scalar(&mut self, _ectx: &mut EvalContext<'a, 'mir, 'tcx, M>, _layout: &layout::Scalar)\n         -> EvalResult<'tcx>\n     { Ok(()) }\n+    #[inline]\n     fn visit_primitive(&mut self, _ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n         -> EvalResult<'tcx>\n     { Ok(()) }\n-}\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    pub fn walk_value<V: ValueVisitor<'a, 'mir, 'tcx, M>>(\n-        &mut self,\n-        v: &mut V,\n-    ) -> EvalResult<'tcx> {\n-        trace!(\"walk_value: {:?}\", v);\n+    // Default recursors. Not meant to be overloaded.\n+    fn walk_array(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx>\n+    {\n+        // Let's get an mplace first.\n+        let mplace = if self.layout().is_zst() {\n+            // it's a ZST, the memory content cannot matter\n+            MPlaceTy::dangling(self.layout(), ectx)\n+        } else {\n+            // non-ZST array/slice/str cannot be immediate\n+            self.value().to_mem_place(ectx)?\n+        };\n+        // Now iterate over it.\n+        for (i, field) in ectx.mplace_array_fields(mplace)?.enumerate() {\n+            self.visit_field(ectx, Value::from_mem_place(field?), i)?;\n+        }\n+        Ok(())\n+    }\n+    fn walk_value(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx>\n+    {\n+        trace!(\"walk_value: {:?}\", self);\n \n         // If this is a multi-variant layout, we have find the right one and proceed with that.\n         // (No benefit from making this recursion, but it is equivalent to that.)\n-        match v.layout().variants {\n+        match self.layout().variants {\n             layout::Variants::NicheFilling { .. } |\n             layout::Variants::Tagged { .. } => {\n-                let (inner, idx) = v.value().project_downcast(self)?;\n+                let (inner, idx) = self.value().project_downcast(ectx)?;\n                 trace!(\"variant layout: {:#?}\", inner.layout());\n                 // recurse with the inner type\n-                return v.visit_field(self, inner, idx);\n+                return self.visit_field(ectx, inner, idx);\n             }\n             layout::Variants::Single { .. } => {}\n         }\n \n         // Even for single variants, we might be able to get a more refined type:\n         // If it is a trait object, switch to the actual type that was used to create it.\n-        match v.layout().ty.sty {\n+        match self.layout().ty.sty {\n             ty::Dynamic(..) => {\n                 // immediate trait objects are not a thing\n-                let dest = v.value().to_mem_place(self)?;\n-                let inner = self.unpack_dyn_trait(dest)?.1;\n+                let dest = self.value().to_mem_place(ectx)?;\n+                let inner = ectx.unpack_dyn_trait(dest)?.1;\n                 trace!(\"dyn object layout: {:#?}\", inner.layout);\n                 // recurse with the inner type\n-                return v.visit_field(self, Value::from_mem_place(inner), 0);\n+                return self.visit_field(ectx, Value::from_mem_place(inner), 0);\n             },\n             _ => {},\n         };\n@@ -260,12 +274,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         // FIXME: We could avoid some redundant checks here. For newtypes wrapping\n         // scalars, we do the same check on every \"level\" (e.g. first we check\n         // MyNewtype and then the scalar in there).\n-        match v.layout().abi {\n+        match self.layout().abi {\n             layout::Abi::Uninhabited => {\n-                v.visit_uninhabited(self)?;\n+                self.visit_uninhabited(ectx)?;\n             }\n             layout::Abi::Scalar(ref layout) => {\n-                v.visit_scalar(self, layout)?;\n+                self.visit_scalar(ectx, layout)?;\n             }\n             // FIXME: Should we do something for ScalarPair? Vector?\n             _ => {}\n@@ -276,17 +290,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         // so we check them separately and before aggregate handling.\n         // It is CRITICAL that we get this check right, or we might be\n         // validating the wrong thing!\n-        let primitive = match v.layout().fields {\n+        let primitive = match self.layout().fields {\n             // Primitives appear as Union with 0 fields -- except for Boxes and fat pointers.\n             layout::FieldPlacement::Union(0) => true,\n-            _ => v.layout().ty.builtin_deref(true).is_some(),\n+            _ => self.layout().ty.builtin_deref(true).is_some(),\n         };\n         if primitive {\n-            return v.visit_primitive(self);\n+            return self.visit_primitive(ectx);\n         }\n \n         // Proceed into the fields.\n-        match v.layout().fields {\n+        match self.layout().fields {\n             layout::FieldPlacement::Union(fields) => {\n                 // Empty unions are not accepted by rustc. That's great, it means we can\n                 // use that as an unambiguous signal for detecting primitives.  Make sure\n@@ -298,26 +312,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             },\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n                 for i in 0..offsets.len() {\n-                    let val = v.value().project_field(self, i as u64)?;\n-                    v.visit_field(self, val, i)?;\n+                    let val = self.value().project_field(ectx, i as u64)?;\n+                    self.visit_field(ectx, val, i)?;\n                 }\n             },\n             layout::FieldPlacement::Array { .. } => {\n-                if !v.handle_array(self)? {\n-                    // We still have to work!\n-                    // Let's get an mplace first.\n-                    let mplace = if v.layout().is_zst() {\n-                        // it's a ZST, the memory content cannot matter\n-                        MPlaceTy::dangling(v.layout(), self)\n-                    } else {\n-                        // non-ZST array/slice/str cannot be immediate\n-                        v.value().to_mem_place(self)?\n-                    };\n-                    // Now iterate over it.\n-                    for (i, field) in self.mplace_array_fields(mplace)?.enumerate() {\n-                        v.visit_field(self, Value::from_mem_place(field?), i)?;\n-                    }\n-                }\n+                self.visit_array(ectx)?;\n             }\n         }\n         Ok(())"}]}