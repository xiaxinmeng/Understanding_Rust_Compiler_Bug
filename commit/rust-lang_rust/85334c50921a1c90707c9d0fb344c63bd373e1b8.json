{"sha": "85334c50921a1c90707c9d0fb344c63bd373e1b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MzM0YzUwOTIxYTFjOTA3MDdjOWQwZmIzNDRjNjNiZDM3M2UxYjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-23T04:48:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-23T04:48:21Z"}, "message": "Auto merge of #60174 - matthewjasper:add-match-arm-scopes, r=pnkfelix\n\nAdd match arm scopes and other scope fixes\n\n* Add drop and lint scopes for match arms.\n* Lint attributes are now respected on match arms.\n* Make sure we emit a StorageDead if we diverge when initializing a temporary.\n* Adjust MIR pretty printing of scopes for locals.\n* Don't generate duplicate lint scopes for `let statements`.\n* Add some previously missing fake borrows for matches.\n\ncloses #46525\n\ncc @rust-lang/compiler", "tree": {"sha": "29d106408d94b1b1809af77d59fa47dff995da93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29d106408d94b1b1809af77d59fa47dff995da93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85334c50921a1c90707c9d0fb344c63bd373e1b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85334c50921a1c90707c9d0fb344c63bd373e1b8", "html_url": "https://github.com/rust-lang/rust/commit/85334c50921a1c90707c9d0fb344c63bd373e1b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85334c50921a1c90707c9d0fb344c63bd373e1b8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15ccaf77911d9261d0c254be8a3e878db84792c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/15ccaf77911d9261d0c254be8a3e878db84792c6", "html_url": "https://github.com/rust-lang/rust/commit/15ccaf77911d9261d0c254be8a3e878db84792c6"}, {"sha": "0835048ea0fc724163b5032112df3c7555a2073b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0835048ea0fc724163b5032112df3c7555a2073b", "html_url": "https://github.com/rust-lang/rust/commit/0835048ea0fc724163b5032112df3c7555a2073b"}], "stats": {"total": 1002, "additions": 726, "deletions": 276}, "files": [{"sha": "ef0d4be268eaf36d1c60f2169f9f9f4bec3f1542", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -419,7 +419,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         for arm in arms {\n             // Add an exit node for when we've visited all the\n             // patterns and the guard (if there is one) in the arm.\n-            let arm_exit = self.add_dummy_node(&[]);\n+            let bindings_exit = self.add_dummy_node(&[]);\n \n             for pat in &arm.pats {\n                 // Visit the pattern, coming from the discriminant exit\n@@ -453,14 +453,16 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n                 // Add an edge from the exit of this pattern to the\n                 // exit of the arm\n-                self.add_contained_edge(pat_exit, arm_exit);\n+                self.add_contained_edge(pat_exit, bindings_exit);\n             }\n \n             // Visit the body of this arm\n-            let body_exit = self.expr(&arm.body, arm_exit);\n+            let body_exit = self.expr(&arm.body, bindings_exit);\n+\n+            let arm_exit = self.add_ast_node(arm.hir_id.local_id, &[body_exit]);\n \n             // Link the body to the exit of the expression\n-            self.add_contained_edge(body_exit, expr_exit);\n+            self.add_contained_edge(arm_exit, expr_exit);\n         }\n \n         expr_exit"}, {"sha": "517c99f99efea1e257339c96ca398c644e1b68a5", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -1102,6 +1102,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n }\n \n pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n+    visitor.visit_id(arm.hir_id);\n     walk_list!(visitor, visit_pat, &arm.pats);\n     if let Some(ref g) = arm.guard {\n         match g {"}, {"sha": "6b82548f6dcde11e7ee9ce2ea6f397647c7e0935", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -1314,13 +1314,15 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm {\n         hir::Arm {\n+            hir_id: self.next_id(),\n             attrs: self.lower_attrs(&arm.attrs),\n             pats: arm.pats.iter().map(|x| self.lower_pat(x)).collect(),\n             guard: match arm.guard {\n                 Some(Guard::If(ref x)) => Some(hir::Guard::If(P(self.lower_expr(x)))),\n                 _ => None,\n             },\n             body: P(self.lower_expr(&arm.body)),\n+            span: arm.span,\n         }\n     }\n \n@@ -5024,9 +5026,11 @@ impl<'a> LoweringContext<'a> {\n \n     fn arm(&mut self, pats: hir::HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n         hir::Arm {\n+            hir_id: self.next_id(),\n             attrs: hir_vec![],\n             pats,\n             guard: None,\n+            span: expr.span,\n             body: expr,\n         }\n     }"}, {"sha": "b5203f9ec1f72b030f68ce025ec7f68d3c273e06", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -430,6 +430,16 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n+    fn visit_arm(&mut self, arm: &'hir Arm) {\n+        let node = Node::Arm(arm);\n+\n+        self.insert(arm.span, arm.hir_id, node);\n+\n+        self.with_parent(arm.hir_id, |this| {\n+            intravisit::walk_arm(this, arm);\n+        });\n+    }\n+\n     fn visit_anon_const(&mut self, constant: &'hir AnonConst) {\n         self.insert(DUMMY_SP, constant.hir_id, Node::AnonConst(constant));\n "}, {"sha": "0741d9322c65328eff9d2fb7dcb1ffdac3883481", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -373,6 +373,7 @@ impl<'hir> Map<'hir> {\n             Node::Pat(_) |\n             Node::Binding(_) |\n             Node::Local(_) |\n+            Node::Arm(_) |\n             Node::Lifetime(_) |\n             Node::Visibility(_) |\n             Node::Block(_) |\n@@ -1000,6 +1001,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::Field(ref f)) => Some(&f.attrs[..]),\n             Some(Node::Expr(ref e)) => Some(&*e.attrs),\n             Some(Node::Stmt(ref s)) => Some(s.node.attrs()),\n+            Some(Node::Arm(ref a)) => Some(&*a.attrs),\n             Some(Node::GenericParam(param)) => Some(&param.attrs[..]),\n             // Unit/tuple structs/variants take the attributes straight from\n             // the struct/variant definition.\n@@ -1073,6 +1075,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::TraitRef(tr)) => tr.path.span,\n             Some(Node::Binding(pat)) => pat.span,\n             Some(Node::Pat(pat)) => pat.span,\n+            Some(Node::Arm(arm)) => arm.span,\n             Some(Node::Block(block)) => block.span,\n             Some(Node::Ctor(..)) => match self.find_by_hir_id(\n                 self.get_parent_node_by_hir_id(hir_id))\n@@ -1288,6 +1291,7 @@ impl<'a> print::State<'a> {\n             Node::TraitRef(a)     => self.print_trait_ref(&a),\n             Node::Binding(a)      |\n             Node::Pat(a)          => self.print_pat(&a),\n+            Node::Arm(a)          => self.print_arm(&a),\n             Node::Block(a)        => {\n                 use syntax::print::pprust::PrintState;\n \n@@ -1417,6 +1421,9 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n         Some(Node::Pat(_)) => {\n             format!(\"pat {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n+        Some(Node::Arm(_)) => {\n+            format!(\"arm {}{}\", map.hir_to_pretty_string(id), id_str)\n+        }\n         Some(Node::Block(_)) => {\n             format!(\"block {}{}\", map.hir_to_pretty_string(id), id_str)\n         }"}, {"sha": "2ae5f7a0b5531f4771c6c264320cb75fe3c6f71e", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -1228,6 +1228,9 @@ pub struct Local {\n /// `<pats> (if <guard>) => <body>`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Arm {\n+    #[stable_hasher(ignore)]\n+    pub hir_id: HirId,\n+    pub span: Span,\n     pub attrs: HirVec<Attribute>,\n     /// Multiple patterns can be combined with `|`\n     pub pats: HirVec<P<Pat>>,\n@@ -2656,6 +2659,7 @@ pub enum Node<'hir> {\n     TraitRef(&'hir TraitRef),\n     Binding(&'hir Pat),\n     Pat(&'hir Pat),\n+    Arm(&'hir Arm),\n     Block(&'hir Block),\n     Local(&'hir Local),\n     MacroDef(&'hir MacroDef),"}, {"sha": "e51681082f3192ed33c6c2e420258c39ea6ba6f5", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -1862,7 +1862,7 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n-    fn print_arm(&mut self, arm: &hir::Arm) -> io::Result<()> {\n+    pub fn print_arm(&mut self, arm: &hir::Arm) -> io::Result<()> {\n         // I have no idea why this check is necessary, but here it\n         // is :(\n         if arm.attrs.is_empty() {"}, {"sha": "512e4d434434ce892a52f9050036e9ba0ac8359e", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -852,6 +852,12 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n         })\n     }\n \n+    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n+        self.with_lint_attrs(a.hir_id, &a.attrs, |builder| {\n+            intravisit::walk_arm(builder, a);\n+        })\n+    }\n+\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |builder| {\n             intravisit::walk_trait_item(builder, trait_item);"}, {"sha": "fa4e8e3d4769d34e2645048a60402aac2ff1757b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -119,18 +119,18 @@ impl fmt::Debug for Scope {\n pub enum ScopeData {\n     Node,\n \n-    // Scope of the call-site for a function or closure\n-    // (outlives the arguments as well as the body).\n+    /// Scope of the call-site for a function or closure\n+    /// (outlives the arguments as well as the body).\n     CallSite,\n \n-    // Scope of arguments passed to a function or closure\n-    // (they outlive its body).\n+    /// Scope of arguments passed to a function or closure\n+    /// (they outlive its body).\n     Arguments,\n \n-    // Scope of destructors for temporaries of node-id.\n+    /// Scope of destructors for temporaries of node-id.\n     Destruction,\n \n-    // Scope following a `let id = expr;` binding in a block.\n+    /// Scope following a `let id = expr;` binding in a block.\n     Remainder(FirstStatementIndex)\n }\n \n@@ -152,11 +152,11 @@ newtype_index! {\n     ///\n     /// * The subscope with `first_statement_index == 1` is scope of `c`,\n     ///   and thus does not include EXPR_2, but covers the `...`.\n-    pub struct FirstStatementIndex { .. }\n+    pub struct FirstStatementIndex {\n+        derive [HashStable]\n+    }\n }\n \n-impl_stable_hash_for!(struct crate::middle::region::FirstStatementIndex { private });\n-\n // compilation error if size of `ScopeData` is not the same as a `u32`\n static_assert_size!(ScopeData, 4);\n \n@@ -814,13 +814,25 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n }\n \n fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &'tcx hir::Arm) {\n+    let prev_cx = visitor.cx;\n+\n+    visitor.enter_scope(\n+        Scope {\n+            id: arm.hir_id.local_id,\n+            data: ScopeData::Node,\n+        }\n+    );\n+    visitor.cx.var_parent = visitor.cx.parent;\n+\n     visitor.terminating_scopes.insert(arm.body.hir_id.local_id);\n \n     if let Some(hir::Guard::If(ref expr)) = arm.guard {\n         visitor.terminating_scopes.insert(expr.hir_id.local_id);\n     }\n \n     intravisit::walk_arm(visitor, arm);\n+\n+    visitor.cx = prev_cx;\n }\n \n fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &'tcx hir::Pat) {\n@@ -893,10 +905,6 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n                 terminating(body.hir_id.local_id);\n             }\n \n-            hir::ExprKind::Match(..) => {\n-                visitor.cx.var_parent = visitor.cx.parent;\n-            }\n-\n             hir::ExprKind::DropTemps(ref expr) => {\n                 // `DropTemps(expr)` does not denote a conditional scope.\n                 // Rather, we want to achieve the same behavior as `{ let _t = expr; _t }`."}, {"sha": "b5bab1585342a1cacf4329ee69aacafcf31d31e1", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -23,8 +23,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             safety_mode\n         } =\n             self.hir.mirror(ast_block);\n-        self.in_opt_scope(opt_destruction_scope.map(|de|(de, source_info)), block, move |this| {\n-            this.in_scope((region_scope, source_info), LintLevel::Inherited, block, move |this| {\n+        self.in_opt_scope(opt_destruction_scope.map(|de|(de, source_info)), move |this| {\n+            this.in_scope((region_scope, source_info), LintLevel::Inherited, move |this| {\n                 if targeted_by_break {\n                     // This is a `break`-able block\n                     let exit_block = this.cfg.start_new_block();\n@@ -83,9 +83,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 StmtKind::Expr { scope, expr } => {\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result: true });\n                     unpack!(block = this.in_opt_scope(\n-                        opt_destruction_scope.map(|de|(de, source_info)), block, |this| {\n+                        opt_destruction_scope.map(|de|(de, source_info)), |this| {\n                             let si = (scope, source_info);\n-                            this.in_scope(si, LintLevel::Inherited, block, |this| {\n+                            this.in_scope(si, LintLevel::Inherited, |this| {\n                                 let expr = this.hir.mirror(expr);\n                                 this.stmt_expr(block, expr, Some(stmt_span))\n                             })\n@@ -113,31 +113,39 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let remainder_span = remainder_scope.span(this.hir.tcx(),\n                                                               &this.hir.region_scope_tree);\n \n-                    let scope;\n+                    let visibility_scope =\n+                        Some(this.new_source_scope(remainder_span, LintLevel::Inherited, None));\n \n                     // Evaluate the initializer, if present.\n                     if let Some(init) = initializer {\n                         let initializer_span = init.span();\n \n-                        scope = this.declare_bindings(\n-                            None,\n-                            remainder_span,\n-                            lint_level,\n-                            &pattern,\n-                            ArmHasGuard(false),\n-                            Some((None, initializer_span)),\n-                        );\n                         unpack!(block = this.in_opt_scope(\n-                            opt_destruction_scope.map(|de|(de, source_info)), block, |this| {\n+                            opt_destruction_scope.map(|de|(de, source_info)), |this| {\n                                 let scope = (init_scope, source_info);\n-                                this.in_scope(scope, lint_level, block, |this| {\n+                                this.in_scope(scope, lint_level, |this| {\n+                                    this.declare_bindings(\n+                                        visibility_scope,\n+                                        remainder_span,\n+                                        &pattern,\n+                                        ArmHasGuard(false),\n+                                        Some((None, initializer_span)),\n+                                    );\n                                     this.expr_into_pattern(block, pattern, init)\n                                 })\n                             }));\n                     } else {\n-                        scope = this.declare_bindings(\n-                            None, remainder_span, lint_level, &pattern,\n-                            ArmHasGuard(false), None);\n+                        let scope = (init_scope, source_info);\n+                        unpack!(this.in_scope(scope, lint_level, |this| {\n+                            this.declare_bindings(\n+                                visibility_scope,\n+                                remainder_span,\n+                                &pattern,\n+                                ArmHasGuard(false),\n+                                None,\n+                            );\n+                            block.unit()\n+                        }));\n \n                         debug!(\"ast_block_stmts: pattern={:?}\", pattern);\n                         this.visit_bindings(\n@@ -149,8 +157,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             })\n                     }\n \n-                    // Enter the source scope, after evaluating the initializer.\n-                    if let Some(source_scope) = scope {\n+                    // Enter the visibility scope, after evaluating the initializer.\n+                    if let Some(source_scope) = visibility_scope {\n                         this.source_scope = source_scope;\n                     }\n                 }"}, {"sha": "ed80cb1a16369e6286917c16d0dfe05d2a54031f", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -57,7 +57,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         {\n             let source_info = this.source_info(expr.span);\n             let region_scope = (region_scope, source_info);\n-            return this.in_scope(region_scope, lint_level, block, |this| {\n+            return this.in_scope(region_scope, lint_level, |this| {\n                 this.as_operand(block, scope, value)\n             });\n         }"}, {"sha": "a956eacb0699fd3cd1276a0687645addc1282bf6", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 region_scope,\n                 lint_level,\n                 value,\n-            } => this.in_scope((region_scope, source_info), lint_level, block, |this| {\n+            } => this.in_scope((region_scope, source_info), lint_level, |this| {\n                 if mutability == Mutability::Not {\n                     this.as_read_only_place(block, value)\n                 } else {"}, {"sha": "a0b504a99de9a7981778362410688bec60663dd7", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 value,\n             } => {\n                 let region_scope = (region_scope, source_info);\n-                this.in_scope(region_scope, lint_level, block, |this| {\n+                this.in_scope(region_scope, lint_level, |this| {\n                     this.as_rvalue(block, scope, value)\n                 })\n             }"}, {"sha": "cffd8fb2892f5ce987d1946a431f998a1669dade", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -1,6 +1,7 @@\n //! See docs in build/expr/mod.rs\n \n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n+use crate::build::scope::{CachedBlock, DropKind};\n use crate::hair::*;\n use rustc::middle::region;\n use rustc::mir::*;\n@@ -43,7 +44,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             value,\n         } = expr.kind\n         {\n-            return this.in_scope((region_scope, source_info), lint_level, block, |this| {\n+            return this.in_scope((region_scope, source_info), lint_level, |this| {\n                 this.as_temp(block, temp_lifetime, value, mutability)\n             });\n         }\n@@ -63,6 +64,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             this.local_decls.push(local_decl)\n         };\n+        let temp_place = &Place::Base(PlaceBase::Local(temp));\n+\n         if !expr_ty.is_never() {\n             this.cfg.push(\n                 block,\n@@ -71,25 +74,38 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     kind: StatementKind::StorageLive(temp),\n                 },\n             );\n+\n+            // In constants, `temp_lifetime` is `None` for temporaries that live for the\n+            // `'static` lifetime. Thus we do not drop these temporaries and simply leak them.\n+            // This is equivalent to what `let x = &foo();` does in functions. The temporary\n+            // is lifted to their surrounding scope. In a function that means the temporary lives\n+            // until just before the function returns. In constants that means it outlives the\n+            // constant's initialization value computation. Anything outliving a constant\n+            // must have the `'static` lifetime and live forever.\n+            // Anything with a shorter lifetime (e.g the `&foo()` in `bar(&foo())` or anything\n+            // within a block will keep the regular drops just like runtime code.\n+            if let Some(temp_lifetime) = temp_lifetime {\n+                this.schedule_drop(\n+                    expr_span,\n+                    temp_lifetime,\n+                    temp_place,\n+                    expr_ty,\n+                    DropKind::Storage,\n+                );\n+            }\n         }\n \n-        unpack!(block = this.into(&Place::Base(PlaceBase::Local(temp)), block, expr));\n+        unpack!(block = this.into(temp_place, block, expr));\n \n-        // In constants, temp_lifetime is None for temporaries that live for the\n-        // 'static lifetime. Thus we do not drop these temporaries and simply leak them.\n-        // This is equivalent to what `let x = &foo();` does in functions. The temporary\n-        // is lifted to their surrounding scope. In a function that means the temporary lives\n-        // until just before the function returns. In constants that means it outlives the\n-        // constant's initialization value computation. Anything outliving a constant\n-        // must have the `'static` lifetime and live forever.\n-        // Anything with a shorter lifetime (e.g the `&foo()` in `bar(&foo())` or anything\n-        // within a block will keep the regular drops just like runtime code.\n         if let Some(temp_lifetime) = temp_lifetime {\n-            this.schedule_drop_storage_and_value(\n+            this.schedule_drop(\n                 expr_span,\n                 temp_lifetime,\n-                &Place::Base(PlaceBase::Local(temp)),\n+                temp_place,\n                 expr_ty,\n+                DropKind::Value {\n+                    cached_block: CachedBlock::default(),\n+                },\n             );\n         }\n "}, {"sha": "7bdfdf0b0895f9579fe4a0cd16cd9f2ae809ebf6", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 value,\n             } => {\n                 let region_scope = (region_scope, source_info);\n-                this.in_scope(region_scope, lint_level, block, |this| {\n+                this.in_scope(region_scope, lint_level, |this| {\n                     this.into(destination, block, value)\n                 })\n             }"}, {"sha": "ac690f89264bfdd0d84f163ecbc3f79df3534733", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -29,7 +29,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 value,\n             } => {\n                 let value = this.hir.mirror(value);\n-                this.in_scope((region_scope, source_info), lint_level, block, |this| {\n+                this.in_scope((region_scope, source_info), lint_level, |this| {\n                     this.stmt_expr(block, value, opt_stmt_span)\n                 })\n             }"}, {"sha": "58ca35abcb123ddb5f8cbec5470d3e652b80325f", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 60, "deletions": 46, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -12,6 +12,7 @@ use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use crate::hair::{self, *};\n use rustc::hir::HirId;\n use rustc::mir::*;\n+use rustc::middle::region;\n use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty};\n use rustc::ty::layout::VariantIdx;\n use rustc_data_structures::bit_set::BitSet;\n@@ -251,45 +252,47 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Step 5. Create everything else: the guards and the arms.\n \n-        let outer_source_info = self.source_info(span);\n         let arm_end_blocks: Vec<_> = arm_candidates.into_iter().map(|(arm, candidates)| {\n-            let mut arm_block = self.cfg.start_new_block();\n-\n-            let body = self.hir.mirror(arm.body.clone());\n-            let scope = self.declare_bindings(\n-                None,\n-                body.span,\n-                LintLevel::Inherited,\n-                &arm.patterns[0],\n-                ArmHasGuard(arm.guard.is_some()),\n-                Some((Some(&scrutinee_place), scrutinee_span)),\n-            );\n-\n-            for candidate in candidates {\n-                self.bind_and_guard_matched_candidate(\n-                    candidate,\n-                    arm.guard.clone(),\n-                    arm_block,\n-                    &fake_borrow_temps,\n-                    scrutinee_span,\n+            let arm_source_info = self.source_info(arm.span);\n+            let region_scope = (arm.scope, arm_source_info);\n+            self.in_scope(region_scope, arm.lint_level, |this| {\n+                let arm_block = this.cfg.start_new_block();\n+\n+                let body = this.hir.mirror(arm.body.clone());\n+                let scope = this.declare_bindings(\n+                    None,\n+                    arm.span,\n+                    &arm.patterns[0],\n+                    ArmHasGuard(arm.guard.is_some()),\n+                    Some((Some(&scrutinee_place), scrutinee_span)),\n                 );\n-            }\n \n-            if let Some(source_scope) = scope {\n-                self.source_scope = source_scope;\n-            }\n+                if let Some(source_scope) = scope {\n+                    this.source_scope = source_scope;\n+                }\n \n-            unpack!(arm_block = self.into(destination, arm_block, body));\n+                for candidate in candidates {\n+                    this.clear_top_scope(arm.scope);\n+                    this.bind_and_guard_matched_candidate(\n+                        candidate,\n+                        arm.guard.clone(),\n+                        arm_block,\n+                        &fake_borrow_temps,\n+                        scrutinee_span,\n+                        region_scope,\n+                    );\n+                }\n \n-            arm_block\n+                this.into(destination, arm_block, body)\n+            })\n         }).collect();\n \n         // all the arm blocks will rejoin here\n         let end_block = self.cfg.start_new_block();\n \n         for arm_block in arm_end_blocks {\n             self.cfg.terminate(\n-                arm_block,\n+                unpack!(arm_block),\n                 outer_source_info,\n                 TerminatorKind::Goto { target: end_block },\n             );\n@@ -489,33 +492,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         &mut self,\n         mut visibility_scope: Option<SourceScope>,\n         scope_span: Span,\n-        lint_level: LintLevel,\n         pattern: &Pattern<'tcx>,\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<&Place<'tcx>>, Span)>,\n     ) -> Option<SourceScope> {\n-        assert!(\n-            !(visibility_scope.is_some() && lint_level.is_explicit()),\n-            \"can't have both a visibility and a lint scope at the same time\"\n-        );\n-        let mut scope = self.source_scope;\n         debug!(\"declare_bindings: pattern={:?}\", pattern);\n         self.visit_bindings(\n             &pattern,\n             UserTypeProjections::none(),\n             &mut |this, mutability, name, mode, var, span, ty, user_ty| {\n                 if visibility_scope.is_none() {\n-                    // If we have lints, create a new source scope\n-                    // that marks the lints for the locals. See the comment\n-                    // on the `source_info` field for why this is needed.\n-                    if lint_level.is_explicit() {\n-                        scope = this.new_source_scope(scope_span, lint_level, None);\n-                    }\n-                visibility_scope = Some(this.new_source_scope(scope_span,\n-                                                           LintLevel::Inherited,\n-                                                           None));\n+                    visibility_scope =\n+                        Some(this.new_source_scope(scope_span, LintLevel::Inherited, None));\n                 }\n-                let source_info = SourceInfo { span, scope };\n+                let source_info = SourceInfo { span, scope: this.source_scope };\n                 let visibility_scope = visibility_scope.unwrap();\n                 this.declare_binding(\n                     source_info,\n@@ -880,7 +870,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             span,\n             untested_candidates,\n             join_block,\n-            &mut None,\n+            fake_borrows,\n         )\n     }\n \n@@ -1328,6 +1318,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         arm_block: BasicBlock,\n         fake_borrows: &Vec<(&Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n+        region_scope: (region::Scope, SourceInfo),\n     ) {\n         debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n \n@@ -1510,17 +1501,40 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             //\n             // and that is clearly not correct.\n             let post_guard_block = self.cfg.start_new_block();\n+            let otherwise_post_guard_block = self.cfg.start_new_block();\n             self.cfg.terminate(\n                 block,\n                 source_info,\n                 TerminatorKind::if_(\n                     self.hir.tcx(),\n-                    cond,\n+                    cond.clone(),\n                     post_guard_block,\n-                    candidate.otherwise_block.unwrap()\n+                    otherwise_post_guard_block,\n                 ),\n             );\n \n+            self.exit_scope(\n+                source_info.span,\n+                region_scope,\n+                otherwise_post_guard_block,\n+                candidate.otherwise_block.unwrap(),\n+            );\n+\n+            if let Operand::Copy(cond_place) | Operand::Move(cond_place) = cond {\n+                if let Place::Base(PlaceBase::Local(cond_temp)) = cond_place {\n+                    // We will call `clear_top_scope` if there's another guard. So\n+                    // we have to drop this variable now or it will be \"storage\n+                    // leaked\".\n+                    self.pop_variable(\n+                        post_guard_block,\n+                        region_scope.0,\n+                        cond_temp\n+                    );\n+                } else {\n+                    bug!(\"Expected as_local_operand to produce a temporary\");\n+                }\n+            }\n+\n             let by_value_bindings = candidate.bindings.iter().filter(|binding| {\n                 if let BindingMode::ByValue = binding.binding_mode { true } else { false }\n             });"}, {"sha": "55b5d5d1471ac0ff8907c407f57835134ee368e9", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -704,13 +704,13 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let mut block = START_BLOCK;\n     let source_info = builder.source_info(span);\n     let call_site_s = (call_site_scope, source_info);\n-    unpack!(block = builder.in_scope(call_site_s, LintLevel::Inherited, block, |builder| {\n+    unpack!(block = builder.in_scope(call_site_s, LintLevel::Inherited, |builder| {\n         if should_abort_on_panic(tcx, fn_def_id, abi) {\n             builder.schedule_abort();\n         }\n \n         let arg_scope_s = (arg_scope, source_info);\n-        unpack!(block = builder.in_scope(arg_scope_s, LintLevel::Inherited, block, |builder| {\n+        unpack!(block = builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n             builder.args_and_body(block, &arguments, arg_scope, &body.value)\n         }));\n         // Attribute epilogue to function's closing brace\n@@ -950,10 +950,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         self.var_indices.insert(var, LocalsForNode::One(local));\n                     }\n                     _ => {\n-                        scope = self.declare_bindings(scope, ast_body.span,\n-                                                      LintLevel::Inherited, &pattern,\n-                                                      matches::ArmHasGuard(false),\n-                                                      Some((Some(&place), span)));\n+                        scope = self.declare_bindings(\n+                            scope,\n+                            ast_body.span,\n+                            &pattern,\n+                            matches::ArmHasGuard(false),\n+                            Some((Some(&place), span)),\n+                        );\n                         unpack!(block = self.place_into_pattern(block, pattern, &place, false));\n                     }\n                 }"}, {"sha": "58339173c9e5d2590e446be852d77d9dbbc22dd0", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 82, "deletions": 10, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -19,13 +19,18 @@ paragraph). This is because region scopes are tied to\n them. Eventually, when we shift to non-lexical lifetimes, there should\n be no need to remember this mapping.\n \n-There is one additional wrinkle, actually, that I wanted to hide from\n-you but duty compels me to mention. In the course of building\n-matches, it sometimes happen that certain code (namely guards) gets\n-executed multiple times. This means that the scope lexical scope may\n-in fact correspond to multiple, disjoint SEME regions. So in fact our\n+### Not so SEME Regions\n+\n+In the course of building matches, it sometimes happens that certain code\n+(namely guards) gets executed multiple times. This means that the scope lexical\n+scope may in fact correspond to multiple, disjoint SEME regions. So in fact our\n mapping is from one scope to a vector of SEME regions.\n \n+Also in matches, the scopes assigned to arms are not even SEME regions! Each\n+arm has a single region with one entry for each pattern. We manually\n+manipulate the scheduled drops in this scope to avoid dropping things multiple\n+times, although drop elaboration would clean this up for value drops.\n+\n ### Drops\n \n The primary purpose for scopes is to insert drops: while building\n@@ -282,13 +287,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     pub fn in_opt_scope<F, R>(&mut self,\n                               opt_scope: Option<(region::Scope, SourceInfo)>,\n-                              mut block: BasicBlock,\n                               f: F)\n                               -> BlockAnd<R>\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> BlockAnd<R>\n     {\n-        debug!(\"in_opt_scope(opt_scope={:?}, block={:?})\", opt_scope, block);\n+        debug!(\"in_opt_scope(opt_scope={:?})\", opt_scope);\n         if let Some(region_scope) = opt_scope { self.push_scope(region_scope); }\n+        let mut block;\n         let rv = unpack!(block = f(self));\n         if let Some(region_scope) = opt_scope {\n             unpack!(block = self.pop_scope(region_scope, block));\n@@ -302,12 +307,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn in_scope<F, R>(&mut self,\n                           region_scope: (region::Scope, SourceInfo),\n                           lint_level: LintLevel,\n-                          mut block: BasicBlock,\n                           f: F)\n                           -> BlockAnd<R>\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> BlockAnd<R>\n     {\n-        debug!(\"in_scope(region_scope={:?}, block={:?})\", region_scope, block);\n+        debug!(\"in_scope(region_scope={:?})\", region_scope);\n         let source_scope = self.source_scope;\n         let tcx = self.hir.tcx();\n         if let LintLevel::Explicit(current_hir_id) = lint_level {\n@@ -333,6 +337,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n         self.push_scope(region_scope);\n+        let mut block;\n         let rv = unpack!(block = f(self));\n         unpack!(block = self.pop_scope(region_scope, block));\n         self.source_scope = source_scope;\n@@ -730,7 +735,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // Note that this code iterates scopes from the inner-most to the outer-most,\n             // invalidating caches of each scope visited. This way bare minimum of the\n             // caches gets invalidated. i.e., if a new drop is added into the middle scope, the\n-            // cache of outer scpoe stays intact.\n+            // cache of outer scope stays intact.\n             scope.invalidate_cache(!needs_drop, this_scope);\n             if this_scope {\n                 if let DropKind::Value { .. } = drop_kind {\n@@ -872,6 +877,73 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         success_block\n     }\n+\n+    // `match` arm scopes\n+    // ==================\n+    /// Unschedules any drops in the top scope.\n+    ///\n+    /// This is only needed for `match` arm scopes, because they have one\n+    /// entrance per pattern, but only one exit.\n+    pub fn clear_top_scope(&mut self, region_scope: region::Scope) {\n+        let top_scope = self.scopes.last_mut().unwrap();\n+\n+        assert_eq!(top_scope.region_scope, region_scope);\n+\n+        top_scope.drops.clear();\n+        top_scope.invalidate_cache(false, true);\n+    }\n+\n+    /// Drops the single variable provided\n+    ///\n+    /// * The scope must be the top scope.\n+    /// * The variable must be in that scope.\n+    /// * The variable must be at the top of that scope: it's the next thing\n+    ///   scheduled to drop.\n+    /// * The drop must be of `DropKind::Storage`.\n+    ///\n+    /// This is used for the boolean holding the result of the match guard. We\n+    /// do this because:\n+    ///\n+    /// * The boolean is different for each pattern\n+    /// * There is only one exit for the arm scope\n+    /// * The guard expression scope is too short, it ends just before the\n+    ///   boolean is tested.\n+    pub fn pop_variable(\n+        &mut self,\n+        block: BasicBlock,\n+        region_scope: region::Scope,\n+        variable: Local,\n+    ) {\n+        let top_scope = self.scopes.last_mut().unwrap();\n+\n+        assert_eq!(top_scope.region_scope, region_scope);\n+\n+        let top_drop_data = top_scope.drops.pop().unwrap();\n+\n+        match top_drop_data.kind {\n+            DropKind::Value { .. } => {\n+                bug!(\"Should not be calling pop_top_variable on non-copy type!\")\n+            }\n+            DropKind::Storage => {\n+                // Drop the storage for both value and storage drops.\n+                // Only temps and vars need their storage dead.\n+                match top_drop_data.location {\n+                    Place::Base(PlaceBase::Local(index)) => {\n+                        let source_info = top_scope.source_info(top_drop_data.span);\n+                        assert_eq!(index, variable);\n+                        self.cfg.push(block, Statement {\n+                            source_info,\n+                            kind: StatementKind::StorageDead(index)\n+                        });\n+                    }\n+                    _ => unreachable!(),\n+                }\n+            }\n+        }\n+\n+        top_scope.invalidate_cache(true, true);\n+    }\n+\n }\n \n /// Builds drops for pop_scope and exit_scope."}, {"sha": "03d55b84f32e260f38dce78551558c77388c331f", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -11,8 +11,7 @@ use super::MoveDataParamEnv;\n \n use crate::util::elaborate_drops::DropFlagState;\n \n-use super::move_paths::{HasMoveData, MoveData, MovePathIndex, InitIndex};\n-use super::move_paths::{LookupResult, InitKind};\n+use super::move_paths::{HasMoveData, MoveData, MovePathIndex, InitIndex, InitKind};\n use super::{BitDenotation, BlockSets, InitialFlow};\n \n use super::drop_flag_effects_for_function_entry;\n@@ -470,35 +469,13 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'gcx, 'tc\n         sets.gen_all(&init_loc_map[location]);\n \n         match stmt.kind {\n-            mir::StatementKind::StorageDead(local) |\n-            mir::StatementKind::StorageLive(local) => {\n-                // End inits for StorageDead and StorageLive, so that an immutable\n-                // variable can be reinitialized on the next iteration of the loop.\n-                //\n-                // FIXME(#46525): We *need* to do this for StorageLive as well as\n-                // StorageDead, because lifetimes of match bindings with guards are\n-                // weird - i.e., this code\n-                //\n-                // ```\n-                //     fn main() {\n-                //         match 0 {\n-                //             a | a\n-                //             if { println!(\"a={}\", a); false } => {}\n-                //             _ => {}\n-                //         }\n-                //     }\n-                // ```\n-                //\n-                // runs the guard twice, using the same binding for `a`, and only\n-                // storagedeads after everything ends, so if we don't regard the\n-                // storagelive as killing storage, we would have a multiple assignment\n-                // to immutable data error.\n-                if let LookupResult::Exact(mpi) =\n-                    rev_lookup.find(&mir::Place::Base(mir::PlaceBase::Local(local))) {\n-                    debug!(\"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n-                           stmt, location, &init_path_map[mpi]);\n-                    sets.kill_all(&init_path_map[mpi]);\n-                }\n+            mir::StatementKind::StorageDead(local) => {\n+                // End inits for StorageDead, so that an immutable variable can\n+                // be reinitialized on the next iteration of the loop.\n+                let move_path_index = rev_lookup.find_local(local);\n+                debug!(\"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n+                        stmt, location, &init_path_map[move_path_index]);\n+                sets.kill_all(&init_path_map[move_path_index]);\n             }\n             _ => {}\n         }"}, {"sha": "d623f149988c7aed7893e9d1cc9614f7d26c9013", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -879,8 +879,12 @@ fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm)\n                 _ => None,\n             },\n         body: arm.body.to_ref(),\n-        // BUG: fix this\n-        lint_level: LintLevel::Inherited,\n+        lint_level: LintLevel::Explicit(arm.hir_id),\n+        scope: region::Scope {\n+            id: arm.hir_id.local_id,\n+            data: region::ScopeData::Node\n+        },\n+        span: arm.span,\n     }\n }\n "}, {"sha": "8e19913f4df26d30ab8611cef310842cce27677f", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -31,15 +31,6 @@ pub enum LintLevel {\n     Explicit(hir::HirId)\n }\n \n-impl LintLevel {\n-    pub fn is_explicit(self) -> bool {\n-        match self {\n-            LintLevel::Inherited => false,\n-            LintLevel::Explicit(_) => true\n-        }\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n pub struct Block<'tcx> {\n     pub targeted_by_break: bool,\n@@ -311,6 +302,8 @@ pub struct Arm<'tcx> {\n     pub guard: Option<Guard<'tcx>>,\n     pub body: ExprRef<'tcx>,\n     pub lint_level: LintLevel,\n+    pub scope: region::Scope,\n+    pub span: Span,\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "0088c97679c6666f13e1d05731a1cdf2ebfb3779", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -149,7 +149,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_arm(&mut self, a: &'v hir::Arm) {\n-        self.record(\"Arm\", Id::None, a);\n+        self.record(\"Arm\", Id::Node(a.hir_id), a);\n         hir_visit::walk_arm(self, a)\n     }\n "}, {"sha": "e4b431e6e68f17bc653196b4818d043680b3d13c", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -540,7 +540,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         err.help(&format!(\"did you mean `{}: &{}`?\", snippet, expected));\n                     }\n                 }\n-                hir::Node::Expr(hir::Expr { node: hir::ExprKind::Match(..), .. }) |\n+                hir::Node::Arm(_) |\n                 hir::Node::Pat(_) => {\n                     // rely on match ergonomics or it might be nested `&&pat`\n                     if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n@@ -781,14 +781,17 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n     fn maybe_get_coercion_reason(&self, hir_id: hir::HirId, span: Span) -> Option<(Span, String)> {\n         use hir::Node::{Block, Item, Local};\n \n-        let node = self.tcx.hir().get_by_hir_id(self.tcx.hir().get_parent_node_by_hir_id(\n-            self.tcx.hir().get_parent_node_by_hir_id(hir_id),\n-        ));\n+        let hir = self.tcx.hir();\n+        let arm_id = hir.get_parent_node_by_hir_id(hir_id);\n+        let match_id = hir.get_parent_node_by_hir_id(arm_id);\n+        let containing_id = hir.get_parent_node_by_hir_id(match_id);\n+\n+        let node = hir.get_by_hir_id(containing_id);\n         if let Block(block) = node {\n             // check that the body's parent is an fn\n-            let parent = self.tcx.hir().get_by_hir_id(\n-                self.tcx.hir().get_parent_node_by_hir_id(\n-                    self.tcx.hir().get_parent_node_by_hir_id(block.hir_id),\n+            let parent = hir.get_by_hir_id(\n+                hir.get_parent_node_by_hir_id(\n+                    hir.get_parent_node_by_hir_id(block.hir_id),\n                 ),\n             );\n             if let (Some(expr), Item(hir::Item {"}, {"sha": "064459e750fbeb20b000811795cb934ad8a578ca", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -908,6 +908,7 @@ pub struct Arm {\n     pub pats: Vec<P<Pat>>,\n     pub guard: Option<Guard>,\n     pub body: P<Expr>,\n+    pub span: Span,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "ad8fb12deb7f6b34cd33954514ccc0b8a3a277da", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -890,12 +890,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n-    fn arm(&self, _span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm {\n+    fn arm(&self, span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm {\n         ast::Arm {\n             attrs: vec![],\n             pats,\n             guard: None,\n             body: expr,\n+            span,\n         }\n     }\n "}, {"sha": "e743248ef4b59057a10b5c3b7b2150098b58e7b2", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -391,11 +391,15 @@ pub fn noop_visit_use_tree<T: MutVisitor>(use_tree: &mut UseTree, vis: &mut T) {\n     vis.visit_span(span);\n }\n \n-pub fn noop_visit_arm<T: MutVisitor>(Arm { attrs, pats, guard, body }: &mut Arm, vis: &mut T) {\n+pub fn noop_visit_arm<T: MutVisitor>(\n+    Arm { attrs, pats, guard, body, span }: &mut Arm,\n+    vis: &mut T,\n+) {\n     visit_attrs(attrs, vis);\n     visit_vec(pats, |pat| vis.visit_pat(pat));\n     visit_opt(guard, |guard| vis.visit_guard(guard));\n     vis.visit_expr(body);\n+    vis.visit_span(span);\n }\n \n pub fn noop_visit_guard<T: MutVisitor>(g: &mut Guard, vis: &mut T) {"}, {"sha": "7600d6078a106cebd3ef1124e89f86eb4c05a586", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -3946,6 +3946,7 @@ impl<'a> Parser<'a> {\n \n     crate fn parse_arm(&mut self) -> PResult<'a, Arm> {\n         let attrs = self.parse_outer_attributes()?;\n+        let lo = self.span;\n         let pats = self.parse_pats()?;\n         let guard = if self.eat_keyword(kw::If) {\n             Some(Guard::If(self.parse_expr()?))\n@@ -3965,6 +3966,8 @@ impl<'a> Parser<'a> {\n         let require_comma = classify::expr_requires_semi_to_be_stmt(&expr)\n             && self.token != token::CloseDelim(token::Brace);\n \n+        let hi = self.span;\n+\n         if require_comma {\n             let cm = self.sess.source_map();\n             self.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Brace)])\n@@ -4008,6 +4011,7 @@ impl<'a> Parser<'a> {\n             pats,\n             guard,\n             body: expr,\n+            span: lo.to(hi),\n         })\n     }\n "}, {"sha": "ee6adfefe3e360b3a0ec00bd878d1fceb2de619e", "filename": "src/test/mir-opt/box_expr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbox_expr.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -22,13 +22,11 @@ impl Drop for S {\n // END RUST SOURCE\n // START rustc.main.ElaborateDrops.before.mir\n //     let mut _0: ();\n+//     let _1: std::boxed::Box<S>;\n //     let mut _2: std::boxed::Box<S>;\n //     let mut _3: ();\n //     let mut _4: std::boxed::Box<S>;\n //     scope 1 {\n-//         let _1: std::boxed::Box<S>;\n-//     }\n-//     scope 2 {\n //     }\n //     bb0: {\n //         StorageLive(_1);"}, {"sha": "0b678be2ab3197ea4f8c1b34b6204c546e16f7fa", "filename": "src/test/mir-opt/issue-41110.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41110.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -29,27 +29,24 @@ impl S {\n // END RUST SOURCE\n // START rustc.main.ElaborateDrops.after.mir\n //    let mut _0: ();\n+//    let _1: ();\n //    let mut _2: S;\n //    let mut _3: S;\n //    let mut _4: S;\n //    let mut _5: bool;\n //    scope 1 {\n-//        let _1: ();\n-//    }\n-//    scope 2 {\n //    }\n //    ...\n //    bb0: {\n // END rustc.main.ElaborateDrops.after.mir\n // START rustc.test.ElaborateDrops.after.mir\n //    let mut _0: ();\n+//    let _1: S;\n //    let mut _3: ();\n //    let mut _4: S;\n //    let mut _5: S;\n //    let mut _6: bool;\n //    ...\n-//    let _1: S;\n-//    ...\n //    let mut _2: S;\n //    ...\n //    bb0: {"}, {"sha": "bf22f00b5055241febebe48805840a533a8cb617", "filename": "src/test/mir-opt/issue-49232.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-49232.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -18,14 +18,12 @@ fn main() {\n // fn main() -> (){\n //     let mut _0: ();\n //     let mut _1: ();\n+//     let _2: i32;\n //     let mut _3: bool;\n //     let mut _4: !;\n //     let mut _5: ();\n //     let mut _6: &i32;\n //     scope 1 {\n-//         let _2: i32;\n-//     }\n-//     scope 2 {\n //     }\n //     bb0: {\n //         goto -> bb1;\n@@ -88,7 +86,6 @@ fn main() {\n //         unreachable;\n //     }\n //     bb17: {\n-//         StorageDead(_4);\n //         goto -> bb18;\n //     }\n //     bb18: {"}, {"sha": "0f026b8a08dfa9fe97c7b8018f9c0e025b3c2d15", "filename": "src/test/mir-opt/match-arm-scopes.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -0,0 +1,245 @@\n+// Test that StorageDead and Drops are generated properly for bindings in\n+// matches:\n+// * The MIR should only contain a single drop of `s` and `t`: at the end\n+//   of their respective arms.\n+// * StorageDead and StorageLive statements are correctly matched up on\n+//   non-unwind paths.\n+// * The visibility scopes of the match arms should be disjoint, and contain.\n+//   all of the bindings for that scope.\n+// * No drop flags are used.\n+\n+#![feature(nll, bind_by_move_pattern_guards)]\n+\n+fn complicated_match(cond: bool, items: (bool, bool, String)) -> i32 {\n+    match items {\n+        (false, a, s) | (a, false, s) if if cond { return 3 } else { a } => 1,\n+        (true, b, t) | (false, b, t) => 2,\n+    }\n+}\n+\n+const CASES: &[(bool, bool, bool, i32)] = &[\n+    (false, false, false, 2),\n+    (false, false, true, 1),\n+    (false, true, false, 1),\n+    (false, true, true, 2),\n+    (true, false, false, 3),\n+    (true, false, true, 3),\n+    (true, true, false, 3),\n+    (true, true, true, 2),\n+];\n+\n+fn main() {\n+    for &(cond, items_1, items_2, result) in CASES {\n+        assert_eq!(\n+            complicated_match(cond, (items_1, items_2, String::new())),\n+            result,\n+        );\n+    }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.complicated_match.SimplifyCfg-initial.after.mir\n+// let mut _0: i32;\n+// let mut _3: &bool;                   // Temp for fake borrow of `items.0`\n+// let mut _4: &bool;                   // Temp for fake borrow of `items.1`\n+// let _5: bool;                    // `a` in arm\n+// let _6: &bool;                   // `a` in guard\n+// let _7: std::string::String;     // `s` in arm\n+// let _8: &std::string::String;    // `s` in guard\n+// let mut _9: bool;                    // `if cond { return 3 } else { a }`\n+// let mut _10: bool;                   // `cond`\n+// let mut _11: !;                      // `return 3`\n+// let mut _12: bool;                   // `if cond { return 3 } else { a }`\n+// let mut _13: bool;                   // `cond`\n+// let mut _14: !;                      // `return 3`\n+// let _15: bool;                   // `b`\n+// let _16: std::string::String;    // `t`\n+// scope 1 {\n+// }\n+// scope 2 {\n+// }\n+// bb0: {\n+//     FakeRead(ForMatchedPlace, _2);\n+//     switchInt((_2.0: bool)) -> [false: bb2, otherwise: bb7];\n+// }\n+// bb1 (cleanup): {\n+//     resume;\n+// }\n+// bb2: {\n+//     falseEdges -> [real: bb10, imaginary: bb3];\n+// }\n+// bb3: {\n+//     falseEdges -> [real: bb21, imaginary: bb4];\n+// }\n+// bb4: {\n+//     falseEdges -> [real: bb31, imaginary: bb5];\n+// }\n+// bb5: {\n+//     falseEdges -> [real: bb32, imaginary: bb6];\n+// }\n+// bb6: {\n+//     unreachable;\n+// }\n+// bb7: {\n+//     switchInt((_2.1: bool)) -> [false: bb3, otherwise: bb8];\n+// }\n+// bb8: {\n+//     switchInt((_2.0: bool)) -> [false: bb5, otherwise: bb4];\n+// }\n+// bb9: {                               // arm 1\n+//     _0 = const 1i32;\n+//     drop(_7) -> [return: bb29, unwind: bb16];\n+// }\n+// bb10: {                              // guard - first time\n+//     StorageLive(_6);\n+//     _6 = &(_2.1: bool);\n+//     StorageLive(_8);\n+//     _8 = &(_2.2: std::string::String);\n+//     _3 = &shallow (_2.0: bool);\n+//     _4 = &shallow (_2.1: bool);\n+//     StorageLive(_9);\n+//     StorageLive(_10);\n+//     _10 = _1;\n+//     FakeRead(ForMatchedPlace, _10);\n+//     switchInt(_10) -> [false: bb12, otherwise: bb11];\n+// }\n+// bb11: {\n+//     falseEdges -> [real: bb14, imaginary: bb12];\n+// }\n+// bb12: {\n+//     falseEdges -> [real: bb18, imaginary: bb13];\n+// }\n+// bb13: {\n+//     unreachable;\n+// }\n+// bb14: {                              // `return 3` - first time\n+//     _0 = const 3i32;\n+//     StorageDead(_10);\n+//     StorageDead(_9);\n+//     StorageDead(_8);\n+//     StorageDead(_6);\n+//     goto -> bb17;\n+// }\n+// bb15: {\n+//     return;\n+// }\n+// bb16 (cleanup): {\n+//     drop(_2) -> bb1;\n+// }\n+// bb17: {\n+//     drop(_2) -> [return: bb15, unwind: bb1];\n+// }\n+// bb18: {                              // `else` block - first time\n+//     _9 = (*_6);\n+//     StorageDead(_10);\n+//     FakeRead(ForMatchGuard, _3);\n+//     FakeRead(ForMatchGuard, _4);\n+//     FakeRead(ForGuardBinding, _6);\n+//     FakeRead(ForGuardBinding, _8);\n+//     switchInt(move _9) -> [false: bb20, otherwise: bb19];\n+// }\n+// bb19: {\n+//     StorageDead(_9);\n+//     StorageLive(_5);\n+//     _5 = (_2.1: bool);\n+//     StorageLive(_7);\n+//     _7 = move (_2.2: std::string::String);\n+//     goto -> bb9;\n+// }\n+// bb20: {                              // guard otherwise case - first time\n+//     StorageDead(_9);\n+//     StorageDead(_8);\n+//     StorageDead(_6);\n+//     falseEdges -> [real: bb7, imaginary: bb3];\n+// }\n+// bb21: {                              // guard - second time\n+//     StorageLive(_6);\n+//     _6 = &(_2.0: bool);\n+//     StorageLive(_8);\n+//     _8 = &(_2.2: std::string::String);\n+//     _3 = &shallow (_2.0: bool);\n+//     _4 = &shallow (_2.1: bool);\n+//     StorageLive(_12);\n+//     StorageLive(_13);\n+//     _13 = _1;\n+//     FakeRead(ForMatchedPlace, _13);\n+//     switchInt(_13) -> [false: bb23, otherwise: bb22];\n+// }\n+// bb22: {\n+//     falseEdges -> [real: bb25, imaginary: bb23];\n+// }\n+// bb23: {\n+//     falseEdges -> [real: bb26, imaginary: bb24];\n+// }\n+// bb24: {\n+//     unreachable;\n+// }\n+// bb25: {                              // `return 3` - second time\n+//     _0 = const 3i32;\n+//     StorageDead(_13);\n+//     StorageDead(_12);\n+//     StorageDead(_8);\n+//     StorageDead(_6);\n+//     goto -> bb17;\n+// }\n+// bb26: {                              // `else` block - second time\n+//     _12 = (*_6);\n+//     StorageDead(_13);\n+//     FakeRead(ForMatchGuard, _3);\n+//     FakeRead(ForMatchGuard, _4);\n+//     FakeRead(ForGuardBinding, _6);\n+//     FakeRead(ForGuardBinding, _8);\n+//     switchInt(move _12) -> [false: bb28, otherwise: bb27];\n+// }\n+// bb27: {                              // Guard otherwise case - second time\n+//     StorageDead(_12);\n+//     StorageLive(_5);\n+//     _5 = (_2.0: bool);\n+//     StorageLive(_7);\n+//     _7 = move (_2.2: std::string::String);\n+//     goto -> bb9;\n+// }\n+// bb28: {                              // rest of arm 1\n+//     StorageDead(_12);\n+//     StorageDead(_8);\n+//     StorageDead(_6);\n+//     falseEdges -> [real: bb8, imaginary: bb4];\n+// }\n+// bb29: {\n+//     StorageDead(_7);\n+//     StorageDead(_5);\n+//     StorageDead(_8);\n+//     StorageDead(_6);\n+//     goto -> bb34;\n+// }\n+// bb30: {                              // arm 2\n+//     _0 = const 2i32;\n+//     drop(_16) -> [return: bb33, unwind: bb16];\n+// }\n+// bb31: {                              // bindings for arm 2 - first pattern\n+//     StorageLive(_15);\n+//     _15 = (_2.1: bool);\n+//     StorageLive(_16);\n+//     _16 = move (_2.2: std::string::String);\n+//     goto -> bb30;\n+// }\n+// bb32: {                              // bindings for arm 2 - first pattern\n+//     StorageLive(_15);\n+//     _15 = (_2.1: bool);\n+//     StorageLive(_16);\n+//     _16 = move (_2.2: std::string::String);\n+//     goto -> bb30;\n+// }\n+// bb33: {                              // rest of arm 2\n+//     StorageDead(_16);\n+//     StorageDead(_15);\n+//     goto -> bb34;\n+// }\n+// bb34: {                              // end of match\n+//     drop(_2) -> [return: bb15, unwind: bb1];\n+// }\n+// END rustc.complicated_match.SimplifyCfg-initial.after.mir\n+// START rustc.complicated_match.ElaborateDrops.after.mir\n+// let _16: std::string::String;      // No drop flags, which would come after this.\n+// scope 1 {\n+// END rustc.complicated_match.ElaborateDrops.after.mir"}, {"sha": "6979924c8cd9083b4986665d81abb6c2df17e97a", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 78, "deletions": 48, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -45,13 +45,13 @@ fn main() {\n //      _2 = std::option::Option::<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n-//      switchInt(move _3) -> [0isize: bb4, 1isize: bb2, otherwise: bb7];\n+//      switchInt(move _3) -> [0isize: bb4, 1isize: bb2, otherwise: bb6];\n //  }\n //  bb1 (cleanup): {\n //      resume;\n //  }\n //  bb2: {\n-//      falseEdges -> [real: bb8, imaginary: bb3]; //pre_binding1\n+//      falseEdges -> [real: bb7, imaginary: bb3]; //pre_binding1\n //  }\n //  bb3: {\n //      falseEdges -> [real: bb11, imaginary: bb4]; //pre_binding2\n@@ -62,48 +62,56 @@ fn main() {\n //  bb5: {\n //      unreachable;\n //  }\n-//  bb6: { // to pre_binding2\n-//      falseEdges -> [real: bb3, imaginary: bb3];\n-//  }\n-//  bb7: {\n+//  bb6: {\n //      unreachable;\n //  }\n-//  bb8: { // binding1 and guard\n+//  bb7: { // binding1 and guard\n //      StorageLive(_6);\n //      _6 = &(((promoted[0]: std::option::Option<i32>) as Some).0: i32);\n //      _4 = &shallow _2;\n //      StorageLive(_7);\n-//      _7 = const guard() -> [return: bb9, unwind: bb1];\n+//      _7 = const guard() -> [return: bb8, unwind: bb1];\n //  }\n-//  bb9: {\n+//  bb8: { // end of guard\n //      FakeRead(ForMatchGuard, _4);\n //      FakeRead(ForGuardBinding, _6);\n-//      switchInt(move _7) -> [false: bb6, otherwise: bb10];\n+//      switchInt(move _7) -> [false: bb10, otherwise: bb9];\n //  }\n-//  bb10: {\n+//  bb9: { // arm1\n+//      StorageDead(_7);\n //      StorageLive(_5);\n //      _5 = ((_2 as Some).0: i32);\n //      StorageLive(_8);\n //      _8 = _5;\n //      _1 = (const 1i32, move _8);\n //      StorageDead(_8);\n+//      StorageDead(_5);\n+//      StorageDead(_6);\n //      goto -> bb13;\n //  }\n-//  bb11: {\n+//  bb10: { // to pre_binding2\n+//      StorageDead(_7);\n+//      StorageDead(_6);\n+//      falseEdges -> [real: bb3, imaginary: bb3];\n+//  }\n+//  bb11: { // arm2\n //      StorageLive(_9);\n //      _9 = ((_2 as Some).0: i32);\n //      StorageLive(_10);\n //      _10 = _9;\n //      _1 = (const 2i32, move _10);\n //      StorageDead(_10);\n+//      StorageDead(_9);\n //      goto -> bb13;\n //  }\n-//  bb12: {\n+//  bb12: { // arm3\n //      _1 = (const 3i32, const 3i32);\n //      goto -> bb13;\n //  }\n //  bb13: {\n-//      ...\n+//      StorageDead(_2);\n+//      StorageDead(_1);\n+//      _0 = ();\n //      return;\n //  }\n // END rustc.full_tested_match.QualifyAndPromoteConstants.after.mir\n@@ -114,13 +122,13 @@ fn main() {\n //      _2 = std::option::Option::<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n-//      switchInt(move _3) -> [0isize: bb3, 1isize: bb2, otherwise: bb7];\n+//      switchInt(move _3) -> [0isize: bb3, 1isize: bb2, otherwise: bb6];\n //  }\n //  bb1 (cleanup): {\n //      resume;\n //  }\n //  bb2: {\n-//      falseEdges -> [real: bb8, imaginary: bb3];\n+//      falseEdges -> [real: bb7, imaginary: bb3];\n //  }\n //  bb3: {\n //      falseEdges -> [real: bb11, imaginary: bb4];\n@@ -131,33 +139,38 @@ fn main() {\n //  bb5: {\n //      unreachable;\n //  }\n-//  bb6: { // to pre_binding3 (can skip 2 since this is `Some`)\n-//      falseEdges -> [real: bb4, imaginary: bb3];\n-//  }\n-//  bb7: {\n+//  bb6: {\n //      unreachable;\n //  }\n-//  bb8: { // binding1 and guard\n+//  bb7: { // binding1 and guard\n //      StorageLive(_6);\n //      _6 = &((_2 as Some).0: i32);\n //      _4 = &shallow _2;\n //      StorageLive(_7);\n-//      _7 = const guard() -> [return: bb9, unwind: bb1];\n+//      _7 = const guard() -> [return: bb8, unwind: bb1];\n //  }\n-//  bb9: { // end of guard\n+//  bb8: { // end of guard\n //      FakeRead(ForMatchGuard, _4);\n //      FakeRead(ForGuardBinding, _6);\n-//      switchInt(move _7) -> [false: bb6, otherwise: bb10];\n+//      switchInt(move _7) -> [false: bb10, otherwise: bb9];\n //  }\n-//  bb10: { // arm1\n+//  bb9: { // arm1\n+//      StorageDead(_7);\n //      StorageLive(_5);\n //      _5 = ((_2 as Some).0: i32);\n //      StorageLive(_8);\n //      _8 = _5;\n //      _1 = (const 1i32, move _8);\n //      StorageDead(_8);\n+//      StorageDead(_5);\n+//      StorageDead(_6);\n //      goto -> bb13;\n //  }\n+//  bb10: { // to pre_binding3 (can skip 2 since this is `Some`)\n+//      StorageDead(_7);\n+//      StorageDead(_6);\n+//      falseEdges -> [real: bb4, imaginary: bb3];\n+//  }\n //  bb11: { // arm2\n //      _1 = (const 3i32, const 3i32);\n //      goto -> bb13;\n@@ -169,16 +182,19 @@ fn main() {\n //      _10 = _9;\n //      _1 = (const 2i32, move _10);\n //      StorageDead(_10);\n+//      StorageDead(_9);\n //      goto -> bb13;\n //  }\n //  bb13: {\n-//      ...\n+//      StorageDead(_2);\n+//      StorageDead(_1);\n+//      _0 = ();\n //      return;\n //  }\n // END rustc.full_tested_match2.QualifyAndPromoteConstants.before.mir\n //\n // START rustc.main.QualifyAndPromoteConstants.before.mir\n-// bb0: {\n+//  bb0: {\n //     ...\n //      _2 = std::option::Option::<i32>::Some(const 1i32,);\n //      FakeRead(ForMatchedPlace, _2);\n@@ -189,79 +205,93 @@ fn main() {\n //      resume;\n //  }\n //  bb2: {\n-//      falseEdges -> [real: bb9, imaginary: bb3];\n+//      falseEdges -> [real: bb7, imaginary: bb3];\n //  }\n //  bb3: {\n-//      falseEdges -> [real: bb12, imaginary: bb4];\n+//      falseEdges -> [real: bb11, imaginary: bb4];\n //  }\n //  bb4: {\n-//      falseEdges -> [real: bb13, imaginary: bb5];\n+//      falseEdges -> [real: bb12, imaginary: bb5];\n //  }\n //  bb5: {\n //      falseEdges -> [real: bb16, imaginary: bb6];\n //  }\n //  bb6: {\n //      unreachable;\n //  }\n-//  bb7: {\n-//      falseEdges -> [real: bb3, imaginary: bb3];\n-//  }\n-//  bb8: {\n-//      falseEdges -> [real: bb5, imaginary: bb5];\n-//  }\n-//  bb9: { // binding1: Some(w) if guard()\n+//  bb7: { // binding1: Some(w) if guard()\n //      StorageLive(_7);\n //      _7 = &((_2 as Some).0: i32);\n //      _5 = &shallow _2;\n //      StorageLive(_8);\n-//      _8 = const guard() -> [return: bb10, unwind: bb1];\n+//      _8 = const guard() -> [return: bb8, unwind: bb1];\n //  }\n-//  bb10: { //end of guard\n+//  bb8: { //end of guard1\n //      FakeRead(ForMatchGuard, _5);\n //      FakeRead(ForGuardBinding, _7);\n-//      switchInt(move _8) -> [false: bb7, otherwise: bb11];\n+//      switchInt(move _8) -> [false: bb10, otherwise: bb9];\n //  }\n-//  bb11: { // set up bindings for arm1\n+//  bb9: {\n+//      StorageDead(_8);\n //      StorageLive(_6);\n //      _6 = ((_2 as Some).0: i32);\n //      _1 = const 1i32;\n+//      StorageDead(_6);\n+//      StorageDead(_7);\n //      goto -> bb17;\n //  }\n-//  bb12: { // binding2 & arm2\n+//  bb10: {\n+//      StorageDead(_8);\n+//      StorageDead(_7);\n+//      falseEdges -> [real: bb3, imaginary: bb3];\n+//  }\n+//  bb11: { // binding2 & arm2\n //      StorageLive(_9);\n //      _9 = _2;\n //      _1 = const 2i32;\n+//      StorageDead(_9);\n //      goto -> bb17;\n //  }\n-//  bb13: { // binding3: Some(y) if guard2(y)\n+//  bb12: { // binding3: Some(y) if guard2(y)\n //      StorageLive(_11);\n //      _11 = &((_2 as Some).0: i32);\n //      _5 = &shallow _2;\n //      StorageLive(_12);\n //      StorageLive(_13);\n //      _13 = (*_11);\n-//      _12 = const guard2(move _13) -> [return: bb14, unwind: bb1];\n+//      _12 = const guard2(move _13) -> [return: bb13, unwind: bb1];\n //  }\n-//  bb14: { // end of guard2\n+//  bb13: { // end of guard2\n //      StorageDead(_13);\n //      FakeRead(ForMatchGuard, _5);\n //      FakeRead(ForGuardBinding, _11);\n-//      switchInt(move _12) -> [false: bb8, otherwise: bb15];\n+//      switchInt(move _12) -> [false: bb15, otherwise: bb14];\n //  }\n-//  bb15: { // binding4 & arm4\n+//  bb14: { // binding4 & arm4\n+//      StorageDead(_12);\n //      StorageLive(_10);\n //      _10 = ((_2 as Some).0: i32);\n //      _1 = const 3i32;\n+//      StorageDead(_10);\n+//      StorageDead(_11);\n //      goto -> bb17;\n //  }\n+//  bb15: {\n+//      StorageDead(_12);\n+//      StorageDead(_11);\n+//      falseEdges -> [real: bb5, imaginary: bb5];\n+//  }\n //  bb16: {\n //      StorageLive(_14);\n //      _14 = _2;\n //      _1 = const 4i32;\n+//      StorageDead(_14);\n //      goto -> bb17;\n //  }\n //  bb17: {\n-//      ...\n+//      StorageDead(_2);\n+//      StorageDead(_1);\n+//      _0 = ();\n //      return;\n //  }\n // END rustc.main.QualifyAndPromoteConstants.before.mir"}, {"sha": "2ef9520c12c637e54c6bb00191c85d01f950a583", "filename": "src/test/mir-opt/match_test.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_test.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -20,10 +20,10 @@ fn main() {\n // START rustc.main.SimplifyCfg-initial.after.mir\n //    bb0: {\n //        ...\n-//        switchInt(move _4) -> [false: bb7, otherwise: bb8];\n+//        switchInt(move _4) -> [false: bb6, otherwise: bb7];\n //    }\n //    bb1: {\n-//        falseEdges -> [real: bb12, imaginary: bb2];\n+//        falseEdges -> [real: bb10, imaginary: bb2];\n //    }\n //    bb2: {\n //        falseEdges -> [real: bb13, imaginary: bb3];\n@@ -38,33 +38,35 @@ fn main() {\n //        unreachable;\n //    }\n //    bb6: {\n-//        falseEdges -> [real: bb4, imaginary: bb2];\n+//        _6 = Le(const 10i32, _1);\n+//        switchInt(move _6) -> [false: bb8, otherwise: bb9];\n //    }\n //    bb7: {\n-//        _6 = Le(const 10i32, _1);\n-//        switchInt(move _6) -> [false: bb9, otherwise: bb10];\n+//        _5 = Lt(_1, const 10i32);\n+//        switchInt(move _5) -> [false: bb6, otherwise: bb1];\n //    }\n //    bb8: {\n-//        _5 = Lt(_1, const 10i32);\n-//        switchInt(move _5) -> [false: bb7, otherwise: bb1];\n+//        switchInt(_1) -> [-1i32: bb3, otherwise: bb4];\n //    }\n //    bb9: {\n-//        switchInt(_1) -> [-1i32: bb3, otherwise: bb4];\n+//        _7 = Le(_1, const 20i32);\n+//        switchInt(move _7) -> [false: bb8, otherwise: bb2];\n //    }\n //    bb10: {\n-//        _7 = Le(_1, const 20i32);\n-//        switchInt(move _7) -> [false: bb9, otherwise: bb2];\n+//        _8 = &shallow _1;\n+//        StorageLive(_9);\n+//        _9 = _2;\n+//        FakeRead(ForMatchGuard, _8);\n+//        switchInt(move _9) -> [false: bb12, otherwise: bb11];\n //    }\n //    bb11: {\n+//        StorageDead(_9);\n //        _3 = const 0i32;\n //        goto -> bb16;\n //    }\n //    bb12: {\n-//        _8 = &shallow _1;\n-//        StorageLive(_9);\n-//        _9 = _2;\n-//        FakeRead(ForMatchGuard, _8);\n-//        switchInt(move _9) -> [false: bb6, otherwise: bb11];\n+//        StorageDead(_9);\n+//        falseEdges -> [real: bb4, imaginary: bb2];\n //    }\n //    bb13: {\n //        _3 = const 1i32;\n@@ -79,7 +81,6 @@ fn main() {\n //        goto -> bb16;\n //    }\n //    bb16: {\n-//        StorageDead(_9);\n //        _0 = ();\n //        StorageDead(_2);\n //        StorageDead(_1);"}, {"sha": "da73cc96348f059e4c15e29ce839204b2b824ed4", "filename": "src/test/mir-opt/packed-struct-drop-aligned.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -18,15 +18,13 @@ impl Drop for Droppy {\n // START rustc.main.EraseRegions.before.mir\n // fn main() -> () {\n //     let mut _0: ();\n+//     let mut _1: Packed;\n //     let mut _2: Aligned;\n //     let mut _3: Droppy;\n //     let mut _4: Aligned;\n //     let mut _5: Droppy;\n //     let mut _6: Aligned;\n //     scope 1 {\n-//         let mut _1: Packed;\n-//     }\n-//     scope 2 {\n //     }\n //\n //     bb0: {"}, {"sha": "6ac9cee79f53a82e53ace7b82f2c3f3a284ac84b", "filename": "src/test/mir-opt/remove_fake_borrows.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -19,10 +19,10 @@ fn main() {\n // bb0: {\n //     FakeRead(ForMatchedPlace, _1);\n //     _3 = discriminant(_1);\n-//     switchInt(move _3) -> [1isize: bb5, otherwise: bb2];\n+//     switchInt(move _3) -> [1isize: bb4, otherwise: bb2];\n // }\n // bb1: {\n-//     goto -> bb7;\n+//     goto -> bb5;\n // }\n // bb2: {\n //     goto -> bb8;\n@@ -31,16 +31,9 @@ fn main() {\n //     unreachable;\n // }\n // bb4: {\n-//     goto -> bb2;\n-// }\n-// bb5: {\n //     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb1, otherwise: bb2];\n // }\n-// bb6: {\n-//     _0 = const 0i32;\n-//     goto -> bb9;\n-// }\n-// bb7: {\n+// bb5: {\n //     _4 = &shallow _1;\n //     _5 = &shallow ((_1 as Some).0: &'<empty> &'<empty> i32);\n //     _6 = &shallow (*((_1 as Some).0: &'<empty> &'<empty> i32));\n@@ -51,14 +44,22 @@ fn main() {\n //     FakeRead(ForMatchGuard, _5);\n //     FakeRead(ForMatchGuard, _6);\n //     FakeRead(ForMatchGuard, _7);\n-//     switchInt(move _8) -> [false: bb4, otherwise: bb6];\n+//     switchInt(move _8) -> [false: bb7, otherwise: bb6];\n+// }\n+// bb6: {\n+//     StorageDead(_8);\n+//     _0 = const 0i32;\n+//     goto -> bb9;\n+// }\n+// bb7: {\n+//     StorageDead(_8);\n+//     goto -> bb2;\n // }\n // bb8: {\n //     _0 = const 1i32;\n //     goto -> bb9;\n // }\n // bb9: {\n-//     StorageDead(_8);\n //     return;\n // }\n // bb10 (cleanup): {\n@@ -70,10 +71,10 @@ fn main() {\n // bb0: {\n //     nop;\n //     _3 = discriminant(_1);\n-//     switchInt(move _3) -> [1isize: bb5, otherwise: bb2];\n+//     switchInt(move _3) -> [1isize: bb4, otherwise: bb2];\n // }\n // bb1: {\n-//     goto -> bb7;\n+//     goto -> bb5;\n // }\n // bb2: {\n //     goto -> bb8;\n@@ -82,16 +83,9 @@ fn main() {\n //     unreachable;\n // }\n // bb4: {\n-//     goto -> bb2;\n-// }\n-// bb5: {\n //     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb1, otherwise: bb2];\n // }\n-// bb6: {\n-//     _0 = const 0i32;\n-//     goto -> bb9;\n-// }\n-// bb7: {\n+// bb5: {\n //     nop;\n //     nop;\n //     nop;\n@@ -102,14 +96,22 @@ fn main() {\n //     nop;\n //     nop;\n //     nop;\n-//     switchInt(move _8) -> [false: bb4, otherwise: bb6];\n+//     switchInt(move _8) -> [false: bb7, otherwise: bb6];\n+// }\n+// bb6: {\n+//     StorageDead(_8);\n+//     _0 = const 0i32;\n+//     goto -> bb9;\n+// }\n+// bb7: {\n+//     StorageDead(_8);\n+//     goto -> bb2;\n // }\n // bb8: {\n //     _0 = const 1i32;\n //     goto -> bb9;\n // }\n // bb9: {\n-//     StorageDead(_8);\n //     return;\n // }\n // bb10 (cleanup): {"}, {"sha": "2ed34ecfad2c6317f8f4b9a07db528b963ff26e9", "filename": "src/test/mir-opt/storage_live_dead_in_statics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -182,8 +182,8 @@ fn main() {\n //        _2 = Foo { tup: const \"hi\", data: move _3 };\n //        _1 = &_2;\n //        _0 = &(*_1);\n-//        StorageDead(_1);\n //        StorageDead(_5);\n+//        StorageDead(_1);\n //        return;\n //    }\n //}"}, {"sha": "2c471a61054b2662a3cbeb40391293ddf539b6d4", "filename": "src/test/ui/lint/lint-match-arms.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fui%2Flint%2Flint-match-arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fui%2Flint%2Flint-match-arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-match-arms.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -0,0 +1,18 @@\n+fn deny_on_arm() {\n+    match 0 {\n+        #[deny(unused_variables)]\n+        //~^ NOTE lint level defined here\n+        y => (),\n+        //~^ ERROR unused variable\n+    }\n+}\n+\n+#[deny(unused_variables)]\n+fn allow_on_arm() {\n+    match 0 {\n+        #[allow(unused_variables)]\n+        y => (), // OK\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e4e3adab0a9b201aac2006f492e30fd4d432661b", "filename": "src/test/ui/lint/lint-match-arms.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fui%2Flint%2Flint-match-arms.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fui%2Flint%2Flint-match-arms.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-match-arms.stderr?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -0,0 +1,14 @@\n+error: unused variable: `y`\n+  --> $DIR/lint-match-arms.rs:5:9\n+   |\n+LL |         y => (),\n+   |         ^ help: consider prefixing with an underscore: `_y`\n+   |\n+note: lint level defined here\n+  --> $DIR/lint-match-arms.rs:3:16\n+   |\n+LL |         #[deny(unused_variables)]\n+   |                ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "78609a6e24b5eefd783900ca4485d0d4e01c43ed", "filename": "src/test/ui/lint/lint-unused-mut-variables.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -105,6 +105,14 @@ fn main() {\n       _ => {}\n     }\n \n+    // Attribute should be respected on match arms\n+    match 0 {\n+        #[allow(unused_mut)]\n+        mut x => {\n+            let mut y = 1;\n+        },\n+    }\n+\n     let x = |mut y: isize| y = 32;\n     fn nothing(mut foo: isize) { foo = 37; }\n "}, {"sha": "1a175c9683ec729642b81dae0050c1299e65a14c", "filename": "src/test/ui/lint/lint-unused-mut-variables.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85334c50921a1c90707c9d0fb344c63bd373e1b8/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr?ref=85334c50921a1c90707c9d0fb344c63bd373e1b8", "patch": "@@ -133,15 +133,15 @@ LL |     fn mut_ref_arg(mut arg : &mut [u8]) -> &mut [u8] {\n    |                    help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:130:9\n+  --> $DIR/lint-unused-mut-variables.rs:138:9\n    |\n LL |     let mut b = vec![2];\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n    |\n note: lint level defined here\n-  --> $DIR/lint-unused-mut-variables.rs:126:8\n+  --> $DIR/lint-unused-mut-variables.rs:134:8\n    |\n LL | #[deny(unused_mut)]\n    |        ^^^^^^^^^^"}]}