{"sha": "2404a067eedd83ab69bb0e07fdc8145825741722", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0MDRhMDY3ZWVkZDgzYWI2OWJiMGUwN2ZkYzgxNDU4MjU3NDE3MjI=", "commit": {"author": {"name": "\u00d6mer Sinan A\u011facan", "email": "omeragacan@gmail.com", "date": "2019-12-05T07:40:24Z"}, "committer": {"name": "\u00d6mer Sinan A\u011facan", "email": "omeragacan@gmail.com", "date": "2019-12-06T16:36:34Z"}, "message": "const-prop: Restrict scalar pair propagation\n\nWe now only propagate a scalar pair if the Rvalue is a tuple with two\nscalars. This for example avoids propagating a (u8, u8) value when\nRvalue has type `((), u8, u8)` (see the regression test). While this is\na correct thing to do, implementation is tricky and will be done later.\n\nFixes #66971\nFixes #66339\nFixes #67019", "tree": {"sha": "a495185c7617b7195398a520cc3fb61402aa2973", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a495185c7617b7195398a520cc3fb61402aa2973"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2404a067eedd83ab69bb0e07fdc8145825741722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2404a067eedd83ab69bb0e07fdc8145825741722", "html_url": "https://github.com/rust-lang/rust/commit/2404a067eedd83ab69bb0e07fdc8145825741722", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2404a067eedd83ab69bb0e07fdc8145825741722/comments", "author": {"login": "osa1", "id": 448274, "node_id": "MDQ6VXNlcjQ0ODI3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/448274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/osa1", "html_url": "https://github.com/osa1", "followers_url": "https://api.github.com/users/osa1/followers", "following_url": "https://api.github.com/users/osa1/following{/other_user}", "gists_url": "https://api.github.com/users/osa1/gists{/gist_id}", "starred_url": "https://api.github.com/users/osa1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/osa1/subscriptions", "organizations_url": "https://api.github.com/users/osa1/orgs", "repos_url": "https://api.github.com/users/osa1/repos", "events_url": "https://api.github.com/users/osa1/events{/privacy}", "received_events_url": "https://api.github.com/users/osa1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "osa1", "id": 448274, "node_id": "MDQ6VXNlcjQ0ODI3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/448274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/osa1", "html_url": "https://github.com/osa1", "followers_url": "https://api.github.com/users/osa1/followers", "following_url": "https://api.github.com/users/osa1/following{/other_user}", "gists_url": "https://api.github.com/users/osa1/gists{/gist_id}", "starred_url": "https://api.github.com/users/osa1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/osa1/subscriptions", "organizations_url": "https://api.github.com/users/osa1/orgs", "repos_url": "https://api.github.com/users/osa1/repos", "events_url": "https://api.github.com/users/osa1/events{/privacy}", "received_events_url": "https://api.github.com/users/osa1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0126e8ed3cc0d6fcb9dd44c36a46f9ce65010a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0126e8ed3cc0d6fcb9dd44c36a46f9ce65010a0", "html_url": "https://github.com/rust-lang/rust/commit/d0126e8ed3cc0d6fcb9dd44c36a46f9ce65010a0"}], "stats": {"total": 141, "additions": 130, "deletions": 11}, "files": [{"sha": "a147ad3bb1e22a79309f5b575bca03e93fd2816f", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2404a067eedd83ab69bb0e07fdc8145825741722/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2404a067eedd83ab69bb0e07fdc8145825741722/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=2404a067eedd83ab69bb0e07fdc8145825741722", "patch": "@@ -636,19 +636,45 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     ScalarMaybeUndef::Scalar(one),\n                     ScalarMaybeUndef::Scalar(two)\n                 ) => {\n+                    // Found a value represented as a pair. For now only do cont-prop if type of\n+                    // Rvalue is also a pair with two scalars. The more general case is more\n+                    // complicated to implement so we'll do it later.\n                     let ty = &value.layout.ty.kind;\n+                    // Only do it for tuples\n                     if let ty::Tuple(substs) = ty {\n-                        *rval = Rvalue::Aggregate(\n-                            Box::new(AggregateKind::Tuple),\n-                            vec![\n-                                self.operand_from_scalar(\n-                                    one, substs[0].expect_ty(), source_info.span\n-                                ),\n-                                self.operand_from_scalar(\n-                                    two, substs[1].expect_ty(), source_info.span\n-                                ),\n-                            ],\n-                        );\n+                        // Only do it if tuple is also a pair with two scalars\n+                        if substs.len() == 2 {\n+                            let opt_ty1_ty2 = self.use_ecx(source_info, |this| {\n+                                let ty1 = substs[0].expect_ty();\n+                                let ty2 = substs[1].expect_ty();\n+                                let ty_is_scalar = |ty| {\n+                                    this.ecx\n+                                        .layout_of(ty)\n+                                        .ok()\n+                                        .map(|ty| ty.details.abi.is_scalar())\n+                                        == Some(true)\n+                                };\n+                                if ty_is_scalar(ty1) && ty_is_scalar(ty2) {\n+                                    Ok(Some((ty1, ty2)))\n+                                } else {\n+                                    Ok(None)\n+                                }\n+                            });\n+\n+                            if let Some(Some((ty1, ty2))) = opt_ty1_ty2 {\n+                                *rval = Rvalue::Aggregate(\n+                                    Box::new(AggregateKind::Tuple),\n+                                    vec![\n+                                        self.operand_from_scalar(\n+                                            one, ty1, source_info.span\n+                                        ),\n+                                        self.operand_from_scalar(\n+                                            two, ty2, source_info.span\n+                                        ),\n+                                    ],\n+                                );\n+                            }\n+                        }\n                     }\n                 },\n                 _ => { }"}, {"sha": "b0bc052929768308fb5f912f25e9eb2296a6f8ea", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2404a067eedd83ab69bb0e07fdc8145825741722/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2404a067eedd83ab69bb0e07fdc8145825741722/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=2404a067eedd83ab69bb0e07fdc8145825741722", "patch": "@@ -802,6 +802,14 @@ impl Abi {\n             _ => false,\n         }\n     }\n+\n+    /// Returns `true` is this is a scalar type\n+    pub fn is_scalar(&self) -> bool {\n+        match *self {\n+            Abi::Scalar(_) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n rustc_index::newtype_index! {"}, {"sha": "30c75303b3e53ccd2973a0929fb70605fc86e6ff", "filename": "src/test/mir-opt/const_prop/issue-66971.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2404a067eedd83ab69bb0e07fdc8145825741722/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-66971.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2404a067eedd83ab69bb0e07fdc8145825741722/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-66971.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-66971.rs?ref=2404a067eedd83ab69bb0e07fdc8145825741722", "patch": "@@ -0,0 +1,38 @@\n+// compile-flags: -Z mir-opt-level=2\n+\n+// Due to a bug in propagating scalar pairs the assertion below used to fail. In the expected\n+// outputs below, after ConstProp this is how _2 would look like with the bug:\n+//\n+//     _2 = (const Scalar(0x00) : (), const 0u8);\n+//\n+// Which has the wrong type.\n+\n+fn encode(this: ((), u8, u8)) {\n+    assert!(this.2 == 0);\n+}\n+\n+fn main() {\n+    encode(((), 0, 0));\n+}\n+\n+// END RUST SOURCE\n+// START rustc.main.ConstProp.before.mir\n+//  bb0: {\n+//      ...\n+//      _3 = ();\n+//      _2 = (move _3, const 0u8, const 0u8);\n+//      ...\n+//      _1 = const encode(move _2) -> bb1;\n+//      ...\n+//  }\n+// END rustc.main.ConstProp.before.mir\n+// START rustc.main.ConstProp.after.mir\n+//  bb0: {\n+//      ...\n+//      _3 = const Scalar(<ZST>) : ();\n+//      _2 = (move _3, const 0u8, const 0u8);\n+//      ...\n+//      _1 = const encode(move _2) -> bb1;\n+//      ...\n+//  }\n+// END rustc.main.ConstProp.after.mir"}, {"sha": "c6d753a1209cd5b03b6a543a0c10aa784bb06b3e", "filename": "src/test/mir-opt/const_prop/issue-67019.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2404a067eedd83ab69bb0e07fdc8145825741722/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-67019.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2404a067eedd83ab69bb0e07fdc8145825741722/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-67019.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-67019.rs?ref=2404a067eedd83ab69bb0e07fdc8145825741722", "patch": "@@ -0,0 +1,34 @@\n+// compile-flags: -Z mir-opt-level=2\n+\n+// This used to ICE in const-prop\n+\n+fn test(this: ((u8, u8),)) {\n+    assert!((this.0).0 == 1);\n+}\n+\n+fn main() {\n+    test(((1, 2),));\n+}\n+\n+// Important bit is parameter passing so we only check that below\n+// END RUST SOURCE\n+// START rustc.main.ConstProp.before.mir\n+//  bb0: {\n+//      ...\n+//      _3 = (const 1u8, const 2u8);\n+//      _2 = (move _3,);\n+//      ...\n+//      _1 = const test(move _2) -> bb1;\n+//      ...\n+//  }\n+// END rustc.main.ConstProp.before.mir\n+// START rustc.main.ConstProp.after.mir\n+//  bb0: {\n+//      ...\n+//      _3 = (const 1u8, const 2u8);\n+//      _2 = (move _3,);\n+//      ...\n+//      _1 = const test(move _2) -> bb1;\n+//      ...\n+//  }\n+// END rustc.main.ConstProp.after.mir"}, {"sha": "98e178c05514672e41ae5bac7cf945df42d9afbf", "filename": "src/test/ui/mir/issue66339.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2404a067eedd83ab69bb0e07fdc8145825741722/src%2Ftest%2Fui%2Fmir%2Fissue66339.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2404a067eedd83ab69bb0e07fdc8145825741722/src%2Ftest%2Fui%2Fmir%2Fissue66339.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fissue66339.rs?ref=2404a067eedd83ab69bb0e07fdc8145825741722", "patch": "@@ -0,0 +1,13 @@\n+// compile-flags: -Z mir-opt-level=2\n+// build-pass\n+\n+// This used to ICE in const-prop\n+\n+fn foo() {\n+    let bar = |_| { };\n+    let _ = bar(\"a\");\n+}\n+\n+fn main() {\n+    foo();\n+}"}]}