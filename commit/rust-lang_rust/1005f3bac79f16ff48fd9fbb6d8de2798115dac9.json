{"sha": "1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMDVmM2JhYzc5ZjE2ZmY0OGZkOWZiYjZkOGRlMjc5ODExNWRhYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-22T06:52:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-22T06:52:39Z"}, "message": "Auto merge of #56113 - spastorino:erroneous-loop-diagnostic-in-nll, r=pnkfelix\n\nErroneous loop diagnostic in nll\n\nCloses #53773\n\nr? @nikomatsakis", "tree": {"sha": "0b58a88e73f261f386891d5ab8f1daf8c3f45b0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b58a88e73f261f386891d5ab8f1daf8c3f45b0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "html_url": "https://github.com/rust-lang/rust/commit/1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6fd02772bdfa8934bedd1823b563ae3a76074e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6fd02772bdfa8934bedd1823b563ae3a76074e6", "html_url": "https://github.com/rust-lang/rust/commit/c6fd02772bdfa8934bedd1823b563ae3a76074e6"}, {"sha": "a12982cdc2fee3d892015ee981a2f98481f831f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a12982cdc2fee3d892015ee981a2f98481f831f0", "html_url": "https://github.com/rust-lang/rust/commit/a12982cdc2fee3d892015ee981a2f98481f831f0"}], "stats": {"total": 555, "additions": 361, "deletions": 194}, "files": [{"sha": "7d6385752c34877337051de5da7e24a96b5c2663", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/find_use.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs?ref=1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "patch": "@@ -65,10 +65,7 @@ impl<'cx, 'gcx, 'tcx> UseFinder<'cx, 'gcx, 'tcx> {\n \n                 None => {\n                     if p.statement_index < block_data.statements.len() {\n-                        queue.push_back(Location {\n-                            statement_index: p.statement_index + 1,\n-                            ..p\n-                        });\n+                        queue.push_back(p.successor_within_block());\n                     } else {\n                         queue.extend(\n                             block_data"}, {"sha": "8ea249959dd2c284e1c113770784f74a92a5d497", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 278, "deletions": 173, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "patch": "@@ -1,14 +1,16 @@\n+use std::collections::VecDeque;\n+\n use crate::borrow_check::borrow_set::BorrowData;\n use crate::borrow_check::error_reporting::UseSpans;\n-use crate::borrow_check::nll::ConstraintDescription;\n use crate::borrow_check::nll::region_infer::{Cause, RegionName};\n+use crate::borrow_check::nll::ConstraintDescription;\n use crate::borrow_check::{Context, MirBorrowckCtxt, WriteKind};\n-use rustc::ty::{self, TyCtxt};\n use rustc::mir::{\n-    CastKind, ConstraintCategory, FakeReadCause, Local, Location, Mir, Operand,\n-    Place, Projection, ProjectionElem, Rvalue, Statement, StatementKind,\n-    TerminatorKind\n+    CastKind, ConstraintCategory, FakeReadCause, Local, Location, Mir, Operand, Place, Projection,\n+    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind,\n };\n+use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n@@ -60,50 +62,58 @@ impl BorrowExplanation {\n                 let message = match later_use_kind {\n                     LaterUseKind::TraitCapture => \"borrow later captured here by trait object\",\n                     LaterUseKind::ClosureCapture => \"borrow later captured here by closure\",\n-                    LaterUseKind::Call =>  \"borrow later used by call\",\n+                    LaterUseKind::Call => \"borrow later used by call\",\n                     LaterUseKind::FakeLetRead => \"borrow later stored here\",\n                     LaterUseKind::Other => \"borrow later used here\",\n                 };\n                 err.span_label(var_or_use_span, format!(\"{}{}\", borrow_desc, message));\n-            },\n+            }\n             BorrowExplanation::UsedLaterInLoop(later_use_kind, var_or_use_span) => {\n                 let message = match later_use_kind {\n-                    LaterUseKind::TraitCapture =>\n-                        \"borrow captured here by trait object, in later iteration of loop\",\n-                    LaterUseKind::ClosureCapture =>\n-                        \"borrow captured here by closure, in later iteration of loop\",\n-                    LaterUseKind::Call =>  \"borrow used by call, in later iteration of loop\",\n+                    LaterUseKind::TraitCapture => {\n+                        \"borrow captured here by trait object, in later iteration of loop\"\n+                    }\n+                    LaterUseKind::ClosureCapture => {\n+                        \"borrow captured here by closure, in later iteration of loop\"\n+                    }\n+                    LaterUseKind::Call => \"borrow used by call, in later iteration of loop\",\n                     LaterUseKind::FakeLetRead => \"borrow later stored here\",\n                     LaterUseKind::Other => \"borrow used here, in later iteration of loop\",\n                 };\n                 err.span_label(var_or_use_span, format!(\"{}{}\", borrow_desc, message));\n-            },\n-            BorrowExplanation::UsedLaterWhenDropped { drop_loc, dropped_local,\n-                                                      should_note_order } =>\n-            {\n+            }\n+            BorrowExplanation::UsedLaterWhenDropped {\n+                drop_loc,\n+                dropped_local,\n+                should_note_order,\n+            } => {\n                 let local_decl = &mir.local_decls[dropped_local];\n                 let (dtor_desc, type_desc) = match local_decl.ty.sty {\n                     // If type is an ADT that implements Drop, then\n                     // simplify output by reporting just the ADT name.\n-                    ty::Adt(adt, _substs) if adt.has_dtor(tcx) && !adt.is_box() =>\n-                        (\"`Drop` code\", format!(\"type `{}`\", tcx.item_path_str(adt.did))),\n+                    ty::Adt(adt, _substs) if adt.has_dtor(tcx) && !adt.is_box() => (\n+                        \"`Drop` code\",\n+                        format!(\"type `{}`\", tcx.item_path_str(adt.did)),\n+                    ),\n \n                     // Otherwise, just report the whole type (and use\n                     // the intentionally fuzzy phrase \"destructor\")\n-                    ty::Closure(..) =>\n-                        (\"destructor\", \"closure\".to_owned()),\n-                    ty::Generator(..) =>\n-                        (\"destructor\", \"generator\".to_owned()),\n+                    ty::Closure(..) => (\"destructor\", \"closure\".to_owned()),\n+                    ty::Generator(..) => (\"destructor\", \"generator\".to_owned()),\n \n                     _ => (\"destructor\", format!(\"type `{}`\", local_decl.ty)),\n                 };\n \n                 match local_decl.name {\n                     Some(local_name) => {\n-                        let message =\n-                            format!(\"{B}borrow might be used here, when `{LOC}` is dropped \\\n-                                     and runs the {DTOR} for {TYPE}\",\n-                                    B=borrow_desc, LOC=local_name, TYPE=type_desc, DTOR=dtor_desc);\n+                        let message = format!(\n+                            \"{B}borrow might be used here, when `{LOC}` is dropped \\\n+                             and runs the {DTOR} for {TYPE}\",\n+                            B = borrow_desc,\n+                            LOC = local_name,\n+                            TYPE = type_desc,\n+                            DTOR = dtor_desc\n+                        );\n                         err.span_label(mir.source_info(drop_loc).span, message);\n \n                         if should_note_order {\n@@ -114,15 +124,22 @@ impl BorrowExplanation {\n                         }\n                     }\n                     None => {\n-                        err.span_label(local_decl.source_info.span,\n-                                       format!(\"a temporary with access to the {B}borrow \\\n-                                                is created here ...\",\n-                                               B=borrow_desc));\n-                        let message =\n-                            format!(\"... and the {B}borrow might be used here, \\\n-                                     when that temporary is dropped \\\n-                                     and runs the {DTOR} for {TYPE}\",\n-                                    B=borrow_desc, TYPE=type_desc, DTOR=dtor_desc);\n+                        err.span_label(\n+                            local_decl.source_info.span,\n+                            format!(\n+                                \"a temporary with access to the {B}borrow \\\n+                                 is created here ...\",\n+                                B = borrow_desc\n+                            ),\n+                        );\n+                        let message = format!(\n+                            \"... and the {B}borrow might be used here, \\\n+                             when that temporary is dropped \\\n+                             and runs the {DTOR} for {TYPE}\",\n+                            B = borrow_desc,\n+                            TYPE = type_desc,\n+                            DTOR = dtor_desc\n+                        );\n                         err.span_label(mir.source_info(drop_loc).span, message);\n \n                         if let Some(info) = &local_decl.is_block_tail {\n@@ -146,7 +163,7 @@ impl BorrowExplanation {\n                         }\n                     }\n                 }\n-            },\n+            }\n             BorrowExplanation::MustBeValidFor {\n                 category,\n                 span,\n@@ -157,18 +174,28 @@ impl BorrowExplanation {\n                 region_name.highlight_region_name(err);\n \n                 if let Some(desc) = opt_place_desc {\n-                    err.span_label(span, format!(\n-                        \"{}requires that `{}` is borrowed for `{}`\",\n-                        category.description(), desc, region_name,\n-                    ));\n+                    err.span_label(\n+                        span,\n+                        format!(\n+                            \"{}requires that `{}` is borrowed for `{}`\",\n+                            category.description(),\n+                            desc,\n+                            region_name,\n+                        ),\n+                    );\n                 } else {\n-                    err.span_label(span, format!(\n-                        \"{}requires that {}borrow lasts for `{}`\",\n-                        category.description(), borrow_desc, region_name,\n-                    ));\n+                    err.span_label(\n+                        span,\n+                        format!(\n+                            \"{}requires that {}borrow lasts for `{}`\",\n+                            category.description(),\n+                            borrow_desc,\n+                            region_name,\n+                        ),\n+                    );\n                 };\n-            },\n-            _ => {},\n+            }\n+            _ => {}\n         }\n     }\n }\n@@ -214,13 +241,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             region_sub\n         );\n \n-         match find_use::find(mir, regioncx, tcx, region_sub, context.loc) {\n+        match find_use::find(mir, regioncx, tcx, region_sub, context.loc) {\n             Some(Cause::LiveVar(local, location)) => {\n                 let span = mir.source_info(location).span;\n-                let spans = self.move_spans(&Place::Local(local), location)\n+                let spans = self\n+                    .move_spans(&Place::Local(local), location)\n                     .or_else(|| self.borrow_spans(span, location));\n \n-                if self.is_borrow_location_in_loop(context.loc) {\n+                let borrow_location = context.loc;\n+                if self.is_use_in_later_iteration_of_loop(borrow_location, location) {\n                     let later_use = self.later_use_kind(borrow, spans, location);\n                     BorrowExplanation::UsedLaterInLoop(later_use.0, later_use.1)\n                 } else {\n@@ -232,155 +261,223 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-             Some(Cause::DropVar(local, location)) => {\n-                 let mut should_note_order = false;\n-                 if mir.local_decls[local].name.is_some() {\n-                     if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n-                         if let Place::Local(borrowed_local) = place {\n-                             let dropped_local_scope = mir.local_decls[local].visibility_scope;\n-                             let borrowed_local_scope =\n-                                 mir.local_decls[*borrowed_local].visibility_scope;\n-\n-                             if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope)\n-                                 && local != *borrowed_local\n-                             {\n-                                 should_note_order = true;\n-                             }\n-                         }\n-                     }\n-                 }\n-\n-                 BorrowExplanation::UsedLaterWhenDropped {\n-                     drop_loc: location,\n-                     dropped_local: local,\n-                     should_note_order,\n-                 }\n+            Some(Cause::DropVar(local, location)) => {\n+                let mut should_note_order = false;\n+                if mir.local_decls[local].name.is_some() {\n+                    if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n+                        if let Place::Local(borrowed_local) = place {\n+                            let dropped_local_scope = mir.local_decls[local].visibility_scope;\n+                            let borrowed_local_scope =\n+                                mir.local_decls[*borrowed_local].visibility_scope;\n+\n+                            if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope)\n+                                && local != *borrowed_local\n+                            {\n+                                should_note_order = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                BorrowExplanation::UsedLaterWhenDropped {\n+                    drop_loc: location,\n+                    dropped_local: local,\n+                    should_note_order,\n+                }\n             }\n \n-            None => if let Some(region) = regioncx.to_error_region_vid(borrow_region_vid) {\n-                let (category, from_closure, span, region_name) = self\n-                    .nonlexical_regioncx\n-                    .free_region_constraint_info(\n-                        self.mir,\n-                        self.mir_def_id,\n-                        self.infcx,\n-                        borrow_region_vid,\n-                        region,\n-                    );\n-                if let Some(region_name) = region_name {\n-                    let opt_place_desc = self.describe_place(&borrow.borrowed_place);\n-                    BorrowExplanation::MustBeValidFor {\n-                        category,\n-                        from_closure,\n-                        span,\n-                        region_name,\n-                        opt_place_desc,\n+            None => {\n+                if let Some(region) = regioncx.to_error_region_vid(borrow_region_vid) {\n+                    let (category, from_closure, span, region_name) =\n+                        self.nonlexical_regioncx.free_region_constraint_info(\n+                            self.mir,\n+                            self.mir_def_id,\n+                            self.infcx,\n+                            borrow_region_vid,\n+                            region,\n+                        );\n+                    if let Some(region_name) = region_name {\n+                        let opt_place_desc = self.describe_place(&borrow.borrowed_place);\n+                        BorrowExplanation::MustBeValidFor {\n+                            category,\n+                            from_closure,\n+                            span,\n+                            region_name,\n+                            opt_place_desc,\n+                        }\n+                    } else {\n+                        BorrowExplanation::Unexplained\n                     }\n                 } else {\n                     BorrowExplanation::Unexplained\n                 }\n-            } else {\n-                BorrowExplanation::Unexplained\n             }\n         }\n     }\n \n-    /// Checks if a borrow location is within a loop.\n-    fn is_borrow_location_in_loop(\n+    /// true if `borrow_location` can reach `use_location` by going through a loop and\n+    /// `use_location` is also inside of that loop\n+    fn is_use_in_later_iteration_of_loop(\n         &self,\n         borrow_location: Location,\n+        use_location: Location,\n     ) -> bool {\n-        let mut visited_locations = Vec::new();\n-        let mut pending_locations = vec![ borrow_location ];\n-        debug!(\"is_in_loop: borrow_location={:?}\", borrow_location);\n-\n-        while let Some(location) = pending_locations.pop() {\n-            debug!(\"is_in_loop: location={:?} pending_locations={:?} visited_locations={:?}\",\n-                   location, pending_locations, visited_locations);\n-            if location == borrow_location && visited_locations.contains(&borrow_location) {\n-                // We've managed to return to where we started (and this isn't the start of the\n-                // search).\n-                debug!(\"is_in_loop: found!\");\n-                return true;\n-            }\n+        let back_edge = self.reach_through_backedge(borrow_location, use_location);\n+        back_edge.map_or(false, |back_edge| {\n+            self.can_reach_head_of_loop(use_location, back_edge)\n+        })\n+    }\n \n-            // Skip locations we've been.\n-            if visited_locations.contains(&location) { continue; }\n+    /// Returns the outmost back edge if `from` location can reach `to` location passing through\n+    /// that back edge\n+    fn reach_through_backedge(&self, from: Location, to: Location) -> Option<Location> {\n+        let mut visited_locations = FxHashSet::default();\n+        let mut pending_locations = VecDeque::new();\n+        visited_locations.insert(from);\n+        pending_locations.push_back(from);\n+        debug!(\"reach_through_backedge: from={:?} to={:?}\", from, to,);\n+\n+        let mut outmost_back_edge = None;\n+        while let Some(location) = pending_locations.pop_front() {\n+            debug!(\n+                \"reach_through_backedge: location={:?} outmost_back_edge={:?}\n+                   pending_locations={:?} visited_locations={:?}\",\n+                location, outmost_back_edge, pending_locations, visited_locations\n+            );\n+\n+            if location == to && outmost_back_edge.is_some() {\n+                // We've managed to reach the use location\n+                debug!(\"reach_through_backedge: found!\");\n+                return outmost_back_edge;\n+            }\n \n             let block = &self.mir.basic_blocks()[location.block];\n-            if location.statement_index ==  block.statements.len() {\n-                // Add start location of the next blocks to pending locations.\n-                match block.terminator().kind {\n-                    TerminatorKind::Goto { target } => {\n-                        pending_locations.push(target.start_location());\n-                    },\n-                    TerminatorKind::SwitchInt { ref targets, .. } => {\n-                        pending_locations.extend(\n-                            targets.into_iter().map(|target| target.start_location()));\n-                    },\n-                    TerminatorKind::Drop { target, unwind, .. } |\n-                    TerminatorKind::DropAndReplace { target, unwind, .. } |\n-                    TerminatorKind::Assert { target, cleanup: unwind, .. } |\n-                    TerminatorKind::Yield { resume: target, drop: unwind, .. } |\n-                    TerminatorKind::FalseUnwind { real_target: target, unwind, .. } => {\n-                        pending_locations.push(target.start_location());\n-                        if let Some(unwind) = unwind {\n-                            pending_locations.push(unwind.start_location());\n-                        }\n-                    },\n-                    TerminatorKind::Call { ref destination, cleanup, .. } => {\n-                        if let Some((_, destination)) = destination {\n-                            pending_locations.push(destination.start_location());\n-                        }\n-                        if let Some(cleanup) = cleanup {\n-                            pending_locations.push(cleanup.start_location());\n-                        }\n-                    },\n-                    TerminatorKind::FalseEdges { real_target, ref imaginary_targets, .. } => {\n-                        pending_locations.push(real_target.start_location());\n-                        pending_locations.extend(\n-                            imaginary_targets.into_iter().map(|target| target.start_location()));\n-                    },\n-                    _ => {},\n+\n+            if location.statement_index < block.statements.len() {\n+                let successor = location.successor_within_block();\n+                if visited_locations.insert(successor) {\n+                    pending_locations.push_back(successor);\n                 }\n             } else {\n-                // Add the next statement to pending locations.\n-                pending_locations.push(location.successor_within_block());\n+                pending_locations.extend(\n+                    block\n+                        .terminator()\n+                        .successors()\n+                        .map(|bb| Location {\n+                            statement_index: 0,\n+                            block: *bb,\n+                        })\n+                        .filter(|s| visited_locations.insert(*s))\n+                        .map(|s| {\n+                            if self.is_back_edge(location, s) {\n+                                match outmost_back_edge {\n+                                    None => {\n+                                        outmost_back_edge = Some(location);\n+                                    }\n+\n+                                    Some(back_edge)\n+                                        if location.dominates(back_edge, &self.dominators) =>\n+                                    {\n+                                        outmost_back_edge = Some(location);\n+                                    }\n+\n+                                    Some(_) => {}\n+                                }\n+                            }\n+\n+                            s\n+                        }),\n+                );\n             }\n+        }\n+\n+        None\n+    }\n+\n+    /// true if `from` location can reach `loop_head` location and `loop_head` dominates all the\n+    /// intermediate nodes\n+    fn can_reach_head_of_loop(&self, from: Location, loop_head: Location) -> bool {\n+        self.find_loop_head_dfs(from, loop_head, &mut FxHashSet::default())\n+    }\n \n-            // Keep track of where we have visited.\n-            visited_locations.push(location);\n+    fn find_loop_head_dfs(\n+        &self,\n+        from: Location,\n+        loop_head: Location,\n+        visited_locations: &mut FxHashSet<Location>,\n+    ) -> bool {\n+        visited_locations.insert(from);\n+\n+        if from == loop_head {\n+            return true;\n+        }\n+\n+        if loop_head.dominates(from, &self.dominators) {\n+            let block = &self.mir.basic_blocks()[from.block];\n+\n+            if from.statement_index < block.statements.len() {\n+                let successor = from.successor_within_block();\n+\n+                if !visited_locations.contains(&successor)\n+                    && self.find_loop_head_dfs(successor, loop_head, visited_locations)\n+                {\n+                    return true;\n+                }\n+            } else {\n+                for bb in block.terminator().successors() {\n+                    let successor = Location {\n+                        statement_index: 0,\n+                        block: *bb,\n+                    };\n+\n+                    if !visited_locations.contains(&successor)\n+                        && self.find_loop_head_dfs(successor, loop_head, visited_locations)\n+                    {\n+                        return true;\n+                    }\n+                }\n+            }\n         }\n \n         false\n     }\n \n+    /// True if an edge `source -> target` is a backedge -- in other words, if the target\n+    /// dominates the source.\n+    fn is_back_edge(&self, source: Location, target: Location) -> bool {\n+        target.dominates(source, &self.mir.dominators())\n+    }\n+\n     /// Determine how the borrow was later used.\n     fn later_use_kind(\n         &self,\n         borrow: &BorrowData<'tcx>,\n         use_spans: UseSpans,\n-        location: Location\n+        location: Location,\n     ) -> (LaterUseKind, Span) {\n         match use_spans {\n             UseSpans::ClosureUse { var_span, .. } => {\n                 // Used in a closure.\n                 (LaterUseKind::ClosureCapture, var_span)\n-            },\n+            }\n             UseSpans::OtherUse(span) => {\n                 let block = &self.mir.basic_blocks()[location.block];\n \n                 let kind = if let Some(&Statement {\n                     kind: StatementKind::FakeRead(FakeReadCause::ForLet, _),\n                     ..\n-                }) = block.statements.get(location.statement_index) {\n+                }) = block.statements.get(location.statement_index)\n+                {\n                     LaterUseKind::FakeLetRead\n                 } else if self.was_captured_by_trait_object(borrow) {\n                     LaterUseKind::TraitCapture\n                 } else if location.statement_index == block.statements.len() {\n                     if let TerminatorKind::Call {\n-                        ref func, from_hir_call: true, ..\n-                    } = block.terminator().kind {\n+                        ref func,\n+                        from_hir_call: true,\n+                        ..\n+                    } = block.terminator().kind\n+                    {\n                         // Just point to the function, to reduce the chance of overlapping spans.\n                         let function_span = match func {\n                             Operand::Constant(c) => c.span,\n@@ -391,7 +488,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 } else {\n                                     span\n                                 }\n-                            },\n+                            }\n                             _ => span,\n                         };\n                         return (LaterUseKind::Call, function_span);\n@@ -415,7 +512,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let location = borrow.reserve_location;\n         let block = &self.mir[location.block];\n         let stmt = block.statements.get(location.statement_index);\n-        debug!(\"was_captured_by_trait_object: location={:?} stmt={:?}\", location, stmt);\n+        debug!(\n+            \"was_captured_by_trait_object: location={:?} stmt={:?}\",\n+            location, stmt\n+        );\n \n         // We make a `queue` vector that has the locations we want to visit. As of writing, this\n         // will only ever have one item at any given time, but by using a vector, we can pop from\n@@ -424,13 +524,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let mut target = if let Some(&Statement {\n             kind: StatementKind::Assign(Place::Local(local), _),\n             ..\n-        }) = stmt {\n+        }) = stmt\n+        {\n             local\n         } else {\n             return false;\n         };\n \n-        debug!(\"was_captured_by_trait: target={:?} queue={:?}\", target, queue);\n+        debug!(\n+            \"was_captured_by_trait: target={:?} queue={:?}\",\n+            target, queue\n+        );\n         while let Some(current_location) = queue.pop() {\n             debug!(\"was_captured_by_trait: target={:?}\", target);\n             let block = &self.mir[current_location.block];\n@@ -441,55 +545,55 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 debug!(\"was_captured_by_trait_object: stmt={:?}\", stmt);\n \n                 // The only kind of statement that we care about is assignments...\n-                if let StatementKind::Assign(\n-                    place,\n-                    box rvalue,\n-                ) = &stmt.kind {\n+                if let StatementKind::Assign(place, box rvalue) = &stmt.kind {\n                     let into = match place {\n                         Place::Local(into) => into,\n                         Place::Projection(box Projection {\n                             base: Place::Local(into),\n                             elem: ProjectionElem::Deref,\n                         }) => into,\n-                        _ =>  {\n+                        _ => {\n                             // Continue at the next location.\n                             queue.push(current_location.successor_within_block());\n                             continue;\n-                        },\n+                        }\n                     };\n \n                     match rvalue {\n                         // If we see a use, we should check whether it is our data, and if so\n                         // update the place that we're looking for to that new place.\n                         Rvalue::Use(operand) => match operand {\n-                            Operand::Copy(Place::Local(from)) |\n-                            Operand::Move(Place::Local(from)) if *from == target => {\n+                            Operand::Copy(Place::Local(from))\n+                            | Operand::Move(Place::Local(from))\n+                                if *from == target =>\n+                            {\n                                 target = *into;\n-                            },\n-                            _ => {},\n+                            }\n+                            _ => {}\n                         },\n                         // If we see a unsized cast, then if it is our data we should check\n                         // whether it is being cast to a trait object.\n                         Rvalue::Cast(CastKind::Unsize, operand, ty) => match operand {\n-                            Operand::Copy(Place::Local(from)) |\n-                            Operand::Move(Place::Local(from)) if *from == target => {\n+                            Operand::Copy(Place::Local(from))\n+                            | Operand::Move(Place::Local(from))\n+                                if *from == target =>\n+                            {\n                                 debug!(\"was_captured_by_trait_object: ty={:?}\", ty);\n                                 // Check the type for a trait object.\n                                 return match ty.sty {\n                                     // `&dyn Trait`\n                                     ty::TyKind::Ref(_, ty, _) if ty.is_trait() => true,\n                                     // `Box<dyn Trait>`\n-                                    _ if ty.is_box() && ty.boxed_ty().is_trait() =>\n-                                        true,\n+                                    _ if ty.is_box() && ty.boxed_ty().is_trait() => true,\n                                     // `dyn Trait`\n                                     _ if ty.is_trait() => true,\n                                     // Anything else.\n                                     _ => false,\n                                 };\n-                            },\n+                            }\n                             _ => return false,\n                         },\n-                        _ => {},\n+                        _ => {}\n                     }\n                 }\n \n@@ -504,7 +608,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     destination: Some((Place::Local(dest), block)),\n                     args,\n                     ..\n-                } = &terminator.kind {\n+                } = &terminator.kind\n+                {\n                     debug!(\n                         \"was_captured_by_trait_object: target={:?} dest={:?} args={:?}\",\n                         target, dest, args"}, {"sha": "32ca24ba6ec43a983f6410116e03e2a9da746a14", "filename": "src/test/ui/borrowck/borrowck-for-loop-head-linkage.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-for-loop-head-linkage.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-for-loop-head-linkage.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-for-loop-head-linkage.nll.stderr?ref=1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "patch": "@@ -5,7 +5,7 @@ LL |     for &x in &vector {\n    |               -------\n    |               |\n    |               immutable borrow occurs here\n-   |               immutable borrow used here, in later iteration of loop\n+   |               immutable borrow later used here\n LL |         let cap = vector.capacity();\n LL |         vector.extend(repeat(0));      //~ ERROR cannot borrow\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n@@ -17,7 +17,7 @@ LL |     for &x in &vector {\n    |               -------\n    |               |\n    |               immutable borrow occurs here\n-   |               immutable borrow used here, in later iteration of loop\n+   |               immutable borrow later used here\n ...\n LL |         vector[1] = 5;   //~ ERROR cannot borrow\n    |         ^^^^^^ mutable borrow occurs here"}, {"sha": "396fd6ffa0c6b1aee7a88382d0537dc9f3771118", "filename": "src/test/ui/borrowck/borrowck-lend-flow-loop.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-lend-flow-loop.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-lend-flow-loop.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-lend-flow-loop.nll.stderr?ref=1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "patch": "@@ -8,13 +8,13 @@ LL |         borrow(&*v); //[ast]~ ERROR cannot borrow\n    |                ^^^ immutable borrow occurs here\n ...\n LL |     *x = box 5;\n-   |     -- mutable borrow used here, in later iteration of loop\n+   |     -- mutable borrow later used here\n \n error[E0502]: cannot borrow `*v` as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-lend-flow-loop.rs:109:16\n    |\n LL |         **x += 1;\n-   |         -------- mutable borrow used here, in later iteration of loop\n+   |         -------- mutable borrow later used here\n LL |         borrow(&*v); //[ast]~ ERROR cannot borrow\n    |                ^^^ immutable borrow occurs here\n ..."}, {"sha": "0f077765336086001e4e0a9697df29e265078346", "filename": "src/test/ui/borrowck/borrowck-mut-borrow-linear-errors.ast.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.ast.nll.stderr?ref=1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "patch": "@@ -4,7 +4,7 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n LL |             1 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                    ----      ^^^^^^ second mutable borrow occurs here\n    |                    |\n-   |                    first borrow used here, in later iteration of loop\n+   |                    first borrow later used here\n ...\n LL |             _ => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                              ------ first mutable borrow occurs here\n@@ -13,7 +13,7 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n   --> $DIR/borrowck-mut-borrow-linear-errors.rs:15:30\n    |\n LL |             1 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n-   |                    ---- first borrow used here, in later iteration of loop\n+   |                    ---- first borrow later used here\n LL |             //[mir]~^ ERROR [E0499]\n LL |             2 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                              ^^^^^^ second mutable borrow occurs here"}, {"sha": "0f077765336086001e4e0a9697df29e265078346", "filename": "src/test/ui/borrowck/borrowck-mut-borrow-linear-errors.mir.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.mir.stderr?ref=1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "patch": "@@ -4,7 +4,7 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n LL |             1 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                    ----      ^^^^^^ second mutable borrow occurs here\n    |                    |\n-   |                    first borrow used here, in later iteration of loop\n+   |                    first borrow later used here\n ...\n LL |             _ => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                              ------ first mutable borrow occurs here\n@@ -13,7 +13,7 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n   --> $DIR/borrowck-mut-borrow-linear-errors.rs:15:30\n    |\n LL |             1 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n-   |                    ---- first borrow used here, in later iteration of loop\n+   |                    ---- first borrow later used here\n LL |             //[mir]~^ ERROR [E0499]\n LL |             2 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                              ^^^^^^ second mutable borrow occurs here"}, {"sha": "9b20fc02319344201895887c8e13a91abce0dc5e", "filename": "src/test/ui/borrowck/mut-borrow-outside-loop.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-outside-loop.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-outside-loop.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-outside-loop.nll.stderr?ref=1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "patch": "@@ -17,7 +17,7 @@ LL |         let inner_second = &mut inner_void; //~ ERROR cannot borrow\n    |                            ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n LL |         inner_second.use_mut();\n LL |         inner_first.use_mut();\n-   |         ----------- first borrow used here, in later iteration of loop\n+   |         ----------- first borrow later used here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d231f621e59c7c1e05a4d3380b540c7a5f112154", "filename": "src/test/ui/issues/issue-52126-assign-op-invariance.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fissues%2Fissue-52126-assign-op-invariance.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fissues%2Fissue-52126-assign-op-invariance.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52126-assign-op-invariance.nll.stderr?ref=1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "patch": "@@ -5,7 +5,7 @@ LL |         let v: Vec<&str> = line.split_whitespace().collect();\n    |                            ^^^^ borrowed value does not live long enough\n ...\n LL |         acc += cnt2;\n-   |         --- borrow used here, in later iteration of loop\n+   |         --- borrow later used here\n ...\n LL |     }\n    |     - `line` dropped here while still borrowed"}, {"sha": "62e1631dcf36ffde8e2e3c0afb5de6299c44bf8b", "filename": "src/test/ui/nll/issue-53773.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fnll%2Fissue-53773.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fnll%2Fissue-53773.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-53773.rs?ref=1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "patch": "@@ -0,0 +1,49 @@\n+#![feature(nll)]\n+\n+struct Archive;\n+struct ArchiveIterator<'a> {\n+    x: &'a Archive,\n+}\n+struct ArchiveChild<'a> {\n+    x: &'a Archive,\n+}\n+\n+struct A {\n+    raw: &'static mut Archive,\n+}\n+struct Iter<'a> {\n+    raw: &'a mut ArchiveIterator<'a>,\n+}\n+struct C<'a> {\n+    raw: &'a mut ArchiveChild<'a>,\n+}\n+\n+impl A {\n+    pub fn iter(&self) -> Iter<'_> {\n+        panic!()\n+    }\n+}\n+impl Drop for A {\n+    fn drop(&mut self) {}\n+}\n+impl<'a> Drop for C<'a> {\n+    fn drop(&mut self) {}\n+}\n+\n+impl<'a> Iterator for Iter<'a> {\n+    type Item = C<'a>;\n+    fn next(&mut self) -> Option<C<'a>> {\n+        panic!()\n+    }\n+}\n+\n+fn error(archive: &A) {\n+    let mut members: Vec<&mut ArchiveChild<'_>> = vec![];\n+    for child in archive.iter() {\n+        members.push(child.raw);\n+        //~^ ERROR borrow may still be in use when destructor runs [E0713]\n+    }\n+    members.len();\n+}\n+\n+fn main() {}"}, {"sha": "92a9946068cfe11a32fa6489b169a91758736916", "filename": "src/test/ui/nll/issue-53773.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fnll%2Fissue-53773.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fnll%2Fissue-53773.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-53773.stderr?ref=1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "patch": "@@ -0,0 +1,16 @@\n+error[E0713]: borrow may still be in use when destructor runs\n+  --> $DIR/issue-53773.rs:43:22\n+   |\n+LL |         members.push(child.raw);\n+   |                      ^^^^^^^^^\n+LL |         //~^ ERROR borrow may still be in use when destructor runs [E0713]\n+LL |     }\n+   |     - here, drop of `child` needs exclusive access to `*child.raw`, because the type `C<'_>` implements the `Drop` trait\n+LL |     members.len();\n+   |     ------- borrow later used here\n+   |\n+   = note: consider using a `let` binding to create a longer lived value\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0713`."}, {"sha": "3a6f66ca4dac5439d0dd3a9bedb3a5861e508b5e", "filename": "src/test/ui/rfc-2005-default-binding-mode/borrowck-issue-49631.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fborrowck-issue-49631.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fborrowck-issue-49631.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fborrowck-issue-49631.nll.stderr?ref=1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "patch": "@@ -7,7 +7,7 @@ LL |         foo.mutate();\n    |         ^^^^^^^^^^^^ mutable borrow occurs here\n LL |         //~^ ERROR cannot borrow `foo` as mutable\n LL |         println!(\"foo={:?}\", *string);\n-   |                              ------- immutable borrow used here, in later iteration of loop\n+   |                              ------- immutable borrow later used here\n \n error: aborting due to previous error\n "}, {"sha": "42df668529749df6d739a23fd8c37827cc5fde92", "filename": "src/test/ui/span/regions-escape-loop-via-variable.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-variable.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-variable.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-variable.nll.stderr?ref=1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "patch": "@@ -2,7 +2,7 @@ error[E0597]: `x` does not live long enough\n   --> $DIR/regions-escape-loop-via-variable.rs:11:13\n    |\n LL |         let x = 1 + *p;\n-   |                     -- borrow used here, in later iteration of loop\n+   |                     -- borrow later used here\n LL |         p = &x;\n    |             ^^ borrowed value does not live long enough\n LL |     }"}, {"sha": "e07fb72778210af86eacf6ba367a5d0124eff8c7", "filename": "src/test/ui/span/regions-escape-loop-via-vec.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.nll.stderr?ref=1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "patch": "@@ -7,7 +7,7 @@ LL |     while x < 10 { //~ ERROR cannot use `x` because it was mutably borrowed\n    |           ^ use of borrowed `x`\n LL |         let mut z = x; //~ ERROR cannot use `x` because it was mutably borrowed\n LL |         _y.push(&mut z);\n-   |         -- borrow used here, in later iteration of loop\n+   |         -- borrow later used here\n \n error[E0503]: cannot use `x` because it was mutably borrowed\n   --> $DIR/regions-escape-loop-via-vec.rs:6:21\n@@ -18,15 +18,15 @@ LL |     while x < 10 { //~ ERROR cannot use `x` because it was mutably borrowed\n LL |         let mut z = x; //~ ERROR cannot use `x` because it was mutably borrowed\n    |                     ^ use of borrowed `x`\n LL |         _y.push(&mut z);\n-   |         -- borrow used here, in later iteration of loop\n+   |         -- borrow later used here\n \n error[E0597]: `z` does not live long enough\n   --> $DIR/regions-escape-loop-via-vec.rs:7:17\n    |\n LL |         _y.push(&mut z);\n    |         --      ^^^^^^ borrowed value does not live long enough\n    |         |\n-   |         borrow used here, in later iteration of loop\n+   |         borrow later used here\n ...\n LL |     }\n    |     - `z` dropped here while still borrowed\n@@ -38,7 +38,7 @@ LL |     let mut _y = vec![&mut x];\n    |                       ------ borrow of `x` occurs here\n ...\n LL |         _y.push(&mut z);\n-   |         -- borrow used here, in later iteration of loop\n+   |         -- borrow later used here\n LL |         //~^ ERROR `z` does not live long enough\n LL |         x += 1; //~ ERROR cannot assign\n    |         ^^^^^^ use of borrowed `x`"}, {"sha": "c77be26f0193883029ba698316f27ca55e088bc4", "filename": "src/test/ui/vec/vec-mut-iter-borrow.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fvec%2Fvec-mut-iter-borrow.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1005f3bac79f16ff48fd9fbb6d8de2798115dac9/src%2Ftest%2Fui%2Fvec%2Fvec-mut-iter-borrow.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvec%2Fvec-mut-iter-borrow.nll.stderr?ref=1005f3bac79f16ff48fd9fbb6d8de2798115dac9", "patch": "@@ -5,7 +5,7 @@ LL |     for x in &mut xs {\n    |              -------\n    |              |\n    |              first mutable borrow occurs here\n-   |              first borrow used here, in later iteration of loop\n+   |              first borrow later used here\n LL |         xs.push(1) //~ ERROR cannot borrow `xs`\n    |         ^^ second mutable borrow occurs here\n "}]}