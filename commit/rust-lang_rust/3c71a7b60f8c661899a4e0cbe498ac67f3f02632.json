{"sha": "3c71a7b60f8c661899a4e0cbe498ac67f3f02632", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNzFhN2I2MGY4YzY2MTg5OWE0ZTBjYmU0OThhYzY3ZjNmMDI2MzI=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-12-30T04:43:44Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-02-02T03:01:31Z"}, "message": "Tests for 2229 lint", "tree": {"sha": "d34022a3603cad2b964c3084b9bd635a85fb0e70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d34022a3603cad2b964c3084b9bd635a85fb0e70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c71a7b60f8c661899a4e0cbe498ac67f3f02632", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c71a7b60f8c661899a4e0cbe498ac67f3f02632", "html_url": "https://github.com/rust-lang/rust/commit/3c71a7b60f8c661899a4e0cbe498ac67f3f02632", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c71a7b60f8c661899a4e0cbe498ac67f3f02632/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc5e6db5f2d25fb1c0371455574db7aecbe0ba0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc5e6db5f2d25fb1c0371455574db7aecbe0ba0c", "html_url": "https://github.com/rust-lang/rust/commit/cc5e6db5f2d25fb1c0371455574db7aecbe0ba0c"}], "stats": {"total": 559, "additions": 559, "deletions": 0}, "files": [{"sha": "37fab71be45df24785d89bcb3917e0df4e4bd4b1", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/3c71a7b60f8c661899a4e0cbe498ac67f3f02632/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c71a7b60f8c661899a4e0cbe498ac67f3f02632/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs?ref=3c71a7b60f8c661899a4e0cbe498ac67f3f02632", "patch": "@@ -0,0 +1,130 @@\n+#![deny(disjoint_capture_drop_reorder)]\n+//~^ NOTE: the lint level is defined here\n+\n+// Test cases for types that implement a insignificant drop (stlib defined)\n+\n+// `t` needs Drop because one of its elements needs drop,\n+// therefore precise capture might affect drop ordering\n+fn test1_all_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let t2 = (String::new(), String::new());\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: let (t, t1, t2) = (t, t1, t2);\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2.0;\n+    };\n+\n+    c();\n+}\n+\n+// String implements drop and therefore should be migrated.\n+// But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n+fn test2_only_precise_paths_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let t2 = (String::new(), String::new());\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: let (t, t1) = (t, t1);\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2;\n+    };\n+\n+    c();\n+}\n+\n+// If a variable would've not been captured by value then it would've not been\n+// dropped with the closure and therefore doesn't need migration.\n+fn test3_only_by_value_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: let (t) = (t);\n+        let _t = t.0;\n+        println!(\"{}\", t1.1);\n+    };\n+\n+    c();\n+}\n+\n+// Copy types get copied into the closure instead of move. Therefore we don't need to\n+// migrate then as their drop order isn't tied to the closure.\n+fn test4_only_non_copy_types_need_migration() {\n+    let t = (String::new(), String::new());\n+\n+    // `t1` is Copy because all of its elements are Copy\n+    let t1 = (0i32, 0i32);\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: let (t) = (t);\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+    };\n+\n+    c();\n+}\n+\n+fn test5_only_drop_types_need_migration() {\n+    struct S(i32, i32);\n+\n+    let t = (String::new(), String::new());\n+\n+    // `s` doesn't implement Drop or any elements within it, and doesn't need migration\n+    let s = S(0i32, 0i32);\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: let (t) = (t);\n+        let _t = t.0;\n+        let _s = s.0;\n+    };\n+\n+    c();\n+}\n+\n+// Since we are using a move closure here, both `t` and `t1` get moved\n+// even though they are being used by ref inside the closure.\n+fn test6_move_closures_non_copy_types_might_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let c = move || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: let (t1, t) = (t1, t);\n+        println!(\"{} {}\", t1.1, t.1);\n+    };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Drop + Non Drop aggregates.\n+// Note we need migration here only because the non-copy (because Drop type) is captured,\n+// otherwise we won't need to, since we can get away with just by ref capture in that case.\n+fn test7_drop_non_drop_aggregate_need_migration() {\n+    let t = (String::new(), 0i32);\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: let (t) = (t);\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test1_all_need_migration();\n+    test2_only_precise_paths_need_migration();\n+    test3_only_by_value_need_migration();\n+    test4_only_non_copy_types_need_migration();\n+    test5_only_drop_types_need_migration();\n+    test6_move_closures_non_copy_types_might_need_migration();\n+    test7_drop_non_drop_aggregate_need_migration();\n+}"}, {"sha": "8b35105cf82585881d0b58c7f8810fd79da9b649", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.stderr", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/3c71a7b60f8c661899a4e0cbe498ac67f3f02632/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c71a7b60f8c661899a4e0cbe498ac67f3f02632/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr?ref=3c71a7b60f8c661899a4e0cbe498ac67f3f02632", "patch": "@@ -0,0 +1,105 @@\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:13:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t1 = t1.0;\n+LL | |         let _t2 = t2.0;\n+LL | |     };\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/insignificant_drop.rs:1:9\n+   |\n+LL | #![deny(disjoint_capture_drop_reorder)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: let (t, t1, t2) = (t, t1, t2);\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:31:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t1 = t1.0;\n+LL | |         let _t2 = t2;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: let (t, t1) = (t, t1);\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:47:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         println!(\"{}\", t1.1);\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: let (t) = (t);\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:65:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t1 = t1.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: let (t) = (t);\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:83:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _s = s.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: let (t) = (t);\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:98:13\n+   |\n+LL |       let c = move || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         println!(\"{} {}\", t1.1, t.1);\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: let (t1, t) = (t1, t);\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:113:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: let (t) = (t);\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "73592ce04c28f9cfebdbb727369675d319db2939", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/no_migrations.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/3c71a7b60f8c661899a4e0cbe498ac67f3f02632/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fno_migrations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c71a7b60f8c661899a4e0cbe498ac67f3f02632/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fno_migrations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fno_migrations.rs?ref=3c71a7b60f8c661899a4e0cbe498ac67f3f02632", "patch": "@@ -0,0 +1,84 @@\n+// run-pass\n+\n+// Set of test cases that don't need migrations\n+\n+#![deny(disjoint_capture_drop_reorder)]\n+\n+\n+// Copy types as copied by the closure instead of being moved into the closure\n+// Therefore their drop order isn't tied to the closure and won't be requiring any\n+// migrations.\n+fn test1_only_copy_types() {\n+    let t = (0i32, 0i32);\n+\n+    let c = || {\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+// Same as test1 but using a move closure\n+fn test2_only_copy_types_move_closure() {\n+    let t = (0i32, 0i32);\n+\n+    let c = move || {\n+        println!(\"{}\", t.0);\n+    };\n+\n+    c();\n+}\n+\n+// Don't need to migrate if captured by ref\n+fn test3_only_copy_types_move_closure() {\n+    let t = (String::new(), String::new());\n+\n+    let c = || {\n+        println!(\"{}\", t.0);\n+    };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Insignificant Drop + Non Drop aggregates.\n+// Note in this test the closure captures a non Drop type and therefore the variable\n+// is only captured by ref.\n+fn test4_insignificant_drop_non_drop_aggregate() {\n+    let t = (String::new(), 0i32);\n+\n+    let c = || {\n+        let _t = t.1;\n+    };\n+\n+    c();\n+}\n+\n+\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+// Test migration analysis in case of Significant Drop + Non Drop aggregates.\n+// Note in this test the closure captures a non Drop type and therefore the variable\n+// is only captured by ref.\n+fn test5_significant_drop_non_drop_aggregate() {\n+    let t = (Foo(0), 0i32);\n+\n+    let c = || {\n+        let _t = t.1;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test1_only_copy_types();\n+    test2_only_copy_types_move_closure();\n+    test3_only_copy_types_move_closure();\n+    test4_insignificant_drop_non_drop_aggregate();\n+    test5_significant_drop_non_drop_aggregate();\n+\n+}"}, {"sha": "1818e2dcc647879572c376a4f2e07488fbc0020e", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/3c71a7b60f8c661899a4e0cbe498ac67f3f02632/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c71a7b60f8c661899a4e0cbe498ac67f3f02632/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs?ref=3c71a7b60f8c661899a4e0cbe498ac67f3f02632", "patch": "@@ -0,0 +1,137 @@\n+#![deny(disjoint_capture_drop_reorder)]\n+//~^ NOTE: the lint level is defined here\n+\n+// Test cases for types that implement a significant drop (user defined)\n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct ConstainsDropField(Foo, Foo);\n+\n+// `t` needs Drop because one of its elements needs drop,\n+// therefore precise capture might affect drop ordering\n+fn test1_all_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0));\n+    let t2 = (Foo(0), Foo(0));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: let (t, t1, t2) = (t, t1, t2);\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2.0;\n+    };\n+\n+    c();\n+}\n+\n+// String implements drop and therefore should be migrated.\n+// But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n+fn test2_only_precise_paths_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0));\n+    let t2 = (Foo(0), Foo(0));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: let (t, t1) = (t, t1);\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2;\n+    };\n+\n+    c();\n+}\n+\n+// If a variable would've not been captured by value then it would've not been\n+// dropped with the closure and therefore doesn't need migration.\n+fn test3_only_by_value_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0));\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: let (t) = (t);\n+        let _t = t.0;\n+        println!(\"{:?}\", t1.1);\n+    };\n+\n+    c();\n+}\n+\n+// The root variable might not implement drop themselves but some path starting\n+// at the root variable might implement Drop.\n+//\n+// If this path isn't captured we need to migrate for the root variable.\n+fn test4_type_contains_drop_need_migration() {\n+    let t = ConstainsDropField(Foo(0), Foo(0));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: let (t) = (t);\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Drop + Non Drop aggregates.\n+// Note we need migration here only because the non-copy (because Drop type) is captured,\n+// otherwise we won't need to, since we can get away with just by ref capture in that case.\n+fn test5_drop_non_drop_aggregate_need_migration() {\n+    let t = (Foo(0), 0i32);\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: let (t) = (t);\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Significant and Insignificant Drop aggregates.\n+fn test6_significant_insignificant_drop_aggregate_need_migration() {\n+    struct S(i32, i32);\n+\n+    let t = (Foo(0), String::new());\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: let (t) = (t);\n+        let _t = t.1;\n+    };\n+\n+    c();\n+}\n+\n+// Since we are using a move closure here, both `t` and `t1` get moved\n+// even though they are being used by ref inside the closure.\n+fn test7_move_closures_non_copy_types_might_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0), Foo(0));\n+\n+    let c = move || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: let (t1, t) = (t1, t);\n+        println!(\"{:?} {:?}\", t1.1, t.1);\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test1_all_need_migration();\n+    test2_only_precise_paths_need_migration();\n+    test3_only_by_value_need_migration();\n+    test4_type_contains_drop_need_migration();\n+    test5_drop_non_drop_aggregate_need_migration();\n+    test6_significant_insignificant_drop_aggregate_need_migration();\n+    test7_move_closures_non_copy_types_might_need_migration();\n+}"}, {"sha": "52b6a628cc0ba907d419ff25711a13d37b0cce49", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.stderr", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/3c71a7b60f8c661899a4e0cbe498ac67f3f02632/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c71a7b60f8c661899a4e0cbe498ac67f3f02632/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr?ref=3c71a7b60f8c661899a4e0cbe498ac67f3f02632", "patch": "@@ -0,0 +1,103 @@\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:24:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t1 = t1.0;\n+LL | |         let _t2 = t2.0;\n+LL | |     };\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/significant_drop.rs:1:9\n+   |\n+LL | #![deny(disjoint_capture_drop_reorder)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: let (t, t1, t2) = (t, t1, t2);\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:42:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t1 = t1.0;\n+LL | |         let _t2 = t2;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: let (t, t1) = (t, t1);\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:58:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         println!(\"{:?}\", t1.1);\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: let (t) = (t);\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:75:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: let (t) = (t);\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:90:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: let (t) = (t);\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:105:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.1;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: let (t) = (t);\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:120:13\n+   |\n+LL |       let c = move || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         println!(\"{:?} {:?}\", t1.1, t.1);\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: let (t1, t) = (t1, t);\n+\n+error: aborting due to 7 previous errors\n+"}]}