{"sha": "6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmMGVhMjk5Y2ZjYjk0YWFkNmRjMGE0ZmQwNmFlMDExNTNkYWY4ZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-17T10:28:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-17T10:28:52Z"}, "message": "Auto merge of #77685 - jackh726:binder-map, r=lcnr\n\nUse rebind instead of Binder::bind when possible\n\nThese are really only the easy places. I just searched for `Binder::bind` and replaced where it straightforward.\n\nr? `@lcnr`\ncc. `@nikomatsakis`", "tree": {"sha": "352755212bf75978554c42881b56c37099120047", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/352755212bf75978554c42881b56c37099120047"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "html_url": "https://github.com/rust-lang/rust/commit/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03687f8ffaf5ff03f6bedbe77752b9f930c7efeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/03687f8ffaf5ff03f6bedbe77752b9f930c7efeb", "html_url": "https://github.com/rust-lang/rust/commit/03687f8ffaf5ff03f6bedbe77752b9f930c7efeb"}, {"sha": "f6a53b4c691a5ba5ead6c0c0d072b301de1649f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6a53b4c691a5ba5ead6c0c0d072b301de1649f8", "html_url": "https://github.com/rust-lang/rust/commit/f6a53b4c691a5ba5ead6c0c0d072b301de1649f8"}], "stats": {"total": 333, "additions": 194, "deletions": 139}, "files": [{"sha": "e9900e8bc108ac9f26b72653b1d5541476e2d6ba", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -673,17 +673,9 @@ fn codegen_emcc_try(\n fn gen_fn<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     name: &str,\n-    inputs: Vec<Ty<'tcx>>,\n-    output: Ty<'tcx>,\n+    rust_fn_sig: ty::PolyFnSig<'tcx>,\n     codegen: &mut dyn FnMut(Builder<'_, 'll, 'tcx>),\n ) -> &'ll Value {\n-    let rust_fn_sig = ty::Binder::bind(cx.tcx.mk_fn_sig(\n-        inputs.into_iter(),\n-        output,\n-        false,\n-        hir::Unsafety::Unsafe,\n-        Abi::Rust,\n-    ));\n     let fn_abi = FnAbi::of_fn_ptr(cx, rust_fn_sig, &[]);\n     let llfn = cx.declare_fn(name, &fn_abi);\n     cx.set_frame_pointer_elimination(llfn);\n@@ -710,22 +702,31 @@ fn get_rust_try_fn<'ll, 'tcx>(\n     // Define the type up front for the signature of the rust_try function.\n     let tcx = cx.tcx;\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n-    let try_fn_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n+    // `unsafe fn(*mut i8) -> ()`\n+    let try_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n         iter::once(i8p),\n         tcx.mk_unit(),\n         false,\n         hir::Unsafety::Unsafe,\n         Abi::Rust,\n     )));\n-    let catch_fn_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n+    // `unsafe fn(*mut i8, *mut i8) -> ()`\n+    let catch_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n         [i8p, i8p].iter().cloned(),\n         tcx.mk_unit(),\n         false,\n         hir::Unsafety::Unsafe,\n         Abi::Rust,\n     )));\n-    let output = tcx.types.i32;\n-    let rust_try = gen_fn(cx, \"__rust_try\", vec![try_fn_ty, i8p, catch_fn_ty], output, codegen);\n+    // `unsafe fn(unsafe fn(*mut i8) -> (), *mut i8, unsafe fn(*mut i8, *mut i8) -> ()) -> i32`\n+    let rust_fn_sig = ty::Binder::dummy(cx.tcx.mk_fn_sig(\n+        vec![try_fn_ty, i8p, catch_fn_ty].into_iter(),\n+        tcx.types.i32,\n+        false,\n+        hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    ));\n+    let rust_try = gen_fn(cx, \"__rust_try\", rust_fn_sig, codegen);\n     cx.rust_try_fn.set(Some(rust_try));\n     rust_try\n }"}, {"sha": "abdd6edea90249454287e11193774404a3967fc3", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -636,7 +636,7 @@ where\n         if let (Some(a), Some(b)) = (a.no_bound_vars(), b.no_bound_vars()) {\n             // Fast path for the common case.\n             self.relate(a, b)?;\n-            return Ok(ty::Binder::bind(a));\n+            return Ok(ty::Binder::dummy(a));\n         }\n \n         if self.ambient_covariance() {"}, {"sha": "f6ef98407887eb42150360f9cc419a72ae22df45", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -126,14 +126,15 @@ impl Elaborator<'tcx> {\n     fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n         let tcx = self.visited.tcx;\n \n-        match obligation.predicate.skip_binders() {\n+        let bound_predicate = obligation.predicate.bound_atom();\n+        match bound_predicate.skip_binder() {\n             ty::PredicateAtom::Trait(data, _) => {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n                 let obligations = predicates.predicates.iter().map(|&(pred, _)| {\n                     predicate_obligation(\n-                        pred.subst_supertrait(tcx, &ty::Binder::bind(data.trait_ref)),\n+                        pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n                         obligation.param_env,\n                         obligation.cause.clone(),\n                     )"}, {"sha": "cc378f1ea47ce22b649d2aab11c84450c68d77fa", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -1056,9 +1056,21 @@ impl<'tcx> Predicate<'tcx> {\n         }\n     }\n \n+    /// Converts this to a `Binder<PredicateAtom<'tcx>>`. If the value was an\n+    /// `Atom`, then it is not allowed to contain escaping bound vars.\n+    pub fn bound_atom(self) -> Binder<PredicateAtom<'tcx>> {\n+        match self.kind() {\n+            &PredicateKind::ForAll(binder) => binder,\n+            &PredicateKind::Atom(atom) => {\n+                debug_assert!(!atom.has_escaping_bound_vars());\n+                Binder::dummy(atom)\n+            }\n+        }\n+    }\n+\n     /// Allows using a `Binder<PredicateAtom<'tcx>>` even if the given predicate previously\n     /// contained unbound variables by shifting these variables outwards.\n-    pub fn bound_atom(self, tcx: TyCtxt<'tcx>) -> Binder<PredicateAtom<'tcx>> {\n+    pub fn bound_atom_with_opt_escaping(self, tcx: TyCtxt<'tcx>) -> Binder<PredicateAtom<'tcx>> {\n         match self.kind() {\n             &PredicateKind::ForAll(binder) => binder,\n             &PredicateKind::Atom(atom) => Binder::wrap_nonbinding(tcx, atom),"}, {"sha": "acdf1f642ab9b21780beb1f585882cc35b4f1a5f", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -618,10 +618,9 @@ pub trait PrettyPrinter<'tcx>:\n                         // may contain unbound variables. We therefore do this manually.\n                         //\n                         // FIXME(lcnr): Find out why exactly this is the case :)\n-                        if let ty::PredicateAtom::Trait(pred, _) =\n-                            predicate.bound_atom(self.tcx()).skip_binder()\n-                        {\n-                            let trait_ref = ty::Binder::bind(pred.trait_ref);\n+                        let bound_predicate = predicate.bound_atom_with_opt_escaping(self.tcx());\n+                        if let ty::PredicateAtom::Trait(pred, _) = bound_predicate.skip_binder() {\n+                            let trait_ref = bound_predicate.rebind(pred.trait_ref);\n                             // Don't print +Sized, but rather +?Sized if absent.\n                             if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n                                 is_sized = true;"}, {"sha": "15803dbd8429f4ba063b784320b27b90082d354b", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -549,7 +549,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateAtom<'a> {\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.as_ref().skip_binder()).map(ty::Binder::bind)\n+        tcx.lift(self.as_ref().skip_binder()).map(|v| self.rebind(v))\n     }\n }\n "}, {"sha": "633b9fe9acd1ff047bf3cb5fedf480b636689d01", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -703,14 +703,16 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n         use crate::ty::ToPredicate;\n         match self.skip_binder() {\n             ExistentialPredicate::Trait(tr) => {\n-                Binder(tr).with_self_ty(tcx, self_ty).without_const().to_predicate(tcx)\n+                self.rebind(tr).with_self_ty(tcx, self_ty).without_const().to_predicate(tcx)\n             }\n             ExistentialPredicate::Projection(p) => {\n-                Binder(p.with_self_ty(tcx, self_ty)).to_predicate(tcx)\n+                self.rebind(p.with_self_ty(tcx, self_ty)).to_predicate(tcx)\n             }\n             ExistentialPredicate::AutoTrait(did) => {\n-                let trait_ref =\n-                    Binder(ty::TraitRef { def_id: did, substs: tcx.mk_substs_trait(self_ty, &[]) });\n+                let trait_ref = self.rebind(ty::TraitRef {\n+                    def_id: did,\n+                    substs: tcx.mk_substs_trait(self_ty, &[]),\n+                });\n                 trait_ref.without_const().to_predicate(tcx)\n             }\n         }\n@@ -775,7 +777,7 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n \n impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n     pub fn principal(&self) -> Option<ty::Binder<ExistentialTraitRef<'tcx>>> {\n-        self.skip_binder().principal().map(Binder::bind)\n+        self.map_bound(|b| b.principal()).transpose()\n     }\n \n     pub fn principal_def_id(&self) -> Option<DefId> {\n@@ -858,8 +860,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n     }\n \n     pub fn to_poly_trait_predicate(&self) -> ty::PolyTraitPredicate<'tcx> {\n-        // Note that we preserve binding levels\n-        Binder(ty::TraitPredicate { trait_ref: self.skip_binder() })\n+        self.map_bound(|trait_ref| ty::TraitPredicate { trait_ref })\n     }\n }\n \n@@ -1001,6 +1002,19 @@ impl<T> Binder<T> {\n         Binder(f(self.0))\n     }\n \n+    /// Wraps a `value` in a binder, using the same bound variables as the\n+    /// current `Binder`. This should not be used if the new value *changes*\n+    /// the bound variables. Note: the (old or new) value itself does not\n+    /// necessarily need to *name* all the bound variables.\n+    ///\n+    /// This currently doesn't do anything different than `bind`, because we\n+    /// don't actually track bound vars. However, semantically, it is different\n+    /// because bound vars aren't allowed to change here, whereas they are\n+    /// in `bind`. This may be (debug) asserted in the future.\n+    pub fn rebind<U>(&self, value: U) -> Binder<U> {\n+        Binder(value)\n+    }\n+\n     /// Unwraps and returns the value within, but only if it contains\n     /// no bound vars at all. (In other words, if this binder --\n     /// and indeed any enclosing binder -- doesn't bind anything at"}, {"sha": "93a0073588ec71663a6e573e379fca5a1c4f1c1d", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -642,18 +642,19 @@ impl AutoTraitFinder<'tcx> {\n             // We check this by calling is_of_param on the relevant types\n             // from the various possible predicates\n \n-            match predicate.skip_binders() {\n+            let bound_predicate = predicate.bound_atom();\n+            match bound_predicate.skip_binder() {\n                 ty::PredicateAtom::Trait(p, _) => {\n                     if self.is_param_no_infer(p.trait_ref.substs)\n                         && !only_projections\n                         && is_new_pred\n                     {\n                         self.add_user_pred(computed_preds, predicate);\n                     }\n-                    predicates.push_back(ty::Binder::bind(p));\n+                    predicates.push_back(bound_predicate.rebind(p));\n                 }\n                 ty::PredicateAtom::Projection(p) => {\n-                    let p = ty::Binder::bind(p);\n+                    let p = bound_predicate.rebind(p);\n                     debug!(\n                         \"evaluate_nested_obligations: examining projection predicate {:?}\",\n                         predicate\n@@ -783,13 +784,13 @@ impl AutoTraitFinder<'tcx> {\n                     }\n                 }\n                 ty::PredicateAtom::RegionOutlives(binder) => {\n-                    let binder = ty::Binder::bind(binder);\n+                    let binder = bound_predicate.rebind(binder);\n                     if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n                         return false;\n                     }\n                 }\n                 ty::PredicateAtom::TypeOutlives(binder) => {\n-                    let binder = ty::Binder::bind(binder);\n+                    let binder = bound_predicate.rebind(binder);\n                     match (\n                         binder.no_bound_vars(),\n                         binder.map_bound_ref(|pred| pred.0).no_bound_vars(),"}, {"sha": "f53465266d2ac9fcb1fc263fe43bd9977b81ec9b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -255,9 +255,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     return;\n                 }\n \n-                match obligation.predicate.skip_binders() {\n+                let bound_predicate = obligation.predicate.bound_atom();\n+                match bound_predicate.skip_binder() {\n                     ty::PredicateAtom::Trait(trait_predicate, _) => {\n-                        let trait_predicate = ty::Binder::bind(trait_predicate);\n+                        let trait_predicate = bound_predicate.rebind(trait_predicate);\n                         let trait_predicate = self.resolve_vars_if_possible(&trait_predicate);\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n@@ -531,7 +532,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n \n                     ty::PredicateAtom::RegionOutlives(predicate) => {\n-                        let predicate = ty::Binder::bind(predicate);\n+                        let predicate = bound_predicate.rebind(predicate);\n                         let predicate = self.resolve_vars_if_possible(&predicate);\n                         let err = self\n                             .region_outlives_predicate(&obligation.cause, predicate)\n@@ -1078,9 +1079,10 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         // FIXME: It should be possible to deal with `ForAll` in a cleaner way.\n-        let (cond, error) = match (cond.skip_binders(), error.skip_binders()) {\n+        let bound_error = error.bound_atom();\n+        let (cond, error) = match (cond.skip_binders(), bound_error.skip_binder()) {\n             (ty::PredicateAtom::Trait(..), ty::PredicateAtom::Trait(error, _)) => {\n-                (cond, ty::Binder::bind(error))\n+                (cond, bound_error.rebind(error))\n             }\n             _ => {\n                 // FIXME: make this work in other cases too.\n@@ -1089,9 +1091,10 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n \n         for obligation in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n-            if let ty::PredicateAtom::Trait(implication, _) = obligation.predicate.skip_binders() {\n+            let bound_predicate = obligation.predicate.bound_atom();\n+            if let ty::PredicateAtom::Trait(implication, _) = bound_predicate.skip_binder() {\n                 let error = error.to_poly_trait_ref();\n-                let implication = ty::Binder::bind(implication.trait_ref);\n+                let implication = bound_predicate.rebind(implication.trait_ref);\n                 // FIXME: I'm just not taking associated types at all here.\n                 // Eventually I'll need to implement param-env-aware\n                 // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n@@ -1169,12 +1172,13 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             //\n             // this can fail if the problem was higher-ranked, in which\n             // cause I have no idea for a good error message.\n-            if let ty::PredicateAtom::Projection(data) = predicate.skip_binders() {\n+            let bound_predicate = predicate.bound_atom();\n+            if let ty::PredicateAtom::Projection(data) = bound_predicate.skip_binder() {\n                 let mut selcx = SelectionContext::new(self);\n                 let (data, _) = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n                     infer::LateBoundRegionConversionTime::HigherRankedType,\n-                    &ty::Binder::bind(data),\n+                    &bound_predicate.rebind(data),\n                 );\n                 let mut obligations = vec![];\n                 let normalized_ty = super::normalize_projection_type(\n@@ -1455,10 +1459,11 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        let mut err = match predicate.skip_binders() {\n+        let bound_predicate = predicate.bound_atom();\n+        let mut err = match bound_predicate.skip_binder() {\n             ty::PredicateAtom::Trait(data, _) => {\n-                let trait_ref = ty::Binder::bind(data.trait_ref);\n-                let self_ty = trait_ref.skip_binder().self_ty();\n+                let self_ty = data.trait_ref.self_ty();\n+                let trait_ref = bound_predicate.rebind(data.trait_ref);\n                 debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind(), trait_ref);\n \n                 if predicate.references_error() {\n@@ -1582,7 +1587,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.emit_inference_failure_err(body_id, span, a.into(), ErrorCode::E0282)\n             }\n             ty::PredicateAtom::Projection(data) => {\n-                let trait_ref = ty::Binder::bind(data).to_poly_trait_ref(self.tcx);\n+                let trait_ref = bound_predicate.rebind(data).to_poly_trait_ref(self.tcx);\n                 let self_ty = trait_ref.skip_binder().self_ty();\n                 let ty = data.ty;\n                 if predicate.references_error() {"}, {"sha": "495a250be7c1fba0d6aa8cc6c451a1e47a9b02d0", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -353,7 +353,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 // This means we need to pass it the bound version of our\n                 // predicate.\n                 ty::PredicateAtom::Trait(trait_ref, _constness) => {\n-                    let trait_obligation = obligation.with(Binder::bind(trait_ref));\n+                    let trait_obligation = obligation.with(binder.rebind(trait_ref));\n \n                     self.process_trait_obligation(\n                         obligation,\n@@ -362,7 +362,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     )\n                 }\n                 ty::PredicateAtom::Projection(data) => {\n-                    let project_obligation = obligation.with(Binder::bind(data));\n+                    let project_obligation = obligation.with(binder.rebind(data));\n \n                     self.process_projection_obligation(\n                         project_obligation,"}, {"sha": "827b1d35f1c2296ddc69fd31fd26b73ac038aac5", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -623,7 +623,8 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n         .obligations\n         .iter()\n         .filter(|obligation| {\n-            match obligation.predicate.skip_binders() {\n+            let bound_predicate = obligation.predicate.bound_atom();\n+            match bound_predicate.skip_binder() {\n                 // We found a `T: Foo<X = U>` predicate, let's check\n                 // if `U` references any unresolved type\n                 // variables. In principle, we only care if this\n@@ -634,7 +635,7 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n                 // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n                 // ?0>`).\n                 ty::PredicateAtom::Projection(data) => {\n-                    infcx.unresolved_type_vars(&ty::Binder::bind(data.ty)).is_some()\n+                    infcx.unresolved_type_vars(&bound_predicate.rebind(data.ty)).is_some()\n                 }\n \n                 // We are only interested in `T: Foo<X = U>` predicates, whre\n@@ -907,8 +908,9 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n         debug!(?predicate);\n+        let bound_predicate = predicate.bound_atom();\n         if let ty::PredicateAtom::Projection(data) = predicate.skip_binders() {\n-            let data = ty::Binder::bind(data);\n+            let data = bound_predicate.rebind(data);\n             let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n \n             let is_match = same_def_id"}, {"sha": "b838602e76ca352a5900b68049418661abad9a33", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -449,16 +449,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         let result = ensure_sufficient_stack(|| {\n-            match obligation.predicate.skip_binders() {\n+            let bound_predicate = obligation.predicate.bound_atom();\n+            match bound_predicate.skip_binder() {\n                 ty::PredicateAtom::Trait(t, _) => {\n-                    let t = ty::Binder::bind(t);\n+                    let t = bound_predicate.rebind(t);\n                     debug_assert!(!t.has_escaping_bound_vars());\n                     let obligation = obligation.with(t);\n                     self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n                 }\n \n                 ty::PredicateAtom::Subtype(p) => {\n-                    let p = ty::Binder::bind(p);\n+                    let p = bound_predicate.rebind(p);\n                     // Does this code ever run?\n                     match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                         Some(Ok(InferOk { mut obligations, .. })) => {\n@@ -502,7 +503,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n \n                 ty::PredicateAtom::Projection(data) => {\n-                    let data = ty::Binder::bind(data);\n+                    let data = bound_predicate.rebind(data);\n                     let project_obligation = obligation.with(data);\n                     match project::poly_project_and_unify_type(self, &project_obligation) {\n                         Ok(Ok(Some(mut subobligations))) => {\n@@ -1174,8 +1175,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .iter()\n             .enumerate()\n             .filter_map(|(idx, bound)| {\n-                if let ty::PredicateAtom::Trait(pred, _) = bound.skip_binders() {\n-                    let bound = ty::Binder::bind(pred.trait_ref);\n+                let bound_predicate = bound.bound_atom();\n+                if let ty::PredicateAtom::Trait(pred, _) = bound_predicate.skip_binder() {\n+                    let bound = bound_predicate.rebind(pred.trait_ref);\n                     if self.infcx.probe(|_| {\n                         match self.match_projection(\n                             obligation,\n@@ -1529,16 +1531,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::Str | ty::Slice(_) | ty::Dynamic(..) | ty::Foreign(..) => None,\n \n-            ty::Tuple(tys) => {\n-                Where(ty::Binder::bind(tys.last().into_iter().map(|k| k.expect_ty()).collect()))\n-            }\n+            ty::Tuple(tys) => Where(\n+                obligation\n+                    .predicate\n+                    .rebind(tys.last().into_iter().map(|k| k.expect_ty()).collect()),\n+            ),\n \n             ty::Adt(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n-                Where(ty::Binder::bind(\n-                    sized_crit.iter().map(|ty| ty.subst(self.tcx(), substs)).collect(),\n-                ))\n+                Where(\n+                    obligation.predicate.rebind({\n+                        sized_crit.iter().map(|ty| ty.subst(self.tcx(), substs)).collect()\n+                    }),\n+                )\n             }\n \n             ty::Projection(_) | ty::Param(_) | ty::Opaque(..) => None,\n@@ -1561,7 +1567,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         use self::BuiltinImplConditions::{Ambiguous, None, Where};\n \n-        match self_ty.kind() {\n+        match *self_ty.kind() {\n             ty::Infer(ty::IntVar(_))\n             | ty::Infer(ty::FloatVar(_))\n             | ty::FnDef(..)\n@@ -1590,12 +1596,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::Array(element_ty, _) => {\n                 // (*) binder moved here\n-                Where(ty::Binder::bind(vec![element_ty]))\n+                Where(obligation.predicate.rebind(vec![element_ty]))\n             }\n \n             ty::Tuple(tys) => {\n                 // (*) binder moved here\n-                Where(ty::Binder::bind(tys.iter().map(|k| k.expect_ty()).collect()))\n+                Where(obligation.predicate.rebind(tys.iter().map(|k| k.expect_ty()).collect()))\n             }\n \n             ty::Closure(_, substs) => {\n@@ -1605,7 +1611,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // Not yet resolved.\n                     Ambiguous\n                 } else {\n-                    Where(ty::Binder::bind(substs.as_closure().upvar_tys().collect()))\n+                    Where(obligation.predicate.rebind(substs.as_closure().upvar_tys().collect()))\n                 }\n             }\n "}, {"sha": "5ca0fc0c88b540623fdee82d71afecfd49eb36d2", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -81,8 +81,11 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n         interner: &RustInterner<'tcx>,\n     ) -> chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'tcx>>> {\n         let clauses = self.environment.into_iter().map(|predicate| {\n-            let (predicate, binders, _named_regions) =\n-                collect_bound_vars(interner, interner.tcx, &predicate.bound_atom(interner.tcx));\n+            let (predicate, binders, _named_regions) = collect_bound_vars(\n+                interner,\n+                interner.tcx,\n+                &predicate.bound_atom_with_opt_escaping(interner.tcx),\n+            );\n             let consequence = match predicate {\n                 ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n                     chalk_ir::DomainGoal::FromEnv(chalk_ir::FromEnv::Ty(ty.lower_into(interner)))\n@@ -133,8 +136,11 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predicate<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n-        let (predicate, binders, _named_regions) =\n-            collect_bound_vars(interner, interner.tcx, &self.bound_atom(interner.tcx));\n+        let (predicate, binders, _named_regions) = collect_bound_vars(\n+            interner,\n+            interner.tcx,\n+            &self.bound_atom_with_opt_escaping(interner.tcx),\n+        );\n \n         let value = match predicate {\n             ty::PredicateAtom::Trait(predicate, _) => {\n@@ -653,8 +659,11 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n-        let (predicate, binders, _named_regions) =\n-            collect_bound_vars(interner, interner.tcx, &self.bound_atom(interner.tcx));\n+        let (predicate, binders, _named_regions) = collect_bound_vars(\n+            interner,\n+            interner.tcx,\n+            &self.bound_atom_with_opt_escaping(interner.tcx),\n+        );\n         let value = match predicate {\n             ty::PredicateAtom::Trait(predicate, _) => {\n                 Some(chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)))\n@@ -762,27 +771,22 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> Option<chalk_solve::rust_ir::QuantifiedInlineBound<RustInterner<'tcx>>> {\n-        match self.bound_atom(interner.tcx).skip_binder() {\n-            ty::PredicateAtom::Trait(predicate, _) => {\n-                let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, &ty::Binder::bind(predicate));\n-\n-                Some(chalk_ir::Binders::new(\n-                    binders,\n-                    chalk_solve::rust_ir::InlineBound::TraitBound(\n-                        predicate.trait_ref.lower_into(interner),\n-                    ),\n-                ))\n-            }\n-            ty::PredicateAtom::Projection(predicate) => {\n-                let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, &ty::Binder::bind(predicate));\n-\n-                Some(chalk_ir::Binders::new(\n-                    binders,\n-                    chalk_solve::rust_ir::InlineBound::AliasEqBound(predicate.lower_into(interner)),\n-                ))\n-            }\n+        let (predicate, binders, _named_regions) = collect_bound_vars(\n+            interner,\n+            interner.tcx,\n+            &self.bound_atom_with_opt_escaping(interner.tcx),\n+        );\n+        match predicate {\n+            ty::PredicateAtom::Trait(predicate, _) => Some(chalk_ir::Binders::new(\n+                binders,\n+                chalk_solve::rust_ir::InlineBound::TraitBound(\n+                    predicate.trait_ref.lower_into(interner),\n+                ),\n+            )),\n+            ty::PredicateAtom::Projection(predicate) => Some(chalk_ir::Binders::new(\n+                binders,\n+                chalk_solve::rust_ir::InlineBound::AliasEqBound(predicate.lower_into(interner)),\n+            )),\n             ty::PredicateAtom::TypeOutlives(_predicate) => None,\n             ty::PredicateAtom::WellFormed(_ty) => None,\n "}, {"sha": "07e523af3ebf518b5b0ad9413273725379a54024", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -1095,9 +1095,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     obligation.predicate\n                 );\n \n-                match obligation.predicate.skip_binders() {\n+                let bound_predicate = obligation.predicate.bound_atom();\n+                match bound_predicate.skip_binder() {\n                     ty::PredicateAtom::Trait(pred, _) => {\n-                        let pred = ty::Binder::bind(pred);\n+                        let pred = bound_predicate.rebind(pred);\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())\n                                 .in_definition_order()\n@@ -1106,7 +1107,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         );\n                     }\n                     ty::PredicateAtom::Projection(pred) => {\n-                        let pred = ty::Binder::bind(pred);\n+                        let pred = bound_predicate.rebind(pred);\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that.\n                         let references_self ="}, {"sha": "8cd83c39f9e31a061205264fc8d1fa0a5dfbe693", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -192,14 +192,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     obligation.predicate\n                 );\n \n+                let bound_predicate = obligation.predicate.bound_atom();\n                 if let ty::PredicateAtom::Projection(proj_predicate) =\n                     obligation.predicate.skip_binders()\n                 {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n                     self.deduce_sig_from_projection(\n                         Some(obligation.cause.span),\n-                        ty::Binder::bind(proj_predicate),\n+                        bound_predicate.rebind(proj_predicate),\n                     )\n                 } else {\n                     None"}, {"sha": "c1485e3baf6776e2e04e8a18580a4c8a07df662d", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -583,7 +583,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         while !queue.is_empty() {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n-            let trait_pred = match obligation.predicate.skip_binders() {\n+            let bound_predicate = obligation.predicate.bound_atom();\n+            let trait_pred = match bound_predicate.skip_binder() {\n                 ty::PredicateAtom::Trait(trait_pred, _)\n                     if traits.contains(&trait_pred.def_id()) =>\n                 {\n@@ -594,7 +595,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             has_unsized_tuple_coercion = true;\n                         }\n                     }\n-                    ty::Binder::bind(trait_pred)\n+                    bound_predicate.rebind(trait_pred)\n                 }\n                 _ => {\n                     coercion.obligations.push(obligation);"}, {"sha": "5650b2cdd3c98d8b2286c68319834586f57ce2bb", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -226,12 +226,14 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // could be extended easily also to the other `Predicate`.\n         let predicate_matches_closure = |p: Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n-            match (predicate.skip_binders(), p.skip_binders()) {\n+            let predicate = predicate.bound_atom();\n+            let p = p.bound_atom();\n+            match (predicate.skip_binder(), p.skip_binder()) {\n                 (ty::PredicateAtom::Trait(a, _), ty::PredicateAtom::Trait(b, _)) => {\n-                    relator.relate(ty::Binder::bind(a), ty::Binder::bind(b)).is_ok()\n+                    relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()\n                 }\n                 (ty::PredicateAtom::Projection(a), ty::PredicateAtom::Projection(b)) => {\n-                    relator.relate(ty::Binder::bind(a), ty::Binder::bind(b)).is_ok()\n+                    relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()\n                 }\n                 _ => predicate == p,\n             }"}, {"sha": "f40a250200e4a1df9f846ea50e7b217f1b26b64b", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -328,14 +328,14 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n \n             kw::Try => {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n-                let try_fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n+                let try_fn_ty = ty::Binder::dummy(tcx.mk_fn_sig(\n                     iter::once(mut_u8),\n                     tcx.mk_unit(),\n                     false,\n                     hir::Unsafety::Normal,\n                     Abi::Rust,\n                 ));\n-                let catch_fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n+                let catch_fn_ty = ty::Binder::dummy(tcx.mk_fn_sig(\n                     [mut_u8, mut_u8].iter().cloned(),\n                     tcx.mk_unit(),\n                     false,"}, {"sha": "d403e25939893f4d4f46a93fbfb8cc3046b0550f", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -796,29 +796,29 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // FIXME: do we want to commit to this behavior for param bounds?\n         debug!(\"assemble_inherent_candidates_from_param(param_ty={:?})\", param_ty);\n \n-        let bounds =\n-            self.param_env.caller_bounds().iter().map(ty::Predicate::skip_binders).filter_map(\n-                |predicate| match predicate {\n-                    ty::PredicateAtom::Trait(trait_predicate, _) => {\n-                        match trait_predicate.trait_ref.self_ty().kind() {\n-                            ty::Param(ref p) if *p == param_ty => {\n-                                Some(ty::Binder::bind(trait_predicate.trait_ref))\n-                            }\n-                            _ => None,\n+        let bounds = self.param_env.caller_bounds().iter().filter_map(|predicate| {\n+            let bound_predicate = predicate.bound_atom();\n+            match bound_predicate.skip_binder() {\n+                ty::PredicateAtom::Trait(trait_predicate, _) => {\n+                    match *trait_predicate.trait_ref.self_ty().kind() {\n+                        ty::Param(p) if p == param_ty => {\n+                            Some(bound_predicate.rebind(trait_predicate.trait_ref))\n                         }\n+                        _ => None,\n                     }\n-                    ty::PredicateAtom::Subtype(..)\n-                    | ty::PredicateAtom::Projection(..)\n-                    | ty::PredicateAtom::RegionOutlives(..)\n-                    | ty::PredicateAtom::WellFormed(..)\n-                    | ty::PredicateAtom::ObjectSafe(..)\n-                    | ty::PredicateAtom::ClosureKind(..)\n-                    | ty::PredicateAtom::TypeOutlives(..)\n-                    | ty::PredicateAtom::ConstEvaluatable(..)\n-                    | ty::PredicateAtom::ConstEquate(..)\n-                    | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n-                },\n-            );\n+                }\n+                ty::PredicateAtom::Subtype(..)\n+                | ty::PredicateAtom::Projection(..)\n+                | ty::PredicateAtom::RegionOutlives(..)\n+                | ty::PredicateAtom::WellFormed(..)\n+                | ty::PredicateAtom::ObjectSafe(..)\n+                | ty::PredicateAtom::ClosureKind(..)\n+                | ty::PredicateAtom::TypeOutlives(..)\n+                | ty::PredicateAtom::ConstEvaluatable(..)\n+                | ty::PredicateAtom::ConstEquate(..)\n+                | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n+            }\n+        });\n \n         self.elaborate_bounds(bounds, |this, poly_trait_ref, item| {\n             let trait_ref = this.erase_late_bound_regions(&poly_trait_ref);"}, {"sha": "6d2ffadc20c27ad126d016836001771c5fc61121", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -637,9 +637,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     };\n                     let mut format_pred = |pred: ty::Predicate<'tcx>| {\n-                        match pred.skip_binders() {\n+                        let bound_predicate = pred.bound_atom();\n+                        match bound_predicate.skip_binder() {\n                             ty::PredicateAtom::Projection(pred) => {\n-                                let pred = ty::Binder::bind(pred);\n+                                let pred = bound_predicate.rebind(pred);\n                                 // `<Foo as Iterator>::Item = String`.\n                                 let trait_ref =\n                                     pred.skip_binder().projection_ty.trait_ref(self.tcx);\n@@ -658,8 +659,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 Some((obligation, trait_ref.self_ty()))\n                             }\n                             ty::PredicateAtom::Trait(poly_trait_ref, _) => {\n-                                let poly_trait_ref = ty::Binder::bind(poly_trait_ref);\n-                                let p = poly_trait_ref.skip_binder().trait_ref;\n+                                let p = poly_trait_ref.trait_ref;\n                                 let self_ty = p.self_ty();\n                                 let path = p.print_only_trait_path();\n                                 let obligation = format!(\"{}: {}\", self_ty, path);"}, {"sha": "e33d8dac1cdcf4a9bbc81f7a5b4d455b428a56a1", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -850,7 +850,8 @@ fn bounds_from_generic_predicates<'tcx>(\n     let mut projections = vec![];\n     for (predicate, _) in predicates.predicates {\n         debug!(\"predicate {:?}\", predicate);\n-        match predicate.skip_binders() {\n+        let bound_predicate = predicate.bound_atom();\n+        match bound_predicate.skip_binder() {\n             ty::PredicateAtom::Trait(trait_predicate, _) => {\n                 let entry = types.entry(trait_predicate.self_ty()).or_default();\n                 let def_id = trait_predicate.def_id();\n@@ -861,7 +862,7 @@ fn bounds_from_generic_predicates<'tcx>(\n                 }\n             }\n             ty::PredicateAtom::Projection(projection_pred) => {\n-                projections.push(ty::Binder::bind(projection_pred));\n+                projections.push(bound_predicate.rebind(projection_pred));\n             }\n             _ => {}\n         }"}, {"sha": "c1fa39e96eb95656761c724c11dc641f5a684de0", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -317,7 +317,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: LocalDefId) {\n                 }\n             }\n \n-            let se_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n+            let se_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n                 [tcx.types.isize, tcx.mk_imm_ptr(tcx.mk_imm_ptr(tcx.types.u8))].iter().cloned(),\n                 tcx.types.isize,\n                 false,"}, {"sha": "f39b53f3c826a60b26fd2682c6ab8ca83c5057c0", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -315,12 +315,13 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         pred: ty::Predicate<'tcx>,\n     ) -> FxHashSet<GenericParamDef> {\n-        let regions = match pred.skip_binders() {\n+        let bound_predicate = pred.bound_atom();\n+        let regions = match bound_predicate.skip_binder() {\n             ty::PredicateAtom::Trait(poly_trait_pred, _) => {\n-                tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(poly_trait_pred))\n+                tcx.collect_referenced_late_bound_regions(&bound_predicate.rebind(poly_trait_pred))\n             }\n             ty::PredicateAtom::Projection(poly_proj_pred) => {\n-                tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(poly_proj_pred))\n+                tcx.collect_referenced_late_bound_regions(&bound_predicate.rebind(poly_proj_pred))\n             }\n             _ => return FxHashSet::default(),\n         };"}, {"sha": "91941b00be29096387db0129136ae6441e554f31", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6f0ea299cfcb94aad6dc0a4fd06ae01153daf8fa", "patch": "@@ -1689,7 +1689,10 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     .filter_map(|bound| {\n                         // Note: The substs of opaque types can contain unbound variables,\n                         // meaning that we have to use `ignore_quantifiers_with_unbound_vars` here.\n-                        let trait_ref = match bound.bound_atom(cx.tcx).skip_binder() {\n+                        let trait_ref = match bound\n+                            .bound_atom_with_opt_escaping(cx.tcx)\n+                            .skip_binder()\n+                        {\n                             ty::PredicateAtom::Trait(tr, _constness) => {\n                                 ty::Binder::bind(tr.trait_ref)\n                             }\n@@ -1713,7 +1716,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             .iter()\n                             .filter_map(|bound| {\n                                 if let ty::PredicateAtom::Projection(proj) =\n-                                    bound.bound_atom(cx.tcx).skip_binder()\n+                                    bound.bound_atom_with_opt_escaping(cx.tcx).skip_binder()\n                                 {\n                                     if proj.projection_ty.trait_ref(cx.tcx)\n                                         == trait_ref.skip_binder()"}]}