{"sha": "5300ca38d88b924f7108274c50d918728c53aecd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMDBjYTM4ZDg4YjkyNGY3MTA4Mjc0YzUwZDkxODcyOGM1M2FlY2Q=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-17T19:12:47Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-17T19:49:59Z"}, "message": "cleanup ty_is_~non~_local_constructor", "tree": {"sha": "0100ac069831f2c5c018a949f5b238c5f8dd390e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0100ac069831f2c5c018a949f5b238c5f8dd390e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5300ca38d88b924f7108274c50d918728c53aecd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5300ca38d88b924f7108274c50d918728c53aecd", "html_url": "https://github.com/rust-lang/rust/commit/5300ca38d88b924f7108274c50d918728c53aecd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5300ca38d88b924f7108274c50d918728c53aecd/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2dbebd3d4ad21e80ef4e7535dd1e868aaad7e50", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2dbebd3d4ad21e80ef4e7535dd1e868aaad7e50", "html_url": "https://github.com/rust-lang/rust/commit/c2dbebd3d4ad21e80ef4e7535dd1e868aaad7e50"}], "stats": {"total": 59, "additions": 21, "deletions": 38}, "files": [{"sha": "3f286d733ed6daf64f546468c71acc4f77d6e990", "filename": "src/librustc_trait_selection/traits/coherence.rs", "status": "modified", "additions": 21, "deletions": 38, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5300ca38d88b924f7108274c50d918728c53aecd/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5300ca38d88b924f7108274c50d918728c53aecd/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs?ref=5300ca38d88b924f7108274c50d918728c53aecd", "patch": "@@ -418,7 +418,7 @@ fn orphan_check_trait_ref<'tcx>(\n                 .substs\n                 .types()\n                 .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-                .find(|ty| ty_is_non_local_constructor(ty, in_crate).is_none());\n+                .find(|ty| ty_is_local_constructor(ty, in_crate));\n \n             debug!(\"orphan_check_trait_ref: uncovered ty local_type: `{:?}`\", local_type);\n \n@@ -435,20 +435,16 @@ fn orphan_check_trait_ref<'tcx>(\n     Err(OrphanCheckErr::NonLocalInputType(non_local_spans))\n }\n \n+// FIXME: Return a `Vec` without `Option` here.\n fn ty_is_non_local(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, in_crate: InCrate) -> Option<Vec<Ty<'tcx>>> {\n-    match ty_is_non_local_constructor(ty, in_crate) {\n-        Some(ty) => {\n-            if let Some(inner_tys) = fundamental_ty_inner_tys(tcx, ty) {\n-                let tys: Vec<_> = inner_tys\n-                    .filter_map(|ty| ty_is_non_local(tcx, ty, in_crate))\n-                    .flatten()\n-                    .collect();\n-                if tys.is_empty() { None } else { Some(tys) }\n-            } else {\n-                Some(vec![ty])\n-            }\n-        }\n-        None => None,\n+    if ty_is_local_constructor(ty, in_crate) {\n+        None\n+    } else if let Some(inner_tys) = fundamental_ty_inner_tys(tcx, ty) {\n+        let tys: Vec<_> =\n+            inner_tys.filter_map(|ty| ty_is_non_local(tcx, ty, in_crate)).flatten().collect();\n+        if tys.is_empty() { None } else { Some(tys) }\n+    } else {\n+        Some(vec![ty])\n     }\n }\n \n@@ -493,8 +489,7 @@ fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n     }\n }\n \n-// FIXME(eddyb) this can just return `bool` as it always returns `Some(ty)` or `None`.\n-fn ty_is_non_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> Option<Ty<'_>> {\n+fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n     debug!(\"ty_is_non_local_constructor({:?})\", ty);\n \n     match ty.kind {\n@@ -513,29 +508,17 @@ fn ty_is_non_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> Option<Ty<'_>>\n         | ty::Never\n         | ty::Tuple(..)\n         | ty::Param(..)\n-        | ty::Projection(..) => Some(ty),\n+        | ty::Projection(..) => false,\n \n         ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) => match in_crate {\n-            InCrate::Local => Some(ty),\n+            InCrate::Local => false,\n             // The inference variable might be unified with a local\n             // type in that remote crate.\n-            InCrate::Remote => None,\n+            InCrate::Remote => true,\n         },\n \n-        ty::Adt(def, _) => {\n-            if def_id_is_local(def.did, in_crate) {\n-                None\n-            } else {\n-                Some(ty)\n-            }\n-        }\n-        ty::Foreign(did) => {\n-            if def_id_is_local(did, in_crate) {\n-                None\n-            } else {\n-                Some(ty)\n-            }\n-        }\n+        ty::Adt(def, _) => def_id_is_local(def.did, in_crate),\n+        ty::Foreign(did) => def_id_is_local(did, in_crate),\n         ty::Opaque(..) => {\n             // This merits some explanation.\n             // Normally, opaque types are not involed when performing\n@@ -553,7 +536,7 @@ fn ty_is_non_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> Option<Ty<'_>>\n             // the underlying type *within the same crate*. When an\n             // opaque type is used from outside the module\n             // where it is declared, it should be impossible to observe\n-            // anyything about it other than the traits that it implements.\n+            // anything about it other than the traits that it implements.\n             //\n             // The alternative would be to look at the underlying type\n             // to determine whether or not the opaque type itself should\n@@ -562,18 +545,18 @@ fn ty_is_non_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> Option<Ty<'_>>\n             // to a remote type. This would violate the rule that opaque\n             // types should be completely opaque apart from the traits\n             // that they implement, so we don't use this behavior.\n-            Some(ty)\n+            false\n         }\n \n         ty::Dynamic(ref tt, ..) => {\n             if let Some(principal) = tt.principal() {\n-                if def_id_is_local(principal.def_id(), in_crate) { None } else { Some(ty) }\n+                def_id_is_local(principal.def_id(), in_crate)\n             } else {\n-                Some(ty)\n+                false\n             }\n         }\n \n-        ty::Error(_) => None,\n+        ty::Error(_) => true,\n \n         ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n             bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)"}]}