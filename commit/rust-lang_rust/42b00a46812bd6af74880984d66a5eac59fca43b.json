{"sha": "42b00a46812bd6af74880984d66a5eac59fca43b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYjAwYTQ2ODEyYmQ2YWY3NDg4MDk4NGQ2NmE1ZWFjNTlmY2E0M2I=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-12-06T14:57:52Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-12-20T03:47:28Z"}, "message": "General purpose teest cases contributed by mw.", "tree": {"sha": "0c3d31c92e2adf5a807573aba70e5992c2d4528d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c3d31c92e2adf5a807573aba70e5992c2d4528d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42b00a46812bd6af74880984d66a5eac59fca43b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42b00a46812bd6af74880984d66a5eac59fca43b", "html_url": "https://github.com/rust-lang/rust/commit/42b00a46812bd6af74880984d66a5eac59fca43b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42b00a46812bd6af74880984d66a5eac59fca43b/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5763627ccd8240672bf9c0e41079a4f0911f4866", "url": "https://api.github.com/repos/rust-lang/rust/commits/5763627ccd8240672bf9c0e41079a4f0911f4866", "html_url": "https://github.com/rust-lang/rust/commit/5763627ccd8240672bf9c0e41079a4f0911f4866"}], "stats": {"total": 136, "additions": 136, "deletions": 0}, "files": [{"sha": "42168dd273eff42627997c1be212f2530f734dae", "filename": "src/test/incremental/thinlto/cgu_invalidated_when_import_added.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/42b00a46812bd6af74880984d66a5eac59fca43b/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_added.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b00a46812bd6af74880984d66a5eac59fca43b/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_added.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_added.rs?ref=42b00a46812bd6af74880984d66a5eac59fca43b", "patch": "@@ -0,0 +1,62 @@\n+// revisions: cfail1 cfail2\n+// compile-flags: -O -Zhuman-readable-cgu-names -Cllvm-args=-import-instr-limit=10\n+// build-pass\n+\n+// rust-lang/rust#59535:\n+//\n+// This is analgous to cgu_invalidated_when_import_removed.rs, but it covers\n+// the other direction:\n+//\n+// We start with a call-graph like `[A] -> [B -> D] [C]` (where the letters are\n+// functions and the modules are enclosed in `[]`), and add a new call `D <- C`,\n+// yielding the new call-graph: `[A] -> [B -> D] <- [C]`\n+//\n+// The effect of this is that the compiler previously classfied `D` as internal\n+// and the import-set of `[A]` to be just `B`. But after adding the `D <- C` call,\n+// `D` is no longer classified as internal, and the import-set of `[A]` becomes\n+// both `B` and `D`.\n+//\n+// We check this case because an early proposed pull request included an\n+// assertion that the import-sets monotonically decreased over time, a claim\n+// which this test case proves to be false.\n+\n+fn main() {\n+    foo::foo();\n+    bar::baz();\n+}\n+\n+mod foo {\n+\n+    // In cfail1, ThinLTO decides that foo() does not get inlined into main, and\n+    // instead bar() gets inlined into foo().\n+    // In cfail2, foo() gets inlined into main.\n+    pub fn foo(){\n+        bar()\n+    }\n+\n+    // This function needs to be big so that it does not get inlined by ThinLTO\n+    // but *does* get inlined into foo() when it is declared `internal` in\n+    // cfail1 (alone).\n+    pub fn bar(){\n+        println!(\"quux1\");\n+        println!(\"quux2\");\n+        println!(\"quux3\");\n+        println!(\"quux4\");\n+        println!(\"quux5\");\n+        println!(\"quux6\");\n+        println!(\"quux7\");\n+        println!(\"quux8\");\n+        println!(\"quux9\");\n+    }\n+}\n+\n+mod bar {\n+\n+    #[inline(never)]\n+    pub fn baz() {\n+        #[cfg(cfail2)]\n+        {\n+            crate::foo::bar();\n+        }\n+    }\n+}"}, {"sha": "19ce7b3e148f73f0388ab80dc21049f9a60120e6", "filename": "src/test/incremental/thinlto/cgu_invalidated_when_import_removed.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/42b00a46812bd6af74880984d66a5eac59fca43b/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_removed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b00a46812bd6af74880984d66a5eac59fca43b/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_removed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_removed.rs?ref=42b00a46812bd6af74880984d66a5eac59fca43b", "patch": "@@ -0,0 +1,74 @@\n+// revisions: cfail1 cfail2\n+// compile-flags: -O -Zhuman-readable-cgu-names -Cllvm-args=-import-instr-limit=10\n+// build-pass\n+\n+// rust-lang/rust#59535:\n+//\n+// Consider a call-graph like `[A] -> [B -> D] <- [C]` (where the letters are\n+// functions and the modules are enclosed in `[]`)\n+//\n+// In our specific instance, the earlier compilations were inlining the call\n+// to`B` into `A`; thus `A` ended up with a external reference to the symbol `D`\n+// in its object code, to be resolved at subsequent link time. The LTO import\n+// information provided by LLVM for those runs reflected that information: it\n+// explicitly says during those runs, `B` definition and `D` declaration were\n+// imported into `[A]`.\n+//\n+// The change between incremental builds was that the call `D <- C` was removed.\n+//\n+// That change, coupled with other decisions within `rustc`, made the compiler\n+// decide to make `D` an internal symbol (since it was no longer accessed from\n+// other codegen units, this makes sense locally). And then the definition of\n+// `D` was inlined into `B` and `D` itself was eliminated entirely.\n+//\n+// The current LTO import information reported that `B` alone is imported into\n+// `[A]` for the *current compilation*. So when the Rust compiler surveyed the\n+// dependence graph, it determined that nothing `[A]` imports changed since the\n+// last build (and `[A]` itself has not changed either), so it chooses to reuse\n+// the object code generated during the previous compilation.\n+//\n+// But that previous object code has an unresolved reference to `D`, and that\n+// causes a link time failure!\n+\n+fn main() {\n+    foo::foo();\n+    bar::baz();\n+}\n+\n+mod foo {\n+\n+    // In cfail1, foo() gets inlined into main.\n+    // In cfail2, ThinLTO decides that foo() does not get inlined into main, and\n+    // instead bar() gets inlined into foo(). But faulty logic in our incr.\n+    // ThinLTO implementation thought that `main()` is unchanged and thus reused\n+    // the object file still containing a call to the now non-existant bar().\n+    pub fn foo(){\n+        bar()\n+    }\n+\n+    // This function needs to be big so that it does not get inlined by ThinLTO\n+    // but *does* get inlined into foo() once it is declared `internal` in\n+    // cfail2.\n+    pub fn bar(){\n+        println!(\"quux1\");\n+        println!(\"quux2\");\n+        println!(\"quux3\");\n+        println!(\"quux4\");\n+        println!(\"quux5\");\n+        println!(\"quux6\");\n+        println!(\"quux7\");\n+        println!(\"quux8\");\n+        println!(\"quux9\");\n+    }\n+}\n+\n+mod bar {\n+\n+    #[inline(never)]\n+    pub fn baz() {\n+        #[cfg(cfail1)]\n+        {\n+            crate::foo::bar();\n+        }\n+    }\n+}"}]}