{"sha": "529e268ab900f1b6e731af64ce2aeecda3555f4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyOWUyNjhhYjkwMGYxYjZlNzMxYWY2NGNlMmFlZWNkYTM1NTVmNGU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-06T02:19:06Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-17T01:47:11Z"}, "message": "Fallout of rewriting std::comm", "tree": {"sha": "7ebb9ed2a7f36455b9550749a442522d45f0dc30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ebb9ed2a7f36455b9550749a442522d45f0dc30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/529e268ab900f1b6e731af64ce2aeecda3555f4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/529e268ab900f1b6e731af64ce2aeecda3555f4e", "html_url": "https://github.com/rust-lang/rust/commit/529e268ab900f1b6e731af64ce2aeecda3555f4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/529e268ab900f1b6e731af64ce2aeecda3555f4e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfa9064ba2687eb1d95708f72f41ddd9729a6ba1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfa9064ba2687eb1d95708f72f41ddd9729a6ba1", "html_url": "https://github.com/rust-lang/rust/commit/bfa9064ba2687eb1d95708f72f41ddd9729a6ba1"}], "stats": {"total": 3355, "additions": 765, "deletions": 2590}, "files": [{"sha": "78d0973fdfe2eb6f13bfb0c39ea6c0c003aca42f", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -77,6 +77,7 @@\n     \"rt/isaac/rand.h\", # public domain\n     \"rt/isaac/standard.h\", # public domain\n     \"libstd/rt/mpsc_queue.rs\", # BSD\n+    \"libstd/rt/spsc_queue.rs\", # BSD\n     \"libstd/rt/mpmc_bounded_queue.rs\", # BSD\n ]\n "}, {"sha": "ea8066b786f4ea728f057d2d77ef772fc0ade1ca", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -597,15 +597,14 @@ mod tests {\n \n     use arc::*;\n \n-    use std::comm;\n     use std::task;\n \n     #[test]\n     fn manually_share_arc() {\n         let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         let arc_v = Arc::new(v);\n \n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n \n         do task::spawn {\n             let arc_v: Arc<~[int]> = p.recv();\n@@ -626,7 +625,7 @@ mod tests {\n     fn test_mutex_arc_condvar() {\n         let arc = ~MutexArc::new(false);\n         let arc2 = ~arc.clone();\n-        let (p,c) = comm::oneshot();\n+        let (p,c) = Chan::new();\n         do task::spawn {\n             // wait until parent gets in\n             p.recv();\n@@ -638,7 +637,7 @@ mod tests {\n \n         let mut c = Some(c);\n         arc.access_cond(|state, cond| {\n-            c.take_unwrap().send(());\n+            c.take_unwrawp().send(());\n             assert!(!*state);\n             while !*state {\n                 cond.wait();\n@@ -650,7 +649,7 @@ mod tests {\n     fn test_arc_condvar_poison() {\n         let arc = ~MutexArc::new(1);\n         let arc2 = ~arc.clone();\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n \n         do spawn {\n             let _ = p.recv();\n@@ -687,7 +686,7 @@ mod tests {\n     pub fn test_mutex_arc_unwrap_poison() {\n         let arc = MutexArc::new(1);\n         let arc2 = ~(&arc).clone();\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n         do task::spawn {\n             arc2.access(|one| {\n                 c.send(());\n@@ -804,7 +803,7 @@ mod tests {\n     fn test_rw_arc() {\n         let arc = RWArc::new(0);\n         let arc2 = arc.clone();\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n \n         do task::spawn {\n             arc2.write(|num| {\n@@ -832,7 +831,7 @@ mod tests {\n         });\n \n         // Wait for children to pass their asserts\n-        for r in children.iter() {\n+        for r in children.mut_iter() {\n             r.recv();\n         }\n \n@@ -855,7 +854,7 @@ mod tests {\n         // Reader tasks\n         let mut reader_convos = ~[];\n         10.times(|| {\n-            let ((rp1, rc1), (rp2, rc2)) = (comm::stream(), comm::stream());\n+            let ((rp1, rc1), (rp2, rc2)) = (Chan::new(), Chan::new());\n             reader_convos.push((rc1, rp2));\n             let arcn = arc.clone();\n             do task::spawn {\n@@ -869,7 +868,7 @@ mod tests {\n \n         // Writer task\n         let arc2 = arc.clone();\n-        let ((wp1, wc1), (wp2, wc2)) = (comm::stream(), comm::stream());\n+        let ((wp1, wc1), (wp2, wc2)) = (Chan::new(), Chan::new());\n         do task::spawn || {\n             wp1.recv();\n             arc2.write_cond(|state, cond| {\n@@ -897,14 +896,14 @@ mod tests {\n                 assert_eq!(*state, 42);\n                 *state = 31337;\n                 // send to other readers\n-                for &(ref rc, _) in reader_convos.iter() {\n+                for &(ref mut rc, _) in reader_convos.mut_iter() {\n                     rc.send(())\n                 }\n             });\n             let read_mode = arc.downgrade(write_mode);\n             read_mode.read(|state| {\n                 // complete handshake with other readers\n-                for &(_, ref rp) in reader_convos.iter() {\n+                for &(_, ref mut rp) in reader_convos.mut_iter() {\n                     rp.recv()\n                 }\n                 wc1.send(()); // tell writer to try again\n@@ -926,7 +925,7 @@ mod tests {\n         //     \"blk(&Condvar { order: opt_lock, ..*cond })\"\n         // with just \"blk(cond)\".\n         let x = RWArc::new(true);\n-        let (wp, wc) = comm::stream();\n+        let (wp, wc) = Chan::new();\n \n         // writer task\n         let xw = x.clone();\n@@ -951,7 +950,7 @@ mod tests {\n             });\n             // make a reader task to trigger the \"reader cloud lock\" handoff\n             let xr = x.clone();\n-            let (rp, rc) = comm::stream();\n+            let (rp, rc) = Chan::new();\n             do task::spawn {\n                 rc.send(());\n                 xr.read(|_state| { })"}, {"sha": "09dd85fe0de4687ac0bea3e0a45b8d0108a1ca10", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 42, "deletions": 77, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -16,11 +16,6 @@ Higher level communication abstractions.\n \n #[allow(missing_doc)];\n \n-\n-use std::comm::{GenericChan, GenericSmartChan, GenericPort};\n-use std::comm::{Chan, Port, Peekable};\n-use std::comm;\n-\n /// An extension of `pipes::stream` that allows both sending and receiving.\n pub struct DuplexStream<T, U> {\n     priv chan: Chan<T>,\n@@ -29,108 +24,73 @@ pub struct DuplexStream<T, U> {\n \n // Allow these methods to be used without import:\n impl<T:Send,U:Send> DuplexStream<T, U> {\n+    /// Creates a bidirectional stream.\n+    pub fn new() -> (DuplexStream<T, U>, DuplexStream<U, T>) {\n+        let (p1, c2) = Chan::new();\n+        let (p2, c1) = Chan::new();\n+        (DuplexStream { chan: c1, port: p1 },\n+         DuplexStream { chan: c2, port: p2 })\n+    }\n     pub fn send(&self, x: T) {\n         self.chan.send(x)\n     }\n     pub fn try_send(&self, x: T) -> bool {\n         self.chan.try_send(x)\n     }\n-    pub fn recv(&self, ) -> U {\n+    pub fn recv(&self) -> U {\n         self.port.recv()\n     }\n     pub fn try_recv(&self) -> Option<U> {\n         self.port.try_recv()\n     }\n-    pub fn peek(&self) -> bool {\n-        self.port.peek()\n-    }\n-}\n-\n-impl<T:Send,U:Send> GenericChan<T> for DuplexStream<T, U> {\n-    fn send(&self, x: T) {\n-        self.chan.send(x)\n-    }\n-}\n-\n-impl<T:Send,U:Send> GenericSmartChan<T> for DuplexStream<T, U> {\n-    fn try_send(&self, x: T) -> bool {\n-        self.chan.try_send(x)\n-    }\n-}\n-\n-impl<T:Send,U:Send> GenericPort<U> for DuplexStream<T, U> {\n-    fn recv(&self) -> U {\n-        self.port.recv()\n-    }\n-\n-    fn try_recv(&self) -> Option<U> {\n-        self.port.try_recv()\n-    }\n-}\n-\n-impl<T:Send,U:Send> Peekable<U> for DuplexStream<T, U> {\n-    fn peek(&self) -> bool {\n-        self.port.peek()\n+    pub fn recv_opt(&self) -> Option<U> {\n+        self.port.recv_opt()\n     }\n }\n \n-/// Creates a bidirectional stream.\n-pub fn DuplexStream<T:Send,U:Send>()\n-    -> (DuplexStream<T, U>, DuplexStream<U, T>)\n-{\n-    let (p1, c2) = comm::stream();\n-    let (p2, c1) = comm::stream();\n-    (DuplexStream {\n-        chan: c1,\n-        port: p1\n-    },\n-     DuplexStream {\n-         chan: c2,\n-         port: p2\n-     })\n-}\n-\n /// An extension of `pipes::stream` that provides synchronous message sending.\n pub struct SyncChan<T> { priv duplex_stream: DuplexStream<T, ()> }\n /// An extension of `pipes::stream` that acknowledges each message received.\n pub struct SyncPort<T> { priv duplex_stream: DuplexStream<(), T> }\n \n-impl<T: Send> GenericChan<T> for SyncChan<T> {\n-    fn send(&self, val: T) {\n+impl<T: Send> SyncChan<T> {\n+    pub fn send(&self, val: T) {\n         assert!(self.try_send(val), \"SyncChan.send: receiving port closed\");\n     }\n-}\n \n-impl<T: Send> GenericSmartChan<T> for SyncChan<T> {\n-    /// Sends a message, or report if the receiver has closed the connection before receiving.\n-    fn try_send(&self, val: T) -> bool {\n-        self.duplex_stream.try_send(val) && self.duplex_stream.try_recv().is_some()\n+    /// Sends a message, or report if the receiver has closed the connection\n+    /// before receiving.\n+    pub fn try_send(&self, val: T) -> bool {\n+        self.duplex_stream.try_send(val) && self.duplex_stream.recv_opt().is_some()\n     }\n }\n \n-impl<T: Send> GenericPort<T> for SyncPort<T> {\n-    fn recv(&self) -> T {\n-        self.try_recv().expect(\"SyncPort.recv: sending channel closed\")\n+impl<T: Send> SyncPort<T> {\n+    pub fn recv(&self) -> T {\n+        self.recv_opt().expect(\"SyncPort.recv: sending channel closed\")\n     }\n \n-    fn try_recv(&self) -> Option<T> {\n-        self.duplex_stream.try_recv().map(|val| {\n+    pub fn recv_opt(&self) -> Option<T> {\n+        self.duplex_stream.recv_opt().map(|val| {\n             self.duplex_stream.try_send(());\n             val\n         })\n     }\n-}\n \n-impl<T: Send> Peekable<T> for SyncPort<T> {\n-    fn peek(&self) -> bool {\n-        self.duplex_stream.peek()\n+    pub fn try_recv(&self) -> Option<T> {\n+        self.duplex_stream.try_recv().map(|val| {\n+            self.duplex_stream.try_send(());\n+            val\n+        })\n     }\n }\n \n-/// Creates a stream whose channel, upon sending a message, blocks until the message is received.\n+/// Creates a stream whose channel, upon sending a message, blocks until the\n+/// message is received.\n pub fn rendezvous<T: Send>() -> (SyncPort<T>, SyncChan<T>) {\n-    let (chan_stream, port_stream) = DuplexStream();\n-    (SyncPort { duplex_stream: port_stream }, SyncChan { duplex_stream: chan_stream })\n+    let (chan_stream, port_stream) = DuplexStream::new();\n+    (SyncPort { duplex_stream: port_stream },\n+     SyncChan { duplex_stream: chan_stream })\n }\n \n #[cfg(test)]\n@@ -141,7 +101,7 @@ mod test {\n \n     #[test]\n     pub fn DuplexStream1() {\n-        let (left, right) = DuplexStream();\n+        let (mut left, mut right) = DuplexStream::new();\n \n         left.send(~\"abc\");\n         right.send(123);\n@@ -152,9 +112,10 @@ mod test {\n \n     #[test]\n     pub fn basic_rendezvous_test() {\n-        let (port, chan) = rendezvous();\n+        let (mut port, chan) = rendezvous();\n \n         do spawn {\n+            let mut chan = chan;\n             chan.send(\"abc\");\n         }\n \n@@ -165,8 +126,9 @@ mod test {\n     fn recv_a_lot() {\n         // Rendezvous streams should be able to handle any number of messages being sent\n         do run_in_uv_task {\n-            let (port, chan) = rendezvous();\n+            let (mut port, chan) = rendezvous();\n             do spawn {\n+                let mut chan = chan;\n                 1000000.times(|| { chan.send(()) })\n             }\n             1000000.times(|| { port.recv() })\n@@ -175,8 +137,9 @@ mod test {\n \n     #[test]\n     fn send_and_fail_and_try_recv() {\n-        let (port, chan) = rendezvous();\n+        let (mut port, chan) = rendezvous();\n         do spawn {\n+            let mut chan = chan;\n             chan.duplex_stream.send(()); // Can't access this field outside this module\n             fail!()\n         }\n@@ -185,8 +148,9 @@ mod test {\n \n     #[test]\n     fn try_send_and_recv_then_fail_before_ack() {\n-        let (port, chan) = rendezvous();\n+        let (port, mut chan) = rendezvous();\n         do spawn {\n+            let mut port = port;\n             port.duplex_stream.recv();\n             fail!()\n         }\n@@ -196,8 +160,9 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn send_and_recv_then_fail_before_ack() {\n-        let (port, chan) = rendezvous();\n+        let (port, mut chan) = rendezvous();\n         do spawn {\n+            let mut port = port;\n             port.duplex_stream.recv();\n             fail!()\n         }"}, {"sha": "eb61b7781f1ba329228be28760065610227a6a1b", "filename": "src/libextra/future.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -25,7 +25,6 @@\n \n #[allow(missing_doc)];\n \n-use std::comm::{PortOne, oneshot};\n use std::util::replace;\n \n /// A type encapsulating the result of a computation which may not be complete\n@@ -104,7 +103,7 @@ impl<A> Future<A> {\n }\n \n impl<A:Send> Future<A> {\n-    pub fn from_port(port: PortOne<A>) -> Future<A> {\n+    pub fn from_port(port: Port<A>) -> Future<A> {\n         /*!\n          * Create a future from a port\n          *\n@@ -125,7 +124,7 @@ impl<A:Send> Future<A> {\n          * value of the future.\n          */\n \n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             chan.send(blk());\n@@ -139,7 +138,6 @@ impl<A:Send> Future<A> {\n mod test {\n     use future::Future;\n \n-    use std::comm::oneshot;\n     use std::task;\n \n     #[test]\n@@ -150,7 +148,7 @@ mod test {\n \n     #[test]\n     fn test_from_port() {\n-        let (po, ch) = oneshot();\n+        let (po, ch) = Chan::new();\n         ch.send(~\"whale\");\n         let mut f = Future::from_port(po);\n         assert_eq!(f.get(), ~\"whale\");"}, {"sha": "1cc403c32f4c4559b50b3b754f5c947f678a1b65", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 50, "deletions": 51, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -19,9 +19,6 @@\n \n \n use std::borrow;\n-use std::comm;\n-use std::comm::SendDeferred;\n-use std::comm::{GenericPort, Peekable};\n use std::unstable::sync::{Exclusive, UnsafeArc};\n use std::unstable::atomics;\n use std::unstable::finally::Finally;\n@@ -34,48 +31,53 @@ use std::util::NonCopyable;\n \n // Each waiting task receives on one of these.\n #[doc(hidden)]\n-type WaitEnd = comm::PortOne<()>;\n+type WaitEnd = Port<()>;\n #[doc(hidden)]\n-type SignalEnd = comm::ChanOne<()>;\n+type SignalEnd = Chan<()>;\n // A doubly-ended queue of waiting tasks.\n #[doc(hidden)]\n-struct WaitQueue { head: comm::Port<SignalEnd>,\n-                   tail: comm::Chan<SignalEnd> }\n+struct WaitQueue { head: Port<SignalEnd>,\n+                   tail: Chan<SignalEnd> }\n \n impl WaitQueue {\n     fn new() -> WaitQueue {\n-        let (block_head, block_tail) = comm::stream();\n+        let (block_head, block_tail) = Chan::new();\n         WaitQueue { head: block_head, tail: block_tail }\n     }\n \n     // Signals one live task from the queue.\n     fn signal(&self) -> bool {\n-        // The peek is mandatory to make sure recv doesn't block.\n-        if self.head.peek() {\n-            // Pop and send a wakeup signal. If the waiter was killed, its port\n-            // will have closed. Keep trying until we get a live task.\n-            if self.head.recv().try_send_deferred(()) {\n-                true\n-            } else {\n-                self.signal()\n+        match self.head.try_recv() {\n+            Some(ch) => {\n+                // Send a wakeup signal. If the waiter was killed, its port will\n+                // have closed. Keep trying until we get a live task.\n+                if ch.try_send_deferred(()) {\n+                    true\n+                } else {\n+                    self.signal()\n+                }\n             }\n-        } else {\n-            false\n+            None => false\n         }\n     }\n \n     fn broadcast(&self) -> uint {\n         let mut count = 0;\n-        while self.head.peek() {\n-            if self.head.recv().try_send_deferred(()) {\n-                count += 1;\n+        loop {\n+            match self.head.try_recv() {\n+                None => break,\n+                Some(ch) => {\n+                    if ch.try_send_deferred(()) {\n+                        count += 1;\n+                    }\n+                }\n             }\n         }\n         count\n     }\n \n     fn wait_end(&self) -> WaitEnd {\n-        let (wait_end, signal_end) = comm::oneshot();\n+        let (wait_end, signal_end) = Chan::new();\n         self.tail.send_deferred(signal_end);\n         wait_end\n     }\n@@ -282,8 +284,7 @@ impl<'a> Condvar<'a> {\n                               condvar_id,\n                               \"cond.signal_on()\",\n                               || {\n-                let queue = queue.take_unwrap();\n-                queue.broadcast()\n+                queue.take_unwrap().broadcast()\n             })\n         }\n     }\n@@ -676,7 +677,6 @@ mod tests {\n     use sync::*;\n \n     use std::cast;\n-    use std::comm;\n     use std::result;\n     use std::task;\n \n@@ -711,7 +711,7 @@ mod tests {\n     #[test]\n     fn test_sem_as_cvar() {\n         /* Child waits and parent signals */\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n         let s = Semaphore::new(0);\n         let s2 = s.clone();\n         do task::spawn {\n@@ -723,7 +723,7 @@ mod tests {\n         let _ = p.recv();\n \n         /* Parent waits and child signals */\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n         let s = Semaphore::new(0);\n         let s2 = s.clone();\n         do task::spawn {\n@@ -740,8 +740,8 @@ mod tests {\n         // time, and shake hands.\n         let s = Semaphore::new(2);\n         let s2 = s.clone();\n-        let (p1,c1) = comm::stream();\n-        let (p2,c2) = comm::stream();\n+        let (p1,c1) = Chan::new();\n+        let (p2,c2) = Chan::new();\n         do task::spawn {\n             s2.access(|| {\n                 let _ = p2.recv();\n@@ -760,7 +760,7 @@ mod tests {\n         do task::spawn_sched(task::SingleThreaded) {\n             let s = Semaphore::new(1);\n             let s2 = s.clone();\n-            let (p, c) = comm::stream();\n+            let (p, c) = Chan::new();\n             let mut child_data = Some((s2, c));\n             s.access(|| {\n                 let (s2, c) = child_data.take_unwrap();\n@@ -782,7 +782,7 @@ mod tests {\n     fn test_mutex_lock() {\n         // Unsafely achieve shared state, and do the textbook\n         // \"load tmp = move ptr; inc tmp; store ptr <- tmp\" dance.\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n         let m = Mutex::new();\n         let m2 = m.clone();\n         let mut sharedstate = ~0;\n@@ -829,7 +829,7 @@ mod tests {\n             cond.wait();\n         });\n         // Parent wakes up child\n-        let (port,chan) = comm::stream();\n+        let (port,chan) = Chan::new();\n         let m3 = m.clone();\n         do task::spawn {\n             m3.lock_cond(|cond| {\n@@ -852,7 +852,7 @@ mod tests {\n \n         num_waiters.times(|| {\n             let mi = m.clone();\n-            let (port, chan) = comm::stream();\n+            let (port, chan) = Chan::new();\n             ports.push(port);\n             do task::spawn {\n                 mi.lock_cond(|cond| {\n@@ -864,13 +864,13 @@ mod tests {\n         });\n \n         // wait until all children get in the mutex\n-        for port in ports.iter() { let _ = port.recv(); }\n+        for port in ports.mut_iter() { let _ = port.recv(); }\n         m.lock_cond(|cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         });\n         // wait until all children wake up\n-        for port in ports.iter() { let _ = port.recv(); }\n+        for port in ports.mut_iter() { let _ = port.recv(); }\n     }\n     #[test]\n     fn test_mutex_cond_broadcast() {\n@@ -915,8 +915,8 @@ mod tests {\n         let m2 = m.clone();\n \n         let result: result::Result<(), ~Any> = do task::try {\n-            let (p, c) = comm::stream();\n-            do task::spawn || { // linked\n+            let (p, c) = Chan::new();\n+            do task::spawn { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n                 task::deschedule();\n                 fail!();\n@@ -940,19 +940,18 @@ mod tests {\n \n         let m = Mutex::new();\n         let m2 = m.clone();\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n \n         let result: result::Result<(), ~Any> = do task::try {\n             let mut sibling_convos = ~[];\n             2.times(|| {\n-                let (p, c) = comm::stream();\n+                let (p, c) = Chan::new();\n                 sibling_convos.push(p);\n                 let mi = m2.clone();\n                 // spawn sibling task\n                 do task::spawn { // linked\n                     let mut c = Some(c);\n                     mi.lock_cond(|cond| {\n-                        let c = c.take_unwrap();\n                         c.send(()); // tell sibling to go ahead\n                         (|| {\n                             cond.wait(); // block forever\n@@ -964,7 +963,7 @@ mod tests {\n                     })\n                 }\n             });\n-            for p in sibling_convos.iter() {\n+            for p in sibling_convos.mut_iter() {\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n             }\n             m2.lock(|| { });\n@@ -973,8 +972,8 @@ mod tests {\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n-        let r = p.recv();\n-        for p in r.iter() { p.recv(); } // wait on all its siblings\n+        let mut r = p.recv();\n+        for p in r.mut_iter() { p.recv(); } // wait on all its siblings\n         m.lock_cond(|cond| {\n             let woken = cond.broadcast();\n             assert_eq!(woken, 0);\n@@ -999,7 +998,7 @@ mod tests {\n         let result = do task::try {\n             let m = Mutex::new_with_condvars(2);\n             let m2 = m.clone();\n-            let (p, c) = comm::stream();\n+            let (p, c) = Chan::new();\n             do task::spawn {\n                 m2.lock_cond(|cond| {\n                     c.send(());\n@@ -1060,7 +1059,7 @@ mod tests {\n                                  mode2: RWLockMode) {\n         // Test mutual exclusion between readers and writers. Just like the\n         // mutex mutual exclusion test, a ways above.\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n         let x2 = x.clone();\n         let mut sharedstate = ~0;\n         {\n@@ -1111,8 +1110,8 @@ mod tests {\n                                  make_mode2_go_first: bool) {\n         // Much like sem_multi_resource.\n         let x2 = x.clone();\n-        let (p1, c1) = comm::stream();\n-        let (p2, c2) = comm::stream();\n+        let (p1, c1) = Chan::new();\n+        let (p2, c2) = Chan::new();\n         do task::spawn {\n             if !make_mode2_go_first {\n                 let _ = p2.recv(); // parent sends to us once it locks, or ...\n@@ -1177,7 +1176,7 @@ mod tests {\n             cond.wait();\n         });\n         // Parent wakes up child\n-        let (port, chan) = comm::stream();\n+        let (port, chan) = Chan::new();\n         let x3 = x.clone();\n         do task::spawn {\n             x3.write_cond(|cond| {\n@@ -1214,7 +1213,7 @@ mod tests {\n \n         num_waiters.times(|| {\n             let xi = x.clone();\n-            let (port, chan) = comm::stream();\n+            let (port, chan) = Chan::new();\n             ports.push(port);\n             do task::spawn {\n                 lock_cond(&xi, dg1, |cond| {\n@@ -1226,13 +1225,13 @@ mod tests {\n         });\n \n         // wait until all children get in the mutex\n-        for port in ports.iter() { let _ = port.recv(); }\n+        for port in ports.mut_iter() { let _ = port.recv(); }\n         lock_cond(&x, dg2, |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         });\n         // wait until all children wake up\n-        for port in ports.iter() { let _ = port.recv(); }\n+        for port in ports.mut_iter() { let _ = port.recv(); }\n     }\n     #[test]\n     fn test_rwlock_cond_broadcast() {"}, {"sha": "f0c9833adf8046b9d2e3ca4ccbb2abed3a3a9fa3", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -14,8 +14,6 @@\n /// parallelism.\n \n \n-use std::comm::{Chan, GenericChan, GenericPort};\n-use std::comm;\n use std::task::SchedMode;\n use std::task;\n use std::vec;\n@@ -35,7 +33,7 @@ pub struct TaskPool<T> {\n #[unsafe_destructor]\n impl<T> Drop for TaskPool<T> {\n     fn drop(&mut self) {\n-        for channel in self.channels.iter() {\n+        for channel in self.channels.mut_iter() {\n             channel.send(Quit);\n         }\n     }\n@@ -54,7 +52,7 @@ impl<T> TaskPool<T> {\n         assert!(n_tasks >= 1);\n \n         let channels = vec::from_fn(n_tasks, |i| {\n-            let (port, chan) = comm::stream::<Msg<T>>();\n+            let (port, chan) = Chan::<Msg<T>>::new();\n             let init_fn = init_fn_factory();\n \n             let task_body: proc() = proc() {"}, {"sha": "974d4dc1dc520117a3ec6201a284118c59ff46f1", "filename": "src/libextra/test.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -29,7 +29,6 @@ use time::precise_time_ns;\n use treemap::TreeMap;\n \n use std::clone::Clone;\n-use std::comm::{stream, SharedChan, GenericPort, GenericChan};\n use std::io;\n use std::io::File;\n use std::io::Writer;\n@@ -746,8 +745,7 @@ fn run_tests(opts: &TestOpts,\n     remaining.reverse();\n     let mut pending = 0;\n \n-    let (p, ch) = stream();\n-    let ch = SharedChan::new(ch);\n+    let (p, ch) = SharedChan::new();\n \n     while pending > 0 || !remaining.is_empty() {\n         while pending < concurrency && !remaining.is_empty() {\n@@ -872,7 +870,7 @@ pub fn run_test(force_ignore: bool,\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: SharedChan<MonitorMsg>,\n                       testfn: proc()) {\n-        do task::spawn {\n+        do spawn {\n             let mut task = task::task();\n             task.name(match desc.name {\n                 DynTestName(ref name) => SendStrOwned(name.clone()),\n@@ -1206,7 +1204,6 @@ mod tests {\n                StaticTestName, DynTestName, DynTestFn};\n     use test::{TestOpts, run_test};\n \n-    use std::comm::{stream, SharedChan};\n     use tempfile::TempDir;\n \n     #[test]\n@@ -1220,8 +1217,7 @@ mod tests {\n             },\n             testfn: DynTestFn(proc() f()),\n         };\n-        let (p, ch) = stream();\n-        let ch = SharedChan::new(ch);\n+        let (p, ch) = SharedChan::new();\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert!(res != TrOk);\n@@ -1238,8 +1234,7 @@ mod tests {\n             },\n             testfn: DynTestFn(proc() f()),\n         };\n-        let (p, ch) = stream();\n-        let ch = SharedChan::new(ch);\n+        let (p, ch) = SharedChan::new();\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert_eq!(res, TrIgnored);\n@@ -1256,8 +1251,7 @@ mod tests {\n             },\n             testfn: DynTestFn(proc() f()),\n         };\n-        let (p, ch) = stream();\n-        let ch = SharedChan::new(ch);\n+        let (p, ch) = SharedChan::new();\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert_eq!(res, TrOk);\n@@ -1274,8 +1268,7 @@ mod tests {\n             },\n             testfn: DynTestFn(proc() f()),\n         };\n-        let (p, ch) = stream();\n-        let ch = SharedChan::new(ch);\n+        let (p, ch) = SharedChan::new();\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert_eq!(res, TrFailed);"}, {"sha": "8713dbde9205a08330665e0ee0fe22f1d75802be", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -15,8 +15,7 @@ use json::ToJson;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n use arc::{Arc,RWArc};\n use treemap::TreeMap;\n-use std::comm::{PortOne, oneshot};\n-use std::{str, task};\n+use std::str;\n use std::io;\n use std::io::{File, Decorator};\n use std::io::mem::MemWriter;\n@@ -252,7 +251,7 @@ pub struct Exec {\n \n enum Work<'a, T> {\n     WorkValue(T),\n-    WorkFromTask(&'a Prep<'a>, PortOne<(Exec, T)>),\n+    WorkFromTask(&'a Prep<'a>, Port<(Exec, T)>),\n }\n \n fn json_encode<'a, T:Encodable<json::Encoder<'a>>>(t: &T) -> ~str {\n@@ -427,11 +426,11 @@ impl<'a> Prep<'a> {\n \n             _ => {\n                 debug!(\"Cache miss!\");\n-                let (port, chan) = oneshot();\n+                let (port, chan) = Chan::new();\n                 let blk = bo.take_unwrap();\n \n                 // XXX: What happens if the task fails?\n-                do task::spawn {\n+                do spawn {\n                     let mut exe = Exec {\n                         discovered_inputs: WorkMap::new(),\n                         discovered_outputs: WorkMap::new(),\n@@ -453,7 +452,7 @@ impl<'a, T:Send +\n     pub fn from_value(elt: T) -> Work<'a, T> {\n         WorkValue(elt)\n     }\n-    pub fn from_task(prep: &'a Prep<'a>, port: PortOne<(Exec, T)>)\n+    pub fn from_task(prep: &'a Prep<'a>, port: Port<(Exec, T)>)\n         -> Work<'a, T> {\n         WorkFromTask(prep, port)\n     }"}, {"sha": "c5be6776eef117583855f96e9fc62840bb13becd", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -27,6 +27,7 @@ use driver::driver::{compile_input};\n use driver::session;\n use middle::lint;\n \n+use std::cast;\n use std::comm;\n use std::io;\n use std::io::Reader;\n@@ -303,7 +304,8 @@ impl diagnostic::Emitter for RustcEmitter {\n             msg: &str,\n             lvl: diagnostic::level) {\n         if lvl == diagnostic::fatal {\n-            self.ch_capture.send(fatal)\n+            let this = unsafe { cast::transmute_mut(self) };\n+            this.ch_capture.send(fatal)\n         }\n \n         diagnostic::DefaultEmitter.emit(cmsp, msg, lvl)\n@@ -333,8 +335,7 @@ pub fn monitor(f: proc(@diagnostic::Emitter)) {\n     #[cfg(not(rtopt))]\n     static STACK_SIZE: uint = 20000000; // 20MB\n \n-    let (p, ch) = stream();\n-    let ch = SharedChan::new(ch);\n+    let (p, ch) = SharedChan::new();\n     let ch_capture = ch.clone();\n     let mut task_builder = task::task();\n     task_builder.name(\"rustc\");"}, {"sha": "04da17d4ec441247d19ae160d5a2f47e680fe889", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 55, "deletions": 57, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -174,71 +174,70 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n         let loc = loc.unwrap();\n \n         local_data::get(cache_key, |cache| {\n-            cache.unwrap().read(|cache| {\n-                let abs_root = root(cache, loc.as_slice());\n-                let rel_root = match path.segments[0].name.as_slice() {\n-                    \"self\" => Some(~\"./\"),\n-                    _ => None,\n-                };\n-\n-                if print_all {\n-                    let amt = path.segments.len() - 1;\n-                    match rel_root {\n-                        Some(root) => {\n-                            let mut root = root;\n-                            for seg in path.segments.slice_to(amt).iter() {\n-                                if \"super\" == seg.name || \"self\" == seg.name {\n-                                    write!(w, \"{}::\", seg.name);\n-                                } else {\n-                                    root.push_str(seg.name);\n-                                    root.push_str(\"/\");\n-                                    write!(w, \"<a class='mod'\n-                                                  href='{}index.html'>{}</a>::\",\n-                                           root,\n-                                           seg.name);\n-                                }\n-                            }\n-                        }\n-                        None => {\n-                            for seg in path.segments.slice_to(amt).iter() {\n+            let cache = cache.unwrap().get();\n+            let abs_root = root(cache, loc.as_slice());\n+            let rel_root = match path.segments[0].name.as_slice() {\n+                \"self\" => Some(~\"./\"),\n+                _ => None,\n+            };\n+\n+            if print_all {\n+                let amt = path.segments.len() - 1;\n+                match rel_root {\n+                    Some(root) => {\n+                        let mut root = root;\n+                        for seg in path.segments.slice_to(amt).iter() {\n+                            if \"super\" == seg.name || \"self\" == seg.name {\n                                 write!(w, \"{}::\", seg.name);\n+                            } else {\n+                                root.push_str(seg.name);\n+                                root.push_str(\"/\");\n+                                write!(w, \"<a class='mod'\n+                                              href='{}index.html'>{}</a>::\",\n+                                       root,\n+                                       seg.name);\n                             }\n                         }\n                     }\n+                    None => {\n+                        for seg in path.segments.slice_to(amt).iter() {\n+                            write!(w, \"{}::\", seg.name);\n+                        }\n+                    }\n                 }\n+            }\n \n-                match info(cache) {\n-                    // This is a documented path, link to it!\n-                    Some((ref fqp, shortty)) if abs_root.is_some() => {\n-                        let mut url = abs_root.unwrap();\n-                        let to_link = fqp.slice_to(fqp.len() - 1);\n-                        for component in to_link.iter() {\n-                            url.push_str(*component);\n-                            url.push_str(\"/\");\n+            match info(cache) {\n+                // This is a documented path, link to it!\n+                Some((ref fqp, shortty)) if abs_root.is_some() => {\n+                    let mut url = abs_root.unwrap();\n+                    let to_link = fqp.slice_to(fqp.len() - 1);\n+                    for component in to_link.iter() {\n+                        url.push_str(*component);\n+                        url.push_str(\"/\");\n+                    }\n+                    match shortty {\n+                        \"mod\" => {\n+                            url.push_str(*fqp.last());\n+                            url.push_str(\"/index.html\");\n                         }\n-                        match shortty {\n-                            \"mod\" => {\n-                                url.push_str(*fqp.last());\n-                                url.push_str(\"/index.html\");\n-                            }\n-                            _ => {\n-                                url.push_str(shortty);\n-                                url.push_str(\".\");\n-                                url.push_str(*fqp.last());\n-                                url.push_str(\".html\");\n-                            }\n+                        _ => {\n+                            url.push_str(shortty);\n+                            url.push_str(\".\");\n+                            url.push_str(*fqp.last());\n+                            url.push_str(\".html\");\n                         }\n-\n-                        write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n-                               shortty, url, fqp.connect(\"::\"), last.name);\n                     }\n \n-                    _ => {\n-                        write!(w, \"{}\", last.name);\n-                    }\n+                    write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n+                           shortty, url, fqp.connect(\"::\"), last.name);\n                 }\n-                write!(w, \"{}\", generics);\n-            })\n+\n+                _ => {\n+                    write!(w, \"{}\", last.name);\n+                }\n+            }\n+            write!(w, \"{}\", generics);\n         })\n     })\n }\n@@ -263,9 +262,8 @@ impl fmt::Default for clean::Type {\n         match *g {\n             clean::TyParamBinder(id) | clean::Generic(id) => {\n                 local_data::get(cache_key, |cache| {\n-                    cache.unwrap().read(|m| {\n-                        f.buf.write(m.typarams.get(&id).as_bytes());\n-                    })\n+                    let m = cache.unwrap().get();\n+                    f.buf.write(m.typarams.get(&id).as_bytes());\n                 })\n             }\n             clean::ResolvedPath{id, typarams: ref tp, path: ref path} => {"}, {"sha": "82122c4c32fb59e76d8dd8e0b21f1fa58099219a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 85, "deletions": 181, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -33,21 +33,17 @@\n //! These tasks are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n-use std::comm::{SharedPort, SharedChan};\n-use std::comm;\n use std::fmt;\n use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n use std::io::buffered::BufferedWriter;\n use std::io;\n use std::io::fs;\n use std::io::File;\n-use std::os;\n use std::str;\n-use std::task;\n use std::vec;\n \n-use extra::arc::RWArc;\n+use extra::arc::Arc;\n use extra::json::ToJson;\n use extra::sort;\n \n@@ -121,7 +117,7 @@ enum Implementor {\n ///\n /// This structure purposefully does not implement `Clone` because it's intended\n /// to be a fairly large and expensive structure to clone. Instead this adheres\n-/// to both `Send` and `Freeze` so it may be stored in a `RWArc` instance and\n+/// to both `Send` and `Freeze` so it may be stored in a `Arc` instance and\n /// shared among the various rendering tasks.\n pub struct Cache {\n     /// Mapping of typaram ids to the name of the type parameter. This is used\n@@ -197,7 +193,7 @@ struct IndexItem {\n \n // TLS keys used to carry information around during rendering.\n \n-local_data_key!(pub cache_key: RWArc<Cache>)\n+local_data_key!(pub cache_key: Arc<Cache>)\n local_data_key!(pub current_location_key: ~[~str])\n \n /// Generates the documentation for `crate` into the directory `dst`\n@@ -640,22 +636,6 @@ impl<'a> Cache {\n     }\n }\n \n-enum Progress {\n-    JobNew,\n-    JobDone,\n-}\n-\n-/// A helper object to unconditionally send a value on a chanel.\n-struct ChannelGuard {\n-    channel: SharedChan<Progress>,\n-}\n-\n-impl Drop for ChannelGuard {\n-    fn drop(&mut self) {\n-        self.channel.send(JobDone)\n-    }\n-}\n-\n impl Context {\n     /// Recurse in the directory structure and change the \"root path\" to make\n     /// sure it always points to the top (relatively)\n@@ -680,97 +660,26 @@ impl Context {\n         return ret;\n     }\n \n-    /// Main method for rendering a crate. This parallelizes the task of\n-    /// rendering a crate, and requires ownership of the crate in order to break\n-    /// it up into its separate components.\n-    fn crate(self, mut crate: clean::Crate, cache: Cache) {\n-        enum Work {\n-            Die,\n-            Process(Context, clean::Item),\n-        }\n-        let workers = match os::getenv(\"RUSTDOC_WORKERS\") {\n-            Some(s) => {\n-                match from_str::<uint>(s) {\n-                    Some(n) => n, None => fail!(\"{} not a number\", s)\n-                }\n-            }\n-            None => 10,\n-        };\n-\n+    /// Main method for rendering a crate.\n+    ///\n+    /// This currently isn't parallelized, but it'd be pretty easy to add\n+    /// parallelization to this function.\n+    fn crate(mut self, mut crate: clean::Crate, cache: Cache) {\n         let mut item = match crate.module.take() {\n             Some(i) => i,\n             None => return\n         };\n         item.name = Some(crate.name);\n \n-        let (port, chan) = comm::stream::<Work>();\n-        let port = SharedPort::new(port);\n-        let chan = SharedChan::new(chan);\n-        let (prog_port, prog_chan) = comm::stream();\n-        let prog_chan = SharedChan::new(prog_chan);\n-        let cache = RWArc::new(cache);\n-\n-        // Each worker thread receives work from a shared port and publishes\n-        // new work onto the corresponding shared port. All of the workers are\n-        // using the same channel/port. Through this, the crate is recursed on\n-        // in a hierarchical fashion, and parallelization is only achieved if\n-        // one node in the hierarchy has more than one child (very common).\n-        for i in range(0, workers) {\n-            let port = port.clone();\n-            let chan = chan.clone();\n-            let prog_chan = prog_chan.clone();\n-\n-            let mut task = task::task();\n-            task.name(format!(\"worker{}\", i));\n-            let cache = cache.clone();\n-            do task.spawn {\n-                worker(cache, &port, &chan, &prog_chan);\n-            }\n-\n-            fn worker(cache: RWArc<Cache>,\n-                      port: &SharedPort<Work>,\n-                      chan: &SharedChan<Work>,\n-                      prog_chan: &SharedChan<Progress>) {\n-                local_data::set(cache_key, cache);\n-\n-                loop {\n-                    match port.recv() {\n-                        Process(cx, item) => {\n-                            let mut cx = cx;\n-\n-                            // If we fail, everything else should still get\n-                            // completed.\n-                            let _guard = ChannelGuard {\n-                                channel: prog_chan.clone(),\n-                            };\n-                            cx.item(item, |cx, item| {\n-                                prog_chan.send(JobNew);\n-                                chan.send(Process(cx.clone(), item));\n-                            })\n-                        }\n-                        Die => break,\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Send off the initial job\n-        chan.send(Process(self, item));\n-        let mut jobs = 1;\n+        // using a rwarc makes this parallelizable in the future\n+        local_data::set(cache_key, Arc::new(cache));\n \n-        // Keep track of the number of jobs active in the system and kill\n-        // everything once there are no more jobs remaining.\n-        loop {\n-            match prog_port.recv() {\n-                JobNew => jobs += 1,\n-                JobDone => jobs -= 1,\n-            }\n-\n-            if jobs == 0 { break }\n-        }\n-\n-        for _ in range(0, workers) {\n-            chan.send(Die);\n+        let mut work = ~[item];\n+        while work.len() > 0 {\n+            let item = work.pop();\n+            self.item(item, |_cx, item| {\n+                work.push(item);\n+            })\n         }\n     }\n \n@@ -1210,29 +1119,28 @@ fn item_trait(w: &mut Writer, it: &clean::Item, t: &clean::Trait) {\n     }\n \n     local_data::get(cache_key, |cache| {\n-        cache.unwrap().read(|cache| {\n-            match cache.implementors.find(&it.id) {\n-                Some(implementors) => {\n-                    write!(w, \"\n-                        <h2 id='implementors'>Implementors</h2>\n-                        <ul class='item-list'>\n-                    \");\n-                    for i in implementors.iter() {\n-                        match *i {\n-                            PathType(ref ty) => {\n-                                write!(w, \"<li><code>{}</code></li>\", *ty);\n-                            }\n-                            OtherType(ref generics, ref trait_, ref for_) => {\n-                                write!(w, \"<li><code>impl{} {} for {}</code></li>\",\n-                                       *generics, *trait_, *for_);\n-                            }\n+        let cache = cache.unwrap().get();\n+        match cache.implementors.find(&it.id) {\n+            Some(implementors) => {\n+                write!(w, \"\n+                    <h2 id='implementors'>Implementors</h2>\n+                    <ul class='item-list'>\n+                \");\n+                for i in implementors.iter() {\n+                    match *i {\n+                        PathType(ref ty) => {\n+                            write!(w, \"<li><code>{}</code></li>\", *ty);\n+                        }\n+                        OtherType(ref generics, ref trait_, ref for_) => {\n+                            write!(w, \"<li><code>impl{} {} for {}</code></li>\",\n+                                   *generics, *trait_, *for_);\n                         }\n                     }\n-                    write!(w, \"</ul>\");\n                 }\n-                None => {}\n+                write!(w, \"</ul>\");\n             }\n-        })\n+            None => {}\n+        }\n     })\n }\n \n@@ -1422,36 +1330,34 @@ fn render_struct(w: &mut Writer, it: &clean::Item,\n \n fn render_methods(w: &mut Writer, it: &clean::Item) {\n     local_data::get(cache_key, |cache| {\n-        let cache = cache.unwrap();\n-        cache.read(|c| {\n-            match c.impls.find(&it.id) {\n-                Some(v) => {\n-                    let mut non_trait = v.iter().filter(|p| {\n-                        p.n0_ref().trait_.is_none()\n-                    });\n-                    let non_trait = non_trait.to_owned_vec();\n-                    let mut traits = v.iter().filter(|p| {\n-                        p.n0_ref().trait_.is_some()\n-                    });\n-                    let traits = traits.to_owned_vec();\n-\n-                    if non_trait.len() > 0 {\n-                        write!(w, \"<h2 id='methods'>Methods</h2>\");\n-                        for &(ref i, ref dox) in non_trait.move_iter() {\n-                            render_impl(w, i, dox);\n-                        }\n+        let c = cache.unwrap().get();\n+        match c.impls.find(&it.id) {\n+            Some(v) => {\n+                let mut non_trait = v.iter().filter(|p| {\n+                    p.n0_ref().trait_.is_none()\n+                });\n+                let non_trait = non_trait.to_owned_vec();\n+                let mut traits = v.iter().filter(|p| {\n+                    p.n0_ref().trait_.is_some()\n+                });\n+                let traits = traits.to_owned_vec();\n+\n+                if non_trait.len() > 0 {\n+                    write!(w, \"<h2 id='methods'>Methods</h2>\");\n+                    for &(ref i, ref dox) in non_trait.move_iter() {\n+                        render_impl(w, i, dox);\n                     }\n-                    if traits.len() > 0 {\n-                        write!(w, \"<h2 id='implementations'>Trait \\\n-                                   Implementations</h2>\");\n-                        for &(ref i, ref dox) in traits.move_iter() {\n-                            render_impl(w, i, dox);\n-                        }\n+                }\n+                if traits.len() > 0 {\n+                    write!(w, \"<h2 id='implementations'>Trait \\\n+                               Implementations</h2>\");\n+                    for &(ref i, ref dox) in traits.move_iter() {\n+                        render_impl(w, i, dox);\n                     }\n                 }\n-                None => {}\n             }\n-        })\n+            None => {}\n+        }\n     })\n }\n \n@@ -1502,27 +1408,26 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n             Some(id) => id,\n         };\n         local_data::get(cache_key, |cache| {\n-            cache.unwrap().read(|cache| {\n-                match cache.traits.find(&trait_id) {\n-                    Some(t) => {\n-                        let name = meth.name.clone();\n-                        match t.methods.iter().find(|t| t.item().name == name) {\n-                            Some(method) => {\n-                                match method.item().doc_value() {\n-                                    Some(s) => {\n-                                        write!(w,\n-                                               \"<div class='docblock'>{}</div>\",\n-                                               Markdown(s));\n-                                    }\n-                                    None => {}\n+            let cache = cache.unwrap().get();\n+            match cache.traits.find(&trait_id) {\n+                Some(t) => {\n+                    let name = meth.name.clone();\n+                    match t.methods.iter().find(|t| t.item().name == name) {\n+                        Some(method) => {\n+                            match method.item().doc_value() {\n+                                Some(s) => {\n+                                    write!(w,\n+                                           \"<div class='docblock'>{}</div>\",\n+                                           Markdown(s));\n                                 }\n+                                None => {}\n                             }\n-                            None => {}\n                         }\n+                        None => {}\n                     }\n-                    None => {}\n                 }\n-            })\n+                None => {}\n+            }\n         })\n     }\n \n@@ -1532,22 +1437,21 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n         None => {}\n         Some(id) => {\n             local_data::get(cache_key, |cache| {\n-                cache.unwrap().read(|cache| {\n-                    match cache.traits.find(&id) {\n-                        Some(t) => {\n-                            for method in t.methods.iter() {\n-                                let n = method.item().name.clone();\n-                                match i.methods.iter().find(|m| m.name == n) {\n-                                    Some(..) => continue,\n-                                    None => {}\n-                                }\n-\n-                                docmeth(w, method.item());\n+                let cache = cache.unwrap().get();\n+                match cache.traits.find(&id) {\n+                    Some(t) => {\n+                        for method in t.methods.iter() {\n+                            let n = method.item().name.clone();\n+                            match i.methods.iter().find(|m| m.name == n) {\n+                                Some(..) => continue,\n+                                None => {}\n                             }\n+\n+                            docmeth(w, method.item());\n                         }\n-                        None => {}\n                     }\n-                })\n+                    None => {}\n+                }\n             })\n         }\n     }"}, {"sha": "67777050cf30a5aaa590e23533aadb143d183b0f", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -11,7 +11,7 @@\n use std::libc::c_int;\n use std::io::signal::Signum;\n use std::rt::sched::{SchedHandle, Scheduler};\n-use std::comm::{SharedChan, SendDeferred};\n+use std::comm::SharedChan;\n use std::rt::local::Local;\n use std::rt::rtio::RtioSignal;\n "}, {"sha": "7efdafd236921afaaeeb7a78a1cbc1add3d7b5f2", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::{oneshot, stream, PortOne, ChanOne, SendDeferred};\n use std::libc::c_int;\n use std::rt::BlockedTask;\n use std::rt::local::Local;\n@@ -28,7 +27,7 @@ pub struct TimerWatcher {\n \n pub enum NextAction {\n     WakeTask(BlockedTask),\n-    SendOnce(ChanOne<()>),\n+    SendOnce(Chan<()>),\n     SendMany(Chan<()>),\n }\n \n@@ -95,8 +94,8 @@ impl RtioTimer for TimerWatcher {\n         self.stop();\n     }\n \n-    fn oneshot(&mut self, msecs: u64) -> PortOne<()> {\n-        let (port, chan) = oneshot();\n+    fn oneshot(&mut self, msecs: u64) -> Port<()> {\n+        let (port, chan) = Chan::new();\n \n         // similarly to the destructor, we must drop the previous action outside\n         // of the homing missile\n@@ -111,7 +110,7 @@ impl RtioTimer for TimerWatcher {\n     }\n \n     fn period(&mut self, msecs: u64) -> Port<()> {\n-        let (port, chan) = stream();\n+        let (port, chan) = Chan::new();\n \n         // similarly to the destructor, we must drop the previous action outside\n         // of the homing missile"}, {"sha": "2d9bc6e9c12bc11582408c52cb70a1d083dda026", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -41,6 +41,8 @@\n //!     }\n //! )\n \n+#[allow(dead_code)];\n+\n use cast;\n use iter::Iterator;\n use kinds::Send;"}, {"sha": "7f94af8307eae8ee6ce2f97a2ae5f2863af1469b", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 13, "deletions": 35, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -10,7 +10,7 @@\n \n use prelude::*;\n \n-use comm::{GenericPort, GenericChan, GenericSmartChan};\n+use comm::{Port, Chan};\n use cmp;\n use io;\n use option::{None, Option, Some};\n@@ -30,15 +30,15 @@ use vec::{bytes, CopyableVector, MutableVector, ImmutableVector};\n ///     None => println!(\"At the end of the stream!\")\n /// }\n /// ```\n-pub struct PortReader<P> {\n+pub struct PortReader {\n     priv buf: Option<~[u8]>,  // A buffer of bytes received but not consumed.\n     priv pos: uint,           // How many of the buffered bytes have already be consumed.\n-    priv port: P,             // The port to pull data from.\n+    priv port: Port<~[u8]>,   // The port to pull data from.\n     priv closed: bool,        // Whether the pipe this port connects to has been closed.\n }\n \n-impl<P: GenericPort<~[u8]>> PortReader<P> {\n-    pub fn new(port: P) -> PortReader<P> {\n+impl PortReader {\n+    pub fn new(port: Port<~[u8]>) -> PortReader<P> {\n         PortReader {\n             buf: None,\n             pos: 0,\n@@ -48,7 +48,7 @@ impl<P: GenericPort<~[u8]>> PortReader<P> {\n     }\n }\n \n-impl<P: GenericPort<~[u8]>> Reader for PortReader<P> {\n+impl Reader for PortReader {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         let mut num_read = 0;\n         loop {\n@@ -67,7 +67,7 @@ impl<P: GenericPort<~[u8]>> Reader for PortReader<P> {\n                 break;\n             }\n             self.pos = 0;\n-            self.buf = self.port.try_recv();\n+            self.buf = self.port.recv_opt();\n             self.closed = self.buf.is_none();\n         }\n         if self.closed && num_read == 0 {\n@@ -89,17 +89,17 @@ impl<P: GenericPort<~[u8]>> Reader for PortReader<P> {\n /// let writer = ChanWriter::new(chan);\n /// writer.write(\"hello, world\".as_bytes());\n /// ```\n-pub struct ChanWriter<C> {\n-    chan: C,\n+pub struct ChanWriter {\n+    chan: Chan<~[u8]>,\n }\n \n-impl<C: GenericSmartChan<~[u8]>> ChanWriter<C> {\n+impl ChanWriter {\n     pub fn new(chan: C) -> ChanWriter<C> {\n         ChanWriter { chan: chan }\n     }\n }\n \n-impl<C: GenericSmartChan<~[u8]>> Writer for ChanWriter<C> {\n+impl Writer for ChanWriter {\n     fn write(&mut self, buf: &[u8]) {\n         if !self.chan.try_send(buf.to_owned()) {\n             io::io_error::cond.raise(io::IoError {\n@@ -111,28 +111,6 @@ impl<C: GenericSmartChan<~[u8]>> Writer for ChanWriter<C> {\n     }\n }\n \n-pub struct ReaderPort<R>;\n-\n-impl<R: Reader> ReaderPort<R> {\n-    pub fn new(_reader: R) -> ReaderPort<R> { fail!() }\n-}\n-\n-impl<R: Reader> GenericPort<~[u8]> for ReaderPort<R> {\n-    fn recv(&self) -> ~[u8] { fail!() }\n-\n-    fn try_recv(&self) -> Option<~[u8]> { fail!() }\n-}\n-\n-pub struct WriterChan<W>;\n-\n-impl<W: Writer> WriterChan<W> {\n-    pub fn new(_writer: W) -> WriterChan<W> { fail!() }\n-}\n-\n-impl<W: Writer> GenericChan<~[u8]> for WriterChan<W> {\n-    fn send(&self, _x: ~[u8]) { fail!() }\n-}\n-\n \n #[cfg(test)]\n mod test {\n@@ -144,7 +122,7 @@ mod test {\n \n     #[test]\n     fn test_port_reader() {\n-        let (port, chan) = comm::stream();\n+        let (port, chan) = Chan::new();\n         do task::spawn {\n           chan.send(~[1u8, 2u8]);\n           chan.send(~[]);\n@@ -199,7 +177,7 @@ mod test {\n \n     #[test]\n     fn test_chan_writer() {\n-        let (port, chan) = comm::stream();\n+        let (port, chan) = Chan::new();\n         let mut writer = ChanWriter::new(chan);\n         writer.write_be_u32(42);\n "}, {"sha": "2e9056a6aee48d8f5eb07df3d1e0ffb5006f3175", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -318,9 +318,6 @@ mod option;\n /// Basic stream compression. XXX: Belongs with other flate code\n pub mod flate;\n \n-/// Interop between byte streams and pipes. Not sure where it belongs\n-pub mod comm_adapters;\n-\n /// Extension traits\n pub mod extensions;\n "}, {"sha": "a6230ede7e34887f74da1524b070627e1e80f715", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 59, "deletions": 82, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -151,7 +151,6 @@ mod test {\n     use io::net::ip::{Ipv4Addr, SocketAddr};\n     use io::*;\n     use prelude::*;\n-    use rt::comm::oneshot;\n \n     #[test] #[ignore]\n     fn bind_error() {\n@@ -195,7 +194,7 @@ mod test {\n     fn smoke_test_ip4() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -206,19 +205,17 @@ mod test {\n                 assert!(buf[0] == 99);\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let mut stream = TcpStream::connect(addr);\n-                stream.write([99]);\n-            }\n+            port.recv();\n+            let mut stream = TcpStream::connect(addr);\n+            stream.write([99]);\n         }\n     }\n \n     #[test]\n     fn smoke_test_ip6() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -229,19 +226,17 @@ mod test {\n                 assert!(buf[0] == 99);\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let mut stream = TcpStream::connect(addr);\n-                stream.write([99]);\n-            }\n+            port.recv();\n+            let mut stream = TcpStream::connect(addr);\n+            stream.write([99]);\n         }\n     }\n \n     #[test]\n     fn read_eof_ip4() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -252,19 +247,17 @@ mod test {\n                 assert!(nread.is_none());\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let _stream = TcpStream::connect(addr);\n-                // Close\n-            }\n+            port.recv();\n+            let _stream = TcpStream::connect(addr);\n+            // Close\n         }\n     }\n \n     #[test]\n     fn read_eof_ip6() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -275,19 +268,17 @@ mod test {\n                 assert!(nread.is_none());\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let _stream = TcpStream::connect(addr);\n-                // Close\n-            }\n+            port.recv();\n+            let _stream = TcpStream::connect(addr);\n+            // Close\n         }\n     }\n \n     #[test]\n     fn read_eof_twice_ip4() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -308,19 +299,17 @@ mod test {\n                 })\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let _stream = TcpStream::connect(addr);\n-                // Close\n-            }\n+            port.recv();\n+            let _stream = TcpStream::connect(addr);\n+            // Close\n         }\n     }\n \n     #[test]\n     fn read_eof_twice_ip6() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -341,19 +330,17 @@ mod test {\n                 })\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let _stream = TcpStream::connect(addr);\n-                // Close\n-            }\n+            port.recv();\n+            let _stream = TcpStream::connect(addr);\n+            // Close\n         }\n     }\n \n     #[test]\n     fn write_close_ip4() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -377,19 +364,17 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let _stream = TcpStream::connect(addr);\n-                // Close\n-            }\n+            port.recv();\n+            let _stream = TcpStream::connect(addr);\n+            // Close\n         }\n     }\n \n     #[test]\n     fn write_close_ip6() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -413,11 +398,9 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let _stream = TcpStream::connect(addr);\n-                // Close\n-            }\n+            port.recv();\n+            let _stream = TcpStream::connect(addr);\n+            // Close\n         }\n     }\n \n@@ -426,7 +409,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n             let max = 10;\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -438,13 +421,11 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                port.recv();\n-                max.times(|| {\n-                    let mut stream = TcpStream::connect(addr);\n-                    stream.write([99]);\n-                });\n-            }\n+            port.recv();\n+            max.times(|| {\n+                let mut stream = TcpStream::connect(addr);\n+                stream.write([99]);\n+            });\n         }\n     }\n \n@@ -453,7 +434,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n             let max = 10;\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -465,13 +446,11 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                port.recv();\n-                max.times(|| {\n-                    let mut stream = TcpStream::connect(addr);\n-                    stream.write([99]);\n-                });\n-            }\n+            port.recv();\n+            max.times(|| {\n+                let mut stream = TcpStream::connect(addr);\n+                stream.write([99]);\n+            });\n         }\n     }\n \n@@ -480,7 +459,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n             static MAX: int = 10;\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -520,7 +499,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n             static MAX: int = 10;\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -560,7 +539,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n             static MAX: int = 10;\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -599,7 +578,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n             static MAX: int = 10;\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -653,7 +632,7 @@ mod test {\n     #[cfg(test)]\n     fn peer_name(addr: SocketAddr) {\n         do run_in_mt_newsched_task {\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -662,20 +641,18 @@ mod test {\n                 acceptor.accept();\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let stream = TcpStream::connect(addr);\n+            port.recv();\n+            let stream = TcpStream::connect(addr);\n \n-                assert!(stream.is_some());\n-                let mut stream = stream.unwrap();\n+            assert!(stream.is_some());\n+            let mut stream = stream.unwrap();\n \n-                // Make sure peer_name gives us the\n-                // address/port of the peer we've\n-                // connected to.\n-                let peer_name = stream.peer_name();\n-                assert!(peer_name.is_some());\n-                assert_eq!(addr, peer_name.unwrap());\n-            }\n+            // Make sure peer_name gives us the\n+            // address/port of the peer we've\n+            // connected to.\n+            let peer_name = stream.peer_name();\n+            assert!(peer_name.is_some());\n+            assert_eq!(addr, peer_name.unwrap());\n         }\n     }\n "}, {"sha": "1e56f964bea529a03e536714ff8591e0377e285d", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 29, "deletions": 38, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -107,8 +107,7 @@ mod test {\n     use rt::test::*;\n     use io::net::ip::{Ipv4Addr, SocketAddr};\n     use io::*;\n-    use option::{Some, None};\n-    use rt::comm::oneshot;\n+    use prelude::*;\n \n     #[test]  #[ignore]\n     fn bind_error() {\n@@ -131,7 +130,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let server_ip = next_test_ip4();\n             let client_ip = next_test_ip4();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n@@ -151,14 +150,12 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                match UdpSocket::bind(client_ip) {\n-                    Some(ref mut client) => {\n-                        port.recv();\n-                        client.sendto([99], server_ip)\n-                    }\n-                    None => fail!()\n+            match UdpSocket::bind(client_ip) {\n+                Some(ref mut client) => {\n+                    port.recv();\n+                    client.sendto([99], server_ip)\n                 }\n+                None => fail!()\n             }\n         }\n     }\n@@ -168,7 +165,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let server_ip = next_test_ip6();\n             let client_ip = next_test_ip6();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n@@ -188,14 +185,12 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                match UdpSocket::bind(client_ip) {\n-                    Some(ref mut client) => {\n-                        port.recv();\n-                        client.sendto([99], server_ip)\n-                    }\n-                    None => fail!()\n+            match UdpSocket::bind(client_ip) {\n+                Some(ref mut client) => {\n+                    port.recv();\n+                    client.sendto([99], server_ip)\n                 }\n+                None => fail!()\n             }\n         }\n     }\n@@ -205,7 +200,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let server_ip = next_test_ip4();\n             let client_ip = next_test_ip4();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n@@ -226,16 +221,14 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                match UdpSocket::bind(client_ip) {\n-                    Some(client) => {\n-                        let client = ~client;\n-                        let mut stream = client.connect(server_ip);\n-                        port.recv();\n-                        stream.write([99]);\n-                    }\n-                    None => fail!()\n+            match UdpSocket::bind(client_ip) {\n+                Some(client) => {\n+                    let client = ~client;\n+                    let mut stream = client.connect(server_ip);\n+                    port.recv();\n+                    stream.write([99]);\n                 }\n+                None => fail!()\n             }\n         }\n     }\n@@ -245,7 +238,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let server_ip = next_test_ip6();\n             let client_ip = next_test_ip6();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n@@ -266,16 +259,14 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                match UdpSocket::bind(client_ip) {\n-                    Some(client) => {\n-                        let client = ~client;\n-                        let mut stream = client.connect(server_ip);\n-                        port.recv();\n-                        stream.write([99]);\n-                    }\n-                    None => fail!()\n+            match UdpSocket::bind(client_ip) {\n+                Some(client) => {\n+                    let client = ~client;\n+                    let mut stream = client.connect(server_ip);\n+                    port.recv();\n+                    stream.write([99]);\n                 }\n+                None => fail!()\n             }\n         }\n     }"}, {"sha": "d3fc265cf2aa8135e6e6440758a95fb18a7e0ee0", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -152,25 +152,22 @@ mod tests {\n     use super::*;\n     use rt::test::*;\n     use io::*;\n-    use rt::comm::oneshot;\n \n     fn smalltest(server: proc(UnixStream), client: proc(UnixStream)) {\n         do run_in_mt_newsched_task {\n             let path1 = next_test_unix();\n             let path2 = path1.clone();\n-            let (port, chan) = oneshot();\n             let (client, server) = (client, server);\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = UnixListener::bind(&path1).listen();\n                 chan.send(());\n-                server(acceptor.accept().unwrap());\n+                server.take()(acceptor.accept().unwrap());\n             }\n \n-            do spawntask {\n-                port.recv();\n-                client(UnixStream::connect(&path2).unwrap());\n-            }\n+            port.recv();\n+            client.take()(UnixStream::connect(&path2).unwrap());\n         }\n     }\n \n@@ -251,7 +248,7 @@ mod tests {\n             let times = 10;\n             let path1 = next_test_unix();\n             let path2 = path1.clone();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = UnixListener::bind(&path1).listen();\n@@ -264,13 +261,11 @@ mod tests {\n                 })\n             }\n \n-            do spawntask {\n-                port.recv();\n-                times.times(|| {\n-                    let mut stream = UnixStream::connect(&path2);\n-                    stream.write([100]);\n-                })\n-            }\n+            port.recv();\n+            times.times(|| {\n+                let mut stream = UnixStream::connect(&path2);\n+                stream.write([100]);\n+            })\n         }\n     }\n "}, {"sha": "c568a19dfa23381ea4b12233adc0c8f3ecf42926", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -20,7 +20,7 @@ definitions for a number of signals.\n */\n \n use clone::Clone;\n-use comm::{Port, SharedChan, stream};\n+use comm::{Port, SharedChan};\n use container::{Map, MutableMap};\n use hashmap;\n use io::io_error;\n@@ -93,9 +93,9 @@ impl Listener {\n     /// Creates a new listener for signals. Once created, signals are bound via\n     /// the `register` method (otherwise nothing will ever be received)\n     pub fn new() -> Listener {\n-        let (port, chan) = stream();\n+        let (port, chan) = SharedChan::new();\n         Listener {\n-            chan: SharedChan::new(chan),\n+            chan: chan,\n             port: port,\n             handles: hashmap::HashMap::new(),\n         }\n@@ -149,7 +149,6 @@ mod test {\n     use libc;\n     use io::timer;\n     use super::{Listener, Interrupt};\n-    use comm::{GenericPort, Peekable};\n \n     // kill is only available on Unixes\n     #[cfg(unix)]\n@@ -198,9 +197,7 @@ mod test {\n         s2.unregister(Interrupt);\n         sigint();\n         timer::sleep(10);\n-        if s2.port.peek() {\n-            fail!(\"Unexpected {:?}\", s2.port.recv());\n-        }\n+        assert!(s2.port.try_recv().is_none());\n     }\n \n     #[cfg(windows)]"}, {"sha": "5fb64ab3d09dbdc2de9827c30ea92e68b5da0ae9", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -38,7 +38,7 @@ loop {\n \n */\n \n-use comm::{Port, PortOne};\n+use comm::Port;\n use option::{Option, Some, None};\n use result::{Ok, Err};\n use io::io_error;\n@@ -86,7 +86,7 @@ impl Timer {\n     /// Note that this invalidates any previous port which has been created by\n     /// this timer, and that the returned port will be invalidated once the\n     /// timer is destroyed (when it falls out of scope).\n-    pub fn oneshot(&mut self, msecs: u64) -> PortOne<()> {\n+    pub fn oneshot(&mut self, msecs: u64) -> Port<()> {\n         self.obj.oneshot(msecs)\n     }\n "}, {"sha": "53e26e435b7df7eeef1ad53eaab8f655322a0e32", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -156,7 +156,6 @@ pub mod trie;\n \n pub mod task;\n pub mod comm;\n-pub mod select;\n pub mod local_data;\n \n "}, {"sha": "201259679cc6f5bfac63a7b48d259073b6dc311c", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -84,7 +84,7 @@ pub use vec::{OwnedVector, OwnedCopyableVector,OwnedEqVector, MutableVector};\n pub use vec::{Vector, VectorVector, CopyableVector, ImmutableVector};\n \n // Reexported runtime types\n-pub use comm::{stream, Port, Chan, GenericChan, GenericSmartChan, GenericPort, Peekable};\n+pub use comm::{Port, Chan, SharedChan};\n pub use task::spawn;\n \n /// Disposes of a value."}, {"sha": "1eaf1a29fa8940da910110bb90efb6866b36fd27", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -135,8 +135,10 @@ impl Drop for OSRng {\n \n #[cfg(test)]\n mod test {\n+    use prelude::*;\n     use super::*;\n     use rand::Rng;\n+    use task;\n \n     #[test]\n     fn test_os_rng() {\n@@ -151,16 +153,10 @@ mod test {\n \n     #[test]\n     fn test_os_rng_tasks() {\n-        use task;\n-        use comm;\n-        use comm::{GenericChan, GenericPort};\n-        use option::{None, Some};\n-        use iter::{Iterator, range};\n-        use vec::{ImmutableVector, OwnedVector};\n \n         let mut chans = ~[];\n         for _ in range(0, 20) {\n-            let (p, c) = comm::stream();\n+            let (p, c) = Chan::new();\n             chans.push(c);\n             do task::spawn {\n                 // wait until all the tasks are ready to go."}, {"sha": "2fa349942928e15d3da5eddaa0ce954ce118ee91", "filename": "src/libstd/rt/comm.rs", "status": "removed", "additions": 0, "deletions": 1141, "changes": 1141, "blob_url": "https://github.com/rust-lang/rust/blob/bfa9064ba2687eb1d95708f72f41ddd9729a6ba1/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa9064ba2687eb1d95708f72f41ddd9729a6ba1/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=bfa9064ba2687eb1d95708f72f41ddd9729a6ba1", "patch": "@@ -1,1141 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Ports and channels.\n-\n-use option::*;\n-use cast;\n-use ops::Drop;\n-use rt::kill::BlockedTask;\n-use kinds::Send;\n-use rt;\n-use rt::sched::Scheduler;\n-use rt::local::Local;\n-use rt::select::{SelectInner, SelectPortInner};\n-use select::{Select, SelectPort};\n-use unstable::atomics::{AtomicUint, AtomicOption, Acquire, Relaxed, SeqCst};\n-use unstable::sync::UnsafeArc;\n-use util;\n-use util::Void;\n-use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable, SendDeferred};\n-use cell::RefCell;\n-use clone::Clone;\n-use tuple::ImmutableTuple;\n-\n-/// A combined refcount / BlockedTask-as-uint pointer.\n-///\n-/// Can be equal to the following values:\n-///\n-/// * 2 - both endpoints are alive\n-/// * 1 - either the sender or the receiver is dead, determined by context\n-/// * <ptr> - A pointer to a blocked Task (see BlockedTask::cast_{to,from}_uint)\n-type State = uint;\n-\n-static STATE_BOTH: State = 2;\n-static STATE_ONE: State = 1;\n-\n-/// The heap-allocated structure shared between two endpoints.\n-struct Packet<T> {\n-    state: AtomicUint,\n-    payload: Option<T>,\n-}\n-\n-// A one-shot channel.\n-pub struct ChanOne<T> {\n-    priv void_packet: *mut Void,\n-    priv suppress_finalize: bool\n-}\n-\n-/// A one-shot port.\n-pub struct PortOne<T> {\n-    priv void_packet: *mut Void,\n-    priv suppress_finalize: bool\n-}\n-\n-pub fn oneshot<T: Send>() -> (PortOne<T>, ChanOne<T>) {\n-    let packet: ~Packet<T> = ~Packet {\n-        state: AtomicUint::new(STATE_BOTH),\n-        payload: None\n-    };\n-\n-    unsafe {\n-        let packet: *mut Void = cast::transmute(packet);\n-        let port = PortOne {\n-            void_packet: packet,\n-            suppress_finalize: false\n-        };\n-        let chan = ChanOne {\n-            void_packet: packet,\n-            suppress_finalize: false\n-        };\n-        return (port, chan);\n-    }\n-}\n-\n-impl<T: Send> ChanOne<T> {\n-    #[inline]\n-    fn packet(&self) -> *mut Packet<T> {\n-        unsafe {\n-            let p: *mut ~Packet<T> = cast::transmute(&self.void_packet);\n-            let p: *mut Packet<T> = &mut **p;\n-            return p;\n-        }\n-    }\n-\n-    /// Send a message on the one-shot channel. If a receiver task is blocked\n-    /// waiting for the message, will wake it up and reschedule to it.\n-    pub fn send(self, val: T) {\n-        self.try_send(val);\n-    }\n-\n-    /// As `send`, but also returns whether or not the receiver endpoint is still open.\n-    pub fn try_send(self, val: T) -> bool {\n-        self.try_send_inner(val, true)\n-    }\n-\n-    /// Send a message without immediately rescheduling to a blocked receiver.\n-    /// This can be useful in contexts where rescheduling is forbidden, or to\n-    /// optimize for when the sender expects to still have useful work to do.\n-    pub fn send_deferred(self, val: T) {\n-        self.try_send_deferred(val);\n-    }\n-\n-    /// As `send_deferred` and `try_send` together.\n-    pub fn try_send_deferred(self, val: T) -> bool {\n-        self.try_send_inner(val, false)\n-    }\n-\n-    // 'do_resched' configures whether the scheduler immediately switches to\n-    // the receiving task, or leaves the sending task still running.\n-    fn try_send_inner(mut self, val: T, do_resched: bool) -> bool {\n-        if do_resched {\n-            rtassert!(!rt::in_sched_context());\n-        }\n-\n-        // In order to prevent starvation of other tasks in situations\n-        // where a task sends repeatedly without ever receiving, we\n-        // occassionally yield instead of doing a send immediately.\n-        // Only doing this if we're doing a rescheduling send,\n-        // otherwise the caller is expecting not to context switch.\n-        if do_resched {\n-            // XXX: This TLS hit should be combined with other uses of the scheduler below\n-            let sched: ~Scheduler = Local::take();\n-            sched.maybe_yield();\n-        }\n-\n-        let mut recvr_active = true;\n-        let packet = self.packet();\n-\n-        unsafe {\n-\n-            // Install the payload\n-            rtassert!((*packet).payload.is_none());\n-            (*packet).payload = Some(val);\n-\n-            // Atomically swap out the old state to figure out what\n-            // the port's up to, issuing a release barrier to prevent\n-            // reordering of the payload write. This also issues an\n-            // acquire barrier that keeps the subsequent access of the\n-            // ~Task pointer from being reordered.\n-            let oldstate = (*packet).state.swap(STATE_ONE, SeqCst);\n-\n-            // Suppress the synchronizing actions in the finalizer. We're\n-            // done with the packet. NB: In case of do_resched, this *must*\n-            // happen before waking up a blocked task (or be unkillable),\n-            // because we might get a kill signal during the reschedule.\n-            self.suppress_finalize = true;\n-\n-            match oldstate {\n-                STATE_BOTH => {\n-                    // Port is not waiting yet. Nothing to do\n-                }\n-                STATE_ONE => {\n-                    // Port has closed. Need to clean up.\n-                    let _packet: ~Packet<T> = cast::transmute(self.void_packet);\n-                    recvr_active = false;\n-                }\n-                task_as_state => {\n-                    // Port is blocked. Wake it up.\n-                    let recvr = BlockedTask::cast_from_uint(task_as_state);\n-                    if do_resched {\n-                        recvr.wake().map(|woken_task| {\n-                            Scheduler::run_task(woken_task);\n-                        });\n-                    } else {\n-                        let mut sched = Local::borrow(None::<Scheduler>);\n-                        sched.get().enqueue_blocked_task(recvr);\n-                    }\n-                }\n-            }\n-        }\n-\n-        return recvr_active;\n-    }\n-}\n-\n-impl<T: Send> PortOne<T> {\n-    fn packet(&self) -> *mut Packet<T> {\n-        unsafe {\n-            let p: *mut ~Packet<T> = cast::transmute(&self.void_packet);\n-            let p: *mut Packet<T> = &mut **p;\n-            return p;\n-        }\n-    }\n-\n-    /// Wait for a message on the one-shot port. Fails if the send end is closed.\n-    pub fn recv(self) -> T {\n-        match self.try_recv() {\n-            Some(val) => val,\n-            None => {\n-                fail!(\"receiving on closed channel\");\n-            }\n-        }\n-    }\n-\n-    /// As `recv`, but returns `None` if the send end is closed rather than failing.\n-    pub fn try_recv(mut self) -> Option<T> {\n-        // Optimistic check. If data was sent already, we don't even need to block.\n-        // No release barrier needed here; we're not handing off our task pointer yet.\n-        if !self.optimistic_check() {\n-            // No data available yet.\n-            // Switch to the scheduler to put the ~Task into the Packet state.\n-            let sched: ~Scheduler = Local::take();\n-            sched.deschedule_running_task_and_then(|sched, task| {\n-                self.block_on(sched, task);\n-            })\n-        }\n-\n-        // Task resumes.\n-        self.recv_ready()\n-    }\n-}\n-\n-impl<T: Send> SelectInner for PortOne<T> {\n-    #[inline] #[cfg(not(test))]\n-    fn optimistic_check(&mut self) -> bool {\n-        unsafe { (*self.packet()).state.load(Acquire) == STATE_ONE }\n-    }\n-\n-    #[inline] #[cfg(test)]\n-    fn optimistic_check(&mut self) -> bool {\n-        // The optimistic check is never necessary for correctness. For testing\n-        // purposes, making it randomly return false simulates a racing sender.\n-        use rand::{Rand};\n-        let mut sched = Local::borrow(None::<Scheduler>);\n-        let actually_check = Rand::rand(&mut sched.get().rng);\n-        if actually_check {\n-            unsafe { (*self.packet()).state.load(Acquire) == STATE_ONE }\n-        } else {\n-            false\n-        }\n-    }\n-\n-    fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n-        unsafe {\n-            // Atomically swap the task pointer into the Packet state, issuing\n-            // an acquire barrier to prevent reordering of the subsequent read\n-            // of the payload. Also issues a release barrier to prevent\n-            // reordering of any previous writes to the task structure.\n-            let task_as_state = task.cast_to_uint();\n-            let oldstate = (*self.packet()).state.swap(task_as_state, SeqCst);\n-            match oldstate {\n-                STATE_BOTH => {\n-                    // Data has not been sent. Now we're blocked.\n-                    rtdebug!(\"non-rendezvous recv\");\n-                    false\n-                }\n-                STATE_ONE => {\n-                    // Re-record that we are the only owner of the packet.\n-                    // No barrier needed, even if the task gets reawoken\n-                    // on a different core -- this is analogous to writing a\n-                    // payload; a barrier in enqueueing the task protects it.\n-                    // NB(#8132). This *must* occur before the enqueue below.\n-                    // FIXME(#6842, #8130) This is usually only needed for the\n-                    // assertion in recv_ready, except in the case of select().\n-                    // This won't actually ever have cacheline contention, but\n-                    // maybe should be optimized out with a cfg(test) anyway?\n-                    (*self.packet()).state.store(STATE_ONE, Relaxed);\n-\n-                    rtdebug!(\"rendezvous recv\");\n-\n-                    // Channel is closed. Switch back and check the data.\n-                    // NB: We have to drop back into the scheduler event loop here\n-                    // instead of switching immediately back or we could end up\n-                    // triggering infinite recursion on the scheduler's stack.\n-                    let recvr = BlockedTask::cast_from_uint(task_as_state);\n-                    sched.enqueue_blocked_task(recvr);\n-                    true\n-                }\n-                _ => rtabort!(\"can't block_on; a task is already blocked\")\n-            }\n-        }\n-    }\n-\n-    // This is the only select trait function that's not also used in recv.\n-    fn unblock_from(&mut self) -> bool {\n-        let packet = self.packet();\n-        unsafe {\n-            // In case the data is available, the acquire barrier here matches\n-            // the release barrier the sender used to release the payload.\n-            match (*packet).state.load(Acquire) {\n-                // Impossible. We removed STATE_BOTH when blocking on it, and\n-                // no self-respecting sender would put it back.\n-                STATE_BOTH    => rtabort!(\"refcount already 2 in unblock_from\"),\n-                // Here, a sender already tried to wake us up. Perhaps they\n-                // even succeeded! Data is available.\n-                STATE_ONE     => true,\n-                // Still registered as blocked. Need to \"unblock\" the pointer.\n-                task_as_state => {\n-                    // In the window between the load and the CAS, a sender\n-                    // might take the pointer and set the refcount to ONE. If\n-                    // that happens, we shouldn't clobber that with BOTH!\n-                    // Acquire barrier again for the same reason as above.\n-                    match (*packet).state.compare_and_swap(task_as_state, STATE_BOTH,\n-                                                           Acquire) {\n-                        STATE_BOTH => rtabort!(\"refcount became 2 in unblock_from\"),\n-                        STATE_ONE  => true, // Lost the race. Data available.\n-                        same_ptr   => {\n-                            // We successfully unblocked our task pointer.\n-                            rtassert!(task_as_state == same_ptr);\n-                            let handle = BlockedTask::cast_from_uint(task_as_state);\n-                            // Because we are already awake, the handle we\n-                            // gave to this port shall already be empty.\n-                            handle.assert_already_awake();\n-                            false\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<T: Send> Select for PortOne<T> { }\n-\n-impl<T: Send> SelectPortInner<T> for PortOne<T> {\n-    fn recv_ready(mut self) -> Option<T> {\n-        let packet = self.packet();\n-\n-        // No further memory barrier is needed here to access the\n-        // payload. Some scenarios:\n-        //\n-        // 1) We encountered STATE_ONE above - the atomic_xchg was the acq barrier. We're fine.\n-        // 2) We encountered STATE_BOTH above and blocked. The sending task then ran us\n-        //    and ran on its thread. The sending task issued a read barrier when taking the\n-        //    pointer to the receiving task.\n-        // 3) We encountered STATE_BOTH above and blocked, but the receiving task (this task)\n-        //    is pinned to some other scheduler, so the sending task had to give us to\n-        //    a different scheduler for resuming. That send synchronized memory.\n-        unsafe {\n-            // See corresponding store() above in block_on for rationale.\n-            // FIXME(#8130) This can happen only in test builds.\n-            // This load is not required for correctness and may be compiled out.\n-            rtassert!((*packet).state.load(Relaxed) == STATE_ONE);\n-\n-            let payload = (*packet).payload.take();\n-\n-            // The sender has closed up shop. Drop the packet.\n-            let _packet: ~Packet<T> = cast::transmute(self.void_packet);\n-            // Suppress the synchronizing actions in the finalizer. We're done with the packet.\n-            self.suppress_finalize = true;\n-            return payload;\n-        }\n-    }\n-}\n-\n-impl<T: Send> SelectPort<T> for PortOne<T> { }\n-\n-impl<T: Send> Peekable<T> for PortOne<T> {\n-    fn peek(&self) -> bool {\n-        unsafe {\n-            let packet: *mut Packet<T> = self.packet();\n-            let oldstate = (*packet).state.load(SeqCst);\n-            match oldstate {\n-                STATE_BOTH => false,\n-                STATE_ONE => (*packet).payload.is_some(),\n-                _ => rtabort!(\"peeked on a blocked task\")\n-            }\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T: Send> Drop for ChanOne<T> {\n-    fn drop(&mut self) {\n-        if self.suppress_finalize { return }\n-\n-        unsafe {\n-            let oldstate = (*self.packet()).state.swap(STATE_ONE, SeqCst);\n-            match oldstate {\n-                STATE_BOTH => {\n-                    // Port still active. It will destroy the Packet.\n-                },\n-                STATE_ONE => {\n-                    let _packet: ~Packet<T> = cast::transmute(self.void_packet);\n-                },\n-                task_as_state => {\n-                    // The port is blocked waiting for a message we will never send. Wake it.\n-                    rtassert!((*self.packet()).payload.is_none());\n-                    let recvr = BlockedTask::cast_from_uint(task_as_state);\n-                    recvr.wake().map(|woken_task| {\n-                        Scheduler::run_task(woken_task);\n-                    });\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T: Send> Drop for PortOne<T> {\n-    fn drop(&mut self) {\n-        if self.suppress_finalize { return }\n-\n-        unsafe {\n-            let oldstate = (*self.packet()).state.swap(STATE_ONE, SeqCst);\n-            match oldstate {\n-                STATE_BOTH => {\n-                    // Chan still active. It will destroy the packet.\n-                },\n-                STATE_ONE => {\n-                    let _packet: ~Packet<T> = cast::transmute(self.void_packet);\n-                }\n-                task_as_state => {\n-                    // This case occurs during unwinding, when the blocked\n-                    // receiver was killed awake. The task can't still be\n-                    // blocked (we are it), but we need to free the handle.\n-                    let recvr = BlockedTask::cast_from_uint(task_as_state);\n-                    recvr.assert_already_awake();\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-struct StreamPayload<T> {\n-    val: T,\n-    next: PortOne<StreamPayload<T>>\n-}\n-\n-type StreamChanOne<T> = ChanOne<StreamPayload<T>>;\n-type StreamPortOne<T> = PortOne<StreamPayload<T>>;\n-\n-/// A channel with unbounded size.\n-pub struct Chan<T> {\n-    // FIXME #5372. Using RefCell because we don't take &mut self\n-    next: RefCell<StreamChanOne<T>>\n-}\n-\n-/// An port with unbounded size.\n-pub struct Port<T> {\n-    // FIXME #5372. Using RefCell because we don't take &mut self\n-    next: RefCell<Option<StreamPortOne<T>>>\n-}\n-\n-pub fn stream<T: Send>() -> (Port<T>, Chan<T>) {\n-    let (pone, cone) = oneshot();\n-    let port = Port { next: RefCell::new(Some(pone)) };\n-    let chan = Chan { next: RefCell::new(cone) };\n-    return (port, chan);\n-}\n-\n-impl<T: Send> Chan<T> {\n-    fn try_send_inner(&self, val: T, do_resched: bool) -> bool {\n-        let (next_pone, mut cone) = oneshot();\n-        let mut b = self.next.borrow_mut();\n-        util::swap(&mut cone, b.get());\n-        cone.try_send_inner(StreamPayload { val: val, next: next_pone }, do_resched)\n-    }\n-}\n-\n-impl<T: Send> GenericChan<T> for Chan<T> {\n-    fn send(&self, val: T) {\n-        self.try_send(val);\n-    }\n-}\n-\n-impl<T: Send> GenericSmartChan<T> for Chan<T> {\n-    fn try_send(&self, val: T) -> bool {\n-        self.try_send_inner(val, true)\n-    }\n-}\n-\n-impl<T: Send> SendDeferred<T> for Chan<T> {\n-    fn send_deferred(&self, val: T) {\n-        self.try_send_deferred(val);\n-    }\n-    fn try_send_deferred(&self, val: T) -> bool {\n-        self.try_send_inner(val, false)\n-    }\n-}\n-\n-impl<T: Send> GenericPort<T> for Port<T> {\n-    fn recv(&self) -> T {\n-        match self.try_recv() {\n-            Some(val) => val,\n-            None => {\n-                fail!(\"receiving on closed channel\");\n-            }\n-        }\n-    }\n-\n-    fn try_recv(&self) -> Option<T> {\n-        let mut b = self.next.borrow_mut();\n-        b.get().take().map_default(None, |pone| {\n-            match pone.try_recv() {\n-                Some(StreamPayload { val, next }) => {\n-                    *b.get() = Some(next);\n-                    Some(val)\n-                }\n-                None => None\n-            }\n-        })\n-    }\n-}\n-\n-impl<T: Send> Peekable<T> for Port<T> {\n-    fn peek(&self) -> bool {\n-        self.next.with_mut(|p| p.get_mut_ref().peek())\n-    }\n-}\n-\n-// XXX: Kind of gross. A Port<T> should be selectable so you can make an array\n-// of them, but a &Port<T> should also be selectable so you can select2 on it\n-// alongside a PortOne<U> without passing the port by value in recv_ready.\n-\n-impl<'a, T: Send> SelectInner for &'a Port<T> {\n-    #[inline]\n-    fn optimistic_check(&mut self) -> bool {\n-        self.next.with_mut(|pone| { pone.get_mut_ref().optimistic_check() })\n-    }\n-\n-    #[inline]\n-    fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n-        let mut b = self.next.borrow_mut();\n-        b.get().get_mut_ref().block_on(sched, task)\n-    }\n-\n-    #[inline]\n-    fn unblock_from(&mut self) -> bool {\n-        self.next.with_mut(|pone| { pone.get_mut_ref().unblock_from() })\n-    }\n-}\n-\n-impl<'a, T: Send> Select for &'a Port<T> { }\n-\n-impl<T: Send> SelectInner for Port<T> {\n-    #[inline]\n-    fn optimistic_check(&mut self) -> bool {\n-        (&*self).optimistic_check()\n-    }\n-\n-    #[inline]\n-    fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n-        (&*self).block_on(sched, task)\n-    }\n-\n-    #[inline]\n-    fn unblock_from(&mut self) -> bool {\n-        (&*self).unblock_from()\n-    }\n-}\n-\n-impl<T: Send> Select for Port<T> { }\n-\n-impl<'a, T: Send> SelectPortInner<T> for &'a Port<T> {\n-    fn recv_ready(self) -> Option<T> {\n-        let mut b = self.next.borrow_mut();\n-        match b.get().take_unwrap().recv_ready() {\n-            Some(StreamPayload { val, next }) => {\n-                *b.get() = Some(next);\n-                Some(val)\n-            }\n-            None => None\n-        }\n-    }\n-}\n-\n-impl<'a, T: Send> SelectPort<T> for &'a Port<T> { }\n-\n-pub struct SharedChan<T> {\n-    // Just like Chan, but a shared AtomicOption\n-    priv next: UnsafeArc<AtomicOption<StreamChanOne<T>>>\n-}\n-\n-impl<T: Send> SharedChan<T> {\n-    pub fn new(chan: Chan<T>) -> SharedChan<T> {\n-        let next = chan.next.unwrap();\n-        let next = AtomicOption::new(~next);\n-        SharedChan { next: UnsafeArc::new(next) }\n-    }\n-}\n-\n-impl<T: Send> SharedChan<T> {\n-    fn try_send_inner(&self, val: T, do_resched: bool) -> bool {\n-        unsafe {\n-            let (next_pone, next_cone) = oneshot();\n-            let cone = (*self.next.get()).swap(~next_cone, SeqCst);\n-            cone.unwrap().try_send_inner(StreamPayload { val: val, next: next_pone },\n-                                         do_resched)\n-        }\n-    }\n-}\n-\n-impl<T: Send> GenericChan<T> for SharedChan<T> {\n-    fn send(&self, val: T) {\n-        self.try_send(val);\n-    }\n-}\n-\n-impl<T: Send> GenericSmartChan<T> for SharedChan<T> {\n-    fn try_send(&self, val: T) -> bool {\n-        self.try_send_inner(val, true)\n-    }\n-}\n-\n-impl<T: Send> SendDeferred<T> for SharedChan<T> {\n-    fn send_deferred(&self, val: T) {\n-        self.try_send_deferred(val);\n-    }\n-    fn try_send_deferred(&self, val: T) -> bool {\n-        self.try_send_inner(val, false)\n-    }\n-}\n-\n-impl<T: Send> Clone for SharedChan<T> {\n-    fn clone(&self) -> SharedChan<T> {\n-        SharedChan {\n-            next: self.next.clone()\n-        }\n-    }\n-}\n-\n-pub struct SharedPort<T> {\n-    // The next port on which we will receive the next port on which we will receive T\n-    priv next_link: UnsafeArc<AtomicOption<PortOne<StreamPortOne<T>>>>\n-}\n-\n-impl<T: Send> SharedPort<T> {\n-    pub fn new(port: Port<T>) -> SharedPort<T> {\n-        // Put the data port into a new link pipe\n-        let next_data_port = port.next.unwrap().unwrap();\n-        let (next_link_port, next_link_chan) = oneshot();\n-        next_link_chan.send(next_data_port);\n-        let next_link = AtomicOption::new(~next_link_port);\n-        SharedPort { next_link: UnsafeArc::new(next_link) }\n-    }\n-}\n-\n-impl<T: Send> GenericPort<T> for SharedPort<T> {\n-    fn recv(&self) -> T {\n-        match self.try_recv() {\n-            Some(val) => val,\n-            None => {\n-                fail!(\"receiving on a closed channel\");\n-            }\n-        }\n-    }\n-\n-    fn try_recv(&self) -> Option<T> {\n-        unsafe {\n-            let (next_link_port, next_link_chan) = oneshot();\n-            let link_port = (*self.next_link.get()).swap(~next_link_port, SeqCst);\n-            let link_port = link_port.unwrap();\n-            let data_port = link_port.recv();\n-            let (next_data_port, res) = match data_port.try_recv() {\n-                Some(StreamPayload { val, next }) => {\n-                    (next, Some(val))\n-                }\n-                None => {\n-                    let (next_data_port, _) = oneshot();\n-                    (next_data_port, None)\n-                }\n-            };\n-            next_link_chan.send(next_data_port);\n-            return res;\n-        }\n-    }\n-}\n-\n-impl<T: Send> Clone for SharedPort<T> {\n-    fn clone(&self) -> SharedPort<T> {\n-        SharedPort {\n-            next_link: self.next_link.clone()\n-        }\n-    }\n-}\n-\n-// FIXME #7760: Need better name\n-type MegaPipe<T> = (SharedPort<T>, SharedChan<T>);\n-\n-pub fn megapipe<T: Send>() -> MegaPipe<T> {\n-    let (port, chan) = stream();\n-    (SharedPort::new(port), SharedChan::new(chan))\n-}\n-\n-impl<T: Send> GenericChan<T> for MegaPipe<T> {\n-    fn send(&self, val: T) {\n-        self.second_ref().send(val)\n-    }\n-}\n-\n-impl<T: Send> GenericSmartChan<T> for MegaPipe<T> {\n-    fn try_send(&self, val: T) -> bool {\n-        self.second_ref().try_send(val)\n-    }\n-}\n-\n-impl<T: Send> GenericPort<T> for MegaPipe<T> {\n-    fn recv(&self) -> T {\n-        self.first_ref().recv()\n-    }\n-\n-    fn try_recv(&self) -> Option<T> {\n-        self.first_ref().try_recv()\n-    }\n-}\n-\n-impl<T: Send> SendDeferred<T> for MegaPipe<T> {\n-    fn send_deferred(&self, val: T) {\n-        self.second_ref().send_deferred(val)\n-    }\n-    fn try_send_deferred(&self, val: T) -> bool {\n-        self.second_ref().try_send_deferred(val)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use option::*;\n-    use rt::test::*;\n-    use num::Times;\n-    use rt::util;\n-\n-    #[test]\n-    fn oneshot_single_thread_close_port_first() {\n-        // Simple test of closing without sending\n-        do run_in_newsched_task {\n-            let (port, _chan) = oneshot::<int>();\n-            { let _p = port; }\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_close_chan_first() {\n-        // Simple test of closing without sending\n-        do run_in_newsched_task {\n-            let (_port, chan) = oneshot::<int>();\n-            { let _c = chan; }\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_send_port_close() {\n-        // Testing that the sender cleans up the payload if receiver is closed\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<~int>();\n-            { let _p = port; }\n-            chan.send(~0);\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_recv_chan_close() {\n-        // Receiving on a closed chan will fail\n-        do run_in_newsched_task {\n-            let res = do spawntask_try {\n-                let (port, chan) = oneshot::<~int>();\n-                { let _c = chan; }\n-                port.recv();\n-            };\n-            // What is our res?\n-            rtdebug!(\"res is: {:?}\", res.is_err());\n-            assert!(res.is_err());\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_send_then_recv() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<~int>();\n-            chan.send(~10);\n-            assert!(port.recv() == ~10);\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_try_send_open() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<int>();\n-            assert!(chan.try_send(10));\n-            assert!(port.recv() == 10);\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_try_send_closed() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<int>();\n-            { let _p = port; }\n-            assert!(!chan.try_send(10));\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_try_recv_open() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<int>();\n-            chan.send(10);\n-            assert!(port.try_recv() == Some(10));\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_try_recv_closed() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<int>();\n-            { let _c = chan; }\n-            assert!(port.try_recv() == None);\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_peek_data() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<int>();\n-            assert!(!port.peek());\n-            chan.send(10);\n-            assert!(port.peek());\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_peek_close() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<int>();\n-            { let _c = chan; }\n-            assert!(!port.peek());\n-            assert!(!port.peek());\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_peek_open() {\n-        do run_in_newsched_task {\n-            let (port, _) = oneshot::<int>();\n-            assert!(!port.peek());\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_multi_task_recv_then_send() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<~int>();\n-            do spawntask {\n-                assert!(port.recv() == ~10);\n-            }\n-\n-            chan.send(~10);\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_multi_task_recv_then_close() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<~int>();\n-            do spawntask_later {\n-                let _ = chan;\n-            }\n-            let res = do spawntask_try {\n-                assert!(port.recv() == ~10);\n-            };\n-            assert!(res.is_err());\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_multi_thread_close_stress() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        stress_factor().times(|| {\n-            do run_in_newsched_task {\n-                let (port, chan) = oneshot::<int>();\n-                let thread = do spawntask_thread {\n-                    let _ = port;\n-                };\n-                let _chan = chan;\n-                thread.join();\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn oneshot_multi_thread_send_close_stress() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        stress_factor().times(|| {\n-            do run_in_newsched_task {\n-                let (port, chan) = oneshot::<int>();\n-                let thread1 = do spawntask_thread {\n-                    let _ = port;\n-                };\n-                let thread2 = do spawntask_thread {\n-                    chan.send(1);\n-                };\n-                thread1.join();\n-                thread2.join();\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn oneshot_multi_thread_recv_close_stress() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        stress_factor().times(|| {\n-            do run_in_newsched_task {\n-                let (port, chan) = oneshot::<int>();\n-                let thread1 = do spawntask_thread {\n-                    let port = port;\n-                    let res = do spawntask_try {\n-                        port.recv();\n-                    };\n-                    assert!(res.is_err());\n-                };\n-                let thread2 = do spawntask_thread {\n-                    let chan = chan;\n-                    do spawntask {\n-                        let _ = chan;\n-                    }\n-                };\n-                thread1.join();\n-                thread2.join();\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn oneshot_multi_thread_send_recv_stress() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        stress_factor().times(|| {\n-            do run_in_newsched_task {\n-                let (port, chan) = oneshot::<~int>();\n-                let thread1 = do spawntask_thread {\n-                    chan.send(~10);\n-                };\n-                let thread2 = do spawntask_thread {\n-                    assert!(port.recv() == ~10);\n-                };\n-                thread1.join();\n-                thread2.join();\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn stream_send_recv_stress() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        stress_factor().times(|| {\n-            do run_in_mt_newsched_task {\n-                let (port, chan) = stream::<~int>();\n-\n-                send(chan, 0);\n-                recv(port, 0);\n-\n-                fn send(chan: Chan<~int>, i: int) {\n-                    if i == 10 { return }\n-\n-                    do spawntask_random {\n-                        chan.send(~i);\n-                        send(chan, i + 1);\n-                    }\n-                }\n-\n-                fn recv(port: Port<~int>, i: int) {\n-                    if i == 10 { return }\n-\n-                    do spawntask_random {\n-                        assert!(port.recv() == ~i);\n-                        recv(port, i + 1);\n-                    };\n-                }\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn recv_a_lot() {\n-        // Regression test that we don't run out of stack in scheduler context\n-        do run_in_newsched_task {\n-            let (port, chan) = stream();\n-            10000.times(|| { chan.send(()) });\n-            10000.times(|| { port.recv() });\n-        }\n-    }\n-\n-    #[test]\n-    fn shared_chan_stress() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        do run_in_mt_newsched_task {\n-            let (port, chan) = stream();\n-            let chan = SharedChan::new(chan);\n-            let total = stress_factor() + 100;\n-            total.times(|| {\n-                let chan_clone = chan.clone();\n-                do spawntask_random {\n-                    chan_clone.send(());\n-                }\n-            });\n-\n-            total.times(|| {\n-                port.recv();\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    fn shared_port_stress() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        do run_in_mt_newsched_task {\n-            let (end_port, end_chan) = stream();\n-            let (port, chan) = stream();\n-            let end_chan = SharedChan::new(end_chan);\n-            let port = SharedPort::new(port);\n-            let total = stress_factor() + 100;\n-            total.times(|| {\n-                let end_chan_clone = end_chan.clone();\n-                let port_clone = port.clone();\n-                do spawntask_random {\n-                    port_clone.recv();\n-                    end_chan_clone.send(());\n-                }\n-            });\n-\n-            total.times(|| {\n-                chan.send(());\n-            });\n-\n-            total.times(|| {\n-                end_port.recv();\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    fn shared_port_close_simple() {\n-        do run_in_mt_newsched_task {\n-            let (port, chan) = stream::<()>();\n-            let port = SharedPort::new(port);\n-            { let _chan = chan; }\n-            assert!(port.try_recv().is_none());\n-        }\n-    }\n-\n-    #[test]\n-    fn shared_port_close() {\n-        do run_in_mt_newsched_task {\n-            let (end_port, end_chan) = stream::<bool>();\n-            let (port, chan) = stream::<()>();\n-            let end_chan = SharedChan::new(end_chan);\n-            let port = SharedPort::new(port);\n-            let chan = SharedChan::new(chan);\n-            let send_total = 10;\n-            let recv_total = 20;\n-            do spawntask_random {\n-                send_total.times(|| {\n-                    let chan_clone = chan.clone();\n-                    do spawntask_random {\n-                        chan_clone.send(());\n-                    }\n-                });\n-            }\n-            let end_chan_clone = end_chan.clone();\n-            do spawntask_random {\n-                recv_total.times(|| {\n-                    let port_clone = port.clone();\n-                    let end_chan_clone = end_chan_clone.clone();\n-                    do spawntask_random {\n-                        let recvd = port_clone.try_recv().is_some();\n-                        end_chan_clone.send(recvd);\n-                    }\n-                });\n-            }\n-\n-            let mut recvd = 0;\n-            recv_total.times(|| {\n-                recvd += if end_port.recv() { 1 } else { 0 };\n-            });\n-\n-            assert!(recvd == send_total);\n-        }\n-    }\n-\n-    #[test]\n-    fn megapipe_stress() {\n-        use rand;\n-        use rand::Rng;\n-\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-\n-        do run_in_mt_newsched_task {\n-            let (end_port, end_chan) = stream::<()>();\n-            let end_chan = SharedChan::new(end_chan);\n-            let pipe = megapipe();\n-            let total = stress_factor() + 10;\n-            let mut rng = rand::rng();\n-            total.times(|| {\n-                let msgs = rng.gen_range(0u, 10);\n-                let pipe_clone = pipe.clone();\n-                let end_chan_clone = end_chan.clone();\n-                do spawntask_random {\n-                    msgs.times(|| {\n-                        pipe_clone.send(());\n-                    });\n-                    msgs.times(|| {\n-                        pipe_clone.recv();\n-                    });\n-                }\n-\n-                end_chan_clone.send(());\n-            });\n-\n-            total.times(|| {\n-                end_port.recv();\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    fn send_deferred() {\n-        use unstable::sync::atomic;\n-\n-        // Tests no-rescheduling of send_deferred on all types of channels.\n-        do run_in_newsched_task {\n-            let (pone, cone) = oneshot();\n-            let (pstream, cstream) = stream();\n-            let (pshared, cshared) = stream();\n-            let cshared = SharedChan::new(cshared);\n-            let mp = megapipe();\n-\n-            do spawntask { pone.recv(); }\n-            do spawntask { pstream.recv(); }\n-            do spawntask { pshared.recv(); }\n-            let p_mp = mp.clone();\n-            do spawntask { p_mp.recv(); }\n-\n-            unsafe {\n-                let _guard = atomic();\n-                cone.send_deferred(());\n-                cstream.send_deferred(());\n-                cshared.send_deferred(());\n-                mp.send_deferred(());\n-            }\n-        }\n-    }\n-\n-}"}, {"sha": "f4f128cf5aac1053852c2475d59fa99f229d920d", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -153,8 +153,9 @@ There are two known issues with the current scheme for exit code propagation.\n use cast;\n use option::{Option, Some, None};\n use prelude::*;\n+use iter;\n+use task::TaskResult;\n use rt::task::Task;\n-use rt::task::UnwindResult;\n use unstable::atomics::{AtomicUint, SeqCst};\n use unstable::sync::UnsafeArc;\n \n@@ -169,11 +170,21 @@ pub enum BlockedTask {\n pub struct Death {\n     // Action to be done with the exit code. If set, also makes the task wait\n     // until all its watched children exit before collecting the status.\n-    on_exit:         Option<proc(UnwindResult)>,\n+    on_exit:         Option<proc(TaskResult)>,\n     // nesting level counter for unstable::atomically calls (0 == can deschedule).\n     priv wont_sleep:      int,\n }\n \n+pub struct BlockedTaskIterator {\n+    priv inner: UnsafeArc<AtomicUint>,\n+}\n+\n+impl Iterator<BlockedTask> for BlockedTaskIterator {\n+    fn next(&mut self) -> Option<BlockedTask> {\n+        Some(Shared(self.inner.clone()))\n+    }\n+}\n+\n impl BlockedTask {\n     /// Returns Some if the task was successfully woken; None if already killed.\n     pub fn wake(self) -> Option<~Task> {\n@@ -194,19 +205,17 @@ impl BlockedTask {\n     }\n \n     /// Converts one blocked task handle to a list of many handles to the same.\n-    pub fn make_selectable(self, num_handles: uint) -> ~[BlockedTask] {\n-        let handles = match self {\n+    pub fn make_selectable(self, num_handles: uint)\n+        -> iter::Take<BlockedTaskIterator>\n+    {\n+        let arc = match self {\n             Owned(task) => {\n-                let flag = unsafe {\n-                    AtomicUint::new(cast::transmute(task))\n-                };\n-                UnsafeArc::newN(flag, num_handles)\n+                let flag = unsafe { AtomicUint::new(cast::transmute(task)) };\n+                UnsafeArc::new(flag)\n             }\n-            Shared(arc) => arc.cloneN(num_handles),\n+            Shared(arc) => arc.clone(),\n         };\n-        // Even if the task was unkillable before, we use 'Killable' because\n-        // multiple pipes will have handles. It does not really mean killable.\n-        handles.move_iter().map(|x| Shared(x)).collect()\n+        BlockedTaskIterator{ inner: arc }.take(num_handles)\n     }\n \n     // This assertion has two flavours because the wake involves an atomic op.\n@@ -254,10 +263,10 @@ impl Death {\n     }\n \n     /// Collect failure exit codes from children and propagate them to a parent.\n-    pub fn collect_failure(&mut self, result: UnwindResult) {\n+    pub fn collect_failure(&mut self, result: TaskResult) {\n         match self.on_exit.take() {\n+            Some(f) => f(result),\n             None => {}\n-            Some(on_exit) => on_exit(result),\n         }\n     }\n "}, {"sha": "925aa802ad5c299626bb616a16e1644f8b0f3590", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -77,10 +77,9 @@ pub unsafe fn borrow<T>() -> Borrowed<T> {\n /// it wherever possible.\n #[cfg(not(windows), not(target_os = \"android\"))]\n pub mod compiled {\n-    #[cfg(not(test))]\n-    use libc::c_void;\n     use cast;\n     use option::{Option, Some, None};\n+    #[cfg(not(test))] use libc::c_void;\n \n     #[cfg(test)]\n     pub use realstd::rt::shouldnt_be_public::RT_TLS_PTR;"}, {"sha": "10e457368f007e3e36ccdb8f2e33a2fd7105b192", "filename": "src/libstd/rt/message_queue.rs", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bfa9064ba2687eb1d95708f72f41ddd9729a6ba1/src%2Flibstd%2Frt%2Fmessage_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa9064ba2687eb1d95708f72f41ddd9729a6ba1/src%2Flibstd%2Frt%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmessage_queue.rs?ref=bfa9064ba2687eb1d95708f72f41ddd9729a6ba1", "patch": "@@ -1,55 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A concurrent queue that supports multiple producers and a\n-//! single consumer.\n-\n-use kinds::Send;\n-use vec::OwnedVector;\n-use option::Option;\n-use clone::Clone;\n-use rt::mpsc_queue::Queue;\n-\n-pub struct MessageQueue<T> {\n-    priv queue: Queue<T>\n-}\n-\n-impl<T: Send> MessageQueue<T> {\n-    pub fn new() -> MessageQueue<T> {\n-        MessageQueue {\n-            queue: Queue::new()\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn push(&mut self, value: T) {\n-        self.queue.push(value)\n-    }\n-\n-    #[inline]\n-    pub fn pop(&mut self) -> Option<T> {\n-        self.queue.pop()\n-    }\n-\n-    /// A pop that may sometimes miss enqueued elements, but is much faster\n-    /// to give up without doing any synchronization\n-    #[inline]\n-    pub fn casual_pop(&mut self) -> Option<T> {\n-        self.queue.pop()\n-    }\n-}\n-\n-impl<T: Send> Clone for MessageQueue<T> {\n-    fn clone(&self) -> MessageQueue<T> {\n-        MessageQueue {\n-            queue: self.queue.clone()\n-        }\n-    }\n-}"}, {"sha": "5d2179e8b9693ba0c6159e92483fa1de4b8109e8", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -65,7 +65,7 @@ use ptr::RawPtr;\n use rt::local::Local;\n use rt::sched::{Scheduler, Shutdown};\n use rt::sleeper_list::SleeperList;\n-use rt::task::UnwindResult;\n+use task::TaskResult;\n use rt::task::{Task, SchedTask, GreenTask, Sched};\n use send_str::SendStrStatic;\n use unstable::atomics::{AtomicInt, AtomicBool, SeqCst};\n@@ -91,8 +91,6 @@ pub use self::kill::BlockedTask;\n // XXX: these probably shouldn't be public...\n #[doc(hidden)]\n pub mod shouldnt_be_public {\n-    pub use super::select::SelectInner;\n-    pub use super::select::{SelectInner, SelectPortInner};\n     pub use super::local_ptr::native::maybe_tls_key;\n     #[cfg(not(windows), not(target_os = \"android\"))]\n     pub use super::local_ptr::compiled::RT_TLS_PTR;\n@@ -123,11 +121,11 @@ pub mod rtio;\n /// or task-local storage.\n pub mod local;\n \n-/// A parallel queue.\n-pub mod message_queue;\n-\n /// A mostly lock-free multi-producer, single consumer queue.\n-mod mpsc_queue;\n+pub mod mpsc_queue;\n+\n+/// A lock-free single-producer, single consumer queue.\n+pub mod spsc_queue;\n \n /// A lock-free multi-producer, multi-consumer bounded queue.\n mod mpmc_bounded_queue;\n@@ -169,11 +167,6 @@ pub mod rc;\n /// scheduler and task context\n pub mod tube;\n \n-/// Simple reimplementation of std::comm\n-pub mod comm;\n-\n-mod select;\n-\n /// The runtime needs to be able to put a pointer into thread-local storage.\n mod local_ptr;\n \n@@ -349,7 +342,7 @@ fn run_(main: proc(), use_main_sched: bool) -> int {\n     // When the main task exits, after all the tasks in the main\n     // task tree, shut down the schedulers and set the exit code.\n     let handles = handles;\n-    let on_exit: proc(UnwindResult) = proc(exit_success) {\n+    let on_exit: proc(TaskResult) = proc(exit_success) {\n         unsafe {\n             assert!(!(*exited_already.get()).swap(true, SeqCst),\n                     \"the runtime already exited\");\n@@ -361,7 +354,7 @@ fn run_(main: proc(), use_main_sched: bool) -> int {\n         }\n \n         unsafe {\n-            let exit_code = if exit_success.is_success() {\n+            let exit_code = if exit_success.is_ok() {\n                 use rt::util;\n \n                 // If we're exiting successfully, then return the global"}, {"sha": "b54231421e3969be21f725ab179998cc9b2a41e3", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -10,7 +10,7 @@\n \n use c_str::CString;\n use cast;\n-use comm::{SharedChan, PortOne, Port};\n+use comm::{SharedChan, Port};\n use libc::c_int;\n use libc;\n use ops::Drop;\n@@ -222,7 +222,7 @@ pub trait RtioUdpSocket : RtioSocket {\n \n pub trait RtioTimer {\n     fn sleep(&mut self, msecs: u64);\n-    fn oneshot(&mut self, msecs: u64) -> PortOne<()>;\n+    fn oneshot(&mut self, msecs: u64) -> Port<()>;\n     fn period(&mut self, msecs: u64) -> Port<()>;\n }\n "}, {"sha": "ac3aeb5a4bb3d8a0d804d7799fd3ab1737f19ce3", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 57, "deletions": 48, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -17,7 +17,6 @@ use super::stack::{StackPool};\n use super::rtio::EventLoop;\n use super::context::Context;\n use super::task::{Task, AnySched, Sched};\n-use super::message_queue::MessageQueue;\n use rt::kill::BlockedTask;\n use rt::deque;\n use rt::local_ptr;\n@@ -29,6 +28,7 @@ use iter::range;\n use unstable::mutex::Mutex;\n use vec::{OwnedVector};\n \n+use mpsc = super::mpsc_queue;\n \n /// A scheduler is responsible for coordinating the execution of Tasks\n /// on a single thread. The scheduler runs inside a slightly modified\n@@ -47,7 +47,9 @@ pub struct Scheduler {\n     /// The queue of incoming messages from other schedulers.\n     /// These are enqueued by SchedHandles after which a remote callback\n     /// is triggered to handle the message.\n-    message_queue: MessageQueue<SchedMessage>,\n+    message_queue: mpsc::Consumer<SchedMessage, ()>,\n+    /// Producer used to clone sched handles from\n+    message_producer: mpsc::Producer<SchedMessage, ()>,\n     /// A shared list of sleeping schedulers. We'll use this to wake\n     /// up schedulers when pushing work onto the work queue.\n     sleeper_list: SleeperList,\n@@ -104,7 +106,7 @@ enum EffortLevel {\n     GiveItYourBest\n }\n \n-static MAX_YIELD_CHECKS: uint = 200;\n+static MAX_YIELD_CHECKS: uint = 20000;\n \n fn reset_yield_check(rng: &mut XorShiftRng) -> uint {\n     let r: uint = Rand::rand(rng);\n@@ -135,9 +137,11 @@ impl Scheduler {\n                        friend: Option<SchedHandle>)\n         -> Scheduler {\n \n+        let (consumer, producer) = mpsc::queue(());\n         let mut sched = Scheduler {\n             sleeper_list: sleeper_list,\n-            message_queue: MessageQueue::new(),\n+            message_queue: consumer,\n+            message_producer: producer,\n             sleepy: false,\n             no_sleep: false,\n             event_loop: event_loop,\n@@ -218,7 +222,7 @@ impl Scheduler {\n \n         // Should not have any messages\n         let message = stask.sched.get_mut_ref().message_queue.pop();\n-        rtassert!(message.is_none());\n+        rtassert!(match message { mpsc::Empty => true, _ => false });\n \n         stask.destroyed = true;\n     }\n@@ -315,10 +319,27 @@ impl Scheduler {\n     fn interpret_message_queue(mut ~self, effort: EffortLevel) -> Option<~Scheduler> {\n \n         let msg = if effort == DontTryTooHard {\n-            // Do a cheap check that may miss messages\n             self.message_queue.casual_pop()\n         } else {\n-            self.message_queue.pop()\n+            // When popping our message queue, we could see an \"inconsistent\"\n+            // state which means that we *should* be able to pop data, but we\n+            // are unable to at this time. Our options are:\n+            //\n+            //  1. Spin waiting for data\n+            //  2. Ignore this and pretend we didn't find a message\n+            //\n+            // If we choose route 1, then if the pusher in question is currently\n+            // pre-empted, we're going to take up our entire time slice just\n+            // spinning on this queue. If we choose route 2, then the pusher in\n+            // question is still guaranteed to make a send() on its async\n+            // handle, so we will guaranteed wake up and see its message at some\n+            // point.\n+            //\n+            // I have chosen to take route #2.\n+            match self.message_queue.pop() {\n+                mpsc::Data(t) => Some(t),\n+                mpsc::Empty | mpsc::Inconsistent => None\n+            }\n         };\n \n         match msg {\n@@ -793,7 +814,7 @@ impl Scheduler {\n \n         return SchedHandle {\n             remote: remote,\n-            queue: self.message_queue.clone(),\n+            queue: self.message_producer.clone(),\n             sched_id: self.sched_id()\n         };\n     }\n@@ -813,7 +834,7 @@ pub enum SchedMessage {\n \n pub struct SchedHandle {\n     priv remote: ~RemoteCallback,\n-    priv queue: MessageQueue<SchedMessage>,\n+    priv queue: mpsc::Producer<SchedMessage, ()>,\n     sched_id: uint\n }\n \n@@ -915,17 +936,17 @@ fn new_sched_rng() -> XorShiftRng {\n #[cfg(test)]\n mod test {\n     use prelude::*;\n-    use rt::test::*;\n-    use unstable::run_in_bare_thread;\n+\n     use borrow::to_uint;\n-    use rt::sched::{Scheduler};\n     use rt::deque::BufferPool;\n-    use rt::thread::Thread;\n-    use rt::task::{Task, Sched};\n     use rt::basic;\n+    use rt::sched::{Scheduler};\n+    use rt::task::{Task, Sched};\n+    use rt::test::*;\n+    use rt::thread::Thread;\n     use rt::util;\n-    use option::{Some};\n-    use rt::task::UnwindResult;\n+    use task::TaskResult;\n+    use unstable::run_in_bare_thread;\n \n     #[test]\n     fn trivial_run_in_newsched_task_test() {\n@@ -1010,8 +1031,8 @@ mod test {\n                 assert!(Task::on_appropriate_sched());\n             };\n \n-            let on_exit: proc(UnwindResult) = proc(exit_status) {\n-                rtassert!(exit_status.is_success())\n+            let on_exit: proc(TaskResult) = proc(exit_status) {\n+                rtassert!(exit_status.is_ok())\n             };\n             task.death.on_exit = Some(on_exit);\n \n@@ -1027,7 +1048,6 @@ mod test {\n         use rt::sleeper_list::SleeperList;\n         use rt::sched::Shutdown;\n         use borrow;\n-        use rt::comm::*;\n \n         do run_in_bare_thread {\n \n@@ -1089,7 +1109,7 @@ mod test {\n             rtdebug!(\"task4 id: **{}**\", borrow::to_uint(task4));\n \n             // Signal from the special task that we are done.\n-            let (port, chan) = oneshot::<()>();\n+            let (port, chan) = Chan::<()>::new();\n \n             let normal_task = ~do Task::new_root(&mut normal_sched.stack_pool, None) {\n                 rtdebug!(\"*about to submit task2*\");\n@@ -1160,10 +1180,8 @@ mod test {\n \n     #[test]\n     fn handle() {\n-        use rt::comm::*;\n-\n         do run_in_bare_thread {\n-            let (port, chan) = oneshot::<()>();\n+            let (port, chan) = Chan::new();\n \n             let thread_one = do Thread::start {\n                 let chan = chan;\n@@ -1230,15 +1248,14 @@ mod test {\n \n     #[test]\n     fn multithreading() {\n-        use rt::comm::*;\n         use num::Times;\n         use vec::OwnedVector;\n         use container::Container;\n \n         do run_in_mt_newsched_task {\n             let mut ports = ~[];\n             10.times(|| {\n-                let (port, chan) = oneshot();\n+                let (port, chan) = Chan::new();\n                 do spawntask_later {\n                     chan.send(());\n                 }\n@@ -1253,21 +1270,17 @@ mod test {\n \n      #[test]\n     fn thread_ring() {\n-        use rt::comm::*;\n-        use comm::{GenericPort, GenericChan};\n-\n         do run_in_mt_newsched_task {\n-            let (end_port, end_chan) = oneshot();\n+            let (end_port, end_chan) = Chan::new();\n \n             let n_tasks = 10;\n             let token = 2000;\n \n-            let (p, ch1) = stream();\n-            let mut p = p;\n+            let (mut p, ch1) = Chan::new();\n             ch1.send((token, end_chan));\n             let mut i = 2;\n             while i <= n_tasks {\n-                let (next_p, ch) = stream();\n+                let (next_p, ch) = Chan::new();\n                 let imm_i = i;\n                 let imm_p = p;\n                 do spawntask_random {\n@@ -1276,23 +1289,23 @@ mod test {\n                 p = next_p;\n                 i += 1;\n             }\n-            let imm_p = p;\n-            let imm_ch = ch1;\n+            let p = p;\n             do spawntask_random {\n-                roundtrip(1, n_tasks, &imm_p, &imm_ch);\n+                roundtrip(1, n_tasks, &p, &ch1);\n             }\n \n             end_port.recv();\n         }\n \n         fn roundtrip(id: int, n_tasks: int,\n-                     p: &Port<(int, ChanOne<()>)>, ch: &Chan<(int, ChanOne<()>)>) {\n+                     p: &Port<(int, Chan<()>)>,\n+                     ch: &Chan<(int, Chan<()>)>) {\n             while (true) {\n                 match p.recv() {\n                     (1, end_chan) => {\n-                                debug!(\"{}\\n\", id);\n-                                end_chan.send(());\n-                                return;\n+                        debug!(\"{}\\n\", id);\n+                        end_chan.send(());\n+                        return;\n                     }\n                     (token, end_chan) => {\n                         debug!(\"thread: {}   got token: {}\", id, token);\n@@ -1331,16 +1344,14 @@ mod test {\n \n     // FIXME: #9407: xfail-test\n     fn dont_starve_1() {\n-        use rt::comm::oneshot;\n-\n         stress_factor().times(|| {\n             do run_in_mt_newsched_task {\n-                let (port, chan) = oneshot();\n+                let (port, chan) = Chan::new();\n \n                 // This task should not be able to starve the sender;\n                 // The sender should get stolen to another thread.\n                 do spawntask {\n-                    while !port.peek() { }\n+                    while port.try_recv().is_none() { }\n                 }\n \n                 chan.send(());\n@@ -1350,17 +1361,15 @@ mod test {\n \n     #[test]\n     fn dont_starve_2() {\n-        use rt::comm::oneshot;\n-\n         stress_factor().times(|| {\n             do run_in_newsched_task {\n-                let (port, chan) = oneshot();\n-                let (_port2, chan2) = stream();\n+                let (port, chan) = Chan::new();\n+                let (_port2, chan2) = Chan::new();\n \n                 // This task should not be able to starve the other task.\n                 // The sends should eventually yield.\n                 do spawntask {\n-                    while !port.peek() {\n+                    while port.try_recv().is_none() {\n                         chan2.send(());\n                     }\n                 }"}, {"sha": "6cde0a1f2169f5f6f47c38040d1dc15570e5f7f4", "filename": "src/libstd/rt/select.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bfa9064ba2687eb1d95708f72f41ddd9729a6ba1/src%2Flibstd%2Frt%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa9064ba2687eb1d95708f72f41ddd9729a6ba1/src%2Flibstd%2Frt%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fselect.rs?ref=bfa9064ba2687eb1d95708f72f41ddd9729a6ba1", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Module for private, abstraction-leaking select traits. Wrapped in std::select.\n-\n-use rt::kill::BlockedTask;\n-use rt::sched::Scheduler;\n-use option::Option;\n-\n-pub trait SelectInner {\n-    // Returns true if data was available.\n-    fn optimistic_check(&mut self) -> bool;\n-    // Returns true if data was available. If so, shall also wake() the task.\n-    fn block_on(&mut self, &mut Scheduler, BlockedTask) -> bool;\n-    // Returns true if data was available.\n-    fn unblock_from(&mut self) -> bool;\n-}\n-\n-pub trait SelectPortInner<T> {\n-    fn recv_ready(self) -> Option<T>;\n-}\n-"}, {"sha": "62e012f9f41204ffe402dd086ce28cd2c99708c5", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 10, "deletions": 52, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -20,20 +20,22 @@ use prelude::*;\n use borrow;\n use cast::transmute;\n use cleanup;\n+use io::Writer;\n use libc::{c_void, uintptr_t, c_char, size_t};\n use local_data;\n use option::{Option, Some, None};\n use rt::borrowck::BorrowRecord;\n use rt::borrowck;\n+use rt::context;\n use rt::context::Context;\n use rt::env;\n-use io::Writer;\n use rt::kill::Death;\n use rt::local::Local;\n use rt::logging::StdErrLogger;\n use rt::sched::{Scheduler, SchedHandle};\n use rt::stack::{StackSegment, StackPool};\n use send_str::SendStr;\n+use task::TaskResult;\n use unstable::finally::Finally;\n use unstable::mutex::Mutex;\n \n@@ -90,46 +92,17 @@ pub enum SchedHome {\n pub struct GarbageCollector;\n pub struct LocalStorage(Option<local_data::Map>);\n \n-/// Represents the reason for the current unwinding process\n-pub enum UnwindResult {\n-    /// The task is ending successfully\n-    Success,\n-\n-    /// The Task is failing with reason `~Any`\n-    Failure(~Any),\n-}\n-\n-impl UnwindResult {\n-    /// Returns `true` if this `UnwindResult` is a failure\n-    #[inline]\n-    pub fn is_failure(&self) -> bool {\n-        match *self {\n-            Success => false,\n-            Failure(_) => true\n-        }\n-    }\n-\n-    /// Returns `true` if this `UnwindResult` is a success\n-    #[inline]\n-    pub fn is_success(&self) -> bool {\n-        match *self {\n-            Success => true,\n-            Failure(_) => false\n-        }\n-    }\n-}\n-\n pub struct Unwinder {\n     unwinding: bool,\n     cause: Option<~Any>\n }\n \n impl Unwinder {\n-    fn to_unwind_result(&mut self) -> UnwindResult {\n+    fn result(&mut self) -> TaskResult {\n         if self.unwinding {\n-            Failure(self.cause.take().unwrap())\n+            Err(self.cause.take().unwrap())\n         } else {\n-            Success\n+            Ok(())\n         }\n     }\n }\n@@ -326,7 +299,7 @@ impl Task {\n         // Cleanup the dynamic borrowck debugging info\n         borrowck::clear_task_borrow_list();\n \n-        self.death.collect_failure(self.unwinder.to_unwind_result());\n+        self.death.collect_failure(self.unwinder.result());\n         self.destroyed = true;\n     }\n \n@@ -691,6 +664,7 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> !\n mod test {\n     use super::*;\n     use rt::test::*;\n+    use prelude::*;\n \n     #[test]\n     fn local_heap() {\n@@ -743,35 +717,19 @@ mod test {\n         }\n     }\n \n-    #[test]\n-    fn comm_oneshot() {\n-        use comm::*;\n-\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot();\n-            chan.send(10);\n-            assert!(port.recv() == 10);\n-        }\n-    }\n-\n     #[test]\n     fn comm_stream() {\n-        use comm::*;\n-\n         do run_in_newsched_task() {\n-            let (port, chan) = stream();\n+            let (port, chan) = Chan::new();\n             chan.send(10);\n             assert!(port.recv() == 10);\n         }\n     }\n \n     #[test]\n     fn comm_shared_chan() {\n-        use comm::*;\n-\n         do run_in_newsched_task() {\n-            let (port, chan) = stream();\n-            let chan = SharedChan::new(chan);\n+            let (port, chan) = SharedChan::new();\n             chan.send(10);\n             assert!(port.recv() == 10);\n         }"}, {"sha": "2b48b396c99e9fe5439bc1169b27e0db1b6c10be", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -21,14 +21,14 @@ use rand::Rng;\n use rand;\n use result::{Result, Ok, Err};\n use rt::basic;\n-use rt::comm::oneshot;\n use rt::deque::BufferPool;\n+use comm::Chan;\n use rt::new_event_loop;\n use rt::sched::Scheduler;\n use rt::sleeper_list::SleeperList;\n use rt::task::Task;\n-use rt::task::UnwindResult;\n use rt::thread::Thread;\n+use task::TaskResult;\n use unstable::{run_in_bare_thread};\n use vec;\n use vec::{OwnedVector, MutableVector, ImmutableVector};\n@@ -82,10 +82,10 @@ pub fn run_in_uv_task_core(f: proc()) {\n     let mut sched = ~new_test_uv_sched();\n     let exit_handle = sched.make_handle();\n \n-    let on_exit: proc(UnwindResult) = proc(exit_status: UnwindResult) {\n+    let on_exit: proc(TaskResult) = proc(exit_status: TaskResult) {\n         let mut exit_handle = exit_handle;\n         exit_handle.send(Shutdown);\n-        rtassert!(exit_status.is_success());\n+        rtassert!(exit_status.is_ok());\n     };\n     let mut task = ~Task::new_root(&mut sched.stack_pool, None, f);\n     task.death.on_exit = Some(on_exit);\n@@ -99,10 +99,10 @@ pub fn run_in_newsched_task_core(f: proc()) {\n     let mut sched = ~new_test_sched();\n     let exit_handle = sched.make_handle();\n \n-    let on_exit: proc(UnwindResult) = proc(exit_status: UnwindResult) {\n+    let on_exit: proc(TaskResult) = proc(exit_status: TaskResult) {\n         let mut exit_handle = exit_handle;\n         exit_handle.send(Shutdown);\n-        rtassert!(exit_status.is_success());\n+        rtassert!(exit_status.is_ok());\n     };\n     let mut task = ~Task::new_root(&mut sched.stack_pool, None, f);\n     task.death.on_exit = Some(on_exit);\n@@ -240,14 +240,14 @@ pub fn run_in_mt_newsched_task(f: proc()) {\n         }\n \n         let handles = handles;  // Work around not being able to capture mut\n-        let on_exit: proc(UnwindResult) = proc(exit_status: UnwindResult) {\n+        let on_exit: proc(TaskResult) = proc(exit_status: TaskResult) {\n             // Tell schedulers to exit\n             let mut handles = handles;\n             for handle in handles.mut_iter() {\n                 handle.send(Shutdown);\n             }\n \n-            rtassert!(exit_status.is_success());\n+            rtassert!(exit_status.is_ok());\n         };\n         let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n                                             None,\n@@ -311,8 +311,8 @@ pub fn spawntask_random(f: proc()) {\n \n pub fn spawntask_try(f: proc()) -> Result<(),()> {\n \n-    let (port, chan) = oneshot();\n-    let on_exit: proc(UnwindResult) = proc(exit_status) {\n+    let (port, chan) = Chan::new();\n+    let on_exit: proc(TaskResult) = proc(exit_status) {\n         chan.send(exit_status)\n     };\n \n@@ -322,7 +322,7 @@ pub fn spawntask_try(f: proc()) -> Result<(),()> {\n     Scheduler::run_task(new_task);\n \n     let exit_status = port.recv();\n-    if exit_status.is_success() { Ok(()) } else { Err(()) }\n+    if exit_status.is_ok() { Ok(()) } else { Err(()) }\n \n }\n "}, {"sha": "da02988c75c94072e9ec012cce0b758f43f7f92f", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 109, "deletions": 78, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -21,42 +21,32 @@ use kinds::Send;\n use libc;\n use ops::Drop;\n use option::{Option, Some, None};\n-use ptr;\n use uint;\n \n-#[cfg(windows)]\n-use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T,\n-                                   LPVOID, DWORD, LPDWORD, HANDLE};\n-\n-#[cfg(windows)] type rust_thread = HANDLE;\n-#[cfg(unix)] type rust_thread = libc::pthread_t;\n-#[cfg(windows)] type rust_thread_return = DWORD;\n-#[cfg(unix)] type rust_thread_return = *libc::c_void;\n-\n-type StartFn = extern \"C\" fn(*libc::c_void) -> rust_thread_return;\n+type StartFn = extern \"C\" fn(*libc::c_void) -> imp::rust_thread_return;\n \n /// This struct represents a native thread's state. This is used to join on an\n /// existing thread created in the join-able state.\n pub struct Thread<T> {\n-    priv native: rust_thread,\n+    priv native: imp::rust_thread,\n     priv joined: bool,\n     priv packet: ~Option<T>,\n }\n \n-static DEFAULT_STACK_SIZE: libc::size_t = 1024*1024;\n+static DEFAULT_STACK_SIZE: libc::size_t = 1024 * 1024;\n \n // This is the starting point of rust os threads. The first thing we do\n // is make sure that we don't trigger __morestack (also why this has a\n // no_split_stack annotation), and then we extract the main function\n // and invoke it.\n #[no_split_stack]\n-extern fn thread_start(main: *libc::c_void) -> rust_thread_return {\n+extern fn thread_start(main: *libc::c_void) -> imp::rust_thread_return {\n     use rt::context;\n     unsafe {\n         context::record_stack_bounds(0, uint::max_value);\n         let f: ~proc() = cast::transmute(main);\n         (*f)();\n-        cast::transmute(0 as rust_thread_return)\n+        cast::transmute(0 as imp::rust_thread_return)\n     }\n }\n \n@@ -88,7 +78,7 @@ impl Thread<()> {\n             *cast::transmute::<&~Option<T>, **mut Option<T>>(&packet)\n         };\n         let main: proc() = proc() unsafe { *packet2 = Some(main()); };\n-        let native = unsafe { native_thread_create(~main) };\n+        let native = unsafe { imp::create(~main) };\n \n         Thread {\n             native: native,\n@@ -105,18 +95,24 @@ impl Thread<()> {\n     /// there are detached thread still running around.\n     pub fn spawn(main: proc()) {\n         unsafe {\n-            let handle = native_thread_create(~main);\n-            native_thread_detach(handle);\n+            let handle = imp::create(~main);\n+            imp::detach(handle);\n         }\n     }\n+\n+    /// Relinquishes the CPU slot that this OS-thread is currently using,\n+    /// allowing another thread to run for awhile.\n+    pub fn yield_now() {\n+        unsafe { imp::yield_now(); }\n+    }\n }\n \n impl<T: Send> Thread<T> {\n     /// Wait for this thread to finish, returning the result of the thread's\n     /// calculation.\n     pub fn join(mut self) -> T {\n         assert!(!self.joined);\n-        unsafe { native_thread_join(self.native) };\n+        unsafe { imp::join(self.native) };\n         self.joined = true;\n         assert!(self.packet.is_some());\n         self.packet.take_unwrap()\n@@ -129,80 +125,115 @@ impl<T: Send> Drop for Thread<T> {\n         // This is required for correctness. If this is not done then the thread\n         // would fill in a return box which no longer exists.\n         if !self.joined {\n-            unsafe { native_thread_join(self.native) };\n+            unsafe { imp::join(self.native) };\n         }\n     }\n }\n \n #[cfg(windows)]\n-unsafe fn native_thread_create(p: ~proc()) -> rust_thread {\n-    let arg: *mut libc::c_void = cast::transmute(p);\n-    CreateThread(ptr::mut_null(), DEFAULT_STACK_SIZE, thread_start,\n-                 arg, 0, ptr::mut_null())\n-}\n-\n-#[cfg(windows)]\n-unsafe fn native_thread_join(native: rust_thread) {\n-    use libc::consts::os::extra::INFINITE;\n-    WaitForSingleObject(native, INFINITE);\n-}\n+mod imp {\n+    use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n+                                       LPVOID, DWORD, LPDWORD, HANDLE};\n+    use libc;\n+    use cast;\n+    use super::DEFAULT_STACK_SIZE;\n+\n+    pub type rust_thread = HANDLE;\n+    pub type rust_thread_return = DWORD;\n+\n+    pub unsafe fn create(p: ~proc()) -> rust_thread {\n+        let arg: *mut libc::c_void = cast::transmute(p);\n+        CreateThread(ptr::mut_null(), DEFAULT_STACK_SIZE, super::thread_start,\n+                     arg, 0, ptr::mut_null())\n+    }\n \n-#[cfg(windows)]\n-unsafe fn native_thread_detach(native: rust_thread) {\n-    assert!(libc::CloseHandle(native) != 0);\n-}\n+    pub unsafe fn join(native: rust_thread) {\n+        use libc::consts::os::extra::INFINITE;\n+        WaitForSingleObject(native, INFINITE);\n+    }\n \n-#[cfg(unix)]\n-unsafe fn native_thread_create(p: ~proc()) -> rust_thread {\n-    use unstable::intrinsics;\n-    use libc::consts::os::posix01::PTHREAD_CREATE_JOINABLE;\n+    pub unsafe fn detach(native: rust_thread) {\n+        assert!(libc::CloseHandle(native) != 0);\n+    }\n \n-    let mut native: libc::pthread_t = intrinsics::uninit();\n-    let mut attr: libc::pthread_attr_t = intrinsics::uninit();\n-    assert_eq!(pthread_attr_init(&mut attr), 0);\n-    assert_eq!(pthread_attr_setstacksize(&mut attr, DEFAULT_STACK_SIZE), 0);\n-    assert_eq!(pthread_attr_setdetachstate(&mut attr, PTHREAD_CREATE_JOINABLE), 0);\n+    pub unsafe fn yield_now() {\n+        // This function will return 0 if there are no other threads to execute,\n+        // but this also means that the yield was useless so this isn't really a\n+        // case that needs to be worried about.\n+        SwitchToThread();\n+    }\n \n-    let arg: *libc::c_void = cast::transmute(p);\n-    assert_eq!(pthread_create(&mut native, &attr, thread_start, arg), 0);\n-    native\n+    extern \"system\" {\n+        fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n+                        dwStackSize: SIZE_T,\n+                        lpStartAddress: super::StartFn,\n+                        lpParameter: LPVOID,\n+                        dwCreationFlags: DWORD,\n+                        lpThreadId: LPDWORD) -> HANDLE;\n+        fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n+        fn SwitchToThread() -> BOOL;\n+    }\n }\n \n #[cfg(unix)]\n-unsafe fn native_thread_join(native: rust_thread) {\n-    assert_eq!(pthread_join(native, ptr::null()), 0);\n-}\n+mod imp {\n+    use cast;\n+    use libc::consts::os::posix01::PTHREAD_CREATE_JOINABLE;\n+    use libc;\n+    use ptr;\n+    use super::DEFAULT_STACK_SIZE;\n+    use unstable::intrinsics;\n \n-#[cfg(unix)]\n-fn native_thread_detach(native: rust_thread) {\n-    unsafe { assert_eq!(pthread_detach(native), 0) }\n-}\n+    pub type rust_thread = libc::pthread_t;\n+    pub type rust_thread_return = *libc::c_void;\n+\n+    pub unsafe fn create(p: ~proc()) -> rust_thread {\n+        let mut native: libc::pthread_t = intrinsics::uninit();\n+        let mut attr: libc::pthread_attr_t = intrinsics::uninit();\n+        assert_eq!(pthread_attr_init(&mut attr), 0);\n+        assert_eq!(pthread_attr_setstacksize(&mut attr, DEFAULT_STACK_SIZE), 0);\n+        assert_eq!(pthread_attr_setdetachstate(&mut attr,\n+                                               PTHREAD_CREATE_JOINABLE), 0);\n+\n+        let arg: *libc::c_void = cast::transmute(p);\n+        assert_eq!(pthread_create(&mut native, &attr,\n+                                  super::thread_start, arg), 0);\n+        native\n+    }\n \n-#[cfg(windows)]\n-extern \"system\" {\n-    fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n-                    dwStackSize: SIZE_T,\n-                    lpStartAddress: StartFn,\n-                    lpParameter: LPVOID,\n-                    dwCreationFlags: DWORD,\n-                    lpThreadId: LPDWORD) -> HANDLE;\n-    fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n-}\n+    pub unsafe fn join(native: rust_thread) {\n+        assert_eq!(pthread_join(native, ptr::null()), 0);\n+    }\n \n-#[cfg(unix)]\n-extern {\n-    fn pthread_create(native: *mut libc::pthread_t,\n-                      attr: *libc::pthread_attr_t,\n-                      f: StartFn,\n-                      value: *libc::c_void) -> libc::c_int;\n-    fn pthread_join(native: libc::pthread_t,\n-                    value: **libc::c_void) -> libc::c_int;\n-    fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n-    fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n-                                 stack_size: libc::size_t) -> libc::c_int;\n-    fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,\n-                                   state: libc::c_int) -> libc::c_int;\n-    fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;\n+    pub unsafe fn detach(native: rust_thread) {\n+        assert_eq!(pthread_detach(native), 0);\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    pub unsafe fn yield_now() { assert_eq!(sched_yield(), 0); }\n+\n+    #[cfg(not(target_os = \"macos\"))]\n+    pub unsafe fn yield_now() { assert_eq!(pthread_yield(), 0); }\n+\n+    extern {\n+        fn pthread_create(native: *mut libc::pthread_t,\n+                          attr: *libc::pthread_attr_t,\n+                          f: super::StartFn,\n+                          value: *libc::c_void) -> libc::c_int;\n+        fn pthread_join(native: libc::pthread_t,\n+                        value: **libc::c_void) -> libc::c_int;\n+        fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n+        fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n+                                     stack_size: libc::size_t) -> libc::c_int;\n+        fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,\n+                                       state: libc::c_int) -> libc::c_int;\n+        fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;\n+\n+        #[cfg(target_os = \"macos\")]\n+        fn sched_yield() -> libc::c_int;\n+        #[cfg(not(target_os = \"macos\"))]\n+        fn pthread_yield() -> libc::c_int;\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "70ad752ea935b4f52057cc68f2d941e46b2ebd78", "filename": "src/libstd/run.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -12,7 +12,7 @@\n \n #[allow(missing_doc)];\n \n-use comm::{stream, SharedChan};\n+use comm::SharedChan;\n use io::Reader;\n use io::process::ProcessExit;\n use io::process;\n@@ -220,8 +220,7 @@ impl Process {\n         // in parallel so we don't deadlock while blocking on one\n         // or the other. FIXME (#2625): Surely there's a much more\n         // clever way to do this.\n-        let (p, ch) = stream();\n-        let ch = SharedChan::new(ch);\n+        let (p, ch) = SharedChan::new();\n         let ch_clone = ch.clone();\n \n         do spawn {"}, {"sha": "cca64244db569f814ba9b95218047e251ee6947d", "filename": "src/libstd/select.rs", "status": "removed", "additions": 0, "deletions": 306, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/bfa9064ba2687eb1d95708f72f41ddd9729a6ba1/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa9064ba2687eb1d95708f72f41ddd9729a6ba1/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=bfa9064ba2687eb1d95708f72f41ddd9729a6ba1", "patch": "@@ -1,306 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(missing_doc)];\n-\n-use comm;\n-use container::Container;\n-use iter::{Iterator, DoubleEndedIterator};\n-use kinds::Send;\n-use ops::Drop;\n-use option::*;\n-use rt::local::Local;\n-use rt::rtio::EventLoop;\n-use rt::sched::Scheduler;\n-use rt::shouldnt_be_public::{SelectInner, SelectPortInner};\n-use vec::{OwnedVector, MutableVector};\n-\n-/// Trait for message-passing primitives that can be select()ed on.\n-pub trait Select : SelectInner { }\n-\n-/// Trait for message-passing primitives that can use the select2() convenience wrapper.\n-// (This is separate from the above trait to enable heterogeneous lists of ports\n-// that implement Select on different types to use select().)\n-pub trait SelectPort<T> : SelectPortInner<T> { }\n-\n-/// A helper type that throws away a value on a port.\n-struct PortGuard<T> {\n-    port: Option<comm::PortOne<T>>,\n-}\n-\n-#[unsafe_destructor]\n-impl<T:Send> Drop for PortGuard<T> {\n-    fn drop(&mut self) {\n-        let _ = self.port.take_unwrap().recv();\n-    }\n-}\n-\n-/// Receive a message from any one of many ports at once. Returns the index of the\n-/// port whose data is ready. (If multiple are ready, returns the lowest index.)\n-pub fn select<A: Select>(ports: &mut [A]) -> uint {\n-    if ports.is_empty() {\n-        fail!(\"can't select on an empty list\");\n-    }\n-\n-    for (index, port) in ports.mut_iter().enumerate() {\n-        if port.optimistic_check() {\n-            return index;\n-        }\n-    }\n-\n-    // If one of the ports already contains data when we go to block on it, we\n-    // don't bother enqueueing on the rest of them, so we shouldn't bother\n-    // unblocking from it either. This is just for efficiency, not correctness.\n-    // (If not, we need to unblock from all of them. Length is a placeholder.)\n-    let mut ready_index = ports.len();\n-\n-    // XXX: We're using deschedule...and_then in an unsafe way here (see #8132),\n-    // in that we need to continue mutating the ready_index in the environment\n-    // after letting the task get woken up. The and_then closure needs to delay\n-    // the task from resuming until all ports have become blocked_on.\n-    let (p,c) = comm::oneshot();\n-\n-    {\n-        let _guard = PortGuard {\n-            port: Some(p),\n-        };\n-\n-        let mut c = Some(c);\n-        let sched: ~Scheduler = Local::take();\n-        sched.deschedule_running_task_and_then(|sched, task| {\n-            let task_handles = task.make_selectable(ports.len());\n-\n-            for (index, (port, task_handle)) in\n-                    ports.mut_iter().zip(task_handles.move_iter()).enumerate() {\n-                // If one of the ports has data by now, it will wake the handle.\n-                if port.block_on(sched, task_handle) {\n-                    ready_index = index;\n-                    break;\n-                }\n-            }\n-\n-            let c = c.take_unwrap();\n-            do sched.event_loop.callback {\n-                c.send_deferred(())\n-            }\n-        })\n-    }\n-\n-    // Task resumes. Now unblock ourselves from all the ports we blocked on.\n-    // If the success index wasn't reset, 'take' will just take all of them.\n-    // Iterate in reverse so the 'earliest' index that's ready gets returned.\n-    for (index, port) in ports.mut_slice(0, ready_index).mut_iter().enumerate().invert() {\n-        if port.unblock_from() {\n-            ready_index = index;\n-        }\n-    }\n-\n-    assert!(ready_index < ports.len());\n-    return ready_index;\n-}\n-\n-/* FIXME(#5121, #7914) This all should be legal, but rust is not clever enough yet.\n-\n-impl <'a> Select for &'a mut Select {\n-    fn optimistic_check(&mut self) -> bool { self.optimistic_check() }\n-    fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n-        self.block_on(sched, task)\n-    }\n-    fn unblock_from(&mut self) -> bool { self.unblock_from() }\n-}\n-\n-pub fn select2<TA, A: SelectPort<TA>, TB, B: SelectPort<TB>>(mut a: A, mut b: B)\n-        -> Either<(Option<TA>, B), (A, Option<TB>)> {\n-    let result = {\n-        let mut ports = [&mut a as &mut Select, &mut b as &mut Select];\n-        select(ports)\n-    };\n-    match result {\n-        0 => Left ((a.recv_ready(), b)),\n-        1 => Right((a, b.recv_ready())),\n-        x => fail!(\"impossible case in select2: {:?}\", x)\n-    }\n-}\n-\n-*/\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use clone::Clone;\n-    use num::Times;\n-    use option::*;\n-    use rt::comm::*;\n-    use rt::test::*;\n-    use vec::*;\n-    use comm::GenericChan;\n-    use task;\n-    use iter::{Iterator, range};\n-\n-    #[test] #[should_fail]\n-    fn select_doesnt_get_trolled() {\n-        select::<PortOne<()>>([]);\n-    }\n-\n-    /* non-blocking select tests */\n-\n-    #[cfg(test)]\n-    fn select_helper(num_ports: uint, send_on_chans: &[uint]) {\n-        // Unfortunately this does not actually test the block_on early-break\n-        // codepath in select -- racing between the sender and the receiver in\n-        // separate tasks is necessary to get around the optimistic check.\n-        let (ports, chans) = unzip(range(0, num_ports).map(|_| oneshot::<()>()));\n-        let mut dead_chans = ~[];\n-        let mut ports = ports;\n-        for (i, chan) in chans.move_iter().enumerate() {\n-            if send_on_chans.contains(&i) {\n-                chan.send(());\n-            } else {\n-                dead_chans.push(chan);\n-            }\n-        }\n-        let ready_index = select(ports);\n-        assert!(send_on_chans.contains(&ready_index));\n-        assert!(ports.swap_remove(ready_index).recv_ready().is_some());\n-        let _ = dead_chans;\n-\n-        // Same thing with streams instead.\n-        // FIXME(#7971): This should be in a macro but borrowck isn't smart enough.\n-        let (ports, chans) = unzip(range(0, num_ports).map(|_| stream::<()>()));\n-        let mut dead_chans = ~[];\n-        let mut ports = ports;\n-        for (i, chan) in chans.move_iter().enumerate() {\n-            if send_on_chans.contains(&i) {\n-                chan.send(());\n-            } else {\n-                dead_chans.push(chan);\n-            }\n-        }\n-        let ready_index = select(ports);\n-        assert!(send_on_chans.contains(&ready_index));\n-        assert!(ports.swap_remove(ready_index).recv_ready().is_some());\n-        let _ = dead_chans;\n-    }\n-\n-    #[test]\n-    fn select_one() {\n-        do run_in_uv_task { select_helper(1, [0]) }\n-    }\n-\n-    #[test]\n-    fn select_two() {\n-        // NB. I would like to have a test that tests the first one that is\n-        // ready is the one that's returned, but that can't be reliably tested\n-        // with the randomized behaviour of optimistic_check.\n-        do run_in_uv_task { select_helper(2, [1]) }\n-        do run_in_uv_task { select_helper(2, [0]) }\n-        do run_in_uv_task { select_helper(2, [1,0]) }\n-    }\n-\n-    #[test]\n-    fn select_a_lot() {\n-        do run_in_uv_task { select_helper(12, [7,8,9]) }\n-    }\n-\n-    #[test]\n-    fn select_stream() {\n-        use util;\n-        use comm::GenericChan;\n-\n-        // Sends 10 buffered packets, and uses select to retrieve them all.\n-        // Puts the port in a different spot in the vector each time.\n-        do run_in_uv_task {\n-            let (ports, _) = unzip(range(0u, 10).map(|_| stream::<int>()));\n-            let (port, chan) = stream();\n-            10.times(|| { chan.send(31337); });\n-            let mut ports = ports;\n-            let mut port = Some(port);\n-            let order = [5u,0,4,3,2,6,9,8,7,1];\n-            for &index in order.iter() {\n-                // put the port in the vector at any index\n-                util::swap(port.get_mut_ref(), &mut ports[index]);\n-                assert!(select(ports) == index);\n-                // get it back out\n-                util::swap(port.get_mut_ref(), &mut ports[index]);\n-                // NB. Not recv(), because optimistic_check randomly fails.\n-                assert!(port.get_ref().recv_ready().unwrap() == 31337);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn select_simple() {\n-        do run_in_uv_task {\n-            select_helper(2, [1])\n-        }\n-    }\n-\n-    /* blocking select tests */\n-\n-    #[test]\n-    fn select_blocking() {\n-        do run_in_uv_task {\n-            let (p1,_c) = oneshot();\n-            let (p2,c2) = oneshot();\n-            let mut ports = [p1,p2];\n-\n-            let (p3,c3) = oneshot();\n-            let (p4,c4) = oneshot();\n-\n-            do task::spawn {\n-                p3.recv();   // handshake parent\n-                c4.send(()); // normal receive\n-                task::deschedule();\n-                c2.send(()); // select receive\n-            }\n-\n-            // Try to block before child sends on c2.\n-            c3.send(());\n-            p4.recv();\n-            assert!(select(ports) == 1);\n-        }\n-    }\n-\n-    #[test]\n-    fn select_racing_senders() {\n-        static NUM_CHANS: uint = 10;\n-\n-        select_racing_senders_helper(~[0,1,2,3,4,5,6,7,8,9]);\n-        select_racing_senders_helper(~[0,1,2]);\n-        select_racing_senders_helper(~[3,4,5,6]);\n-        select_racing_senders_helper(~[7,8,9]);\n-\n-        fn select_racing_senders_helper(send_on_chans: ~[uint]) {\n-            use rt::test::spawntask_random;\n-\n-            do run_in_uv_task {\n-                // A bit of stress, since ordinarily this is just smoke and mirrors.\n-                4.times(|| {\n-                    let send_on_chans = send_on_chans.clone();\n-                    do task::spawn {\n-                        let mut ports = ~[];\n-                        for i in range(0u, NUM_CHANS) {\n-                            let (p,c) = oneshot();\n-                            ports.push(p);\n-                            if send_on_chans.contains(&i) {\n-                                do spawntask_random {\n-                                    task::deschedule();\n-                                    c.send(());\n-                                }\n-                            }\n-                        }\n-                        // nondeterministic result, but should succeed\n-                        select(ports);\n-                    }\n-                })\n-            }\n-        }\n-    }\n-}"}, {"sha": "0e56f42f5b9c013650e2c2cc2390556c61467ff6", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 21, "deletions": 51, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -55,11 +55,10 @@\n \n use prelude::*;\n \n-use comm::{stream, Chan, GenericChan, GenericPort, Port, Peekable};\n+use comm::{Chan, Port};\n use result::{Result, Ok, Err};\n use rt::in_green_task_context;\n use rt::local::Local;\n-use rt::task::{UnwindResult, Success, Failure};\n use send_str::{SendStr, IntoSendStr};\n use util;\n \n@@ -81,33 +80,6 @@ pub mod spawn;\n /// children tasks complete, recommend using a result future.\n pub type TaskResult = Result<(), ~Any>;\n \n-pub struct TaskResultPort {\n-    priv port: Port<UnwindResult>\n-}\n-\n-fn to_task_result(res: UnwindResult) -> TaskResult {\n-    match res {\n-        Success => Ok(()), Failure(a) => Err(a),\n-    }\n-}\n-\n-impl GenericPort<TaskResult> for TaskResultPort {\n-    #[inline]\n-    fn recv(&self) -> TaskResult {\n-        to_task_result(self.port.recv())\n-    }\n-\n-    #[inline]\n-    fn try_recv(&self) -> Option<TaskResult> {\n-        self.port.try_recv().map(to_task_result)\n-    }\n-}\n-\n-impl Peekable<TaskResult> for TaskResultPort {\n-    #[inline]\n-    fn peek(&self) -> bool { self.port.peek() }\n-}\n-\n /// Scheduler modes\n #[deriving(Eq)]\n pub enum SchedMode {\n@@ -150,7 +122,7 @@ pub struct SchedOpts {\n  */\n pub struct TaskOpts {\n     priv watched: bool,\n-    priv notify_chan: Option<Chan<UnwindResult>>,\n+    priv notify_chan: Option<Chan<TaskResult>>,\n     name: Option<SendStr>,\n     sched: SchedOpts,\n     stack_size: Option<uint>\n@@ -232,7 +204,7 @@ impl TaskBuilder {\n     ///\n     /// # Failure\n     /// Fails if a future_result was already set for this task.\n-    pub fn future_result(&mut self) -> TaskResultPort {\n+    pub fn future_result(&mut self) -> Port<TaskResult> {\n         // FIXME (#3725): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -243,12 +215,12 @@ impl TaskBuilder {\n         }\n \n         // Construct the future and give it to the caller.\n-        let (notify_pipe_po, notify_pipe_ch) = stream::<UnwindResult>();\n+        let (notify_pipe_po, notify_pipe_ch) = Chan::new();\n \n         // Reconfigure self to use a notify channel.\n         self.opts.notify_chan = Some(notify_pipe_ch);\n \n-        TaskResultPort { port: notify_pipe_po }\n+        notify_pipe_po\n     }\n \n     /// Name the task-to-be. Currently the name is used for identification\n@@ -341,7 +313,7 @@ impl TaskBuilder {\n      * Fails if a future_result was already set for this task.\n      */\n     pub fn try<T:Send>(mut self, f: proc() -> T) -> Result<T, ~Any> {\n-        let (po, ch) = stream::<T>();\n+        let (po, ch) = Chan::new();\n \n         let result = self.future_result();\n \n@@ -466,7 +438,7 @@ pub fn failing() -> bool {\n // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n \n #[cfg(test)]\n-fn block_forever() { let (po, _ch) = stream::<()>(); po.recv(); }\n+fn block_forever() { let (po, _ch) = Chan::<()>::new(); po.recv(); }\n \n #[test]\n fn test_unnamed_task() {\n@@ -528,9 +500,8 @@ fn test_send_named_task() {\n \n #[test]\n fn test_run_basic() {\n-    let (po, ch) = stream::<()>();\n-    let builder = task();\n-    do builder.spawn {\n+    let (po, ch) = Chan::new();\n+    do task().spawn {\n         ch.send(());\n     }\n     po.recv();\n@@ -543,7 +514,7 @@ struct Wrapper {\n \n #[test]\n fn test_add_wrapper() {\n-    let (po, ch) = stream::<()>();\n+    let (po, ch) = Chan::new();\n     let mut b0 = task();\n     do b0.add_wrapper |body| {\n         let ch = ch;\n@@ -608,8 +579,7 @@ fn get_sched_id() -> int {\n \n #[test]\n fn test_spawn_sched() {\n-    let (po, ch) = stream::<()>();\n-    let ch = SharedChan::new(ch);\n+    let (po, ch) = SharedChan::new();\n \n     fn f(i: int, ch: SharedChan<()>) {\n         let parent_sched_id = get_sched_id();\n@@ -632,14 +602,14 @@ fn test_spawn_sched() {\n \n #[test]\n fn test_spawn_sched_childs_on_default_sched() {\n-    let (po, ch) = stream();\n+    let (po, ch) = Chan::new();\n \n     // Assuming tests run on the default scheduler\n     let default_id = get_sched_id();\n \n     do spawn_sched(SingleThreaded) {\n-        let parent_sched_id = get_sched_id();\n         let ch = ch;\n+        let parent_sched_id = get_sched_id();\n         do spawn {\n             let child_sched_id = get_sched_id();\n             assert!(parent_sched_id != child_sched_id);\n@@ -660,8 +630,8 @@ fn test_spawn_sched_blocking() {\n         // Testing that a task in one scheduler can block in foreign code\n         // without affecting other schedulers\n         20u.times(|| {\n-            let (start_po, start_ch) = stream();\n-            let (fin_po, fin_ch) = stream();\n+            let (start_po, start_ch) = Chan::new();\n+            let (fin_po, fin_ch) = Chan::new();\n \n             let mut lock = Mutex::new();\n             let lock2 = lock.clone();\n@@ -686,14 +656,14 @@ fn test_spawn_sched_blocking() {\n                 let mut val = 20;\n                 while val > 0 {\n                     val = po.recv();\n-                    ch.send(val - 1);\n+                    ch.try_send(val - 1);\n                 }\n             }\n \n-            let (setup_po, setup_ch) = stream();\n-            let (parent_po, parent_ch) = stream();\n+            let (setup_po, setup_ch) = Chan::new();\n+            let (parent_po, parent_ch) = Chan::new();\n             do spawn {\n-                let (child_po, child_ch) = stream();\n+                let (child_po, child_ch) = Chan::new();\n                 setup_ch.send(child_ch);\n                 pingpong(&child_po, &parent_ch);\n             };\n@@ -712,12 +682,12 @@ fn test_spawn_sched_blocking() {\n \n #[cfg(test)]\n fn avoid_copying_the_body(spawnfn: |v: proc()|) {\n-    let (p, ch) = stream::<uint>();\n+    let (p, ch) = Chan::<uint>::new();\n \n     let x = ~1;\n     let x_in_parent = ptr::to_unsafe_ptr(&*x) as uint;\n \n-    do spawnfn || {\n+    do spawnfn {\n         let x_in_child = ptr::to_unsafe_ptr(&*x) as uint;\n         ch.send(x_in_child);\n     }"}, {"sha": "eb3e19f4a5a7f46bd8552ad47c6a82413639f5a9", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -77,18 +77,15 @@\n \n use prelude::*;\n \n-use comm::{GenericChan, oneshot};\n+use comm::Chan;\n use rt::local::Local;\n use rt::sched::{Scheduler, Shutdown, TaskFromFriend};\n use rt::task::{Task, Sched};\n-use rt::task::UnwindResult;\n use rt::thread::Thread;\n use rt::{in_green_task_context, new_event_loop};\n-use task::SingleThreaded;\n-use task::TaskOpts;\n+use task::{SingleThreaded, TaskOpts, TaskResult};\n \n #[cfg(test)] use task::default_task_opts;\n-#[cfg(test)] use comm;\n #[cfg(test)] use task;\n \n pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n@@ -132,7 +129,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n \n             // Create a task that will later be used to join with the new scheduler\n             // thread when it is ready to terminate\n-            let (thread_port, thread_chan) = oneshot();\n+            let (thread_port, thread_chan) = Chan::new();\n             let join_task = do Task::build_child(None) {\n                 debug!(\"running join task\");\n                 let thread: Thread<()> = thread_port.recv();\n@@ -173,7 +170,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n \n     if opts.notify_chan.is_some() {\n         let notify_chan = opts.notify_chan.take_unwrap();\n-        let on_exit: proc(UnwindResult) = proc(task_result) {\n+        let on_exit: proc(TaskResult) = proc(task_result) {\n             notify_chan.send(task_result)\n         };\n         task.death.on_exit = Some(on_exit);\n@@ -187,7 +184,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n \n #[test]\n fn test_spawn_raw_simple() {\n-    let (po, ch) = stream();\n+    let (po, ch) = Chan::new();\n     do spawn_raw(default_task_opts()) {\n         ch.send(());\n     }\n@@ -208,21 +205,21 @@ fn test_spawn_raw_unsupervise() {\n \n #[test]\n fn test_spawn_raw_notify_success() {\n-    let (notify_po, notify_ch) = comm::stream();\n+    let (notify_po, notify_ch) = Chan::new();\n \n     let opts = task::TaskOpts {\n         notify_chan: Some(notify_ch),\n         .. default_task_opts()\n     };\n     do spawn_raw(opts) {\n     }\n-    assert!(notify_po.recv().is_success());\n+    assert!(notify_po.recv().is_ok());\n }\n \n #[test]\n fn test_spawn_raw_notify_failure() {\n     // New bindings for these\n-    let (notify_po, notify_ch) = comm::stream();\n+    let (notify_po, notify_ch) = Chan::new();\n \n     let opts = task::TaskOpts {\n         watched: false,\n@@ -232,5 +229,5 @@ fn test_spawn_raw_notify_failure() {\n     do spawn_raw(opts) {\n         fail!();\n     }\n-    assert!(notify_po.recv().is_failure());\n+    assert!(notify_po.recv().is_err());\n }"}, {"sha": "043d99eb1b82b46ecc2429750a03f79f78ad87cb", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -10,10 +10,7 @@\n \n #[doc(hidden)];\n \n-use comm::{GenericChan, GenericPort};\n-use comm;\n use prelude::*;\n-use task;\n use libc::uintptr_t;\n \n pub mod dynamic_lib;\n@@ -38,15 +35,7 @@ a normal large stack.\n */\n pub fn run_in_bare_thread(f: proc()) {\n     use rt::thread::Thread;\n-\n-    let (port, chan) = comm::stream();\n-    // FIXME #4525: Unfortunate that this creates an extra scheduler but it's\n-    // necessary since rust_raw_thread_join is blocking\n-    do task::spawn_sched(task::SingleThreaded) {\n-        Thread::start(f).join();\n-        chan.send(());\n-    }\n-    port.recv();\n+    Thread::start(f).join()\n }\n \n #[test]"}, {"sha": "50fae1e0239a6183238f5b1420a38fc8fcca6f7b", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use cast;\n-use comm;\n+use comm::{Chan, Port};\n use ptr;\n use option::{Option,Some,None};\n use task;\n@@ -56,7 +56,7 @@ struct ArcData<T> {\n     // drops the last refcount on an arc. Unfortunately this can't be a proper\n     // pipe protocol because the unwrapper has to access both stages at once.\n     // FIXME(#7544): Maybe use AtomicPtr instead (to avoid xchg in take() later)?\n-    unwrapper: AtomicOption<(comm::ChanOne<()>, comm::PortOne<bool>)>,\n+    unwrapper: AtomicOption<(Chan<()>, Port<bool>)>,\n     // FIXME(#3224) should be able to make this non-option to save memory\n     data: Option<T>,\n }\n@@ -70,7 +70,7 @@ unsafe fn new_inner<T: Send>(data: T, refcount: uint) -> *mut ArcData<T> {\n \n /// A helper object used by `UnsafeArc::unwrap`.\n struct ChannelAndDataGuard<T> {\n-    channel: Option<comm::ChanOne<bool>>,\n+    channel: Option<Chan<bool>>,\n     data: Option<~ArcData<T>>,\n }\n \n@@ -92,7 +92,7 @@ impl<T> Drop for ChannelAndDataGuard<T> {\n }\n \n impl<T> ChannelAndDataGuard<T> {\n-    fn unwrap(mut self) -> (comm::ChanOne<bool>, ~ArcData<T>) {\n+    fn unwrap(mut self) -> (Chan<bool>, ~ArcData<T>) {\n         (self.channel.take_unwrap(), self.data.take_unwrap())\n     }\n }\n@@ -167,8 +167,8 @@ impl<T: Send> UnsafeArc<T> {\n             // The ~ dtor needs to run if this code succeeds.\n             let mut data: ~ArcData<T> = cast::transmute(this.data);\n             // Set up the unwrap protocol.\n-            let (p1,c1) = comm::oneshot(); // ()\n-            let (p2,c2) = comm::oneshot(); // bool\n+            let (p1,c1) = Chan::new(); // ()\n+            let (p2,c2) = Chan::new(); // bool\n             // Try to put our server end in the unwrapper slot.\n             // This needs no barrier -- it's protected by the release barrier on\n             // the xadd, and the acquire+release barrier in the destructor's xadd.\n@@ -269,7 +269,7 @@ impl<T> Drop for UnsafeArc<T>{\n                 // reference. In effect, being here means we're the only\n                 // *awake* task with the data.\n                 match data.unwrapper.take(Acquire) {\n-                    Some(~(message,response)) => {\n+                    Some(~(message, response)) => {\n                         // Send 'ready' and wait for a response.\n                         message.send(());\n                         // Unkillable wait. Message guaranteed to come.\n@@ -508,7 +508,6 @@ impl<T:Send> Exclusive<T> {\n \n #[cfg(test)]\n mod tests {\n-    use comm;\n     use option::*;\n     use prelude::*;\n     use super::{Exclusive, UnsafeArc, atomic};\n@@ -541,18 +540,18 @@ mod tests {\n \n             for _ in range(0u, num_tasks) {\n                 let total = total.clone();\n-                let (port, chan) = comm::stream();\n+                let (port, chan) = Chan::new();\n                 futures.push(port);\n \n-                do task::spawn || {\n+                do task::spawn {\n                     for _ in range(0u, count) {\n                         total.with(|count| **count += 1);\n                     }\n                     chan.send(());\n                 }\n             };\n \n-            for f in futures.iter() { f.recv() }\n+            for f in futures.mut_iter() { f.recv() }\n \n             total.with(|total| assert!(**total == num_tasks * count));\n         }\n@@ -625,7 +624,7 @@ mod tests {\n         // When an unwrap and a try_unwrap race, the unwrapper should always win.\n         let x = UnsafeArc::new(~~\"hello\");\n         let x2 = x.clone();\n-        let (p,c) = comm::stream();\n+        let (p,c) = Chan::new();\n         do task::spawn {\n             c.send(());\n             assert!(x2.unwrap() == ~~\"hello\");"}, {"sha": "ed896af69b41fb1537c1806acfab511715f660d6", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -11,7 +11,7 @@\n use std::task;\n \n pub fn foo<T:Send + Clone>(x: T) -> Port<T> {\n-    let (p, c) = stream();\n+    let (p, c) = Chan::new();\n     do task::spawn() {\n         c.send(x.clone());\n     }"}, {"sha": "015d31bf42cce021520639c9ddcc6bd8c1e445c8", "filename": "src/test/compile-fail/bind-by-move-no-guards.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm;\n-\n fn main() {\n-    let (p,c) = comm::stream();\n+    let (p,c) = Chan::new();\n     let x = Some(p);\n     c.send(false);\n     match x {"}, {"sha": "c82f752a4548ec58c8de023cf3d04dd341660ada", "filename": "src/test/compile-fail/builtin-superkinds-self-type.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -11,18 +11,16 @@\n // Tests (negatively) the ability for the Self type in default methods\n // to use capabilities granted by builtin kinds as supertraits.\n \n-use std::comm;\n-\n trait Foo : Freeze {\n-    fn foo(self, chan: comm::Chan<Self>) {\n+    fn foo(self, mut chan: Chan<Self>) {\n         chan.send(self); //~ ERROR does not fulfill `Send`\n     }\n }\n \n impl <T: Freeze> Foo for T { }\n \n fn main() {\n-    let (p,c) = comm::stream();\n+    let (p,c) = Chan::new();\n     1193182.foo(c);\n     assert!(p.recv() == 1193182);\n }"}, {"sha": "1eff31b2aa4b95ce283d9cc673436979371ed9c0", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -13,8 +13,6 @@\n // Test that a class with an unsendable field can't be\n // sent\n \n-use std::comm;\n-\n struct foo {\n   i: int,\n   j: @~str,\n@@ -29,6 +27,6 @@ fn foo(i:int, j: @~str) -> foo {\n \n fn main() {\n   let cat = ~\"kitty\";\n-    let (_, ch) = comm::stream(); //~ ERROR does not fulfill `Send`\n+  let (_, ch) = Chan::new(); //~ ERROR does not fulfill `Send`\n   ch.send(foo(42, @(cat))); //~ ERROR does not fulfill `Send`\n }"}, {"sha": "7dc12c70b9be4acde885eed5d82cb73a05c6f6f6", "filename": "src/test/run-pass/builtin-superkinds-capabilities-transitive.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -14,20 +14,18 @@\n // a Send. Basically this just makes sure rustc is using\n // each_bound_trait_and_supertraits in type_contents correctly.\n \n-use std::comm;\n-\n trait Bar : Send { }\n trait Foo : Bar { }\n \n impl <T: Send> Foo for T { }\n impl <T: Send> Bar for T { }\n \n-fn foo<T: Foo>(val: T, chan: comm::Chan<T>) {\n+fn foo<T: Foo>(val: T, chan: Chan<T>) {\n     chan.send(val);\n }\n \n pub fn main() {\n-    let (p,c) = comm::stream();\n+    let (p,c) = Chan::new();\n     foo(31337, c);\n     assert!(p.recv() == 31337);\n }"}, {"sha": "f94d1af84f623e8f5f926b21ddb9a14a030615ce", "filename": "src/test/run-pass/builtin-superkinds-capabilities-xc.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -17,20 +17,19 @@\n \n extern mod trait_superkinds_in_metadata;\n use trait_superkinds_in_metadata::{RequiresRequiresFreezeAndSend, RequiresFreeze};\n-use std::comm;\n \n #[deriving(Eq)]\n struct X<T>(T);\n \n impl <T: Freeze> RequiresFreeze for X<T> { }\n impl <T: Freeze+Send> RequiresRequiresFreezeAndSend for X<T> { }\n \n-fn foo<T: RequiresRequiresFreezeAndSend>(val: T, chan: comm::Chan<T>) {\n+fn foo<T: RequiresRequiresFreezeAndSend>(val: T, chan: Chan<T>) {\n     chan.send(val);\n }\n \n fn main() {\n-    let (p,c) = comm::stream();\n+    let (p,c) = Chan::new();\n     foo(X(31337), c);\n     assert!(p.recv() == X(31337));\n }"}, {"sha": "fa3903b41d1ba1e9b600a5fda6258b378b98aba5", "filename": "src/test/run-pass/builtin-superkinds-capabilities.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -12,18 +12,16 @@\n // builtin-kinds, e.g., if a trait requires Send to implement, then\n // at usage site of that trait, we know we have the Send capability.\n \n-use std::comm;\n-\n trait Foo : Send { }\n \n impl <T: Send> Foo for T { }\n \n-fn foo<T: Foo>(val: T, chan: comm::Chan<T>) {\n+fn foo<T: Foo>(val: T, chan: Chan<T>) {\n     chan.send(val);\n }\n \n pub fn main() {\n-    let (p,c) = comm::stream();\n+    let (p,c) = Chan::new();\n     foo(31337, c);\n     assert!(p.recv() == 31337);\n }"}, {"sha": "a71bedfefe021cd78a59171a7097cb2c2430d66d", "filename": "src/test/run-pass/builtin-superkinds-self-type.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -11,18 +11,16 @@\n // Tests the ability for the Self type in default methods to use\n // capabilities granted by builtin kinds as supertraits.\n \n-use std::comm;\n-\n trait Foo : Send {\n-    fn foo(self, chan: comm::Chan<Self>) {\n+    fn foo(self, chan: Chan<Self>) {\n         chan.send(self);\n     }\n }\n \n impl <T: Send> Foo for T { }\n \n pub fn main() {\n-    let (p,c) = comm::stream();\n+    let (p,c) = Chan::new();\n     1193182.foo(c);\n     assert!(p.recv() == 1193182);\n }"}, {"sha": "0d9fdea4a9d51027f313dfaac49f15a0f81449ee", "filename": "src/test/run-pass/capture_nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture_nil.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -27,7 +27,7 @@\n use std::task;\n \n fn foo(x: ()) -> Port<()> {\n-    let (p, c) = stream::<()>();\n+    let (p, c) = Chan::<()>::new();\n     do task::spawn() {\n         c.send(x);\n     }"}, {"sha": "3a92f4ba3f401412545f1f2661c2dd2aab8e5455", "filename": "src/test/run-pass/closure-bounds-can-capture-chan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -15,7 +15,7 @@ fn foo(blk: proc()) {\n }\n \n pub fn main() {\n-    let (p,c) = comm::stream();\n+    let (p,c) = Chan::new();\n     do foo {\n         c.send(());\n     }"}, {"sha": "25e31f0b548b5c78747bef747c31fbb4b0f6c6d7", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -11,8 +11,8 @@\n use std::task;\n \n pub fn main() {\n-    let (p, ch) = stream();\n-    let _t = task::spawn(proc() child(&ch));\n+    let (p, ch) = Chan::new();\n+    let _t = task::spawn(proc() { child(&ch) });\n     let y = p.recv();\n     error!(\"received\");\n     error!(\"{:?}\", y);"}, {"sha": "bacf8353a2e3686e45c8e0726b8add262cf3cc62", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -21,7 +21,6 @@\n pub fn map(filename: ~str, emit: map_reduce::putter) { emit(filename, ~\"1\"); }\n \n mod map_reduce {\n-    use std::comm::{stream, SharedChan};\n     use std::hashmap::HashMap;\n     use std::str;\n     use std::task;\n@@ -43,12 +42,13 @@ mod map_reduce {\n     fn map_task(ctrl: SharedChan<ctrl_proto>, input: ~str) {\n         let intermediates = @mut HashMap::new();\n \n-        fn emit(im: &mut HashMap<~str, int>, ctrl: SharedChan<ctrl_proto>, key: ~str,\n+        fn emit(im: &mut HashMap<~str, int>,\n+                ctrl: SharedChan<ctrl_proto>, key: ~str,\n                 _val: ~str) {\n             if im.contains_key(&key) {\n                 return;\n             }\n-            let (pp, cc) = stream();\n+            let (pp, cc) = Chan::new();\n             error!(\"sending find_reducer\");\n             ctrl.send(find_reducer(key.as_bytes().to_owned(), cc));\n             error!(\"receiving\");\n@@ -63,8 +63,7 @@ mod map_reduce {\n     }\n \n     pub fn map_reduce(inputs: ~[~str]) {\n-        let (ctrl_port, ctrl_chan) = stream();\n-        let ctrl_chan = SharedChan::new(ctrl_chan);\n+        let (ctrl_port, ctrl_chan) = SharedChan::new();\n \n         // This task becomes the master control task. It spawns others\n         // to do the rest.\n@@ -81,10 +80,11 @@ mod map_reduce {\n             match ctrl_port.recv() {\n               mapper_done => { num_mappers -= 1; }\n               find_reducer(k, cc) => {\n-                let c = match reducers.find(&str::from_utf8_owned(k)) {\n-                  Some(&_c) => _c,\n-                  None => 0\n-                };\n+                let mut c;\n+                match reducers.find(&str::from_utf8(k)) {\n+                  Some(&_c) => { c = _c; }\n+                  None => { c = 0; }\n+                }\n                 cc.send(c);\n               }\n             }"}, {"sha": "4922ab18f8d45bca609903e0f914c4b48762a96c", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -14,6 +14,7 @@ enum Msg\n fn foo(name: ~str, samples_chan: Chan<Msg>) {\n     do task::spawn\n     {\n+        let mut samples_chan = samples_chan;\n         let callback: SamplesFn = proc(buffer) {\n             for i in range(0u, buffer.len()) {\n                 error!(\"{}: {}\", i, buffer[i])"}, {"sha": "53b45ba99caf01d0da257785c7d3d3f467b469e0", "filename": "src/test/run-pass/issue-4446.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4446.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let (port, chan) = stream();\n+    let (port, chan) = Chan::new();\n \n     do spawn {\n         println(port.recv());"}, {"sha": "c3f871c79124bae7b74f99610cb09f8f9efff5c8", "filename": "src/test/run-pass/issue-4448.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fissue-4448.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fissue-4448.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4448.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm;\n use std::task;\n \n pub fn main() {\n-    let (port, chan) = comm::stream::<&'static str>();\n+    let (port, chan) = Chan::<&'static str>::new();\n \n     do task::spawn {\n         assert_eq!(port.recv(), \"hello, world\");"}, {"sha": "aa009a91aecf318d0ddff2387fff88bd35b4d078", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -7,8 +7,10 @@ fn producer(c: &Chan<~[u8]>) {\n }\n \n pub fn main() {\n-    let (p, ch) = stream::<~[u8]>();\n-    let _prod = task::spawn(proc() producer(&ch) );\n+    let (p, ch) = Chan::<~[u8]>::new();\n+    let _prod = task::spawn(proc() {\n+        producer(&ch)\n+    });\n \n     let _data: ~[u8] = p.recv();\n }"}, {"sha": "6a88b804c22ee81cc2d9e166b9e43ddbf6def354", "filename": "src/test/run-pass/logging-only-prints-once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -25,7 +25,7 @@ impl fmt::Default for Foo {\n }\n \n pub fn main() {\n-    let (p,c) = stream();\n+    let (p,c) = Chan::new();\n     do spawn {\n         let f = Foo(@mut 0);\n         debug!(\"{}\", f);"}, {"sha": "7ede574a4d5bef69a7443cb14c556105148b29b2", "filename": "src/test/run-pass/send-resource.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -25,10 +25,10 @@ fn test(f: int) -> test {\n }\n \n pub fn main() {\n-    let (p, c) = stream();\n+    let (p, c) = Chan::new();\n \n     do task::spawn() {\n-        let (pp, cc) = stream();\n+        let (pp, cc) = Chan::new();\n         c.send(cc);\n \n         let _r = pp.recv();"}, {"sha": "a8dc4a68e94449f34478f4a0845614ce41d4f113", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -14,8 +14,8 @@ struct Command<K, V> {\n     val: V\n }\n \n-fn cache_server<K:Send,V:Send>(c: Chan<Chan<Command<K, V>>>) {\n-    let (_ctrl_port, ctrl_chan) = stream();\n+fn cache_server<K:Send,V:Send>(mut c: Chan<Chan<Command<K, V>>>) {\n+    let (_ctrl_port, ctrl_chan) = Chan::new();\n     c.send(ctrl_chan);\n }\n pub fn main() { }"}, {"sha": "0c7091a44547ef51aad9557cb5832250781c38a2", "filename": "src/test/run-pass/sendable-class.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendable-class.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -10,8 +10,6 @@\n \n // Test that a class with only sendable fields can be sent\n \n-use std::comm;\n-\n struct foo {\n   i: int,\n   j: char,\n@@ -25,6 +23,6 @@ fn foo(i:int, j: char) -> foo {\n }\n \n pub fn main() {\n-    let (_po, ch) = comm::stream();\n+    let (_po, ch) = Chan::new();\n     ch.send(foo(42, 'c'));\n }"}, {"sha": "67d1836b545cf90e398e085883b7135c66cb6371", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -23,6 +23,6 @@ fn iotask(_cx: &ctx, ip: ~str) {\n }\n \n pub fn main() {\n-    let (_p, ch) = stream::<int>();\n+    let (_p, ch) = Chan::<int>::new();\n     task::spawn(proc() iotask(&ch, ~\"localhost\") );\n }"}, {"sha": "671ef16c5eba4cb9e080e6953af84cf68085433a", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -12,8 +12,6 @@\n \n extern mod extra;\n \n-use std::comm::Chan;\n-use std::comm;\n use std::task;\n \n pub fn main() { test05(); }\n@@ -28,8 +26,8 @@ fn test05_start(ch : &Chan<int>) {\n }\n \n fn test05() {\n-    let (po, ch) = comm::stream();\n-    task::spawn(proc() test05_start(&ch) );\n+    let (po, ch) = Chan::new();\n+    task::spawn(proc() { test05_start(&ch) });\n     let mut value: int = po.recv();\n     error!(\"{}\", value);\n     value = po.recv();"}, {"sha": "fc8c6069152a56967e5051ace43a1d0696352277", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -12,11 +12,10 @@\n \n extern mod extra;\n \n-use std::comm;\n use std::task;\n \n-fn start(c: &comm::Chan<comm::Chan<~str>>) {\n-    let (p, ch) = comm::stream();\n+fn start(c: &Chan<Chan<~str>>) {\n+    let (p, ch) = Chan::new();\n     c.send(ch);\n \n     let mut a;\n@@ -30,10 +29,10 @@ fn start(c: &comm::Chan<comm::Chan<~str>>) {\n }\n \n pub fn main() {\n-    let (p, ch) = comm::stream();\n-    let _child = task::spawn(proc() start(&ch) );\n+    let (p, ch) = Chan::new();\n+    let _child = task::spawn(proc() { start(&ch) });\n \n-    let c = p.recv();\n+    let mut c = p.recv();\n     c.send(~\"A\");\n     c.send(~\"B\");\n     task::deschedule();"}, {"sha": "6f5990e7d167eab198c70affc65c0eccec787351", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -12,16 +12,17 @@\n \n extern mod extra;\n \n-use std::comm;\n use std::task;\n \n-fn start(c: &comm::Chan<comm::Chan<int>>) {\n-    let (_p, ch) = comm::stream();\n+fn start(c: &Chan<Chan<int>>) {\n+    let (_p, ch) = Chan::new();\n     c.send(ch);\n }\n \n pub fn main() {\n-    let (p, ch) = comm::stream();\n-    let _child = task::spawn(proc() start(&ch) );\n+    let (mut p, ch) = Chan::new();\n+    let _child = task::spawn(proc() {\n+        start(&ch)\n+    });\n     let _c = p.recv();\n }"}, {"sha": "ce30071aaf4456cc2760d86908306036b82a7002", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -19,7 +19,7 @@ fn start(_task_number: int) { info!(\"Started / Finished task.\"); }\n fn test00() {\n     let i: int = 0;\n     let mut builder = task::task();\n-    let result = builder.future_result();\n+    let mut result = builder.future_result();\n     do builder.spawn {\n         start(i)\n     }"}, {"sha": "ce3cd59bfb13fb5b8f7093d5c7fc97a64b69c54f", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -12,17 +12,16 @@\n \n extern mod extra;\n \n-use std::comm;\n use std::task;\n \n-fn start(c: &comm::Chan<int>, start: int, number_of_messages: int) {\n+fn start(c: &Chan<int>, start: int, number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(start + i); i += 1; }\n }\n \n pub fn main() {\n     info!(\"Check that we don't deadlock.\");\n-    let (_p, ch) = comm::stream();\n-    task::try(proc() start(&ch, 0, 10) );\n+    let (_p, ch) = Chan::new();\n+    task::try(proc() { start(&ch, 0, 10) });\n     info!(\"Joined task\");\n }"}, {"sha": "435d68ada4964bca64f0754dcaf9111df61ea225", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -10,19 +10,17 @@\n \n // xfail-fast\n \n-use std::comm;\n use std::task;\n \n pub fn main() {\n-    let (po, ch) = comm::stream();\n-    let ch = comm::SharedChan::new(ch);\n+    let (po, ch) = SharedChan::new();\n \n     // Spawn 10 tasks each sending us back one int.\n     let mut i = 10;\n     while (i > 0) {\n         info!(\"{}\", i);\n         let ch = ch.clone();\n-        task::spawn({let i = i; proc() child(i, &ch)});\n+        task::spawn({let i = i; proc() { child(i, &ch) });\n         i = i - 1;\n     }\n \n@@ -39,7 +37,7 @@ pub fn main() {\n     info!(\"main thread exiting\");\n }\n \n-fn child(x: int, ch: &comm::SharedChan<int>) {\n+fn child(x: int, ch: &SharedChan<int>) {\n     info!(\"{}\", x);\n     ch.send(x);\n }"}, {"sha": "9f0d9908f7f5586d8260aaacffb240f3db0be4dd", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -12,10 +12,9 @@\n \n extern mod extra;\n \n-use std::comm;\n use std::task;\n \n-fn start(c: &comm::Chan<int>, i0: int) {\n+fn start(c: &Chan<int>, i0: int) {\n     let mut i = i0;\n     while i > 0 {\n         c.send(0);\n@@ -28,7 +27,10 @@ pub fn main() {\n     // is likely to terminate before the child completes, so from\n     // the child's point of view the receiver may die. We should\n     // drop messages on the floor in this case, and not crash!\n-    let (p, ch) = comm::stream();\n-    task::spawn(proc() start(&ch, 10));\n+    let (p, ch) = Chan::new();\n+    task::spawn(proc() {\n+        let mut ch = ch;\n+        start(&ch, 10)\n+    });\n     p.recv();\n }"}, {"sha": "42d445dc24c2e8cab89fa0c090887d32e58eede4", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm;\n use std::cmp;\n \n // Tests of ports and channels on various types\n fn test_rec() {\n     struct R {val0: int, val1: u8, val2: char}\n \n-    let (po, ch) = comm::stream();\n+    let (po, ch) = Chan::new();\n     let r0: R = R {val0: 0, val1: 1u8, val2: '2'};\n     ch.send(r0);\n     let mut r1: R;\n@@ -26,7 +25,7 @@ fn test_rec() {\n }\n \n fn test_vec() {\n-    let (po, ch) = comm::stream();\n+    let (po, ch) = Chan::new();\n     let v0: ~[int] = ~[0, 1, 2];\n     ch.send(v0);\n     let v1 = po.recv();\n@@ -36,7 +35,7 @@ fn test_vec() {\n }\n \n fn test_str() {\n-    let (po, ch) = comm::stream();\n+    let (po, ch) = Chan::new();\n     let s0 = ~\"test\";\n     ch.send(s0);\n     let s1 = po.recv();\n@@ -80,7 +79,7 @@ impl cmp::Eq for t {\n }\n \n fn test_tag() {\n-    let (po, ch) = comm::stream();\n+    let (po, ch) = Chan::new();\n     ch.send(tag1);\n     ch.send(tag2(10));\n     ch.send(tag3(10, 11u8, 'A'));\n@@ -94,10 +93,10 @@ fn test_tag() {\n }\n \n fn test_chan() {\n-    let (po, ch) = comm::stream();\n-    let (po0, ch0) = comm::stream();\n+    let (po, ch) = Chan::new();\n+    let (po0, ch0) = Chan::new();\n     ch.send(ch0);\n-    let ch1 = po.recv();\n+    let mut ch1 = po.recv();\n     // Does the transmitted channel still work?\n \n     ch1.send(10);"}, {"sha": "9679aebcc9c56284170e98a6367c8f0bcc71a3e2", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -12,8 +12,6 @@\n \n extern mod extra;\n \n-use std::comm::SharedChan;\n-use std::comm;\n use std::task;\n \n pub fn main() { info!(\"===== WITHOUT THREADS =====\"); test00(); }\n@@ -35,8 +33,7 @@ fn test00() {\n \n     info!(\"Creating tasks\");\n \n-    let (po, ch) = comm::stream();\n-    let ch = comm::SharedChan::new(ch);\n+    let (po, ch) = SharedChan::new();\n \n     let mut i: int = 0;\n \n@@ -47,8 +44,11 @@ fn test00() {\n         let mut builder = task::task();\n         results.push(builder.future_result());\n         builder.spawn({\n+            let ch = ch;\n             let i = i;\n-            proc() test00_start(&ch, i, number_of_messages)\n+            proc() {\n+                test00_start(&ch, i, number_of_messages)\n+            }\n         });\n         i = i + 1;\n     }"}, {"sha": "3ac4c0e00876880249a6a31e24a89cf7dc53f1cb", "filename": "src/test/run-pass/task-comm-4.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -10,14 +10,12 @@\n \n #[allow(dead_assignment)];\n \n-use std::comm;\n-\n pub fn main() { test00(); }\n \n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let (p, c) = comm::stream();\n+    let (p, c) = Chan::new();\n     c.send(1);\n     c.send(2);\n     c.send(3);"}, {"sha": "c63bf12db2b33a1015acbfe4afdc8da0eab11b9e", "filename": "src/test/run-pass/task-comm-5.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -10,14 +10,12 @@\n \n extern mod extra;\n \n-use std::comm;\n-\n pub fn main() { test00(); }\n \n fn test00() {\n     let _r: int = 0;\n     let mut sum: int = 0;\n-    let (p, c) = comm::stream();\n+    let (p, c) = Chan::new();\n     let number_of_messages: int = 1000;\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(i + 0); i += 1; }"}, {"sha": "45994e78d9405e337c931e0e00b7010ec1cd22bf", "filename": "src/test/run-pass/task-comm-6.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -10,20 +10,16 @@\n \n #[allow(dead_assignment)];\n \n-use std::comm::SharedChan;\n-use std::comm;\n-\n pub fn main() { test00(); }\n \n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let (p, ch) = comm::stream();\n-    let ch = SharedChan::new(ch);\n-    let c0 = ch.clone();\n-    let c1 = ch.clone();\n-    let c2 = ch.clone();\n-    let c3 = ch.clone();\n+    let (p, ch) = SharedChan::new();\n+    let mut c0 = ch.clone();\n+    let mut c1 = ch.clone();\n+    let mut c2 = ch.clone();\n+    let mut c3 = ch.clone();\n     let number_of_messages: int = 1000;\n     let mut i: int = 0;\n     while i < number_of_messages {"}, {"sha": "43ac3957ae2ed8f3604bae6266b5bc98106846e0", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -14,21 +14,20 @@\n \n extern mod extra;\n \n-use std::comm;\n use std::task;\n \n pub fn main() { test00(); }\n \n-fn test00_start(c: &comm::SharedChan<int>, start: int, number_of_messages: int) {\n+fn test00_start(c: &SharedChan<int>, start: int,\n+                number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(start + i); i += 1; }\n }\n \n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let (p, ch) = comm::stream();\n-    let ch = comm::SharedChan::new(ch);\n+    let (p, ch) = SharedChan::new();\n     let number_of_messages: int = 10;\n \n     let c = ch.clone();"}, {"sha": "a2463ff76815f2f175bd3e60f1f8572a8f53318e", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -12,26 +12,26 @@\n \n extern mod extra;\n \n-use std::comm;\n use std::task;\n \n pub fn main() { test00(); }\n \n-fn test00_start(c: &comm::Chan<int>, number_of_messages: int) {\n+fn test00_start(c: &Chan<int>, number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(i + 0); i += 1; }\n }\n \n fn test00() {\n     let r: int = 0;\n     let mut sum: int = 0;\n-    let (p, ch) = comm::stream();\n+    let (p, ch) = Chan::new();\n     let number_of_messages: int = 10;\n \n     let mut builder = task::task();\n     let result = builder.future_result();\n     do builder.spawn {\n-        test00_start(&ch, number_of_messages);\n+        let mut ch = ch;\n+        test00_start(&mut ch, number_of_messages);\n     }\n \n     let mut i: int = 0;"}, {"sha": "3277400704910cd7b8432d7f26b71c0ceca27827", "filename": "src/test/run-pass/task-comm-chan-nil.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -11,13 +11,11 @@\n \n extern mod extra;\n \n-use std::comm;\n-\n // rustboot can't transmit nils across channels because they don't have\n // any size, but rustc currently can because they do have size. Whether\n // or not this is desirable I don't know, but here's a regression test.\n pub fn main() {\n-    let (po, ch) = comm::stream();\n+    let (po, ch) = Chan::new();\n     ch.send(());\n     let n: () = po.recv();\n     assert_eq!(n, ());"}, {"sha": "1ed0c23fd7a4ce4cb8c4e1ffb629922558bded70", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -12,7 +12,7 @@ use std::ptr;\n use std::task;\n \n pub fn main() {\n-    let (p, ch) = stream::<uint>();\n+    let (p, ch) = Chan::<uint>::new();\n \n     let x = ~1;\n     let x_in_parent = ptr::to_unsafe_ptr(&(*x)) as uint;"}, {"sha": "d3bb8128a3b9e7725f10b3a7a28203132d3c4e4a", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -38,7 +38,7 @@ fn test_tempdir() {\n }\n \n fn test_rm_tempdir() {\n-    let (rd, wr) = stream();\n+    let (rd, wr) = Chan::new();\n     let f: proc() = proc() {\n         let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n         wr.send(tmp.path().clone());"}, {"sha": "7e13d96094756e5d3787ae65603f9da75009ee3b", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -18,7 +18,6 @@\n extern mod extra;\n \n use extra::arc;\n-use std::comm;\n use std::task;\n \n trait Pet {\n@@ -70,13 +69,13 @@ fn main() {\n                          ~dogge1 as ~Pet:Freeze+Send,\n                          ~fishe  as ~Pet:Freeze+Send,\n                          ~dogge2 as ~Pet:Freeze+Send]);\n-    let (p1,c1) = comm::stream();\n+    let (p1,c1) = Chan::new();\n     let arc1 = arc.clone();\n     do task::spawn { check_legs(arc1); c1.send(()); }\n-    let (p2,c2) = comm::stream();\n+    let (p2,c2) = Chan::new();\n     let arc2 = arc.clone();\n     do task::spawn { check_names(arc2); c2.send(()); }\n-    let (p3,c3) = comm::stream();\n+    let (p3,c3) = Chan::new();\n     let arc3 = arc.clone();\n     do task::spawn { check_pedigree(arc3); c3.send(()); }\n     p1.recv();"}, {"sha": "e95f9184a6302d43c1e65bec19b871bc9908d858", "filename": "src/test/run-pass/trivial-message.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrivial-message.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -13,10 +13,8 @@\n   message.\n  */\n \n-use std::comm;\n-\n pub fn main() {\n-    let (po, ch) = comm::stream();\n+    let (po, ch) = Chan::new();\n     ch.send(42);\n     let r = po.recv();\n     error!(\"{:?}\", r);"}, {"sha": "d1c45a336fa7abea0df21d68663c3b236eed9afc", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -8,21 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::{SharedChan, stream};\n use std::task;\n \n fn child(c: &SharedChan<~uint>, i: uint) {\n     c.send(~i);\n }\n \n pub fn main() {\n-    let (p, ch) = stream();\n-    let ch = SharedChan::new(ch);\n+    let (p, ch) = SharedChan::new();\n     let n = 100u;\n     let mut expected = 0u;\n     for i in range(0u, n) {\n         let ch = ch.clone();\n-        task::spawn(proc() child(&ch, i) );\n+        task::spawn(proc() {\n+            child(&ch, i)\n+        });\n         expected += i;\n     }\n "}, {"sha": "a1c0050e725b1e5fef845ad3b3bb5000e31c8667", "filename": "src/test/run-pass/unique-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Funique-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Funique-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let (p, c) = stream();\n+    let (p, c) = Chan::new();\n     c.send(~100);\n     let v = p.recv();\n     assert_eq!(v, ~100);"}, {"sha": "f46769fa28e98910b39a78144d9be195dd653604", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -12,7 +12,6 @@\n \n extern mod extra;\n \n-use std::comm::{stream, SharedChan};\n use std::task;\n \n struct complainer {\n@@ -40,8 +39,7 @@ fn f(c: SharedChan<bool>) {\n }\n \n pub fn main() {\n-    let (p, c) = stream();\n-    let c = SharedChan::new(c);\n+    let (p, c) = SharedChan::new();\n     task::spawn(proc() f(c.clone()));\n     error!(\"hiiiiiiiii\");\n     assert!(p.recv());"}, {"sha": "4ec30d6e02a0bbde441183e5c2bf64e915abcc30", "filename": "src/test/run-pass/yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -12,7 +12,7 @@ use std::task;\n \n pub fn main() {\n     let mut builder = task::task();\n-    let result = builder.future_result();\n+    let mut result = builder.future_result();\n     builder.spawn(child);\n     error!(\"1\");\n     task::deschedule();"}, {"sha": "c08c62b47a2258558961eebc0a86b921a7bca6ed", "filename": "src/test/run-pass/yield1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fyield1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529e268ab900f1b6e731af64ce2aeecda3555f4e/src%2Ftest%2Frun-pass%2Fyield1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield1.rs?ref=529e268ab900f1b6e731af64ce2aeecda3555f4e", "patch": "@@ -12,7 +12,7 @@ use std::task;\n \n pub fn main() {\n     let mut builder = task::task();\n-    let result = builder.future_result();\n+    let mut result = builder.future_result();\n     builder.spawn(child);\n     error!(\"1\");\n     task::deschedule();"}]}