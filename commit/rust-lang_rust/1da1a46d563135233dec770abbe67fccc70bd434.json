{"sha": "1da1a46d563135233dec770abbe67fccc70bd434", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYTFhNDZkNTYzMTM1MjMzZGVjNzcwYWJiZTY3ZmNjYzcwYmQ0MzQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-16T08:43:25Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-16T08:43:25Z"}, "message": "Rollup merge of #26898 - GuillaumeGomez:fixup, r=eddyb\n\n r? @eddyb\n\nFirst part of the improvement. I then intend to improve resolve_error as indicated by @eddyb. Do not merge for now (please !).", "tree": {"sha": "a4e43e976ca11a19b9316dc917392e3770272ccb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4e43e976ca11a19b9316dc917392e3770272ccb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1da1a46d563135233dec770abbe67fccc70bd434", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1da1a46d563135233dec770abbe67fccc70bd434", "html_url": "https://github.com/rust-lang/rust/commit/1da1a46d563135233dec770abbe67fccc70bd434", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1da1a46d563135233dec770abbe67fccc70bd434/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38e875aa806f98d634bb965fa90b66484884aa2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/38e875aa806f98d634bb965fa90b66484884aa2e", "html_url": "https://github.com/rust-lang/rust/commit/38e875aa806f98d634bb965fa90b66484884aa2e"}, {"sha": "60133aa6dd4bf288cacbaba72368f80c131d252c", "url": "https://api.github.com/repos/rust-lang/rust/commits/60133aa6dd4bf288cacbaba72368f80c131d252c", "html_url": "https://github.com/rust-lang/rust/commit/60133aa6dd4bf288cacbaba72368f80c131d252c"}], "stats": {"total": 755, "additions": 539, "deletions": 216}, "files": [{"sha": "aa7f93776da22918cb8fd56d560d57a660459ce3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1da1a46d563135233dec770abbe67fccc70bd434/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1da1a46d563135233dec770abbe67fccc70bd434/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1da1a46d563135233dec770abbe67fccc70bd434", "patch": "@@ -26,6 +26,7 @@ use ParentLink::{self, ModuleParentLink, BlockParentLink};\n use Resolver;\n use resolve_imports::Shadowable;\n use TypeNsDef;\n+use {resolve_error, ResolutionError};\n \n use self::DuplicateCheckingMode::*;\n use self::NamespaceError::*;\n@@ -208,10 +209,13 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     // Return an error here by looking up the namespace that\n                     // had the duplicate.\n                     let ns = ns.unwrap();\n-                    self.resolve_error(sp,\n-                        &format!(\"duplicate definition of {} `{}`\",\n-                             namespace_error_to_string(duplicate_type),\n-                             token::get_name(name)));\n+                    resolve_error(\n+                        self,\n+                        sp,\n+                        ResolutionError::DuplicateDefinition(\n+                            namespace_error_to_string(duplicate_type),\n+                            name)\n+                    );\n                     {\n                         let r = child.span_for_namespace(ns);\n                         if let Some(sp) = r {\n@@ -304,8 +308,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                             full_path.segments.last().unwrap().identifier.name;\n                         if &token::get_name(source_name)[..] == \"mod\" ||\n                            &token::get_name(source_name)[..] == \"self\" {\n-                            self.resolve_error(view_path.span,\n-                                \"`self` imports are only allowed within a { } list\");\n+                            resolve_error(self,\n+                                            view_path.span,\n+                                            ResolutionError::SelfImportsOnlyAllowedWithin\n+                            );\n                         }\n \n                         let subclass = SingleImport(binding.name,\n@@ -325,8 +331,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                             _ => None\n                         }).collect::<Vec<Span>>();\n                         if mod_spans.len() > 1 {\n-                            self.resolve_error(mod_spans[0],\n-                                \"`self` import can only appear once in the list\");\n+                            resolve_error(\n+                                self,\n+                                mod_spans[0],\n+                                ResolutionError::SelfImportCanOnlyAppearOnceInTheList\n+                            );\n                             for other_span in mod_spans.iter().skip(1) {\n                                 self.session.span_note(*other_span,\n                                     \"another `self` import appears here\");\n@@ -341,9 +350,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                     let name = match module_path.last() {\n                                         Some(name) => *name,\n                                         None => {\n-                                            self.resolve_error(source_item.span,\n-                                                \"`self` import can only appear in an import list \\\n-                                                 with a non-empty prefix\");\n+                                            resolve_error(\n+                                                self,\n+                                                source_item.span,\n+                                                ResolutionError::\n+                                                SelfImportOnlyInImportListWithNonEmptyPrefix\n+                                            );\n                                             continue;\n                                         }\n                                     };"}, {"sha": "939991da20307f0679918f33677d9055b2c8e785", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1da1a46d563135233dec770abbe67fccc70bd434/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1da1a46d563135233dec770abbe67fccc70bd434/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=1da1a46d563135233dec770abbe67fccc70bd434", "patch": "@@ -202,12 +202,52 @@ http://doc.rust-lang.org/reference.html#types\n }\n \n register_diagnostics! {\n-    E0157,\n-    E0153,\n+    E0153, // called no where\n+    E0157, // called from no where\n     E0253, // not directly importable\n     E0254, // import conflicts with imported crate in this module\n     E0257,\n     E0258,\n     E0364, // item is private\n-    E0365  // item is private\n+    E0365, // item is private\n+    E0401, // can't use type parameters from outer function\n+    E0402, // cannot use an outer type parameter in this context\n+    E0403, // the name `{}` is already used\n+    E0404, // is not a trait\n+    E0405, // use of undeclared trait name\n+    E0406, // undeclared associated type\n+    E0407, // method is not a member of trait\n+    E0408, // variable from pattern #1 is not bound in pattern #\n+    E0409, // variable is bound with different mode in pattern # than in\n+           // pattern #1\n+    E0410, // variable from pattern is not bound in pattern 1\n+    E0411, // use of `Self` outside of an impl or trait\n+    E0412, // use of undeclared\n+    E0413, // declaration of shadows an enum variant or unit-like struct in\n+           // scope\n+    E0414, // only irrefutable patterns allowed here\n+    E0415, // identifier is bound more than once in this parameter list\n+    E0416, // identifier is bound more than once in the same pattern\n+    E0417, // static variables cannot be referenced in a pattern, use a\n+           // `const` instead\n+    E0418, // is not an enum variant, struct or const\n+    E0419, // unresolved enum variant, struct or const\n+    E0420, // is not an associated const\n+    E0421, // unresolved associated const\n+    E0422, // does not name a structure\n+    E0423, // is a struct variant name, but this expression uses it like a\n+           // function name\n+    E0424, // `self` is not available in a static method.\n+    E0425, // unresolved name\n+    E0426, // use of undeclared label\n+    E0427, // cannot use `ref` binding mode with ...\n+    E0428, // duplicate definition of ...\n+    E0429, // `self` imports are only allowed within a { } list\n+    E0430, // `self` import can only appear once in the list\n+    E0431, // `self` import can only appear in an import list with a non-empty\n+           // prefix\n+    E0432, // unresolved import\n+    E0433, // failed to resolve\n+    E0434, // can't capture dynamic environment in a fn item\n+    E0435  // attempt to use a non-constant value in a constant\n }"}, {"sha": "e1afc33684ce65ea7b595d3b546feeace5405295", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 449, "deletions": 181, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/1da1a46d563135233dec770abbe67fccc70bd434/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1da1a46d563135233dec770abbe67fccc70bd434/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1da1a46d563135233dec770abbe67fccc70bd434", "patch": "@@ -99,7 +99,6 @@ use std::usize;\n use resolve_imports::{Target, ImportDirective, ImportResolution};\n use resolve_imports::Shadowable;\n \n-\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n pub mod diagnostics;\n@@ -109,6 +108,262 @@ mod record_exports;\n mod build_reduced_graph;\n mod resolve_imports;\n \n+pub enum ResolutionError<'a> {\n+    /// error E0401: can't use type parameters from outer function\n+    TypeParametersFromOuterFunction,\n+    /// error E0402: cannot use an outer type parameter in this context\n+    OuterTypeParameterContext,\n+    /// error E0403: the name is already used for a type parameter in this type parameter list\n+    NameAlreadyUsedInTypeParameterList(Name),\n+    /// error E0404: is not a trait\n+    IsNotATrait(&'a str),\n+    /// error E0405: use of undeclared trait name\n+    UndeclaredTraitName(&'a str),\n+    /// error E0406: undeclared associated type\n+    UndeclaredAssociatedType,\n+    /// error E0407: method is not a member of trait\n+    MethodNotMemberOfTrait(Name, &'a str),\n+    /// error E0408: variable `{}` from pattern #1 is not bound in pattern\n+    VariableNotBoundInPattern(Name, usize),\n+    /// error E0409: variable is bound with different mode in pattern #{} than in pattern #1\n+    VariableBoundWithDifferentMode(Name, usize),\n+    /// error E0410: variable from pattern is not bound in pattern #1\n+    VariableNotBoundInParentPattern(Name, usize),\n+    /// error E0411: use of `Self` outside of an impl or trait\n+    SelfUsedOutsideImplOrTrait,\n+    /// error E0412: use of undeclared\n+    UseOfUndeclared(&'a str, &'a str),\n+    /// error E0413: declaration shadows an enum variant or unit-like struct in scope\n+    DeclarationShadowsEnumVariantOrUnitLikeStruct(Name),\n+    /// error E0414: only irrefutable patterns allowed here\n+    OnlyIrrefutablePatternsAllowedHere,\n+    /// error E0415: identifier is bound more than once in this parameter list\n+    IdentifierBoundMoreThanOnceInParameterList(&'a str),\n+    /// error E0416: identifier is bound more than once in the same pattern\n+    IdentifierBoundMoreThanOnceInSamePattern(&'a str),\n+    /// error E0417: static variables cannot be referenced in a pattern\n+    StaticVariableReference,\n+    /// error E0418: is not an enum variant, struct or const\n+    NotAnEnumVariantStructOrConst(&'a str),\n+    /// error E0419: unresolved enum variant, struct or const\n+    UnresolvedEnumVariantStructOrConst(&'a str),\n+    /// error E0420: is not an associated const\n+    NotAnAssociatedConst(&'a str),\n+    /// error E0421: unresolved associated const\n+    UnresolvedAssociatedConst(&'a str),\n+    /// error E0422: does not name a struct\n+    DoesNotNameAStruct(&'a str),\n+    /// error E0423: is a struct variant name, but this expression uses it like a function name\n+    StructVariantUsedAsFunction(&'a str),\n+    /// error E0424: `self` is not available in a static method\n+    SelfNotAvailableInStaticMethod,\n+    /// error E0425: unresolved name\n+    UnresolvedName(&'a str, &'a str),\n+    /// error E0426: use of undeclared label\n+    UndeclaredLabel(&'a str),\n+    /// error E0427: cannot use `ref` binding mode with ...\n+    CannotUseRefBindingModeWith(&'a str),\n+    /// error E0428: duplicate definition\n+    DuplicateDefinition(&'a str, Name),\n+    /// error E0429: `self` imports are only allowed within a { } list\n+    SelfImportsOnlyAllowedWithin,\n+    /// error E0430: `self` import can only appear once in the list\n+    SelfImportCanOnlyAppearOnceInTheList,\n+    /// error E0431: `self` import can only appear in an import list with a non-empty prefix\n+    SelfImportOnlyInImportListWithNonEmptyPrefix,\n+    /// error E0432: unresolved import\n+    UnresolvedImport(Option<(&'a str, Option<&'a str>)>),\n+    /// error E0433: failed to resolve\n+    FailedToResolve(&'a str),\n+    /// error E0434: can't capture dynamic environment in a fn item\n+    CannotCaptureDynamicEnvironmentInFnItem,\n+    /// error E0435: attempt to use a non-constant value in a constant\n+    AttemptToUseNonConstantValueInConstant,\n+}\n+\n+fn resolve_error<'b, 'a:'b, 'tcx:'a>(resolver: &'b Resolver<'a, 'tcx>, span: syntax::codemap::Span,\n+                                     resolution_error: ResolutionError<'b>) {\n+    if !resolver.emit_errors {\n+        return;\n+    }\n+    match resolution_error {\n+        ResolutionError::TypeParametersFromOuterFunction => {\n+            span_err!(resolver.session, span, E0401, \"can't use type parameters from \\\n+                                                      outer function; try using a local \\\n+                                                      type parameter instead\");\n+        },\n+        ResolutionError::OuterTypeParameterContext => {\n+            span_err!(resolver.session, span, E0402,\n+                         \"cannot use an outer type parameter in this context\");\n+        },\n+        ResolutionError::NameAlreadyUsedInTypeParameterList(name) => {\n+            span_err!(resolver.session, span, E0403,\n+                         \"the name `{}` is already used for a type \\\n+                          parameter in this type parameter list\", name);\n+        },\n+        ResolutionError::IsNotATrait(name) => {\n+            span_err!(resolver.session, span, E0404,\n+                         \"`{}` is not a trait\",\n+                         name);\n+        },\n+        ResolutionError::UndeclaredTraitName(name) => {\n+            span_err!(resolver.session, span, E0405,\n+                         \"use of undeclared trait name `{}`\",\n+                         name);\n+        },\n+        ResolutionError::UndeclaredAssociatedType => {\n+            span_err!(resolver.session, span, E0406, \"undeclared associated type\");\n+        },\n+        ResolutionError::MethodNotMemberOfTrait(method, trait_) => {\n+            span_err!(resolver.session, span, E0407,\n+                         \"method `{}` is not a member of trait `{}`\",\n+                         method,\n+                         trait_);\n+        },\n+        ResolutionError::VariableNotBoundInPattern(variable_name, pattern_number) => {\n+            span_err!(resolver.session, span, E0408,\n+                         \"variable `{}` from pattern #1 is not bound in pattern #{}\",\n+                         variable_name,\n+                         pattern_number);\n+        },\n+        ResolutionError::VariableBoundWithDifferentMode(variable_name, pattern_number) => {\n+            span_err!(resolver.session, span, E0409,\n+                         \"variable `{}` is bound with different \\\n+                         mode in pattern #{} than in pattern #1\",\n+                         variable_name,\n+                         pattern_number);\n+        },\n+        ResolutionError::VariableNotBoundInParentPattern(variable_name, pattern_number) => {\n+            span_err!(resolver.session, span, E0410,\n+                         \"variable `{}` from pattern #{} is not bound in pattern #1\",\n+                         variable_name,\n+                         pattern_number);\n+        },\n+        ResolutionError::SelfUsedOutsideImplOrTrait => {\n+            span_err!(resolver.session, span, E0411, \"use of `Self` outside of an impl or trait\");\n+        },\n+        ResolutionError::UseOfUndeclared(kind, name) => {\n+            span_err!(resolver.session, span, E0412,\n+                         \"use of undeclared {} `{}`\",\n+                         kind,\n+                         name);\n+        },\n+        ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(name) => {\n+            span_err!(resolver.session, span, E0413,\n+                         \"declaration of `{}` shadows an enum variant or unit-like struct in \\\n+                          scope\",\n+                         name);\n+        },\n+        ResolutionError::OnlyIrrefutablePatternsAllowedHere => {\n+            span_err!(resolver.session, span, E0414, \"only irrefutable patterns allowed here\");\n+        },\n+        ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n+            span_err!(resolver.session, span, E0415,\n+                         \"identifier `{}` is bound more than once in this parameter list\",\n+                         identifier);\n+        },\n+        ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => {\n+            span_err!(resolver.session, span, E0416,\n+                         \"identifier `{}` is bound more than once in the same pattern\",\n+                         identifier);\n+        },\n+        ResolutionError::StaticVariableReference => {\n+            span_err!(resolver.session, span, E0417, \"static variables cannot be \\\n+                                                      referenced in a pattern, \\\n+                                                      use a `const` instead\");\n+        },\n+        ResolutionError::NotAnEnumVariantStructOrConst(name) => {\n+            span_err!(resolver.session, span, E0418,\n+                         \"`{}` is not an enum variant, struct or const\",\n+                         name);\n+        },\n+        ResolutionError::UnresolvedEnumVariantStructOrConst(name) => {\n+            span_err!(resolver.session, span, E0419,\n+                         \"unresolved enum variant, struct or const `{}`\",\n+                         name);\n+        },\n+        ResolutionError::NotAnAssociatedConst(name) => {\n+            span_err!(resolver.session, span, E0420,\n+                         \"`{}` is not an associated const\",\n+                         name);\n+        },\n+        ResolutionError::UnresolvedAssociatedConst(name) => {\n+            span_err!(resolver.session, span, E0421,\n+                         \"unresolved associated const `{}`\",\n+                         name);\n+        },\n+        ResolutionError::DoesNotNameAStruct(name) => {\n+            span_err!(resolver.session, span, E0422, \"`{}` does not name a structure\", name);\n+        },\n+        ResolutionError::StructVariantUsedAsFunction(path_name) => {\n+            span_err!(resolver.session, span, E0423,\n+                         \"`{}` is a struct variant name, but \\\n+                          this expression \\\n+                          uses it like a function name\",\n+                          path_name);\n+        },\n+        ResolutionError::SelfNotAvailableInStaticMethod => {\n+            span_err!(resolver.session, span, E0424, \"`self` is not available in a static method. \\\n+                                                      Maybe a `self` argument is missing?\");\n+        },\n+        ResolutionError::UnresolvedName(path, name) => {\n+            span_err!(resolver.session, span, E0425,\n+                         \"unresolved name `{}`{}\",\n+                         path,\n+                         name);\n+        },\n+        ResolutionError::UndeclaredLabel(name) => {\n+            span_err!(resolver.session, span, E0426,\n+                         \"use of undeclared label `{}`\",\n+                         name);\n+        },\n+        ResolutionError::CannotUseRefBindingModeWith(descr) => {\n+            span_err!(resolver.session, span, E0427,\n+                         \"cannot use `ref` binding mode with {}\",\n+                         descr);\n+        },\n+        ResolutionError::DuplicateDefinition(namespace, name) => {\n+            span_err!(resolver.session, span, E0428,\n+                         \"duplicate definition of {} `{}`\",\n+                         namespace,\n+                         name);\n+        },\n+        ResolutionError::SelfImportsOnlyAllowedWithin => {\n+            span_err!(resolver.session, span, E0429, \"{}\",\n+                         \"`self` imports are only allowed within a { } list\");\n+        },\n+        ResolutionError::SelfImportCanOnlyAppearOnceInTheList => {\n+            span_err!(resolver.session, span, E0430,\n+                         \"`self` import can only appear once in the list\");\n+        },\n+        ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix => {\n+            span_err!(resolver.session, span, E0431,\n+                         \"`self` import can only appear in an import list with a \\\n+                          non-empty prefix\");\n+        }\n+        ResolutionError::UnresolvedImport(name) => {\n+            let msg = match name {\n+                Some((n, Some(p))) => format!(\"unresolved import `{}`{}\", n, p),\n+                Some((n, None)) => format!(\"unresolved import (maybe you meant `{}::*`?)\", n),\n+                None => \"unresolved import\".to_owned()\n+            };\n+            span_err!(resolver.session, span, E0432, \"{}\", msg);\n+        },\n+        ResolutionError::FailedToResolve(msg) => {\n+            span_err!(resolver.session, span, E0433, \"failed to resolve. {}\", msg);\n+        },\n+        ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n+            span_err!(resolver.session, span, E0434, \"{}\",\n+                         \"can't capture dynamic environment in a fn item; \\\n+                          use the || { ... } closure form instead\");\n+        },\n+        ResolutionError::AttemptToUseNonConstantValueInConstant =>{\n+            span_err!(resolver.session, span, E0435,\n+                         \"attempt to use a non-constant value in a constant\");\n+        },\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n struct BindingInfo {\n     span: Span,\n@@ -947,8 +1202,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if module.external_module_children.borrow().contains_key(&name) {\n                 span_err!(self.session, span, E0259,\n                           \"an external crate named `{}` has already \\\n-                                   been imported into this module\",\n-                                  &token::get_name(name));\n+                           been imported into this module\",\n+                          name);\n         }\n     }\n \n@@ -960,9 +1215,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if module.external_module_children.borrow().contains_key(&name) {\n                 span_err!(self.session, span, E0260,\n                           \"the name `{}` conflicts with an external \\\n-                                   crate that has been imported into this \\\n-                                   module\",\n-                                  &token::get_name(name));\n+                           crate that has been imported into this \\\n+                           module\",\n+                           name);\n         }\n     }\n \n@@ -1041,7 +1296,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Indeterminate => {\n                     debug!(\"(resolving module path for import) module \\\n                             resolution is indeterminate: {}\",\n-                            token::get_name(name));\n+                            name);\n                     return Indeterminate;\n                 }\n                 Success((target, used_proxy)) => {\n@@ -1052,7 +1307,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             match type_def.module_def {\n                                 None => {\n                                     let msg = format!(\"Not a module `{}`\",\n-                                                        token::get_name(name));\n+                                                        name);\n \n                                     return Failed(Some((span, msg)));\n                                 }\n@@ -1078,7 +1333,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         None => {\n                             // There are no type bindings at all.\n                             let msg = format!(\"Not a module `{}`\",\n-                                              token::get_name(name));\n+                                              name);\n                             return Failed(Some((span, msg)));\n                         }\n                     }\n@@ -1200,7 +1455,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in \\\n                 namespace {:?} in `{}`\",\n-               token::get_name(name),\n+               name,\n                namespace,\n                module_to_string(&*module_));\n \n@@ -1302,9 +1557,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               namespace,\n                                               PathSearch,\n                                               true) {\n-                Failed(Some((span, msg))) =>\n-                    self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                     msg)),\n+                Failed(Some((span, msg))) => {\n+                    resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                },\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n                     // We couldn't see through the higher scope because of an\n@@ -1469,7 +1724,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               allow_private_imports: bool)\n                               -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n-               &token::get_name(name),\n+               name,\n                module_to_string(&*module_));\n \n         // First, check the direct children of the module.\n@@ -1547,7 +1802,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // We're out of luck.\n         debug!(\"(resolving name in module) failed to resolve `{}`\",\n-               &token::get_name(name));\n+               name);\n         return Failed(None);\n     }\n \n@@ -1561,12 +1816,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                          .span_to_snippet((*imports)[index].span)\n                          .unwrap();\n             if sn.contains(\"::\") {\n-                self.resolve_error((*imports)[index].span,\n-                                   \"unresolved import\");\n+                resolve_error(self,\n+                              (*imports)[index].span,\n+                              ResolutionError::UnresolvedImport(None));\n             } else {\n-                let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n-                                  sn);\n-                self.resolve_error((*imports)[index].span, &err[..]);\n+                resolve_error(self,\n+                              (*imports)[index].span,\n+                              ResolutionError::UnresolvedImport(Some((&*sn, None))));\n             }\n         }\n \n@@ -1623,15 +1879,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match orig_module.children.borrow().get(&name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n-                               token::get_name(name),\n+                               name,\n                                module_to_string(&*orig_module));\n                     }\n                     Some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             None => {\n                                 debug!(\"!!! (with scope) didn't find module \\\n                                         for `{}` in `{}`\",\n-                                       token::get_name(name),\n+                                       name,\n                                        module_to_string(&*orig_module));\n                             }\n                             Some(module_) => {\n@@ -1692,17 +1948,20 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n-\n-                            self.resolve_error(span,\n-                                \"can't capture dynamic environment in a fn item; \\\n-                                 use the || { ... } closure form instead\");\n+                            resolve_error(\n+                                self,\n+                                span,\n+                                ResolutionError::CannotCaptureDynamicEnvironmentInFnItem\n+                            );\n                             return None;\n                         }\n                         ConstantItemRibKind => {\n                             // Still doesn't deal with upvars\n-                            self.resolve_error(span,\n-                                               \"attempt to use a non-constant \\\n-                                                value in a constant\");\n+                            resolve_error(\n+                                self,\n+                                span,\n+                                ResolutionError::AttemptToUseNonConstantValueInConstant\n+                            );\n                             return None;\n                         }\n                     }\n@@ -1718,17 +1977,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // This was an attempt to use a type parameter outside\n                             // its scope.\n \n-                            self.resolve_error(span,\n-                                               \"can't use type parameters from \\\n-                                                outer function; try using a local \\\n-                                                type parameter instead\");\n+                            resolve_error(self,\n+                                          span,\n+                                          ResolutionError::TypeParametersFromOuterFunction);\n                             return None;\n                         }\n                         ConstantItemRibKind => {\n                             // see #9186\n-                            self.resolve_error(span,\n-                                               \"cannot use an outer type \\\n-                                                parameter in this context\");\n+                            resolve_error(self, span, ResolutionError::OuterTypeParameterContext);\n                             return None;\n                         }\n                     }\n@@ -1795,7 +2051,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name = item.ident.name;\n \n         debug!(\"(resolving item) resolving {}\",\n-               token::get_name(name));\n+               name);\n \n         match item.node {\n             ItemEnum(_, ref generics) |\n@@ -1921,12 +2177,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n \n                     if seen_bindings.contains(&name) {\n-                        self.resolve_error(type_parameter.span,\n-                                           &format!(\"the name `{}` is already \\\n-                                                     used for a type \\\n-                                                     parameter in this type \\\n-                                                     parameter list\",\n-                                                    token::get_name(name)))\n+                        resolve_error(self,\n+                                      type_parameter.span,\n+                                      ResolutionError::NameAlreadyUsedInTypeParameterList(\n+                                        name)\n+                        );\n                     }\n                     seen_bindings.insert(name);\n \n@@ -2013,9 +2268,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n                 Ok(path_res)\n             } else {\n-                self.resolve_error(trait_path.span,\n-                    &format!(\"`{}` is not a trait\",\n-                             path_names_to_string(trait_path, path_depth)));\n+                resolve_error(self,\n+                              trait_path.span,\n+                              ResolutionError::IsNotATrait(&*path_names_to_string(trait_path,\n+                                                                                   path_depth))\n+                             );\n \n                 // If it's a typedef, give a note\n                 if let DefTy(..) = path_res.base_def {\n@@ -2025,9 +2282,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Err(())\n             }\n         } else {\n-            let msg = format!(\"use of undeclared trait name `{}`\",\n-                              path_names_to_string(trait_path, path_depth));\n-            self.resolve_error(trait_path.span, &msg);\n+            resolve_error(self,\n+                          trait_path.span,\n+                          ResolutionError::UndeclaredTraitName(\n+                            &*path_names_to_string(trait_path, path_depth))\n+                         );\n             Err(())\n         }\n     }\n@@ -2045,7 +2304,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     if let Some(PathResolution { base_def: DefTyParam(..), .. }) = path_res {\n                         self.record_def(eq_pred.id, path_res.unwrap());\n                     } else {\n-                        self.resolve_error(eq_pred.path.span, \"undeclared associated type\");\n+                        resolve_error(self,\n+                                      eq_pred.span,\n+                                      ResolutionError::UndeclaredAssociatedType);\n                     }\n                 }\n             }\n@@ -2170,10 +2431,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if let Some((did, ref trait_ref)) = self.current_trait_ref {\n             if !self.trait_item_map.contains_key(&(name, did)) {\n                 let path_str = path_names_to_string(&trait_ref.path, 0);\n-                self.resolve_error(span,\n-                                    &format!(\"method `{}` is not a member of trait `{}`\",\n-                                            token::get_name(name),\n-                                            path_str));\n+                resolve_error(self,\n+                              span,\n+                              ResolutionError::MethodNotMemberOfTrait(name,\n+                                                                       &*path_str));\n             }\n         }\n     }\n@@ -2220,34 +2481,29 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             for (&key, &binding_0) in &map_0 {\n                 match map_i.get(&key) {\n                   None => {\n-                    self.resolve_error(\n-                        p.span,\n-                        &format!(\"variable `{}` from pattern #1 is \\\n-                                  not bound in pattern #{}\",\n-                                token::get_name(key),\n-                                i + 1));\n+                    resolve_error(self,\n+                                  p.span,\n+                                  ResolutionError::VariableNotBoundInPattern(key,\n+                                                                              i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n-                        self.resolve_error(\n-                            binding_i.span,\n-                            &format!(\"variable `{}` is bound with different \\\n-                                      mode in pattern #{} than in pattern #1\",\n-                                    token::get_name(key),\n-                                    i + 1));\n+                        resolve_error(self,\n+                                      binding_i.span,\n+                                      ResolutionError::VariableBoundWithDifferentMode(key,\n+                                                                                       i + 1)\n+                                     );\n                     }\n                   }\n                 }\n             }\n \n             for (&key, &binding) in &map_i {\n                 if !map_0.contains_key(&key) {\n-                    self.resolve_error(\n-                        binding.span,\n-                        &format!(\"variable `{}` from pattern {}{} is \\\n-                                  not bound in pattern {}1\",\n-                                token::get_name(key),\n-                                \"#\", i + 1, \"#\"));\n+                    resolve_error(self,\n+                                  binding.span,\n+                                  ResolutionError::VariableNotBoundInParentPattern(key,\n+                                                                                    i + 1));\n                 }\n             }\n         }\n@@ -2360,14 +2616,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             path.segments.len() > 0 &&\n                             maybe_qself.is_none() &&\n                             path.segments[0].identifier.name == self_type_name;\n-                        let msg = if is_invalid_self_type_name {\n-                            \"use of `Self` outside of an impl or trait\".to_string()\n+                        if is_invalid_self_type_name {\n+                            resolve_error(self,\n+                                          ty.span,\n+                                          ResolutionError::SelfUsedOutsideImplOrTrait);\n                         } else {\n-                            format!(\"use of undeclared {} `{}`\",\n-                                kind, path_names_to_string(path, 0))\n-                        };\n-\n-                        self.resolve_error(ty.span, &msg[..]);\n+                            resolve_error(self,\n+                                          ty.span,\n+                                          ResolutionError::UseOfUndeclared(\n+                                                                    kind,\n+                                                                    &*path_names_to_string(path,\n+                                                                                           0))\n+                                         );\n+                        }\n                     }\n                 }\n             }\n@@ -2405,7 +2666,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     struct or enum variant\",\n-                                   token::get_name(renamed));\n+                                   renamed);\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -2418,17 +2679,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             });\n                         }\n                         FoundStructOrEnumVariant(..) => {\n-                            self.resolve_error(\n+                            resolve_error(\n+                                self,\n                                 pattern.span,\n-                                &format!(\"declaration of `{}` shadows an enum \\\n-                                         variant or unit-like struct in \\\n-                                         scope\",\n-                                        token::get_name(renamed)));\n+                                ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(\n+                                    renamed)\n+                            );\n                         }\n                         FoundConst(def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     constant\",\n-                                   token::get_name(renamed));\n+                                   renamed);\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -2441,13 +2702,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             });\n                         }\n                         FoundConst(..) => {\n-                            self.resolve_error(pattern.span,\n-                                                  \"only irrefutable patterns \\\n-                                                   allowed here\");\n+                            resolve_error(\n+                                self,\n+                                pattern.span,\n+                                ResolutionError::OnlyIrrefutablePatternsAllowedHere\n+                            );\n                         }\n                         BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `{}`\",\n-                                   token::get_name(renamed));\n+                                   renamed);\n \n                             let def = DefLocal(pattern.id);\n \n@@ -2475,24 +2738,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     bindings_list.contains_key(&renamed) {\n                                 // Forbid duplicate bindings in the same\n                                 // parameter list.\n-                                self.resolve_error(pattern.span,\n-                                                   &format!(\"identifier `{}` \\\n-                                                            is bound more \\\n-                                                            than once in \\\n-                                                            this parameter \\\n-                                                            list\",\n-                                                           token::get_ident(\n-                                                               ident))\n-                                                   )\n+                                resolve_error(\n+                                    self,\n+                                    pattern.span,\n+                                    ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n+                                        &*token::get_ident(ident))\n+                                );\n                             } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n                                 // same disjunction, which is an error.\n-                                self.resolve_error(pattern.span,\n-                                    &format!(\"identifier `{}` is bound \\\n-                                             more than once in the same \\\n-                                             pattern\",\n-                                            token::get_ident(ident)));\n+                                resolve_error(\n+                                    self,\n+                                    pattern.span,\n+                                    ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n+                                        &*token::get_ident(ident))\n+                                );\n                             }\n                             // Else, not bound in the same pattern: do\n                             // nothing.\n@@ -2523,22 +2784,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 self.record_def(pattern.id, path_res);\n                             }\n                             DefStatic(..) => {\n-                                self.resolve_error(path.span,\n-                                                   \"static variables cannot be \\\n-                                                    referenced in a pattern, \\\n-                                                    use a `const` instead\");\n+                                resolve_error(&self,\n+                                              path.span,\n+                                              ResolutionError::StaticVariableReference);\n                             }\n                             _ => {\n                                 // If anything ends up here entirely resolved,\n                                 // it's an error. If anything ends up here\n                                 // partially resolved, that's OK, because it may\n                                 // be a `T::CONST` that typeck will resolve.\n                                 if path_res.depth == 0 {\n-                                    self.resolve_error(\n+                                    resolve_error(\n+                                        self,\n                                         path.span,\n-                                        &format!(\"`{}` is not an enum variant, struct or const\",\n-                                                 token::get_ident(\n-                                                     path.segments.last().unwrap().identifier)));\n+                                        ResolutionError::NotAnEnumVariantStructOrConst(\n+                                            &*token::get_ident(\n+                                                path.segments.last().unwrap().identifier)\n+                                            )\n+                                    );\n                                 } else {\n                                     let const_name = path.segments.last().unwrap()\n                                                          .identifier.name;\n@@ -2549,9 +2812,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             }\n                         }\n                     } else {\n-                        self.resolve_error(path.span,\n-                            &format!(\"unresolved enum variant, struct or const `{}`\",\n-                                token::get_ident(path.segments.last().unwrap().identifier)));\n+                        resolve_error(\n+                            self,\n+                            path.span,\n+                            ResolutionError::UnresolvedEnumVariantStructOrConst(\n+                                &*token::get_ident(path.segments.last().unwrap().identifier))\n+                        );\n                     }\n                     visit::walk_path(self, path);\n                 }\n@@ -2583,16 +2849,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 self.record_def(pattern.id, path_res);\n                             }\n                             _ => {\n-                                self.resolve_error(path.span,\n-                                    &format!(\"`{}` is not an associated const\",\n-                                        token::get_ident(\n-                                            path.segments.last().unwrap().identifier)));\n+                                resolve_error(\n+                                    self,\n+                                    path.span,\n+                                    ResolutionError::NotAnAssociatedConst(\n+                                        &*token::get_ident(\n+                                            path.segments.last().unwrap().identifier)\n+                                    )\n+                                );\n                             }\n                         }\n                     } else {\n-                        self.resolve_error(path.span,\n-                            &format!(\"unresolved associated const `{}`\",\n-                                token::get_ident(path.segments.last().unwrap().identifier)));\n+                        resolve_error(\n+                            self,\n+                            path.span,\n+                            ResolutionError::UnresolvedAssociatedConst(\n+                                &*token::get_ident(path.segments.last().unwrap().identifier)\n+                            )\n+                        );\n                     }\n                     visit::walk_pat(self, pattern);\n                 }\n@@ -2605,9 +2879,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         result => {\n                             debug!(\"(resolving pattern) didn't find struct \\\n                                     def: {:?}\", result);\n-                            let msg = format!(\"`{}` does not name a structure\",\n-                                              path_names_to_string(path, 0));\n-                            self.resolve_error(path.span, &msg[..]);\n+                            resolve_error(\n+                                self,\n+                                path.span,\n+                                ResolutionError::DoesNotNameAStruct(\n+                                    &*path_names_to_string(path, 0))\n+                            );\n                         }\n                     }\n                     visit::walk_path(self, path);\n@@ -2634,7 +2911,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Success((target, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in \\\n                          finding {} at {:?}\",\n-                        token::get_name(name),\n+                        name,\n                         target.bindings.value_def.borrow());\n                 match *target.bindings.value_def.borrow() {\n                     None => {\n@@ -2653,10 +2930,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 return FoundConst(def, LastMod(AllPublic));\n                             }\n                             DefStatic(..) => {\n-                                self.resolve_error(span,\n-                                                   \"static variables cannot be \\\n-                                                    referenced in a pattern, \\\n-                                                    use a `const` instead\");\n+                                resolve_error(self,\n+                                              span,\n+                                              ResolutionError::StaticVariableReference);\n                                 return BareIdentifierPatternUnresolved;\n                             }\n                             _ => {\n@@ -2673,14 +2949,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Failed(err) => {\n                 match err {\n                     Some((span, msg)) => {\n-                        self.resolve_error(span, &format!(\"failed to resolve: {}\",\n-                                                         msg));\n+                        resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n                     }\n                     None => ()\n                 }\n \n                 debug!(\"(resolve bare identifier pattern) failed to find {}\",\n-                        token::get_name(name));\n+                        name);\n                 return BareIdentifierPatternUnresolved;\n             }\n         }\n@@ -2903,8 +3178,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                 msg));\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n                 return None;\n             }\n             Indeterminate => panic!(\"indeterminate unexpected\"),\n@@ -2963,8 +3237,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                 msg));\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n                 return None;\n             }\n \n@@ -3038,13 +3311,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // found a module instead. Modules don't have defs.\n                         debug!(\"(resolving item path by identifier in lexical \\\n                                  scope) failed to resolve {} after success...\",\n-                                 token::get_name(name));\n+                                 name);\n                         return None;\n                     }\n                     Some(def) => {\n                         debug!(\"(resolving item path in lexical scope) \\\n                                 resolved `{}` to item\",\n-                               token::get_name(name));\n+                               name);\n                         // This lookup is \"all public\" because it only searched\n                         // for one identifier in the current module (couldn't\n                         // have passed through reexports or anything like that.\n@@ -3057,10 +3330,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n             Failed(err) => {\n                 debug!(\"(resolving item path by identifier in lexical scope) \\\n-                         failed to resolve {}\", token::get_name(name));\n+                         failed to resolve {}\", name);\n \n                 if let Some((span, msg)) = err {\n-                    self.resolve_error(span, &format!(\"failed to resolve. {}\", msg))\n+                    resolve_error(self, span, ResolutionError::FailedToResolve(&*msg))\n                 }\n \n                 return None;\n@@ -3077,12 +3350,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         rs\n     }\n \n-    fn resolve_error(&self, span: Span, s: &str) {\n-        if self.emit_errors {\n-            self.session.span_err(span, s);\n-        }\n-    }\n-\n     fn find_fallback_in_self_type(&mut self, name: Name) -> FallbackSuggestion {\n         fn extract_path_and_node_id(t: &Ty, allow: FallbackChecks)\n                                                     -> Option<(Path, NodeId, FallbackChecks)> {\n@@ -3268,11 +3535,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // Check if struct variant\n                     if let DefVariant(_, _, true) = path_res.base_def {\n                         let path_name = path_names_to_string(path, 0);\n-                        self.resolve_error(expr.span,\n-                                &format!(\"`{}` is a struct variant name, but \\\n-                                          this expression \\\n-                                          uses it like a function name\",\n-                                         path_name));\n+\n+                        resolve_error(self,\n+                                      expr.span,\n+                                      ResolutionError::StructVariantUsedAsFunction(&*path_name));\n \n                         let msg = format!(\"did you mean to write: \\\n                                            `{} {{ /* fields */ }}`?\",\n@@ -3309,11 +3575,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     match type_res.map(|r| r.base_def) {\n                         Some(DefTy(struct_id, _))\n                             if self.structs.contains_key(&struct_id) => {\n-                                self.resolve_error(expr.span,\n-                                    &format!(\"`{}` is a structure name, but \\\n-                                                this expression \\\n-                                                uses it like a function name\",\n-                                                path_name));\n+                                resolve_error(\n+                                    self,\n+                                    expr.span,\n+                                    ResolutionError::StructVariantUsedAsFunction(\n+                                        &*path_name)\n+                                );\n \n                                 let msg = format!(\"did you mean to write: \\\n                                                      `{} {{ /* fields */ }}`?\",\n@@ -3340,11 +3607,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                             if method_scope &&\n                                &token::get_name(special_names::self_)[..] == path_name {\n-                                    self.resolve_error(\n-                                        expr.span,\n-                                        \"`self` is not available \\\n-                                         in a static method. Maybe a \\\n-                                         `self` argument is missing?\");\n+                                resolve_error(\n+                                    self,\n+                                    expr.span,\n+                                    ResolutionError::SelfNotAvailableInStaticMethod\n+                                );\n                             } else {\n                                 let last_name = path.segments.last().unwrap().identifier.name;\n                                 let mut msg = match self.find_fallback_in_self_type(last_name) {\n@@ -3368,10 +3635,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     msg = format!(\". Did you mean {}?\", msg)\n                                 }\n \n-                                self.resolve_error(\n-                                    expr.span,\n-                                    &format!(\"unresolved name `{}`{}\",\n-                                             path_name, msg));\n+                                resolve_error(self,\n+                                              expr.span,\n+                                              ResolutionError::UnresolvedName(&*path_name,\n+                                                                               &*msg));\n                             }\n                         }\n                     }\n@@ -3388,9 +3655,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some(definition) => self.record_def(expr.id, definition),\n                     None => {\n                         debug!(\"(resolving expression) didn't find struct def\",);\n-                        let msg = format!(\"`{}` does not name a structure\",\n-                                          path_names_to_string(path, 0));\n-                        self.resolve_error(path.span, &msg[..]);\n+\n+                        resolve_error(self,\n+                                      path.span,\n+                                      ResolutionError::DoesNotNameAStruct(\n+                                                                &*path_names_to_string(path, 0))\n+                                     );\n                     }\n                 }\n \n@@ -3415,10 +3685,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let renamed = mtwt::resolve(label);\n                 match self.search_label(renamed) {\n                     None => {\n-                        self.resolve_error(\n-                            expr.span,\n-                            &format!(\"use of undeclared label `{}`\",\n-                                    token::get_ident(label)))\n+                        resolve_error(self,\n+                                      expr.span,\n+                                      ResolutionError::UndeclaredLabel(&*token::get_ident(label)))\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n@@ -3467,15 +3736,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn get_traits_containing_item(&mut self, name: Name) -> Vec<DefId> {\n         debug!(\"(getting traits containing item) looking for '{}'\",\n-               token::get_name(name));\n+               name);\n \n         fn add_trait_info(found_traits: &mut Vec<DefId>,\n                           trait_def_id: DefId,\n                           name: Name) {\n             debug!(\"(adding trait info) found trait {}:{} for method '{}'\",\n                 trait_def_id.krate,\n                 trait_def_id.node,\n-                token::get_name(name));\n+                name);\n             found_traits.push(trait_def_id);\n         }\n \n@@ -3564,10 +3833,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match pat_binding_mode {\n             BindByValue(_) => {}\n             BindByRef(..) => {\n-                self.resolve_error(pat.span,\n-                                   &format!(\"cannot use `ref` binding mode \\\n-                                            with {}\",\n-                                           descr));\n+                resolve_error(self,\n+                              pat.span,\n+                              ResolutionError::CannotUseRefBindingModeWith(descr));\n             }\n         }\n     }\n@@ -3586,7 +3854,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         debug!(\"Children:\");\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n         for (&name, _) in module_.children.borrow().iter() {\n-            debug!(\"* {}\", token::get_name(name));\n+            debug!(\"* {}\", name);\n         }\n \n         debug!(\"Import resolutions:\");\n@@ -3610,7 +3878,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n \n-            debug!(\"* {}:{}{}\", token::get_name(name), value_repr, type_repr);\n+            debug!(\"* {}:{}{}\", name, value_repr, type_repr);\n         }\n     }\n }"}, {"sha": "e797da7b8f64bf299a85d664e3e494e9687335d3", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1da1a46d563135233dec770abbe67fccc70bd434/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1da1a46d563135233dec770abbe67fccc70bd434/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=1da1a46d563135233dec770abbe67fccc70bd434", "patch": "@@ -22,6 +22,7 @@ use ResolveResult;\n use Resolver;\n use UseLexicalScopeFlag;\n use {names_to_string, module_to_string};\n+use {resolve_error, ResolutionError};\n \n use build_reduced_graph;\n \n@@ -272,12 +273,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         Some((span, msg)) => (span, format!(\". {}\", msg)),\n                         None => (import_directive.span, String::new())\n                     };\n-                    let msg = format!(\"unresolved import `{}`{}\",\n-                                      import_path_to_string(\n-                                          &import_directive.module_path,\n-                                          import_directive.subclass),\n-                                      help);\n-                    self.resolver.resolve_error(span, &msg[..]);\n+                    resolve_error(self.resolver,\n+                                    span,\n+                                    ResolutionError::UnresolvedImport(\n+                                                Some((&*import_path_to_string(\n+                                                        &import_directive.module_path,\n+                                                        import_directive.subclass),\n+                                                      Some(&*help))))\n+                                   );\n                 }\n                 ResolveResult::Indeterminate => break, // Bail out. We'll come around next time.\n                 ResolveResult::Success(()) => () // Good. Continue.\n@@ -394,9 +397,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                              -> ResolveResult<()> {\n         debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n                 `{}` id {}, last private {:?}\",\n-               token::get_name(target),\n+               target,\n                module_to_string(&*target_module),\n-               token::get_name(source),\n+               source,\n                module_to_string(module_),\n                directive.id,\n                lp);\n@@ -431,7 +434,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     value_result = BoundResult(target_module.clone(),\n                                                (*child_name_bindings).clone());\n                     if directive.is_public && !child_name_bindings.is_public(ValueNS) {\n-                        let msg = format!(\"`{}` is private\", token::get_name(source));\n+                        let msg = format!(\"`{}` is private\", source);\n                         span_err!(self.resolver.session, directive.span, E0364, \"{}\", &msg);\n                         pub_err = true;\n                     }\n@@ -441,7 +444,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     type_result = BoundResult(target_module.clone(),\n                                               (*child_name_bindings).clone());\n                     if !pub_err && directive.is_public && !child_name_bindings.is_public(TypeNS) {\n-                        let msg = format!(\"`{}` is private\", token::get_name(source));\n+                        let msg = format!(\"`{}` is private\", source);\n                         span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg);\n                     }\n                 }\n@@ -655,7 +658,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         if value_result.is_unbound() && type_result.is_unbound() {\n             let msg = format!(\"There is no `{}` in `{}`\",\n-                              token::get_name(source),\n+                              source,\n                               module_to_string(&target_module));\n             return ResolveResult::Failed(Some((directive.span, msg)));\n         }\n@@ -736,7 +739,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         for (ident, target_import_resolution) in import_resolutions.iter() {\n             debug!(\"(resolving glob import) writing module resolution \\\n                     {} into `{}`\",\n-                   token::get_name(*ident),\n+                   *ident,\n                    module_to_string(module_));\n \n             if !target_import_resolution.is_public {\n@@ -842,7 +845,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n                to `{}`\",\n-               &token::get_name(name),\n+               name,\n                module_to_string(&*containing_module),\n                module_to_string(module_));\n \n@@ -861,7 +864,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         let msg = format!(\"a {} named `{}` has already been imported \\\n                                            in this module\",\n                                           namespace_name,\n-                                          &token::get_name(name));\n+                                          name);\n                         span_err!(self.resolver.session, import_directive.span, E0251, \"{}\", msg);\n                     } else {\n                         let target = Target::new(containing_module.clone(),\n@@ -894,7 +897,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                     namespace: Namespace) {\n         let target = import_resolution.target_for_namespace(namespace);\n         debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n-               &token::get_name(name),\n+               name,\n                target.is_some());\n \n         match target {\n@@ -918,13 +921,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 span_err!(self.resolver.session, import_span, E0252,\n                           \"a {} named `{}` has already been imported \\\n                            in this module\", ns_word,\n-                                  &token::get_name(name));\n+                                  name);\n                 let use_id = import_resolution.id(namespace);\n                 let item = self.resolver.ast_map.expect_item(use_id);\n                 // item is syntax::ast::Item;\n                 span_note!(self.resolver.session, item.span,\n                             \"previous import of `{}` here\",\n-                            token::get_name(name));\n+                            name);\n             }\n             Some(_) | None => {}\n         }\n@@ -938,7 +941,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                        namespace: Namespace) {\n         if !name_bindings.defined_in_namespace_with(namespace, DefModifiers::IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n-                              token::get_name(name));\n+                              name);\n             span_err!(self.resolver.session, import_span, E0253, \"{}\", &msg[..]);\n         }\n     }\n@@ -959,7 +962,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     let msg = format!(\"import `{0}` conflicts with imported \\\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n-                                      &token::get_name(name));\n+                                      name);\n                     span_err!(self.resolver.session, import_span, E0254, \"{}\", &msg[..]);\n                 }\n                 Some(_) | None => {}\n@@ -981,7 +984,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 if let Some(ref value) = *name_bindings.value_def.borrow() {\n                     span_err!(self.resolver.session, import_span, E0255,\n                               \"import `{}` conflicts with value in this module\",\n-                              &token::get_name(name));\n+                              name);\n                     if let Some(span) = value.value_span {\n                         self.resolver.session.span_note(span, \"conflicting value here\");\n                     }\n@@ -1004,7 +1007,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     };\n                     span_err!(self.resolver.session, import_span, E0256,\n                               \"import `{}` conflicts with {}\",\n-                              &token::get_name(name), what);\n+                              name, what);\n                     if let Some(span) = ty.type_span {\n                         self.resolver.session.span_note(span, note);\n                     }"}]}