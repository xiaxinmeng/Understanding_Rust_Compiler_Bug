{"sha": "d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxNjEyOWJjYTVmNWM5ZjNhNWJiNjZkM2Y3NTdlYzc1ZWQwZjljN2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-17T03:05:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-17T03:05:56Z"}, "message": "Auto merge of #28349 - nrc:ast-lints, r=manishearth\n\nr? @nikomatsakis, f? @Manishearth", "tree": {"sha": "ddb9cb7a509d78339ac53e37486ecd7b5f49359a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddb9cb7a509d78339ac53e37486ecd7b5f49359a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "html_url": "https://github.com/rust-lang/rust/commit/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "151ffa48c17c10c420963d9db561ee9014e94ded", "url": "https://api.github.com/repos/rust-lang/rust/commits/151ffa48c17c10c420963d9db561ee9014e94ded", "html_url": "https://github.com/rust-lang/rust/commit/151ffa48c17c10c420963d9db561ee9014e94ded"}, {"sha": "ed61a64a957d5c13cc524f9d516ac3626861717f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed61a64a957d5c13cc524f9d516ac3626861717f", "html_url": "https://github.com/rust-lang/rust/commit/ed61a64a957d5c13cc524f9d516ac3626861717f"}], "stats": {"total": 1226, "additions": 792, "deletions": 434}, "files": [{"sha": "d9b05d804000ae3c9a4ef1f71779d05195e80359", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -14,7 +14,7 @@\n //! compiler code, rather than using their own custom pass. Those\n //! lints are all available in `rustc_lint::builtin`.\n \n-use lint::{LintPass, LintArray};\n+use lint::{LintPass, LateLintPass, LintArray};\n \n declare_lint! {\n     pub UNUSED_IMPORTS,\n@@ -138,3 +138,5 @@ impl LintPass for HardwiredLints {\n         )\n     }\n }\n+\n+impl LateLintPass for HardwiredLints {}"}, {"sha": "9a736747d5291ea00e5c92e9da328810aaf0bd6b", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 440, "deletions": 121, "changes": 561, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -28,23 +28,24 @@ use self::TargetLint::*;\n use middle::privacy::ExportedItems;\n use middle::ty::{self, Ty};\n use session::{early_error, Session};\n-use lint::{Level, LevelSource, Lint, LintId, LintArray, LintPass, LintPassObject};\n+use lint::{Level, LevelSource, Lint, LintId, LintArray, LintPass};\n+use lint::{EarlyLintPass, EarlyLintPassObject, LateLintPass, LateLintPassObject};\n use lint::{Default, CommandLine, Node, Allow, Warn, Deny, Forbid};\n use lint::builtin;\n use util::nodemap::FnvHashMap;\n \n use std::cell::RefCell;\n use std::cmp;\n use std::mem;\n-use syntax::ast_util::IdVisitingOperation;\n+use syntax::ast_util::{self, IdVisitingOperation};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use syntax::ast;\n use rustc_front::hir;\n-use rustc_front::visit::{self, Visitor, FnKind};\n use rustc_front::util;\n-use syntax::visit::Visitor as SyntaxVisitor;\n+use rustc_front::visit as hir_visit;\n+use syntax::visit as ast_visit;\n use syntax::diagnostic;\n \n /// Information about the registered lints.\n@@ -59,7 +60,8 @@ pub struct LintStore {\n     /// Trait objects for each lint pass.\n     /// This is only `None` while iterating over the objects. See the definition\n     /// of run_lints.\n-    passes: Option<Vec<LintPassObject>>,\n+    early_passes: Option<Vec<EarlyLintPassObject>>,\n+    late_passes: Option<Vec<LateLintPassObject>>,\n \n     /// Lints indexed by name.\n     by_name: FnvHashMap<String, TargetLint>,\n@@ -115,7 +117,8 @@ impl LintStore {\n     pub fn new() -> LintStore {\n         LintStore {\n             lints: vec!(),\n-            passes: Some(vec!()),\n+            early_passes: Some(vec!()),\n+            late_passes: Some(vec!()),\n             by_name: FnvHashMap(),\n             levels: FnvHashMap(),\n             lint_groups: FnvHashMap(),\n@@ -133,8 +136,27 @@ impl LintStore {\n                                               v.1)).collect()\n     }\n \n-    pub fn register_pass(&mut self, sess: Option<&Session>,\n-                         from_plugin: bool, pass: LintPassObject) {\n+    pub fn register_early_pass(&mut self,\n+                               sess: Option<&Session>,\n+                               from_plugin: bool,\n+                               pass: EarlyLintPassObject) {\n+        self.push_pass(sess, from_plugin, &pass);\n+        self.early_passes.as_mut().unwrap().push(pass);\n+    }\n+\n+    pub fn register_late_pass(&mut self,\n+                              sess: Option<&Session>,\n+                              from_plugin: bool,\n+                              pass: LateLintPassObject) {\n+        self.push_pass(sess, from_plugin, &pass);\n+        self.late_passes.as_mut().unwrap().push(pass);\n+    }\n+\n+    // Helper method for register_early/late_pass\n+    fn push_pass<P: LintPass + ?Sized + 'static>(&mut self,\n+                                        sess: Option<&Session>,\n+                                        from_plugin: bool,\n+                                        pass: &Box<P>) {\n         for &lint in pass.get_lints() {\n             self.lints.push((*lint, from_plugin));\n \n@@ -156,7 +178,6 @@ impl LintStore {\n                 self.levels.insert(id, (lint.default_level, Default));\n             }\n         }\n-        self.passes.as_mut().unwrap().push(pass);\n     }\n \n     pub fn register_group(&mut self, sess: Option<&Session>,\n@@ -248,8 +269,8 @@ impl LintStore {\n     }\n }\n \n-/// Context for lint checking.\n-pub struct Context<'a, 'tcx: 'a> {\n+/// Context for lint checking after type checking.\n+pub struct LateContext<'a, 'tcx: 'a> {\n     /// Type context we're checking in.\n     pub tcx: &'a ty::ctxt<'tcx>,\n \n@@ -272,15 +293,33 @@ pub struct Context<'a, 'tcx: 'a> {\n     node_levels: RefCell<FnvHashMap<(ast::NodeId, LintId), LevelSource>>,\n }\n \n+/// Context for lint checking of the AST, after expansion, before lowering to\n+/// HIR.\n+pub struct EarlyContext<'a> {\n+    /// Type context we're checking in.\n+    pub sess: &'a Session,\n+\n+    /// The crate being checked.\n+    pub krate: &'a ast::Crate,\n+\n+    /// The store of registered lints.\n+    lints: LintStore,\n+\n+    /// When recursing into an attributed node of the ast which modifies lint\n+    /// levels, this stack keeps track of the previous lint levels of whatever\n+    /// was modified.\n+    level_stack: Vec<(LintId, LevelSource)>,\n+}\n+\n /// Convenience macro for calling a `LintPass` method on every pass in the context.\n-macro_rules! run_lints { ($cx:expr, $f:ident, $($args:expr),*) => ({\n+macro_rules! run_lints { ($cx:expr, $f:ident, $ps:ident, $($args:expr),*) => ({\n     // Move the vector of passes out of `$cx` so that we can\n     // iterate over it mutably while passing `$cx` to the methods.\n-    let mut passes = $cx.lints.passes.take().unwrap();\n+    let mut passes = $cx.mut_lints().$ps.take().unwrap();\n     for obj in &mut passes {\n         obj.$f($cx, $($args),*);\n     }\n-    $cx.lints.passes = Some(passes);\n+    $cx.mut_lints().$ps = Some(passes);\n }) }\n \n /// Parse the lint attributes into a vector, with `Err`s for malformed lint\n@@ -364,65 +403,50 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n     }\n }\n \n-impl<'a, 'tcx> Context<'a, 'tcx> {\n-    fn new(tcx: &'a ty::ctxt<'tcx>,\n-           krate: &'a hir::Crate,\n-           exported_items: &'a ExportedItems) -> Context<'a, 'tcx> {\n-        // We want to own the lint store, so move it out of the session.\n-        let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(),\n-                                      LintStore::new());\n-\n-        Context {\n-            tcx: tcx,\n-            krate: krate,\n-            exported_items: exported_items,\n-            lints: lint_store,\n-            level_stack: vec![],\n-            node_levels: RefCell::new(FnvHashMap()),\n-        }\n-    }\n-\n-    /// Get the overall compiler `Session` object.\n-    pub fn sess(&'a self) -> &'a Session {\n-        &self.tcx.sess\n-    }\n+pub trait LintContext: Sized {\n+    fn sess(&self) -> &Session;\n+    fn lints(&self) -> &LintStore;\n+    fn mut_lints(&mut self) -> &mut LintStore;\n+    fn level_stack(&mut self) -> &mut Vec<(LintId, LevelSource)>;\n+    fn enter_attrs(&mut self, attrs: &[ast::Attribute]);\n+    fn exit_attrs(&mut self, attrs: &[ast::Attribute]);\n \n     /// Get the level of `lint` at the current position of the lint\n     /// traversal.\n-    pub fn current_level(&self, lint: &'static Lint) -> Level {\n-        self.lints.levels.get(&LintId::of(lint)).map_or(Allow, |&(lvl, _)| lvl)\n+    fn current_level(&self, lint: &'static Lint) -> Level {\n+        self.lints().levels.get(&LintId::of(lint)).map_or(Allow, |&(lvl, _)| lvl)\n     }\n \n     fn lookup_and_emit(&self, lint: &'static Lint, span: Option<Span>, msg: &str) {\n-        let (level, src) = match self.lints.levels.get(&LintId::of(lint)) {\n+        let (level, src) = match self.lints().levels.get(&LintId::of(lint)) {\n             None => return,\n             Some(&(Warn, src)) => {\n                 let lint_id = LintId::of(builtin::WARNINGS);\n-                (self.lints.get_level_source(lint_id).0, src)\n+                (self.lints().get_level_source(lint_id).0, src)\n             }\n             Some(&pair) => pair,\n         };\n \n-        raw_emit_lint(&self.tcx.sess, lint, (level, src), span, msg);\n-    }\n-\n-    /// Emit a lint at the appropriate level, with no associated span.\n-    pub fn lint(&self, lint: &'static Lint, msg: &str) {\n-        self.lookup_and_emit(lint, None, msg);\n+        raw_emit_lint(&self.sess(), lint, (level, src), span, msg);\n     }\n \n     /// Emit a lint at the appropriate level, for a particular span.\n-    pub fn span_lint(&self, lint: &'static Lint, span: Span, msg: &str) {\n+    fn span_lint(&self, lint: &'static Lint, span: Span, msg: &str) {\n         self.lookup_and_emit(lint, Some(span), msg);\n     }\n \n+    /// Emit a lint at the appropriate level, with no associated span.\n+    fn lint(&self, lint: &'static Lint, msg: &str) {\n+        self.lookup_and_emit(lint, None, msg);\n+    }\n+\n     /// Merge the lints specified by any lint attributes into the\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n     fn with_lint_attrs<F>(&mut self,\n                           attrs: &[ast::Attribute],\n-                          f: F) where\n-        F: FnOnce(&mut Context),\n+                          f: F)\n+        where F: FnOnce(&mut Self),\n     {\n         // Parse all of the lint attributes, and then add them all to the\n         // current dictionary of lint information. Along the way, keep a history\n@@ -433,15 +457,15 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n         for result in gather_attrs(attrs) {\n             let v = match result {\n                 Err(span) => {\n-                    span_err!(self.tcx.sess, span, E0452,\n+                    span_err!(self.sess(), span, E0452,\n                               \"malformed lint attribute\");\n                     continue;\n                 }\n                 Ok((lint_name, level, span)) => {\n-                    match self.lints.find_lint(&lint_name, &self.tcx.sess, Some(span)) {\n+                    match self.lints().find_lint(&lint_name, &self.sess(), Some(span)) {\n                         Ok(lint_id) => vec![(lint_id, level, span)],\n                         Err(FindLintError::NotFound) => {\n-                            match self.lints.lint_groups.get(&lint_name[..]) {\n+                            match self.lints().lint_groups.get(&lint_name[..]) {\n                                 Some(&(ref v, _)) => v.iter()\n                                                       .map(|lint_id: &LintId|\n                                                            (*lint_id, level, span))\n@@ -460,35 +484,82 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n             };\n \n             for (lint_id, level, span) in v {\n-                let now = self.lints.get_level_source(lint_id).0;\n+                let now = self.lints().get_level_source(lint_id).0;\n                 if now == Forbid && level != Forbid {\n                     let lint_name = lint_id.as_str();\n-                    span_err!(self.tcx.sess, span, E0453,\n+                    span_err!(self.sess(), span, E0453,\n                               \"{}({}) overruled by outer forbid({})\",\n                               level.as_str(), lint_name,\n                               lint_name);\n                 } else if now != level {\n-                    let src = self.lints.get_level_source(lint_id).1;\n-                    self.level_stack.push((lint_id, (now, src)));\n+                    let src = self.lints().get_level_source(lint_id).1;\n+                    self.level_stack().push((lint_id, (now, src)));\n                     pushed += 1;\n-                    self.lints.set_level(lint_id, (level, Node(span)));\n+                    self.mut_lints().set_level(lint_id, (level, Node(span)));\n                 }\n             }\n         }\n \n-        run_lints!(self, enter_lint_attrs, attrs);\n+        self.enter_attrs(attrs);\n         f(self);\n-        run_lints!(self, exit_lint_attrs, attrs);\n+        self.exit_attrs(attrs);\n \n         // rollback\n         for _ in 0..pushed {\n-            let (lint, lvlsrc) = self.level_stack.pop().unwrap();\n-            self.lints.set_level(lint, lvlsrc);\n+            let (lint, lvlsrc) = self.level_stack().pop().unwrap();\n+            self.mut_lints().set_level(lint, lvlsrc);\n+        }\n+    }\n+}\n+\n+\n+impl<'a> EarlyContext<'a> {\n+    fn new(sess: &'a Session,\n+           krate: &'a ast::Crate) -> EarlyContext<'a> {\n+        // We want to own the lint store, so move it out of the session. Remember\n+        // to put it back later...\n+        let lint_store = mem::replace(&mut *sess.lint_store.borrow_mut(),\n+                                      LintStore::new());\n+        EarlyContext {\n+            sess: sess,\n+            krate: krate,\n+            lints: lint_store,\n+            level_stack: vec![],\n+        }\n+    }\n+\n+    fn visit_ids<F>(&mut self, f: F)\n+        where F: FnOnce(&mut ast_util::IdVisitor<EarlyContext>)\n+    {\n+        let mut v = ast_util::IdVisitor {\n+            operation: self,\n+            pass_through_items: false,\n+            visited_outermost: false,\n+        };\n+        f(&mut v);\n+    }\n+}\n+\n+impl<'a, 'tcx> LateContext<'a, 'tcx> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>,\n+           krate: &'a hir::Crate,\n+           exported_items: &'a ExportedItems) -> LateContext<'a, 'tcx> {\n+        // We want to own the lint store, so move it out of the session.\n+        let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(),\n+                                      LintStore::new());\n+\n+        LateContext {\n+            tcx: tcx,\n+            krate: krate,\n+            exported_items: exported_items,\n+            lints: lint_store,\n+            level_stack: vec![],\n+            node_levels: RefCell::new(FnvHashMap()),\n         }\n     }\n \n-    fn visit_ids<F>(&mut self, f: F) where\n-        F: FnOnce(&mut util::IdVisitor<Context>)\n+    fn visit_ids<F>(&mut self, f: F)\n+        where F: FnOnce(&mut util::IdVisitor<LateContext>)\n     {\n         let mut v = util::IdVisitor {\n             operation: self,\n@@ -499,158 +570,372 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n+impl<'a, 'tcx> LintContext for LateContext<'a, 'tcx> {\n+    /// Get the overall compiler `Session` object.\n+    fn sess(&self) -> &Session {\n+        &self.tcx.sess\n+    }\n+\n+    fn lints(&self) -> &LintStore {\n+        &self.lints\n+    }\n+\n+    fn mut_lints(&mut self) -> &mut LintStore {\n+        &mut self.lints\n+    }\n+\n+    fn level_stack(&mut self) -> &mut Vec<(LintId, LevelSource)> {\n+        &mut self.level_stack\n+    }\n+\n+    fn enter_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        run_lints!(self, enter_lint_attrs, late_passes, attrs);\n+    }\n+\n+    fn exit_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        run_lints!(self, exit_lint_attrs, late_passes, attrs);\n+    }\n+}\n+\n+impl<'a> LintContext for EarlyContext<'a> {\n+    /// Get the overall compiler `Session` object.\n+    fn sess(&self) -> &Session {\n+        &self.sess\n+    }\n+\n+    fn lints(&self) -> &LintStore {\n+        &self.lints\n+    }\n+\n+    fn mut_lints(&mut self) -> &mut LintStore {\n+        &mut self.lints\n+    }\n+\n+    fn level_stack(&mut self) -> &mut Vec<(LintId, LevelSource)> {\n+        &mut self.level_stack\n+    }\n+\n+    fn enter_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        run_lints!(self, enter_lint_attrs, early_passes, attrs);\n+    }\n+\n+    fn exit_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        run_lints!(self, exit_lint_attrs, early_passes, attrs);\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     fn visit_item(&mut self, it: &hir::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n-            run_lints!(cx, check_item, it);\n+            run_lints!(cx, check_item, late_passes, it);\n             cx.visit_ids(|v| v.visit_item(it));\n-            visit::walk_item(cx, it);\n+            hir_visit::walk_item(cx, it);\n         })\n     }\n \n     fn visit_foreign_item(&mut self, it: &hir::ForeignItem) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n-            run_lints!(cx, check_foreign_item, it);\n-            visit::walk_foreign_item(cx, it);\n+            run_lints!(cx, check_foreign_item, late_passes, it);\n+            hir_visit::walk_foreign_item(cx, it);\n         })\n     }\n \n     fn visit_pat(&mut self, p: &hir::Pat) {\n-        run_lints!(self, check_pat, p);\n-        visit::walk_pat(self, p);\n+        run_lints!(self, check_pat, late_passes, p);\n+        hir_visit::walk_pat(self, p);\n     }\n \n     fn visit_expr(&mut self, e: &hir::Expr) {\n-        run_lints!(self, check_expr, e);\n-        visit::walk_expr(self, e);\n+        run_lints!(self, check_expr, late_passes, e);\n+        hir_visit::walk_expr(self, e);\n     }\n \n     fn visit_stmt(&mut self, s: &hir::Stmt) {\n-        run_lints!(self, check_stmt, s);\n-        visit::walk_stmt(self, s);\n+        run_lints!(self, check_stmt, late_passes, s);\n+        hir_visit::walk_stmt(self, s);\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, decl: &'v hir::FnDecl,\n+    fn visit_fn(&mut self, fk: hir_visit::FnKind<'v>, decl: &'v hir::FnDecl,\n                 body: &'v hir::Block, span: Span, id: ast::NodeId) {\n-        run_lints!(self, check_fn, fk, decl, body, span, id);\n-        visit::walk_fn(self, fk, decl, body, span);\n+        run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n+        hir_visit::walk_fn(self, fk, decl, body, span);\n     }\n \n     fn visit_struct_def(&mut self,\n                         s: &hir::StructDef,\n                         ident: ast::Ident,\n                         g: &hir::Generics,\n                         id: ast::NodeId) {\n-        run_lints!(self, check_struct_def, s, ident, g, id);\n-        visit::walk_struct_def(self, s);\n-        run_lints!(self, check_struct_def_post, s, ident, g, id);\n+        run_lints!(self, check_struct_def, late_passes, s, ident, g, id);\n+        hir_visit::walk_struct_def(self, s);\n+        run_lints!(self, check_struct_def_post, late_passes, s, ident, g, id);\n     }\n \n     fn visit_struct_field(&mut self, s: &hir::StructField) {\n         self.with_lint_attrs(&s.node.attrs, |cx| {\n-            run_lints!(cx, check_struct_field, s);\n-            visit::walk_struct_field(cx, s);\n+            run_lints!(cx, check_struct_field, late_passes, s);\n+            hir_visit::walk_struct_field(cx, s);\n         })\n     }\n \n     fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics) {\n         self.with_lint_attrs(&v.node.attrs, |cx| {\n-            run_lints!(cx, check_variant, v, g);\n-            visit::walk_variant(cx, v, g);\n-            run_lints!(cx, check_variant_post, v, g);\n+            run_lints!(cx, check_variant, late_passes, v, g);\n+            hir_visit::walk_variant(cx, v, g);\n+            run_lints!(cx, check_variant_post, late_passes, v, g);\n         })\n     }\n \n     fn visit_ty(&mut self, t: &hir::Ty) {\n-        run_lints!(self, check_ty, t);\n-        visit::walk_ty(self, t);\n+        run_lints!(self, check_ty, late_passes, t);\n+        hir_visit::walk_ty(self, t);\n     }\n \n     fn visit_ident(&mut self, sp: Span, id: ast::Ident) {\n-        run_lints!(self, check_ident, sp, id);\n+        run_lints!(self, check_ident, late_passes, sp, id);\n     }\n \n     fn visit_mod(&mut self, m: &hir::Mod, s: Span, n: ast::NodeId) {\n-        run_lints!(self, check_mod, m, s, n);\n-        visit::walk_mod(self, m);\n+        run_lints!(self, check_mod, late_passes, m, s, n);\n+        hir_visit::walk_mod(self, m);\n     }\n \n     fn visit_local(&mut self, l: &hir::Local) {\n-        run_lints!(self, check_local, l);\n-        visit::walk_local(self, l);\n+        run_lints!(self, check_local, late_passes, l);\n+        hir_visit::walk_local(self, l);\n     }\n \n     fn visit_block(&mut self, b: &hir::Block) {\n-        run_lints!(self, check_block, b);\n-        visit::walk_block(self, b);\n+        run_lints!(self, check_block, late_passes, b);\n+        hir_visit::walk_block(self, b);\n     }\n \n     fn visit_arm(&mut self, a: &hir::Arm) {\n-        run_lints!(self, check_arm, a);\n-        visit::walk_arm(self, a);\n+        run_lints!(self, check_arm, late_passes, a);\n+        hir_visit::walk_arm(self, a);\n     }\n \n     fn visit_decl(&mut self, d: &hir::Decl) {\n-        run_lints!(self, check_decl, d);\n-        visit::walk_decl(self, d);\n+        run_lints!(self, check_decl, late_passes, d);\n+        hir_visit::walk_decl(self, d);\n     }\n \n     fn visit_expr_post(&mut self, e: &hir::Expr) {\n-        run_lints!(self, check_expr_post, e);\n+        run_lints!(self, check_expr_post, late_passes, e);\n     }\n \n     fn visit_generics(&mut self, g: &hir::Generics) {\n-        run_lints!(self, check_generics, g);\n-        visit::walk_generics(self, g);\n+        run_lints!(self, check_generics, late_passes, g);\n+        hir_visit::walk_generics(self, g);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n         self.with_lint_attrs(&trait_item.attrs, |cx| {\n-            run_lints!(cx, check_trait_item, trait_item);\n+            run_lints!(cx, check_trait_item, late_passes, trait_item);\n             cx.visit_ids(|v| v.visit_trait_item(trait_item));\n-            visit::walk_trait_item(cx, trait_item);\n+            hir_visit::walk_trait_item(cx, trait_item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n         self.with_lint_attrs(&impl_item.attrs, |cx| {\n-            run_lints!(cx, check_impl_item, impl_item);\n+            run_lints!(cx, check_impl_item, late_passes, impl_item);\n             cx.visit_ids(|v| v.visit_impl_item(impl_item));\n-            visit::walk_impl_item(cx, impl_item);\n+            hir_visit::walk_impl_item(cx, impl_item);\n         });\n     }\n \n     fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<hir::Lifetime>) {\n-        run_lints!(self, check_opt_lifetime_ref, sp, lt);\n+        run_lints!(self, check_opt_lifetime_ref, late_passes, sp, lt);\n     }\n \n     fn visit_lifetime_ref(&mut self, lt: &hir::Lifetime) {\n-        run_lints!(self, check_lifetime_ref, lt);\n+        run_lints!(self, check_lifetime_ref, late_passes, lt);\n     }\n \n     fn visit_lifetime_def(&mut self, lt: &hir::LifetimeDef) {\n-        run_lints!(self, check_lifetime_def, lt);\n+        run_lints!(self, check_lifetime_def, late_passes, lt);\n     }\n \n     fn visit_explicit_self(&mut self, es: &hir::ExplicitSelf) {\n-        run_lints!(self, check_explicit_self, es);\n-        visit::walk_explicit_self(self, es);\n+        run_lints!(self, check_explicit_self, late_passes, es);\n+        hir_visit::walk_explicit_self(self, es);\n     }\n \n     fn visit_path(&mut self, p: &hir::Path, id: ast::NodeId) {\n-        run_lints!(self, check_path, p, id);\n-        visit::walk_path(self, p);\n+        run_lints!(self, check_path, late_passes, p, id);\n+        hir_visit::walk_path(self, p);\n+    }\n+\n+    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n+        run_lints!(self, check_attribute, late_passes, attr);\n+    }\n+}\n+\n+impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n+    fn visit_item(&mut self, it: &ast::Item) {\n+        self.with_lint_attrs(&it.attrs, |cx| {\n+            run_lints!(cx, check_item, early_passes, it);\n+            cx.visit_ids(|v| v.visit_item(it));\n+            ast_visit::walk_item(cx, it);\n+        })\n+    }\n+\n+    fn visit_foreign_item(&mut self, it: &ast::ForeignItem) {\n+        self.with_lint_attrs(&it.attrs, |cx| {\n+            run_lints!(cx, check_foreign_item, early_passes, it);\n+            ast_visit::walk_foreign_item(cx, it);\n+        })\n+    }\n+\n+    fn visit_pat(&mut self, p: &ast::Pat) {\n+        run_lints!(self, check_pat, early_passes, p);\n+        ast_visit::walk_pat(self, p);\n+    }\n+\n+    fn visit_expr(&mut self, e: &ast::Expr) {\n+        run_lints!(self, check_expr, early_passes, e);\n+        ast_visit::walk_expr(self, e);\n+    }\n+\n+    fn visit_stmt(&mut self, s: &ast::Stmt) {\n+        run_lints!(self, check_stmt, early_passes, s);\n+        ast_visit::walk_stmt(self, s);\n+    }\n+\n+    fn visit_fn(&mut self, fk: ast_visit::FnKind<'v>, decl: &'v ast::FnDecl,\n+                body: &'v ast::Block, span: Span, id: ast::NodeId) {\n+        run_lints!(self, check_fn, early_passes, fk, decl, body, span, id);\n+        ast_visit::walk_fn(self, fk, decl, body, span);\n+    }\n+\n+    fn visit_struct_def(&mut self,\n+                        s: &ast::StructDef,\n+                        ident: ast::Ident,\n+                        g: &ast::Generics,\n+                        id: ast::NodeId) {\n+        run_lints!(self, check_struct_def, early_passes, s, ident, g, id);\n+        ast_visit::walk_struct_def(self, s);\n+        run_lints!(self, check_struct_def_post, early_passes, s, ident, g, id);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &ast::StructField) {\n+        self.with_lint_attrs(&s.node.attrs, |cx| {\n+            run_lints!(cx, check_struct_field, early_passes, s);\n+            ast_visit::walk_struct_field(cx, s);\n+        })\n+    }\n+\n+    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n+        self.with_lint_attrs(&v.node.attrs, |cx| {\n+            run_lints!(cx, check_variant, early_passes, v, g);\n+            ast_visit::walk_variant(cx, v, g);\n+            run_lints!(cx, check_variant_post, early_passes, v, g);\n+        })\n+    }\n+\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n+        run_lints!(self, check_ty, early_passes, t);\n+        ast_visit::walk_ty(self, t);\n+    }\n+\n+    fn visit_ident(&mut self, sp: Span, id: ast::Ident) {\n+        run_lints!(self, check_ident, early_passes, sp, id);\n+    }\n+\n+    fn visit_mod(&mut self, m: &ast::Mod, s: Span, n: ast::NodeId) {\n+        run_lints!(self, check_mod, early_passes, m, s, n);\n+        ast_visit::walk_mod(self, m);\n+    }\n+\n+    fn visit_local(&mut self, l: &ast::Local) {\n+        run_lints!(self, check_local, early_passes, l);\n+        ast_visit::walk_local(self, l);\n+    }\n+\n+    fn visit_block(&mut self, b: &ast::Block) {\n+        run_lints!(self, check_block, early_passes, b);\n+        ast_visit::walk_block(self, b);\n+    }\n+\n+    fn visit_arm(&mut self, a: &ast::Arm) {\n+        run_lints!(self, check_arm, early_passes, a);\n+        ast_visit::walk_arm(self, a);\n+    }\n+\n+    fn visit_decl(&mut self, d: &ast::Decl) {\n+        run_lints!(self, check_decl, early_passes, d);\n+        ast_visit::walk_decl(self, d);\n+    }\n+\n+    fn visit_expr_post(&mut self, e: &ast::Expr) {\n+        run_lints!(self, check_expr_post, early_passes, e);\n+    }\n+\n+    fn visit_generics(&mut self, g: &ast::Generics) {\n+        run_lints!(self, check_generics, early_passes, g);\n+        ast_visit::walk_generics(self, g);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        self.with_lint_attrs(&trait_item.attrs, |cx| {\n+            run_lints!(cx, check_trait_item, early_passes, trait_item);\n+            cx.visit_ids(|v| v.visit_trait_item(trait_item));\n+            ast_visit::walk_trait_item(cx, trait_item);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n+        self.with_lint_attrs(&impl_item.attrs, |cx| {\n+            run_lints!(cx, check_impl_item, early_passes, impl_item);\n+            cx.visit_ids(|v| v.visit_impl_item(impl_item));\n+            ast_visit::walk_impl_item(cx, impl_item);\n+        });\n+    }\n+\n+    fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<ast::Lifetime>) {\n+        run_lints!(self, check_opt_lifetime_ref, early_passes, sp, lt);\n+    }\n+\n+    fn visit_lifetime_ref(&mut self, lt: &ast::Lifetime) {\n+        run_lints!(self, check_lifetime_ref, early_passes, lt);\n+    }\n+\n+    fn visit_lifetime_def(&mut self, lt: &ast::LifetimeDef) {\n+        run_lints!(self, check_lifetime_def, early_passes, lt);\n+    }\n+\n+    fn visit_explicit_self(&mut self, es: &ast::ExplicitSelf) {\n+        run_lints!(self, check_explicit_self, early_passes, es);\n+        ast_visit::walk_explicit_self(self, es);\n+    }\n+\n+    fn visit_path(&mut self, p: &ast::Path, id: ast::NodeId) {\n+        run_lints!(self, check_path, early_passes, p, id);\n+        ast_visit::walk_path(self, p);\n     }\n \n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n-        run_lints!(self, check_attribute, attr);\n+        run_lints!(self, check_attribute, early_passes, attr);\n     }\n }\n \n // Output any lints that were previously added to the session.\n-impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n+impl<'a, 'tcx> IdVisitingOperation for LateContext<'a, 'tcx> {\n     fn visit_id(&mut self, id: ast::NodeId) {\n-        match self.tcx.sess.lints.borrow_mut().remove(&id) {\n+        match self.sess().lints.borrow_mut().remove(&id) {\n+            None => {}\n+            Some(lints) => {\n+                for (lint_id, span, msg) in lints {\n+                    self.span_lint(lint_id.lint, span, &msg[..])\n+                }\n+            }\n+        }\n+    }\n+}\n+impl<'a> IdVisitingOperation for EarlyContext<'a> {\n+    fn visit_id(&mut self, id: ast::NodeId) {\n+        match self.sess.lints.borrow_mut().remove(&id) {\n             None => {}\n             Some(lints) => {\n                 for (lint_id, span, msg) in lints {\n@@ -661,7 +946,7 @@ impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n     }\n }\n \n-// This lint pass is defined here because it touches parts of the `Context`\n+// This lint pass is defined here because it touches parts of the `LateContext`\n // that we don't want to expose. It records the lint level at certain AST\n // nodes, so that the variant size difference check in trans can call\n // `raw_emit_lint`.\n@@ -672,8 +957,10 @@ impl LintPass for GatherNodeLevels {\n     fn get_lints(&self) -> LintArray {\n         lint_array!()\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+impl LateLintPass for GatherNodeLevels {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemEnum(..) => {\n                 let lint_id = LintId::of(builtin::VARIANT_SIZE_DIFFERENCES);\n@@ -698,21 +985,21 @@ pub fn check_crate(tcx: &ty::ctxt,\n                    krate: &hir::Crate,\n                    exported_items: &ExportedItems) {\n \n-    let mut cx = Context::new(tcx, krate, exported_items);\n+    let mut cx = LateContext::new(tcx, krate, exported_items);\n \n     // Visit the whole crate.\n     cx.with_lint_attrs(&krate.attrs, |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n             v.visited_outermost = true;\n-            visit::walk_crate(v, krate);\n+            hir_visit::walk_crate(v, krate);\n         });\n \n         // since the root module isn't visited as an item (because it isn't an\n         // item), warn for it here.\n-        run_lints!(cx, check_crate, krate);\n+        run_lints!(cx, check_crate, late_passes, krate);\n \n-        visit::walk_crate(cx, krate);\n+        hir_visit::walk_crate(cx, krate);\n     });\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n@@ -727,3 +1014,35 @@ pub fn check_crate(tcx: &ty::ctxt,\n \n     *tcx.node_lint_levels.borrow_mut() = cx.node_levels.into_inner();\n }\n+\n+pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n+    let mut cx = EarlyContext::new(sess, krate);\n+\n+    // Visit the whole crate.\n+    cx.with_lint_attrs(&krate.attrs, |cx| {\n+        cx.visit_id(ast::CRATE_NODE_ID);\n+        cx.visit_ids(|v| {\n+            v.visited_outermost = true;\n+            ast_visit::walk_crate(v, krate);\n+        });\n+\n+        // since the root module isn't visited as an item (because it isn't an\n+        // item), warn for it here.\n+        run_lints!(cx, check_crate, early_passes, krate);\n+\n+        ast_visit::walk_crate(cx, krate);\n+    });\n+\n+    // Put the lint store back in the session.\n+    mem::replace(&mut *sess.lint_store.borrow_mut(), cx.lints);\n+\n+    // If we missed any lints added to the session, then there's a bug somewhere\n+    // in the iteration code.\n+    for (_, v) in sess.lints.borrow().iter() {\n+        for &(lint, span, ref msg) in v {\n+            sess.span_bug(span,\n+                          &format!(\"unprocessed lint {}: {}\",\n+                                   lint.as_str(), *msg))\n+        }\n+    }\n+}"}, {"sha": "e52b6e91f68cd5a50f928c0548c0fae642b577c4", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 96, "deletions": 42, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -35,10 +35,12 @@ use std::hash;\n use std::ascii::AsciiExt;\n use syntax::codemap::Span;\n use rustc_front::visit::FnKind;\n+use syntax::visit as ast_visit;\n use syntax::ast;\n use rustc_front::hir;\n \n-pub use lint::context::{Context, LintStore, raw_emit_lint, check_crate, gather_attrs,\n+pub use lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n+                        raw_emit_lint, check_crate, check_ast_crate, gather_attrs,\n                         GatherNodeLevels};\n \n /// Specification of a single lint.\n@@ -109,14 +111,6 @@ macro_rules! lint_array { ($( $lint:expr ),*) => (\n \n pub type LintArray = &'static [&'static &'static Lint];\n \n-/// Trait for types providing lint checks.\n-///\n-/// Each `check` method checks a single syntax node, and should not\n-/// invoke methods recursively (unlike `Visitor`). By default they\n-/// do nothing.\n-//\n-// FIXME: eliminate the duplication with `Visitor`. But this also\n-// contains a few lint-specific methods with no equivalent in `Visitor`.\n pub trait LintPass {\n     /// Get descriptions of the lints this `LintPass` object can emit.\n     ///\n@@ -125,51 +119,111 @@ pub trait LintPass {\n     /// parts of the compiler. If you want enforced access restrictions for your\n     /// `Lint`, make it a private `static` item in its own module.\n     fn get_lints(&self) -> LintArray;\n+}\n+\n \n-    fn check_crate(&mut self, _: &Context, _: &hir::Crate) { }\n-    fn check_ident(&mut self, _: &Context, _: Span, _: ast::Ident) { }\n-    fn check_mod(&mut self, _: &Context, _: &hir::Mod, _: Span, _: ast::NodeId) { }\n-    fn check_foreign_item(&mut self, _: &Context, _: &hir::ForeignItem) { }\n-    fn check_item(&mut self, _: &Context, _: &hir::Item) { }\n-    fn check_local(&mut self, _: &Context, _: &hir::Local) { }\n-    fn check_block(&mut self, _: &Context, _: &hir::Block) { }\n-    fn check_stmt(&mut self, _: &Context, _: &hir::Stmt) { }\n-    fn check_arm(&mut self, _: &Context, _: &hir::Arm) { }\n-    fn check_pat(&mut self, _: &Context, _: &hir::Pat) { }\n-    fn check_decl(&mut self, _: &Context, _: &hir::Decl) { }\n-    fn check_expr(&mut self, _: &Context, _: &hir::Expr) { }\n-    fn check_expr_post(&mut self, _: &Context, _: &hir::Expr) { }\n-    fn check_ty(&mut self, _: &Context, _: &hir::Ty) { }\n-    fn check_generics(&mut self, _: &Context, _: &hir::Generics) { }\n-    fn check_fn(&mut self, _: &Context,\n+/// Trait for types providing lint checks.\n+///\n+/// Each `check` method checks a single syntax node, and should not\n+/// invoke methods recursively (unlike `Visitor`). By default they\n+/// do nothing.\n+//\n+// FIXME: eliminate the duplication with `Visitor`. But this also\n+// contains a few lint-specific methods with no equivalent in `Visitor`.\n+pub trait LateLintPass: LintPass {\n+    fn check_ident(&mut self, _: &LateContext, _: Span, _: ast::Ident) { }\n+    fn check_crate(&mut self, _: &LateContext, _: &hir::Crate) { }\n+    fn check_mod(&mut self, _: &LateContext, _: &hir::Mod, _: Span, _: ast::NodeId) { }\n+    fn check_foreign_item(&mut self, _: &LateContext, _: &hir::ForeignItem) { }\n+    fn check_item(&mut self, _: &LateContext, _: &hir::Item) { }\n+    fn check_local(&mut self, _: &LateContext, _: &hir::Local) { }\n+    fn check_block(&mut self, _: &LateContext, _: &hir::Block) { }\n+    fn check_stmt(&mut self, _: &LateContext, _: &hir::Stmt) { }\n+    fn check_arm(&mut self, _: &LateContext, _: &hir::Arm) { }\n+    fn check_pat(&mut self, _: &LateContext, _: &hir::Pat) { }\n+    fn check_decl(&mut self, _: &LateContext, _: &hir::Decl) { }\n+    fn check_expr(&mut self, _: &LateContext, _: &hir::Expr) { }\n+    fn check_expr_post(&mut self, _: &LateContext, _: &hir::Expr) { }\n+    fn check_ty(&mut self, _: &LateContext, _: &hir::Ty) { }\n+    fn check_generics(&mut self, _: &LateContext, _: &hir::Generics) { }\n+    fn check_fn(&mut self, _: &LateContext,\n         _: FnKind, _: &hir::FnDecl, _: &hir::Block, _: Span, _: ast::NodeId) { }\n-    fn check_trait_item(&mut self, _: &Context, _: &hir::TraitItem) { }\n-    fn check_impl_item(&mut self, _: &Context, _: &hir::ImplItem) { }\n-    fn check_struct_def(&mut self, _: &Context,\n+    fn check_trait_item(&mut self, _: &LateContext, _: &hir::TraitItem) { }\n+    fn check_impl_item(&mut self, _: &LateContext, _: &hir::ImplItem) { }\n+    fn check_struct_def(&mut self, _: &LateContext,\n         _: &hir::StructDef, _: ast::Ident, _: &hir::Generics, _: ast::NodeId) { }\n-    fn check_struct_def_post(&mut self, _: &Context,\n+    fn check_struct_def_post(&mut self, _: &LateContext,\n         _: &hir::StructDef, _: ast::Ident, _: &hir::Generics, _: ast::NodeId) { }\n-    fn check_struct_field(&mut self, _: &Context, _: &hir::StructField) { }\n-    fn check_variant(&mut self, _: &Context, _: &hir::Variant, _: &hir::Generics) { }\n-    fn check_variant_post(&mut self, _: &Context, _: &hir::Variant, _: &hir::Generics) { }\n-    fn check_opt_lifetime_ref(&mut self, _: &Context, _: Span, _: &Option<hir::Lifetime>) { }\n-    fn check_lifetime_ref(&mut self, _: &Context, _: &hir::Lifetime) { }\n-    fn check_lifetime_def(&mut self, _: &Context, _: &hir::LifetimeDef) { }\n-    fn check_explicit_self(&mut self, _: &Context, _: &hir::ExplicitSelf) { }\n-    fn check_mac(&mut self, _: &Context, _: &ast::Mac) { }\n-    fn check_path(&mut self, _: &Context, _: &hir::Path, _: ast::NodeId) { }\n-    fn check_attribute(&mut self, _: &Context, _: &ast::Attribute) { }\n+    fn check_struct_field(&mut self, _: &LateContext, _: &hir::StructField) { }\n+    fn check_variant(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }\n+    fn check_variant_post(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }\n+    fn check_opt_lifetime_ref(&mut self, _: &LateContext, _: Span, _: &Option<hir::Lifetime>) { }\n+    fn check_lifetime_ref(&mut self, _: &LateContext, _: &hir::Lifetime) { }\n+    fn check_lifetime_def(&mut self, _: &LateContext, _: &hir::LifetimeDef) { }\n+    fn check_explicit_self(&mut self, _: &LateContext, _: &hir::ExplicitSelf) { }\n+    // Note that you shouldn't implement both check_mac and check_ast_mac,\n+    // because then your lint will be called twice. Prefer check_ast_mac.\n+    fn check_mac(&mut self, _: &LateContext, _: &ast::Mac) { }\n+    fn check_path(&mut self, _: &LateContext, _: &hir::Path, _: ast::NodeId) { }\n+    fn check_attribute(&mut self, _: &LateContext, _: &ast::Attribute) { }\n+\n+    /// Called when entering a syntax node that can have lint attributes such\n+    /// as `#[allow(...)]`. Called with *all* the attributes of that node.\n+    fn enter_lint_attrs(&mut self, _: &LateContext, _: &[ast::Attribute]) { }\n+\n+    /// Counterpart to `enter_lint_attrs`.\n+    fn exit_lint_attrs(&mut self, _: &LateContext, _: &[ast::Attribute]) { }\n+}\n+\n+pub trait EarlyLintPass: LintPass {\n+    fn check_ident(&mut self, _: &EarlyContext, _: Span, _: ast::Ident) { }\n+    fn check_crate(&mut self, _: &EarlyContext, _: &ast::Crate) { }\n+    fn check_mod(&mut self, _: &EarlyContext, _: &ast::Mod, _: Span, _: ast::NodeId) { }\n+    fn check_foreign_item(&mut self, _: &EarlyContext, _: &ast::ForeignItem) { }\n+    fn check_item(&mut self, _: &EarlyContext, _: &ast::Item) { }\n+    fn check_local(&mut self, _: &EarlyContext, _: &ast::Local) { }\n+    fn check_block(&mut self, _: &EarlyContext, _: &ast::Block) { }\n+    fn check_stmt(&mut self, _: &EarlyContext, _: &ast::Stmt) { }\n+    fn check_arm(&mut self, _: &EarlyContext, _: &ast::Arm) { }\n+    fn check_pat(&mut self, _: &EarlyContext, _: &ast::Pat) { }\n+    fn check_decl(&mut self, _: &EarlyContext, _: &ast::Decl) { }\n+    fn check_expr(&mut self, _: &EarlyContext, _: &ast::Expr) { }\n+    fn check_expr_post(&mut self, _: &EarlyContext, _: &ast::Expr) { }\n+    fn check_ty(&mut self, _: &EarlyContext, _: &ast::Ty) { }\n+    fn check_generics(&mut self, _: &EarlyContext, _: &ast::Generics) { }\n+    fn check_fn(&mut self, _: &EarlyContext,\n+        _: ast_visit::FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) { }\n+    fn check_trait_item(&mut self, _: &EarlyContext, _: &ast::TraitItem) { }\n+    fn check_impl_item(&mut self, _: &EarlyContext, _: &ast::ImplItem) { }\n+    fn check_struct_def(&mut self, _: &EarlyContext,\n+        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n+    fn check_struct_def_post(&mut self, _: &EarlyContext,\n+        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n+    fn check_struct_field(&mut self, _: &EarlyContext, _: &ast::StructField) { }\n+    fn check_variant(&mut self, _: &EarlyContext, _: &ast::Variant, _: &ast::Generics) { }\n+    fn check_variant_post(&mut self, _: &EarlyContext, _: &ast::Variant, _: &ast::Generics) { }\n+    fn check_opt_lifetime_ref(&mut self,\n+                              _: &EarlyContext,\n+                              _: Span,\n+                              _: &Option<ast::Lifetime>) { }\n+    fn check_lifetime_ref(&mut self, _: &EarlyContext, _: &ast::Lifetime) { }\n+    fn check_lifetime_def(&mut self, _: &EarlyContext, _: &ast::LifetimeDef) { }\n+    fn check_explicit_self(&mut self, _: &EarlyContext, _: &ast::ExplicitSelf) { }\n+    fn check_mac(&mut self, _: &EarlyContext, _: &ast::Mac) { }\n+    fn check_path(&mut self, _: &EarlyContext, _: &ast::Path, _: ast::NodeId) { }\n+    fn check_attribute(&mut self, _: &EarlyContext, _: &ast::Attribute) { }\n \n     /// Called when entering a syntax node that can have lint attributes such\n     /// as `#[allow(...)]`. Called with *all* the attributes of that node.\n-    fn enter_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) { }\n+    fn enter_lint_attrs(&mut self, _: &EarlyContext, _: &[ast::Attribute]) { }\n \n     /// Counterpart to `enter_lint_attrs`.\n-    fn exit_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) { }\n+    fn exit_lint_attrs(&mut self, _: &EarlyContext, _: &[ast::Attribute]) { }\n }\n \n /// A lint pass boxed up as a trait object.\n-pub type LintPassObject = Box<LintPass + 'static>;\n+pub type EarlyLintPassObject = Box<EarlyLintPass + 'static>;\n+pub type LateLintPassObject = Box<LateLintPass + 'static>;\n \n /// Identifies a lint known to the compiler.\n #[derive(Clone, Copy)]"}, {"sha": "60aebd9cd42266bd68a2316768df49720eccbb14", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -354,7 +354,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ExprAddrOf(_, ref e) |\n             hir::ExprCast(ref e, _) |\n             hir::ExprUnary(_, ref e) |\n-            hir::ExprParen(ref e) |\n             hir::ExprField(ref e, _) |\n             hir::ExprTupField(ref e, _) => {\n                 self.straightline(expr, pred, Some(&**e).into_iter())"}, {"sha": "7da2c8f1492df25dddb0e24b611edfede9c76c75", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -678,7 +678,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             let mut callee = &**callee;\n             loop {\n                 callee = match callee.node {\n-                    hir::ExprParen(ref inner) => &**inner,\n                     hir::ExprBlock(ref block) => match block.expr {\n                         Some(ref tail) => &**tail,\n                         None => break\n@@ -763,7 +762,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         hir::ExprField(..) |\n         hir::ExprTupField(..) |\n         hir::ExprVec(_) |\n-        hir::ExprParen(..) |\n         hir::ExprTup(..) => {}\n \n         // Conditional control flow (possible to implement)."}, {"sha": "8f5cf36278d52f031d271d77f29b7d035a456eba", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -996,7 +996,6 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n       hir::ExprLit(ref lit) => {\n           lit_to_const(&**lit, ety)\n       }\n-      hir::ExprParen(ref e) => try!(eval_const_expr_partial(tcx, &**e, ty_hint)),\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => try!(eval_const_expr_partial(tcx, &**expr, ty_hint)),"}, {"sha": "c067c9b4d6313a3d5b9ea87583214a088966333a", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -362,9 +362,6 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate.borrow(expr.id, expr.span, cmt, r, bk, cause);\n \n-        // Note: Unlike consume, we can ignore ExprParen. cat_expr\n-        // already skips over them, and walk will uncover any\n-        // attachments or whatever.\n         self.walk_expr(expr)\n     }\n \n@@ -378,10 +375,6 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         self.walk_adjustment(expr);\n \n         match expr.node {\n-            hir::ExprParen(ref subexpr) => {\n-                self.walk_expr(&**subexpr)\n-            }\n-\n             hir::ExprPath(..) => { }\n \n             hir::ExprUnary(hir::UnDeref, ref base) => {      // *base"}, {"sha": "9bb19bb37d8e419198f9d0d61a4a4c543378ddc7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -495,7 +495,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       hir::ExprAgain(_) | hir::ExprLit(_) | hir::ExprRet(..) |\n       hir::ExprBlock(..) | hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n-      hir::ExprParen(..) | hir::ExprInlineAsm(..) | hir::ExprBox(..) |\n+      hir::ExprInlineAsm(..) | hir::ExprBox(..) |\n       hir::ExprRange(..) => {\n           visit::walk_expr(ir, expr);\n       }\n@@ -1161,8 +1161,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           hir::ExprBox(None, ref e) |\n           hir::ExprAddrOf(_, ref e) |\n           hir::ExprCast(ref e, _) |\n-          hir::ExprUnary(_, ref e) |\n-          hir::ExprParen(ref e) => {\n+          hir::ExprUnary(_, ref e) => {\n             self.propagate_through_expr(&**e, succ)\n           }\n \n@@ -1435,7 +1434,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprRet(..) |\n       hir::ExprBreak(..) | hir::ExprAgain(..) | hir::ExprLit(_) |\n       hir::ExprBlock(..) | hir::ExprAddrOf(..) |\n-      hir::ExprStruct(..) | hir::ExprRepeat(..) | hir::ExprParen(..) |\n+      hir::ExprStruct(..) | hir::ExprRepeat(..) |\n       hir::ExprClosure(..) | hir::ExprPath(..) | hir::ExprBox(..) |\n       hir::ExprRange(..) => {\n         visit::walk_expr(this, expr);"}, {"sha": "2078ee2c57b8f65a4c2fddab64c77a2ad320227f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -519,10 +519,6 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n-          hir::ExprParen(ref e) => {\n-            self.cat_expr(&**e)\n-          }\n-\n           hir::ExprAddrOf(..) | hir::ExprCall(..) |\n           hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n           hir::ExprClosure(..) | hir::ExprRet(..) |"}, {"sha": "c26982ff5ede15f436db54c4870fb93083c8b634", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -997,8 +997,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n             hir::ExprUnary(hir::UnUniq, ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id);\n             }\n-            hir::ExprCast(ref subexpr, _) |\n-            hir::ExprParen(ref subexpr) => {\n+            hir::ExprCast(ref subexpr, _) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id)\n             }\n             hir::ExprBlock(ref block) => {\n@@ -1047,8 +1046,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n                 hir::ExprUnary(hir::UnDeref, ref subexpr) |\n                 hir::ExprField(ref subexpr, _) |\n                 hir::ExprTupField(ref subexpr, _) |\n-                hir::ExprIndex(ref subexpr, _) |\n-                hir::ExprParen(ref subexpr) => {\n+                hir::ExprIndex(ref subexpr, _) => {\n                     expr = &**subexpr;\n                 }\n                 _ => {"}, {"sha": "972f7242808b63c48322560f002e26669a52c209", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -2089,8 +2089,6 @@ impl<'tcx> ctxt<'tcx> {\n             hir::ExprCast(..) => {\n                 false\n             }\n-\n-            hir::ExprParen(ref e) => self.expr_is_lval(e),\n         }\n     }\n "}, {"sha": "50ca092dfe64e43e5e694c004544de673a477342", "filename": "src/librustc/plugin/registry.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fplugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc%2Fplugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fregistry.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -10,7 +10,7 @@\n \n //! Used by plugin crates to tell `rustc` about the plugins they provide.\n \n-use lint::{LintPassObject, LintId, Lint};\n+use lint::{EarlyLintPassObject, LateLintPassObject, LintId, Lint};\n use session::Session;\n \n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n@@ -48,7 +48,10 @@ pub struct Registry<'a> {\n     pub syntax_exts: Vec<NamedSyntaxExtension>,\n \n     #[doc(hidden)]\n-    pub lint_passes: Vec<LintPassObject>,\n+    pub early_lint_passes: Vec<EarlyLintPassObject>,\n+\n+    #[doc(hidden)]\n+    pub late_lint_passes: Vec<LateLintPassObject>,\n \n     #[doc(hidden)]\n     pub lint_groups: HashMap<&'static str, Vec<LintId>>,\n@@ -68,7 +71,8 @@ impl<'a> Registry<'a> {\n             args_hidden: None,\n             krate_span: krate.span,\n             syntax_exts: vec!(),\n-            lint_passes: vec!(),\n+            early_lint_passes: vec!(),\n+            late_lint_passes: vec!(),\n             lint_groups: HashMap::new(),\n             llvm_passes: vec!(),\n             attributes: vec!(),\n@@ -89,7 +93,6 @@ impl<'a> Registry<'a> {\n     /// Register a syntax extension of any kind.\n     ///\n     /// This is the most general hook into `libsyntax`'s expansion behavior.\n-    #[allow(deprecated)]\n     pub fn register_syntax_extension(&mut self, name: ast::Name, extension: SyntaxExtension) {\n         self.syntax_exts.push((name, match extension {\n             NormalTT(ext, _, allow_internal_unstable) => {\n@@ -118,10 +121,14 @@ impl<'a> Registry<'a> {\n     }\n \n     /// Register a compiler lint pass.\n-    pub fn register_lint_pass(&mut self, lint_pass: LintPassObject) {\n-        self.lint_passes.push(lint_pass);\n+    pub fn register_early_lint_pass(&mut self, lint_pass: EarlyLintPassObject) {\n+        self.early_lint_passes.push(lint_pass);\n     }\n \n+    /// Register a compiler lint pass.\n+    pub fn register_late_lint_pass(&mut self, lint_pass: LateLintPassObject) {\n+        self.late_lint_passes.push(lint_pass);\n+    }\n     /// Register a lint group.\n     pub fn register_lint_group(&mut self, name: &'static str, to: Vec<&'static Lint>) {\n         self.lint_groups.insert(name, to.into_iter().map(|x| LintId::of(x)).collect());"}, {"sha": "7134066d08ce78f54a97b4757d15a96825d31e27", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -249,7 +249,6 @@ mod svh_visitor {\n         SawExprInlineAsm(&'a hir::InlineAsm),\n         SawExprStruct,\n         SawExprRepeat,\n-        SawExprParen,\n     }\n \n     fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n@@ -283,7 +282,6 @@ mod svh_visitor {\n             ExprInlineAsm(ref asm)   => SawExprInlineAsm(asm),\n             ExprStruct(..)           => SawExprStruct,\n             ExprRepeat(..)           => SawExprRepeat,\n-            ExprParen(..)            => SawExprParen,\n         }\n     }\n "}, {"sha": "ec5ceadd0662c3b262e475454290d0ca703cb20b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -129,10 +129,12 @@ pub fn compile_input(sess: Session,\n                                                                      &ast_map.krate(),\n                                                                      &id[..]));\n \n+        time(sess.time_passes(), \"early lint checks\", || {\n+            lint::check_ast_crate(&sess, &expanded_crate)\n+        });\n \n         phase_3_run_analysis_passes(sess,\n                                     ast_map,\n-                                    &expanded_crate,\n                                     &arenas,\n                                     id,\n                                     control.make_glob_map,\n@@ -480,13 +482,16 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         }\n     });\n \n-    let Registry { syntax_exts, lint_passes, lint_groups,\n+    let Registry { syntax_exts, early_lint_passes, late_lint_passes, lint_groups,\n                    llvm_passes, attributes, .. } = registry;\n \n     {\n         let mut ls = sess.lint_store.borrow_mut();\n-        for pass in lint_passes {\n-            ls.register_pass(Some(sess), true, pass);\n+        for pass in early_lint_passes {\n+            ls.register_early_pass(Some(sess), true, pass);\n+        }\n+        for pass in late_lint_passes {\n+            ls.register_late_pass(Some(sess), true, pass);\n         }\n \n         for (name, to) in lint_groups {\n@@ -641,7 +646,6 @@ pub fn make_map<'ast>(sess: &Session,\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n                                                ast_map: front::map::Map<'tcx>,\n-                                               ast_crate: &ast::Crate,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                name: String,\n                                                make_glob_map: resolve::MakeGlobMap,\n@@ -765,7 +769,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n                 &tcx.sess, lib_features_used));\n \n         time(time_passes, \"lint checking\", ||\n-            lint::check_crate(tcx, &lower_crate(ast_crate), &exported_items));\n+            lint::check_crate(tcx, krate, &exported_items));\n \n         // The above three passes generate errors w/o aborting\n         tcx.sess.abort_if_errors();"}, {"sha": "75b57341d48dfcc88de5cec39806486c537666ac", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -157,7 +157,6 @@ impl PpSourceMode {\n     fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n                                                sess: Session,\n                                                ast_map: &hir_map::Map<'tcx>,\n-                                               ast_crate: &ast::Crate,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                id: String,\n                                                payload: B,\n@@ -180,7 +179,6 @@ impl PpSourceMode {\n             PpmTyped => {\n                 driver::phase_3_run_analysis_passes(sess,\n                                                     ast_map.clone(),\n-                                                    ast_crate,\n                                                     arenas,\n                                                     id,\n                                                     resolve::MakeGlobMap::No,\n@@ -715,7 +713,7 @@ pub fn pretty_print_input(sess: Session,\n         (PpmHir(s), None) => {\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(\n-                sess, &ast_map.unwrap(), &krate, &arenas, id, box out, |annotation, out, krate| {\n+                sess, &ast_map.unwrap(), &arenas, id, box out, |annotation, out, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     pprust_hir::print_crate(sess.codemap(),\n@@ -733,7 +731,6 @@ pub fn pretty_print_input(sess: Session,\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(sess,\n                                        &ast_map.unwrap(),\n-                                       &krate,\n                                        &arenas,\n                                        id,\n                                        (out,uii),\n@@ -782,7 +779,6 @@ pub fn pretty_print_input(sess: Session,\n                     let variants = gather_flowgraph_variants(&sess);\n                     driver::phase_3_run_analysis_passes(sess,\n                                                         ast_map,\n-                                                        &krate,\n                                                         &arenas,\n                                                         id,\n                                                         resolve::MakeGlobMap::No,"}, {"sha": "0693092c04a4025bac0146d2850053b6686bbefe", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -1164,7 +1164,6 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                         fields.move_map(|x| folder.fold_field(x)),\n                         maybe_expr.map(|x| folder.fold_expr(x)))\n             },\n-            ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n         },\n         span: folder.new_span(span)\n     }"}, {"sha": "8bc8bda9e066cabda89413acb28fa7a8a58b0c4f", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -703,9 +703,6 @@ pub enum Expr_ {\n     /// For example, `[1u8; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n     ExprRepeat(P<Expr>, P<Expr>),\n-\n-    /// No-op: used solely so we can pretty-print faithfully\n-    ExprParen(P<Expr>)\n }\n \n /// The explicit Self type in a \"qualified path\". The actual"}, {"sha": "4f5f892043b0853f765a14816d61a19996f5b05a", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -810,7 +810,9 @@ pub fn lower_expr(e: &Expr) -> P<hir::Expr> {\n                             fields.iter().map(|x| lower_field(x)).collect(),\n                             maybe_expr.as_ref().map(|x| lower_expr(x)))\n                 },\n-                ExprParen(ref ex) => hir::ExprParen(lower_expr(ex)),\n+                ExprParen(ref ex) => {\n+                    return lower_expr(ex);\n+                }\n                 ExprIfLet(..) |\n                 ExprWhileLet(..) |\n                 ExprForLoop(..) |"}, {"sha": "d4a52a5ed8eb0af3492afa241e94e6d85ffe248e", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -1556,11 +1556,6 @@ impl<'a> State<'a> {\n \n                 try!(self.pclose());\n             }\n-            hir::ExprParen(ref e) => {\n-                try!(self.popen());\n-                try!(self.print_expr(&**e));\n-                try!(self.pclose());\n-            }\n         }\n         try!(self.ann.post(self, NodeExpr(expr)));\n         self.end()"}, {"sha": "d9b4f37411420b7fe583846d7f565915edf015ac", "filename": "src/librustc_front/visit.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_front%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_front%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fvisit.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -814,9 +814,6 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprRet(ref optional_expression) => {\n             walk_expr_opt(visitor, optional_expression)\n         }\n-        ExprParen(ref subexpression) => {\n-            visitor.visit_expr(&**subexpression)\n-        }\n         ExprInlineAsm(ref ia) => {\n             for input in &ia.inputs {\n                 let (_, ref input) = *input;"}, {"sha": "394bd2abc08c7f491d33fc31c656523bf20d1487", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 167, "deletions": 111, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -38,7 +38,8 @@ use middle::const_eval::{eval_const_expr_partial, ConstVal};\n use middle::const_eval::EvalHint::ExprTypeChecked;\n use rustc::front::map as hir_map;\n use util::nodemap::{FnvHashMap, FnvHashSet, NodeSet};\n-use lint::{Level, Context, LintPass, LintArray, Lint};\n+use lint::{Level, LateContext, EarlyContext, LintContext, LintArray, Lint};\n+use lint::{LintPass, EarlyLintPass, LateLintPass};\n \n use std::collections::HashSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n@@ -72,8 +73,10 @@ impl LintPass for WhileTrue {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(WHILE_TRUE)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+impl LateLintPass for WhileTrue {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprWhile(ref cond, _, _) = e.node {\n             if let hir::ExprLit(ref lit) = cond.node {\n                 if let ast::LitBool(true) = lit.node {\n@@ -121,8 +124,10 @@ impl LintPass for TypeLimits {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_COMPARISONS, OVERFLOWING_LITERALS, EXCEEDING_BITSHIFTS)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+impl LateLintPass for TypeLimits {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         match e.node {\n             hir::ExprUnary(hir::UnNeg, ref expr) => {\n                 match expr.node  {\n@@ -154,9 +159,6 @@ impl LintPass for TypeLimits {\n                     self.negated_expr_id = expr.id;\n                 }\n             },\n-            hir::ExprParen(ref expr) if self.negated_expr_id == e.id => {\n-                self.negated_expr_id = expr.id;\n-            },\n             hir::ExprBinary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx.tcx, binop, &**l, &**r) {\n                     cx.span_lint(UNUSED_COMPARISONS, e.span,\n@@ -377,7 +379,7 @@ impl LintPass for TypeLimits {\n             }\n         }\n \n-        fn check_unsigned_negation_feature(cx: &Context, span: Span) {\n+        fn check_unsigned_negation_feature(cx: &LateContext, span: Span) {\n             if !cx.sess().features.borrow().negate_unsigned {\n                 // FIXME(#27141): change this to syntax::feature_gate::emit_feature_err\u2026\n                 cx.sess().span_warn(span,\n@@ -398,7 +400,7 @@ declare_lint! {\n }\n \n struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n-    cx: &'a Context<'a, 'tcx>\n+    cx: &'a LateContext<'a, 'tcx>\n }\n \n enum FfiResult {\n@@ -702,14 +704,16 @@ impl LintPass for ImproperCTypes {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(IMPROPER_CTYPES)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n-        fn check_ty(cx: &Context, ty: &hir::Ty) {\n+impl LateLintPass for ImproperCTypes {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+        fn check_ty(cx: &LateContext, ty: &hir::Ty) {\n             let mut vis = ImproperCTypesVisitor { cx: cx };\n             vis.visit_ty(ty);\n         }\n \n-        fn check_foreign_fn(cx: &Context, decl: &hir::FnDecl) {\n+        fn check_foreign_fn(cx: &LateContext, decl: &hir::FnDecl) {\n             for input in &decl.inputs {\n                 check_ty(cx, &*input.ty);\n             }\n@@ -747,7 +751,7 @@ declare_lint! {\n pub struct BoxPointers;\n \n impl BoxPointers {\n-    fn check_heap_type<'a, 'tcx>(&self, cx: &Context<'a, 'tcx>,\n+    fn check_heap_type<'a, 'tcx>(&self, cx: &LateContext<'a, 'tcx>,\n                                  span: Span, ty: Ty<'tcx>) {\n         for leaf_ty in ty.walk() {\n             if let ty::TyBox(_) = leaf_ty.sty {\n@@ -762,8 +766,10 @@ impl LintPass for BoxPointers {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(BOX_POINTERS)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+impl LateLintPass for BoxPointers {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemFn(..) |\n             hir::ItemTy(..) |\n@@ -786,7 +792,7 @@ impl LintPass for BoxPointers {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         let ty = cx.tcx.node_id_to_type(e.id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n@@ -799,7 +805,7 @@ declare_lint! {\n }\n \n struct RawPtrDeriveVisitor<'a, 'tcx: 'a> {\n-    cx: &'a Context<'a, 'tcx>\n+    cx: &'a LateContext<'a, 'tcx>\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for RawPtrDeriveVisitor<'a, 'tcx> {\n@@ -831,8 +837,10 @@ impl LintPass for RawPointerDerive {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(RAW_POINTER_DERIVE)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, item: &hir::Item) {\n+impl LateLintPass for RawPointerDerive {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         if !attr::contains_name(&item.attrs, \"automatically_derived\") {\n             return;\n         }\n@@ -887,8 +895,10 @@ impl LintPass for UnusedAttributes {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_ATTRIBUTES)\n     }\n+}\n \n-    fn check_attribute(&mut self, cx: &Context, attr: &ast::Attribute) {\n+impl LateLintPass for UnusedAttributes {\n+    fn check_attribute(&mut self, cx: &LateContext, attr: &ast::Attribute) {\n         // Note that check_name() marks the attribute as used if it matches.\n         for &(ref name, ty, _) in KNOWN_ATTRIBUTES {\n             match ty {\n@@ -947,8 +957,10 @@ impl LintPass for PathStatements {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(PATH_STATEMENTS)\n     }\n+}\n \n-    fn check_stmt(&mut self, cx: &Context, s: &hir::Stmt) {\n+impl LateLintPass for PathStatements {\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         match s.node {\n             hir::StmtSemi(ref expr, _) => {\n                 match expr.node {\n@@ -981,8 +993,10 @@ impl LintPass for UnusedResults {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_MUST_USE, UNUSED_RESULTS)\n     }\n+}\n \n-    fn check_stmt(&mut self, cx: &Context, s: &hir::Stmt) {\n+impl LateLintPass for UnusedResults {\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         let expr = match s.node {\n             hir::StmtSemi(ref expr, _) => &**expr,\n             _ => return\n@@ -1015,7 +1029,7 @@ impl LintPass for UnusedResults {\n             cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n         }\n \n-        fn check_must_use(cx: &Context, attrs: &[ast::Attribute], sp: Span) -> bool {\n+        fn check_must_use(cx: &LateContext, attrs: &[ast::Attribute], sp: Span) -> bool {\n             for attr in attrs {\n                 if attr.check_name(\"must_use\") {\n                     let mut msg = \"unused result which must be used\".to_string();\n@@ -1046,7 +1060,7 @@ declare_lint! {\n pub struct NonCamelCaseTypes;\n \n impl NonCamelCaseTypes {\n-    fn check_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n+    fn check_case(&self, cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n         fn is_camel_case(ident: ast::Ident) -> bool {\n             let ident = ident.name.as_str();\n             if ident.is_empty() {\n@@ -1087,8 +1101,10 @@ impl LintPass for NonCamelCaseTypes {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NON_CAMEL_CASE_TYPES)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+impl LateLintPass for NonCamelCaseTypes {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         let extern_repr_count = it.attrs.iter().filter(|attr| {\n             attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr).iter()\n                 .any(|r| r == &attr::ReprExtern)\n@@ -1119,29 +1135,29 @@ impl LintPass for NonCamelCaseTypes {\n         }\n     }\n \n-    fn check_generics(&mut self, cx: &Context, it: &hir::Generics) {\n+    fn check_generics(&mut self, cx: &LateContext, it: &hir::Generics) {\n         for gen in it.ty_params.iter() {\n             self.check_case(cx, \"type parameter\", gen.ident, gen.span);\n         }\n     }\n }\n \n #[derive(PartialEq)]\n-enum MethodContext {\n+enum MethodLateContext {\n     TraitDefaultImpl,\n     TraitImpl,\n     PlainImpl\n }\n \n-fn method_context(cx: &Context, id: ast::NodeId, span: Span) -> MethodContext {\n+fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n     match cx.tcx.impl_or_trait_items.borrow().get(&DefId::local(id)) {\n         None => cx.sess().span_bug(span, \"missing method descriptor?!\"),\n         Some(item) => match item.container() {\n-            ty::TraitContainer(..) => MethodContext::TraitDefaultImpl,\n+            ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n             ty::ImplContainer(cid) => {\n                 match cx.tcx.impl_trait_ref(cid) {\n-                    Some(_) => MethodContext::TraitImpl,\n-                    None => MethodContext::PlainImpl\n+                    Some(_) => MethodLateContext::TraitImpl,\n+                    None => MethodLateContext::PlainImpl\n                 }\n             }\n         }\n@@ -1190,7 +1206,7 @@ impl NonSnakeCase {\n         words.join(\"_\")\n     }\n \n-    fn check_snake_case(&self, cx: &Context, sort: &str, name: &str, span: Option<Span>) {\n+    fn check_snake_case(&self, cx: &LateContext, sort: &str, name: &str, span: Option<Span>) {\n         fn is_snake_case(ident: &str) -> bool {\n             if ident.is_empty() {\n                 return true;\n@@ -1233,8 +1249,10 @@ impl LintPass for NonSnakeCase {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NON_SNAKE_CASE)\n     }\n+}\n \n-    fn check_crate(&mut self, cx: &Context, cr: &hir::Crate) {\n+impl LateLintPass for NonSnakeCase {\n+    fn check_crate(&mut self, cx: &LateContext, cr: &hir::Crate) {\n         let attr_crate_name = cr.attrs.iter().find(|at| at.check_name(\"crate_name\"))\n                                       .and_then(|at| at.value_str().map(|s| (at, s)));\n         if let Some(ref name) = cx.tcx.sess.opts.crate_name {\n@@ -1244,15 +1262,15 @@ impl LintPass for NonSnakeCase {\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &Context,\n+    fn check_fn(&mut self, cx: &LateContext,\n                 fk: FnKind, _: &hir::FnDecl,\n                 _: &hir::Block, span: Span, id: ast::NodeId) {\n         match fk {\n             FnKind::Method(ident, _, _) => match method_context(cx, id, span) {\n-                MethodContext::PlainImpl => {\n+                MethodLateContext::PlainImpl => {\n                     self.check_snake_case(cx, \"method\", &ident.name.as_str(), Some(span))\n                 },\n-                MethodContext::TraitDefaultImpl => {\n+                MethodLateContext::TraitDefaultImpl => {\n                     self.check_snake_case(cx, \"trait method\", &ident.name.as_str(), Some(span))\n                 },\n                 _ => (),\n@@ -1264,25 +1282,25 @@ impl LintPass for NonSnakeCase {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if let hir::ItemMod(_) = it.node {\n             self.check_snake_case(cx, \"module\", &it.ident.name.as_str(), Some(it.span));\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, trait_item: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n         if let hir::MethodTraitItem(_, None) = trait_item.node {\n             self.check_snake_case(cx, \"trait method\", &trait_item.ident.name.as_str(),\n                                   Some(trait_item.span));\n         }\n     }\n \n-    fn check_lifetime_def(&mut self, cx: &Context, t: &hir::LifetimeDef) {\n+    fn check_lifetime_def(&mut self, cx: &LateContext, t: &hir::LifetimeDef) {\n         self.check_snake_case(cx, \"lifetime\", &t.lifetime.name.as_str(),\n                               Some(t.lifetime.span));\n     }\n \n-    fn check_pat(&mut self, cx: &Context, p: &hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         if let &hir::PatIdent(_, ref path1, _) = &p.node {\n             let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n             if let Some(def::DefLocal(_)) = def {\n@@ -1291,7 +1309,7 @@ impl LintPass for NonSnakeCase {\n         }\n     }\n \n-    fn check_struct_def(&mut self, cx: &Context, s: &hir::StructDef,\n+    fn check_struct_def(&mut self, cx: &LateContext, s: &hir::StructDef,\n                         _: ast::Ident, _: &hir::Generics, _: ast::NodeId) {\n         for sf in &s.fields {\n             if let hir::StructField_ { kind: hir::NamedField(ident, _), .. } = sf.node {\n@@ -1312,7 +1330,7 @@ declare_lint! {\n pub struct NonUpperCaseGlobals;\n \n impl NonUpperCaseGlobals {\n-    fn check_upper_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n+    fn check_upper_case(cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n         let s = ident.name.as_str();\n \n         if s.chars().any(|c| c.is_lowercase()) {\n@@ -1334,8 +1352,10 @@ impl LintPass for NonUpperCaseGlobals {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NON_UPPER_CASE_GLOBALS)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+impl LateLintPass for NonUpperCaseGlobals {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             // only check static constants\n             hir::ItemStatic(_, hir::MutImmutable, _) => {\n@@ -1348,7 +1368,7 @@ impl LintPass for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, ti: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, ti: &hir::TraitItem) {\n         match ti.node {\n             hir::ConstTraitItem(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n@@ -1358,7 +1378,7 @@ impl LintPass for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &Context, ii: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext, ii: &hir::ImplItem) {\n         match ii.node {\n             hir::ConstImplItem(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n@@ -1368,7 +1388,7 @@ impl LintPass for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &Context, p: &hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n             (&hir::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n@@ -1390,9 +1410,9 @@ declare_lint! {\n pub struct UnusedParens;\n \n impl UnusedParens {\n-    fn check_unused_parens_core(&self, cx: &Context, value: &hir::Expr, msg: &str,\n+    fn check_unused_parens_core(&self, cx: &EarlyContext, value: &ast::Expr, msg: &str,\n                                 struct_lit_needs_parens: bool) {\n-        if let hir::ExprParen(ref inner) = value.node {\n+        if let ast::ExprParen(ref inner) = value.node {\n             let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS, value.span,\n@@ -1405,27 +1425,27 @@ impl UnusedParens {\n         /// delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo\n         /// == X { y: 1 }` and `X { y: 1 } == foo` all do, but `(X {\n         /// y: 1 }) == foo` does not.\n-        fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n+        fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n             match value.node {\n-                hir::ExprStruct(..) => true,\n+                ast::ExprStruct(..) => true,\n \n-                hir::ExprAssign(ref lhs, ref rhs) |\n-                hir::ExprAssignOp(_, ref lhs, ref rhs) |\n-                hir::ExprBinary(_, ref lhs, ref rhs) => {\n+                ast::ExprAssign(ref lhs, ref rhs) |\n+                ast::ExprAssignOp(_, ref lhs, ref rhs) |\n+                ast::ExprBinary(_, ref lhs, ref rhs) => {\n                     // X { y: 1 } + X { y: 2 }\n                     contains_exterior_struct_lit(&**lhs) ||\n                         contains_exterior_struct_lit(&**rhs)\n                 }\n-                hir::ExprUnary(_, ref x) |\n-                hir::ExprCast(ref x, _) |\n-                hir::ExprField(ref x, _) |\n-                hir::ExprTupField(ref x, _) |\n-                hir::ExprIndex(ref x, _) => {\n+                ast::ExprUnary(_, ref x) |\n+                ast::ExprCast(ref x, _) |\n+                ast::ExprField(ref x, _) |\n+                ast::ExprTupField(ref x, _) |\n+                ast::ExprIndex(ref x, _) => {\n                     // &X { y: 1 }, X { y: 1 }.y\n                     contains_exterior_struct_lit(&**x)\n                 }\n \n-                hir::ExprMethodCall(_, _, ref exprs) => {\n+                ast::ExprMethodCall(_, _, ref exprs) => {\n                     // X { y: 1 }.bar(...)\n                     contains_exterior_struct_lit(&*exprs[0])\n                 }\n@@ -1440,29 +1460,31 @@ impl LintPass for UnusedParens {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_PARENS)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+impl EarlyLintPass for UnusedParens {\n+    fn check_expr(&mut self, cx: &EarlyContext, e: &ast::Expr) {\n         let (value, msg, struct_lit_needs_parens) = match e.node {\n-            hir::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n-            hir::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n-            hir::ExprMatch(ref head, _, source) => match source {\n-                hir::MatchSource::Normal => (head, \"`match` head expression\", true),\n-                hir::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n-                hir::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n-                hir::MatchSource::ForLoopDesugar => (head, \"`for` head expression\", true),\n+            ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n+            ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n+            ast::ExprMatch(ref head, _, source) => match source {\n+                ast::MatchSource::Normal => (head, \"`match` head expression\", true),\n+                ast::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n+                ast::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n+                ast::MatchSource::ForLoopDesugar => (head, \"`for` head expression\", true),\n             },\n-            hir::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n-            hir::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n-            hir::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n+            ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n+            ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n+            ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n             _ => return\n         };\n         self.check_unused_parens_core(cx, &**value, msg, struct_lit_needs_parens);\n     }\n \n-    fn check_stmt(&mut self, cx: &Context, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &EarlyContext, s: &ast::Stmt) {\n         let (value, msg) = match s.node {\n-            hir::StmtDecl(ref decl, _) => match decl.node {\n-                hir::DeclLocal(ref local) => match local.init {\n+            ast::StmtDecl(ref decl, _) => match decl.node {\n+                ast::DeclLocal(ref local) => match local.init {\n                     Some(ref value) => (value, \"assigned value\"),\n                     None => return\n                 },\n@@ -1487,8 +1509,10 @@ impl LintPass for UnusedImportBraces {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_IMPORT_BRACES)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, item: &hir::Item) {\n+impl LateLintPass for UnusedImportBraces {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         if let hir::ItemUse(ref view_path) = item.node {\n             if let hir::ViewPathList(_, ref items) = view_path.node {\n                 if items.len() == 1 {\n@@ -1517,8 +1541,10 @@ impl LintPass for NonShorthandFieldPatterns {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NON_SHORTHAND_FIELD_PATTERNS)\n     }\n+}\n \n-    fn check_pat(&mut self, cx: &Context, pat: &hir::Pat) {\n+impl LateLintPass for NonShorthandFieldPatterns {\n+    fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n         let def_map = cx.tcx.def_map.borrow();\n         if let hir::PatStruct(_, ref v, _) = pat.node {\n             let field_pats = v.iter().filter(|fieldpat| {\n@@ -1556,8 +1582,10 @@ impl LintPass for UnusedUnsafe {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_UNSAFE)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+impl LateLintPass for UnusedUnsafe {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             if blk.rules == hir::UnsafeBlock(hir::UserProvided) &&\n@@ -1581,8 +1609,10 @@ impl LintPass for UnsafeCode {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNSAFE_CODE)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+impl LateLintPass for UnsafeCode {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             if blk.rules == hir::UnsafeBlock(hir::UserProvided) {\n@@ -1591,7 +1621,7 @@ impl LintPass for UnsafeCode {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemTrait(hir::Unsafety::Unsafe, _, _, _) =>\n                 cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` trait\"),\n@@ -1603,7 +1633,7 @@ impl LintPass for UnsafeCode {\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &Context, fk: FnKind, _: &hir::FnDecl,\n+    fn check_fn(&mut self, cx: &LateContext, fk: FnKind, _: &hir::FnDecl,\n                 _: &hir::Block, span: Span, _: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, _, hir::Unsafety::Unsafe, _, _, _) =>\n@@ -1619,7 +1649,7 @@ impl LintPass for UnsafeCode {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, trait_item: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n         if let hir::MethodTraitItem(ref sig, None) = trait_item.node {\n             if sig.unsafety == hir::Unsafety::Unsafe {\n                 cx.span_lint(UNSAFE_CODE, trait_item.span,\n@@ -1639,7 +1669,7 @@ declare_lint! {\n pub struct UnusedMut;\n \n impl UnusedMut {\n-    fn check_unused_mut_pat(&self, cx: &Context, pats: &[P<hir::Pat>]) {\n+    fn check_unused_mut_pat(&self, cx: &LateContext, pats: &[P<hir::Pat>]) {\n         // collect all mutable pattern and group their NodeIDs by their Identifier to\n         // avoid false warnings in match arms with multiple patterns\n \n@@ -1672,24 +1702,26 @@ impl LintPass for UnusedMut {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_MUT)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+impl LateLintPass for UnusedMut {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprMatch(_, ref arms, _) = e.node {\n             for a in arms {\n                 self.check_unused_mut_pat(cx, &a.pats)\n             }\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &Context, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         if let hir::StmtDecl(ref d, _) = s.node {\n             if let hir::DeclLocal(ref l) = d.node {\n                 self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n             }\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &Context,\n+    fn check_fn(&mut self, cx: &LateContext,\n                 _: FnKind, decl: &hir::FnDecl,\n                 _: &hir::Block, _: Span, _: ast::NodeId) {\n         for a in &decl.inputs {\n@@ -1711,8 +1743,10 @@ impl LintPass for UnusedAllocation {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_ALLOCATION)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+impl LateLintPass for UnusedAllocation {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         match e.node {\n             hir::ExprUnary(hir::UnUniq, _) => (),\n             _ => return\n@@ -1774,7 +1808,7 @@ impl MissingDoc {\n     }\n \n     fn check_missing_docs_attrs(&self,\n-                               cx: &Context,\n+                               cx: &LateContext,\n                                id: Option<ast::NodeId>,\n                                attrs: &[ast::Attribute],\n                                sp: Span,\n@@ -1816,8 +1850,10 @@ impl LintPass for MissingDoc {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(MISSING_DOCS)\n     }\n+}\n \n-    fn enter_lint_attrs(&mut self, _: &Context, attrs: &[ast::Attribute]) {\n+impl LateLintPass for MissingDoc {\n+    fn enter_lint_attrs(&mut self, _: &LateContext, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n@@ -1827,26 +1863,26 @@ impl LintPass for MissingDoc {\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n \n-    fn exit_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) {\n+    fn exit_lint_attrs(&mut self, _: &LateContext, _: &[ast::Attribute]) {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n-    fn check_struct_def(&mut self, _: &Context, _: &hir::StructDef,\n+    fn check_struct_def(&mut self, _: &LateContext, _: &hir::StructDef,\n                         _: ast::Ident, _: &hir::Generics, id: ast::NodeId) {\n         self.struct_def_stack.push(id);\n     }\n \n-    fn check_struct_def_post(&mut self, _: &Context, _: &hir::StructDef,\n+    fn check_struct_def_post(&mut self, _: &LateContext, _: &hir::StructDef,\n                              _: ast::Ident, _: &hir::Generics, id: ast::NodeId) {\n         let popped = self.struct_def_stack.pop().expect(\"empty struct_def_stack\");\n         assert!(popped == id);\n     }\n \n-    fn check_crate(&mut self, cx: &Context, krate: &hir::Crate) {\n+    fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n         self.check_missing_docs_attrs(cx, None, &krate.attrs, krate.span, \"crate\");\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         let desc = match it.node {\n             hir::ItemFn(..) => \"a function\",\n             hir::ItemMod(..) => \"a module\",\n@@ -1886,7 +1922,7 @@ impl LintPass for MissingDoc {\n         self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs, it.span, desc);\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, trait_item: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n         if self.private_traits.contains(&trait_item.id) { return }\n \n         let desc = match trait_item.node {\n@@ -1900,9 +1936,9 @@ impl LintPass for MissingDoc {\n                                       trait_item.span, desc);\n     }\n \n-    fn check_impl_item(&mut self, cx: &Context, impl_item: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext, impl_item: &hir::ImplItem) {\n         // If the method is an impl for a trait, don't doc.\n-        if method_context(cx, impl_item.id, impl_item.span) == MethodContext::TraitImpl {\n+        if method_context(cx, impl_item.id, impl_item.span) == MethodLateContext::TraitImpl {\n             return;\n         }\n \n@@ -1916,7 +1952,7 @@ impl LintPass for MissingDoc {\n                                       impl_item.span, desc);\n     }\n \n-    fn check_struct_field(&mut self, cx: &Context, sf: &hir::StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext, sf: &hir::StructField) {\n         if let hir::NamedField(_, vis) = sf.node.kind {\n             if vis == hir::Public || self.in_variant {\n                 let cur_struct_def = *self.struct_def_stack.last()\n@@ -1928,13 +1964,13 @@ impl LintPass for MissingDoc {\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &Context, v: &hir::Variant, _: &hir::Generics) {\n+    fn check_variant(&mut self, cx: &LateContext, v: &hir::Variant, _: &hir::Generics) {\n         self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs, v.span, \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;\n     }\n \n-    fn check_variant_post(&mut self, _: &Context, _: &hir::Variant, _: &hir::Generics) {\n+    fn check_variant_post(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) {\n         assert!(self.in_variant);\n         self.in_variant = false;\n     }\n@@ -1953,8 +1989,10 @@ impl LintPass for MissingCopyImplementations {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(MISSING_COPY_IMPLEMENTATIONS)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, item: &hir::Item) {\n+impl LateLintPass for MissingCopyImplementations {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         if !cx.exported_items.contains(&item.id) {\n             return;\n         }\n@@ -2015,8 +2053,10 @@ impl LintPass for MissingDebugImplementations {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(MISSING_DEBUG_IMPLEMENTATIONS)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, item: &hir::Item) {\n+impl LateLintPass for MissingDebugImplementations {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         if !cx.exported_items.contains(&item.id) {\n             return;\n         }\n@@ -2066,7 +2106,7 @@ declare_lint! {\n pub struct Stability;\n \n impl Stability {\n-    fn lint(&self, cx: &Context, _id: DefId,\n+    fn lint(&self, cx: &LateContext, _id: DefId,\n             span: Span, stability: &Option<&attr::Stability>) {\n         // Deprecated attributes apply in-crate and cross-crate.\n         let (lint, label) = match *stability {\n@@ -2077,7 +2117,7 @@ impl Stability {\n \n         output(cx, span, stability, lint, label);\n \n-        fn output(cx: &Context, span: Span, stability: &Option<&attr::Stability>,\n+        fn output(cx: &LateContext, span: Span, stability: &Option<&attr::Stability>,\n                   lint: &'static Lint, label: &'static str) {\n             let msg = match *stability {\n                 Some(&attr::Stability { reason: Some(ref s), .. }) => {\n@@ -2109,29 +2149,31 @@ impl LintPass for Stability {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(DEPRECATED)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, item: &hir::Item) {\n+impl LateLintPass for Stability {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         stability::check_item(cx.tcx, item, false,\n                               &mut |id, sp, stab|\n                                 self.lint(cx, id, sp,\n                                           &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         stability::check_expr(cx.tcx, e,\n                               &mut |id, sp, stab|\n                                 self.lint(cx, id, sp,\n                                           &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n     }\n \n-    fn check_path(&mut self, cx: &Context, path: &hir::Path, id: ast::NodeId) {\n+    fn check_path(&mut self, cx: &LateContext, path: &hir::Path, id: ast::NodeId) {\n         stability::check_path(cx.tcx, path, id,\n                               &mut |id, sp, stab|\n                                 self.lint(cx, id, sp,\n                                           &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n     }\n \n-    fn check_pat(&mut self, cx: &Context, pat: &hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n         stability::check_pat(cx.tcx, pat,\n                              &mut |id, sp, stab|\n                                 self.lint(cx, id, sp,\n@@ -2153,8 +2195,10 @@ impl LintPass for UnconditionalRecursion {\n     fn get_lints(&self) -> LintArray {\n         lint_array![UNCONDITIONAL_RECURSION]\n     }\n+}\n \n-    fn check_fn(&mut self, cx: &Context, fn_kind: FnKind, _: &hir::FnDecl,\n+impl LateLintPass for UnconditionalRecursion {\n+    fn check_fn(&mut self, cx: &LateContext, fn_kind: FnKind, _: &hir::FnDecl,\n                 blk: &hir::Block, sp: Span, id: ast::NodeId) {\n         type F = for<'tcx> fn(&ty::ctxt<'tcx>,\n                               ast::NodeId, ast::NodeId, ast::Ident, ast::NodeId) -> bool;\n@@ -2400,8 +2444,10 @@ impl LintPass for PluginAsLibrary {\n     fn get_lints(&self) -> LintArray {\n         lint_array![PLUGIN_AS_LIBRARY]\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+impl LateLintPass for PluginAsLibrary {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if cx.sess().plugin_registrar_fn.get().is_some() {\n             // We're compiling a plugin; it's fine to link other plugins.\n             return;\n@@ -2456,8 +2502,10 @@ impl LintPass for InvalidNoMangleItems {\n                     PRIVATE_NO_MANGLE_STATICS,\n                     NO_MANGLE_CONST_ITEMS)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+impl LateLintPass for InvalidNoMangleItems {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemFn(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n@@ -2502,8 +2550,10 @@ impl LintPass for MutableTransmutes {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(MUTABLE_TRANSMUTES)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &hir::Expr) {\n+impl LateLintPass for MutableTransmutes {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n         use syntax::abi::RustIntrinsic;\n \n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior,\\\n@@ -2518,7 +2568,7 @@ impl LintPass for MutableTransmutes {\n             _ => ()\n         }\n \n-        fn get_transmute_from_to<'a, 'tcx>(cx: &Context<'a, 'tcx>, expr: &hir::Expr)\n+        fn get_transmute_from_to<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr)\n             -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n             match expr.node {\n                 hir::ExprPath(..) => (),\n@@ -2542,7 +2592,7 @@ impl LintPass for MutableTransmutes {\n             None\n         }\n \n-        fn def_id_is_transmute(cx: &Context, def_id: DefId) -> bool {\n+        fn def_id_is_transmute(cx: &LateContext, def_id: DefId) -> bool {\n             match cx.tcx.lookup_item_type(def_id).ty.sty {\n                 ty::TyBareFn(_, ref bfty) if bfty.abi == RustIntrinsic => (),\n                 _ => return false\n@@ -2569,7 +2619,10 @@ impl LintPass for UnstableFeatures {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNSTABLE_FEATURES)\n     }\n-    fn check_attribute(&mut self, ctx: &Context, attr: &ast::Attribute) {\n+}\n+\n+impl LateLintPass for UnstableFeatures {\n+    fn check_attribute(&mut self, ctx: &LateContext, attr: &ast::Attribute) {\n         if attr::contains_name(&[attr.node.value.clone()], \"feature\") {\n             if let Some(items) = attr.node.value.meta_item_list() {\n                 for item in items {\n@@ -2595,7 +2648,10 @@ impl LintPass for DropWithReprExtern {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(DROP_WITH_REPR_EXTERN)\n     }\n-    fn check_crate(&mut self, ctx: &Context, _: &hir::Crate) {\n+}\n+\n+impl LateLintPass for DropWithReprExtern {\n+    fn check_crate(&mut self, ctx: &LateContext, _: &hir::Crate) {\n         for dtor_did in ctx.tcx.destructors.borrow().iter() {\n             let (drop_impl_did, dtor_self_type) =\n                 if dtor_did.is_local() {"}, {"sha": "5338316406063ad3cd67482211de21d447e6eda0", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -67,15 +67,23 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     macro_rules! add_builtin {\n         ($sess:ident, $($name:ident),*,) => (\n             {$(\n-                store.register_pass($sess, false, box builtin::$name);\n+                store.register_late_pass($sess, false, box builtin::$name);\n+                )*}\n+            )\n+    }\n+\n+    macro_rules! add_early_builtin {\n+        ($sess:ident, $($name:ident),*,) => (\n+            {$(\n+                store.register_early_pass($sess, false, box builtin::$name);\n                 )*}\n             )\n     }\n \n     macro_rules! add_builtin_with_new {\n         ($sess:ident, $($name:ident),*,) => (\n             {$(\n-                store.register_pass($sess, false, box builtin::$name::new());\n+                store.register_late_pass($sess, false, box builtin::$name::new());\n                 )*}\n             )\n     }\n@@ -86,6 +94,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             )\n     }\n \n+    add_early_builtin!(sess,\n+                       UnusedParens,\n+                       );\n+\n     add_builtin!(sess,\n                  HardwiredLints,\n                  WhileTrue,\n@@ -97,7 +109,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  NonCamelCaseTypes,\n                  NonSnakeCase,\n                  NonUpperCaseGlobals,\n-                 UnusedParens,\n                  UnusedImportBraces,\n                  NonShorthandFieldPatterns,\n                  UnusedUnsafe,\n@@ -130,7 +141,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     UNUSED_UNSAFE, PATH_STATEMENTS);\n \n     // We have one lint pass defined specially\n-    store.register_pass(sess, false, box lint::GatherNodeLevels);\n+    store.register_late_pass(sess, false, box lint::GatherNodeLevels);\n \n     // Insert temporary renamings for a one-time deprecation\n     store.register_renamed(\"raw_pointer_deriving\", \"raw_pointer_derive\");"}, {"sha": "5d20fe4bab4fd85303d20154be2cecafb4f99b3e", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -33,9 +33,6 @@ impl<H:Hair> Builder<H> {\n             ExprKind::Scope { extent: _, value } => {\n                 return this.as_constant(value);\n             }\n-            ExprKind::Paren { arg } => {\n-                return this.as_constant(arg);\n-            }\n             ExprKind::Literal { literal } => {\n                 ConstantKind::Literal(literal)\n             }"}, {"sha": "ffbb9781bdce5cec4aeb7d703c62cc950eb947df", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -43,9 +43,6 @@ impl<H:Hair> Builder<H> {\n                     this.as_lvalue(block, value)\n                 })\n             }\n-            ExprKind::Paren { arg } => {\n-                this.as_lvalue(block, arg)\n-            }\n             ExprKind::Field { lhs, name } => {\n                 let lvalue = unpack!(block = this.as_lvalue(block, lhs));\n                 let lvalue = lvalue.field(name);"}, {"sha": "0b236f3a1dcc359b59dbf9619c190a4a33ccd23e", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -39,16 +39,10 @@ impl<H:Hair> Builder<H> {\n                block, expr);\n         let this = self;\n \n-        match expr.kind {\n-            ExprKind::Scope { extent, value } => {\n-                return this.in_scope(extent, block, |this| {\n-                    this.as_operand(block, value)\n-                });\n-            }\n-            ExprKind::Paren { arg } => {\n-                return this.as_operand(block, arg);\n-            }\n-            _ => { }\n+        if let ExprKind::Scope { extent, value } = expr.kind {\n+            return this.in_scope(extent, block, |this| {\n+                this.as_operand(block, value)\n+            });\n         }\n \n         let category = Category::of(&expr.kind).unwrap();"}, {"sha": "d03028ffea6753b9f59053831683baabc685be26", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -46,9 +46,6 @@ impl<H:Hair> Builder<H> {\n                     this.as_rvalue(block, value)\n                 })\n             }\n-            ExprKind::Paren { arg } => {\n-                this.as_rvalue(block, arg)\n-            }\n             ExprKind::InlineAsm { asm } => {\n                 block.and(Rvalue::InlineAsm(asm))\n             }"}, {"sha": "cb652c8a5945ef4b7cb811a62380f9f667c01408", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -37,16 +37,10 @@ impl<H:Hair> Builder<H> {\n                block, expr);\n         let this = self;\n \n-        match expr.kind {\n-            ExprKind::Scope { extent, value } => {\n-                return this.in_scope(extent, block, |this| {\n-                    this.as_temp(block, value)\n-                });\n-            }\n-            ExprKind::Paren { arg } => {\n-                return this.as_temp(block, arg);\n-            }\n-            _ => { }\n+        if let ExprKind::Scope { extent, value } = expr.kind {\n+            return this.in_scope(extent, block, |this| {\n+                this.as_temp(block, value)\n+            });\n         }\n \n         let expr_ty = expr.ty.clone();"}, {"sha": "9cab2976b2c6182423e516c2f7ea01d716a6a7be", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -43,9 +43,7 @@ pub enum RvalueFunc {\n impl Category {\n     pub fn of<H:Hair>(ek: &ExprKind<H>) -> Option<Category> {\n         match *ek {\n-            ExprKind::Scope { .. } |\n-            ExprKind::Paren { .. } =>\n-                None,\n+            ExprKind::Scope { .. } => None,\n \n             ExprKind::Field { .. } |\n             ExprKind::Deref { .. } |"}, {"sha": "72e505f2b6edd8cec7fe276dbb0f03872017d513", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -40,9 +40,6 @@ impl<H:Hair> Builder<H> {\n                     this.into(destination, block, value)\n                 })\n             }\n-            ExprKind::Paren { arg } => {\n-                this.into(destination, block, arg)\n-            }\n             ExprKind::Block { body: ast_block } => {\n                 this.ast_block(destination, block, ast_block)\n             }"}, {"sha": "f1450522dd83ea8ad0af97c02a7d58118b50235c", "filename": "src/librustc_mir/hair.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fhair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Fhair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -171,7 +171,6 @@ pub struct Expr<H:Hair> {\n #[derive(Clone, Debug)]\n pub enum ExprKind<H:Hair> {\n     Scope { extent: H::CodeExtent, value: ExprRef<H> },\n-    Paren { arg: ExprRef<H> }, // ugh. should be able to remove this!\n     Box { place: Option<ExprRef<H>>, value: ExprRef<H> },\n     Call { fun: ExprRef<H>, args: Vec<ExprRef<H>> },\n     Deref { arg: ExprRef<H> }, // NOT overloaded!"}, {"sha": "7e68993b1309be25532bcd4e337f824f4ea2b161", "filename": "src/librustc_mir/tcx/expr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -267,8 +267,6 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n \n             // Now comes the rote stuff:\n \n-            hir::ExprParen(ref p) =>\n-                ExprKind::Paren { arg: p.to_ref() },\n             hir::ExprRepeat(ref v, ref c) =>\n                 ExprKind::Repeat { value: v.to_ref(), count: c.to_ref() },\n             hir::ExprRet(ref v) =>"}, {"sha": "1d0c5137eceaad82caefd093ea37d9f8be9aead4", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -703,7 +703,6 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let mut cur = sub;\n             loop {\n                 match cur.node {\n-                    hir::ExprParen(ref sub) => cur = sub,\n                     hir::ExprBlock(ref blk) => {\n                         if let Some(ref sub) = blk.expr {\n                             cur = sub;\n@@ -830,7 +829,6 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let mut callee = &**callee;\n             loop {\n                 callee = match callee.node {\n-                    hir::ExprParen(ref inner) => &**inner,\n                     hir::ExprBlock(ref block) => match block.expr {\n                         Some(ref tail) => &**tail,\n                         None => break,\n@@ -870,7 +868,6 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             const_fn_call(cx, MethodCallKey(method_call),\n                           method_did, &arg_vals, param_substs)\n         },\n-        hir::ExprParen(ref e) => const_expr(cx, &**e, param_substs, fn_args).0,\n         hir::ExprBlock(ref block) => {\n             match block.expr {\n                 Some(ref expr) => const_expr(cx, &**expr, param_substs, fn_args).0,"}, {"sha": "828086800499a80d14d4dfd8ff05170f2eac8b12", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -322,8 +322,7 @@ fn walk_expr(cx: &CrateContext,\n         hir::ExprCast(ref sub_exp, _)     |\n         hir::ExprAddrOf(_, ref sub_exp)  |\n         hir::ExprField(ref sub_exp, _) |\n-        hir::ExprTupField(ref sub_exp, _) |\n-        hir::ExprParen(ref sub_exp) =>\n+        hir::ExprTupField(ref sub_exp, _) =>\n             walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n \n         hir::ExprBox(ref place, ref sub_expr) => {"}, {"sha": "d8397b3c0176614b73bc3c91bdc0bbdb0c7ab0f9", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -630,9 +630,6 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_datum_unadjusted\");\n \n     match expr.node {\n-        hir::ExprParen(ref e) => {\n-            trans(bcx, &**e)\n-        }\n         hir::ExprPath(..) => {\n             trans_def(bcx, expr, bcx.def(expr.id))\n         }\n@@ -934,9 +931,6 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n \n     match expr.node {\n-        hir::ExprParen(ref e) => {\n-            trans_into(bcx, &**e, Ignore)\n-        }\n         hir::ExprBreak(label_opt) => {\n             controlflow::trans_break(bcx, expr, label_opt.map(|l| l.node))\n         }\n@@ -1050,9 +1044,6 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n \n     match expr.node {\n-        hir::ExprParen(ref e) => {\n-            trans_into(bcx, &**e, dest)\n-        }\n         hir::ExprPath(..) => {\n             trans_def_dps_unadjusted(bcx, expr, bcx.def(expr.id), dest)\n         }\n@@ -2750,7 +2741,5 @@ fn expr_kind(tcx: &ty::ctxt, expr: &hir::Expr) -> ExprKind {\n                 ExprKind::RvalueDps\n             }\n         }\n-\n-        hir::ExprParen(ref e) => expr_kind(tcx, &**e),\n     }\n }"}, {"sha": "abdcbf099a57a4104f75dee658b94e5107ac8dc2", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -468,7 +468,6 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         loop {\n             let last = exprs[exprs.len() - 1];\n             match last.node {\n-                hir::ExprParen(ref expr) |\n                 hir::ExprField(ref expr, _) |\n                 hir::ExprTupField(ref expr, _) |\n                 hir::ExprIndex(ref expr, _) |"}, {"sha": "e5dbfdf176739eb29d5479fb7c2a5dd9f84a1421", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -3444,13 +3444,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n         fcx.write_ty(id, fcx.infcx().next_diverging_ty_var());\n       }\n-      hir::ExprParen(ref a) => {\n-        check_expr_with_expectation_and_lvalue_pref(fcx,\n-                                                    &**a,\n-                                                    expected,\n-                                                    lvalue_pref);\n-        fcx.write_ty(id, fcx.expr_ty(&**a));\n-      }\n       hir::ExprAssign(ref lhs, ref rhs) => {\n         check_expr_with_lvalue_pref(fcx, &**lhs, PreferMutLvalue);\n "}, {"sha": "d7238c827ab57506b6fcd3e48496b3511c77da62", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -141,7 +141,6 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n \n     driver::phase_3_run_analysis_passes(sess,\n                                         hir_map,\n-                                        &krate,\n                                         &arenas,\n                                         name,\n                                         resolve::MakeGlobMap::No,"}, {"sha": "7ae161a86a3614254472364026e3575a72540d0b", "filename": "src/test/auxiliary/lint_for_crate.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fauxiliary%2Flint_for_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fauxiliary%2Flint_for_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_for_crate.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -17,7 +17,7 @@\n extern crate rustc_front;\n extern crate syntax;\n \n-use rustc::lint::{Context, LintPass, LintPassObject, LintArray};\n+use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n use rustc::plugin::Registry;\n use rustc_front::hir;\n use syntax::attr;\n@@ -30,8 +30,10 @@ impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(CRATE_NOT_OKAY)\n     }\n+}\n \n-    fn check_crate(&mut self, cx: &Context, krate: &hir::Crate) {\n+impl LateLintPass for Pass {\n+    fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n         if !attr::contains_name(&krate.attrs, \"crate_okay\") {\n             cx.span_lint(CRATE_NOT_OKAY, krate.span,\n                          \"crate is not marked with #![crate_okay]\");\n@@ -41,5 +43,5 @@ impl LintPass for Pass {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_lint_pass(box Pass as LintPassObject);\n+    reg.register_late_lint_pass(box Pass as LateLintPassObject);\n }"}, {"sha": "13cf5f09db32b38a7978b0866432f0e752231489", "filename": "src/test/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -20,7 +20,7 @@ extern crate rustc_front;\n extern crate rustc;\n \n use rustc_front::hir;\n-use rustc::lint::{Context, LintPass, LintPassObject, LintArray};\n+use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n use rustc::plugin::Registry;\n \n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n@@ -33,8 +33,10 @@ impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(TEST_LINT, PLEASE_LINT)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+impl LateLintPass for Pass {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match &*it.ident.name.as_str() {\n             \"lintme\" => cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\"),\n             \"pleaselintme\" => cx.span_lint(PLEASE_LINT, it.span, \"item is named 'pleaselintme'\"),\n@@ -45,6 +47,6 @@ impl LintPass for Pass {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_lint_pass(box Pass as LintPassObject);\n+    reg.register_late_lint_pass(box Pass as LateLintPassObject);\n     reg.register_lint_group(\"lint_me\", vec![TEST_LINT, PLEASE_LINT]);\n }"}, {"sha": "4f5e8d6e0874c1a9d77eb885b135e32e9dbae031", "filename": "src/test/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -13,15 +13,16 @@\n #![feature(plugin_registrar)]\n #![feature(box_syntax, rustc_private)]\n \n-extern crate rustc_front;\n+extern crate syntax;\n \n // Load rustc as a plugin to get macros\n #[macro_use]\n extern crate rustc;\n \n-use rustc::lint::{Context, LintPass, LintPassObject, LintArray};\n+use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass,\n+                  EarlyLintPassObject, LintArray};\n use rustc::plugin::Registry;\n-use rustc_front::hir;\n+use syntax::ast;\n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n \n struct Pass;\n@@ -30,8 +31,10 @@ impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(TEST_LINT)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+impl EarlyLintPass for Pass {\n+    fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n         if it.ident.name == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n@@ -40,5 +43,5 @@ impl LintPass for Pass {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_lint_pass(box Pass as LintPassObject);\n+    reg.register_early_lint_pass(box Pass as EarlyLintPassObject);\n }"}, {"sha": "0d666a4920038aa40254183d496ccf73c9a72af6", "filename": "src/test/compile-fail/autoderef-full-lval.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unknown_features)]\n #![feature(box_syntax)]\n \n struct clam {"}, {"sha": "f3417fafe90375ed9996d8b917d90137e123a375", "filename": "src/test/compile-fail/borrow-tuple-fields.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fborrow-tuple-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fborrow-tuple-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrow-tuple-fields.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unknown_features)]\n #![feature(box_syntax)]\n \n struct Foo(Box<isize>, isize);"}, {"sha": "52a4950022d1e13364ae8a26ac5edac2b50e5e8f", "filename": "src/test/compile-fail/cast-as-bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fcast-as-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fcast-as-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-as-bool.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let u = (5 as bool);\n+    let u = 5 as bool;\n     //~^ ERROR cannot cast as `bool`\n     //~^^ HELP compare with zero instead\n }"}, {"sha": "9cfeaca6dfadf2a3120577f8accc69dc03f448db", "filename": "src/test/compile-fail/dropck_arr_cycle_checked.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -19,7 +19,6 @@ use std::cell::Cell;\n use id::Id;\n \n mod s {\n-    #![allow(unstable)]\n     use std::sync::atomic::{AtomicUsize, Ordering};\n \n     static S_COUNT: AtomicUsize = AtomicUsize::new(0);"}, {"sha": "d36293a484d4e3cb638ac934da2bb2fe39fd4435", "filename": "src/test/compile-fail/dropck_tarena_cycle_checked.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -16,7 +16,6 @@\n //  which is a reduction of this code to more directly show the reason\n //  for the error message we see here.)\n \n-#![allow(unstable)]\n #![feature(const_fn)]\n \n extern crate arena;\n@@ -26,7 +25,6 @@ use std::cell::Cell;\n use id::Id;\n \n mod s {\n-    #![allow(unstable)]\n     use std::sync::atomic::{AtomicUsize, Ordering};\n \n     static S_COUNT: AtomicUsize = AtomicUsize::new(0);"}, {"sha": "600c794109ccf97bd23539a210de22ca7e6534b4", "filename": "src/test/compile-fail/dropck_tarena_unsound_drop.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_unsound_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_unsound_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_unsound_drop.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -19,8 +19,6 @@\n // (Also compare against dropck_tarena_cycle_checked.rs, from which\n // this was reduced to better understand its error message.)\n \n-#![allow(unstable)]\n-\n extern crate arena;\n \n use arena::TypedArena;"}, {"sha": "caf25e68d568ca3af4bd8691822507ca8e1abf06", "filename": "src/test/compile-fail/dropck_vec_cycle_checked.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -18,7 +18,6 @@ use std::cell::Cell;\n use id::Id;\n \n mod s {\n-    #![allow(unstable)]\n     use std::sync::atomic::{AtomicUsize, Ordering};\n \n     static S_COUNT: AtomicUsize = AtomicUsize::new(0);"}, {"sha": "f06882875fd9b4650d29f17b0caf019a30cd7153", "filename": "src/test/compile-fail/for-loop-hygiene.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Ffor-loop-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Ffor-loop-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-hygiene.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -11,8 +11,6 @@\n // for-loops are expanded in the front end, and use an `iter` ident in their expansion. Check that\n // `iter` is not accessible inside the for loop.\n \n-#![allow(unstable)]\n-\n fn main() {\n     for _ in 0..10 {\n         iter.next();  //~ error: unresolved name `iter`"}, {"sha": "c7d6443663241a27392acbc03f13f6ad8fa700fa", "filename": "src/test/compile-fail/issue-17283.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fissue-17283.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fissue-17283.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17283.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -11,6 +11,8 @@\n // Test that the parser does not attempt to parse struct literals\n // within assignments in if expressions.\n \n+#![allow(unused_parens)]\n+\n struct Foo {\n     foo: usize\n }"}, {"sha": "dba9c32f9b4808e4a2d82ccd05404ce56c82c323", "filename": "src/test/compile-fail/issue-23046.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fissue-23046.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fissue-23046.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23046.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -24,7 +24,7 @@ pub fn let_<'var, VAR, F: for<'v: 'var> Fn(Expr<'v, VAR>) -> Expr<'v, VAR>>\n }\n \n fn main() {\n-    let ex =  (|x| {\n+    let ex = |x| {\n         let_(add(x,x), |y| { //~ ERROR unable to infer enough type information about `_`\n-            let_(add(x, x), |x|x)})});\n+            let_(add(x, x), |x|x)})};\n }"}, {"sha": "f98cf6575d6ec5b2340b65bd2b8cd27462762b81", "filename": "src/test/compile-fail/issue-23729.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fissue-23729.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fissue-23729.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23729.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -26,7 +26,7 @@ fn main() {\n                     self.pos += 1;\n                     Some(next_val)\n                 } else {\n-                    let next_val = (self.mem[0] + self.mem[1]);\n+                    let next_val = self.mem[0] + self.mem[1];\n                     self.mem[0] = self.mem[1];\n                     self.mem[1] = next_val;\n                     Some(next_val)"}, {"sha": "d34738282eb268e0d90f430307433a333dfa13f4", "filename": "src/test/compile-fail/lint-visible-private-types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(visible_private_types)]\n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n "}, {"sha": "cd320ba148aba8fe02323db6fa3fcbae88ac67f3", "filename": "src/test/compile-fail/loop-does-not-diverge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Floop-does-not-diverge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Floop-does-not-diverge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Floop-does-not-diverge.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -18,5 +18,5 @@ fn forever() -> ! {\n }\n \n fn main() {\n-  if (1 == 2) { forever(); }\n+  if 1 == 2 { forever(); }\n }"}, {"sha": "b6f197987bab1df73c4b5a3552f229f36f9234a3", "filename": "src/test/compile-fail/variance-trait-bounds.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(bivariance)]\n #![allow(dead_code)]\n #![feature(rustc_attrs)]\n "}, {"sha": "2fd8bf20c79974beef8c80e77077a1dd8dedf268", "filename": "src/test/compile-fail/variance-types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(bivariance)]\n #![allow(dead_code)]\n #![feature(rustc_attrs)]\n "}, {"sha": "c8f4326bb28241a32531d13b70a2aed201c2a09b", "filename": "src/test/compile-fail/vec-must-not-hide-type-from-dropck.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -29,7 +29,6 @@ use std::cell::Cell;\n use id::Id;\n \n mod s {\n-    #![allow(unstable)]\n     use std::sync::atomic::{AtomicUsize, Ordering};\n \n     static S_COUNT: AtomicUsize = AtomicUsize::new(0);"}, {"sha": "835f7fc96c63fb5e9c6ef6976b32a63daab8a945", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -27,10 +27,9 @@\n     let _: [(); (1 as usize)] = ([(() as ())] as [(); 1]);\n \n     let _ =\n-        (((&((([(1 as i32), (2 as i32), (3 as i32)] as [i32; 3])) as [i32; 3])\n-              as &[i32; 3]) as *const _ as *const [i32; 3]) as\n-            *const [i32; (3 as usize)] as *const [i32; 3]);\n-\n+        (((&([(1 as i32), (2 as i32), (3 as i32)] as [i32; 3]) as &[i32; 3])\n+             as *const _ as *const [i32; 3]) as *const [i32; (3 as usize)] as\n+            *const [i32; 3]);\n \n \n "}, {"sha": "6fc12d3a750782318340272e23a5b0288286b8e9", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=d16129bca5f5c9f3a5bb66d3f757ec75ed0f9c7b", "patch": "@@ -228,7 +228,7 @@ fn compile_program(input: &str, sysroot: PathBuf)\n         let ast_map = driver::make_map(&sess, &mut hir_forest);\n \n         driver::phase_3_run_analysis_passes(\n-            sess, ast_map, &krate, &arenas, id, MakeGlobMap::No, |tcx, analysis| {\n+            sess, ast_map, &arenas, id, MakeGlobMap::No, |tcx, analysis| {\n \n             let trans = driver::phase_4_translate_to_llvm(tcx, analysis);\n "}]}