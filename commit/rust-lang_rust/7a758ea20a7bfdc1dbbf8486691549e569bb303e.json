{"sha": "7a758ea20a7bfdc1dbbf8486691549e569bb303e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhNzU4ZWEyMGE3YmZkYzFkYmJmODQ4NjY5MTU0OWU1NjliYjMwM2U=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-04-15T08:52:08Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2016-04-15T08:52:08Z"}, "message": "Fix closures again (#937)\n\n* Fix closures again\r\n\r\nCloses #934\r\n\r\nOh god, the rules for parsing closures are even more messed up than I thought - whether or not there is an inner block or depends not only on if there are braces, but also if there is a return type for the closure (!) and if there are statements in the block.\r\n\r\n* Fix overflow", "tree": {"sha": "f3f8776e25c86338f3733f63d2177f3fe2845571", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3f8776e25c86338f3733f63d2177f3fe2845571"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a758ea20a7bfdc1dbbf8486691549e569bb303e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a758ea20a7bfdc1dbbf8486691549e569bb303e", "html_url": "https://github.com/rust-lang/rust/commit/7a758ea20a7bfdc1dbbf8486691549e569bb303e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a758ea20a7bfdc1dbbf8486691549e569bb303e/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c", "html_url": "https://github.com/rust-lang/rust/commit/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c"}], "stats": {"total": 83, "additions": 69, "deletions": 14}, "files": [{"sha": "a88e7ee6d19cc36b98beb9cf311dcb6e0ad00556", "filename": "src/expr.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7a758ea20a7bfdc1dbbf8486691549e569bb303e/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a758ea20a7bfdc1dbbf8486691549e569bb303e/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=7a758ea20a7bfdc1dbbf8486691549e569bb303e", "patch": "@@ -313,6 +313,9 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n //   * the body of a closure is represented by an ast::Block, but that does not\n //     imply there are `{}` (unless the block is empty) (see rust issue #27872),\n //   * if there is a return type, then there must be braces,\n+//   * given a closure with braces, whether that is parsed to give an inner block\n+//     or not depends on if there is a return type and if there are statements\n+//     in that block,\n //   * if the first expression in the body ends with a block (i.e., is a\n //     statement without needing a semi-colon), then adding or removing braces\n //     can change whether it is treated as an expression or statement.\n@@ -379,11 +382,7 @@ fn rewrite_closure(capture: ast::CaptureBy,\n         prefix.push_str(&ret_str);\n     }\n \n-    assert!(body.stmts.is_empty(),\n-            \"unexpected statements in closure: `{}`\",\n-            context.snippet(span));\n-\n-    if body.expr.is_none() {\n+    if body.expr.is_none() && body.stmts.is_empty() {\n         return Some(format!(\"{} {{}}\", prefix));\n     }\n \n@@ -392,15 +391,17 @@ fn rewrite_closure(capture: ast::CaptureBy,\n     let budget = try_opt!(width.checked_sub(extra_offset));\n \n     // This is where we figure out whether to use braces or not.\n-    let mut had_braces = false;\n+    let mut had_braces = true;\n     let mut inner_block = body;\n-    if let ast::ExprKind::Block(ref inner) = inner_block.expr.as_ref().unwrap().node {\n-        had_braces = true;\n-        inner_block = inner;\n-    };\n-    assert!(!force_block || !had_braces,\n-            \"Closure requires braces, but they weren't present. How did this parse? `{}`\",\n-            context.snippet(span));\n+\n+    // If there is an inner block and we can ignore it, do so.\n+    if body.stmts.is_empty() {\n+        if let ast::ExprKind::Block(ref inner) = inner_block.expr.as_ref().unwrap().node {\n+            inner_block = inner;\n+        } else if !force_block {\n+            had_braces = false;\n+        }\n+    }\n \n     let try_single_line = is_simple_block(inner_block, context.codemap) &&\n                           inner_block.rules == ast::BlockCheckMode::Default;\n@@ -439,7 +440,9 @@ fn rewrite_closure(capture: ast::CaptureBy,\n     if try_single_line && !prefix.contains('\\n') {\n         let inner_expr = inner_block.expr.as_ref().unwrap();\n         // 4 = braces and spaces.\n-        let mut rewrite = inner_expr.rewrite(context, budget - 4, offset + extra_offset);\n+        let mut rewrite = inner_expr.rewrite(context,\n+                                             try_opt!(budget.checked_sub(4)),\n+                                             offset + extra_offset);\n \n         // Checks if rewrite succeeded and fits on a single line.\n         rewrite = and_one_line(rewrite);"}, {"sha": "4fd5465cca0d4735305eac4a6ea842d4eadf639f", "filename": "tests/source/closure.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7a758ea20a7bfdc1dbbf8486691549e569bb303e/tests%2Fsource%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a758ea20a7bfdc1dbbf8486691549e569bb303e/tests%2Fsource%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fclosure.rs?ref=7a758ea20a7bfdc1dbbf8486691549e569bb303e", "patch": "@@ -57,3 +57,28 @@ fn issue863() {\n         _ => false,\n     } == true;\n }\n+\n+fn issue934() {\n+    let hash: &Fn(&&Block) -> u64 = &|block| -> u64 {\n+        let mut h = SpanlessHash::new(cx);\n+        h.hash_block(block);\n+        h.finish()\n+    };\n+\n+    let hash: &Fn(&&Block) -> u64 = &|block| -> u64 {\n+        let mut h = SpanlessHash::new(cx);\n+        h.hash_block(block);\n+        h.finish();\n+    };\n+}\n+\n+impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n+    pub fn eq_expr(&self, left: &Expr, right: &Expr) -> bool {\n+        match (&left.node, &right.node) {\n+            (&ExprBinary(l_op, ref ll, ref lr), &ExprBinary(r_op, ref rl, ref rr)) => {\n+                l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr) ||\n+                swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr))\n+            }\n+        }\n+    }\n+}"}, {"sha": "5f40610d60318a4ef169f672ff974933a687bb82", "filename": "tests/target/closure.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7a758ea20a7bfdc1dbbf8486691549e569bb303e/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a758ea20a7bfdc1dbbf8486691549e569bb303e/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=7a758ea20a7bfdc1dbbf8486691549e569bb303e", "patch": "@@ -82,3 +82,30 @@ fn issue863() {\n         _ => false,\n     } == true;\n }\n+\n+fn issue934() {\n+    let hash: &Fn(&&Block) -> u64 = &|block| -> u64 {\n+        let mut h = SpanlessHash::new(cx);\n+        h.hash_block(block);\n+        h.finish()\n+    };\n+\n+    let hash: &Fn(&&Block) -> u64 = &|block| -> u64 {\n+        let mut h = SpanlessHash::new(cx);\n+        h.hash_block(block);\n+        h.finish();\n+    };\n+}\n+\n+impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n+    pub fn eq_expr(&self, left: &Expr, right: &Expr) -> bool {\n+        match (&left.node, &right.node) {\n+            (&ExprBinary(l_op, ref ll, ref lr), &ExprBinary(r_op, ref rl, ref rr)) => {\n+                l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr) ||\n+                swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n+                    l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                })\n+            }\n+        }\n+    }\n+}"}]}