{"sha": "b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0OTU5MzNhN2ZkYzVlN2IyOGRkYmIwNThkMWUyZGFiMzMwYWNlN2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-01T01:56:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-01T01:56:32Z"}, "message": "auto merge of #16141 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "08789d8ee08603d5bee30fc7958e1f8fcae83bea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08789d8ee08603d5bee30fc7958e1f8fcae83bea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "html_url": "https://github.com/rust-lang/rust/commit/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75a39e0fb8fef20d72f7279686ec266bb9cec127", "url": "https://api.github.com/repos/rust-lang/rust/commits/75a39e0fb8fef20d72f7279686ec266bb9cec127", "html_url": "https://github.com/rust-lang/rust/commit/75a39e0fb8fef20d72f7279686ec266bb9cec127"}, {"sha": "ec79d368d2f9b56ac1d00825108b4e8b8bd26498", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec79d368d2f9b56ac1d00825108b4e8b8bd26498", "html_url": "https://github.com/rust-lang/rust/commit/ec79d368d2f9b56ac1d00825108b4e8b8bd26498"}], "stats": {"total": 2820, "additions": 1580, "deletions": 1240}, "files": [{"sha": "5bc4505fb05c742bf92f22bf21d65320820112d2", "filename": "mk/crates.mk", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -51,7 +51,7 @@\n \n TARGET_CRATES := libc std green rustuv native flate arena glob term semver \\\n                  uuid serialize sync getopts collections num test time rand \\\n-                 url log regex graphviz core rlibc alloc debug rustrt \\\n+                 url log regex graphviz core rbml rlibc alloc debug rustrt \\\n                  unicode\n HOST_CRATES := syntax rustc rustdoc fourcc hexfloat regex_macros fmt_macros \\\n \t       rustc_llvm rustc_back\n@@ -71,7 +71,7 @@ DEPS_green := std native:context_switch\n DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std\n DEPS_syntax := std term serialize log fmt_macros debug\n-DEPS_rustc := syntax flate arena serialize getopts \\\n+DEPS_rustc := syntax flate arena serialize getopts rbml \\\n               time log graphviz debug rustc_llvm rustc_back\n DEPS_rustc_llvm := native:rustllvm libc std\n DEPS_rustc_back := std syntax rustc_llvm flate log libc\n@@ -82,6 +82,7 @@ DEPS_arena := std\n DEPS_graphviz := std\n DEPS_glob := std\n DEPS_serialize := std log\n+DEPS_rbml := std log serialize\n DEPS_term := std log\n DEPS_semver := std\n DEPS_uuid := std serialize\n@@ -91,7 +92,7 @@ DEPS_collections := core alloc unicode\n DEPS_fourcc := rustc syntax std\n DEPS_hexfloat := rustc syntax std\n DEPS_num := std\n-DEPS_test := std getopts serialize term time regex native:rust_test_helpers\n+DEPS_test := std getopts serialize rbml term time regex native:rust_test_helpers\n DEPS_time := std serialize\n DEPS_rand := core\n DEPS_url := std"}, {"sha": "c5ddd180ee8e13186d23b6de106d3cd5bb6bb78a", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -1,6 +1,5 @@\n % Language FAQ\n \n-\n ## Are there any big programs written in it yet? I want to read big samples.\n \n There aren't many large programs yet. The Rust [compiler][rustc], 60,000+ lines at the time of writing, is written in Rust. As the oldest body of Rust code it has gone through many iterations of the language, and some parts are nicer to look at than others. It may not be the best code to learn from, but [borrowck] and [resolve] were written recently.\n@@ -29,6 +28,18 @@ You may also be interested in browsing [GitHub's Rust][github-rust] page.\n \n [github-rust]: https://github.com/trending?l=rust\n \n+## Is anyone using Rust in production?\n+\n+Currently, Rust is still pre-1.0, and so we don't recommend that you use Rust\n+in production unless you know exactly what you're getting into.\n+\n+That said, there are two production deployments of Rust that we're aware of:\n+\n+* [OpenDNS](http://labs.opendns.com/2013/10/04/zeromq-helping-us-block-malicious-domains/)\n+* [Skylight](http://skylight.io)\n+\n+Let the fact that this is an easily countable number be a warning.\n+\n ## Does it run on Windows?\n \n Yes. All development happens in lock-step on all 3 target platforms. Using MinGW, not Cygwin. Note that the windows implementation currently has some limitations: in particular 64-bit build is [not fully supported yet][win64], and all executables created by rustc [depend on libgcc DLL at runtime][libgcc]."}, {"sha": "66faee3fa04c802e1ea199603477d95c71ae387e", "filename": "src/doc/guide-lifetimes.md", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Fdoc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Fdoc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-lifetimes.md?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -431,36 +431,6 @@ In any case, whatever the lifetime of `r` is, the pointer produced by\n field of a struct is valid as long as the struct is valid. Therefore,\n the compiler accepts the function `get_x()`.\n \n-To emphasize this point, let\u2019s look at a variation on the example, this\n-time one that does not compile:\n-\n-~~~ {.ignore}\n-struct Point {x: f64, y: f64}\n-fn get_x_sh(p: &Point) -> &f64 {\n-    &p.x // Error reported here\n-}\n-~~~\n-\n-Here, the function `get_x_sh()` takes a reference as input and\n-returns a reference. As before, the lifetime of the reference\n-that will be returned is a parameter (specified by the\n-caller). That means that `get_x_sh()` promises to return a reference\n-that is valid for as long as the caller would like: this is\n-subtly different from the first example, which promised to return a\n-pointer that was valid for as long as its pointer argument was valid.\n-\n-Within `get_x_sh()`, we see the expression `&p.x` which takes the\n-address of a field of a Point. The presence of this expression\n-implies that the compiler must guarantee that , so long as the\n-resulting pointer is valid, the original Point won't be moved or changed.\n-\n-But recall that `get_x_sh()` also promised to\n-return a pointer that was valid for as long as the caller wanted it to\n-be. Clearly, `get_x_sh()` is not in a position to make both of these\n-guarantees; in fact, it cannot guarantee that the pointer will remain\n-valid at all once it returns, as the parameter `p` may or may not be\n-live in the caller. Therefore, the compiler will report an error here.\n-\n In general, if you borrow a struct or box to create a\n reference, it will only be valid within the function\n and cannot be returned. This is why the typical way to return references"}, {"sha": "8dca82cc087c874cf226716781a7323049431056", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -578,12 +578,12 @@ fn main() {\n \n Notice we changed the signature of `add_one()` to request a mutable reference.\n \n-# Best practices\n+## Best practices\n \n Boxes are appropriate to use in two situations: Recursive data structures,\n and occasionally, when returning data.\n \n-## Recursive data structures\n+### Recursive data structures\n \n Sometimes, you need a recursive data structure. The simplest is known as a\n 'cons list':\n@@ -615,7 +615,7 @@ we don't know the size, and therefore, we need to heap allocate our list.\n Working with recursive or other unknown-sized data structures is the primary\n use-case for boxes.\n \n-## Returning data\n+### Returning data\n \n This is important enough to have its own section entirely. The TL;DR is this:\n you don't generally want to return pointers, even when you might in a language\n@@ -733,18 +733,15 @@ This part is coming soon.\n \n Here's a quick rundown of Rust's pointer types:\n \n-| Type         | Name                | Summary                                   |\n-|--------------|---------------------|-------------------------------------------|\n-| `&T`         | Reference           | Allows one or more references to read `T` |\n-| `&mut T`     | Mutable Reference   | Allows a single reference to              |\n-|              |                     | read and write `T`                        |\n-| `Box<T>`     | Box                 | Heap allocated `T` with a single owner    |\n-|              |                     | that may read and write `T`.              |\n-| `Rc<T>`      | \"arr cee\" pointer   | Heap allocated `T` with many readers      |\n-| `Arc<T>`     | Arc pointer         | Same as above, but safe sharing across    |\n-|              |                     | threads                                   |\n-| `*const T`   | Raw pointer         | Unsafe read access to `T`                 |\n-| `*mut T`     | Mutable raw pointer | Unsafe read and write access to `T`       |\n+| Type         | Name                | Summary                                                             |\n+|--------------|---------------------|---------------------------------------------------------------------|\n+| `&T`         | Reference           | Allows one or more references to read `T`                           |\n+| `&mut T`     | Mutable Reference   | Allows a single reference to read and write `T`                     |\n+| `Box<T>`     | Box                 | Heap allocated `T` with a single owner that may read and write `T`. |\n+| `Rc<T>`      | \"arr cee\" pointer   | Heap allocated `T` with many readers                                |\n+| `Arc<T>`     | Arc pointer         | Same as above, but safe sharing across threads                      |\n+| `*const T`   | Raw pointer         | Unsafe read access to `T`                                           |\n+| `*mut T`     | Mutable raw pointer | Unsafe read and write access to `T`                                 |\n \n # Related resources\n "}, {"sha": "b0ce038cf572204dd2c9d1c8f59e1969092544ab", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -1503,7 +1503,7 @@ reference. We also call this _borrowing_ the local variable\n `on_the_stack`, because we are creating an alias: that is, another\n route to the same data.\n \n-Likewise, in the case of `owned_box`,\n+Likewise, in the case of `on_the_heap`,\n the `&` operator is used in conjunction with the `*` operator\n to take a reference to the contents of the box.\n "}, {"sha": "35914aa354159ea07caf43f2cf981f81a7f2abe7", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -226,7 +226,7 @@ impl<T: Clone> Rc<T> {\n     /// data is cloned if the reference count is greater than one.\n     #[inline]\n     #[experimental]\n-    pub fn make_unique<'a>(&'a mut self) -> &'a mut T {\n+    pub fn make_unique(&mut self) -> &mut T {\n         // Note that we hold a strong reference, which also counts as\n         // a weak reference, so we only clone if there is an\n         // additional reference of either kind.\n@@ -247,7 +247,7 @@ impl<T: Clone> Rc<T> {\n impl<T> Deref<T> for Rc<T> {\n     /// Borrow the value contained in the reference-counted box\n     #[inline(always)]\n-    fn deref<'a>(&'a self) -> &'a T {\n+    fn deref(&self) -> &T {\n         &self.inner().value\n     }\n }\n@@ -390,7 +390,7 @@ impl<T> Clone for Weak<T> {\n \n #[doc(hidden)]\n trait RcBoxPtr<T> {\n-    fn inner<'a>(&'a self) -> &'a RcBox<T>;\n+    fn inner(&self) -> &RcBox<T>;\n \n     #[inline]\n     fn strong(&self) -> uint { self.inner().strong.get() }\n@@ -413,12 +413,12 @@ trait RcBoxPtr<T> {\n \n impl<T> RcBoxPtr<T> for Rc<T> {\n     #[inline(always)]\n-    fn inner<'a>(&'a self) -> &'a RcBox<T> { unsafe { &(*self._ptr) } }\n+    fn inner(&self) -> &RcBox<T> { unsafe { &(*self._ptr) } }\n }\n \n impl<T> RcBoxPtr<T> for Weak<T> {\n     #[inline(always)]\n-    fn inner<'a>(&'a self) -> &'a RcBox<T> { unsafe { &(*self._ptr) } }\n+    fn inner(&self) -> &RcBox<T> { unsafe { &(*self._ptr) } }\n }\n \n #[cfg(test)]"}, {"sha": "5d316cdb51e37ab2f25ac883d64de1290e924d5b", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -207,7 +207,7 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_copy<'a, T>(&'a self, op: || -> T) -> &'a T {\n+    fn alloc_copy<T>(&self, op: || -> T) -> &T {\n         unsafe {\n             let ptr = self.alloc_copy_inner(mem::size_of::<T>(),\n                                             mem::min_align_of::<T>());\n@@ -261,7 +261,7 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_noncopy<'a, T>(&'a self, op: || -> T) -> &'a T {\n+    fn alloc_noncopy<T>(&self, op: || -> T) -> &T {\n         unsafe {\n             let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n@@ -285,7 +285,7 @@ impl Arena {\n     /// Allocate a new item in the arena, using `op` to initialize the value\n     /// and returning a reference to it.\n     #[inline]\n-    pub fn alloc<'a, T>(&'a self, op: || -> T) -> &'a T {\n+    pub fn alloc<T>(&self, op: || -> T) -> &T {\n         unsafe {\n             if intrinsics::needs_drop::<T>() {\n                 self.alloc_noncopy(op)\n@@ -458,13 +458,13 @@ impl<T> TypedArena<T> {\n \n     /// Allocates an object in the TypedArena, returning a reference to it.\n     #[inline]\n-    pub fn alloc<'a>(&'a self, object: T) -> &'a T {\n+    pub fn alloc(&self, object: T) -> &T {\n         if self.ptr == self.end {\n             self.grow()\n         }\n \n-        let ptr: &'a T = unsafe {\n-            let ptr: &'a mut T = mem::transmute(self.ptr);\n+        let ptr: &T = unsafe {\n+            let ptr: &mut T = mem::transmute(self.ptr);\n             ptr::write(ptr, object);\n             self.ptr.set(self.ptr.get().offset(1));\n             ptr"}, {"sha": "3f739b86a1b0975a2ee03a1cd6ce1feae00da50f", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -149,7 +149,7 @@ impl PartialOrd for Ordering {\n /// If the first ordering is different, the first ordering is all that must be returned.\n /// If the first ordering is equal, then second ordering is returned.\n #[inline]\n-#[deprecated = \"Just call .cmp() on an Ordering\"]\n+#[deprecated = \"Just call .cmp() on a tuple\"]\n pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n     match o1 {\n         Equal => o2,"}, {"sha": "f5cfa2611d5e66ef260a07d4be8a7aca05714bc4", "filename": "src/libcore/failure.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibcore%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibcore%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffailure.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -16,7 +16,7 @@\n //! interface for failure is:\n //!\n //! ```ignore\n-//! fn begin_unwind(fmt: &fmt::Arguments, file: &str, line: uint) -> !;\n+//! fn begin_unwind(fmt: &fmt::Arguments, &(&'static str, uint)) -> !;\n //! ```\n //!\n //! This definition allows for failing with any general message, but it does not\n@@ -33,6 +33,7 @@\n use fmt;\n use intrinsics;\n \n+#[cfg(stage0)]\n #[cold] #[inline(never)] // this is the slow path, always\n #[lang=\"fail_\"]\n fn fail_(expr: &'static str, file: &'static str, line: uint) -> ! {\n@@ -43,6 +44,7 @@ fn fail_(expr: &'static str, file: &'static str, line: uint) -> ! {\n     unsafe { intrinsics::abort() }\n }\n \n+#[cfg(stage0)]\n #[cold]\n #[lang=\"fail_bounds_check\"]\n fn fail_bounds_check(file: &'static str, line: uint,\n@@ -53,7 +55,31 @@ fn fail_bounds_check(file: &'static str, line: uint,\n     unsafe { intrinsics::abort() }\n }\n \n-#[cold]\n+#[cfg(not(stage0))]\n+#[cold] #[inline(never)] // this is the slow path, always\n+#[lang=\"fail_\"]\n+fn fail_(expr_file_line: &(&'static str, &'static str, uint)) -> ! {\n+    let (expr, file, line) = *expr_file_line;\n+    let ref file_line = (file, line);\n+    format_args!(|args| -> () {\n+        begin_unwind(args, file_line);\n+    }, \"{}\", expr);\n+\n+    unsafe { intrinsics::abort() }\n+}\n+\n+#[cfg(not(stage0))]\n+#[cold] #[inline(never)]\n+#[lang=\"fail_bounds_check\"]\n+fn fail_bounds_check(file_line: &(&'static str, uint),\n+                     index: uint, len: uint) -> ! {\n+    format_args!(|args| -> () {\n+        begin_unwind(args, file_line);\n+    }, \"index out of bounds: the len is {} but the index is {}\", len, index);\n+    unsafe { intrinsics::abort() }\n+}\n+\n+#[cold] #[inline(never)]\n pub fn begin_unwind(fmt: &fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n     #[allow(ctypes)]\n     extern {"}, {"sha": "f8293aeb03d1910651677ceb44175a797730e9ab", "filename": "src/libcore/option.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -143,6 +143,7 @@\n \n use cmp::{PartialEq, Eq, Ord};\n use default::Default;\n+use slice::Vector;\n use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};\n use mem;\n use slice;\n@@ -216,15 +217,6 @@ impl<T> Option<T> {\n         match *self { Some(ref mut x) => Some(x), None => None }\n     }\n \n-    /// Convert from `Option<T>` to `&[T]` (without copying)\n-    #[inline]\n-    pub fn as_slice<'r>(&'r self) -> &'r [T] {\n-        match *self {\n-            Some(ref x) => slice::ref_slice(x),\n-            None => &[]\n-        }\n-    }\n-\n     /// Convert from `Option<T>` to `&mut [T]` (without copying)\n     #[inline]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n@@ -526,6 +518,17 @@ impl<T: Default> Option<T> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n+impl<T> Vector<T> for Option<T> {\n+    /// Convert from `Option<T>` to `&[T]` (without copying)\n+    #[inline]\n+    fn as_slice<'a>(&'a self) -> &'a [T] {\n+        match *self {\n+            Some(ref x) => slice::ref_slice(x),\n+            None => &[]\n+        }\n+    }\n+}\n+\n impl<T> Default for Option<T> {\n     #[inline]\n     fn default() -> Option<T> { None }"}, {"sha": "4596c98cffdedb0f475bec7d022a7c32de5fd898", "filename": "src/libfourcc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibfourcc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibfourcc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfourcc%2Flib.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -40,7 +40,8 @@ fn main() {\n */\n \n #![crate_name = \"fourcc\"]\n-#![experimental]\n+#![deprecated = \"This is now a cargo package located at: \\\n+                 https://github.com/rust-lang/fourcc\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![license = \"MIT/ASL2\"]"}, {"sha": "9adeeb2e4c9241997a3da22806604f26e9b225c5", "filename": "src/libhexfloat/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -37,7 +37,8 @@ fn main() {\n */\n \n #![crate_name = \"hexfloat\"]\n-#![experimental]\n+#![deprecated = \"This is now a cargo package located at: \\\n+                 https://github.com/rust-lang/hexfloat\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![license = \"MIT/ASL2\"]"}, {"sha": "9ab163c5f474055fdb80ecc54ff25205111e0c88", "filename": "src/librbml/io.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -39,7 +39,7 @@ fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64>\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::SeekableMemWriter;\n+/// use rbml::io::SeekableMemWriter;\n ///\n /// let mut w = SeekableMemWriter::new();\n /// w.write([0, 1, 2]);\n@@ -128,6 +128,7 @@ impl Seek for SeekableMemWriter {\n \n #[cfg(test)]\n mod tests {\n+    extern crate test;\n     use super::SeekableMemWriter;\n     use std::io;\n     use test::Bencher;", "previous_filename": "src/librustc/util/io.rs"}, {"sha": "f77d36d1e0648fa6e7dde3d3cdb586e023ba4d1e", "filename": "src/librbml/lib.rs", "status": "renamed", "additions": 38, "deletions": 134, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -8,16 +8,35 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Really Bad Markup Language (rbml) is a temporary measure until we migrate\n+//! the rust object metadata to a better serialization format. It is not\n+//! intended to be used by users.\n+//!\n+//! It is loosely based on the Extensible Binary Markup Language (ebml):\n+//!     http://www.matroska.org/technical/specs/rfc/index.html\n+\n+#![crate_name = \"rbml\"]\n+#![experimental]\n+#![crate_type = \"rlib\"]\n+#![crate_type = \"dylib\"]\n+#![license = \"MIT/ASL2\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+       html_root_url = \"http://doc.rust-lang.org/master/\",\n+       html_playground_url = \"http://play.rust-lang.org/\")]\n+#![feature(macro_rules, phase)]\n #![allow(missing_doc)]\n \n-use std::io;\n+extern crate serialize;\n+\n+#[phase(plugin, link)] extern crate log;\n+#[cfg(test)] extern crate test;\n+\n use std::str;\n \n-// Simple Extensible Binary Markup Language (ebml) reader and writer on a\n-// cursor model. See the specification here:\n-//     http://www.matroska.org/technical/specs/rfc/index.html\n+pub mod io;\n \n-// Common data structures\n+/// Common data structures\n #[deriving(Clone)]\n pub struct Doc<'a> {\n     pub data: &'a [u8],\n@@ -86,7 +105,7 @@ pub enum EbmlEncoderTag {\n pub enum Error {\n     IntTooBig(uint),\n     Expected(String),\n-    IoError(io::IoError)\n+    IoError(std::io::IoError)\n }\n // --------------------------------------\n \n@@ -107,7 +126,7 @@ pub mod reader {\n         Expected };\n \n     pub type DecodeResult<T> = Result<T, Error>;\n-    // ebml reading\n+    // rbml reading\n \n     macro_rules! try_or(\n         ($e:expr, $r:expr) => (\n@@ -637,7 +656,7 @@ pub mod writer {\n \n     pub type EncodeResult = io::IoResult<()>;\n \n-    // ebml writing\n+    // rbml writing\n     pub struct Encoder<'a, W> {\n         pub writer: &'a mut W,\n         size_positions: Vec<uint>,\n@@ -671,7 +690,7 @@ pub mod writer {\n         })\n     }\n \n-    // FIXME (#2741): Provide a function to write the standard ebml header.\n+    // FIXME (#2741): Provide a function to write the standard rbml header.\n     impl<'a, W: Writer + Seek> Encoder<'a, W> {\n         pub fn new(w: &'a mut W) -> Encoder<'a, W> {\n             Encoder {\n@@ -1018,130 +1037,16 @@ pub mod writer {\n \n #[cfg(test)]\n mod tests {\n-    use super::Doc;\n-    use ebml::reader;\n-    use ebml::writer;\n-    use {Encodable, Decodable};\n+    use super::{Doc, reader, writer};\n+    use super::io::SeekableMemWriter;\n+\n+    use serialize::{Encodable, Decodable};\n \n     use std::io::{IoError, IoResult, SeekStyle};\n     use std::io;\n     use std::option::{None, Option, Some};\n     use std::slice;\n \n-    static BUF_CAPACITY: uint = 128;\n-\n-    fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n-        // compute offset as signed and clamp to prevent overflow\n-        let pos = match seek {\n-            io::SeekSet => 0,\n-            io::SeekEnd => end,\n-            io::SeekCur => cur,\n-        } as i64;\n-\n-        if offset + pos < 0 {\n-            Err(IoError {\n-                kind: io::InvalidInput,\n-                desc: \"invalid seek to a negative offset\",\n-                detail: None\n-            })\n-        } else {\n-            Ok((offset + pos) as u64)\n-        }\n-    }\n-\n-    /// Writes to an owned, growable byte vector that supports seeking.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![allow(unused_must_use)]\n-    /// use std::io::SeekableMemWriter;\n-    ///\n-    /// let mut w = SeekableMemWriter::new();\n-    /// w.write([0, 1, 2]);\n-    ///\n-    /// assert_eq!(w.unwrap(), vec!(0, 1, 2));\n-    /// ```\n-    pub struct SeekableMemWriter {\n-        buf: Vec<u8>,\n-        pos: uint,\n-    }\n-\n-    impl SeekableMemWriter {\n-        /// Create a new `SeekableMemWriter`.\n-        #[inline]\n-        pub fn new() -> SeekableMemWriter {\n-            SeekableMemWriter::with_capacity(BUF_CAPACITY)\n-        }\n-        /// Create a new `SeekableMemWriter`, allocating at least `n` bytes for\n-        /// the internal buffer.\n-        #[inline]\n-        pub fn with_capacity(n: uint) -> SeekableMemWriter {\n-            SeekableMemWriter { buf: Vec::with_capacity(n), pos: 0 }\n-        }\n-\n-        /// Acquires an immutable reference to the underlying buffer of this\n-        /// `SeekableMemWriter`.\n-        ///\n-        /// No method is exposed for acquiring a mutable reference to the buffer\n-        /// because it could corrupt the state of this `MemWriter`.\n-        #[inline]\n-        pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n-\n-        /// Unwraps this `SeekableMemWriter`, returning the underlying buffer\n-        #[inline]\n-        pub fn unwrap(self) -> Vec<u8> { self.buf }\n-    }\n-\n-    impl Writer for SeekableMemWriter {\n-        #[inline]\n-        fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-            if self.pos == self.buf.len() {\n-                self.buf.push_all(buf)\n-            } else {\n-                // Make sure the internal buffer is as least as big as where we\n-                // currently are\n-                let difference = self.pos as i64 - self.buf.len() as i64;\n-                if difference > 0 {\n-                    self.buf.grow(difference as uint, &0);\n-                }\n-\n-                // Figure out what bytes will be used to overwrite what's currently\n-                // there (left), and what will be appended on the end (right)\n-                let cap = self.buf.len() - self.pos;\n-                let (left, right) = if cap <= buf.len() {\n-                    (buf.slice_to(cap), buf.slice_from(cap))\n-                } else {\n-                    (buf, &[])\n-                };\n-\n-                // Do the necessary writes\n-                if left.len() > 0 {\n-                    slice::bytes::copy_memory(self.buf.mut_slice_from(self.pos), left);\n-                }\n-                if right.len() > 0 {\n-                    self.buf.push_all(right);\n-                }\n-            }\n-\n-            // Bump us forward\n-            self.pos += buf.len();\n-            Ok(())\n-        }\n-    }\n-\n-    impl Seek for SeekableMemWriter {\n-        #[inline]\n-        fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-\n-        #[inline]\n-        fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-            let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-            self.pos = new as uint;\n-            Ok(())\n-        }\n-    }\n-\n     #[test]\n     fn test_vuint_at() {\n         let data = [\n@@ -1196,11 +1101,11 @@ mod tests {\n             debug!(\"v == {}\", v);\n             let mut wr = SeekableMemWriter::new();\n             {\n-                let mut ebml_w = writer::Encoder::new(&mut wr);\n-                let _ = v.encode(&mut ebml_w);\n+                let mut rbml_w = writer::Encoder::new(&mut wr);\n+                let _ = v.encode(&mut rbml_w);\n             }\n-            let ebml_doc = Doc::new(wr.get_ref());\n-            let mut deser = reader::Decoder::new(ebml_doc);\n+            let rbml_doc = Doc::new(wr.get_ref());\n+            let mut deser = reader::Decoder::new(rbml_doc);\n             let v1 = Decodable::decode(&mut deser).unwrap();\n             debug!(\"v1 == {}\", v1);\n             assert_eq!(v, v1);\n@@ -1215,9 +1120,8 @@ mod tests {\n #[cfg(test)]\n mod bench {\n     #![allow(non_snake_case_functions)]\n-    extern crate test;\n-    use self::test::Bencher;\n-    use ebml::reader;\n+    use test::Bencher;\n+    use super::reader;\n \n     #[bench]\n     pub fn vuint_at_A_aligned(b: &mut Bencher) {", "previous_filename": "src/libserialize/ebml.rs"}, {"sha": "f9774e83e8a1c19c905db648c59db95d49374333", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -44,6 +44,7 @@ extern crate libc;\n extern crate llvm = \"rustc_llvm\";\n extern crate rustc_back = \"rustc_back\";\n extern crate serialize;\n+extern crate rbml;\n extern crate time;\n #[phase(plugin, link)] extern crate log;\n #[phase(plugin, link)] extern crate syntax;\n@@ -132,7 +133,6 @@ pub mod util {\n \n     pub mod common;\n     pub mod ppaux;\n-    pub mod io;\n     pub mod nodemap;\n }\n "}, {"sha": "252d19bbb237b838cab6db360de0bcc8b1e3c018", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -20,8 +20,8 @@ use middle::ty;\n use middle::typeck;\n use middle::subst::VecPerParamSpace;\n \n-use serialize::ebml;\n-use serialize::ebml::reader;\n+use rbml;\n+use rbml::reader;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::ast_map;\n@@ -218,7 +218,7 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n                       def: ast::DefId) -> ty::Polytype {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(class_id.krate);\n-    let all_items = reader::get_doc(ebml::Doc::new(cdata.data()), tag_items);\n+    let all_items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n     let class_doc = expect(tcx.sess.diagnostic(),\n                            decoder::maybe_find_item(class_id.node, all_items),\n                            || {"}, {"sha": "c9807a18383e8ef5bc932222cfb55f306e44b121", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -37,8 +37,8 @@ use std::io;\n use std::collections::hashmap::HashMap;\n use std::rc::Rc;\n use std::u64;\n-use serialize::ebml::reader;\n-use serialize::ebml;\n+use rbml::reader;\n+use rbml;\n use serialize::Decodable;\n use syntax::ast_map;\n use syntax::attr;\n@@ -56,8 +56,8 @@ pub type Cmd<'a> = &'a crate_metadata;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash<'a>(d: ebml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n-                   hash: u64) -> Option<ebml::Doc<'a>> {\n+fn lookup_hash<'a>(d: rbml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n+                   hash: u64) -> Option<rbml::Doc<'a>> {\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + (hash % 256 * 4) as uint;\n@@ -80,7 +80,7 @@ fn lookup_hash<'a>(d: ebml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n }\n \n pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n-                           items: ebml::Doc<'a>) -> Option<ebml::Doc<'a>> {\n+                           items: rbml::Doc<'a>) -> Option<rbml::Doc<'a>> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n         return u64_from_be_bytes(\n             bytes.slice(0u, 4u), 0u, 4u) as ast::NodeId\n@@ -91,17 +91,17 @@ pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n                 hash::hash(&(item_id as i64)))\n }\n \n-fn find_item<'a>(item_id: ast::NodeId, items: ebml::Doc<'a>) -> ebml::Doc<'a> {\n+fn find_item<'a>(item_id: ast::NodeId, items: rbml::Doc<'a>) -> rbml::Doc<'a> {\n     match maybe_find_item(item_id, items) {\n        None => fail!(\"lookup_item: id not found: {}\", item_id),\n        Some(d) => d\n     }\n }\n \n-// Looks up an item in the given metadata and returns an ebml doc pointing\n+// Looks up an item in the given metadata and returns an rbml doc pointing\n // to the item data.\n-fn lookup_item<'a>(item_id: ast::NodeId, data: &'a [u8]) -> ebml::Doc<'a> {\n-    let items = reader::get_doc(ebml::Doc::new(data), tag_items);\n+fn lookup_item<'a>(item_id: ast::NodeId, data: &'a [u8]) -> rbml::Doc<'a> {\n+    let items = reader::get_doc(rbml::Doc::new(data), tag_items);\n     find_item(item_id, items)\n }\n \n@@ -127,7 +127,7 @@ enum Family {\n     InheritedField         // N\n }\n \n-fn item_family(item: ebml::Doc) -> Family {\n+fn item_family(item: rbml::Doc) -> Family {\n     let fam = reader::get_doc(item, tag_items_data_item_family);\n     match reader::doc_as_u8(fam) as char {\n       'c' => ImmStatic,\n@@ -152,7 +152,7 @@ fn item_family(item: ebml::Doc) -> Family {\n     }\n }\n \n-fn item_visibility(item: ebml::Doc) -> ast::Visibility {\n+fn item_visibility(item: rbml::Doc) -> ast::Visibility {\n     match reader::maybe_get_doc(item, tag_items_data_item_visibility) {\n         None => ast::Public,\n         Some(visibility_doc) => {\n@@ -165,7 +165,7 @@ fn item_visibility(item: ebml::Doc) -> ast::Visibility {\n     }\n }\n \n-fn item_method_sort(item: ebml::Doc) -> char {\n+fn item_method_sort(item: rbml::Doc) -> char {\n     let mut ret = 'r';\n     reader::tagged_docs(item, tag_item_trait_method_sort, |doc| {\n         ret = doc.as_str_slice().as_bytes()[0] as char;\n@@ -174,11 +174,11 @@ fn item_method_sort(item: ebml::Doc) -> char {\n     ret\n }\n \n-fn item_symbol(item: ebml::Doc) -> String {\n+fn item_symbol(item: rbml::Doc) -> String {\n     reader::get_doc(item, tag_items_data_item_symbol).as_str().to_string()\n }\n \n-fn item_parent_item(d: ebml::Doc) -> Option<ast::DefId> {\n+fn item_parent_item(d: rbml::Doc) -> Option<ast::DefId> {\n     let mut ret = None;\n     reader::tagged_docs(d, tag_items_data_parent_item, |did| {\n         ret = Some(reader::with_doc_data(did, parse_def_id));\n@@ -188,60 +188,60 @@ fn item_parent_item(d: ebml::Doc) -> Option<ast::DefId> {\n }\n \n fn item_reqd_and_translated_parent_item(cnum: ast::CrateNum,\n-                                        d: ebml::Doc) -> ast::DefId {\n+                                        d: rbml::Doc) -> ast::DefId {\n     let trait_did = item_parent_item(d).expect(\"item without parent\");\n     ast::DefId { krate: cnum, node: trait_did.node }\n }\n \n-fn item_def_id(d: ebml::Doc, cdata: Cmd) -> ast::DefId {\n+fn item_def_id(d: rbml::Doc, cdata: Cmd) -> ast::DefId {\n     let tagdoc = reader::get_doc(d, tag_def_id);\n     return translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n }\n \n-fn get_provided_source(d: ebml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n+fn get_provided_source(d: rbml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n     reader::maybe_get_doc(d, tag_item_method_provided_source).map(|doc| {\n         translate_def_id(cdata, reader::with_doc_data(doc, parse_def_id))\n     })\n }\n \n-fn each_reexport(d: ebml::Doc, f: |ebml::Doc| -> bool) -> bool {\n+fn each_reexport(d: rbml::Doc, f: |rbml::Doc| -> bool) -> bool {\n     reader::tagged_docs(d, tag_items_data_item_reexport, f)\n }\n \n-fn variant_disr_val(d: ebml::Doc) -> Option<ty::Disr> {\n+fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n     reader::maybe_get_doc(d, tag_disr_val).and_then(|val_doc| {\n         reader::with_doc_data(val_doc, |data| u64::parse_bytes(data, 10u))\n     })\n }\n \n-fn doc_type(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::t {\n+fn doc_type(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::t {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n     parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                   |_, did| translate_def_id(cdata, did))\n }\n \n-fn doc_method_fty(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::BareFnTy {\n+fn doc_method_fty(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::BareFnTy {\n     let tp = reader::get_doc(doc, tag_item_method_fty);\n     parse_bare_fn_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                           |_, did| translate_def_id(cdata, did))\n }\n \n-pub fn item_type(_item_id: ast::DefId, item: ebml::Doc,\n+pub fn item_type(_item_id: ast::DefId, item: rbml::Doc,\n                  tcx: &ty::ctxt, cdata: Cmd) -> ty::t {\n     doc_type(item, tcx, cdata)\n }\n \n-fn doc_trait_ref(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n+fn doc_trait_ref(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n     parse_trait_ref_data(doc.data, cdata.cnum, doc.start, tcx,\n                          |_, did| translate_def_id(cdata, did))\n }\n \n-fn item_trait_ref(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n+fn item_trait_ref(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n     let tp = reader::get_doc(doc, tag_item_trait_ref);\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn item_ty_param_defs(item: ebml::Doc,\n+fn item_ty_param_defs(item: rbml::Doc,\n                       tcx: &ty::ctxt,\n                       cdata: Cmd,\n                       tag: uint)\n@@ -257,7 +257,7 @@ fn item_ty_param_defs(item: ebml::Doc,\n     bounds\n }\n \n-fn item_region_param_defs(item_doc: ebml::Doc, cdata: Cmd)\n+fn item_region_param_defs(item_doc: rbml::Doc, cdata: Cmd)\n                           -> subst::VecPerParamSpace<ty::RegionParameterDef>\n {\n     let mut v = subst::VecPerParamSpace::empty();\n@@ -285,7 +285,7 @@ fn item_region_param_defs(item_doc: ebml::Doc, cdata: Cmd)\n     v\n }\n \n-fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n+fn enum_variant_ids(item: rbml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n     let mut ids: Vec<ast::DefId> = Vec::new();\n     let v = tag_items_data_item_variant;\n     reader::tagged_docs(item, v, |p| {\n@@ -296,7 +296,7 @@ fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n     return ids;\n }\n \n-fn item_path(item_doc: ebml::Doc) -> Vec<ast_map::PathElem> {\n+fn item_path(item_doc: rbml::Doc) -> Vec<ast_map::PathElem> {\n     let path_doc = reader::get_doc(item_doc, tag_path);\n \n     let len_doc = reader::get_doc(path_doc, tag_path_len);\n@@ -319,7 +319,7 @@ fn item_path(item_doc: ebml::Doc) -> Vec<ast_map::PathElem> {\n     result\n }\n \n-fn item_name(intr: &IdentInterner, item: ebml::Doc) -> ast::Ident {\n+fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Ident {\n     let name = reader::get_doc(item, tag_paths_data_name);\n     let string = name.as_str_slice();\n     match intr.find_equiv(&string) {\n@@ -328,7 +328,7 @@ fn item_name(intr: &IdentInterner, item: ebml::Doc) -> ast::Ident {\n     }\n }\n \n-fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n+fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     -> DefLike {\n     let fam = item_family(item);\n     match fam {\n@@ -463,7 +463,7 @@ pub enum DefLike {\n \n /// Iterates over the language items in the given crate.\n pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n-    let root = ebml::Doc::new(cdata.data());\n+    let root = rbml::Doc::new(cdata.data());\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     reader::tagged_docs(lang_items, tag_lang_items_item, |item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n@@ -480,7 +480,7 @@ pub type GetCrateDataCb<'a> = |ast::CrateNum|: 'a -> Rc<crate_metadata>;\n \n fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n                                cdata: Cmd,\n-                               item_doc: ebml::Doc,\n+                               item_doc: rbml::Doc,\n                                get_crate_data: GetCrateDataCb,\n                                callback: |DefLike,\n                                           ast::Ident,\n@@ -503,7 +503,7 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n             None => cdata\n         };\n \n-        let other_crates_items = reader::get_doc(ebml::Doc::new(crate_data.data()), tag_items);\n+        let other_crates_items = reader::get_doc(rbml::Doc::new(crate_data.data()), tag_items);\n \n         // Get the item.\n         match maybe_find_item(child_def_id.node, other_crates_items) {\n@@ -531,7 +531,7 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n                                 |inherent_impl_def_id_doc| {\n         let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc,\n                                                cdata);\n-        let items = reader::get_doc(ebml::Doc::new(cdata.data()), tag_items);\n+        let items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n         match maybe_find_item(inherent_impl_def_id.node, items) {\n             None => {}\n             Some(inherent_impl_doc) => {\n@@ -596,7 +596,7 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n             None => cdata\n         };\n \n-        let other_crates_items = reader::get_doc(ebml::Doc::new(crate_data.data()), tag_items);\n+        let other_crates_items = reader::get_doc(rbml::Doc::new(crate_data.data()), tag_items);\n \n         // Get the item.\n         match maybe_find_item(child_def_id.node, other_crates_items) {\n@@ -623,7 +623,7 @@ pub fn each_child_of_item(intr: Rc<IdentInterner>,\n                           get_crate_data: GetCrateDataCb,\n                           callback: |DefLike, ast::Ident, ast::Visibility|) {\n     // Find the item.\n-    let root_doc = ebml::Doc::new(cdata.data());\n+    let root_doc = rbml::Doc::new(cdata.data());\n     let items = reader::get_doc(root_doc, tag_items);\n     let item_doc = match maybe_find_item(id, items) {\n         None => return,\n@@ -644,7 +644,7 @@ pub fn each_top_level_item_of_crate(intr: Rc<IdentInterner>,\n                                     callback: |DefLike,\n                                                ast::Ident,\n                                                ast::Visibility|) {\n-    let root_doc = ebml::Doc::new(cdata.data());\n+    let root_doc = rbml::Doc::new(cdata.data());\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n                                           tag_misc_info_crate_items);\n@@ -663,7 +663,7 @@ pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> Vec<ast_map::PathElem> {\n pub type DecodeInlinedItem<'a> = |cdata: Cmd,\n                                   tcx: &ty::ctxt,\n                                   path: Vec<ast_map::PathElem>,\n-                                  par_doc: ebml::Doc|: 'a\n+                                  par_doc: rbml::Doc|: 'a\n                                   -> Result<ast::InlinedItem, Vec<ast_map::PathElem> >;\n \n pub fn maybe_get_item_ast(cdata: Cmd, tcx: &ty::ctxt, id: ast::NodeId,\n@@ -693,7 +693,7 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: &ty::ctxt, id: ast::NodeId,\n pub fn get_enum_variants(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n                      tcx: &ty::ctxt) -> Vec<Rc<ty::VariantInfo>> {\n     let data = cdata.data();\n-    let items = reader::get_doc(ebml::Doc::new(data), tag_items);\n+    let items = reader::get_doc(rbml::Doc::new(data), tag_items);\n     let item = find_item(id, items);\n     let mut disr_val = 0;\n     enum_variant_ids(item, cdata).iter().map(|did| {\n@@ -725,7 +725,7 @@ pub fn get_enum_variants(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n     }).collect()\n }\n \n-fn get_explicit_self(item: ebml::Doc) -> ty::ExplicitSelfCategory {\n+fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n     fn get_mutability(ch: u8) -> ast::Mutability {\n         match ch as char {\n             'i' => ast::MutImmutable,\n@@ -965,7 +965,7 @@ pub fn get_item_attrs(cdata: Cmd,\n }\n \n pub fn get_struct_field_attrs(cdata: Cmd) -> HashMap<ast::NodeId, Vec<ast::Attribute>> {\n-    let data = ebml::Doc::new(cdata.data());\n+    let data = rbml::Doc::new(cdata.data());\n     let fields = reader::get_doc(data, tag_struct_fields);\n     let mut map = HashMap::new();\n     reader::tagged_docs(fields, tag_struct_field, |field| {\n@@ -1023,7 +1023,7 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n     result\n }\n \n-fn get_meta_items(md: ebml::Doc) -> Vec<Gc<ast::MetaItem>> {\n+fn get_meta_items(md: rbml::Doc) -> Vec<Gc<ast::MetaItem>> {\n     let mut items: Vec<Gc<ast::MetaItem>> = Vec::new();\n     reader::tagged_docs(md, tag_meta_item_word, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n@@ -1051,7 +1051,7 @@ fn get_meta_items(md: ebml::Doc) -> Vec<Gc<ast::MetaItem>> {\n     return items;\n }\n \n-fn get_attributes(md: ebml::Doc) -> Vec<ast::Attribute> {\n+fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n     let mut attrs: Vec<ast::Attribute> = Vec::new();\n     match reader::maybe_get_doc(md, tag_attributes) {\n       Some(attrs_d) => {\n@@ -1082,7 +1082,7 @@ fn get_attributes(md: ebml::Doc) -> Vec<ast::Attribute> {\n     return attrs;\n }\n \n-fn list_crate_attributes(md: ebml::Doc, hash: &Svh,\n+fn list_crate_attributes(md: rbml::Doc, hash: &Svh,\n                          out: &mut io::Writer) -> io::IoResult<()> {\n     try!(write!(out, \"=Crate Attributes ({})=\\n\", *hash));\n \n@@ -1095,7 +1095,7 @@ fn list_crate_attributes(md: ebml::Doc, hash: &Svh,\n }\n \n pub fn get_crate_attributes(data: &[u8]) -> Vec<ast::Attribute> {\n-    get_attributes(ebml::Doc::new(data))\n+    get_attributes(rbml::Doc::new(data))\n }\n \n #[deriving(Clone)]\n@@ -1107,10 +1107,10 @@ pub struct CrateDep {\n \n pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     let mut deps: Vec<CrateDep> = Vec::new();\n-    let cratedoc = ebml::Doc::new(data);\n+    let cratedoc = rbml::Doc::new(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n-    fn docstr(doc: ebml::Doc, tag_: uint) -> String {\n+    fn docstr(doc: rbml::Doc, tag_: uint) -> String {\n         let d = reader::get_doc(doc, tag_);\n         d.as_str_slice().to_string()\n     }\n@@ -1138,27 +1138,27 @@ fn list_crate_deps(data: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n }\n \n pub fn maybe_get_crate_hash(data: &[u8]) -> Option<Svh> {\n-    let cratedoc = ebml::Doc::new(data);\n+    let cratedoc = rbml::Doc::new(data);\n     reader::maybe_get_doc(cratedoc, tag_crate_hash).map(|doc| {\n         Svh::new(doc.as_str_slice())\n     })\n }\n \n pub fn get_crate_hash(data: &[u8]) -> Svh {\n-    let cratedoc = ebml::Doc::new(data);\n+    let cratedoc = rbml::Doc::new(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n     Svh::new(hashdoc.as_str_slice())\n }\n \n pub fn maybe_get_crate_name(data: &[u8]) -> Option<String> {\n-    let cratedoc = ebml::Doc::new(data);\n+    let cratedoc = rbml::Doc::new(data);\n     reader::maybe_get_doc(cratedoc, tag_crate_crate_name).map(|doc| {\n         doc.as_str_slice().to_string()\n     })\n }\n \n pub fn get_crate_triple(data: &[u8]) -> Option<String> {\n-    let cratedoc = ebml::Doc::new(data);\n+    let cratedoc = rbml::Doc::new(data);\n     let triple_doc = reader::maybe_get_doc(cratedoc, tag_crate_triple);\n     triple_doc.map(|s| s.as_str().to_string())\n }\n@@ -1169,7 +1169,7 @@ pub fn get_crate_name(data: &[u8]) -> String {\n \n pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n     let hash = get_crate_hash(bytes);\n-    let md = ebml::Doc::new(bytes);\n+    let md = rbml::Doc::new(bytes);\n     try!(list_crate_attributes(md, &hash, out));\n     list_crate_deps(bytes, out)\n }\n@@ -1196,7 +1196,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n }\n \n pub fn each_impl(cdata: Cmd, callback: |ast::DefId|) {\n-    let impls_doc = reader::get_doc(ebml::Doc::new(cdata.data()), tag_impls);\n+    let impls_doc = reader::get_doc(rbml::Doc::new(cdata.data()), tag_impls);\n     let _ = reader::tagged_docs(impls_doc, tag_impls_impl, |impl_doc| {\n         callback(item_def_id(impl_doc, cdata));\n         true\n@@ -1252,7 +1252,7 @@ pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n \n pub fn get_native_libraries(cdata: Cmd)\n                             -> Vec<(cstore::NativeLibaryKind, String)> {\n-    let libraries = reader::get_doc(ebml::Doc::new(cdata.data()),\n+    let libraries = reader::get_doc(rbml::Doc::new(cdata.data()),\n                                     tag_native_libraries);\n     let mut result = Vec::new();\n     reader::tagged_docs(libraries, tag_native_libraries_lib, |lib_doc| {\n@@ -1268,12 +1268,12 @@ pub fn get_native_libraries(cdata: Cmd)\n }\n \n pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n-    reader::maybe_get_doc(ebml::Doc::new(data), tag_plugin_registrar_fn)\n+    reader::maybe_get_doc(rbml::Doc::new(data), tag_plugin_registrar_fn)\n         .map(|doc| FromPrimitive::from_u32(reader::doc_as_u32(doc)).unwrap())\n }\n \n pub fn get_exported_macros(data: &[u8]) -> Vec<String> {\n-    let macros = reader::get_doc(ebml::Doc::new(data),\n+    let macros = reader::get_doc(rbml::Doc::new(data),\n                                  tag_exported_macros);\n     let mut result = Vec::new();\n     reader::tagged_docs(macros, tag_macro_def, |macro_doc| {\n@@ -1286,7 +1286,7 @@ pub fn get_exported_macros(data: &[u8]) -> Vec<String> {\n pub fn get_dylib_dependency_formats(cdata: Cmd)\n     -> Vec<(ast::CrateNum, cstore::LinkagePreference)>\n {\n-    let formats = reader::get_doc(ebml::Doc::new(cdata.data()),\n+    let formats = reader::get_doc(rbml::Doc::new(cdata.data()),\n                                   tag_dylib_dependency_formats);\n     let mut result = Vec::new();\n \n@@ -1312,7 +1312,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n pub fn get_missing_lang_items(cdata: Cmd)\n     -> Vec<lang_items::LangItem>\n {\n-    let items = reader::get_doc(ebml::Doc::new(cdata.data()), tag_lang_items);\n+    let items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_lang_items);\n     let mut result = Vec::new();\n     reader::tagged_docs(items, tag_lang_items_missing, |missing_doc| {\n         let item: lang_items::LangItem =\n@@ -1340,7 +1340,7 @@ pub fn get_method_arg_names(cdata: Cmd, id: ast::NodeId) -> Vec<String> {\n \n pub fn get_reachable_extern_fns(cdata: Cmd) -> Vec<ast::DefId> {\n     let mut ret = Vec::new();\n-    let items = reader::get_doc(ebml::Doc::new(cdata.data()),\n+    let items = reader::get_doc(rbml::Doc::new(cdata.data()),\n                                 tag_reachable_extern_fns);\n     reader::tagged_docs(items, tag_reachable_extern_fn_id, |doc| {\n         ret.push(ast::DefId {"}, {"sha": "6ede414e83758b5f7b801716619e7e46c4df739e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 613, "deletions": 618, "changes": 1231, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -26,7 +26,6 @@ use middle::ty;\n use middle::typeck;\n use middle::stability;\n use middle;\n-use util::io::SeekableMemWriter;\n use util::nodemap::{NodeMap, NodeSet};\n \n use serialize::Encodable;\n@@ -52,7 +51,8 @@ use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n use syntax;\n-use writer = serialize::ebml::writer;\n+use rbml::writer;\n+use rbml::io::SeekableMemWriter;\n \n /// A borrowed version of ast::InlinedItem.\n pub enum InlinedItemRef<'a> {\n@@ -64,7 +64,7 @@ pub enum InlinedItemRef<'a> {\n pub type Encoder<'a> = writer::Encoder<'a, SeekableMemWriter>;\n \n pub type EncodeInlinedItem<'a> = |ecx: &EncodeContext,\n-                                  ebml_w: &mut Encoder,\n+                                  rbml_w: &mut Encoder,\n                                   ii: InlinedItemRef|: 'a;\n \n pub struct EncodeParams<'a> {\n@@ -92,16 +92,16 @@ pub struct EncodeContext<'a> {\n     pub reachable: &'a NodeSet,\n }\n \n-fn encode_name(ebml_w: &mut Encoder, name: Name) {\n-    ebml_w.wr_tagged_str(tag_paths_data_name, token::get_name(name).get());\n+fn encode_name(rbml_w: &mut Encoder, name: Name) {\n+    rbml_w.wr_tagged_str(tag_paths_data_name, token::get_name(name).get());\n }\n \n-fn encode_impl_type_basename(ebml_w: &mut Encoder, name: Ident) {\n-    ebml_w.wr_tagged_str(tag_item_impl_type_basename, token::get_ident(name).get());\n+fn encode_impl_type_basename(rbml_w: &mut Encoder, name: Ident) {\n+    rbml_w.wr_tagged_str(tag_item_impl_type_basename, token::get_ident(name).get());\n }\n \n-pub fn encode_def_id(ebml_w: &mut Encoder, id: DefId) {\n-    ebml_w.wr_tagged_str(tag_def_id, def_to_string(id).as_slice());\n+pub fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n+    rbml_w.wr_tagged_str(tag_def_id, def_to_string(id).as_slice());\n }\n \n #[deriving(Clone)]\n@@ -110,7 +110,7 @@ struct entry<T> {\n     pos: u64\n }\n \n-fn encode_trait_ref(ebml_w: &mut Encoder,\n+fn encode_trait_ref(rbml_w: &mut Encoder,\n                     ecx: &EncodeContext,\n                     trait_ref: &ty::TraitRef,\n                     tag: uint) {\n@@ -121,31 +121,31 @@ fn encode_trait_ref(ebml_w: &mut Encoder,\n         abbrevs: &ecx.type_abbrevs\n     };\n \n-    ebml_w.start_tag(tag);\n-    tyencode::enc_trait_ref(ebml_w.writer, ty_str_ctxt, trait_ref);\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(tag);\n+    tyencode::enc_trait_ref(rbml_w.writer, ty_str_ctxt, trait_ref);\n+    rbml_w.end_tag();\n }\n \n-fn encode_impl_vtables(ebml_w: &mut Encoder,\n+fn encode_impl_vtables(rbml_w: &mut Encoder,\n                        ecx: &EncodeContext,\n                        vtables: &typeck::vtable_res) {\n-    ebml_w.start_tag(tag_item_impl_vtables);\n-    astencode::encode_vtable_res(ecx, ebml_w, vtables);\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(tag_item_impl_vtables);\n+    astencode::encode_vtable_res(ecx, rbml_w, vtables);\n+    rbml_w.end_tag();\n }\n \n // Item info table encoding\n-fn encode_family(ebml_w: &mut Encoder, c: char) {\n-    ebml_w.start_tag(tag_items_data_item_family);\n-    ebml_w.writer.write(&[c as u8]);\n-    ebml_w.end_tag();\n+fn encode_family(rbml_w: &mut Encoder, c: char) {\n+    rbml_w.start_tag(tag_items_data_item_family);\n+    rbml_w.writer.write(&[c as u8]);\n+    rbml_w.end_tag();\n }\n \n pub fn def_to_string(did: DefId) -> String {\n     format!(\"{}:{}\", did.krate, did.node)\n }\n \n-fn encode_ty_type_param_defs(ebml_w: &mut Encoder,\n+fn encode_ty_type_param_defs(rbml_w: &mut Encoder,\n                              ecx: &EncodeContext,\n                              params: &VecPerParamSpace<ty::TypeParameterDef>,\n                              tag: uint) {\n@@ -156,162 +156,162 @@ fn encode_ty_type_param_defs(ebml_w: &mut Encoder,\n         abbrevs: &ecx.type_abbrevs\n     };\n     for param in params.iter() {\n-        ebml_w.start_tag(tag);\n-        tyencode::enc_type_param_def(ebml_w.writer, ty_str_ctxt, param);\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag);\n+        tyencode::enc_type_param_def(rbml_w.writer, ty_str_ctxt, param);\n+        rbml_w.end_tag();\n     }\n }\n \n-fn encode_region_param_defs(ebml_w: &mut Encoder,\n+fn encode_region_param_defs(rbml_w: &mut Encoder,\n                             params: &VecPerParamSpace<ty::RegionParameterDef>) {\n     for param in params.iter() {\n-        ebml_w.start_tag(tag_region_param_def);\n+        rbml_w.start_tag(tag_region_param_def);\n \n-        ebml_w.start_tag(tag_region_param_def_ident);\n-        encode_name(ebml_w, param.name);\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_region_param_def_ident);\n+        encode_name(rbml_w, param.name);\n+        rbml_w.end_tag();\n \n-        ebml_w.wr_tagged_str(tag_region_param_def_def_id,\n+        rbml_w.wr_tagged_str(tag_region_param_def_def_id,\n                              def_to_string(param.def_id).as_slice());\n \n-        ebml_w.wr_tagged_u64(tag_region_param_def_space,\n+        rbml_w.wr_tagged_u64(tag_region_param_def_space,\n                              param.space.to_uint() as u64);\n \n-        ebml_w.wr_tagged_u64(tag_region_param_def_index,\n+        rbml_w.wr_tagged_u64(tag_region_param_def_index,\n                              param.index as u64);\n \n-        ebml_w.end_tag();\n+        rbml_w.end_tag();\n     }\n }\n \n-fn encode_item_variances(ebml_w: &mut Encoder,\n+fn encode_item_variances(rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n                          id: ast::NodeId) {\n     let v = ty::item_variances(ecx.tcx, ast_util::local_def(id));\n-    ebml_w.start_tag(tag_item_variances);\n-    v.encode(ebml_w);\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(tag_item_variances);\n+    v.encode(rbml_w);\n+    rbml_w.end_tag();\n }\n \n-fn encode_bounds_and_type(ebml_w: &mut Encoder,\n+fn encode_bounds_and_type(rbml_w: &mut Encoder,\n                           ecx: &EncodeContext,\n                           pty: &ty::Polytype) {\n-    encode_ty_type_param_defs(ebml_w, ecx, &pty.generics.types,\n+    encode_ty_type_param_defs(rbml_w, ecx, &pty.generics.types,\n                               tag_items_data_item_ty_param_bounds);\n-    encode_region_param_defs(ebml_w, &pty.generics.regions);\n-    encode_type(ecx, ebml_w, pty.ty);\n+    encode_region_param_defs(rbml_w, &pty.generics.regions);\n+    encode_type(ecx, rbml_w, pty.ty);\n }\n \n-fn encode_variant_id(ebml_w: &mut Encoder, vid: DefId) {\n-    ebml_w.start_tag(tag_items_data_item_variant);\n+fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n+    rbml_w.start_tag(tag_items_data_item_variant);\n     let s = def_to_string(vid);\n-    ebml_w.writer.write(s.as_bytes());\n-    ebml_w.end_tag();\n+    rbml_w.writer.write(s.as_bytes());\n+    rbml_w.end_tag();\n }\n \n pub fn write_closure_type(ecx: &EncodeContext,\n-                          ebml_w: &mut Encoder,\n+                          rbml_w: &mut Encoder,\n                           closure_type: &ty::ClosureTy) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_closure_ty(ebml_w.writer, ty_str_ctxt, closure_type);\n+    tyencode::enc_closure_ty(rbml_w.writer, ty_str_ctxt, closure_type);\n }\n \n pub fn write_type(ecx: &EncodeContext,\n-                  ebml_w: &mut Encoder,\n+                  rbml_w: &mut Encoder,\n                   typ: ty::t) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n+    tyencode::enc_ty(rbml_w.writer, ty_str_ctxt, typ);\n }\n \n fn encode_type(ecx: &EncodeContext,\n-               ebml_w: &mut Encoder,\n+               rbml_w: &mut Encoder,\n                typ: ty::t) {\n-    ebml_w.start_tag(tag_items_data_item_type);\n-    write_type(ecx, ebml_w, typ);\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(tag_items_data_item_type);\n+    write_type(ecx, rbml_w, typ);\n+    rbml_w.end_tag();\n }\n \n fn encode_method_fty(ecx: &EncodeContext,\n-                     ebml_w: &mut Encoder,\n+                     rbml_w: &mut Encoder,\n                      typ: &ty::BareFnTy) {\n-    ebml_w.start_tag(tag_item_method_fty);\n+    rbml_w.start_tag(tag_item_method_fty);\n \n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_bare_fn_ty(ebml_w.writer, ty_str_ctxt, typ);\n+    tyencode::enc_bare_fn_ty(rbml_w.writer, ty_str_ctxt, typ);\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_symbol(ecx: &EncodeContext,\n-                 ebml_w: &mut Encoder,\n+                 rbml_w: &mut Encoder,\n                  id: NodeId) {\n-    ebml_w.start_tag(tag_items_data_item_symbol);\n+    rbml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.borrow().find(&id) {\n         Some(x) => {\n             debug!(\"encode_symbol(id={:?}, str={})\", id, *x);\n-            ebml_w.writer.write(x.as_bytes());\n+            rbml_w.writer.write(x.as_bytes());\n         }\n         None => {\n             ecx.diag.handler().bug(\n                 format!(\"encode_symbol: id not found {}\", id).as_slice());\n         }\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_disr_val(_: &EncodeContext,\n-                   ebml_w: &mut Encoder,\n+                   rbml_w: &mut Encoder,\n                    disr_val: ty::Disr) {\n-    ebml_w.start_tag(tag_disr_val);\n+    rbml_w.start_tag(tag_disr_val);\n     let s = disr_val.to_string();\n-    ebml_w.writer.write(s.as_bytes());\n-    ebml_w.end_tag();\n+    rbml_w.writer.write(s.as_bytes());\n+    rbml_w.end_tag();\n }\n \n-fn encode_parent_item(ebml_w: &mut Encoder, id: DefId) {\n-    ebml_w.start_tag(tag_items_data_parent_item);\n+fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n+    rbml_w.start_tag(tag_items_data_parent_item);\n     let s = def_to_string(id);\n-    ebml_w.writer.write(s.as_bytes());\n-    ebml_w.end_tag();\n+    rbml_w.writer.write(s.as_bytes());\n+    rbml_w.end_tag();\n }\n \n-fn encode_struct_fields(ebml_w: &mut Encoder,\n+fn encode_struct_fields(rbml_w: &mut Encoder,\n                         fields: &[ty::field_ty],\n                         origin: DefId) {\n     for f in fields.iter() {\n         if f.name == special_idents::unnamed_field.name {\n-            ebml_w.start_tag(tag_item_unnamed_field);\n+            rbml_w.start_tag(tag_item_unnamed_field);\n         } else {\n-            ebml_w.start_tag(tag_item_field);\n-            encode_name(ebml_w, f.name);\n+            rbml_w.start_tag(tag_item_field);\n+            encode_name(rbml_w, f.name);\n         }\n-        encode_struct_field_family(ebml_w, f.vis);\n-        encode_def_id(ebml_w, f.id);\n-        ebml_w.start_tag(tag_item_field_origin);\n+        encode_struct_field_family(rbml_w, f.vis);\n+        encode_def_id(rbml_w, f.id);\n+        rbml_w.start_tag(tag_item_field_origin);\n         let s = def_to_string(origin);\n-        ebml_w.writer.write(s.as_bytes());\n-        ebml_w.end_tag();\n-        ebml_w.end_tag();\n+        rbml_w.writer.write(s.as_bytes());\n+        rbml_w.end_tag();\n+        rbml_w.end_tag();\n     }\n }\n \n fn encode_enum_variant_info(ecx: &EncodeContext,\n-                            ebml_w: &mut Encoder,\n+                            rbml_w: &mut Encoder,\n                             id: NodeId,\n                             variants: &[P<Variant>],\n                             index: &mut Vec<entry<i64>>) {\n@@ -325,82 +325,82 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         let def_id = local_def(variant.node.id);\n         index.push(entry {\n             val: variant.node.id as i64,\n-            pos: ebml_w.writer.tell().unwrap(),\n+            pos: rbml_w.writer.tell().unwrap(),\n         });\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n         match variant.node.kind {\n-            ast::TupleVariantKind(_) => encode_family(ebml_w, 'v'),\n-            ast::StructVariantKind(_) => encode_family(ebml_w, 'V')\n+            ast::TupleVariantKind(_) => encode_family(rbml_w, 'v'),\n+            ast::StructVariantKind(_) => encode_family(rbml_w, 'V')\n         }\n-        encode_name(ebml_w, variant.node.name.name);\n-        encode_parent_item(ebml_w, local_def(id));\n-        encode_visibility(ebml_w, variant.node.vis);\n-        encode_attributes(ebml_w, variant.node.attrs.as_slice());\n+        encode_name(rbml_w, variant.node.name.name);\n+        encode_parent_item(rbml_w, local_def(id));\n+        encode_visibility(rbml_w, variant.node.vis);\n+        encode_attributes(rbml_w, variant.node.attrs.as_slice());\n \n         let stab = stability::lookup(ecx.tcx, ast_util::local_def(variant.node.id));\n-        encode_stability(ebml_w, stab);\n+        encode_stability(rbml_w, stab);\n \n         match variant.node.kind {\n             ast::TupleVariantKind(_) => {},\n             ast::StructVariantKind(_) => {\n                 let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n                 let idx = encode_info_for_struct(ecx,\n-                                                 ebml_w,\n+                                                 rbml_w,\n                                                  fields.as_slice(),\n                                                  index);\n-                encode_struct_fields(ebml_w, fields.as_slice(), def_id);\n-                encode_index(ebml_w, idx, write_i64);\n+                encode_struct_fields(rbml_w, fields.as_slice(), def_id);\n+                encode_index(rbml_w, idx, write_i64);\n             }\n         }\n         if vi.get(i).disr_val != disr_val {\n-            encode_disr_val(ecx, ebml_w, vi.get(i).disr_val);\n+            encode_disr_val(ecx, rbml_w, vi.get(i).disr_val);\n             disr_val = vi.get(i).disr_val;\n         }\n-        encode_bounds_and_type(ebml_w, ecx,\n+        encode_bounds_and_type(rbml_w, ecx,\n                                &lookup_item_type(ecx.tcx, def_id));\n \n-        ecx.tcx.map.with_path(variant.node.id, |path| encode_path(ebml_w, path));\n-        ebml_w.end_tag();\n+        ecx.tcx.map.with_path(variant.node.id, |path| encode_path(rbml_w, path));\n+        rbml_w.end_tag();\n         disr_val += 1;\n         i += 1;\n     }\n }\n \n-fn encode_path<PI: Iterator<PathElem> + Clone>(ebml_w: &mut Encoder,\n+fn encode_path<PI: Iterator<PathElem> + Clone>(rbml_w: &mut Encoder,\n                                                mut path: PI) {\n-    ebml_w.start_tag(tag_path);\n-    ebml_w.wr_tagged_u32(tag_path_len, path.clone().count() as u32);\n+    rbml_w.start_tag(tag_path);\n+    rbml_w.wr_tagged_u32(tag_path_len, path.clone().count() as u32);\n     for pe in path {\n         let tag = match pe {\n             ast_map::PathMod(_) => tag_path_elem_mod,\n             ast_map::PathName(_) => tag_path_elem_name\n         };\n-        ebml_w.wr_tagged_str(tag, token::get_name(pe.name()).get());\n+        rbml_w.wr_tagged_str(tag, token::get_name(pe.name()).get());\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_reexported_static_method(ebml_w: &mut Encoder,\n+fn encode_reexported_static_method(rbml_w: &mut Encoder,\n                                    exp: &middle::resolve::Export2,\n                                    method_def_id: DefId,\n                                    method_ident: Ident) {\n     debug!(\"(encode reexported static method) {}::{}\",\n             exp.name, token::get_ident(method_ident));\n-    ebml_w.start_tag(tag_items_data_item_reexport);\n-    ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    ebml_w.wr_str(def_to_string(method_def_id).as_slice());\n-    ebml_w.end_tag();\n-    ebml_w.start_tag(tag_items_data_item_reexport_name);\n-    ebml_w.wr_str(format!(\"{}::{}\",\n+    rbml_w.start_tag(tag_items_data_item_reexport);\n+    rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n+    rbml_w.wr_str(def_to_string(method_def_id).as_slice());\n+    rbml_w.end_tag();\n+    rbml_w.start_tag(tag_items_data_item_reexport_name);\n+    rbml_w.wr_str(format!(\"{}::{}\",\n                           exp.name,\n                           token::get_ident(method_ident)).as_slice());\n-    ebml_w.end_tag();\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n-                                         ebml_w: &mut Encoder,\n+                                         rbml_w: &mut Encoder,\n                                          exp: &middle::resolve::Export2)\n                                          -> bool {\n     let impl_methods = ecx.tcx.impl_methods.borrow();\n@@ -410,7 +410,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                 for &method_did in impl_methods.get(base_impl_did).iter() {\n                     let m = ty::method(ecx.tcx, method_did);\n                     if m.explicit_self == ty::StaticExplicitSelfCategory {\n-                        encode_reexported_static_method(ebml_w, exp, m.def_id, m.ident);\n+                        encode_reexported_static_method(rbml_w, exp, m.def_id, m.ident);\n                     }\n                 }\n             }\n@@ -422,14 +422,14 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n }\n \n fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n-                                          ebml_w: &mut Encoder,\n+                                          rbml_w: &mut Encoder,\n                                           exp: &middle::resolve::Export2)\n                                           -> bool {\n     match ecx.tcx.trait_methods_cache.borrow().find(&exp.def_id) {\n         Some(methods) => {\n             for m in methods.iter() {\n                 if m.explicit_self == ty::StaticExplicitSelfCategory {\n-                    encode_reexported_static_method(ebml_w, exp, m.def_id, m.ident);\n+                    encode_reexported_static_method(rbml_w, exp, m.def_id, m.ident);\n                 }\n             }\n \n@@ -440,7 +440,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n }\n \n fn encode_reexported_static_methods(ecx: &EncodeContext,\n-                                    ebml_w: &mut Encoder,\n+                                    rbml_w: &mut Encoder,\n                                     mod_path: PathElems,\n                                     exp: &middle::resolve::Export2) {\n     match ecx.tcx.map.find(exp.def_id.node) {\n@@ -469,8 +469,8 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n             // but not yet for Foo.\n             //\n             if path_differs || original_name.get() != exp.name.as_slice() {\n-                if !encode_reexported_static_base_methods(ecx, ebml_w, exp) {\n-                    if encode_reexported_static_trait_methods(ecx, ebml_w, exp) {\n+                if !encode_reexported_static_base_methods(ecx, rbml_w, exp) {\n+                    if encode_reexported_static_trait_methods(ecx, rbml_w, exp) {\n                         debug!(\"(encode reexported static methods) {} \\\n                                  [trait]\",\n                                 original_name);\n@@ -520,7 +520,7 @@ fn each_auxiliary_node_id(item: Gc<Item>, callback: |NodeId| -> bool) -> bool {\n }\n \n fn encode_reexports(ecx: &EncodeContext,\n-                    ebml_w: &mut Encoder,\n+                    rbml_w: &mut Encoder,\n                     id: NodeId,\n                     path: PathElems) {\n     debug!(\"(encoding info for module) encoding reexports for {}\", id);\n@@ -534,15 +534,15 @@ fn encode_reexports(ecx: &EncodeContext,\n                        exp.def_id.krate,\n                        exp.def_id.node,\n                        id);\n-                ebml_w.start_tag(tag_items_data_item_reexport);\n-                ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                ebml_w.wr_str(def_to_string(exp.def_id).as_slice());\n-                ebml_w.end_tag();\n-                ebml_w.start_tag(tag_items_data_item_reexport_name);\n-                ebml_w.wr_str(exp.name.as_slice());\n-                ebml_w.end_tag();\n-                ebml_w.end_tag();\n-                encode_reexported_static_methods(ecx, ebml_w, path.clone(), exp);\n+                rbml_w.start_tag(tag_items_data_item_reexport);\n+                rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n+                rbml_w.wr_str(def_to_string(exp.def_id).as_slice());\n+                rbml_w.end_tag();\n+                rbml_w.start_tag(tag_items_data_item_reexport_name);\n+                rbml_w.wr_str(exp.name.as_slice());\n+                rbml_w.end_tag();\n+                rbml_w.end_tag();\n+                encode_reexported_static_methods(ecx, rbml_w, path.clone(), exp);\n             }\n         }\n         None => {\n@@ -553,30 +553,30 @@ fn encode_reexports(ecx: &EncodeContext,\n }\n \n fn encode_info_for_mod(ecx: &EncodeContext,\n-                       ebml_w: &mut Encoder,\n+                       rbml_w: &mut Encoder,\n                        md: &Mod,\n                        attrs: &[Attribute],\n                        id: NodeId,\n                        path: PathElems,\n                        name: Ident,\n                        vis: Visibility) {\n-    ebml_w.start_tag(tag_items_data_item);\n-    encode_def_id(ebml_w, local_def(id));\n-    encode_family(ebml_w, 'm');\n-    encode_name(ebml_w, name.name);\n+    rbml_w.start_tag(tag_items_data_item);\n+    encode_def_id(rbml_w, local_def(id));\n+    encode_family(rbml_w, 'm');\n+    encode_name(rbml_w, name.name);\n     debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n     // Encode info about all the module children.\n     for item in md.items.iter() {\n-        ebml_w.start_tag(tag_mod_child);\n-        ebml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_mod_child);\n+        rbml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n+        rbml_w.end_tag();\n \n         each_auxiliary_node_id(*item, |auxiliary_node_id| {\n-            ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_string(local_def(\n+            rbml_w.start_tag(tag_mod_child);\n+            rbml_w.wr_str(def_to_string(local_def(\n                         auxiliary_node_id)).as_slice());\n-            ebml_w.end_tag();\n+            rbml_w.end_tag();\n             true\n         });\n \n@@ -588,100 +588,100 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                         token::get_ident(ident),\n                         did, ecx.tcx.map.node_to_string(did));\n \n-                ebml_w.start_tag(tag_mod_impl);\n-                ebml_w.wr_str(def_to_string(local_def(did)).as_slice());\n-                ebml_w.end_tag();\n+                rbml_w.start_tag(tag_mod_impl);\n+                rbml_w.wr_str(def_to_string(local_def(did)).as_slice());\n+                rbml_w.end_tag();\n             }\n             _ => {}\n         }\n     }\n \n-    encode_path(ebml_w, path.clone());\n-    encode_visibility(ebml_w, vis);\n+    encode_path(rbml_w, path.clone());\n+    encode_visibility(rbml_w, vis);\n \n     let stab = stability::lookup(ecx.tcx, ast_util::local_def(id));\n-    encode_stability(ebml_w, stab);\n+    encode_stability(rbml_w, stab);\n \n     // Encode the reexports of this module, if this module is public.\n     if vis == Public {\n         debug!(\"(encoding info for module) encoding reexports for {}\", id);\n-        encode_reexports(ecx, ebml_w, id, path);\n+        encode_reexports(ecx, rbml_w, id, path);\n     }\n-    encode_attributes(ebml_w, attrs);\n+    encode_attributes(rbml_w, attrs);\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_struct_field_family(ebml_w: &mut Encoder,\n+fn encode_struct_field_family(rbml_w: &mut Encoder,\n                               visibility: Visibility) {\n-    encode_family(ebml_w, match visibility {\n+    encode_family(rbml_w, match visibility {\n         Public => 'g',\n         Inherited => 'N'\n     });\n }\n \n-fn encode_visibility(ebml_w: &mut Encoder, visibility: Visibility) {\n-    ebml_w.start_tag(tag_items_data_item_visibility);\n+fn encode_visibility(rbml_w: &mut Encoder, visibility: Visibility) {\n+    rbml_w.start_tag(tag_items_data_item_visibility);\n     let ch = match visibility {\n         Public => 'y',\n         Inherited => 'i',\n     };\n-    ebml_w.wr_str(ch.to_string().as_slice());\n-    ebml_w.end_tag();\n+    rbml_w.wr_str(ch.to_string().as_slice());\n+    rbml_w.end_tag();\n }\n \n-fn encode_explicit_self(ebml_w: &mut Encoder,\n+fn encode_explicit_self(rbml_w: &mut Encoder,\n                         explicit_self: &ty::ExplicitSelfCategory) {\n-    ebml_w.start_tag(tag_item_trait_method_explicit_self);\n+    rbml_w.start_tag(tag_item_trait_method_explicit_self);\n \n     // Encode the base self type.\n     match *explicit_self {\n         ty::StaticExplicitSelfCategory => {\n-            ebml_w.writer.write(&[ 's' as u8 ]);\n+            rbml_w.writer.write(&[ 's' as u8 ]);\n         }\n         ty::ByValueExplicitSelfCategory => {\n-            ebml_w.writer.write(&[ 'v' as u8 ]);\n+            rbml_w.writer.write(&[ 'v' as u8 ]);\n         }\n         ty::ByBoxExplicitSelfCategory => {\n-            ebml_w.writer.write(&[ '~' as u8 ]);\n+            rbml_w.writer.write(&[ '~' as u8 ]);\n         }\n         ty::ByReferenceExplicitSelfCategory(_, m) => {\n             // FIXME(#4846) encode custom lifetime\n-            ebml_w.writer.write(&['&' as u8]);\n-            encode_mutability(ebml_w, m);\n+            rbml_w.writer.write(&['&' as u8]);\n+            encode_mutability(rbml_w, m);\n         }\n     }\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n \n-    fn encode_mutability(ebml_w: &mut Encoder,\n+    fn encode_mutability(rbml_w: &mut Encoder,\n                          m: ast::Mutability) {\n         match m {\n-            MutImmutable => { ebml_w.writer.write(&[ 'i' as u8 ]); }\n-            MutMutable => { ebml_w.writer.write(&[ 'm' as u8 ]); }\n+            MutImmutable => { rbml_w.writer.write(&[ 'i' as u8 ]); }\n+            MutMutable => { rbml_w.writer.write(&[ 'm' as u8 ]); }\n         }\n     }\n }\n \n-fn encode_method_sort(ebml_w: &mut Encoder, sort: char) {\n-    ebml_w.start_tag(tag_item_trait_method_sort);\n-    ebml_w.writer.write(&[ sort as u8 ]);\n-    ebml_w.end_tag();\n+fn encode_method_sort(rbml_w: &mut Encoder, sort: char) {\n+    rbml_w.start_tag(tag_item_trait_method_sort);\n+    rbml_w.writer.write(&[ sort as u8 ]);\n+    rbml_w.end_tag();\n }\n \n-fn encode_provided_source(ebml_w: &mut Encoder,\n+fn encode_provided_source(rbml_w: &mut Encoder,\n                           source_opt: Option<DefId>) {\n     for source in source_opt.iter() {\n-        ebml_w.start_tag(tag_item_method_provided_source);\n+        rbml_w.start_tag(tag_item_method_provided_source);\n         let s = def_to_string(*source);\n-        ebml_w.writer.write(s.as_bytes());\n-        ebml_w.end_tag();\n+        rbml_w.writer.write(s.as_bytes());\n+        rbml_w.end_tag();\n     }\n }\n \n /* Returns an index of items in this class */\n fn encode_info_for_struct(ecx: &EncodeContext,\n-                          ebml_w: &mut Encoder,\n+                          rbml_w: &mut Encoder,\n                           fields: &[ty::field_ty],\n                           global_index: &mut Vec<entry<i64>>)\n                           -> Vec<entry<i64>> {\n@@ -695,86 +695,86 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         let nm = field.name;\n         let id = field.id.node;\n \n-        index.push(entry {val: id as i64, pos: ebml_w.writer.tell().unwrap()});\n+        index.push(entry {val: id as i64, pos: rbml_w.writer.tell().unwrap()});\n         global_index.push(entry {\n             val: id as i64,\n-            pos: ebml_w.writer.tell().unwrap(),\n+            pos: rbml_w.writer.tell().unwrap(),\n         });\n-        ebml_w.start_tag(tag_items_data_item);\n+        rbml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing {} {}\",\n                token::get_name(nm), id);\n-        encode_struct_field_family(ebml_w, field.vis);\n-        encode_name(ebml_w, nm);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n-        encode_def_id(ebml_w, local_def(id));\n+        encode_struct_field_family(rbml_w, field.vis);\n+        encode_name(rbml_w, nm);\n+        encode_type(ecx, rbml_w, node_id_to_type(tcx, id));\n+        encode_def_id(rbml_w, local_def(id));\n \n         let stab = stability::lookup(ecx.tcx, field.id);\n-        encode_stability(ebml_w, stab);\n+        encode_stability(rbml_w, stab);\n \n-        ebml_w.end_tag();\n+        rbml_w.end_tag();\n     }\n     index\n }\n \n fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n-                               ebml_w: &mut Encoder,\n+                               rbml_w: &mut Encoder,\n                                name: ast::Ident,\n                                ctor_id: NodeId,\n                                index: &mut Vec<entry<i64>>,\n                                struct_id: NodeId) {\n     index.push(entry {\n         val: ctor_id as i64,\n-        pos: ebml_w.writer.tell().unwrap(),\n+        pos: rbml_w.writer.tell().unwrap(),\n     });\n \n-    ebml_w.start_tag(tag_items_data_item);\n-    encode_def_id(ebml_w, local_def(ctor_id));\n-    encode_family(ebml_w, 'f');\n-    encode_bounds_and_type(ebml_w, ecx,\n+    rbml_w.start_tag(tag_items_data_item);\n+    encode_def_id(rbml_w, local_def(ctor_id));\n+    encode_family(rbml_w, 'f');\n+    encode_bounds_and_type(rbml_w, ecx,\n                            &lookup_item_type(ecx.tcx, local_def(ctor_id)));\n-    encode_name(ebml_w, name.name);\n-    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, ctor_id));\n-    ecx.tcx.map.with_path(ctor_id, |path| encode_path(ebml_w, path));\n-    encode_parent_item(ebml_w, local_def(struct_id));\n+    encode_name(rbml_w, name.name);\n+    encode_type(ecx, rbml_w, node_id_to_type(ecx.tcx, ctor_id));\n+    ecx.tcx.map.with_path(ctor_id, |path| encode_path(rbml_w, path));\n+    encode_parent_item(rbml_w, local_def(struct_id));\n \n     if ecx.item_symbols.borrow().contains_key(&ctor_id) {\n-        encode_symbol(ecx, ebml_w, ctor_id);\n+        encode_symbol(ecx, rbml_w, ctor_id);\n     }\n \n     let stab = stability::lookup(ecx.tcx, ast_util::local_def(ctor_id));\n-    encode_stability(ebml_w, stab);\n+    encode_stability(rbml_w, stab);\n \n     // indicate that this is a tuple struct ctor, because downstream users will normally want\n     // the tuple struct definition, but without this there is no way for them to tell that\n     // they actually have a ctor rather than a normal function\n-    ebml_w.start_tag(tag_items_data_item_is_tuple_struct_ctor);\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(tag_items_data_item_is_tuple_struct_ctor);\n+    rbml_w.end_tag();\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_method_ty_fields(ecx: &EncodeContext,\n-                           ebml_w: &mut Encoder,\n+                           rbml_w: &mut Encoder,\n                            method_ty: &ty::Method) {\n-    encode_def_id(ebml_w, method_ty.def_id);\n-    encode_name(ebml_w, method_ty.ident.name);\n-    encode_ty_type_param_defs(ebml_w, ecx, &method_ty.generics.types,\n+    encode_def_id(rbml_w, method_ty.def_id);\n+    encode_name(rbml_w, method_ty.ident.name);\n+    encode_ty_type_param_defs(rbml_w, ecx, &method_ty.generics.types,\n                               tag_item_method_tps);\n-    encode_method_fty(ecx, ebml_w, &method_ty.fty);\n-    encode_visibility(ebml_w, method_ty.vis);\n-    encode_explicit_self(ebml_w, &method_ty.explicit_self);\n+    encode_method_fty(ecx, rbml_w, &method_ty.fty);\n+    encode_visibility(rbml_w, method_ty.vis);\n+    encode_explicit_self(rbml_w, &method_ty.explicit_self);\n     let fn_style = method_ty.fty.fn_style;\n     match method_ty.explicit_self {\n         ty::StaticExplicitSelfCategory => {\n-            encode_family(ebml_w, fn_style_static_method_family(fn_style));\n+            encode_family(rbml_w, fn_style_static_method_family(fn_style));\n         }\n-        _ => encode_family(ebml_w, style_fn_family(fn_style))\n+        _ => encode_family(rbml_w, style_fn_family(fn_style))\n     }\n-    encode_provided_source(ebml_w, method_ty.provided_source);\n+    encode_provided_source(rbml_w, method_ty.provided_source);\n }\n \n fn encode_info_for_method(ecx: &EncodeContext,\n-                          ebml_w: &mut Encoder,\n+                          rbml_w: &mut Encoder,\n                           m: &ty::Method,\n                           impl_path: PathElems,\n                           is_default_impl: bool,\n@@ -783,65 +783,65 @@ fn encode_info_for_method(ecx: &EncodeContext,\n \n     debug!(\"encode_info_for_method: {:?} {}\", m.def_id,\n            token::get_ident(m.ident));\n-    ebml_w.start_tag(tag_items_data_item);\n+    rbml_w.start_tag(tag_items_data_item);\n \n-    encode_method_ty_fields(ecx, ebml_w, m);\n-    encode_parent_item(ebml_w, local_def(parent_id));\n+    encode_method_ty_fields(ecx, rbml_w, m);\n+    encode_parent_item(rbml_w, local_def(parent_id));\n \n     let stab = stability::lookup(ecx.tcx, m.def_id);\n-    encode_stability(ebml_w, stab);\n+    encode_stability(rbml_w, stab);\n \n     // The type for methods gets encoded twice, which is unfortunate.\n     let pty = lookup_item_type(ecx.tcx, m.def_id);\n-    encode_bounds_and_type(ebml_w, ecx, &pty);\n+    encode_bounds_and_type(rbml_w, ecx, &pty);\n \n     let elem = ast_map::PathName(m.ident.name);\n-    encode_path(ebml_w, impl_path.chain(Some(elem).move_iter()));\n+    encode_path(rbml_w, impl_path.chain(Some(elem).move_iter()));\n     match ast_method_opt {\n         Some(ast_method) => {\n-            encode_attributes(ebml_w, ast_method.attrs.as_slice())\n+            encode_attributes(rbml_w, ast_method.attrs.as_slice())\n         }\n         None => ()\n     }\n \n     for &ast_method in ast_method_opt.iter() {\n         let any_types = !pty.generics.types.is_empty();\n         if any_types || is_default_impl || should_inline(ast_method.attrs.as_slice()) {\n-            encode_inlined_item(ecx, ebml_w,\n+            encode_inlined_item(ecx, rbml_w,\n                                 IIMethodRef(local_def(parent_id), false,\n                                             &*ast_method));\n         } else {\n-            encode_symbol(ecx, ebml_w, m.def_id.node);\n+            encode_symbol(ecx, rbml_w, m.def_id.node);\n         }\n-        encode_method_argument_names(ebml_w, &*ast_method.pe_fn_decl());\n+        encode_method_argument_names(rbml_w, &*ast_method.pe_fn_decl());\n     }\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_method_argument_names(ebml_w: &mut Encoder,\n+fn encode_method_argument_names(rbml_w: &mut Encoder,\n                                 decl: &ast::FnDecl) {\n-    ebml_w.start_tag(tag_method_argument_names);\n+    rbml_w.start_tag(tag_method_argument_names);\n     for arg in decl.inputs.iter() {\n-        ebml_w.start_tag(tag_method_argument_name);\n+        rbml_w.start_tag(tag_method_argument_name);\n         match arg.pat.node {\n             ast::PatIdent(_, ref path1, _) => {\n                 let name = token::get_ident(path1.node);\n-                ebml_w.writer.write(name.get().as_bytes());\n+                rbml_w.writer.write(name.get().as_bytes());\n             }\n             _ => {}\n         }\n-        ebml_w.end_tag();\n+        rbml_w.end_tag();\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_inlined_item(ecx: &EncodeContext,\n-                       ebml_w: &mut Encoder,\n+                       rbml_w: &mut Encoder,\n                        ii: InlinedItemRef) {\n     let mut eii = ecx.encode_inlined_item.borrow_mut();\n     let eii: &mut EncodeInlinedItem = &mut *eii;\n-    (*eii)(ecx, ebml_w, ii)\n+    (*eii)(ecx, rbml_w, ii)\n }\n \n fn style_fn_family(s: FnStyle) -> char {\n@@ -869,57 +869,57 @@ fn should_inline(attrs: &[Attribute]) -> bool {\n \n // Encodes the inherent implementations of a structure, enumeration, or trait.\n fn encode_inherent_implementations(ecx: &EncodeContext,\n-                                   ebml_w: &mut Encoder,\n+                                   rbml_w: &mut Encoder,\n                                    def_id: DefId) {\n     match ecx.tcx.inherent_impls.borrow().find(&def_id) {\n         None => {}\n         Some(implementations) => {\n             for &impl_def_id in implementations.borrow().iter() {\n-                ebml_w.start_tag(tag_items_data_item_inherent_impl);\n-                encode_def_id(ebml_w, impl_def_id);\n-                ebml_w.end_tag();\n+                rbml_w.start_tag(tag_items_data_item_inherent_impl);\n+                encode_def_id(rbml_w, impl_def_id);\n+                rbml_w.end_tag();\n             }\n         }\n     }\n }\n \n // Encodes the implementations of a trait defined in this crate.\n fn encode_extension_implementations(ecx: &EncodeContext,\n-                                    ebml_w: &mut Encoder,\n+                                    rbml_w: &mut Encoder,\n                                     trait_def_id: DefId) {\n     match ecx.tcx.trait_impls.borrow().find(&trait_def_id) {\n         None => {}\n         Some(implementations) => {\n             for &impl_def_id in implementations.borrow().iter() {\n-                ebml_w.start_tag(tag_items_data_item_extension_impl);\n-                encode_def_id(ebml_w, impl_def_id);\n-                ebml_w.end_tag();\n+                rbml_w.start_tag(tag_items_data_item_extension_impl);\n+                encode_def_id(rbml_w, impl_def_id);\n+                rbml_w.end_tag();\n             }\n         }\n     }\n }\n \n-fn encode_stability(ebml_w: &mut Encoder, stab_opt: Option<attr::Stability>) {\n+fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<attr::Stability>) {\n     stab_opt.map(|stab| {\n-        ebml_w.start_tag(tag_items_data_item_stability);\n-        stab.encode(ebml_w).unwrap();\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_items_data_item_stability);\n+        stab.encode(rbml_w).unwrap();\n+        rbml_w.end_tag();\n     });\n }\n \n fn encode_info_for_item(ecx: &EncodeContext,\n-                        ebml_w: &mut Encoder,\n+                        rbml_w: &mut Encoder,\n                         item: &Item,\n                         index: &mut Vec<entry<i64>>,\n                         path: PathElems,\n                         vis: ast::Visibility) {\n     let tcx = ecx.tcx;\n \n-    fn add_to_index(item: &Item, ebml_w: &Encoder,\n+    fn add_to_index(item: &Item, rbml_w: &Encoder,\n                     index: &mut Vec<entry<i64>>) {\n         index.push(entry {\n             val: item.id as i64,\n-            pos: ebml_w.writer.tell().unwrap(),\n+            pos: rbml_w.writer.tell().unwrap(),\n         });\n     }\n \n@@ -931,52 +931,52 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n     match item.node {\n       ItemStatic(_, m, _) => {\n-        add_to_index(item, ebml_w, index);\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n+        add_to_index(item, rbml_w, index);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n         if m == ast::MutMutable {\n-            encode_family(ebml_w, 'b');\n+            encode_family(rbml_w, 'b');\n         } else {\n-            encode_family(ebml_w, 'c');\n+            encode_family(rbml_w, 'c');\n         }\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        encode_symbol(ecx, ebml_w, item.id);\n-        encode_name(ebml_w, item.ident.name);\n-        encode_path(ebml_w, path);\n+        encode_type(ecx, rbml_w, node_id_to_type(tcx, item.id));\n+        encode_symbol(ecx, rbml_w, item.id);\n+        encode_name(rbml_w, item.ident.name);\n+        encode_path(rbml_w, path);\n \n         let inlineable = !ecx.non_inlineable_statics.borrow().contains(&item.id);\n \n         if inlineable {\n-            encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n+            encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         }\n-        encode_visibility(ebml_w, vis);\n-        encode_stability(ebml_w, stab);\n-        ebml_w.end_tag();\n+        encode_visibility(rbml_w, vis);\n+        encode_stability(rbml_w, stab);\n+        rbml_w.end_tag();\n       }\n       ItemFn(ref decl, fn_style, _, ref generics, _) => {\n-        add_to_index(item, ebml_w, index);\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n-        encode_family(ebml_w, style_fn_family(fn_style));\n+        add_to_index(item, rbml_w, index);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, style_fn_family(fn_style));\n         let tps_len = generics.ty_params.len();\n-        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n-        encode_name(ebml_w, item.ident.name);\n-        encode_path(ebml_w, path);\n-        encode_attributes(ebml_w, item.attrs.as_slice());\n+        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_name(rbml_w, item.ident.name);\n+        encode_path(rbml_w, path);\n+        encode_attributes(rbml_w, item.attrs.as_slice());\n         if tps_len > 0u || should_inline(item.attrs.as_slice()) {\n-            encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n+            encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         } else {\n-            encode_symbol(ecx, ebml_w, item.id);\n+            encode_symbol(ecx, rbml_w, item.id);\n         }\n-        encode_visibility(ebml_w, vis);\n-        encode_stability(ebml_w, stab);\n-        encode_method_argument_names(ebml_w, &**decl);\n-        ebml_w.end_tag();\n+        encode_visibility(rbml_w, vis);\n+        encode_stability(rbml_w, stab);\n+        encode_method_argument_names(rbml_w, &**decl);\n+        rbml_w.end_tag();\n       }\n       ItemMod(ref m) => {\n-        add_to_index(item, ebml_w, index);\n+        add_to_index(item, rbml_w, index);\n         encode_info_for_mod(ecx,\n-                            ebml_w,\n+                            rbml_w,\n                             m,\n                             item.attrs.as_slice(),\n                             item.id,\n@@ -985,60 +985,60 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                             item.vis);\n       }\n       ItemForeignMod(ref fm) => {\n-        add_to_index(item, ebml_w, index);\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n-        encode_family(ebml_w, 'n');\n-        encode_name(ebml_w, item.ident.name);\n-        encode_path(ebml_w, path);\n+        add_to_index(item, rbml_w, index);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, 'n');\n+        encode_name(rbml_w, item.ident.name);\n+        encode_path(rbml_w, path);\n \n         // Encode all the items in this module.\n         for foreign_item in fm.items.iter() {\n-            ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_string(local_def(foreign_item.id)).as_slice());\n-            ebml_w.end_tag();\n+            rbml_w.start_tag(tag_mod_child);\n+            rbml_w.wr_str(def_to_string(local_def(foreign_item.id)).as_slice());\n+            rbml_w.end_tag();\n         }\n-        encode_visibility(ebml_w, vis);\n-        encode_stability(ebml_w, stab);\n-        ebml_w.end_tag();\n+        encode_visibility(rbml_w, vis);\n+        encode_stability(rbml_w, stab);\n+        rbml_w.end_tag();\n       }\n       ItemTy(..) => {\n-        add_to_index(item, ebml_w, index);\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n-        encode_family(ebml_w, 'y');\n-        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n-        encode_name(ebml_w, item.ident.name);\n-        encode_path(ebml_w, path);\n-        encode_visibility(ebml_w, vis);\n-        encode_stability(ebml_w, stab);\n-        ebml_w.end_tag();\n+        add_to_index(item, rbml_w, index);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, 'y');\n+        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_name(rbml_w, item.ident.name);\n+        encode_path(rbml_w, path);\n+        encode_visibility(rbml_w, vis);\n+        encode_stability(rbml_w, stab);\n+        rbml_w.end_tag();\n       }\n       ItemEnum(ref enum_definition, _) => {\n-        add_to_index(item, ebml_w, index);\n-\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n-        encode_family(ebml_w, 't');\n-        encode_item_variances(ebml_w, ecx, item.id);\n-        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n-        encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs.as_slice());\n+        add_to_index(item, rbml_w, index);\n+\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, 't');\n+        encode_item_variances(rbml_w, ecx, item.id);\n+        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_name(rbml_w, item.ident.name);\n+        encode_attributes(rbml_w, item.attrs.as_slice());\n         for v in (*enum_definition).variants.iter() {\n-            encode_variant_id(ebml_w, local_def(v.node.id));\n+            encode_variant_id(rbml_w, local_def(v.node.id));\n         }\n-        encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n-        encode_path(ebml_w, path);\n+        encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n+        encode_path(rbml_w, path);\n \n         // Encode inherent implementations for this enumeration.\n-        encode_inherent_implementations(ecx, ebml_w, def_id);\n+        encode_inherent_implementations(ecx, rbml_w, def_id);\n \n-        encode_visibility(ebml_w, vis);\n-        encode_stability(ebml_w, stab);\n-        ebml_w.end_tag();\n+        encode_visibility(rbml_w, vis);\n+        encode_stability(rbml_w, stab);\n+        rbml_w.end_tag();\n \n         encode_enum_variant_info(ecx,\n-                                 ebml_w,\n+                                 rbml_w,\n                                  item.id,\n                                  (*enum_definition).variants.as_slice(),\n                                  index);\n@@ -1051,44 +1051,44 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            the index, and the index needs to be in the item for the\n            class itself */\n         let idx = encode_info_for_struct(ecx,\n-                                         ebml_w,\n+                                         rbml_w,\n                                          fields.as_slice(),\n                                          index);\n \n         /* Index the class*/\n-        add_to_index(item, ebml_w, index);\n+        add_to_index(item, rbml_w, index);\n \n         /* Now, make an item for the class itself */\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n-        encode_family(ebml_w, 'S');\n-        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n-\n-        encode_item_variances(ebml_w, ecx, item.id);\n-        encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs.as_slice());\n-        encode_path(ebml_w, path.clone());\n-        encode_stability(ebml_w, stab);\n-        encode_visibility(ebml_w, vis);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, 'S');\n+        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+\n+        encode_item_variances(rbml_w, ecx, item.id);\n+        encode_name(rbml_w, item.ident.name);\n+        encode_attributes(rbml_w, item.attrs.as_slice());\n+        encode_path(rbml_w, path.clone());\n+        encode_stability(rbml_w, stab);\n+        encode_visibility(rbml_w, vis);\n \n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(ebml_w, fields.as_slice(), def_id);\n+        encode_struct_fields(rbml_w, fields.as_slice(), def_id);\n \n-        encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n+        encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n \n         // Encode inherent implementations for this structure.\n-        encode_inherent_implementations(ecx, ebml_w, def_id);\n+        encode_inherent_implementations(ecx, rbml_w, def_id);\n \n         /* Each class has its own index -- encode it */\n-        encode_index(ebml_w, idx, write_i64);\n-        ebml_w.end_tag();\n+        encode_index(rbml_w, idx, write_i64);\n+        rbml_w.end_tag();\n \n         // If this is a tuple-like struct, encode the type of the constructor.\n         match struct_def.ctor_id {\n             Some(ctor_id) => {\n-                encode_info_for_struct_ctor(ecx, ebml_w, item.ident,\n+                encode_info_for_struct_ctor(ecx, rbml_w, item.ident,\n                                             ctor_id, index, def_id.node);\n             }\n             None => {}\n@@ -1100,38 +1100,38 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let impl_methods = tcx.impl_methods.borrow();\n         let methods = impl_methods.get(&def_id);\n \n-        add_to_index(item, ebml_w, index);\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n-        encode_family(ebml_w, 'i');\n-        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n-        encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs.as_slice());\n+        add_to_index(item, rbml_w, index);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, 'i');\n+        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_name(rbml_w, item.ident.name);\n+        encode_attributes(rbml_w, item.attrs.as_slice());\n         match ty.node {\n             ast::TyPath(ref path, ref bounds, _) if path.segments\n                                                         .len() == 1 => {\n                 let ident = path.segments.last().unwrap().identifier;\n                 assert!(bounds.is_none());\n-                encode_impl_type_basename(ebml_w, ident);\n+                encode_impl_type_basename(rbml_w, ident);\n             }\n             _ => {}\n         }\n         for &method_def_id in methods.iter() {\n-            ebml_w.start_tag(tag_item_impl_method);\n+            rbml_w.start_tag(tag_item_impl_method);\n             let s = def_to_string(method_def_id);\n-            ebml_w.writer.write(s.as_bytes());\n-            ebml_w.end_tag();\n+            rbml_w.writer.write(s.as_bytes());\n+            rbml_w.end_tag();\n         }\n         for ast_trait_ref in opt_trait.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(\n                 tcx, ast_trait_ref.ref_id);\n-            encode_trait_ref(ebml_w, ecx, &*trait_ref, tag_item_trait_ref);\n+            encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_trait_ref);\n             let impl_vtables = ty::lookup_impl_vtables(tcx, def_id);\n-            encode_impl_vtables(ebml_w, ecx, &impl_vtables);\n+            encode_impl_vtables(rbml_w, ecx, &impl_vtables);\n         }\n-        encode_path(ebml_w, path.clone());\n-        encode_stability(ebml_w, stab);\n-        ebml_w.end_tag();\n+        encode_path(rbml_w, path.clone());\n+        encode_stability(rbml_w, stab);\n+        rbml_w.end_tag();\n \n         // Iterate down the methods, emitting them. We rely on the\n         // assumption that all of the actually implemented methods\n@@ -1145,10 +1145,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             index.push(entry {\n                 val: method_def_id.node as i64,\n-                pos: ebml_w.writer.tell().unwrap(),\n+                pos: rbml_w.writer.tell().unwrap(),\n             });\n             encode_info_for_method(ecx,\n-                                   ebml_w,\n+                                   rbml_w,\n                                    &*ty::method(tcx, method_def_id),\n                                    path.clone(),\n                                    false,\n@@ -1157,43 +1157,43 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n       }\n       ItemTrait(_, _, ref super_traits, ref ms) => {\n-        add_to_index(item, ebml_w, index);\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n-        encode_family(ebml_w, 'I');\n-        encode_item_variances(ebml_w, ecx, item.id);\n+        add_to_index(item, rbml_w, index);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, 'I');\n+        encode_item_variances(rbml_w, ecx, item.id);\n         let trait_def = ty::lookup_trait_def(tcx, def_id);\n-        encode_ty_type_param_defs(ebml_w, ecx,\n+        encode_ty_type_param_defs(rbml_w, ecx,\n                                   &trait_def.generics.types,\n                                   tag_items_data_item_ty_param_bounds);\n-        encode_region_param_defs(ebml_w, &trait_def.generics.regions);\n-        encode_trait_ref(ebml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n-        encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs.as_slice());\n-        encode_visibility(ebml_w, vis);\n-        encode_stability(ebml_w, stab);\n+        encode_region_param_defs(rbml_w, &trait_def.generics.regions);\n+        encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n+        encode_name(rbml_w, item.ident.name);\n+        encode_attributes(rbml_w, item.attrs.as_slice());\n+        encode_visibility(rbml_w, vis);\n+        encode_stability(rbml_w, stab);\n         for &method_def_id in ty::trait_method_def_ids(tcx, def_id).iter() {\n-            ebml_w.start_tag(tag_item_trait_method);\n-            encode_def_id(ebml_w, method_def_id);\n-            ebml_w.end_tag();\n+            rbml_w.start_tag(tag_item_trait_method);\n+            encode_def_id(rbml_w, method_def_id);\n+            rbml_w.end_tag();\n \n-            ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_string(method_def_id).as_slice());\n-            ebml_w.end_tag();\n+            rbml_w.start_tag(tag_mod_child);\n+            rbml_w.wr_str(def_to_string(method_def_id).as_slice());\n+            rbml_w.end_tag();\n         }\n-        encode_path(ebml_w, path.clone());\n+        encode_path(rbml_w, path.clone());\n         // FIXME(#8559): This should use the tcx's supertrait cache instead of\n         // reading the AST's list, because the former has already filtered out\n         // the builtin-kinds-as-supertraits. See corresponding fixme in decoder.\n         for ast_trait_ref in super_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n-            encode_trait_ref(ebml_w, ecx, &*trait_ref, tag_item_super_trait_ref);\n+            encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_super_trait_ref);\n         }\n \n         // Encode the implementations of this trait.\n-        encode_extension_implementations(ecx, ebml_w, def_id);\n+        encode_extension_implementations(ecx, rbml_w, def_id);\n \n-        ebml_w.end_tag();\n+        rbml_w.end_tag();\n \n         // Now output the method info for each method.\n         let r = ty::trait_method_def_ids(tcx, def_id);\n@@ -1204,65 +1204,65 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             index.push(entry {\n                 val: method_def_id.node as i64,\n-                pos: ebml_w.writer.tell().unwrap(),\n+                pos: rbml_w.writer.tell().unwrap(),\n             });\n \n-            ebml_w.start_tag(tag_items_data_item);\n+            rbml_w.start_tag(tag_items_data_item);\n \n-            encode_method_ty_fields(ecx, ebml_w, &*method_ty);\n-            encode_parent_item(ebml_w, def_id);\n+            encode_method_ty_fields(ecx, rbml_w, &*method_ty);\n+            encode_parent_item(rbml_w, def_id);\n \n             let stab = stability::lookup(tcx, method_def_id);\n-            encode_stability(ebml_w, stab);\n+            encode_stability(rbml_w, stab);\n \n             let elem = ast_map::PathName(method_ty.ident.name);\n-            encode_path(ebml_w, path.clone().chain(Some(elem).move_iter()));\n+            encode_path(rbml_w, path.clone().chain(Some(elem).move_iter()));\n \n             match method_ty.explicit_self {\n                 ty::StaticExplicitSelfCategory => {\n-                    encode_family(ebml_w,\n+                    encode_family(rbml_w,\n                                   fn_style_static_method_family(\n                                       method_ty.fty.fn_style));\n \n                     let pty = ty::lookup_item_type(tcx, method_def_id);\n-                    encode_bounds_and_type(ebml_w, ecx, &pty);\n+                    encode_bounds_and_type(rbml_w, ecx, &pty);\n                 }\n \n                 _ => {\n-                    encode_family(ebml_w,\n+                    encode_family(rbml_w,\n                                   style_fn_family(\n                                       method_ty.fty.fn_style));\n                 }\n             }\n \n             match ms.get(i) {\n                 &Required(ref tm) => {\n-                    encode_attributes(ebml_w, tm.attrs.as_slice());\n-                    encode_method_sort(ebml_w, 'r');\n-                    encode_method_argument_names(ebml_w, &*tm.decl);\n+                    encode_attributes(rbml_w, tm.attrs.as_slice());\n+                    encode_method_sort(rbml_w, 'r');\n+                    encode_method_argument_names(rbml_w, &*tm.decl);\n                 }\n \n                 &Provided(m) => {\n-                    encode_attributes(ebml_w, m.attrs.as_slice());\n+                    encode_attributes(rbml_w, m.attrs.as_slice());\n                     // If this is a static method, we've already encoded\n                     // this.\n                     if method_ty.explicit_self != ty::StaticExplicitSelfCategory {\n                         // FIXME: I feel like there is something funny going on.\n                         let pty = ty::lookup_item_type(tcx, method_def_id);\n-                        encode_bounds_and_type(ebml_w, ecx, &pty);\n+                        encode_bounds_and_type(rbml_w, ecx, &pty);\n                     }\n-                    encode_method_sort(ebml_w, 'p');\n-                    encode_inlined_item(ecx, ebml_w,\n+                    encode_method_sort(rbml_w, 'p');\n+                    encode_inlined_item(ecx, rbml_w,\n                                         IIMethodRef(def_id, true, &*m));\n-                    encode_method_argument_names(ebml_w, &*m.pe_fn_decl());\n+                    encode_method_argument_names(rbml_w, &*m.pe_fn_decl());\n                 }\n             }\n \n-            ebml_w.end_tag();\n+            rbml_w.end_tag();\n         }\n \n         // Encode inherent implementations for this trait.\n-        encode_inherent_implementations(ecx, ebml_w, def_id);\n+        encode_inherent_implementations(ecx, rbml_w, def_id);\n       }\n       ItemMac(..) => {\n         // macros are encoded separately\n@@ -1271,61 +1271,61 @@ fn encode_info_for_item(ecx: &EncodeContext,\n }\n \n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n-                                ebml_w: &mut Encoder,\n+                                rbml_w: &mut Encoder,\n                                 nitem: &ForeignItem,\n                                 index: &mut Vec<entry<i64>>,\n                                 path: PathElems,\n                                 abi: abi::Abi) {\n     index.push(entry {\n         val: nitem.id as i64,\n-        pos: ebml_w.writer.tell().unwrap(),\n+        pos: rbml_w.writer.tell().unwrap(),\n     });\n \n-    ebml_w.start_tag(tag_items_data_item);\n-    encode_def_id(ebml_w, local_def(nitem.id));\n+    rbml_w.start_tag(tag_items_data_item);\n+    encode_def_id(rbml_w, local_def(nitem.id));\n     match nitem.node {\n       ForeignItemFn(..) => {\n-        encode_family(ebml_w, style_fn_family(NormalFn));\n-        encode_bounds_and_type(ebml_w, ecx,\n+        encode_family(rbml_w, style_fn_family(NormalFn));\n+        encode_bounds_and_type(rbml_w, ecx,\n                                &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n-        encode_name(ebml_w, nitem.ident.name);\n+        encode_name(rbml_w, nitem.ident.name);\n         if abi == abi::RustIntrinsic {\n-            encode_inlined_item(ecx, ebml_w, IIForeignRef(nitem));\n+            encode_inlined_item(ecx, rbml_w, IIForeignRef(nitem));\n         } else {\n-            encode_symbol(ecx, ebml_w, nitem.id);\n+            encode_symbol(ecx, rbml_w, nitem.id);\n         }\n       }\n       ForeignItemStatic(_, mutbl) => {\n         if mutbl {\n-            encode_family(ebml_w, 'b');\n+            encode_family(rbml_w, 'b');\n         } else {\n-            encode_family(ebml_w, 'c');\n+            encode_family(rbml_w, 'c');\n         }\n-        encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n-        encode_symbol(ecx, ebml_w, nitem.id);\n-        encode_name(ebml_w, nitem.ident.name);\n+        encode_type(ecx, rbml_w, node_id_to_type(ecx.tcx, nitem.id));\n+        encode_symbol(ecx, rbml_w, nitem.id);\n+        encode_name(rbml_w, nitem.ident.name);\n       }\n     }\n-    encode_path(ebml_w, path);\n-    ebml_w.end_tag();\n+    encode_path(rbml_w, path);\n+    rbml_w.end_tag();\n }\n \n fn my_visit_expr(_e: &Expr) { }\n \n fn my_visit_item(i: &Item,\n-                 ebml_w: &mut Encoder,\n+                 rbml_w: &mut Encoder,\n                  ecx_ptr: *const int,\n                  index: &mut Vec<entry<i64>>) {\n-    let mut ebml_w = unsafe { ebml_w.unsafe_clone() };\n+    let mut rbml_w = unsafe { rbml_w.unsafe_clone() };\n     // See above\n     let ecx: &EncodeContext = unsafe { mem::transmute(ecx_ptr) };\n     ecx.tcx.map.with_path(i.id, |path| {\n-        encode_info_for_item(ecx, &mut ebml_w, i, index, path, i.vis);\n+        encode_info_for_item(ecx, &mut rbml_w, i, index, path, i.vis);\n     });\n }\n \n fn my_visit_foreign_item(ni: &ForeignItem,\n-                         ebml_w: &mut Encoder,\n+                         rbml_w: &mut Encoder,\n                          ecx_ptr:*const int,\n                          index: &mut Vec<entry<i64>>) {\n     // See above\n@@ -1334,19 +1334,19 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n             ecx.tcx.map.path_to_string(ni.id),\n             token::get_ident(ni.ident));\n \n-    let mut ebml_w = unsafe {\n-        ebml_w.unsafe_clone()\n+    let mut rbml_w = unsafe {\n+        rbml_w.unsafe_clone()\n     };\n     let abi = ecx.tcx.map.get_foreign_abi(ni.id);\n     ecx.tcx.map.with_path(ni.id, |path| {\n-        encode_info_for_foreign_item(ecx, &mut ebml_w,\n+        encode_info_for_foreign_item(ecx, &mut rbml_w,\n                                      ni, index,\n                                      path, abi);\n     });\n }\n \n struct EncodeVisitor<'a,'b> {\n-    ebml_w_for_visit_item: &'a mut Encoder<'b>,\n+    rbml_w_for_visit_item: &'a mut Encoder<'b>,\n     ecx_ptr:*const int,\n     index: &'a mut Vec<entry<i64>>,\n }\n@@ -1359,31 +1359,31 @@ impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n     fn visit_item(&mut self, i: &Item, _: ()) {\n         visit::walk_item(self, i, ());\n         my_visit_item(i,\n-                      self.ebml_w_for_visit_item,\n+                      self.rbml_w_for_visit_item,\n                       self.ecx_ptr,\n                       self.index);\n     }\n     fn visit_foreign_item(&mut self, ni: &ForeignItem, _: ()) {\n         visit::walk_foreign_item(self, ni, ());\n         my_visit_foreign_item(ni,\n-                              self.ebml_w_for_visit_item,\n+                              self.rbml_w_for_visit_item,\n                               self.ecx_ptr,\n                               self.index);\n     }\n }\n \n fn encode_info_for_items(ecx: &EncodeContext,\n-                         ebml_w: &mut Encoder,\n+                         rbml_w: &mut Encoder,\n                          krate: &Crate)\n                          -> Vec<entry<i64>> {\n     let mut index = Vec::new();\n-    ebml_w.start_tag(tag_items_data);\n+    rbml_w.start_tag(tag_items_data);\n     index.push(entry {\n         val: CRATE_NODE_ID as i64,\n-        pos: ebml_w.writer.tell().unwrap(),\n+        pos: rbml_w.writer.tell().unwrap(),\n     });\n     encode_info_for_mod(ecx,\n-                        ebml_w,\n+                        rbml_w,\n                         &krate.module,\n                         &[],\n                         CRATE_NODE_ID,\n@@ -1396,51 +1396,51 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     visit::walk_crate(&mut EncodeVisitor {\n         index: &mut index,\n         ecx_ptr: ecx_ptr,\n-        ebml_w_for_visit_item: &mut *ebml_w,\n+        rbml_w_for_visit_item: &mut *rbml_w,\n     }, krate, ());\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n     index\n }\n \n \n // Path and definition ID indexing\n \n-fn encode_index<T: Hash>(ebml_w: &mut Encoder, index: Vec<entry<T>>,\n+fn encode_index<T: Hash>(rbml_w: &mut Encoder, index: Vec<entry<T>>,\n                          write_fn: |&mut SeekableMemWriter, &T|) {\n     let mut buckets: Vec<Vec<entry<T>>> = Vec::from_fn(256, |_| Vec::new());\n     for elt in index.move_iter() {\n         let h = hash::hash(&elt.val) as uint;\n         buckets.get_mut(h % 256).push(elt);\n     }\n \n-    ebml_w.start_tag(tag_index);\n+    rbml_w.start_tag(tag_index);\n     let mut bucket_locs = Vec::new();\n-    ebml_w.start_tag(tag_index_buckets);\n+    rbml_w.start_tag(tag_index_buckets);\n     for bucket in buckets.iter() {\n-        bucket_locs.push(ebml_w.writer.tell().unwrap());\n-        ebml_w.start_tag(tag_index_buckets_bucket);\n+        bucket_locs.push(rbml_w.writer.tell().unwrap());\n+        rbml_w.start_tag(tag_index_buckets_bucket);\n         for elt in bucket.iter() {\n-            ebml_w.start_tag(tag_index_buckets_bucket_elt);\n+            rbml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n             {\n-                let wr: &mut SeekableMemWriter = ebml_w.writer;\n+                let wr: &mut SeekableMemWriter = rbml_w.writer;\n                 wr.write_be_u32(elt.pos as u32);\n             }\n-            write_fn(ebml_w.writer, &elt.val);\n-            ebml_w.end_tag();\n+            write_fn(rbml_w.writer, &elt.val);\n+            rbml_w.end_tag();\n         }\n-        ebml_w.end_tag();\n+        rbml_w.end_tag();\n     }\n-    ebml_w.end_tag();\n-    ebml_w.start_tag(tag_index_table);\n+    rbml_w.end_tag();\n+    rbml_w.start_tag(tag_index_table);\n     for pos in bucket_locs.iter() {\n         assert!(*pos < 0xffff_ffff);\n-        let wr: &mut SeekableMemWriter = ebml_w.writer;\n+        let wr: &mut SeekableMemWriter = rbml_w.writer;\n         wr.write_be_u32(*pos as u32);\n     }\n-    ebml_w.end_tag();\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn write_i64(writer: &mut SeekableMemWriter, &n: &i64) {\n@@ -1449,55 +1449,55 @@ fn write_i64(writer: &mut SeekableMemWriter, &n: &i64) {\n     wr.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: &mut Encoder, mi: Gc<MetaItem>) {\n+fn encode_meta_item(rbml_w: &mut Encoder, mi: Gc<MetaItem>) {\n     match mi.node {\n       MetaWord(ref name) => {\n-        ebml_w.start_tag(tag_meta_item_word);\n-        ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(name.get().as_bytes());\n-        ebml_w.end_tag();\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_meta_item_word);\n+        rbml_w.start_tag(tag_meta_item_name);\n+        rbml_w.writer.write(name.get().as_bytes());\n+        rbml_w.end_tag();\n+        rbml_w.end_tag();\n       }\n       MetaNameValue(ref name, ref value) => {\n         match value.node {\n           LitStr(ref value, _) => {\n-            ebml_w.start_tag(tag_meta_item_name_value);\n-            ebml_w.start_tag(tag_meta_item_name);\n-            ebml_w.writer.write(name.get().as_bytes());\n-            ebml_w.end_tag();\n-            ebml_w.start_tag(tag_meta_item_value);\n-            ebml_w.writer.write(value.get().as_bytes());\n-            ebml_w.end_tag();\n-            ebml_w.end_tag();\n+            rbml_w.start_tag(tag_meta_item_name_value);\n+            rbml_w.start_tag(tag_meta_item_name);\n+            rbml_w.writer.write(name.get().as_bytes());\n+            rbml_w.end_tag();\n+            rbml_w.start_tag(tag_meta_item_value);\n+            rbml_w.writer.write(value.get().as_bytes());\n+            rbml_w.end_tag();\n+            rbml_w.end_tag();\n           }\n           _ => {/* FIXME (#623): encode other variants */ }\n         }\n       }\n       MetaList(ref name, ref items) => {\n-        ebml_w.start_tag(tag_meta_item_list);\n-        ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(name.get().as_bytes());\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_meta_item_list);\n+        rbml_w.start_tag(tag_meta_item_name);\n+        rbml_w.writer.write(name.get().as_bytes());\n+        rbml_w.end_tag();\n         for inner_item in items.iter() {\n-            encode_meta_item(ebml_w, *inner_item);\n+            encode_meta_item(rbml_w, *inner_item);\n         }\n-        ebml_w.end_tag();\n+        rbml_w.end_tag();\n       }\n     }\n }\n \n-fn encode_attributes(ebml_w: &mut Encoder, attrs: &[Attribute]) {\n-    ebml_w.start_tag(tag_attributes);\n+fn encode_attributes(rbml_w: &mut Encoder, attrs: &[Attribute]) {\n+    rbml_w.start_tag(tag_attributes);\n     for attr in attrs.iter() {\n-        ebml_w.start_tag(tag_attribute);\n-        ebml_w.wr_tagged_u8(tag_attribute_is_sugared_doc, attr.node.is_sugared_doc as u8);\n-        encode_meta_item(ebml_w, attr.node.value);\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_attribute);\n+        rbml_w.wr_tagged_u8(tag_attribute_is_sugared_doc, attr.node.is_sugared_doc as u8);\n+        encode_meta_item(rbml_w, attr.node.value);\n+        rbml_w.end_tag();\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_crate_deps(ebml_w: &mut Encoder, cstore: &cstore::CStore) {\n+fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n     fn get_ordered_deps(cstore: &cstore::CStore) -> Vec<decoder::CrateDep> {\n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = Vec::new();\n@@ -1527,150 +1527,150 @@ fn encode_crate_deps(ebml_w: &mut Encoder, cstore: &cstore::CStore) {\n     // the assumption that they are numbered 1 to n.\n     // FIXME (#2166): This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n-    ebml_w.start_tag(tag_crate_deps);\n+    rbml_w.start_tag(tag_crate_deps);\n     let r = get_ordered_deps(cstore);\n     for dep in r.iter() {\n-        encode_crate_dep(ebml_w, (*dep).clone());\n+        encode_crate_dep(rbml_w, (*dep).clone());\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n-    ebml_w.start_tag(tag_lang_items);\n+fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n+    rbml_w.start_tag(tag_lang_items);\n \n     for (i, def_id) in ecx.tcx.lang_items.items() {\n         for id in def_id.iter() {\n             if id.krate == LOCAL_CRATE {\n-                ebml_w.start_tag(tag_lang_items_item);\n+                rbml_w.start_tag(tag_lang_items_item);\n \n-                ebml_w.start_tag(tag_lang_items_item_id);\n+                rbml_w.start_tag(tag_lang_items_item_id);\n                 {\n-                    let wr: &mut SeekableMemWriter = ebml_w.writer;\n+                    let wr: &mut SeekableMemWriter = rbml_w.writer;\n                     wr.write_be_u32(i as u32);\n                 }\n-                ebml_w.end_tag();   // tag_lang_items_item_id\n+                rbml_w.end_tag();   // tag_lang_items_item_id\n \n-                ebml_w.start_tag(tag_lang_items_item_node_id);\n+                rbml_w.start_tag(tag_lang_items_item_node_id);\n                 {\n-                    let wr: &mut SeekableMemWriter = ebml_w.writer;\n+                    let wr: &mut SeekableMemWriter = rbml_w.writer;\n                     wr.write_be_u32(id.node as u32);\n                 }\n-                ebml_w.end_tag();   // tag_lang_items_item_node_id\n+                rbml_w.end_tag();   // tag_lang_items_item_node_id\n \n-                ebml_w.end_tag();   // tag_lang_items_item\n+                rbml_w.end_tag();   // tag_lang_items_item\n             }\n         }\n     }\n \n     for i in ecx.tcx.lang_items.missing.iter() {\n-        ebml_w.wr_tagged_u32(tag_lang_items_missing, *i as u32);\n+        rbml_w.wr_tagged_u32(tag_lang_items_missing, *i as u32);\n     }\n \n-    ebml_w.end_tag();   // tag_lang_items\n+    rbml_w.end_tag();   // tag_lang_items\n }\n \n-fn encode_native_libraries(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n-    ebml_w.start_tag(tag_native_libraries);\n+fn encode_native_libraries(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n+    rbml_w.start_tag(tag_native_libraries);\n \n     for &(ref lib, kind) in ecx.tcx.sess.cstore.get_used_libraries()\n                                .borrow().iter() {\n         match kind {\n             cstore::NativeStatic => {} // these libraries are not propagated\n             cstore::NativeFramework | cstore::NativeUnknown => {\n-                ebml_w.start_tag(tag_native_libraries_lib);\n+                rbml_w.start_tag(tag_native_libraries_lib);\n \n-                ebml_w.start_tag(tag_native_libraries_kind);\n-                ebml_w.writer.write_be_u32(kind as u32);\n-                ebml_w.end_tag();\n+                rbml_w.start_tag(tag_native_libraries_kind);\n+                rbml_w.writer.write_be_u32(kind as u32);\n+                rbml_w.end_tag();\n \n-                ebml_w.start_tag(tag_native_libraries_name);\n-                ebml_w.writer.write(lib.as_bytes());\n-                ebml_w.end_tag();\n+                rbml_w.start_tag(tag_native_libraries_name);\n+                rbml_w.writer.write(lib.as_bytes());\n+                rbml_w.end_tag();\n \n-                ebml_w.end_tag();\n+                rbml_w.end_tag();\n             }\n         }\n     }\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_plugin_registrar_fn(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n+fn encode_plugin_registrar_fn(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     match ecx.tcx.sess.plugin_registrar_fn.get() {\n-        Some(id) => { ebml_w.wr_tagged_u32(tag_plugin_registrar_fn, id); }\n+        Some(id) => { rbml_w.wr_tagged_u32(tag_plugin_registrar_fn, id); }\n         None => {}\n     }\n }\n \n /// Given a span, write the text of that span into the output stream\n /// as an exported macro\n fn encode_macro_def(ecx: &EncodeContext,\n-                    ebml_w: &mut Encoder,\n+                    rbml_w: &mut Encoder,\n                     span: &syntax::codemap::Span) {\n     let def = ecx.tcx.sess.codemap().span_to_snippet(*span)\n         .expect(\"Unable to find source for macro\");\n-    ebml_w.start_tag(tag_macro_def);\n-    ebml_w.wr_str(def.as_slice());\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(tag_macro_def);\n+    rbml_w.wr_str(def.as_slice());\n+    rbml_w.end_tag();\n }\n \n /// Serialize the text of the exported macros\n fn encode_macro_defs(ecx: &EncodeContext,\n                      krate: &Crate,\n-                     ebml_w: &mut Encoder) {\n-    ebml_w.start_tag(tag_exported_macros);\n+                     rbml_w: &mut Encoder) {\n+    rbml_w.start_tag(tag_exported_macros);\n     for item in krate.exported_macros.iter() {\n-        encode_macro_def(ecx, ebml_w, &item.span);\n+        encode_macro_def(ecx, rbml_w, &item.span);\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_unboxed_closures<'a>(\n                            ecx: &'a EncodeContext,\n-                           ebml_w: &'a mut Encoder) {\n-    ebml_w.start_tag(tag_unboxed_closures);\n+                           rbml_w: &'a mut Encoder) {\n+    rbml_w.start_tag(tag_unboxed_closures);\n     for (unboxed_closure_id, unboxed_closure_type) in\n             ecx.tcx.unboxed_closure_types.borrow().iter() {\n         if unboxed_closure_id.krate != LOCAL_CRATE {\n             continue\n         }\n \n-        ebml_w.start_tag(tag_unboxed_closure);\n-        encode_def_id(ebml_w, *unboxed_closure_id);\n-        ebml_w.start_tag(tag_unboxed_closure_type);\n-        write_closure_type(ecx, ebml_w, unboxed_closure_type);\n-        ebml_w.end_tag();\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_unboxed_closure);\n+        encode_def_id(rbml_w, *unboxed_closure_id);\n+        rbml_w.start_tag(tag_unboxed_closure_type);\n+        write_closure_type(ecx, rbml_w, unboxed_closure_type);\n+        rbml_w.end_tag();\n+        rbml_w.end_tag();\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_struct_field_attrs(ebml_w: &mut Encoder, krate: &Crate) {\n+fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &Crate) {\n     struct StructFieldVisitor<'a, 'b> {\n-        ebml_w: &'a mut Encoder<'b>,\n+        rbml_w: &'a mut Encoder<'b>,\n     }\n \n     impl<'a, 'b> Visitor<()> for StructFieldVisitor<'a, 'b> {\n         fn visit_struct_field(&mut self, field: &ast::StructField, _: ()) {\n-            self.ebml_w.start_tag(tag_struct_field);\n-            self.ebml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n-            encode_attributes(self.ebml_w, field.node.attrs.as_slice());\n-            self.ebml_w.end_tag();\n+            self.rbml_w.start_tag(tag_struct_field);\n+            self.rbml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n+            encode_attributes(self.rbml_w, field.node.attrs.as_slice());\n+            self.rbml_w.end_tag();\n         }\n     }\n \n-    ebml_w.start_tag(tag_struct_fields);\n+    rbml_w.start_tag(tag_struct_fields);\n     visit::walk_crate(&mut StructFieldVisitor {\n-        ebml_w: ebml_w\n+        rbml_w: rbml_w\n     }, krate, ());\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n \n \n struct ImplVisitor<'a,'b,'c> {\n     ecx: &'a EncodeContext<'b>,\n-    ebml_w: &'a mut Encoder<'c>,\n+    rbml_w: &'a mut Encoder<'c>,\n }\n \n impl<'a,'b,'c> Visitor<()> for ImplVisitor<'a,'b,'c> {\n@@ -1685,9 +1685,9 @@ impl<'a,'b,'c> Visitor<()> for ImplVisitor<'a,'b,'c> {\n                 // or if the trait is not defined in this crate.\n                 if Some(def_id) == self.ecx.tcx.lang_items.drop_trait() ||\n                         def_id.krate != LOCAL_CRATE {\n-                    self.ebml_w.start_tag(tag_impls_impl);\n-                    encode_def_id(self.ebml_w, local_def(item.id));\n-                    self.ebml_w.end_tag();\n+                    self.rbml_w.start_tag(tag_impls_impl);\n+                    encode_def_id(self.rbml_w, local_def(item.id));\n+                    self.rbml_w.end_tag();\n                 }\n             }\n             _ => {}\n@@ -1708,55 +1708,55 @@ impl<'a,'b,'c> Visitor<()> for ImplVisitor<'a,'b,'c> {\n /// * Implementations of traits not defined in this crate.\n fn encode_impls<'a>(ecx: &'a EncodeContext,\n                     krate: &Crate,\n-                    ebml_w: &'a mut Encoder) {\n-    ebml_w.start_tag(tag_impls);\n+                    rbml_w: &'a mut Encoder) {\n+    rbml_w.start_tag(tag_impls);\n \n     {\n         let mut visitor = ImplVisitor {\n             ecx: ecx,\n-            ebml_w: ebml_w,\n+            rbml_w: rbml_w,\n         };\n         visit::walk_crate(&mut visitor, krate, ());\n     }\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_misc_info(ecx: &EncodeContext,\n                     krate: &Crate,\n-                    ebml_w: &mut Encoder) {\n-    ebml_w.start_tag(tag_misc_info);\n-    ebml_w.start_tag(tag_misc_info_crate_items);\n+                    rbml_w: &mut Encoder) {\n+    rbml_w.start_tag(tag_misc_info);\n+    rbml_w.start_tag(tag_misc_info_crate_items);\n     for &item in krate.module.items.iter() {\n-        ebml_w.start_tag(tag_mod_child);\n-        ebml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_mod_child);\n+        rbml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n+        rbml_w.end_tag();\n \n         each_auxiliary_node_id(item, |auxiliary_node_id| {\n-            ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_string(local_def(\n+            rbml_w.start_tag(tag_mod_child);\n+            rbml_w.wr_str(def_to_string(local_def(\n                         auxiliary_node_id)).as_slice());\n-            ebml_w.end_tag();\n+            rbml_w.end_tag();\n             true\n         });\n     }\n \n     // Encode reexports for the root module.\n-    encode_reexports(ecx, ebml_w, 0, ast_map::Values([].iter()).chain(None));\n+    encode_reexports(ecx, rbml_w, 0, ast_map::Values([].iter()).chain(None));\n \n-    ebml_w.end_tag();\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_reachable_extern_fns(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n-    ebml_w.start_tag(tag_reachable_extern_fns);\n+fn encode_reachable_extern_fns(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n+    rbml_w.start_tag(tag_reachable_extern_fns);\n \n     for id in ecx.reachable.iter() {\n         match ecx.tcx.map.find(*id) {\n             Some(ast_map::NodeItem(i)) => {\n                 match i.node {\n                     ast::ItemFn(_, _, abi, _, _) if abi != abi::Rust => {\n-                        ebml_w.wr_tagged_u32(tag_reachable_extern_fn_id, *id);\n+                        rbml_w.wr_tagged_u32(tag_reachable_extern_fn_id, *id);\n                     }\n                     _ => {}\n                 }\n@@ -1765,41 +1765,41 @@ fn encode_reachable_extern_fns(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n         }\n     }\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_crate_dep(ebml_w: &mut Encoder,\n+fn encode_crate_dep(rbml_w: &mut Encoder,\n                     dep: decoder::CrateDep) {\n-    ebml_w.start_tag(tag_crate_dep);\n-    ebml_w.start_tag(tag_crate_dep_crate_name);\n-    ebml_w.writer.write(dep.name.as_bytes());\n-    ebml_w.end_tag();\n-    ebml_w.start_tag(tag_crate_dep_hash);\n-    ebml_w.writer.write(dep.hash.as_str().as_bytes());\n-    ebml_w.end_tag();\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(tag_crate_dep);\n+    rbml_w.start_tag(tag_crate_dep_crate_name);\n+    rbml_w.writer.write(dep.name.as_bytes());\n+    rbml_w.end_tag();\n+    rbml_w.start_tag(tag_crate_dep_hash);\n+    rbml_w.writer.write(dep.hash.as_str().as_bytes());\n+    rbml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_hash(ebml_w: &mut Encoder, hash: &Svh) {\n-    ebml_w.start_tag(tag_crate_hash);\n-    ebml_w.writer.write(hash.as_str().as_bytes());\n-    ebml_w.end_tag();\n+fn encode_hash(rbml_w: &mut Encoder, hash: &Svh) {\n+    rbml_w.start_tag(tag_crate_hash);\n+    rbml_w.writer.write(hash.as_str().as_bytes());\n+    rbml_w.end_tag();\n }\n \n-fn encode_crate_name(ebml_w: &mut Encoder, crate_name: &str) {\n-    ebml_w.start_tag(tag_crate_crate_name);\n-    ebml_w.writer.write(crate_name.as_bytes());\n-    ebml_w.end_tag();\n+fn encode_crate_name(rbml_w: &mut Encoder, crate_name: &str) {\n+    rbml_w.start_tag(tag_crate_crate_name);\n+    rbml_w.writer.write(crate_name.as_bytes());\n+    rbml_w.end_tag();\n }\n \n-fn encode_crate_triple(ebml_w: &mut Encoder, triple: &str) {\n-    ebml_w.start_tag(tag_crate_triple);\n-    ebml_w.writer.write(triple.as_bytes());\n-    ebml_w.end_tag();\n+fn encode_crate_triple(rbml_w: &mut Encoder, triple: &str) {\n+    rbml_w.start_tag(tag_crate_triple);\n+    rbml_w.writer.write(triple.as_bytes());\n+    rbml_w.end_tag();\n }\n \n-fn encode_dylib_dependency_formats(ebml_w: &mut Encoder, ecx: &EncodeContext) {\n-    ebml_w.start_tag(tag_dylib_dependency_formats);\n+fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n+    rbml_w.start_tag(tag_dylib_dependency_formats);\n     match ecx.tcx.dependency_formats.borrow().find(&config::CrateTypeDylib) {\n         Some(arr) => {\n             let s = arr.iter().enumerate().filter_map(|(i, slot)| {\n@@ -1808,20 +1808,15 @@ fn encode_dylib_dependency_formats(ebml_w: &mut Encoder, ecx: &EncodeContext) {\n                     cstore::RequireStatic => \"s\",\n                 })).to_string())\n             }).collect::<Vec<String>>();\n-            ebml_w.writer.write(s.connect(\",\").as_bytes());\n+            rbml_w.writer.write(s.connect(\",\").as_bytes());\n         }\n         None => {}\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n // NB: Increment this as you change the metadata encoding version.\n-pub static metadata_encoding_version : &'static [u8] =\n-    &[0x72, //'r' as u8,\n-      0x75, //'u' as u8,\n-      0x73, //'s' as u8,\n-      0x74, //'t' as u8,\n-      0, 0, 0, 1 ];\n+pub static metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 1 ];\n \n pub fn encode_metadata(parms: EncodeParams, krate: &Crate) -> Vec<u8> {\n     let mut wr = SeekableMemWriter::new();\n@@ -1885,79 +1880,79 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter, parms: EncodeParams, krate:\n         reachable: reachable,\n      };\n \n-    let mut ebml_w = writer::Encoder::new(wr);\n+    let mut rbml_w = writer::Encoder::new(wr);\n \n-    encode_crate_name(&mut ebml_w, ecx.link_meta.crate_name.as_slice());\n-    encode_crate_triple(&mut ebml_w,\n+    encode_crate_name(&mut rbml_w, ecx.link_meta.crate_name.as_slice());\n+    encode_crate_triple(&mut rbml_w,\n                         tcx.sess\n                            .targ_cfg\n                            .target_strs\n                            .target_triple\n                            .as_slice());\n-    encode_hash(&mut ebml_w, &ecx.link_meta.crate_hash);\n-    encode_dylib_dependency_formats(&mut ebml_w, &ecx);\n+    encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);\n+    encode_dylib_dependency_formats(&mut rbml_w, &ecx);\n \n-    let mut i = ebml_w.writer.tell().unwrap();\n-    encode_attributes(&mut ebml_w, krate.attrs.as_slice());\n-    stats.attr_bytes = ebml_w.writer.tell().unwrap() - i;\n+    let mut i = rbml_w.writer.tell().unwrap();\n+    encode_attributes(&mut rbml_w, krate.attrs.as_slice());\n+    stats.attr_bytes = rbml_w.writer.tell().unwrap() - i;\n \n-    i = ebml_w.writer.tell().unwrap();\n-    encode_crate_deps(&mut ebml_w, ecx.cstore);\n-    stats.dep_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_crate_deps(&mut rbml_w, ecx.cstore);\n+    stats.dep_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode the language items.\n-    i = ebml_w.writer.tell().unwrap();\n-    encode_lang_items(&ecx, &mut ebml_w);\n-    stats.lang_item_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_lang_items(&ecx, &mut rbml_w);\n+    stats.lang_item_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode the native libraries used\n-    i = ebml_w.writer.tell().unwrap();\n-    encode_native_libraries(&ecx, &mut ebml_w);\n-    stats.native_lib_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_native_libraries(&ecx, &mut rbml_w);\n+    stats.native_lib_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode the plugin registrar function\n-    i = ebml_w.writer.tell().unwrap();\n-    encode_plugin_registrar_fn(&ecx, &mut ebml_w);\n-    stats.plugin_registrar_fn_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_plugin_registrar_fn(&ecx, &mut rbml_w);\n+    stats.plugin_registrar_fn_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode macro definitions\n-    i = ebml_w.writer.tell().unwrap();\n-    encode_macro_defs(&ecx, krate, &mut ebml_w);\n-    stats.macro_defs_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_macro_defs(&ecx, krate, &mut rbml_w);\n+    stats.macro_defs_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode the types of all unboxed closures in this crate.\n-    i = ebml_w.writer.tell().unwrap();\n-    encode_unboxed_closures(&ecx, &mut ebml_w);\n-    stats.unboxed_closure_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_unboxed_closures(&ecx, &mut rbml_w);\n+    stats.unboxed_closure_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode the def IDs of impls, for coherence checking.\n-    i = ebml_w.writer.tell().unwrap();\n-    encode_impls(&ecx, krate, &mut ebml_w);\n-    stats.impl_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_impls(&ecx, krate, &mut rbml_w);\n+    stats.impl_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode miscellaneous info.\n-    i = ebml_w.writer.tell().unwrap();\n-    encode_misc_info(&ecx, krate, &mut ebml_w);\n-    encode_reachable_extern_fns(&ecx, &mut ebml_w);\n-    stats.misc_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_misc_info(&ecx, krate, &mut rbml_w);\n+    encode_reachable_extern_fns(&ecx, &mut rbml_w);\n+    stats.misc_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode and index the items.\n-    ebml_w.start_tag(tag_items);\n-    i = ebml_w.writer.tell().unwrap();\n-    let items_index = encode_info_for_items(&ecx, &mut ebml_w, krate);\n-    stats.item_bytes = ebml_w.writer.tell().unwrap() - i;\n+    rbml_w.start_tag(tag_items);\n+    i = rbml_w.writer.tell().unwrap();\n+    let items_index = encode_info_for_items(&ecx, &mut rbml_w, krate);\n+    stats.item_bytes = rbml_w.writer.tell().unwrap() - i;\n \n-    i = ebml_w.writer.tell().unwrap();\n-    encode_index(&mut ebml_w, items_index, write_i64);\n-    stats.index_bytes = ebml_w.writer.tell().unwrap() - i;\n-    ebml_w.end_tag();\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_index(&mut rbml_w, items_index, write_i64);\n+    stats.index_bytes = rbml_w.writer.tell().unwrap() - i;\n+    rbml_w.end_tag();\n \n-    encode_struct_field_attrs(&mut ebml_w, krate);\n+    encode_struct_field_attrs(&mut rbml_w, krate);\n \n-    stats.total_bytes = ebml_w.writer.tell().unwrap();\n+    stats.total_bytes = rbml_w.writer.tell().unwrap();\n \n     if tcx.sess.meta_stats() {\n-        for e in ebml_w.writer.get_ref().iter() {\n+        for e in rbml_w.writer.get_ref().iter() {\n             if *e == 0 {\n                 stats.zero_bytes += 1;\n             }"}, {"sha": "f16a46ed72933e6ef8bf8b6373571618f678c57e", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -27,7 +27,7 @@ use syntax::ast::*;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token;\n \n-use util::io::SeekableMemWriter;\n+use rbml::io::SeekableMemWriter;\n \n macro_rules! mywrite( ($($arg:tt)*) => ({ write!($($arg)*); }) )\n "}, {"sha": "f68501bbb9143e3acedfcc683f95073ee144ceae", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 151, "deletions": 152, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -28,7 +28,6 @@ use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::typeck::{MethodCall, MethodCallee, MethodOrigin};\n use middle::{ty, typeck};\n-use util::io::SeekableMemWriter;\n use util::ppaux::ty_to_string;\n \n use syntax::{ast, ast_map, ast_util, codemap, fold};\n@@ -43,12 +42,12 @@ use std::io::Seek;\n use std::mem;\n use std::gc::GC;\n \n-use serialize::ebml::reader;\n-use serialize::ebml;\n+use rbml::io::SeekableMemWriter;\n+use rbml::{reader, writer};\n+use rbml;\n use serialize;\n use serialize::{Encoder, Encodable, EncoderHelpers, DecoderHelpers};\n use serialize::{Decoder, Decodable};\n-use writer = serialize::ebml::writer;\n \n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::print::pprust;\n@@ -79,7 +78,7 @@ pub type Encoder<'a> = writer::Encoder<'a, SeekableMemWriter>;\n // Top-level methods.\n \n pub fn encode_inlined_item(ecx: &e::EncodeContext,\n-                           ebml_w: &mut Encoder,\n+                           rbml_w: &mut Encoder,\n                            ii: e::InlinedItemRef) {\n     let id = match ii {\n         e::IIItemRef(i) => i.id,\n@@ -88,26 +87,26 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     };\n     debug!(\"> Encoding inlined item: {} ({})\",\n            ecx.tcx.map.path_to_string(id),\n-           ebml_w.writer.tell());\n+           rbml_w.writer.tell());\n \n     let ii = simplify_ast(ii);\n     let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n \n-    ebml_w.start_tag(c::tag_ast as uint);\n-    id_range.encode(ebml_w);\n-    encode_ast(ebml_w, ii);\n-    encode_side_tables_for_ii(ecx, ebml_w, &ii);\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(c::tag_ast as uint);\n+    id_range.encode(rbml_w);\n+    encode_ast(rbml_w, ii);\n+    encode_side_tables_for_ii(ecx, rbml_w, &ii);\n+    rbml_w.end_tag();\n \n     debug!(\"< Encoded inlined fn: {} ({})\",\n            ecx.tcx.map.path_to_string(id),\n-           ebml_w.writer.tell());\n+           rbml_w.writer.tell());\n }\n \n pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n                            tcx: &ty::ctxt,\n                            path: Vec<ast_map::PathElem>,\n-                           par_doc: ebml::Doc)\n+                           par_doc: rbml::Doc)\n                            -> Result<ast::InlinedItem, Vec<ast_map::PathElem>> {\n     let dcx = &DecodeContext {\n         cdata: cdata,\n@@ -294,10 +293,10 @@ impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(ebml_w: &mut Encoder, item: ast::InlinedItem) {\n-    ebml_w.start_tag(c::tag_tree as uint);\n-    item.encode(ebml_w);\n-    ebml_w.end_tag();\n+fn encode_ast(rbml_w: &mut Encoder, item: ast::InlinedItem) {\n+    rbml_w.start_tag(c::tag_tree as uint);\n+    item.encode(rbml_w);\n+    rbml_w.end_tag();\n }\n \n struct NestedItemsDropper;\n@@ -353,7 +352,7 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n     }\n }\n \n-fn decode_ast(par_doc: ebml::Doc) -> ast::InlinedItem {\n+fn decode_ast(par_doc: rbml::Doc) -> ast::InlinedItem {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder::new(chi_doc);\n     Decodable::decode(&mut d).unwrap()\n@@ -401,7 +400,7 @@ fn renumber_and_map_ast(xcx: &ExtendedDecodeContext,\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn decode_def(xcx: &ExtendedDecodeContext, doc: ebml::Doc) -> def::Def {\n+fn decode_def(xcx: &ExtendedDecodeContext, doc: rbml::Doc) -> def::Def {\n     let mut dsr = reader::Decoder::new(doc);\n     let def: def::Def = Decodable::decode(&mut dsr).unwrap();\n     def.tr(xcx)\n@@ -526,16 +525,16 @@ impl tr for ty::TraitStore {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(ebml_w: &mut Encoder, fv: &freevar_entry) {\n-    (*fv).encode(ebml_w).unwrap();\n+fn encode_freevar_entry(rbml_w: &mut Encoder, fv: &freevar_entry) {\n+    (*fv).encode(rbml_w).unwrap();\n }\n \n-trait ebml_decoder_helper {\n+trait rbml_decoder_helper {\n     fn read_freevar_entry(&mut self, xcx: &ExtendedDecodeContext)\n                           -> freevar_entry;\n }\n \n-impl<'a> ebml_decoder_helper for reader::Decoder<'a> {\n+impl<'a> rbml_decoder_helper for reader::Decoder<'a> {\n     fn read_freevar_entry(&mut self, xcx: &ExtendedDecodeContext)\n                           -> freevar_entry {\n         let fv: freevar_entry = Decodable::decode(self).unwrap();\n@@ -561,21 +560,21 @@ trait read_method_callee_helper {\n }\n \n fn encode_method_callee(ecx: &e::EncodeContext,\n-                        ebml_w: &mut Encoder,\n+                        rbml_w: &mut Encoder,\n                         adjustment: typeck::ExprAdjustment,\n                         method: &MethodCallee) {\n-    ebml_w.emit_struct(\"MethodCallee\", 4, |ebml_w| {\n-        ebml_w.emit_struct_field(\"adjustment\", 0u, |ebml_w| {\n-            adjustment.encode(ebml_w)\n+    rbml_w.emit_struct(\"MethodCallee\", 4, |rbml_w| {\n+        rbml_w.emit_struct_field(\"adjustment\", 0u, |rbml_w| {\n+            adjustment.encode(rbml_w)\n         });\n-        ebml_w.emit_struct_field(\"origin\", 1u, |ebml_w| {\n-            method.origin.encode(ebml_w)\n+        rbml_w.emit_struct_field(\"origin\", 1u, |rbml_w| {\n+            method.origin.encode(rbml_w)\n         });\n-        ebml_w.emit_struct_field(\"ty\", 2u, |ebml_w| {\n-            Ok(ebml_w.emit_ty(ecx, method.ty))\n+        rbml_w.emit_struct_field(\"ty\", 2u, |rbml_w| {\n+            Ok(rbml_w.emit_ty(ecx, method.ty))\n         });\n-        ebml_w.emit_struct_field(\"substs\", 3u, |ebml_w| {\n-            Ok(ebml_w.emit_substs(ecx, &method.substs))\n+        rbml_w.emit_struct_field(\"substs\", 3u, |rbml_w| {\n+            Ok(rbml_w.emit_substs(ecx, &method.substs))\n         })\n     }).unwrap();\n }\n@@ -636,81 +635,81 @@ impl tr for MethodOrigin {\n // Encoding and decoding vtable_res\n \n fn encode_vtable_res_with_key(ecx: &e::EncodeContext,\n-                              ebml_w: &mut Encoder,\n+                              rbml_w: &mut Encoder,\n                               adjustment: typeck::ExprAdjustment,\n                               dr: &typeck::vtable_res) {\n-    ebml_w.emit_struct(\"VtableWithKey\", 2, |ebml_w| {\n-        ebml_w.emit_struct_field(\"adjustment\", 0u, |ebml_w| {\n-            adjustment.encode(ebml_w)\n+    rbml_w.emit_struct(\"VtableWithKey\", 2, |rbml_w| {\n+        rbml_w.emit_struct_field(\"adjustment\", 0u, |rbml_w| {\n+            adjustment.encode(rbml_w)\n         });\n-        ebml_w.emit_struct_field(\"vtable_res\", 1u, |ebml_w| {\n-            Ok(encode_vtable_res(ecx, ebml_w, dr))\n+        rbml_w.emit_struct_field(\"vtable_res\", 1u, |rbml_w| {\n+            Ok(encode_vtable_res(ecx, rbml_w, dr))\n         })\n     }).unwrap()\n }\n \n pub fn encode_vtable_res(ecx: &e::EncodeContext,\n-                         ebml_w: &mut Encoder,\n+                         rbml_w: &mut Encoder,\n                          dr: &typeck::vtable_res) {\n     // can't autogenerate this code because automatic code of\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones. perhaps we should fix this.\n     encode_vec_per_param_space(\n-        ebml_w, dr,\n-        |ebml_w, param_tables| encode_vtable_param_res(ecx, ebml_w,\n+        rbml_w, dr,\n+        |rbml_w, param_tables| encode_vtable_param_res(ecx, rbml_w,\n                                                        param_tables))\n }\n \n pub fn encode_vtable_param_res(ecx: &e::EncodeContext,\n-                     ebml_w: &mut Encoder,\n+                     rbml_w: &mut Encoder,\n                      param_tables: &typeck::vtable_param_res) {\n-    ebml_w.emit_from_vec(param_tables.as_slice(), |ebml_w, vtable_origin| {\n-        Ok(encode_vtable_origin(ecx, ebml_w, vtable_origin))\n+    rbml_w.emit_from_vec(param_tables.as_slice(), |rbml_w, vtable_origin| {\n+        Ok(encode_vtable_origin(ecx, rbml_w, vtable_origin))\n     }).unwrap()\n }\n \n \n pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n-                        ebml_w: &mut Encoder,\n+                        rbml_w: &mut Encoder,\n                         vtable_origin: &typeck::vtable_origin) {\n-    ebml_w.emit_enum(\"vtable_origin\", |ebml_w| {\n+    rbml_w.emit_enum(\"vtable_origin\", |rbml_w| {\n         match *vtable_origin {\n           typeck::vtable_static(def_id, ref substs, ref vtable_res) => {\n-            ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u, |ebml_w| {\n-                ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n-                    Ok(ebml_w.emit_def_id(def_id))\n+            rbml_w.emit_enum_variant(\"vtable_static\", 0u, 3u, |rbml_w| {\n+                rbml_w.emit_enum_variant_arg(0u, |rbml_w| {\n+                    Ok(rbml_w.emit_def_id(def_id))\n                 });\n-                ebml_w.emit_enum_variant_arg(1u, |ebml_w| {\n-                    Ok(ebml_w.emit_substs(ecx, substs))\n+                rbml_w.emit_enum_variant_arg(1u, |rbml_w| {\n+                    Ok(rbml_w.emit_substs(ecx, substs))\n                 });\n-                ebml_w.emit_enum_variant_arg(2u, |ebml_w| {\n-                    Ok(encode_vtable_res(ecx, ebml_w, vtable_res))\n+                rbml_w.emit_enum_variant_arg(2u, |rbml_w| {\n+                    Ok(encode_vtable_res(ecx, rbml_w, vtable_res))\n                 })\n             })\n           }\n           typeck::vtable_param(pn, bn) => {\n-            ebml_w.emit_enum_variant(\"vtable_param\", 1u, 3u, |ebml_w| {\n-                ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n-                    pn.encode(ebml_w)\n+            rbml_w.emit_enum_variant(\"vtable_param\", 1u, 3u, |rbml_w| {\n+                rbml_w.emit_enum_variant_arg(0u, |rbml_w| {\n+                    pn.encode(rbml_w)\n                 });\n-                ebml_w.emit_enum_variant_arg(1u, |ebml_w| {\n-                    ebml_w.emit_uint(bn)\n+                rbml_w.emit_enum_variant_arg(1u, |rbml_w| {\n+                    rbml_w.emit_uint(bn)\n                 })\n             })\n           }\n           typeck::vtable_unboxed_closure(def_id) => {\n-              ebml_w.emit_enum_variant(\"vtable_unboxed_closure\",\n+              rbml_w.emit_enum_variant(\"vtable_unboxed_closure\",\n                                        2u,\n                                        1u,\n-                                       |ebml_w| {\n-                ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n-                    Ok(ebml_w.emit_def_id(def_id))\n+                                       |rbml_w| {\n+                rbml_w.emit_enum_variant_arg(0u, |rbml_w| {\n+                    Ok(rbml_w.emit_def_id(def_id))\n                 })\n               })\n           }\n           typeck::vtable_error => {\n-            ebml_w.emit_enum_variant(\"vtable_error\", 3u, 3u, |_ebml_w| {\n+            rbml_w.emit_enum_variant(\"vtable_error\", 3u, 3u, |_rbml_w| {\n                 Ok(())\n             })\n           }\n@@ -831,12 +830,12 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n // ___________________________________________________________________________\n //\n \n-fn encode_vec_per_param_space<T>(ebml_w: &mut Encoder,\n+fn encode_vec_per_param_space<T>(rbml_w: &mut Encoder,\n                                  v: &subst::VecPerParamSpace<T>,\n                                  f: |&mut Encoder, &T|) {\n     for &space in subst::ParamSpace::all().iter() {\n-        ebml_w.emit_from_vec(v.get_slice(space),\n-                             |ebml_w, n| Ok(f(ebml_w, n))).unwrap();\n+        rbml_w.emit_from_vec(v.get_slice(space),\n+                             |rbml_w, n| Ok(f(rbml_w, n))).unwrap();\n     }\n }\n \n@@ -858,7 +857,7 @@ impl<'a> get_ty_str_ctxt for e::EncodeContext<'a> {\n     }\n }\n \n-trait ebml_writer_helpers {\n+trait rbml_writer_helpers {\n     fn emit_closure_type(&mut self,\n                          ecx: &e::EncodeContext,\n                          closure_type: &ty::ClosureTy);\n@@ -874,7 +873,7 @@ trait ebml_writer_helpers {\n     fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment);\n }\n \n-impl<'a> ebml_writer_helpers for Encoder<'a> {\n+impl<'a> rbml_writer_helpers for Encoder<'a> {\n     fn emit_closure_type(&mut self,\n                          ecx: &e::EncodeContext,\n                          closure_type: &ty::ClosureTy) {\n@@ -980,34 +979,34 @@ impl<'a> write_tag_and_id for Encoder<'a> {\n \n struct SideTableEncodingIdVisitor<'a,'b> {\n     ecx_ptr: *const libc::c_void,\n-    new_ebml_w: &'a mut Encoder<'b>,\n+    new_rbml_w: &'a mut Encoder<'b>,\n }\n \n impl<'a,'b> ast_util::IdVisitingOperation for\n         SideTableEncodingIdVisitor<'a,'b> {\n     fn visit_id(&self, id: ast::NodeId) {\n-        // Note: this will cause a copy of ebml_w, which is bad as\n+        // Note: this will cause a copy of rbml_w, which is bad as\n         // it is mutable. But I believe it's harmless since we generate\n         // balanced EBML.\n         //\n         // FIXME(pcwalton): Don't copy this way.\n-        let mut new_ebml_w = unsafe {\n-            self.new_ebml_w.unsafe_clone()\n+        let mut new_rbml_w = unsafe {\n+            self.new_rbml_w.unsafe_clone()\n         };\n         // See above\n         let ecx: &e::EncodeContext = unsafe {\n             mem::transmute(self.ecx_ptr)\n         };\n-        encode_side_tables_for_id(ecx, &mut new_ebml_w, id)\n+        encode_side_tables_for_id(ecx, &mut new_rbml_w, id)\n     }\n }\n \n fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n-                             ebml_w: &mut Encoder,\n+                             rbml_w: &mut Encoder,\n                              ii: &ast::InlinedItem) {\n-    ebml_w.start_tag(c::tag_table as uint);\n-    let mut new_ebml_w = unsafe {\n-        ebml_w.unsafe_clone()\n+    rbml_w.start_tag(c::tag_table as uint);\n+    let mut new_rbml_w = unsafe {\n+        rbml_w.unsafe_clone()\n     };\n \n     // Because the ast visitor uses @IdVisitingOperation, I can't pass in\n@@ -1017,88 +1016,88 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n         ecx_ptr: unsafe {\n             mem::transmute(ecx)\n         },\n-        new_ebml_w: &mut new_ebml_w,\n+        new_rbml_w: &mut new_rbml_w,\n     });\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n-                             ebml_w: &mut Encoder,\n+                             rbml_w: &mut Encoder,\n                              id: ast::NodeId) {\n     let tcx = ecx.tcx;\n \n     debug!(\"Encoding side tables for id {}\", id);\n \n     for def in tcx.def_map.borrow().find(&id).iter() {\n-        ebml_w.tag(c::tag_table_def, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| (*def).encode(ebml_w).unwrap());\n+        rbml_w.tag(c::tag_table_def, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| (*def).encode(rbml_w).unwrap());\n         })\n     }\n \n     for &ty in tcx.node_types.borrow().find(&(id as uint)).iter() {\n-        ebml_w.tag(c::tag_table_node_type, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_ty(ecx, *ty);\n+        rbml_w.tag(c::tag_table_node_type, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                rbml_w.emit_ty(ecx, *ty);\n             })\n         })\n     }\n \n     for &item_substs in tcx.item_substs.borrow().find(&id).iter() {\n-        ebml_w.tag(c::tag_table_item_subst, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_substs(ecx, &item_substs.substs);\n+        rbml_w.tag(c::tag_table_item_subst, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                rbml_w.emit_substs(ecx, &item_substs.substs);\n             })\n         })\n     }\n \n     for &fv in tcx.freevars.borrow().find(&id).iter() {\n-        ebml_w.tag(c::tag_table_freevars, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_from_vec(fv.as_slice(), |ebml_w, fv_entry| {\n-                    Ok(encode_freevar_entry(ebml_w, fv_entry))\n+        rbml_w.tag(c::tag_table_freevars, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                rbml_w.emit_from_vec(fv.as_slice(), |rbml_w, fv_entry| {\n+                    Ok(encode_freevar_entry(rbml_w, fv_entry))\n                 });\n             })\n         })\n     }\n \n     let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n     for &pty in tcx.tcache.borrow().find(&lid).iter() {\n-        ebml_w.tag(c::tag_table_tcache, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_polytype(ecx, pty.clone());\n+        rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                rbml_w.emit_polytype(ecx, pty.clone());\n             })\n         })\n     }\n \n     for &type_param_def in tcx.ty_param_defs.borrow().find(&id).iter() {\n-        ebml_w.tag(c::tag_table_param_defs, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_type_param_def(ecx, type_param_def)\n+        rbml_w.tag(c::tag_table_param_defs, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                rbml_w.emit_type_param_def(ecx, type_param_def)\n             })\n         })\n     }\n \n     let method_call = MethodCall::expr(id);\n     for &method in tcx.method_map.borrow().find(&method_call).iter() {\n-        ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                encode_method_callee(ecx, ebml_w, method_call.adjustment, method)\n+        rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                encode_method_callee(ecx, rbml_w, method_call.adjustment, method)\n             })\n         })\n     }\n \n     for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n-        ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                encode_vtable_res_with_key(ecx, ebml_w, method_call.adjustment, dr);\n+        rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                encode_vtable_res_with_key(ecx, rbml_w, method_call.adjustment, dr);\n             })\n         })\n     }\n@@ -1109,20 +1108,20 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                 for autoderef in range(0, adj.autoderefs) {\n                     let method_call = MethodCall::autoderef(id, autoderef);\n                     for &method in tcx.method_map.borrow().find(&method_call).iter() {\n-                        ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n-                            ebml_w.id(id);\n-                            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                                encode_method_callee(ecx, ebml_w,\n+                        rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n+                            rbml_w.id(id);\n+                            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                                encode_method_callee(ecx, rbml_w,\n                                                      method_call.adjustment, method)\n                             })\n                         })\n                     }\n \n                     for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n-                        ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n-                            ebml_w.id(id);\n-                            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                                encode_vtable_res_with_key(ecx, ebml_w,\n+                        rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n+                            rbml_w.id(id);\n+                            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                                encode_vtable_res_with_key(ecx, rbml_w,\n                                                            method_call.adjustment, dr);\n                             })\n                         })\n@@ -1132,30 +1131,30 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ty::AutoObject(..) => {\n                 let method_call = MethodCall::autoobject(id);\n                 for &method in tcx.method_map.borrow().find(&method_call).iter() {\n-                    ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n-                        ebml_w.id(id);\n-                        ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                            encode_method_callee(ecx, ebml_w, method_call.adjustment, method)\n+                    rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n+                        rbml_w.id(id);\n+                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                            encode_method_callee(ecx, rbml_w, method_call.adjustment, method)\n                         })\n                     })\n                 }\n \n                 for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n-                    ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n-                        ebml_w.id(id);\n-                        ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                            encode_vtable_res_with_key(ecx, ebml_w, method_call.adjustment, dr);\n+                    rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n+                        rbml_w.id(id);\n+                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                            encode_vtable_res_with_key(ecx, rbml_w, method_call.adjustment, dr);\n                         })\n                     })\n                 }\n             }\n             _ => {}\n         }\n \n-        ebml_w.tag(c::tag_table_adjustments, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_auto_adjustment(ecx, adj);\n+        rbml_w.tag(c::tag_table_adjustments, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                rbml_w.emit_auto_adjustment(ecx, adj);\n             })\n         })\n     }\n@@ -1164,10 +1163,10 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                                    .borrow()\n                                    .find(&ast_util::local_def(id))\n                                    .iter() {\n-        ebml_w.tag(c::tag_table_unboxed_closure_type, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_closure_type(ecx, *unboxed_closure_type)\n+        rbml_w.tag(c::tag_table_unboxed_closure_type, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                rbml_w.emit_closure_type(ecx, *unboxed_closure_type)\n             })\n         })\n     }\n@@ -1178,14 +1177,14 @@ trait doc_decoder_helpers {\n     fn opt_child(&self, tag: c::astencode_tag) -> Option<Self>;\n }\n \n-impl<'a> doc_decoder_helpers for ebml::Doc<'a> {\n+impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n     fn as_int(&self) -> int { reader::doc_as_u64(*self) as int }\n-    fn opt_child(&self, tag: c::astencode_tag) -> Option<ebml::Doc<'a>> {\n+    fn opt_child(&self, tag: c::astencode_tag) -> Option<rbml::Doc<'a>> {\n         reader::maybe_get_doc(*self, tag as uint)\n     }\n }\n \n-trait ebml_decoder_decoder_helpers {\n+trait rbml_decoder_decoder_helpers {\n     fn read_ty(&mut self, xcx: &ExtendedDecodeContext) -> ty::t;\n     fn read_tys(&mut self, xcx: &ExtendedDecodeContext) -> Vec<ty::t>;\n     fn read_type_param_def(&mut self, xcx: &ExtendedDecodeContext)\n@@ -1214,7 +1213,7 @@ trait ebml_decoder_decoder_helpers {\n                          -> subst::Substs;\n }\n \n-impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n+impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n     fn read_ty_noxcx(&mut self,\n                      tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> ty::t {\n         self.read_opaque(|_, doc| {\n@@ -1270,7 +1269,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n             Ok(ty)\n         }).unwrap();\n \n-        fn type_string(doc: ebml::Doc) -> String {\n+        fn type_string(doc: rbml::Doc) -> String {\n             let mut str = String::new();\n             for i in range(doc.start, doc.end) {\n                 str.push_char(doc.data[i] as char);\n@@ -1423,7 +1422,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n }\n \n fn decode_side_tables(xcx: &ExtendedDecodeContext,\n-                      ast_doc: ebml::Doc) {\n+                      ast_doc: rbml::Doc) {\n     let dcx = xcx.dcx;\n     let tbl_doc = ast_doc.get(c::tag_table as uint);\n     reader::docs(tbl_doc, |tag, entry_doc| {\n@@ -1527,14 +1526,14 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: &mut Encoder, item: Gc<ast::Item>) {\n-    ebml_w.start_tag(c::tag_tree as uint);\n-    (*item).encode(ebml_w);\n-    ebml_w.end_tag();\n+fn encode_item_ast(rbml_w: &mut Encoder, item: Gc<ast::Item>) {\n+    rbml_w.start_tag(c::tag_tree as uint);\n+    (*item).encode(rbml_w);\n+    rbml_w.end_tag();\n }\n \n #[cfg(test)]\n-fn decode_item_ast(par_doc: ebml::Doc) -> Gc<ast::Item> {\n+fn decode_item_ast(par_doc: rbml::Doc) -> Gc<ast::Item> {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder::new(chi_doc);\n     box(GC) Decodable::decode(&mut d).unwrap()\n@@ -1576,11 +1575,11 @@ fn roundtrip(in_item: Option<Gc<ast::Item>>) {\n     let in_item = in_item.unwrap();\n     let mut wr = SeekableMemWriter::new();\n     {\n-        let mut ebml_w = writer::Encoder::new(&mut wr);\n-        encode_item_ast(&mut ebml_w, in_item);\n+        let mut rbml_w = writer::Encoder::new(&mut wr);\n+        encode_item_ast(&mut rbml_w, in_item);\n     }\n-    let ebml_doc = ebml::Doc::new(wr.get_ref());\n-    let out_item = decode_item_ast(ebml_doc);\n+    let rbml_doc = rbml::Doc::new(wr.get_ref());\n+    let out_item = decode_item_ast(rbml_doc);\n \n     assert!(in_item == out_item);\n }"}, {"sha": "673872103af60977c3ea6dfa76ed81201f03a21a", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -584,9 +584,11 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n                                 self.tcx().sess.span_bug(\n                                     span,\n                                     format!(\"Type parameter out of range \\\n-                                     when substituting in region {} (root type={})\",\n+                                     when substituting in region {} (root type={}) \\\n+                                     (space={}, index={})\",\n                                     region_name.as_str(),\n-                                    self.root_ty.repr(self.tcx())).as_slice());\n+                                    self.root_ty.repr(self.tcx()),\n+                                    space, i).as_slice());\n                             }\n                         }\n                 }"}, {"sha": "f1e84b8da8105b17a008586050efb6d898a173ee", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -485,6 +485,9 @@ pub fn get_res_dtor(ccx: &CrateContext,\n     if !substs.types.is_empty() {\n         assert_eq!(did.krate, ast::LOCAL_CRATE);\n \n+        // Since we're in trans we don't care for any region parameters\n+        let ref substs = subst::Substs::erased(substs.types.clone());\n+\n         let vtables = typeck::check::vtable::trans_resolve_method(ccx.tcx(), did.node, substs);\n         let (val, _) = monomorphize::monomorphic_fn(ccx, did, substs, vtables, None);\n \n@@ -2593,7 +2596,7 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     }\n \n     let encode_inlined_item: encoder::EncodeInlinedItem =\n-        |ecx, ebml_w, ii| astencode::encode_inlined_item(ecx, ebml_w, ii);\n+        |ecx, rbml_w, ii| astencode::encode_inlined_item(ecx, rbml_w, ii);\n \n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);"}, {"sha": "7d546aac0cbaed28eecce64105d3c2760be91b80", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -109,7 +109,7 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n     (v, llunitty, inlineable.iter().fold(true, |a, &b| a && b))\n }\n \n-fn const_addr_of(cx: &CrateContext, cv: ValueRef) -> ValueRef {\n+pub fn const_addr_of(cx: &CrateContext, cv: ValueRef) -> ValueRef {\n     unsafe {\n         let gv = \"const\".with_c_str(|name| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(cv).to_ref(), name)"}, {"sha": "2fd2e69cfc3bcbf31ec72682b5deb2e07a36e56d", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -20,6 +20,7 @@ use middle::trans::callee;\n use middle::trans::cleanup::CleanupMethods;\n use middle::trans::cleanup;\n use middle::trans::common::*;\n+use middle::trans::consts;\n use middle::trans::datum;\n use middle::trans::debuginfo;\n use middle::trans::expr;\n@@ -477,14 +478,6 @@ pub fn trans_ret<'a>(bcx: &'a Block<'a>,\n     return bcx;\n }\n \n-fn str_slice_arg<'a>(bcx: &'a Block<'a>, s: InternedString) -> ValueRef {\n-    let ccx = bcx.ccx();\n-    let s = C_str_slice(ccx, s);\n-    let slot = alloca(bcx, val_ty(s), \"__temp\");\n-    Store(bcx, s, slot);\n-    slot\n-}\n-\n pub fn trans_fail<'a>(\n                   bcx: &'a Block<'a>,\n                   sp: Span,\n@@ -493,12 +486,14 @@ pub fn trans_fail<'a>(\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"trans_fail_value\");\n \n-    let v_str = str_slice_arg(bcx, fail_str);\n+    let v_str = C_str_slice(ccx, fail_str);\n     let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n     let filename = token::intern_and_get_ident(loc.file.name.as_slice());\n-    let v_filename = str_slice_arg(bcx, filename);\n-    let v_line = loc.line as int;\n-    let args = vec!(v_str, v_filename, C_int(ccx, v_line));\n+    let filename = C_str_slice(ccx, filename);\n+    let line = C_int(ccx, loc.line as int);\n+    let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n+    let expr_file_line = consts::const_addr_of(ccx, expr_file_line_const);\n+    let args = vec!(expr_file_line);\n     let did = langcall(bcx, Some(sp), \"\", FailFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n@@ -514,16 +509,19 @@ pub fn trans_fail_bounds_check<'a>(\n                                index: ValueRef,\n                                len: ValueRef)\n                                -> &'a Block<'a> {\n+    let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"trans_fail_bounds_check\");\n \n     // Extract the file/line from the span\n     let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n     let filename = token::intern_and_get_ident(loc.file.name.as_slice());\n \n     // Invoke the lang item\n-    let filename = str_slice_arg(bcx, filename);\n-    let line = C_int(bcx.ccx(), loc.line as int);\n-    let args = vec!(filename, line, index, len);\n+    let filename = C_str_slice(ccx,  filename);\n+    let line = C_int(ccx, loc.line as int);\n+    let file_line_const = C_struct(ccx, &[filename, line], false);\n+    let file_line = consts::const_addr_of(ccx, file_line_const);\n+    let args = vec!(file_line, index, len);\n     let did = langcall(bcx, Some(sp), \"\", FailBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,"}, {"sha": "fd2ccc539e2ad24620417c9d512a38387df1364d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -3547,6 +3547,17 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         span_err!(tcx.sess, path.span, E0071,\n                             \"`{}` does not name a structure\",\n                             pprust::path_to_string(path));\n+\n+                        // Make sure to still write the types\n+                        // otherwise we might ICE\n+                        fcx.write_error(id);\n+                        for field in fields.iter() {\n+                            check_expr(fcx, &*field.expr);\n+                        }\n+                        match base_expr {\n+                            Some(ref base) => check_expr(fcx, &**base),\n+                            None => {}\n+                        }\n                     }\n                 }\n "}, {"sha": "9e4c42296769e56b5bb615aa08e397a413b02f7c", "filename": "src/librustrt/at_exit_imp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustrt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustrt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fat_exit_imp.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -31,7 +31,7 @@ pub fn init() {\n     let state: Box<Queue> = box Exclusive::new(Vec::new());\n     unsafe {\n         rtassert!(!RUNNING.load(atomics::SeqCst));\n-        rtassert!(QUEUE.swap(mem::transmute(state), atomics::SeqCst) == 0);\n+        assert!(QUEUE.swap(mem::transmute(state), atomics::SeqCst) == 0);\n     }\n }\n "}, {"sha": "5873c8273e790f16a47f15c94e2cca9ce9d0d80c", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -649,7 +649,7 @@ mod test {\n     #[should_fail]\n     fn test_begin_unwind() {\n         use std::rt::unwind::begin_unwind;\n-        begin_unwind(\"cause\", file!(), line!())\n+        begin_unwind(\"cause\", &(file!(), line!()))\n     }\n \n     #[test]"}, {"sha": "344d3a0f103d3138eec1d743676f0821c1df19d0", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -417,8 +417,8 @@ pub fn begin_unwind_fmt(msg: &fmt::Arguments, file_line: &(&'static str, uint))\n     begin_unwind_inner(box String::from_utf8(v).unwrap(), file_line)\n }\n \n-// FIXME: Need to change expr_fail in AstBuilder to change this to &(str, uint)\n /// This is the entry point of unwinding for fail!() and assert!().\n+#[cfg(stage0)]\n #[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> ! {\n     // Note that this should be the only allocation performed in this code path.\n@@ -432,6 +432,21 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> !\n     begin_unwind_inner(box msg, &(file, line))\n }\n \n+/// This is the entry point of unwinding for fail!() and assert!().\n+#[cfg(not(stage0))]\n+#[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n+pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) -> ! {\n+    // Note that this should be the only allocation performed in this code path.\n+    // Currently this means that fail!() on OOM will invoke this code path,\n+    // but then again we're not really ready for failing on OOM anyway. If\n+    // we do start doing this, then we should propagate this allocation to\n+    // be performed in the parent of this task instead of the task that's\n+    // failing.\n+\n+    // see below for why we do the `Any` coercion here.\n+    begin_unwind_inner(box msg, file_line)\n+}\n+\n /// The core of the unwinding.\n ///\n /// This is non-generic to avoid instantiation bloat in other crates"}, {"sha": "3cc5189c024db7b4a5dcd15f09c6928866bbcfb0", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -29,7 +29,8 @@\n //! `0.8.1-rc.3.0+20130922.linux`.\n \n #![crate_name = \"semver\"]\n-#![experimental]\n+#![deprecated = \"This is now a cargo package located at: \\\n+                 https://github.com/rust-lang/semver\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![license = \"MIT/ASL2\"]"}, {"sha": "5c35ad8523382cef363099662becabdac6c3a677", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -39,6 +39,5 @@ mod serialize;\n mod collection_impls;\n \n pub mod base64;\n-pub mod ebml;\n pub mod hex;\n pub mod json;"}, {"sha": "80fe05fcea5cdf99f1cdc14179c4af21dfd3324d", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -43,6 +43,7 @@ use option::{Option, Some, None};\n use ptr::RawPtr;\n use ptr;\n use raw;\n+use slice::Vector;\n \n /// The type representing a foreign chunk of memory\n pub struct CVec<T> {\n@@ -101,13 +102,6 @@ impl<T> CVec<T> {\n         }\n     }\n \n-    /// View the stored data as a slice.\n-    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n-        unsafe {\n-            mem::transmute(raw::Slice { data: self.base as *const T, len: self.len })\n-        }\n-    }\n-\n     /// View the stored data as a mutable slice.\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n@@ -151,6 +145,15 @@ impl<T> CVec<T> {\n     }\n }\n \n+impl<T> Vector<T> for CVec<T> {\n+    /// View the stored data as a slice.\n+    fn as_slice<'a>(&'a self) -> &'a [T] {\n+        unsafe {\n+            mem::transmute(raw::Slice { data: self.base as *const T, len: self.len })\n+        }\n+    }\n+}\n+\n impl<T> Collection for CVec<T> {\n     fn len(&self) -> uint { self.len }\n }"}, {"sha": "e67329df7aec4beae2b8af3baadaa192aabda700", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -37,6 +37,39 @@\n /// fail!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n /// ```\n #[macro_export]\n+#[cfg(not(stage0))]\n+macro_rules! fail(\n+    () => ({\n+        fail!(\"explicit failure\")\n+    });\n+    ($msg:expr) => ({\n+        // static requires less code at runtime, more constant data\n+        static FILE_LINE: (&'static str, uint) = (file!(), line!());\n+        ::std::rt::begin_unwind($msg, &FILE_LINE)\n+    });\n+    ($fmt:expr, $($arg:tt)*) => ({\n+        // a closure can't have return type !, so we need a full\n+        // function to pass to format_args!, *and* we need the\n+        // file and line numbers right here; so an inner bare fn\n+        // is our only choice.\n+        //\n+        // LLVM doesn't tend to inline this, presumably because begin_unwind_fmt\n+        // is #[cold] and #[inline(never)] and because this is flagged as cold\n+        // as returning !. We really do want this to be inlined, however,\n+        // because it's just a tiny wrapper. Small wins (156K to 149K in size)\n+        // were seen when forcing this to be inlined, and that number just goes\n+        // up with the number of calls to fail!()\n+        #[inline(always)]\n+        fn run_fmt(fmt: &::std::fmt::Arguments) -> ! {\n+            static FILE_LINE: (&'static str, uint) = (file!(), line!());\n+            ::std::rt::begin_unwind_fmt(fmt, &FILE_LINE)\n+        }\n+        format_args!(run_fmt, $fmt, $($arg)*)\n+    });\n+)\n+\n+#[macro_export]\n+#[cfg(stage0)]\n macro_rules! fail(\n     () => ({\n         fail!(\"explicit failure\")"}, {"sha": "a22db7292fa087ce7231afac9b09f5bcee72c189", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -142,6 +142,16 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// Creates a new Path from a byte vector or string.\n     /// The resulting Path will always be normalized.\n     ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let path = Path::new(\"foo/bar\");\n+    /// # }\n+    /// ```\n+    ///\n     /// # Failure\n     ///\n     /// Fails the task if the path contains a NUL.\n@@ -155,6 +165,17 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n \n     /// Creates a new Path from a byte vector or string, if possible.\n     /// The resulting Path will always be normalized.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let x: &[u8] = b\"foo\\0\";\n+    /// assert!(Path::new_opt(x).is_none());\n+    /// # }\n+    /// ```\n     #[inline]\n     fn new_opt<T: BytesContainer>(path: T) -> Option<Self> {\n         if contains_nul(&path) {\n@@ -166,51 +187,166 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n \n     /// Returns the path as a string, if possible.\n     /// If the path is not representable in utf-8, this returns None.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"/abc/def\");\n+    /// assert_eq!(p.as_str(), Some(\"/abc/def\"));\n+    /// # }\n+    /// ```\n     #[inline]\n     fn as_str<'a>(&'a self) -> Option<&'a str> {\n         str::from_utf8(self.as_vec())\n     }\n \n     /// Returns the path as a byte vector\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"abc/def\");\n+    /// assert_eq!(p.as_vec(), b\"abc/def\");\n+    /// # }\n+    /// ```\n     fn as_vec<'a>(&'a self) -> &'a [u8];\n \n     /// Converts the Path into an owned byte vector\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"abc/def\");\n+    /// assert_eq!(p.into_vec(), b\"abc/def\".to_vec());\n+    /// // attempting to use p now results in \"error: use of moved value\"\n+    /// # }\n+    /// ```\n     fn into_vec(self) -> Vec<u8>;\n \n     /// Returns an object that implements `Show` for printing paths\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"abc/def\");\n+    /// println!(\"{}\", p.display()); // prints \"abc/def\"\n+    /// # }\n+    /// ```\n     fn display<'a>(&'a self) -> Display<'a, Self> {\n         Display{ path: self, filename: false }\n     }\n \n     /// Returns an object that implements `Show` for printing filenames\n     ///\n     /// If there is no filename, nothing will be printed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"abc/def\");\n+    /// println!(\"{}\", p.filename_display()); // prints \"def\"\n+    /// # }\n+    /// ```\n     fn filename_display<'a>(&'a self) -> Display<'a, Self> {\n         Display{ path: self, filename: true }\n     }\n \n     /// Returns the directory component of `self`, as a byte vector (with no trailing separator).\n     /// If `self` has no directory component, returns ['.'].\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"abc/def/ghi\");\n+    /// assert_eq!(p.dirname(), b\"abc/def\");\n+    /// # }\n+    /// ```\n     fn dirname<'a>(&'a self) -> &'a [u8];\n+\n     /// Returns the directory component of `self`, as a string, if possible.\n     /// See `dirname` for details.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"abc/def/ghi\");\n+    /// assert_eq!(p.dirname_str(), Some(\"abc/def\"));\n+    /// # }\n+    /// ```\n     #[inline]\n     fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n         str::from_utf8(self.dirname())\n     }\n+\n     /// Returns the file component of `self`, as a byte vector.\n     /// If `self` represents the root of the file hierarchy, returns None.\n     /// If `self` is \".\" or \"..\", returns None.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"abc/def/ghi\");\n+    /// assert_eq!(p.filename(), Some(b\"ghi\"));\n+    /// # }\n+    /// ```\n     fn filename<'a>(&'a self) -> Option<&'a [u8]>;\n+\n     /// Returns the file component of `self`, as a string, if possible.\n     /// See `filename` for details.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"abc/def/ghi\");\n+    /// assert_eq!(p.filename_str(), Some(\"ghi\"));\n+    /// # }\n+    /// ```\n     #[inline]\n     fn filename_str<'a>(&'a self) -> Option<&'a str> {\n         self.filename().and_then(str::from_utf8)\n     }\n+\n     /// Returns the stem of the filename of `self`, as a byte vector.\n     /// The stem is the portion of the filename just before the last '.'.\n     /// If there is no '.', the entire filename is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"/abc/def.txt\");\n+    /// assert_eq!(p.filestem(), Some(b\"def\"));\n+    /// # }\n+    /// ```\n     fn filestem<'a>(&'a self) -> Option<&'a [u8]> {\n         match self.filename() {\n             None => None,\n@@ -224,16 +360,40 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             })\n         }\n     }\n+\n     /// Returns the stem of the filename of `self`, as a string, if possible.\n     /// See `filestem` for details.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"/abc/def.txt\");\n+    /// assert_eq!(p.filestem_str(), Some(\"def\"));\n+    /// # }\n+    /// ```\n     #[inline]\n     fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n         self.filestem().and_then(str::from_utf8)\n     }\n+\n     /// Returns the extension of the filename of `self`, as an optional byte vector.\n     /// The extension is the portion of the filename just after the last '.'.\n     /// If there is no extension, None is returned.\n     /// If the filename ends in '.', the empty vector is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"abc/def.txt\");\n+    /// assert_eq!(p.extension(), Some(b\"txt\"));\n+    /// # }\n+    /// ```\n     fn extension<'a>(&'a self) -> Option<&'a [u8]> {\n         match self.filename() {\n             None => None,\n@@ -247,8 +407,20 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             }\n         }\n     }\n+\n     /// Returns the extension of the filename of `self`, as a string, if possible.\n     /// See `extension` for details.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"abc/def.txt\");\n+    /// assert_eq!(p.extension_str(), Some(\"txt\"));\n+    /// # }\n+    /// ```\n     #[inline]\n     fn extension_str<'a>(&'a self) -> Option<&'a str> {\n         self.extension().and_then(str::from_utf8)\n@@ -257,6 +429,18 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// Replaces the filename portion of the path with the given byte vector or string.\n     /// If the replacement name is [], this is equivalent to popping the path.\n     ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let mut p = Path::new(\"abc/def.txt\");\n+    /// p.set_filename(\"foo.dat\");\n+    /// assert!(p == Path::new(\"abc/foo.dat\"));\n+    /// # }\n+    /// ```\n+    ///\n     /// # Failure\n     ///\n     /// Fails the task if the filename contains a NUL.\n@@ -265,11 +449,24 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         assert!(!contains_nul(&filename));\n         unsafe { self.set_filename_unchecked(filename) }\n     }\n+\n     /// Replaces the extension with the given byte vector or string.\n     /// If there is no extension in `self`, this adds one.\n     /// If the argument is [] or \"\", this removes the extension.\n     /// If `self` has no filename, this is a no-op.\n     ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let mut p = Path::new(\"abc/def.txt\");\n+    /// p.set_extension(\"csv\");\n+    /// assert!(p == Path::new(\"abc/def.csv\"));\n+    /// # }\n+    /// ```\n+    ///\n     /// # Failure\n     ///\n     /// Fails the task if the extension contains a NUL.\n@@ -308,6 +505,17 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// byte vector or string.\n     /// See `set_filename` for details.\n     ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let mut p = Path::new(\"abc/def.txt\");\n+    /// assert!(p.with_filename(\"foo.dat\") == Path::new(\"abc/foo.dat\"));\n+    /// # }\n+    /// ```\n+    ///\n     /// # Failure\n     ///\n     /// Fails the task if the filename contains a NUL.\n@@ -317,10 +525,22 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         p.set_filename(filename);\n         p\n     }\n+\n     /// Returns a new Path constructed by setting the extension to the given\n     /// byte vector or string.\n     /// See `set_extension` for details.\n     ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let mut p = Path::new(\"abc/def.txt\");\n+    /// assert!(p.with_extension(\"csv\") == Path::new(\"abc/def.csv\"));\n+    /// # }\n+    /// ```\n+    ///\n     /// # Failure\n     ///\n     /// Fails the task if the extension contains a NUL.\n@@ -333,6 +553,17 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n \n     /// Returns the directory component of `self`, as a Path.\n     /// If `self` represents the root of the filesystem hierarchy, returns `self`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"abc/def/ghi\");\n+    /// assert!(p.dir_path() == Path::new(\"abc/def\"));\n+    /// # }\n+    /// ```\n     fn dir_path(&self) -> Self {\n         // self.dirname() returns a NUL-free vector\n         unsafe { GenericPathUnsafe::new_unchecked(self.dirname()) }\n@@ -341,11 +572,34 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// Returns a Path that represents the filesystem root that `self` is rooted in.\n     ///\n     /// If `self` is not absolute, or vol/cwd-relative in the case of Windows, this returns None.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// assert!(Path::new(\"abc/def\").root_path() == None);\n+    /// assert!(Path::new(\"/abc/def\").root_path() == Some(Path::new(\"/\")));\n+    /// # }\n+    /// ```\n     fn root_path(&self) -> Option<Self>;\n \n     /// Pushes a path (as a byte vector or string) onto `self`.\n     /// If the argument represents an absolute path, it replaces `self`.\n     ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let mut p = Path::new(\"foo/bar\");\n+    /// p.push(\"baz.txt\");\n+    /// assert!(p == Path::new(\"foo/bar/baz.txt\"));\n+    /// # }\n+    /// ```\n+    ///\n     /// # Failure\n     ///\n     /// Fails the task if the path contains a NUL.\n@@ -354,8 +608,21 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         assert!(!contains_nul(&path));\n         unsafe { self.push_unchecked(path) }\n     }\n+\n     /// Pushes multiple paths (as byte vectors or strings) onto `self`.\n     /// See `push` for details.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let mut p = Path::new(\"foo\");\n+    /// p.push_many(&[\"bar\", \"baz.txt\"]);\n+    /// assert!(p == Path::new(\"foo/bar/baz.txt\"));\n+    /// # }\n+    /// ```\n     #[inline]\n     fn push_many<T: BytesContainer>(&mut self, paths: &[T]) {\n         let t: Option<T> = None;\n@@ -369,15 +636,39 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             }\n         }\n     }\n+\n     /// Removes the last path component from the receiver.\n     /// Returns `true` if the receiver was modified, or `false` if it already\n     /// represented the root of the file hierarchy.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let mut p = Path::new(\"foo/bar/baz.txt\");\n+    /// p.pop();\n+    /// assert!(p == Path::new(\"foo/bar\"));\n+    /// # }\n+    /// ```\n     fn pop(&mut self) -> bool;\n \n     /// Returns a new Path constructed by joining `self` with the given path\n     /// (as a byte vector or string).\n     /// If the given path is absolute, the new Path will represent just that.\n     ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"/foo\");\n+    /// assert!(p.join(\"bar.txt\") == Path::new(\"/foo/bar.txt\"));\n+    /// # }\n+    /// ```\n+    ///\n     /// # Failure\n     ///\n     /// Fails the task if the path contains a NUL.\n@@ -387,9 +678,22 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         p.push(path);\n         p\n     }\n+\n     /// Returns a new Path constructed by joining `self` with the given paths\n     /// (as byte vectors or strings).\n     /// See `join` for details.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"foo\");\n+    /// let fbbq = Path::new(\"foo/bar/baz/quux.txt\");\n+    /// assert!(p.join_many(&[\"bar\", \"baz\", \"quux.txt\"]) == fbbq);\n+    /// # }\n+    /// ```\n     #[inline]\n     fn join_many<T: BytesContainer>(&self, paths: &[T]) -> Self {\n         let mut p = self.clone();\n@@ -400,28 +704,88 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// Returns whether `self` represents an absolute path.\n     /// An absolute path is defined as one that, when joined to another path, will\n     /// yield back the same absolute path.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"/abc/def\");\n+    /// assert!(p.is_absolute());\n+    /// # }\n+    /// ```\n     fn is_absolute(&self) -> bool;\n \n     /// Returns whether `self` represents a relative path.\n     /// Typically this is the inverse of `is_absolute`.\n     /// But for Windows paths, it also means the path is not volume-relative or\n     /// relative to the current working directory.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"abc/def\");\n+    /// assert!(p.is_relative());\n+    /// # }\n+    /// ```\n     fn is_relative(&self) -> bool {\n         !self.is_absolute()\n     }\n \n     /// Returns whether `self` is equal to, or is an ancestor of, the given path.\n     /// If both paths are relative, they are compared as though they are relative\n     /// to the same parent path.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"foo/bar/baz/quux.txt\");\n+    /// let fb = Path::new(\"foo/bar\");\n+    /// let bq = Path::new(\"baz/quux.txt\");\n+    /// assert!(fb.is_ancestor_of(&p));\n+    /// # }\n+    /// ```\n     fn is_ancestor_of(&self, other: &Self) -> bool;\n \n     /// Returns the Path that, were it joined to `base`, would yield `self`.\n     /// If no such path exists, None is returned.\n     /// If `self` is absolute and `base` is relative, or on Windows if both\n     /// paths refer to separate drives, an absolute path is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"foo/bar/baz/quux.txt\");\n+    /// let fb = Path::new(\"foo/bar\");\n+    /// let bq = Path::new(\"baz/quux.txt\");\n+    /// assert!(p.path_relative_from(&fb) == Some(bq));\n+    /// # }\n+    /// ```\n     fn path_relative_from(&self, base: &Self) -> Option<Self>;\n \n     /// Returns whether the relative path `child` is a suffix of `self`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # foo();\n+    /// # #[cfg(windows)] fn foo() {}\n+    /// # #[cfg(unix)] fn foo() {\n+    /// let p = Path::new(\"foo/bar/baz/quux.txt\");\n+    /// let bq = Path::new(\"baz/quux.txt\");\n+    /// assert!(p.ends_with_path(&bq));\n+    /// # }\n+    /// ```\n     fn ends_with_path(&self, child: &Self) -> bool;\n }\n "}, {"sha": "33daefa3e06b1a516cde3f069171c75d1763eed5", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -690,6 +690,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn expr_fail(&self, span: Span, msg: InternedString) -> Gc<ast::Expr> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n+        let expr_file = self.expr_str(span,\n+                                      token::intern_and_get_ident(loc.file\n+                                                                  .name\n+                                                                  .as_slice()));\n+        let expr_line = self.expr_uint(span, loc.line);\n+        let expr_file_line_tuple = self.expr_tuple(span, vec!(expr_file, expr_line));\n+        let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);\n         self.expr_call_global(\n             span,\n             vec!(\n@@ -698,11 +705,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 self.ident_of(\"begin_unwind\")),\n             vec!(\n                 self.expr_str(span, msg),\n-                self.expr_str(span,\n-                              token::intern_and_get_ident(loc.file\n-                                                             .name\n-                                                             .as_slice())),\n-                self.expr_uint(span, loc.line)))\n+                expr_file_line_ptr))\n     }\n \n     fn expr_unreachable(&self, span: Span) -> Gc<ast::Expr> {"}, {"sha": "9af28e771e1fbd17ec095ecaa050bae91724a636", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -164,7 +164,7 @@ impl<T: FloatMath + FromPrimitive> Summary<T> {\n     }\n }\n \n-impl<'a,T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n+impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n \n     // FIXME #11059 handle NaN, inf and overflow\n     fn sum(self) -> T {"}, {"sha": "0221b95b40434b23c721bdebd3a8df0b6e7cecb9", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -394,7 +394,7 @@ pub fn decode_form_urlencoded(s: &[u8])\n     }\n }\n \n-fn split_char_first<'a>(s: &'a str, c: char) -> (&'a str, &'a str) {\n+fn split_char_first(s: &str, c: char) -> (&str, &str) {\n     let mut iter = s.splitn(c, 1);\n \n     match (iter.next(), iter.next()) {\n@@ -466,7 +466,7 @@ pub fn query_to_str(query: &Query) -> String {\n /// };\n /// println!(\"Scheme in use: {}.\", scheme); // Scheme in use: https.\n /// ```\n-pub fn get_scheme<'a>(rawurl: &'a str) -> DecodeResult<(&'a str, &'a str)> {\n+pub fn get_scheme(rawurl: &str) -> DecodeResult<(&str, &str)> {\n     for (i,c) in rawurl.chars().enumerate() {\n         let result = match c {\n             'A' .. 'Z'\n@@ -493,8 +493,8 @@ pub fn get_scheme<'a>(rawurl: &'a str) -> DecodeResult<(&'a str, &'a str)> {\n }\n \n // returns userinfo, host, port, and unparsed part, or an error\n-fn get_authority<'a>(rawurl: &'a str) ->\n-    DecodeResult<(Option<UserInfo>, &'a str, Option<u16>, &'a str)> {\n+fn get_authority(rawurl: &str) ->\n+    DecodeResult<(Option<UserInfo>, &str, Option<u16>, &str)> {\n     enum State {\n         Start, // starting state\n         PassHostPort, // could be in user or port\n@@ -662,8 +662,7 @@ fn get_authority<'a>(rawurl: &'a str) ->\n \n \n // returns the path and unparsed part of url, or an error\n-fn get_path<'a>(rawurl: &'a str, is_authority: bool)\n-                                            -> DecodeResult<(String, &'a str)> {\n+fn get_path(rawurl: &str, is_authority: bool) -> DecodeResult<(String, &str)> {\n     let len = rawurl.len();\n     let mut end = len;\n     for (i,c) in rawurl.chars().enumerate() {"}, {"sha": "2ffed792abd4683dbb379920a7877a0d29c13fcf", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -29,6 +29,8 @@ unlikely.\n To create a new random (V4) UUID and print it out in hexadecimal form:\n \n ```rust\n+# #![allow(deprecated)]\n+# extern crate uuid;\n use uuid::Uuid;\n \n fn main() {\n@@ -55,7 +57,8 @@ Examples of string representations:\n */\n \n #![crate_name = \"uuid\"]\n-#![experimental]\n+#![deprecated = \"This is now a cargo package located at: \\\n+                 https://github.com/rust-lang/uuid\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![license = \"MIT/ASL2\"]\n@@ -312,7 +315,7 @@ impl Uuid {\n     }\n \n     /// Return an array of 16 octets containing the UUID data\n-    pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n+    pub fn as_bytes(&self) -> &[u8] {\n         self.bytes.as_slice()\n     }\n "}, {"sha": "5723b59a60b95c3bb3b89184c37f73fd9562229e", "filename": "src/test/auxiliary/lang-item-public.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flang-item-public.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -12,7 +12,7 @@\n #![feature(lang_items)]\n \n #[lang=\"fail_\"]\n-fn fail(_: &'static str, _: &'static str, _: uint) -> ! { loop {} }\n+fn fail(_: &(&'static str, &'static str, uint)) -> ! { loop {} }\n \n #[lang = \"stack_exhausted\"]\n extern fn stack_exhausted() {}"}, {"sha": "4637512216c40b15d3e72110ff0dbcb4ad54e1e9", "filename": "src/test/compile-fail/issue-16058.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+pub struct GslResult {\n+    pub val: f64,\n+    pub err: f64\n+}\n+\n+impl GslResult {\n+    pub fn new() -> GslResult {\n+        Result { //~ ERROR: `Result` does not name a structure\n+            val: 0f64,\n+            err: 0f64\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b03feb8fc224b050c2e822a23fcad972ad6bc618", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -10,33 +10,33 @@\n \n // ignore-test FIXME(#5121)\n \n-\n-extern crate time;\n+extern crate rbml;\n extern crate serialize;\n+extern crate time;\n \n // These tests used to be separate files, but I wanted to refactor all\n // the common code.\n \n use std::hashmap::{HashMap, HashSet};\n \n-use EBReader = serialize::ebml::reader;\n-use EBWriter = serialize::ebml::writer;\n+use EBReader = rbml::reader;\n+use EBWriter = rbml::writer;\n use std::cmp::Eq;\n use std::cmp;\n use std::io;\n use serialize::{Decodable, Encodable};\n \n-fn test_ebml<'a, 'b, A:\n+fn test_rbml<'a, 'b, A:\n     Eq +\n     Encodable<EBWriter::Encoder<'a>> +\n     Decodable<EBReader::Decoder<'b>>\n >(a1: &A) {\n     let mut wr = std::io::MemWriter::new();\n-    let mut ebml_w = EBwriter::Encoder::new(&mut wr);\n-    a1.encode(&mut ebml_w);\n+    let mut rbml_w = EBwriter::Encoder::new(&mut wr);\n+    a1.encode(&mut rbml_w);\n     let bytes = wr.get_ref();\n \n-    let d: serialize::ebml::Doc<'a> = EBDoc::new(bytes);\n+    let d: serialize::rbml::Doc<'a> = EBDoc::new(bytes);\n     let mut decoder: EBReader::Decoder<'a> = EBreader::Decoder::new(d);\n     let a2: A = Decodable::decode(&mut decoder);\n     assert!(*a1 == a2);\n@@ -133,40 +133,40 @@ enum CLike { A, B, C }\n \n pub fn main() {\n     let a = &Plus(@Minus(@Val(3u), @Val(10u)), @Plus(@Val(22u), @Val(5u)));\n-    test_ebml(a);\n+    test_rbml(a);\n \n     let a = &Spanned {lo: 0u, hi: 5u, node: 22u};\n-    test_ebml(a);\n+    test_rbml(a);\n \n     let a = &Point {x: 3u, y: 5u};\n-    test_ebml(a);\n+    test_rbml(a);\n \n     let a = &Top(22u);\n-    test_ebml(a);\n+    test_rbml(a);\n \n     let a = &Bottom(222u);\n-    test_ebml(a);\n+    test_rbml(a);\n \n     let a = &A;\n-    test_ebml(a);\n+    test_rbml(a);\n \n     let a = &B;\n-    test_ebml(a);\n+    test_rbml(a);\n \n     let a = &time::now();\n-    test_ebml(a);\n+    test_rbml(a);\n \n-    test_ebml(&1.0f32);\n-    test_ebml(&1.0f64);\n-    test_ebml(&'a');\n+    test_rbml(&1.0f32);\n+    test_rbml(&1.0f64);\n+    test_rbml(&'a');\n \n     let mut a = HashMap::new();\n-    test_ebml(&a);\n+    test_rbml(&a);\n     a.insert(1, 2);\n-    test_ebml(&a);\n+    test_rbml(&a);\n \n     let mut a = HashSet::new();\n-    test_ebml(&a);\n+    test_rbml(&a);\n     a.insert(1);\n-    test_ebml(&a);\n+    test_rbml(&a);\n }"}, {"sha": "0e4be12aa456d581f093b6e783cedfee35d36380", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -24,7 +24,10 @@ fn start(argc: int, argv: *const *const u8) -> int {\n \n #[inline(never)]\n fn foo() {\n-    fail!()\n+    let _v = vec![1i, 2, 3];\n+    if os::getenv(\"IS_TEST\").is_some() {\n+        fail!()\n+    }\n }\n \n #[inline(never)]\n@@ -37,32 +40,35 @@ fn double() {\n }\n \n fn runtest(me: &str) {\n+    let mut template = Command::new(me);\n+    template.env(\"IS_TEST\", \"1\");\n+\n     // Make sure that the stack trace is printed\n-    let mut p = Command::new(me).arg(\"fail\").env(\"RUST_BACKTRACE\", \"1\").spawn().unwrap();\n+    let p = template.clone().arg(\"fail\").env(\"RUST_BACKTRACE\", \"1\").spawn().unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(s.contains(\"stack backtrace\") && s.contains(\"foo::h\"),\n             \"bad output: {}\", s);\n \n     // Make sure the stack trace is *not* printed\n-    let mut p = Command::new(me).arg(\"fail\").spawn().unwrap();\n+    let p = template.clone().arg(\"fail\").spawn().unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(!s.contains(\"stack backtrace\") && !s.contains(\"foo::h\"),\n             \"bad output2: {}\", s);\n \n     // Make sure a stack trace is printed\n-    let mut p = Command::new(me).arg(\"double-fail\").spawn().unwrap();\n+    let p = template.clone().arg(\"double-fail\").spawn().unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(s.contains(\"stack backtrace\") && s.contains(\"double::h\"),\n             \"bad output3: {}\", s);\n \n     // Make sure a stack trace isn't printed too many times\n-    let mut p = Command::new(me).arg(\"double-fail\")\n+    let p = template.clone().arg(\"double-fail\")\n                                 .env(\"RUST_BACKTRACE\", \"1\").spawn().unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());"}, {"sha": "573b57fb44a46d772b18a6ac031cbc43882c109d", "filename": "src/test/run-pass/deriving-encodable-decodable.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -16,15 +16,16 @@\n #![feature(struct_variant)]\n \n extern crate rand;\n+extern crate rbml;\n extern crate serialize;\n \n use std::io::MemWriter;\n use rand::{random, Rand};\n+use rbml;\n+use rbml::Doc;\n+use rbml::writer::Encoder;\n+use rbml::reader::Decoder;\n use serialize::{Encodable, Decodable};\n-use serialize::ebml;\n-use serialize::ebml::Doc;\n-use serialize::ebml::writer::Encoder;\n-use serialize::ebml::reader::Decoder;\n \n #[deriving(Encodable, Decodable, Eq, Rand)]\n struct A;\n@@ -61,7 +62,7 @@ fn roundtrip<'a, T: Rand + Eq + Encodable<Encoder<'a>> +\n     let mut w = MemWriter::new();\n     let mut e = Encoder::new(&mut w);\n     obj.encode(&mut e);\n-    let doc = ebml::Doc::new(@w.get_ref());\n+    let doc = rbml::Doc::new(@w.get_ref());\n     let mut dec = Decoder::new(doc);\n     let obj2 = Decodable::decode(&mut dec);\n     assert!(obj == obj2);"}, {"sha": "206ab0dfeb2d06074568c2fde5c1150e2e7e08c3", "filename": "src/test/run-pass/for-loop-does-not-borrow-iterators.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Frun-pass%2Ffor-loop-does-not-borrow-iterators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Frun-pass%2Ffor-loop-does-not-borrow-iterators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-loop-does-not-borrow-iterators.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// The `for` loop use to keep a mutable borrow when executing its body,\n+// making it impossible to re-use the iterator as follows.\n+// https://github.com/rust-lang/rust/issues/8372\n+//\n+// This was fixed in https://github.com/rust-lang/rust/pull/15809\n+\n+pub fn main() {\n+    let mut for_loop_values = Vec::new();\n+    let mut explicit_next_call_values = Vec::new();\n+\n+    let mut iter = range(1i, 10);\n+    for i in iter {\n+        for_loop_values.push(i);\n+        explicit_next_call_values.push(iter.next());\n+    }\n+\n+    assert_eq!(for_loop_values, vec![1, 3, 5, 7, 9]);\n+    assert_eq!(explicit_next_call_values, vec![Some(2), Some(4), Some(6), Some(8), None]);\n+}"}, {"sha": "28fc4ce192e187cc84d532b35b6a5f1df1342f99", "filename": "src/test/run-pass/issue-11881.rs", "status": "modified", "additions": 6, "deletions": 117, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11881.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+extern crate rbml;\n extern crate serialize;\n \n use std::io;\n@@ -16,121 +17,9 @@ use std::slice;\n \n use serialize::{Encodable, Encoder};\n use serialize::json;\n-use serialize::ebml::writer;\n \n-static BUF_CAPACITY: uint = 128;\n-\n-fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n-    // compute offset as signed and clamp to prevent overflow\n-    let pos = match seek {\n-        io::SeekSet => 0,\n-        io::SeekEnd => end,\n-        io::SeekCur => cur,\n-    } as i64;\n-\n-    if offset + pos < 0 {\n-        Err(IoError {\n-            kind: io::InvalidInput,\n-            desc: \"invalid seek to a negative offset\",\n-            detail: None\n-        })\n-    } else {\n-        Ok((offset + pos) as u64)\n-    }\n-}\n-\n-/// Writes to an owned, growable byte vector that supports seeking.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// # #![allow(unused_must_use)]\n-/// use std::io::SeekableMemWriter;\n-///\n-/// let mut w = SeekableMemWriter::new();\n-/// w.write([0, 1, 2]);\n-///\n-/// assert_eq!(w.unwrap(), vec!(0, 1, 2));\n-/// ```\n-pub struct SeekableMemWriter {\n-    buf: Vec<u8>,\n-    pos: uint,\n-}\n-\n-impl SeekableMemWriter {\n-    /// Create a new `SeekableMemWriter`.\n-    #[inline]\n-    pub fn new() -> SeekableMemWriter {\n-        SeekableMemWriter::with_capacity(BUF_CAPACITY)\n-    }\n-    /// Create a new `SeekableMemWriter`, allocating at least `n` bytes for\n-    /// the internal buffer.\n-    #[inline]\n-    pub fn with_capacity(n: uint) -> SeekableMemWriter {\n-        SeekableMemWriter { buf: Vec::with_capacity(n), pos: 0 }\n-    }\n-\n-    /// Acquires an immutable reference to the underlying buffer of this\n-    /// `SeekableMemWriter`.\n-    ///\n-    /// No method is exposed for acquiring a mutable reference to the buffer\n-    /// because it could corrupt the state of this `MemWriter`.\n-    #[inline]\n-    pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n-\n-    /// Unwraps this `SeekableMemWriter`, returning the underlying buffer\n-    #[inline]\n-    pub fn unwrap(self) -> Vec<u8> { self.buf }\n-}\n-\n-impl Writer for SeekableMemWriter {\n-    #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        if self.pos == self.buf.len() {\n-            self.buf.push_all(buf)\n-        } else {\n-            // Make sure the internal buffer is as least as big as where we\n-            // currently are\n-            let difference = self.pos as i64 - self.buf.len() as i64;\n-            if difference > 0 {\n-                self.buf.grow(difference as uint, &0);\n-            }\n-\n-            // Figure out what bytes will be used to overwrite what's currently\n-            // there (left), and what will be appended on the end (right)\n-            let cap = self.buf.len() - self.pos;\n-            let (left, right) = if cap <= buf.len() {\n-                (buf.slice_to(cap), buf.slice_from(cap))\n-            } else {\n-                (buf, &[])\n-            };\n-\n-            // Do the necessary writes\n-            if left.len() > 0 {\n-                slice::bytes::copy_memory(self.buf.mut_slice_from(self.pos), left);\n-            }\n-            if right.len() > 0 {\n-                self.buf.push_all(right);\n-            }\n-        }\n-\n-        // Bump us forward\n-        self.pos += buf.len();\n-        Ok(())\n-    }\n-}\n-\n-impl Seek for SeekableMemWriter {\n-    #[inline]\n-    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-\n-    #[inline]\n-    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = new as uint;\n-        Ok(())\n-    }\n-}\n+use rbml::writer;\n+use rbml::io::SeekableMemWriter;\n \n #[deriving(Encodable)]\n struct Foo {\n@@ -144,7 +33,7 @@ struct Bar {\n \n enum WireProtocol {\n     JSON,\n-    EBML,\n+    RBML,\n     // ...\n }\n \n@@ -155,7 +44,7 @@ fn encode_json<'a,\n     let mut encoder = json::Encoder::new(wr);\n     val.encode(&mut encoder);\n }\n-fn encode_ebml<'a,\n+fn encode_rbml<'a,\n                T: Encodable<writer::Encoder<'a, SeekableMemWriter>,\n                             std::io::IoError>>(val: &T,\n                                                wr: &'a mut SeekableMemWriter) {\n@@ -169,6 +58,6 @@ pub fn main() {\n     let proto = JSON;\n     match proto {\n         JSON => encode_json(&target, &mut wr),\n-        EBML => encode_ebml(&target, &mut wr)\n+        RBML => encode_rbml(&target, &mut wr)\n     }\n }"}, {"sha": "c75c672546125bbbbef280a344252e4cb2d45b7f", "filename": "src/test/run-pass/issue-15858.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Frun-pass%2Fissue-15858.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b495933a7fdc5e7b28ddbb058d1e2dab330ace7b/src%2Ftest%2Frun-pass%2Fissue-15858.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15858.rs?ref=b495933a7fdc5e7b28ddbb058d1e2dab330ace7b", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsafe_destructor)]\n+\n+static mut DROP_RAN: bool = false;\n+\n+trait Bar<'b> {\n+    fn do_something(&mut self);\n+}\n+\n+struct BarImpl<'b>;\n+\n+impl<'b> Bar<'b> for BarImpl<'b> {\n+    fn do_something(&mut self) {}\n+}\n+\n+\n+struct Foo<B>;\n+\n+#[unsafe_destructor]\n+impl<'b, B: Bar<'b>> Drop for Foo<B> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            DROP_RAN = true;\n+        }\n+    }\n+}\n+\n+\n+fn main() {\n+    {\n+       let _x: Foo<BarImpl> = Foo;\n+    }\n+    unsafe {\n+        assert_eq!(DROP_RAN, true);\n+    }\n+}"}]}