{"sha": "b4fda6ef06be190aa655bb23a9c66e46589daff4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ZmRhNmVmMDZiZTE5MGFhNjU1YmIyM2E5YzY2ZTQ2NTg5ZGFmZjQ=", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-04-25T22:01:05Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-04-26T01:27:03Z"}, "message": "Give rounding intrinsics their own modules", "tree": {"sha": "f039d260ce92faa5350613f5be22af59d1291b0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f039d260ce92faa5350613f5be22af59d1291b0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4fda6ef06be190aa655bb23a9c66e46589daff4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4fda6ef06be190aa655bb23a9c66e46589daff4", "html_url": "https://github.com/rust-lang/rust/commit/b4fda6ef06be190aa655bb23a9c66e46589daff4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4fda6ef06be190aa655bb23a9c66e46589daff4/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24ebae870e11ed60a83ca0acccc202387f95f25f", "url": "https://api.github.com/repos/rust-lang/rust/commits/24ebae870e11ed60a83ca0acccc202387f95f25f", "html_url": "https://github.com/rust-lang/rust/commit/24ebae870e11ed60a83ca0acccc202387f95f25f"}], "stats": {"total": 144, "additions": 81, "deletions": 63}, "files": [{"sha": "e8bcca22f6842b57c9a72d1dca0d1e883774160a", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b4fda6ef06be190aa655bb23a9c66e46589daff4/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4fda6ef06be190aa655bb23a9c66e46589daff4/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=b4fda6ef06be190aa655bb23a9c66e46589daff4", "patch": "@@ -43,14 +43,6 @@ extern \"platform-intrinsic\" {\n     /// neg/fneg\n     pub(crate) fn simd_neg<T>(x: T) -> T;\n \n-    // floor\n-    #[cfg(feature = \"std\")]\n-    pub(crate) fn simd_floor<T>(x: T) -> T;\n-\n-    // ceil\n-    #[cfg(feature = \"std\")]\n-    pub(crate) fn simd_ceil<T>(x: T) -> T;\n-\n     /// fabs\n     pub(crate) fn simd_fabs<T>(x: T) -> T;\n \n@@ -85,3 +77,17 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_reduce_or<T, U>(x: T) -> U;\n     pub(crate) fn simd_reduce_xor<T, U>(x: T) -> U;\n }\n+\n+#[cfg(feature = \"std\")]\n+mod std {\n+    extern \"platform-intrinsic\" {\n+        // ceil\n+        pub(crate) fn simd_ceil<T>(x: T) -> T;\n+\n+        // floor\n+        pub(crate) fn simd_floor<T>(x: T) -> T;\n+    }\n+}\n+\n+#[cfg(feature = \"std\")]\n+pub(crate) use crate::intrinsics::std::*;"}, {"sha": "1855c1480d267b72bdd416d8ec917d17135cd9ea", "filename": "crates/core_simd/src/round.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4fda6ef06be190aa655bb23a9c66e46589daff4/crates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4fda6ef06be190aa655bb23a9c66e46589daff4/crates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fround.rs?ref=b4fda6ef06be190aa655bb23a9c66e46589daff4", "patch": "@@ -2,20 +2,19 @@ macro_rules! implement {\n     {\n         $type:ident, $int_type:ident\n     } => {\n+        #[cfg(feature = \"std\")]\n         impl<const LANES: usize> crate::$type<LANES>\n         where\n             Self: crate::LanesAtMost32,\n         {\n             /// Returns the largest integer less than or equal to each lane.\n-            #[cfg(feature = \"std\")]\n             #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             #[inline]\n             pub fn floor(self) -> Self {\n                 unsafe { crate::intrinsics::simd_floor(self) }\n             }\n \n             /// Returns the smallest integer greater than or equal to each lane.\n-            #[cfg(feature = \"std\")]\n             #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             #[inline]\n             pub fn ceil(self) -> Self {"}, {"sha": "9f9992258770166038e83aa73d611f7275fb2298", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b4fda6ef06be190aa655bb23a9c66e46589daff4/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4fda6ef06be190aa655bb23a9c66e46589daff4/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=b4fda6ef06be190aa655bb23a9c66e46589daff4", "patch": "@@ -353,7 +353,6 @@ macro_rules! impl_float_tests {\n         mod $scalar {\n             type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n             type Scalar = $scalar;\n-            type IntScalar = $int_scalar;\n \n             impl_unary_op_test!(Vector<LANES>, Scalar, Neg::neg);\n             impl_binary_op_test!(Vector<LANES>, Scalar, Add::add, AddAssign::add_assign);\n@@ -362,25 +361,6 @@ macro_rules! impl_float_tests {\n             impl_binary_op_test!(Vector<LANES>, Scalar, Div::div, DivAssign::div_assign);\n             impl_binary_op_test!(Vector<LANES>, Scalar, Rem::rem, RemAssign::rem_assign);\n \n-            #[cfg(feature = \"std\")]\n-            test_helpers::test_lanes! {\n-                fn ceil<const LANES: usize>() {\n-                    test_helpers::test_unary_elementwise(\n-                        &Vector::<LANES>::ceil,\n-                        &Scalar::ceil,\n-                        &|_| true,\n-                    )\n-                }\n-\n-                fn floor<const LANES: usize>() {\n-                    test_helpers::test_unary_elementwise(\n-                        &Vector::<LANES>::floor,\n-                        &Scalar::floor,\n-                        &|_| true,\n-                    )\n-                }\n-            }\n-\n             test_helpers::test_lanes! {\n                 fn is_sign_positive<const LANES: usize>() {\n                     test_helpers::test_unary_mask_elementwise(\n@@ -446,39 +426,6 @@ macro_rules! impl_float_tests {\n                     )\n                 }\n \n-                fn round_from_int<const LANES: usize>() {\n-                    test_helpers::test_unary_elementwise(\n-                        &Vector::<LANES>::round_from_int,\n-                        &|x| x as Scalar,\n-                        &|_| true,\n-                    )\n-                }\n-\n-                fn to_int_unchecked<const LANES: usize>() {\n-                    // The maximum integer that can be represented by the equivalently sized float has\n-                    // all of the mantissa digits set to 1, pushed up to the MSB.\n-                    const ALL_MANTISSA_BITS: IntScalar = ((1 << <Scalar>::MANTISSA_DIGITS) - 1);\n-                    const MAX_REPRESENTABLE_VALUE: Scalar =\n-                        (ALL_MANTISSA_BITS << (core::mem::size_of::<Scalar>() * 8 - <Scalar>::MANTISSA_DIGITS as usize - 1)) as Scalar;\n-\n-                    let mut runner = proptest::test_runner::TestRunner::default();\n-                    runner.run(\n-                        &test_helpers::array::UniformArrayStrategy::new(-MAX_REPRESENTABLE_VALUE..MAX_REPRESENTABLE_VALUE),\n-                        |x| {\n-                            let result_1 = unsafe { Vector::from_array(x).to_int_unchecked().to_array() };\n-                            let result_2 = {\n-                                let mut result = [0; LANES];\n-                                for (i, o) in x.iter().zip(result.iter_mut()) {\n-                                    *o = unsafe { i.to_int_unchecked() };\n-                                }\n-                                result\n-                            };\n-                            test_helpers::prop_assert_biteq!(result_1, result_2);\n-                            Ok(())\n-                        },\n-                    ).unwrap();\n-                }\n-\n                 fn horizontal_sum<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n                         test_helpers::prop_assert_biteq! ("}, {"sha": "dc9c8ad4ad25c71877861655ce162c74bf10eaff", "filename": "crates/core_simd/tests/round.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b4fda6ef06be190aa655bb23a9c66e46589daff4/crates%2Fcore_simd%2Ftests%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4fda6ef06be190aa655bb23a9c66e46589daff4/crates%2Fcore_simd%2Ftests%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fround.rs?ref=b4fda6ef06be190aa655bb23a9c66e46589daff4", "patch": "@@ -0,0 +1,66 @@\n+macro_rules! float_rounding_test {\n+    { $vector:ident, $scalar:tt, $int_scalar:tt } => {\n+        mod $scalar {\n+            type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n+            type Scalar = $scalar;\n+            type IntScalar = $int_scalar;\n+\n+            #[cfg(feature = \"std\")]\n+            test_helpers::test_lanes! {\n+                fn ceil<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::ceil,\n+                        &Scalar::ceil,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn floor<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::floor,\n+                        &Scalar::floor,\n+                        &|_| true,\n+                    )\n+                }\n+            }\n+\n+            test_helpers::test_lanes! {\n+                fn from_int<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::round_from_int,\n+                        &|x| x as Scalar,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn to_int_unchecked<const LANES: usize>() {\n+                    // The maximum integer that can be represented by the equivalently sized float has\n+                    // all of the mantissa digits set to 1, pushed up to the MSB.\n+                    const ALL_MANTISSA_BITS: IntScalar = ((1 << <Scalar>::MANTISSA_DIGITS) - 1);\n+                    const MAX_REPRESENTABLE_VALUE: Scalar =\n+                        (ALL_MANTISSA_BITS << (core::mem::size_of::<Scalar>() * 8 - <Scalar>::MANTISSA_DIGITS as usize - 1)) as Scalar;\n+\n+                    let mut runner = proptest::test_runner::TestRunner::default();\n+                    runner.run(\n+                        &test_helpers::array::UniformArrayStrategy::new(-MAX_REPRESENTABLE_VALUE..MAX_REPRESENTABLE_VALUE),\n+                        |x| {\n+                            let result_1 = unsafe { Vector::from_array(x).to_int_unchecked().to_array() };\n+                            let result_2 = {\n+                                let mut result = [0; LANES];\n+                                for (i, o) in x.iter().zip(result.iter_mut()) {\n+                                    *o = unsafe { i.to_int_unchecked() };\n+                                }\n+                                result\n+                            };\n+                            test_helpers::prop_assert_biteq!(result_1, result_2);\n+                            Ok(())\n+                        },\n+                    ).unwrap();\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+float_rounding_test! { SimdF32, f32, i32 }\n+float_rounding_test! { SimdF64, f64, i64 }"}]}