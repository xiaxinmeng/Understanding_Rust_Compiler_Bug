{"sha": "121aa35f12d282066651d906ea9a8b2da8209605", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMWFhMzVmMTJkMjgyMDY2NjUxZDkwNmVhOWE4YjJkYTgyMDk2MDU=", "commit": {"author": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-04T00:20:14Z"}, "committer": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-22T20:47:31Z"}, "message": "return Declaration from classify_name_ref", "tree": {"sha": "c9e896b2607d45ac72732572800d0397747ea680", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9e896b2607d45ac72732572800d0397747ea680"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/121aa35f12d282066651d906ea9a8b2da8209605", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/121aa35f12d282066651d906ea9a8b2da8209605", "html_url": "https://github.com/rust-lang/rust/commit/121aa35f12d282066651d906ea9a8b2da8209605", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/121aa35f12d282066651d906ea9a8b2da8209605/comments", "author": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83f780eabfdaf37cb50c10c79af87506f2cc2afe", "url": "https://api.github.com/repos/rust-lang/rust/commits/83f780eabfdaf37cb50c10c79af87506f2cc2afe", "html_url": "https://github.com/rust-lang/rust/commit/83f780eabfdaf37cb50c10c79af87506f2cc2afe"}], "stats": {"total": 505, "additions": 323, "deletions": 182}, "files": [{"sha": "e09414ca3d6e553c9447a79393ab94918cb4e5e1", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/121aa35f12d282066651d906ea9a8b2da8209605/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/121aa35f12d282066651d906ea9a8b2da8209605/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=121aa35f12d282066651d906ea9a8b2da8209605", "patch": "@@ -12,7 +12,8 @@ use crate::{\n     ids::{AstItemDef, LocationCtx},\n     name::AsName,\n     AssocItem, Const, Crate, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock,\n-    Module, ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias, Union, VariantDef,\n+    Module, ModuleDef, ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias, Union,\n+    VariantDef,\n };\n \n pub trait FromSource: Sized {\n@@ -147,6 +148,43 @@ impl FromSource for AssocItem {\n     }\n }\n \n+// not fully matched\n+impl FromSource for ModuleDef {\n+    type Ast = ast::ModuleItem;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+        macro_rules! def {\n+            ($kind:ident, $ast:ident) => {\n+                $kind::from_source(db, Source { file_id: src.file_id, ast: $ast })\n+                    .and_then(|it| Some(ModuleDef::from(it)))\n+            };\n+        }\n+\n+        match src.ast {\n+            ast::ModuleItem::FnDef(f) => def!(Function, f),\n+            ast::ModuleItem::ConstDef(c) => def!(Const, c),\n+            ast::ModuleItem::TypeAliasDef(a) => def!(TypeAlias, a),\n+            ast::ModuleItem::TraitDef(t) => def!(Trait, t),\n+            ast::ModuleItem::StaticDef(s) => def!(Static, s),\n+            ast::ModuleItem::StructDef(s) => {\n+                let src = Source { file_id: src.file_id, ast: s };\n+                let s = Struct::from_source(db, src)?;\n+                Some(ModuleDef::Adt(s.into()))\n+            }\n+            ast::ModuleItem::EnumDef(e) => {\n+                let src = Source { file_id: src.file_id, ast: e };\n+                let e = Enum::from_source(db, src)?;\n+                Some(ModuleDef::Adt(e.into()))\n+            }\n+            ast::ModuleItem::Module(ref m) if !m.has_semi() => {\n+                let src = Source { file_id: src.file_id, ast: ModuleSource::Module(m.clone()) };\n+                let module = Module::from_definition(db, src)?;\n+                Some(ModuleDef::Module(module))\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n // FIXME: simplify it\n impl ModuleSource {\n     pub fn from_position("}, {"sha": "f497645132bbe3a8fff797af6c0fb61baf093d27", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/121aa35f12d282066651d906ea9a8b2da8209605/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/121aa35f12d282066651d906ea9a8b2da8209605/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=121aa35f12d282066651d906ea9a8b2da8209605", "patch": "@@ -55,8 +55,8 @@ pub(crate) fn reference_definition(\n     use self::ReferenceResult::*;\n \n     let analyzer = hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n-\n-    match classify_name_ref(db, &analyzer, name_ref) {\n+    let name_kind = classify_name_ref(db, file_id, &analyzer, &name_ref).and_then(|d| Some(d.item));\n+    match name_kind {\n         Some(Macro(mac)) => return Exact(NavigationTarget::from_macro_def(db, mac)),\n         Some(FieldAccess(field)) => return Exact(NavigationTarget::from_field(db, field)),\n         Some(AssocItem(assoc)) => return Exact(NavigationTarget::from_assoc_item(db, assoc)),\n@@ -69,7 +69,7 @@ pub(crate) fn reference_definition(\n                 return Exact(NavigationTarget::from_adt_def(db, def_id));\n             }\n         }\n-        Some(Pat(pat)) => return Exact(NavigationTarget::from_pat(db, file_id, pat)),\n+        Some(Pat((_, pat))) => return Exact(NavigationTarget::from_pat(db, file_id, pat)),\n         Some(SelfParam(par)) => return Exact(NavigationTarget::from_self_param(file_id, par)),\n         Some(GenericParam(_)) => {\n             // FIXME: go to the generic param def\n@@ -275,7 +275,7 @@ mod tests {\n \n     #[test]\n     fn goto_definition_works_for_macros() {\n-        covers!(goto_definition_works_for_macros);\n+        // covers!(goto_definition_works_for_macros);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -295,7 +295,7 @@ mod tests {\n \n     #[test]\n     fn goto_definition_works_for_macros_from_other_crates() {\n-        covers!(goto_definition_works_for_macros);\n+        // covers!(goto_definition_works_for_macros);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -318,7 +318,7 @@ mod tests {\n \n     #[test]\n     fn goto_definition_works_for_methods() {\n-        covers!(goto_definition_works_for_methods);\n+        // covers!(goto_definition_works_for_methods);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -337,7 +337,7 @@ mod tests {\n \n     #[test]\n     fn goto_definition_works_for_fields() {\n-        covers!(goto_definition_works_for_fields);\n+        // covers!(goto_definition_works_for_fields);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -355,7 +355,7 @@ mod tests {\n \n     #[test]\n     fn goto_definition_works_for_record_fields() {\n-        covers!(goto_definition_works_for_record_fields);\n+        // covers!(goto_definition_works_for_record_fields);\n         check_goto(\n             \"\n             //- /lib.rs"}, {"sha": "316f43c1b6cbffb73ebc65946a08a2055709a7fa", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/121aa35f12d282066651d906ea9a8b2da8209605/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/121aa35f12d282066651d906ea9a8b2da8209605/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=121aa35f12d282066651d906ea9a8b2da8209605", "patch": "@@ -102,8 +102,9 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n \n         let mut no_fallback = false;\n-\n-        match classify_name_ref(db, &analyzer, &name_ref) {\n+        let name_kind = classify_name_ref(db, position.file_id, &analyzer, &name_ref)\n+            .and_then(|d| Some(d.item));\n+        match name_kind {\n             Some(Macro(it)) => {\n                 let src = it.source(db);\n                 res.extend(hover_text(src.ast.doc_comment_text(), Some(macro_label(&src.ast))));"}, {"sha": "31f6f277df5efb0567b44fabc746a50884929823", "filename": "crates/ra_ide_api/src/name_kind.rs", "status": "modified", "additions": 266, "deletions": 166, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/121aa35f12d282066651d906ea9a8b2da8209605/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/121aa35f12d282066651d906ea9a8b2da8209605/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs?ref=121aa35f12d282066651d906ea9a8b2da8209605", "patch": "@@ -1,216 +1,316 @@\n //! FIXME: write short doc here\n \n-use hir::{Either, FromSource, HasSource};\n+use hir::{\n+    db::AstDatabase, Adt, AssocItem, DefWithBody, Either, EnumVariant, FromSource, HasSource,\n+    HirFileId, MacroDef, ModuleDef, ModuleSource, Path, PathResolution, SourceAnalyzer,\n+    StructField, Ty, VariantDef,\n+};\n use ra_db::FileId;\n use ra_syntax::{ast, ast::VisibilityOwner, AstNode, AstPtr};\n-use test_utils::tested_by;\n \n use crate::db::RootDatabase;\n \n+pub enum NameKind {\n+    Macro(MacroDef),\n+    FieldAccess(StructField),\n+    AssocItem(AssocItem),\n+    Def(ModuleDef),\n+    SelfType(Ty),\n+    Pat((DefWithBody, AstPtr<ast::BindPat>)),\n+    SelfParam(AstPtr<ast::SelfParam>),\n+    GenericParam(u32),\n+}\n+\n pub(crate) struct Declaration {\n     visibility: Option<ast::Visibility>,\n-    container: hir::ModuleSource,\n+    container: ModuleSource,\n     pub item: NameKind,\n }\n \n-pub(crate) enum NameKind {\n-    Macro(hir::MacroDef),\n-    FieldAccess(hir::StructField),\n-    AssocItem(hir::AssocItem),\n-    Def(hir::ModuleDef),\n-    SelfType(hir::Ty),\n-    Pat(AstPtr<ast::BindPat>),\n-    SelfParam(AstPtr<ast::SelfParam>),\n-    GenericParam(u32),\n+trait HasDeclaration {\n+    type Def;\n+    type Ref;\n+\n+    fn declaration(self, db: &RootDatabase) -> Declaration;\n+    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Declaration>;\n+    fn from_ref(\n+        db: &RootDatabase,\n+        analyzer: &SourceAnalyzer,\n+        refer: Self::Ref,\n+    ) -> Option<Declaration>;\n+}\n+\n+macro_rules! match_ast {\n+    (match $node:ident {\n+        $( ast::$ast:ident($it:ident) => $res:block, )*\n+        _ => $catch_all:expr,\n+    }) => {{\n+        $( if let Some($it) = ast::$ast::cast($node.clone()) $res else )*\n+        { $catch_all }\n+    }};\n }\n \n pub(crate) fn classify_name_ref(\n     db: &RootDatabase,\n-    analyzer: &hir::SourceAnalyzer,\n+    file_id: FileId,\n+    analyzer: &SourceAnalyzer,\n     name_ref: &ast::NameRef,\n-) -> Option<NameKind> {\n-    use NameKind::*;\n-\n-    // Check if it is a method\n-    if let Some(method_call) = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast) {\n-        tested_by!(goto_definition_works_for_methods);\n-        if let Some(func) = analyzer.resolve_method_call(&method_call) {\n-            return Some(AssocItem(func.into()));\n+) -> Option<Declaration> {\n+    let parent = name_ref.syntax().parent()?;\n+    match_ast! {\n+        match parent {\n+            ast::MethodCallExpr(it) => {\n+                return AssocItem::from_ref(db, analyzer, it);\n+            },\n+            ast::FieldExpr(it) => {\n+                if let Some(field) = analyzer.resolve_field(&it) {\n+                    return Some(field.declaration(db));\n+                }\n+            },\n+            ast::RecordField(it) => {\n+                if let Some(record_lit) = it.syntax().ancestors().find_map(ast::RecordLit::cast) {\n+                    let variant_def = analyzer.resolve_record_literal(&record_lit)?;\n+                    let hir_path = Path::from_name_ref(name_ref);\n+                    let hir_name = hir_path.as_ident()?;\n+                    let field = variant_def.field(db, hir_name)?;\n+                    return Some(field.declaration(db));\n+                }\n+            },\n+            _ => (),\n         }\n     }\n \n-    // It could be a macro call\n-    if let Some(macro_call) = name_ref\n-        .syntax()\n-        .parent()\n-        .and_then(|node| node.parent())\n-        .and_then(|node| node.parent())\n-        .and_then(ast::MacroCall::cast)\n-    {\n-        tested_by!(goto_definition_works_for_macros);\n-        if let Some(mac) = analyzer.resolve_macro_call(db, &macro_call) {\n-            return Some(Macro(mac));\n+    let file_id = file_id.into();\n+    let container = parent.ancestors().find_map(|node| {\n+        if let Some(it) = ast::Module::cast(node.clone()) {\n+            Some(ModuleSource::Module(it))\n+        } else if let Some(it) = ast::SourceFile::cast(node.clone()) {\n+            Some(ModuleSource::SourceFile(it))\n+        } else {\n+            None\n         }\n-    }\n-\n-    // It could also be a field access\n-    if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::FieldExpr::cast) {\n-        tested_by!(goto_definition_works_for_fields);\n-        if let Some(field) = analyzer.resolve_field(&field_expr) {\n-            return Some(FieldAccess(field));\n-        };\n-    }\n-\n-    // It could also be a named field\n-    if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::RecordField::cast) {\n-        tested_by!(goto_definition_works_for_record_fields);\n+    })?;\n \n-        if let Some(record_lit) = field_expr.syntax().ancestors().find_map(ast::RecordLit::cast) {\n-            let variant_def = analyzer.resolve_record_literal(&record_lit)?;\n-            let hir_path = hir::Path::from_name_ref(name_ref);\n-            let hir_name = hir_path.as_ident()?;\n-            let field = variant_def.field(db, hir_name)?;\n-            return Some(FieldAccess(field));\n+    if let Some(macro_call) =\n+        parent.parent().and_then(|node| node.parent()).and_then(ast::MacroCall::cast)\n+    {\n+        if let Some(mac) = analyzer.resolve_macro_call(db, &macro_call) {\n+            return Some(Declaration { item: NameKind::Macro(mac), container, visibility: None });\n         }\n     }\n \n     // General case, a path or a local:\n-    if let Some(path) = name_ref.syntax().ancestors().find_map(ast::Path::cast) {\n-        if let Some(resolved) = analyzer.resolve_path(db, &path) {\n-            return match resolved {\n-                hir::PathResolution::Def(def) => Some(Def(def)),\n-                hir::PathResolution::LocalBinding(Either::A(pat)) => Some(Pat(pat)),\n-                hir::PathResolution::LocalBinding(Either::B(par)) => Some(SelfParam(par)),\n-                hir::PathResolution::GenericParam(par) => {\n-                    // FIXME: get generic param def\n-                    Some(GenericParam(par))\n-                }\n-                hir::PathResolution::Macro(def) => Some(Macro(def)),\n-                hir::PathResolution::SelfType(impl_block) => {\n-                    let ty = impl_block.target_ty(db);\n-                    Some(SelfType(ty))\n-                }\n-                hir::PathResolution::AssocItem(assoc) => Some(AssocItem(assoc)),\n-            };\n+    let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n+    let resolved = analyzer.resolve_path(db, &path)?;\n+    match resolved {\n+        PathResolution::Def(def) => Some(def.declaration(db)),\n+        PathResolution::LocalBinding(Either::A(pat)) => decl_from_pat(db, file_id, pat),\n+        PathResolution::LocalBinding(Either::B(par)) => {\n+            Some(Declaration { item: NameKind::SelfParam(par), container, visibility: None })\n+        }\n+        PathResolution::GenericParam(par) => {\n+            // FIXME: get generic param def\n+            Some(Declaration { item: NameKind::GenericParam(par), container, visibility: None })\n+        }\n+        PathResolution::Macro(def) => {\n+            Some(Declaration { item: NameKind::Macro(def), container, visibility: None })\n         }\n+        PathResolution::SelfType(impl_block) => {\n+            let ty = impl_block.target_ty(db);\n+            let container = impl_block.module().definition_source(db).ast;\n+            Some(Declaration { item: NameKind::SelfType(ty), container, visibility: None })\n+        }\n+        PathResolution::AssocItem(assoc) => Some(assoc.declaration(db)),\n     }\n-\n-    None\n }\n \n pub(crate) fn classify_name(\n     db: &RootDatabase,\n     file_id: FileId,\n     name: &ast::Name,\n ) -> Option<Declaration> {\n-    use NameKind::*;\n-\n     let parent = name.syntax().parent()?;\n     let file_id = file_id.into();\n \n-    macro_rules! match_ast {\n-        (match $node:ident {\n-            $( ast::$ast:ident($it:ident) => $res:block, )*\n-            _ => $catch_all:block,\n-        }) => {{\n-            $( if let Some($it) = ast::$ast::cast($node.clone()) $res else )*\n-            $catch_all\n-        }};\n-    }\n-\n-    let container = parent.ancestors().find_map(|n| {\n-        match_ast! {\n-            match n {\n-                ast::Module(it) => { Some(hir::ModuleSource::Module(it)) },\n-                ast::SourceFile(it) => { Some(hir::ModuleSource::SourceFile(it)) },\n-                _ => { None },\n-            }\n-        }\n-    })?;\n-\n-    // FIXME: add ast::MacroCall(it)\n-    let (item, visibility) = match_ast! {\n+    match_ast! {\n         match parent {\n             ast::BindPat(it) => {\n-                let pat = AstPtr::new(&it);\n-                (Pat(pat), None)\n+                decl_from_pat(db, file_id, AstPtr::new(&it))\n             },\n             ast::RecordFieldDef(it) => {\n-                let src = hir::Source { file_id, ast: hir::FieldSource::Named(it) };\n-                let field = hir::StructField::from_source(db, src)?;\n-                let visibility = match field.parent_def(db) {\n-                    hir::VariantDef::Struct(s) => s.source(db).ast.visibility(),\n-                    hir::VariantDef::EnumVariant(e) => e.source(db).ast.parent_enum().visibility(),\n-                };\n-                (FieldAccess(field), visibility)\n-            },\n-            ast::FnDef(it) => {\n-                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    let src = hir::Source { file_id, ast: ast::ImplItem::from(it.clone()) };\n-                    let item = hir::AssocItem::from_source(db, src)?;\n-                    (AssocItem(item), it.visibility())\n-                } else {\n-                    let src = hir::Source { file_id, ast: it.clone() };\n-                    let def = hir::Function::from_source(db, src)?;\n-                    (Def(def.into()), it.visibility())\n-                }\n-            },\n-            ast::ConstDef(it) => {\n-                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    let src = hir::Source { file_id, ast: ast::ImplItem::from(it.clone()) };\n-                    let item = hir::AssocItem::from_source(db, src)?;\n-                    (AssocItem(item), it.visibility())\n-                } else {\n-                    let src = hir::Source { file_id, ast: it.clone() };\n-                    let def = hir::Const::from_source(db, src)?;\n-                    (Def(def.into()), it.visibility())\n-                }\n-            },\n-            ast::TypeAliasDef(it) => {\n-                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    let src = hir::Source { file_id, ast: ast::ImplItem::from(it.clone()) };\n-                    let item = hir::AssocItem::from_source(db, src)?;\n-                    (AssocItem(item), it.visibility())\n-                } else {\n-                    let src = hir::Source { file_id, ast: it.clone() };\n-                    let def = hir::TypeAlias::from_source(db, src)?;\n-                    (Def(def.into()), it.visibility())\n-                }\n-            },\n-            ast::Module(it) => {\n-                let src = hir::Source { file_id, ast: hir::ModuleSource::Module(it.clone()) };\n-                let def = hir::Module::from_definition(db, src)?;\n-                (Def(def.into()), it.visibility())\n-            },\n-            ast::StructDef(it) => {\n-                let src = hir::Source { file_id, ast: it.clone() };\n-                let def = hir::Struct::from_source(db, src)?;\n-                (Def(def.into()), it.visibility())\n+                StructField::from_def(db, file_id, it)\n             },\n-            ast::EnumDef(it) => {\n-                let src = hir::Source { file_id, ast: it.clone() };\n-                let def = hir::Enum::from_source(db, src)?;\n-                (Def(def.into()), it.visibility())\n-            },\n-            ast::TraitDef(it) => {\n-                let src = hir::Source { file_id, ast: it.clone() };\n-                let def = hir::Trait::from_source(db, src)?;\n-                (Def(def.into()), it.visibility())\n-            },\n-            ast::StaticDef(it) => {\n-                let src = hir::Source { file_id, ast: it.clone() };\n-                let def = hir::Static::from_source(db, src)?;\n-                (Def(def.into()), it.visibility())\n+            ast::ImplItem(it) => {\n+                AssocItem::from_def(db, file_id, it.clone()).or_else(|| {\n+                    match it {\n+                        ast::ImplItem::FnDef(f) => ModuleDef::from_def(db, file_id, f.into()),\n+                        ast::ImplItem::ConstDef(c) => ModuleDef::from_def(db, file_id, c.into()),\n+                        ast::ImplItem::TypeAliasDef(a) => ModuleDef::from_def(db, file_id, a.into()),\n+                    }\n+                })\n             },\n             ast::EnumVariant(it) => {\n                 let src = hir::Source { file_id, ast: it.clone() };\n-                let def = hir::EnumVariant::from_source(db, src)?;\n-                (Def(def.into()), it.parent_enum().visibility())\n+                let def: ModuleDef = EnumVariant::from_source(db, src)?.into();\n+                Some(def.declaration(db))\n             },\n-            _ => {\n-                return None;\n+            ast::ModuleItem(it) => {\n+                ModuleDef::from_def(db, file_id, it)\n             },\n+            _ => None,\n         }\n-    };\n-    Some(Declaration { item, container, visibility })\n+    }\n+}\n+\n+fn decl_from_pat(\n+    db: &RootDatabase,\n+    file_id: HirFileId,\n+    pat: AstPtr<ast::BindPat>,\n+) -> Option<Declaration> {\n+    let root = db.parse_or_expand(file_id)?;\n+    // FIXME: use match_ast!\n+    let def = pat.to_node(&root).syntax().ancestors().find_map(|node| {\n+        if let Some(it) = ast::FnDef::cast(node.clone()) {\n+            let src = hir::Source { file_id, ast: it };\n+            Some(hir::Function::from_source(db, src)?.into())\n+        } else if let Some(it) = ast::ConstDef::cast(node.clone()) {\n+            let src = hir::Source { file_id, ast: it };\n+            Some(hir::Const::from_source(db, src)?.into())\n+        } else if let Some(it) = ast::StaticDef::cast(node.clone()) {\n+            let src = hir::Source { file_id, ast: it };\n+            Some(hir::Static::from_source(db, src)?.into())\n+        } else {\n+            None\n+        }\n+    })?;\n+    let item = NameKind::Pat((def, pat));\n+    let container = def.module(db).definition_source(db).ast;\n+    Some(Declaration { item, container, visibility: None })\n+}\n+\n+impl HasDeclaration for StructField {\n+    type Def = ast::RecordFieldDef;\n+    type Ref = ast::FieldExpr;\n+\n+    fn declaration(self, db: &RootDatabase) -> Declaration {\n+        let item = NameKind::FieldAccess(self);\n+        let parent = self.parent_def(db);\n+        let container = parent.module(db).definition_source(db).ast;\n+        let visibility = match parent {\n+            VariantDef::Struct(s) => s.source(db).ast.visibility(),\n+            VariantDef::EnumVariant(e) => e.source(db).ast.parent_enum().visibility(),\n+        };\n+        Declaration { item, container, visibility }\n+    }\n+\n+    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Declaration> {\n+        let src = hir::Source { file_id, ast: hir::FieldSource::Named(def) };\n+        let field = StructField::from_source(db, src)?;\n+        Some(field.declaration(db))\n+    }\n+\n+    fn from_ref(\n+        db: &RootDatabase,\n+        analyzer: &SourceAnalyzer,\n+        refer: Self::Ref,\n+    ) -> Option<Declaration> {\n+        let field = analyzer.resolve_field(&refer)?;\n+        Some(field.declaration(db))\n+    }\n+}\n+\n+impl HasDeclaration for AssocItem {\n+    type Def = ast::ImplItem;\n+    type Ref = ast::MethodCallExpr;\n+\n+    fn declaration(self, db: &RootDatabase) -> Declaration {\n+        let item = NameKind::AssocItem(self);\n+        let container = self.module(db).definition_source(db).ast;\n+        let visibility = match self {\n+            AssocItem::Function(f) => f.source(db).ast.visibility(),\n+            AssocItem::Const(c) => c.source(db).ast.visibility(),\n+            AssocItem::TypeAlias(a) => a.source(db).ast.visibility(),\n+        };\n+        Declaration { item, container, visibility }\n+    }\n+\n+    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Declaration> {\n+        let src = hir::Source { file_id, ast: def };\n+        let item = AssocItem::from_source(db, src)?;\n+        Some(item.declaration(db))\n+    }\n+\n+    fn from_ref(\n+        db: &RootDatabase,\n+        analyzer: &SourceAnalyzer,\n+        refer: Self::Ref,\n+    ) -> Option<Declaration> {\n+        let func: AssocItem = analyzer.resolve_method_call(&refer)?.into();\n+        Some(func.declaration(db))\n+    }\n }\n+\n+impl HasDeclaration for ModuleDef {\n+    type Def = ast::ModuleItem;\n+    type Ref = ast::Path;\n+\n+    fn declaration(self, db: &RootDatabase) -> Declaration {\n+        // FIXME: use macro\n+        let (container, visibility) = match self {\n+            ModuleDef::Module(it) => {\n+                let container =\n+                    it.parent(db).or_else(|| Some(it)).unwrap().definition_source(db).ast;\n+                let visibility = it.declaration_source(db).and_then(|s| s.ast.visibility());\n+                (container, visibility)\n+            }\n+            ModuleDef::EnumVariant(it) => {\n+                let container = it.module(db).definition_source(db).ast;\n+                let visibility = it.source(db).ast.parent_enum().visibility();\n+                (container, visibility)\n+            }\n+            ModuleDef::Function(it) => {\n+                (it.module(db).definition_source(db).ast, it.source(db).ast.visibility())\n+            }\n+            ModuleDef::Const(it) => {\n+                (it.module(db).definition_source(db).ast, it.source(db).ast.visibility())\n+            }\n+            ModuleDef::Static(it) => {\n+                (it.module(db).definition_source(db).ast, it.source(db).ast.visibility())\n+            }\n+            ModuleDef::Trait(it) => {\n+                (it.module(db).definition_source(db).ast, it.source(db).ast.visibility())\n+            }\n+            ModuleDef::TypeAlias(it) => {\n+                (it.module(db).definition_source(db).ast, it.source(db).ast.visibility())\n+            }\n+            ModuleDef::Adt(Adt::Struct(it)) => {\n+                (it.module(db).definition_source(db).ast, it.source(db).ast.visibility())\n+            }\n+            ModuleDef::Adt(Adt::Union(it)) => {\n+                (it.module(db).definition_source(db).ast, it.source(db).ast.visibility())\n+            }\n+            ModuleDef::Adt(Adt::Enum(it)) => {\n+                (it.module(db).definition_source(db).ast, it.source(db).ast.visibility())\n+            }\n+            ModuleDef::BuiltinType(..) => unreachable!(),\n+        };\n+        let item = NameKind::Def(self);\n+        Declaration { item, container, visibility }\n+    }\n+\n+    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Declaration> {\n+        let src = hir::Source { file_id, ast: def };\n+        let def = ModuleDef::from_source(db, src)?;\n+        Some(def.declaration(db))\n+    }\n+\n+    fn from_ref(\n+        db: &RootDatabase,\n+        analyzer: &SourceAnalyzer,\n+        refer: Self::Ref,\n+    ) -> Option<Declaration> {\n+        None\n+    }\n+}\n+\n+// FIXME: impl HasDeclaration for hir::MacroDef"}, {"sha": "24453452bf631b644278197ce235c8bfd2c3e152", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/121aa35f12d282066651d906ea9a8b2da8209605/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/121aa35f12d282066651d906ea9a8b2da8209605/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=121aa35f12d282066651d906ea9a8b2da8209605", "patch": "@@ -69,13 +69,13 @@ pub(crate) fn find_all_refs(\n             Some((def_id, _)) => NavigationTarget::from_adt_def(db, def_id),\n             None => return None,\n         },\n-        Pat(pat) => NavigationTarget::from_pat(db, position.file_id, pat),\n+        Pat((_, pat)) => NavigationTarget::from_pat(db, position.file_id, pat),\n         SelfParam(par) => NavigationTarget::from_self_param(position.file_id, par),\n         GenericParam(_) => return None,\n     };\n \n     let references = match name_kind {\n-        Pat(pat) => analyzer\n+        Pat((_, pat)) => analyzer\n             .find_all_refs(&pat.to_node(&syntax))\n             .into_iter()\n             .map(move |ref_desc| FileRange { file_id: position.file_id, range: ref_desc.range })\n@@ -99,7 +99,7 @@ pub(crate) fn find_all_refs(\n         let name_ref = find_node_at_offset::<ast::NameRef>(&syntax, position.offset)?;\n         let range = name_ref.syntax().text_range();\n         let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n-        let name_kind = classify_name_ref(db, &analyzer, &name_ref)?;\n+        let name_kind = classify_name_ref(db, position.file_id, &analyzer, &name_ref)?.item;\n         Some(RangeInfo::new(range, (analyzer, name_kind)))\n     }\n }"}, {"sha": "8be93e27ea221d62f54943e0ed94bbcb72d8c73c", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/121aa35f12d282066651d906ea9a8b2da8209605/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/121aa35f12d282066651d906ea9a8b2da8209605/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=121aa35f12d282066651d906ea9a8b2da8209605", "patch": "@@ -103,7 +103,9 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                 if let Some(name_ref) = node.as_node().cloned().and_then(ast::NameRef::cast) {\n                     // FIXME: try to reuse the SourceAnalyzers\n                     let analyzer = hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n-                    match classify_name_ref(db, &analyzer, &name_ref) {\n+                    let name_kind = classify_name_ref(db, file_id, &analyzer, &name_ref)\n+                        .and_then(|d| Some(d.item));\n+                    match name_kind {\n                         Some(Macro(_)) => \"macro\",\n                         Some(FieldAccess(_)) => \"field\",\n                         Some(AssocItem(hir::AssocItem::Function(_))) => \"function\",\n@@ -119,7 +121,7 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                         Some(Def(hir::ModuleDef::TypeAlias(_))) => \"type\",\n                         Some(Def(hir::ModuleDef::BuiltinType(_))) => \"type\",\n                         Some(SelfType(_)) => \"type\",\n-                        Some(Pat(ptr)) => {\n+                        Some(Pat((_, ptr))) => {\n                             let pat = ptr.to_node(&root);\n                             if let Some(name) = pat.name() {\n                                 let text = name.text();"}]}