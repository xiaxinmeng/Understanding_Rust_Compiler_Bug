{"sha": "f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwY2MzYTkzNjUxZDIzN2E4YzVkZGExNTcxZTgyM2EzY2JhN2NlNjA=", "commit": {"author": {"name": "Brian Koropoff", "email": "bkoropoff@gmail.com", "date": "2014-10-18T17:46:57Z"}, "committer": {"name": "Brian Koropoff", "email": "bkoropoff@gmail.com", "date": "2014-10-28T01:51:27Z"}, "message": "Fix monomorphization of unboxed closures\n\nThis adds a `Substs` field to `ty_unboxed_closure` and plumbs basic\nhandling of it throughout the compiler. trans now correctly\nmonomorphizes captured free variables and llvm function defs.  This\nfixes uses of unboxed closures which reference a free type or region\nparameter from their environment in either their signature or free\nvariables.  Closes #16791", "tree": {"sha": "5df482458ebd1db8905bdbb1aa1cda0fafd68d7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5df482458ebd1db8905bdbb1aa1cda0fafd68d7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "html_url": "https://github.com/rust-lang/rust/commit/f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/comments", "author": {"login": "bkoropoff", "id": 2101303, "node_id": "MDQ6VXNlcjIxMDEzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2101303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkoropoff", "html_url": "https://github.com/bkoropoff", "followers_url": "https://api.github.com/users/bkoropoff/followers", "following_url": "https://api.github.com/users/bkoropoff/following{/other_user}", "gists_url": "https://api.github.com/users/bkoropoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkoropoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkoropoff/subscriptions", "organizations_url": "https://api.github.com/users/bkoropoff/orgs", "repos_url": "https://api.github.com/users/bkoropoff/repos", "events_url": "https://api.github.com/users/bkoropoff/events{/privacy}", "received_events_url": "https://api.github.com/users/bkoropoff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bkoropoff", "id": 2101303, "node_id": "MDQ6VXNlcjIxMDEzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2101303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkoropoff", "html_url": "https://github.com/bkoropoff", "followers_url": "https://api.github.com/users/bkoropoff/followers", "following_url": "https://api.github.com/users/bkoropoff/following{/other_user}", "gists_url": "https://api.github.com/users/bkoropoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkoropoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkoropoff/subscriptions", "organizations_url": "https://api.github.com/users/bkoropoff/orgs", "repos_url": "https://api.github.com/users/bkoropoff/repos", "events_url": "https://api.github.com/users/bkoropoff/events{/privacy}", "received_events_url": "https://api.github.com/users/bkoropoff/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd7138dd698dde29fb4d7fd34529a863b85d947e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd7138dd698dde29fb4d7fd34529a863b85d947e", "html_url": "https://github.com/rust-lang/rust/commit/bd7138dd698dde29fb4d7fd34529a863b85d947e"}], "stats": {"total": 347, "additions": 202, "deletions": 145}, "files": [{"sha": "b5456e724d28b65660ab81e6b4eb882c0ccda160", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -465,9 +465,12 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n           return ty::mk_struct(st.tcx, did, substs);\n       }\n       'k' => {\n+          assert_eq!(next(st), '[');\n           let did = parse_def(st, NominalType, |x,y| conv(x,y));\n-          let region = parse_region(st, conv);\n-          return ty::mk_unboxed_closure(st.tcx, did, region);\n+          let region = parse_region(st, |x,y| conv(x,y));\n+          let substs = parse_substs(st, |x,y| conv(x,y));\n+          assert_eq!(next(st), ']');\n+          return ty::mk_unboxed_closure(st.tcx, did, region, substs);\n       }\n       'e' => {\n           return ty::mk_err();"}, {"sha": "6c59537b377723c8b33bb3df5bdff53c5448880d", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -285,9 +285,11 @@ fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_unboxed_closure(def, region) => {\n-            mywrite!(w, \"k{}\", (cx.ds)(def));\n+        ty::ty_unboxed_closure(def, region, ref substs) => {\n+            mywrite!(w, \"k[{}|\", (cx.ds)(def));\n             enc_region(w, cx, region);\n+            enc_substs(w, cx, substs);\n+            mywrite!(w, \"]\");\n         }\n         ty::ty_err => {\n             mywrite!(w, \"e\");"}, {"sha": "abdbd80ebf2e35e5240c057d95d4cc3206e64b39", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -594,7 +594,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                       };\n                       self.cat_upvar(id, span, var_id, fn_node_id, kind, mode, false)\n                   }\n-                  ty::ty_unboxed_closure(closure_id, _) => {\n+                  ty::ty_unboxed_closure(closure_id, _, _) => {\n                       let unboxed_closures = self.typer.unboxed_closures().borrow();\n                       let kind = (*unboxed_closures)[closure_id].kind;\n                       let mode = self.typer.capture_mode(fn_node_id);"}, {"sha": "2f345e2e6196c8370b07540fe002e3243be0e18a", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -110,7 +110,7 @@ enum Candidate {\n     BuiltinCandidate(ty::BuiltinBound),\n     ParamCandidate(VtableParamData),\n     ImplCandidate(ast::DefId),\n-    UnboxedClosureCandidate(/* closure */ ast::DefId),\n+    UnboxedClosureCandidate(/* closure */ ast::DefId, Substs),\n     ErrorCandidate,\n }\n \n@@ -995,8 +995,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n-        let closure_def_id = match ty::get(self_ty).sty {\n-            ty::ty_unboxed_closure(id, _) => id,\n+        let (closure_def_id, substs) = match ty::get(self_ty).sty {\n+            ty::ty_unboxed_closure(id, _, ref substs) => (id, substs.clone()),\n             ty::ty_infer(ty::TyVar(_)) => {\n                 candidates.ambiguous = true;\n                 return Ok(());\n@@ -1019,7 +1019,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         if closure_kind == kind {\n-            candidates.vec.push(UnboxedClosureCandidate(closure_def_id));\n+            candidates.vec.push(UnboxedClosureCandidate(closure_def_id, substs.clone()));\n         }\n \n         Ok(())\n@@ -1383,7 +1383,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(If(tys.clone()))\n             }\n \n-            ty::ty_unboxed_closure(def_id, _) => {\n+            ty::ty_unboxed_closure(def_id, _, ref substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n                 // closures particularly, we need the results of\n                 // inference to decide how to reflect the type of each\n@@ -1407,7 +1407,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             .map(|freevar| {\n                                 let freevar_def_id = freevar.def.def_id();\n                                 self.typer.node_ty(freevar_def_id.node)\n-                                    .unwrap_or(ty::mk_err())\n+                                    .unwrap_or(ty::mk_err()).subst(self.tcx(), substs)\n                             })\n                             .collect();\n                         Ok(If(tys))\n@@ -1548,8 +1548,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(VtableImpl(vtable_impl))\n             }\n \n-            UnboxedClosureCandidate(closure_def_id) => {\n-                try!(self.confirm_unboxed_closure_candidate(obligation, closure_def_id));\n+            UnboxedClosureCandidate(closure_def_id, ref substs) => {\n+                try!(self.confirm_unboxed_closure_candidate(obligation, closure_def_id, substs));\n                 Ok(VtableUnboxedClosure(closure_def_id))\n             }\n         }\n@@ -1646,12 +1646,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn confirm_unboxed_closure_candidate(&mut self,\n                                          obligation: &Obligation,\n-                                         closure_def_id: ast::DefId)\n+                                         closure_def_id: ast::DefId,\n+                                         substs: &Substs)\n                                          -> Result<(),SelectionError>\n     {\n-        debug!(\"confirm_unboxed_closure_candidate({},{})\",\n+        debug!(\"confirm_unboxed_closure_candidate({},{},{})\",\n                obligation.repr(self.tcx()),\n-               closure_def_id.repr(self.tcx()));\n+               closure_def_id.repr(self.tcx()),\n+               substs.repr(self.tcx()));\n \n         let closure_type = match self.typer.unboxed_closures().borrow().find(&closure_def_id) {\n             Some(closure) => closure.closure_type.clone(),\n@@ -1678,7 +1680,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let trait_ref = Rc::new(ty::TraitRef {\n             def_id: obligation.trait_ref.def_id,\n             substs: Substs::new_trait(\n-                vec![arguments_tuple, new_signature.output],\n+                vec![arguments_tuple.subst(self.tcx(), substs),\n+                     new_signature.output.subst(self.tcx(), substs)],\n                 vec![],\n                 obligation.self_ty())\n         });\n@@ -1959,7 +1962,9 @@ impl Repr for Candidate {\n         match *self {\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n             BuiltinCandidate(b) => format!(\"BuiltinCandidate({})\", b),\n-            UnboxedClosureCandidate(c) => format!(\"MatchedUnboxedClosureCandidate({})\", c),\n+            UnboxedClosureCandidate(c, ref s) => {\n+                format!(\"MatchedUnboxedClosureCandidate({},{})\", c, s.repr(tcx))\n+            }\n             ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n             ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n         }"}, {"sha": "2525da8863f557924c30a16e769e347950a03a38", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -176,8 +176,8 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n \n             return Univariant(mk_struct(cx, ftys.as_slice(), packed, t), dtor)\n         }\n-        ty::ty_unboxed_closure(def_id, _) => {\n-            let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id);\n+        ty::ty_unboxed_closure(def_id, _, ref substs) => {\n+            let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs);\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n             return Univariant(mk_struct(cx, upvar_types.as_slice(), false, t),\n                               false)"}, {"sha": "a739f6e3db279f066f0573a01df0193b469b219f", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -253,21 +253,19 @@ fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::De\n }\n \n pub fn self_type_for_unboxed_closure(ccx: &CrateContext,\n-                                     closure_id: ast::DefId)\n+                                     closure_id: ast::DefId,\n+                                     fn_ty: ty::t)\n                                      -> ty::t {\n-    let unboxed_closure_type = ty::mk_unboxed_closure(ccx.tcx(),\n-                                                      closure_id,\n-                                                      ty::ReStatic);\n     let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n     let unboxed_closure = &(*unboxed_closures)[closure_id];\n     match unboxed_closure.kind {\n         ty::FnUnboxedClosureKind => {\n-            ty::mk_imm_rptr(ccx.tcx(), ty::ReStatic, unboxed_closure_type)\n+            ty::mk_imm_rptr(ccx.tcx(), ty::ReStatic, fn_ty)\n         }\n         ty::FnMutUnboxedClosureKind => {\n-            ty::mk_mut_rptr(ccx.tcx(), ty::ReStatic, unboxed_closure_type)\n+            ty::mk_mut_rptr(ccx.tcx(), ty::ReStatic, fn_ty)\n         }\n-        ty::FnOnceUnboxedClosureKind => unboxed_closure_type,\n+        ty::FnOnceUnboxedClosureKind => fn_ty\n     }\n }\n \n@@ -285,14 +283,14 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n         ty::ty_closure(ref f) => {\n             (f.sig.inputs.clone(), f.sig.output, f.abi, Some(Type::i8p(ccx)))\n         }\n-        ty::ty_unboxed_closure(closure_did, _) => {\n+        ty::ty_unboxed_closure(closure_did, _, ref substs) => {\n             let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n             let unboxed_closure = &(*unboxed_closures)[closure_did];\n             let function_type = unboxed_closure.closure_type.clone();\n-            let self_type = self_type_for_unboxed_closure(ccx, closure_did);\n+            let self_type = self_type_for_unboxed_closure(ccx, closure_did, fn_ty);\n             let llenvironment_type = type_of_explicit_arg(ccx, self_type);\n-            (function_type.sig.inputs.clone(),\n-             function_type.sig.output,\n+            (function_type.sig.inputs.iter().map(|t| t.subst(ccx.tcx(), substs)).collect(),\n+             function_type.sig.output.subst(ccx.tcx(), substs),\n              RustCall,\n              Some(llenvironment_type))\n         }\n@@ -738,9 +736,9 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n               }\n           })\n       }\n-      ty::ty_unboxed_closure(def_id, _) => {\n+      ty::ty_unboxed_closure(def_id, _, ref substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id);\n+          let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs);\n           for (i, upvar) in upvars.iter().enumerate() {\n               let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n               cx = f(cx, llupvar, upvar.ty);\n@@ -2351,12 +2349,12 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n     let (fn_sig, abi, has_env) = match ty::get(fn_ty).sty {\n         ty::ty_closure(ref f) => (f.sig.clone(), f.abi, true),\n         ty::ty_bare_fn(ref f) => (f.sig.clone(), f.abi, false),\n-        ty::ty_unboxed_closure(closure_did, _) => {\n+        ty::ty_unboxed_closure(closure_did, _, ref substs) => {\n             let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n             let ref function_type = (*unboxed_closures)[closure_did]\n                                                     .closure_type;\n \n-            (function_type.sig.clone(), RustCall, true)\n+            (function_type.sig.subst(ccx.tcx(), substs), RustCall, true)\n         }\n         _ => ccx.sess().bug(\"expected closure or function.\")\n     };\n@@ -2371,7 +2369,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n     // These have an odd calling convention, so we need to manually\n     // unpack the input ty's\n     let input_tys = match ty::get(fn_ty).sty {\n-        ty::ty_unboxed_closure(_, _) => {\n+        ty::ty_unboxed_closure(_, _, _) => {\n             assert!(abi == RustCall);\n \n             match ty::get(fn_sig.inputs[0]).sty {"}, {"sha": "b8895e9486a05623b07c561cabf9e5620fd85541", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -491,7 +491,7 @@ pub fn trans_fn_ref_with_substs(\n     };\n \n     // If this is an unboxed closure, redirect to it.\n-    match closure::get_or_create_declaration_if_unboxed_closure(ccx, def_id) {\n+    match closure::get_or_create_declaration_if_unboxed_closure(bcx, def_id) {\n         None => {}\n         Some(llfn) => return llfn,\n     }"}, {"sha": "d4e1473f0e5c21036087e88a55816b0cd7496210", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -23,6 +23,7 @@ use middle::trans::common::*;\n use middle::trans::datum::{Datum, DatumBlock, Expr, Lvalue, rvalue_scratch_datum};\n use middle::trans::debuginfo;\n use middle::trans::expr;\n+use middle::trans::monomorphize::MonoId;\n use middle::trans::type_of::*;\n use middle::trans::type_::Type;\n use middle::ty;\n@@ -312,7 +313,8 @@ fn load_unboxed_closure_environment<'blk, 'tcx>(\n     }\n \n     // Special case for small by-value selfs.\n-    let self_type = self_type_for_unboxed_closure(bcx.ccx(), closure_id);\n+    let self_type = self_type_for_unboxed_closure(bcx.ccx(), closure_id,\n+                                                  node_id_type(bcx, closure_id.node));\n     let kind = kind_for_unboxed_closure(bcx.ccx(), closure_id);\n     let llenv = if kind == ty::FnOnceUnboxedClosureKind &&\n             !arg_is_indirect(bcx.ccx(), self_type) {\n@@ -418,15 +420,26 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n /// Returns the LLVM function declaration for an unboxed closure, creating it\n /// if necessary. If the ID does not correspond to a closure ID, returns None.\n-pub fn get_or_create_declaration_if_unboxed_closure(ccx: &CrateContext,\n-                                                    closure_id: ast::DefId)\n-                                                    -> Option<ValueRef> {\n+pub fn get_or_create_declaration_if_unboxed_closure<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                                                closure_id: ast::DefId)\n+                                                                -> Option<ValueRef> {\n+    let ccx = bcx.ccx();\n     if !ccx.tcx().unboxed_closures.borrow().contains_key(&closure_id) {\n         // Not an unboxed closure.\n         return None\n     }\n \n-    match ccx.unboxed_closure_vals().borrow().find(&closure_id) {\n+    let function_type = node_id_type(bcx, closure_id.node);\n+    let params = match ty::get(function_type).sty {\n+        ty::ty_unboxed_closure(_, _, ref substs) => substs.types.clone(),\n+        _ => unreachable!()\n+    };\n+    let mono_id = MonoId {\n+        def: closure_id,\n+        params: params\n+    };\n+\n+    match ccx.unboxed_closure_vals().borrow().find(&mono_id) {\n         Some(llfn) => {\n             debug!(\"get_or_create_declaration_if_unboxed_closure(): found \\\n                     closure\");\n@@ -435,9 +448,7 @@ pub fn get_or_create_declaration_if_unboxed_closure(ccx: &CrateContext,\n         None => {}\n     }\n \n-    let function_type = ty::mk_unboxed_closure(ccx.tcx(),\n-                                               closure_id,\n-                                               ty::ReStatic);\n+    let function_type = node_id_type(bcx, closure_id.node);\n     let symbol = ccx.tcx().map.with_path(closure_id.node, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"unboxed_closure\")\n     });\n@@ -449,9 +460,9 @@ pub fn get_or_create_declaration_if_unboxed_closure(ccx: &CrateContext,\n \n     debug!(\"get_or_create_declaration_if_unboxed_closure(): inserting new \\\n             closure {} (type {})\",\n-           closure_id,\n+           mono_id,\n            ccx.tn().type_to_string(val_ty(llfn)));\n-    ccx.unboxed_closure_vals().borrow_mut().insert(closure_id, llfn);\n+    ccx.unboxed_closure_vals().borrow_mut().insert(mono_id, llfn);\n \n     Some(llfn)\n }\n@@ -469,7 +480,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n \n     let closure_id = ast_util::local_def(id);\n     let llfn = get_or_create_declaration_if_unboxed_closure(\n-        bcx.ccx(),\n+        bcx,\n         closure_id).unwrap();\n \n     let unboxed_closures = bcx.tcx().unboxed_closures.borrow();"}, {"sha": "64ad88630f4604ce6613912e63034d4e6023ffa0", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -138,7 +138,7 @@ pub struct LocalCrateContext {\n     builder: BuilderRef_res,\n \n     /// Holds the LLVM values for closure IDs.\n-    unboxed_closure_vals: RefCell<DefIdMap<ValueRef>>,\n+    unboxed_closure_vals: RefCell<HashMap<MonoId, ValueRef>>,\n \n     dbg_cx: Option<debuginfo::CrateDebugContext>,\n \n@@ -419,7 +419,7 @@ impl LocalCrateContext {\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n-                unboxed_closure_vals: RefCell::new(DefIdMap::new()),\n+                unboxed_closure_vals: RefCell::new(HashMap::new()),\n                 dbg_cx: dbg_cx,\n                 eh_personality: RefCell::new(None),\n                 intrinsics: RefCell::new(HashMap::new()),\n@@ -689,7 +689,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.opaque_vec_type\n     }\n \n-    pub fn unboxed_closure_vals<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n+    pub fn unboxed_closure_vals<'a>(&'a self) -> &'a RefCell<HashMap<MonoId,ValueRef>> {\n         &self.local.unboxed_closure_vals\n     }\n "}, {"sha": "3368b2b7765b88f336d059c167708701bd15344c", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -190,7 +190,7 @@ use llvm;\n use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::*;\n use metadata::csearch;\n-use middle::subst;\n+use middle::subst::{mod, Subst};\n use middle::trans::adt;\n use middle::trans::common::*;\n use middle::trans::machine;\n@@ -460,9 +460,9 @@ impl TypeMap {\n                                                         closure_ty.clone(),\n                                                         &mut unique_type_id);\n             },\n-            ty::ty_unboxed_closure(ref def_id, _) => {\n+            ty::ty_unboxed_closure(ref def_id, _, ref substs) => {\n                 let closure_ty = cx.tcx().unboxed_closures.borrow()\n-                                   .find(def_id).unwrap().closure_type.clone();\n+                                   .find(def_id).unwrap().closure_type.subst(cx.tcx(), substs);\n                 self.get_unique_type_id_of_closure_type(cx,\n                                                         closure_ty,\n                                                         &mut unique_type_id);\n@@ -2911,9 +2911,9 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_closure(ref closurety) => {\n             subroutine_type_metadata(cx, unique_type_id, &closurety.sig, usage_site_span)\n         }\n-        ty::ty_unboxed_closure(ref def_id, _) => {\n+        ty::ty_unboxed_closure(ref def_id, _, ref substs) => {\n             let sig = cx.tcx().unboxed_closures.borrow()\n-                        .find(def_id).unwrap().closure_type.sig.clone();\n+                        .find(def_id).unwrap().closure_type.sig.subst(cx.tcx(), substs);\n             subroutine_type_metadata(cx, unique_type_id, &sig, usage_site_span)\n         }\n         ty::ty_struct(def_id, ref substs) => {"}, {"sha": "bab11c30204cc77dca17e2752c8f944fddb72335", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -344,13 +344,10 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n         traits::VtableUnboxedClosure(closure_def_id) => {\n-          // The static region and type parameters are lies, but we're in\n-          // trans so it doesn't matter.\n-          //\n-          // FIXME(pcwalton): Is this true in the case of type parameters?\n-          let callee_substs = get_callee_substitutions_for_unboxed_closure(\n+            let self_ty = node_id_type(bcx, closure_def_id.node);\n+            let callee_substs = get_callee_substitutions_for_unboxed_closure(\n                 bcx,\n-                closure_def_id);\n+                self_ty);\n \n             let llfn = trans_fn_ref_with_substs(bcx,\n                                                 closure_def_id,\n@@ -504,24 +501,22 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n }\n \n-/// Creates the self type and (fake) callee substitutions for an unboxed\n-/// closure with the given def ID. The static region and type parameters are\n-/// lies, but we're in trans so it doesn't matter.\n+/// Looks up the substitutions for an unboxed closure and adds the\n+/// self type\n fn get_callee_substitutions_for_unboxed_closure(bcx: Block,\n-                                                def_id: ast::DefId)\n+                                                self_ty: ty::t)\n                                                 -> subst::Substs {\n-    let self_ty = ty::mk_unboxed_closure(bcx.tcx(), def_id, ty::ReStatic);\n-    subst::Substs::erased(\n-        VecPerParamSpace::new(Vec::new(),\n-                              vec![\n-                                  ty::mk_rptr(bcx.tcx(),\n-                                              ty::ReStatic,\n-                                              ty::mt {\n+    match ty::get(self_ty).sty {\n+        ty::ty_unboxed_closure(_, _, ref substs) => {\n+            substs.with_self_ty(ty::mk_rptr(bcx.tcx(),\n+                                            ty::ReStatic,\n+                                            ty::mt {\n                                                 ty: self_ty,\n                                                 mutbl: ast::MutMutable,\n-                                              })\n-                              ],\n-                              Vec::new()))\n+                                            }))\n+        },\n+        _ => unreachable!()\n+    }\n }\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n@@ -569,10 +564,12 @@ pub fn get_vtable(bcx: Block,\n                 emit_vtable_methods(bcx, id, substs).into_iter()\n             }\n             traits::VtableUnboxedClosure(closure_def_id) => {\n+                let self_ty = node_id_type(bcx, closure_def_id.node);\n+\n                 let callee_substs =\n                     get_callee_substitutions_for_unboxed_closure(\n                         bcx,\n-                        closure_def_id);\n+                        self_ty.clone());\n \n                 let mut llfn = trans_fn_ref_with_substs(\n                     bcx,\n@@ -590,25 +587,28 @@ pub fn get_vtable(bcx: Block,\n                                                  unboxed closure\");\n                     if closure_info.kind == ty::FnOnceUnboxedClosureKind {\n                         // Untuple the arguments and create an unboxing shim.\n-                        let mut new_inputs = vec![\n-                            ty::mk_unboxed_closure(bcx.tcx(),\n-                                                   closure_def_id,\n-                                                   ty::ReStatic)\n-                        ];\n-                        match ty::get(closure_info.closure_type\n-                                                  .sig\n-                                                  .inputs[0]).sty {\n-                            ty::ty_tup(ref elements) => {\n-                                for element in elements.iter() {\n-                                    new_inputs.push(*element)\n+                        let (new_inputs, new_output) = match ty::get(self_ty).sty {\n+                            ty::ty_unboxed_closure(_, _, ref substs) => {\n+                                let mut new_inputs = vec![self_ty.clone()];\n+                                match ty::get(closure_info.closure_type\n+                                              .sig\n+                                              .inputs[0]).sty {\n+                                    ty::ty_tup(ref elements) => {\n+                                        for element in elements.iter() {\n+                                            new_inputs.push(element.subst(bcx.tcx(), substs));\n+                                        }\n+                                    }\n+                                    ty::ty_nil => {}\n+                                    _ => {\n+                                        bcx.tcx().sess.bug(\"get_vtable(): closure \\\n+                                                            type wasn't a tuple\")\n+                                    }\n                                 }\n-                            }\n-                            ty::ty_nil => {}\n-                            _ => {\n-                                bcx.tcx().sess.bug(\"get_vtable(): closure \\\n-                                                    type wasn't a tuple\")\n-                            }\n-                        }\n+                                (new_inputs,\n+                                 closure_info.closure_type.sig.output.subst(bcx.tcx(), substs))\n+                            },\n+                            _ => bcx.tcx().sess.bug(\"get_vtable(): def wasn't an unboxed closure\")\n+                        };\n \n                         let closure_type = ty::BareFnTy {\n                             fn_style: closure_info.closure_type.fn_style,\n@@ -618,7 +618,7 @@ pub fn get_vtable(bcx: Block,\n                                                        .sig\n                                                        .binder_id,\n                                 inputs: new_inputs,\n-                                output: closure_info.closure_type.sig.output,\n+                                output: new_output,\n                                 variadic: false,\n                             },\n                         };"}, {"sha": "6d7985767ab869fe3592b94e68728cfacb4b0d4f", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -309,11 +309,15 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           let name = llvm_type_name(cx, an_enum, did, tps);\n           adt::incomplete_type_of(cx, &*repr, name.as_slice())\n       }\n-      ty::ty_unboxed_closure(did, _) => {\n+      ty::ty_unboxed_closure(did, _, ref substs) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache.\n           let repr = adt::represent_type(cx, t);\n-          let name = llvm_type_name(cx, an_unboxed_closure, did, []);\n+          // Unboxed closures can have substitutions in all spaces\n+          // inherited from their environment, so we use entire\n+          // contents of the VecPerParamSpace to to construct the llvm\n+          // name\n+          let name = llvm_type_name(cx, an_unboxed_closure, did, substs.types.as_slice());\n           adt::incomplete_type_of(cx, &*repr, name.as_slice())\n       }\n "}, {"sha": "7fedea67f79af3facbf9d1aea6312b4a87e04c7e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -962,7 +962,7 @@ pub enum sty {\n     ty_closure(Box<ClosureTy>),\n     ty_trait(Box<TyTrait>),\n     ty_struct(DefId, Substs),\n-    ty_unboxed_closure(DefId, Region),\n+    ty_unboxed_closure(DefId, Region, Substs),\n     ty_tup(Vec<t>),\n \n     ty_param(ParamTy), // type parameter\n@@ -1636,7 +1636,10 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n               flags = flags | HAS_PARAMS;\n           }\n       }\n-      &ty_unboxed_closure(_, ref region) => flags = flags | rflags(*region),\n+      &ty_unboxed_closure(_, ref region, ref substs) => {\n+          flags = flags | rflags(*region);\n+          flags = flags | sflags(substs);\n+      }\n       &ty_infer(_) => flags = flags | HAS_TY_INFER,\n       &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n           flags = flags | sflags(substs);\n@@ -1885,9 +1888,9 @@ pub fn mk_struct(cx: &ctxt, struct_id: ast::DefId, substs: Substs) -> t {\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n \n-pub fn mk_unboxed_closure(cx: &ctxt, closure_id: ast::DefId, region: Region)\n+pub fn mk_unboxed_closure(cx: &ctxt, closure_id: ast::DefId, region: Region, substs: Substs)\n                           -> t {\n-    mk_t(cx, ty_unboxed_closure(closure_id, region))\n+    mk_t(cx, ty_unboxed_closure(closure_id, region, substs))\n }\n \n pub fn mk_var(cx: &ctxt, v: TyVid) -> t { mk_infer(cx, TyVar(v)) }\n@@ -1922,12 +1925,12 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n     }\n     match get(ty).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-        ty_str | ty_infer(_) | ty_param(_) | ty_unboxed_closure(_, _) | ty_err => {}\n+        ty_str | ty_infer(_) | ty_param(_) | ty_err => {}\n         ty_uniq(ty) | ty_vec(ty, _) | ty_open(ty) => maybe_walk_ty(ty, f),\n         ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n             maybe_walk_ty(tm.ty, f);\n         }\n-        ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n+        ty_enum(_, ref substs) | ty_struct(_, ref substs) | ty_unboxed_closure(_, _, ref substs) |\n         ty_trait(box TyTrait { ref substs, .. }) => {\n             for subty in (*substs).types.iter() {\n                 maybe_walk_ty(*subty, |x| f(x));\n@@ -2484,10 +2487,10 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 apply_lang_items(cx, did, res)\n             }\n \n-            ty_unboxed_closure(did, r) => {\n+            ty_unboxed_closure(did, r, ref substs) => {\n                 // FIXME(#14449): `borrowed_contents` below assumes `&mut`\n                 // unboxed closure.\n-                let upvars = unboxed_closure_upvars(cx, did);\n+                let upvars = unboxed_closure_upvars(cx, did, substs);\n                 TypeContents::union(upvars.as_slice(),\n                                     |f| tc_ty(cx, f.ty, cache)) |\n                     borrowed_contents(r, MutMutable)\n@@ -2781,8 +2784,8 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n                 r\n             }\n \n-            ty_unboxed_closure(did, _) => {\n-                let upvars = unboxed_closure_upvars(cx, did);\n+            ty_unboxed_closure(did, _, ref substs) => {\n+                let upvars = unboxed_closure_upvars(cx, did, substs);\n                 upvars.iter().any(|f| type_requires(cx, seen, r_ty, f.ty))\n             }\n \n@@ -2869,8 +2872,8 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n \n                 find_nonrepresentable(cx, sp, seen, iter)\n             }\n-            ty_unboxed_closure(did, _) => {\n-                let upvars = unboxed_closure_upvars(cx, did);\n+            ty_unboxed_closure(did, _, ref substs) => {\n+                let upvars = unboxed_closure_upvars(cx, did, substs);\n                 find_nonrepresentable(cx, sp, seen, upvars.iter().map(|f| f.ty))\n             }\n             _ => Representable,\n@@ -4225,7 +4228,7 @@ pub fn ty_to_def_id(ty: t) -> Option<ast::DefId> {\n         ty_trait(box TyTrait { def_id: id, .. }) |\n         ty_struct(id, _) |\n         ty_enum(id, _) |\n-        ty_unboxed_closure(id, _) => Some(id),\n+        ty_unboxed_closure(id, _, _) => Some(id),\n         _ => None\n     }\n }\n@@ -4623,7 +4626,7 @@ pub struct UnboxedClosureUpvar {\n }\n \n // Returns a list of `UnboxedClosureUpvar`s for each upvar.\n-pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId)\n+pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId, substs: &Substs)\n                               -> Vec<UnboxedClosureUpvar> {\n     if closure_id.krate == ast::LOCAL_CRATE {\n         let capture_mode = tcx.capture_modes.borrow().get_copy(&closure_id.node);\n@@ -4632,7 +4635,8 @@ pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId)\n             Some(ref freevars) => {\n                 freevars.iter().map(|freevar| {\n                     let freevar_def_id = freevar.def.def_id();\n-                    let mut freevar_ty = node_id_to_type(tcx, freevar_def_id.node);\n+                    let freevar_ty = node_id_to_type(tcx, freevar_def_id.node);\n+                    let mut freevar_ty = freevar_ty.subst(tcx, substs);\n                     if capture_mode == ast::CaptureByRef {\n                         let borrow = tcx.upvar_borrow_map.borrow().get_copy(&ty::UpvarId {\n                             var_id: freevar_def_id.node,\n@@ -5226,7 +5230,7 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n             ty_open(_) => byte!(22),\n             ty_infer(_) => unreachable!(),\n             ty_err => byte!(23),\n-            ty_unboxed_closure(d, r) => {\n+            ty_unboxed_closure(d, r, _) => {\n                 byte!(24);\n                 did(&mut state, d);\n                 region(&mut state, r);\n@@ -5503,22 +5507,18 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n                 ..\n             }) |\n             ty_struct(_, ref substs) => {\n-                match substs.regions {\n-                    subst::ErasedRegions => {}\n-                    subst::NonerasedRegions(ref regions) => {\n-                        for region in regions.iter() {\n-                            accumulator.push(*region)\n-                        }\n-                    }\n-                }\n+                accum_substs(accumulator, substs);\n             }\n             ty_closure(ref closure_ty) => {\n                 match closure_ty.store {\n                     RegionTraitStore(region, _) => accumulator.push(region),\n                     UniqTraitStore => {}\n                 }\n             }\n-            ty_unboxed_closure(_, ref region) => accumulator.push(*region),\n+            ty_unboxed_closure(_, ref region, ref substs) => {\n+                accumulator.push(*region);\n+                accum_substs(accumulator, substs);\n+            }\n             ty_nil |\n             ty_bot |\n             ty_bool |\n@@ -5537,7 +5537,18 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_open(_) |\n             ty_err => {}\n         }\n-    })\n+    });\n+\n+    fn accum_substs(accumulator: &mut Vec<Region>, substs: &Substs) {\n+        match substs.regions {\n+            subst::ErasedRegions => {}\n+            subst::NonerasedRegions(ref regions) => {\n+                for region in regions.iter() {\n+                    accumulator.push(*region)\n+                }\n+            }\n+        }\n+    }\n }\n \n /// A free variable referred to in a function."}, {"sha": "c7fe8a19937c9f93ce4d3de5b7bdce6586326442", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -534,8 +534,8 @@ pub fn super_fold_sty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n         ty::ty_struct(did, ref substs) => {\n             ty::ty_struct(did, substs.fold_with(this))\n         }\n-        ty::ty_unboxed_closure(did, ref region) => {\n-            ty::ty_unboxed_closure(did, region.fold_with(this))\n+        ty::ty_unboxed_closure(did, ref region, ref substs) => {\n+            ty::ty_unboxed_closure(did, region.fold_with(this), substs.fold_with(this))\n         }\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_char | ty::ty_str |\n         ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |"}, {"sha": "f8604eeb5c69c8c48c8e81c172cd7283e953b60a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -505,7 +505,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 }\n                 ty_enum(did, _) |\n                 ty_struct(did, _) |\n-                ty_unboxed_closure(did, _) => {\n+                ty_unboxed_closure(did, _, _) => {\n                     if self.check_traits == CheckTraitsAndInherentMethods {\n                         self.push_inherent_impl_candidates_for_type(did);\n                     }"}, {"sha": "5f6795f24c1e9bf6617a76a8b2c82d9e4274ab31", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -3270,7 +3270,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         };\n         let closure_type = ty::mk_unboxed_closure(fcx.ccx.tcx,\n                                                   local_def(expr.id),\n-                                                  region);\n+                                                  region,\n+                                                  fcx.inh.param_env.free_substs.clone());\n         fcx.write_ty(expr.id, closure_type);\n \n         check_fn(fcx.ccx,"}, {"sha": "8585cacdbc43472975cfc48f288c2b33007f6829", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -867,7 +867,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                 }\n             });\n         }\n-        ty::ty_unboxed_closure(_, region) => {\n+        ty::ty_unboxed_closure(_, region, _) => {\n             if tcx.capture_modes.borrow().get_copy(&expr.id) == ast::CaptureByRef {\n                 ty::with_freevars(tcx, expr.id, |freevars| {\n                     if !freevars.is_empty() {\n@@ -908,7 +908,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                 ensure_free_variable_types_outlive_closure_bound(rcx, bounds, expr, freevars);\n             })\n         }\n-        ty::ty_unboxed_closure(_, region) => {\n+        ty::ty_unboxed_closure(_, region, _) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n                 let bounds = ty::region_existential_bound(region);\n                 ensure_free_variable_types_outlive_closure_bound(rcx, bounds, expr, freevars);"}, {"sha": "06b633ba15b57a1ee4bfc1f000b8a3d066987ef4", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                 self.accumulate_from_closure_ty(ty, c);\n             }\n \n-            ty::ty_unboxed_closure(_, region) => {\n+            ty::ty_unboxed_closure(_, region, _) => {\n                 // An \"unboxed closure type\" is basically\n                 // modeled here as equivalent to a struct like\n                 //\n@@ -118,6 +118,18 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                 //\n                 // where the `'b` is the lifetime bound of the\n                 // contents (i.e., all contents must outlive 'b).\n+                //\n+                // Even though unboxed closures are glorified structs\n+                // of upvars, we do not need to consider them as they\n+                // can't generate any new constraints.  The\n+                // substitutions on the closure are equal to the free\n+                // substitutions of the enclosing parameter\n+                // environment.  An upvar captured by value has the\n+                // same type as the original local variable which is\n+                // already checked for consistency.  If the upvar is\n+                // captured by reference it must also outlive the\n+                // region bound on the closure, but this is explicitly\n+                // handled by logic in regionck.\n                 self.push_region_constraint_from_top(region);\n             }\n "}, {"sha": "38ac317b7a3d4f281af1f666bdd7c33b65296ed0", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -105,7 +105,7 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n             match get(base_type).sty {\n                 ty_enum(def_id, _) |\n                 ty_struct(def_id, _) |\n-                ty_unboxed_closure(def_id, _) => {\n+                ty_unboxed_closure(def_id, _, _) => {\n                     Some(def_id)\n                 }\n                 ty_ptr(ty::mt {ty, ..}) |\n@@ -445,7 +445,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             match ty::get(self_type.ty).sty {\n                 ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) |\n-                ty::ty_unboxed_closure(type_def_id, _) => {\n+                ty::ty_unboxed_closure(type_def_id, _, _) => {\n                     tcx.destructor_for_type\n                        .borrow_mut()\n                        .insert(type_def_id, method_def_id.def_id());"}, {"sha": "de59fb80ad515c46a37b8943a03f1e1b247e0da4", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -105,6 +105,15 @@ pub trait Combine<'tcx> {\n         } else {\n             None\n         };\n+        self.substs_variances(variances.as_ref().map(|v| &**v), a_subst, b_subst)\n+    }\n+\n+    fn substs_variances(&self,\n+                        variances: Option<&ty::ItemVariances>,\n+                        a_subst: &subst::Substs,\n+                        b_subst: &subst::Substs)\n+                        -> cres<subst::Substs>\n+    {\n         let mut substs = subst::Substs::empty();\n \n         for &space in subst::ParamSpace::all().iter() {\n@@ -126,7 +135,7 @@ pub trait Combine<'tcx> {\n \n                     let mut invariance = Vec::new();\n                     let r_variances = match variances {\n-                        Some(ref variances) => {\n+                        Some(variances) => {\n                             variances.regions.get_slice(space)\n                         }\n                         None => {\n@@ -138,7 +147,6 @@ pub trait Combine<'tcx> {\n                     };\n \n                     let regions = try!(relate_region_params(self,\n-                                                            item_def_id,\n                                                             r_variances,\n                                                             a_regions,\n                                                             b_regions));\n@@ -150,7 +158,6 @@ pub trait Combine<'tcx> {\n         return Ok(substs);\n \n         fn relate_region_params<'tcx, C: Combine<'tcx>>(this: &C,\n-                                                        item_def_id: ast::DefId,\n                                                         variances: &[ty::Variance],\n                                                         a_rs: &[ty::Region],\n                                                         b_rs: &[ty::Region])\n@@ -159,11 +166,9 @@ pub trait Combine<'tcx> {\n             let num_region_params = variances.len();\n \n             debug!(\"relate_region_params(\\\n-                   item_def_id={}, \\\n                    a_rs={}, \\\n                    b_rs={},\n                    variances={})\",\n-                   item_def_id.repr(tcx),\n                    a_rs.repr(tcx),\n                    b_rs.repr(tcx),\n                    variances.repr(tcx));\n@@ -464,14 +469,15 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n             Ok(ty::mk_struct(tcx, a_id, substs))\n       }\n \n-      (&ty::ty_unboxed_closure(a_id, a_region),\n-       &ty::ty_unboxed_closure(b_id, b_region))\n+      (&ty::ty_unboxed_closure(a_id, a_region, ref a_substs),\n+       &ty::ty_unboxed_closure(b_id, b_region, ref b_substs))\n       if a_id == b_id => {\n           // All ty_unboxed_closure types with the same id represent\n           // the (anonymous) type of the same closure expression. So\n           // all of their regions should be equated.\n           let region = try!(this.equate().regions(a_region, b_region));\n-          Ok(ty::mk_unboxed_closure(tcx, a_id, region))\n+          let substs = try!(this.substs_variances(None, a_substs, b_substs));\n+          Ok(ty::mk_unboxed_closure(tcx, a_id, region, substs))\n       }\n \n       (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {"}, {"sha": "d8541a54bd9866153c67b4624c6ed7a4e069f832", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -734,9 +734,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 /* leaf type -- noop */\n             }\n \n-            ty::ty_unboxed_closure(_, region) => {\n-                let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(region, contra);\n+            ty::ty_unboxed_closure(..) => {\n+                self.tcx().sess.bug(\"Unexpected unboxed closure type in variance computation\");\n             }\n \n             ty::ty_rptr(region, ref mt) => {"}, {"sha": "943570743e83f21a133315bc3cee556210470332", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cc3a93651d237a8c5dda1571e823a3cba7ce60/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f0cc3a93651d237a8c5dda1571e823a3cba7ce60", "patch": "@@ -425,7 +425,12 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n                   bound_str)\n       }\n       ty_str => \"str\".to_string(),\n-      ty_unboxed_closure(..) => \"closure\".to_string(),\n+      ty_unboxed_closure(ref did, _, ref substs) => {\n+          let unboxed_closures = cx.unboxed_closures.borrow();\n+          unboxed_closures.find(did).map(|cl| {\n+              closure_to_string(cx, &cl.closure_type.subst(cx, substs))\n+          }).unwrap_or_else(|| \"closure\".to_string())\n+      }\n       ty_vec(t, sz) => {\n           match sz {\n               Some(n) => {"}]}