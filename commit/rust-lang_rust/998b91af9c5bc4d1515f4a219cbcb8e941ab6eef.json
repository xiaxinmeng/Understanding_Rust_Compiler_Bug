{"sha": "998b91af9c5bc4d1515f4a219cbcb8e941ab6eef", "node_id": "C_kwDOAAsO6NoAKDk5OGI5MWFmOWM1YmM0ZDE1MTVmNGEyMTljYmNiOGU5NDFhYjZlZWY", "commit": {"author": {"name": "C\u00f4me ALLART", "email": "come.allart@etu.emse.fr", "date": "2021-12-06T17:32:25Z"}, "committer": {"name": "C\u00f4me ALLART", "email": "come.allart@etu.emse.fr", "date": "2021-12-06T17:32:25Z"}, "message": "feat: assist to generate documentation templates", "tree": {"sha": "6a364b8b12ecb87ff0c8a2d00d3eb3f8e57c5fac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a364b8b12ecb87ff0c8a2d00d3eb3f8e57c5fac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/998b91af9c5bc4d1515f4a219cbcb8e941ab6eef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/998b91af9c5bc4d1515f4a219cbcb8e941ab6eef", "html_url": "https://github.com/rust-lang/rust/commit/998b91af9c5bc4d1515f4a219cbcb8e941ab6eef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/998b91af9c5bc4d1515f4a219cbcb8e941ab6eef/comments", "author": null, "committer": null, "parents": [{"sha": "d9b2291f546abc77d24499339a72a89127464b95", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9b2291f546abc77d24499339a72a89127464b95", "html_url": "https://github.com/rust-lang/rust/commit/d9b2291f546abc77d24499339a72a89127464b95"}], "stats": {"total": 972, "additions": 972, "deletions": 0}, "files": [{"sha": "3abdddbb8cb5573a65e0fcd511fd0847f998bb19", "filename": "crates/ide_assists/src/handlers/generate_documentation_template.rs", "status": "added", "additions": 970, "deletions": 0, "changes": 970, "blob_url": "https://github.com/rust-lang/rust/blob/998b91af9c5bc4d1515f4a219cbcb8e941ab6eef/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998b91af9c5bc4d1515f4a219cbcb8e941ab6eef/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs?ref=998b91af9c5bc4d1515f4a219cbcb8e941ab6eef", "patch": "@@ -0,0 +1,970 @@\n+use ide_db::assists::{AssistId, AssistKind};\n+use stdx::to_lower_snake_case;\n+use syntax::{\n+    ast::{self, edit::IndentLevel, HasDocComments, HasName},\n+    AstNode,\n+};\n+\n+use crate::assist_context::{AssistContext, Assists};\n+\n+/// Assist: generate_documentation_template\n+///\n+/// Adds a documentation template above a function definition / declaration\n+///\n+/// ```\n+/// fn my_func(a: i32, b: i32) -> Result<(), std::io::Error> {\n+///     unimplemented!()\n+/// }\n+/// ```\n+/// ->\n+/// ```\n+/// /// .\n+/// ///\n+/// /// # Examples\n+/// ///\n+/// /// ```rust\n+/// /// use my_crate::my_func;\n+/// ///\n+/// /// let result = my_func(a, b);\n+/// /// assert_eq!(result, );\n+/// /// ```\n+/// ///\n+/// /// # Errors\n+/// ///\n+/// /// This function will return an error if .\n+/// fn my_func(a: i32, b: i32) -> Result<(), std::io::Error> {\n+///     unimplemented!()\n+/// }\n+/// ```\n+pub(crate) fn generate_documentation_template(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+) -> Option<()> {\n+    let name = ctx.find_node_at_offset::<ast::Name>()?;\n+    let ast_func = ast::Fn::cast(name.syntax().parent()?)?;\n+    if is_in_trait_impl(&ast_func) {\n+        return None;\n+    }\n+    // TODO disable at least examples if function not public, as the example will fail to build on\n+    // `cargo test`. What is the exact criteria of `pub`ness? All parent modules must be `pub`, for\n+    // `impl { fn }` both `fn` and `struct`* must be public.\n+    //\n+    // What about `pub(crate)`?\n+    //\n+    // *: Seems complex but maybe ignoring this criteria can be ignored.\n+\n+    let parent_syntax = ast_func.syntax();\n+    let text_range = parent_syntax.text_range();\n+    let indent_level = IndentLevel::from_node(&parent_syntax);\n+    let krate_name =\n+        ctx.sema.scope(&parent_syntax).module()?.krate().display_name(ctx.db())?.to_string();\n+\n+    acc.add(\n+        AssistId(\"generate_documentation_template\", AssistKind::Generate),\n+        \"Generate a documentation template\",\n+        text_range,\n+        |builder| {\n+            let mut doc_lines = Vec::new();\n+            // Introduction / short function description before the sections\n+            doc_lines.push(introduction_builder(&ast_func));\n+            // Then come the sections\n+            if let Some(mut lines) = examples_builder(&ast_func, krate_name) {\n+                doc_lines.push(\"\".into());\n+                doc_lines.append(&mut lines);\n+            }\n+            for section_builder in [panics_builder, errors_builder, safety_builder] {\n+                if let Some(mut lines) = section_builder(&ast_func) {\n+                    doc_lines.push(\"\".into());\n+                    doc_lines.append(&mut lines);\n+                }\n+            }\n+            if ast_func.doc_comments().next().is_some() {\n+                doc_lines.push(\"--- OLD VERSION BELOW ---\".into());\n+            }\n+            builder.insert(text_range.start(), documentation_from_lines(doc_lines, indent_level));\n+        },\n+    )\n+}\n+\n+/// Builds an introduction, trying to be smart if the function is `::new()`\n+fn introduction_builder(ast_func: &ast::Fn) -> String {\n+    let is_new = ast_func.name().map(|name| &name.to_string() == \"new\").unwrap_or(false);\n+    if is_new {\n+        let ret_type = return_type(ast_func).map(|ret_type| ret_type.to_string());\n+        let self_type = self_type(ast_func);\n+        if ret_type.as_deref() == Some(\"Self\") || ret_type == self_type {\n+            if let Some(self_type) = self_type {\n+                return format!(\"Creates a new [`{}`].\", self_type);\n+            }\n+        }\n+    }\n+    \".\".into()\n+}\n+\n+/// Builds an `# Examples` section. An option is returned to be able to manage an error in the AST.\n+fn examples_builder(ast_func: &ast::Fn, krate_name: String) -> Option<Vec<String>> {\n+    let (no_panic_ex, panic_ex) = if is_in_trait_def(ast_func) {\n+        let message = \"// Example template not implemented for trait functions\";\n+        (Some(vec![message.into()]), Some(vec![message.into()]))\n+    } else {\n+        let panic_ex = match can_panic(ast_func) {\n+            Some(true) => gen_panic_ex_template(ast_func, krate_name.clone()),\n+            _ => None,\n+        };\n+        let no_panic_ex = gen_ex_template(ast_func, krate_name);\n+        (no_panic_ex, panic_ex)\n+    };\n+\n+    let mut lines = string_vec_from(&[\"# Examples\", \"\", \"```\"]);\n+    lines.append(&mut no_panic_ex?);\n+    lines.push(\"```\".into());\n+    if let Some(mut ex) = panic_ex {\n+        lines.push(\"\".into());\n+        lines.push(\"```should_panic\".into());\n+        lines.append(&mut ex);\n+        lines.push(\"```\".into());\n+    }\n+    Some(lines)\n+}\n+\n+/// Builds an optional `# Panics` section\n+fn panics_builder(ast_func: &ast::Fn) -> Option<Vec<String>> {\n+    match can_panic(ast_func) {\n+        Some(true) => Some(string_vec_from(&[\"# Panics\", \"\", \"Panics if .\"])),\n+        _ => None,\n+    }\n+}\n+\n+/// Builds an optional `# Errors` section\n+fn errors_builder(ast_func: &ast::Fn) -> Option<Vec<String>> {\n+    match return_type(ast_func)?.to_string().contains(\"Result\") {\n+        true => Some(string_vec_from(&[\"# Errors\", \"\", \"This function will return an error if .\"])),\n+        false => None,\n+    }\n+}\n+\n+/// Builds an optional `# Safety` section\n+fn safety_builder(ast_func: &ast::Fn) -> Option<Vec<String>> {\n+    let is_unsafe = ast_func.unsafe_token().is_some();\n+    match is_unsafe {\n+        true => Some(string_vec_from(&[\"# Safety\", \"\", \".\"])),\n+        false => None,\n+    }\n+}\n+\n+/// Generate an example template which should not panic\n+/// `None` if the function has a `self` parameter but is not in an `impl`.\n+fn gen_ex_template(ast_func: &ast::Fn, krate_name: String) -> Option<Vec<String>> {\n+    let (mut lines, ex_helper) = gen_ex_start_helper(ast_func, krate_name)?;\n+    // Call the function, check result\n+    if returns_a_value(ast_func) {\n+        if count_parameters(&ex_helper.param_list) < 3 {\n+            lines.push(format!(\"assert_eq!({}, );\", ex_helper.function_call));\n+        } else {\n+            lines.push(format!(\"let result = {};\", ex_helper.function_call));\n+            lines.push(\"assert_eq!(result, );\".into());\n+        }\n+    } else {\n+        lines.push(format!(\"{};\", ex_helper.function_call));\n+    }\n+    // Check the mutated values\n+    if is_ref_mut_self(ast_func) == Some(true) {\n+        lines.push(format!(\"assert_eq!({}, );\", ex_helper.self_name?));\n+    }\n+    for param_name in &ex_helper.ref_mut_params {\n+        lines.push(format!(\"assert_eq!({}, );\", param_name));\n+    }\n+    Some(lines)\n+}\n+\n+/// Generate an example template which should panic\n+/// `None` if the function has a `self` parameter but is not in an `impl`.\n+fn gen_panic_ex_template(ast_func: &ast::Fn, krate_name: String) -> Option<Vec<String>> {\n+    let (mut lines, ex_helper) = gen_ex_start_helper(ast_func, krate_name)?;\n+    match returns_a_value(ast_func) {\n+        true => lines.push(format!(\"let _ = {}; // panics\", ex_helper.function_call)),\n+        false => lines.push(format!(\"{}; // panics\", ex_helper.function_call)),\n+    }\n+    Some(lines)\n+}\n+\n+/// Intermediary results of the start of example generation\n+struct ExHelper {\n+    function_call: String,\n+    param_list: ast::ParamList,\n+    ref_mut_params: Vec<String>,\n+    self_name: Option<String>,\n+}\n+\n+/// Build the start of the example and transmit the useful intermediary results.\n+/// `None` if the function has a `self` parameter but is not in an `impl`.\n+fn gen_ex_start_helper(ast_func: &ast::Fn, krate_name: String) -> Option<(Vec<String>, ExHelper)> {\n+    let mut lines = Vec::new();\n+    let is_unsafe = ast_func.unsafe_token().is_some();\n+    let param_list = ast_func.param_list()?;\n+    let ref_mut_params = ref_mut_params(&param_list);\n+    let self_name: Option<String> = self_name(ast_func);\n+\n+    lines.push(format!(\"use {};\", build_path(ast_func, krate_name)));\n+    lines.push(\"\".into());\n+    if let Some(self_definition) = self_definition(ast_func, self_name.as_deref()) {\n+        lines.push(self_definition);\n+    }\n+    for param_name in &ref_mut_params {\n+        lines.push(format!(\"let mut {} = ;\", param_name))\n+    }\n+    let function_call = function_call(ast_func, &param_list, self_name.as_deref(), is_unsafe)?;\n+    let ex_helper = ExHelper { function_call, param_list, ref_mut_params, self_name };\n+    Some((lines, ex_helper))\n+}\n+\n+/// `None` if function without a body; some bool to guess if function can panic\n+fn can_panic(ast_func: &ast::Fn) -> Option<bool> {\n+    let body = ast_func.body()?.to_string();\n+    let can_panic = body.contains(\"panic!(\")\n+        || body.contains(\"assert!(\")\n+        || body.contains(\".unwrap()\")\n+        || body.contains(\".expect(\");\n+    Some(can_panic)\n+}\n+\n+/// Helper function to get the name that should be given to `self` arguments\n+fn self_name(ast_func: &ast::Fn) -> Option<String> {\n+    self_partial_type(ast_func).map(|name| to_lower_snake_case(&name))\n+}\n+\n+/// Heper function to get the name of the type of `self`\n+fn self_type(ast_func: &ast::Fn) -> Option<String> {\n+    ast_func\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::Impl::cast)\n+        .and_then(|i| i.self_ty())\n+        .map(|t| (t.to_string()))\n+}\n+\n+/// Heper function to get the name of the type of `self` without generic arguments\n+fn self_partial_type(ast_func: &ast::Fn) -> Option<String> {\n+    let mut self_type = self_type(ast_func)?;\n+    if let Some(idx) = self_type.find(|c| ['<', ' '].contains(&c)) {\n+        self_type.truncate(idx);\n+    }\n+    Some(self_type)\n+}\n+\n+/// Helper function to determine if the function is in a trait implementation\n+fn is_in_trait_impl(ast_func: &ast::Fn) -> bool {\n+    ast_func\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::Impl::cast)\n+        .and_then(|impl_| impl_.trait_())\n+        .is_some()\n+}\n+\n+/// Helper function to determine if the function definition is in a trait definition\n+fn is_in_trait_def(ast_func: &ast::Fn) -> bool {\n+    ast_func.syntax().ancestors().find_map(ast::Trait::cast).is_some()\n+}\n+\n+/// Returns `None` if no `self` at all, `Some(true)` if there is `&mut self` else `Some(false)`\n+fn is_ref_mut_self(ast_func: &ast::Fn) -> Option<bool> {\n+    let self_param = ast_func.param_list()?.self_param()?;\n+    Some(self_param.mut_token().is_some() && self_param.amp_token().is_some())\n+}\n+\n+/// Helper function to define an variable to be the `self` argument\n+fn self_definition(ast_func: &ast::Fn, self_name: Option<&str>) -> Option<String> {\n+    let definition = match is_ref_mut_self(ast_func)? {\n+        true => format!(\"let mut {} = ;\", self_name?),\n+        false => format!(\"let {} = ;\", self_name?),\n+    };\n+    Some(definition)\n+}\n+\n+/// Helper function to determine if a parameter is `&mut`\n+fn is_a_ref_mut_param(param: &ast::Param) -> bool {\n+    match param.ty() {\n+        Some(ast::Type::RefType(param_ref)) => param_ref.mut_token().is_some(),\n+        _ => false,\n+    }\n+}\n+\n+/// Helper function to build the list of `&mut` parameters\n+fn ref_mut_params(param_list: &ast::ParamList) -> Vec<String> {\n+    param_list\n+        .params()\n+        .filter_map(|param| match is_a_ref_mut_param(&param) {\n+            // Maybe better filter the param name (to do this maybe extract a function from\n+            // `arguments_from_params`?) in case of a `mut a: &mut T`. Anyway managing most (not\n+            // all) cases might be enough, the goal is just to produce a template.\n+            true => Some(param.pat()?.to_string()),\n+            false => None,\n+        })\n+        .collect()\n+}\n+\n+/// Helper function to build the comma-separated list of arguments of the function\n+fn arguments_from_params(param_list: &ast::ParamList) -> String {\n+    let args_iter = param_list.params().map(|param| match param.pat() {\n+        // To avoid `mut` in the function call (which would be a nonsense), `Pat` should not be\n+        // written as is so its variants must be managed independently. Other variants (for\n+        // instance `TuplePat`) could be managed later.\n+        Some(ast::Pat::IdentPat(ident_pat)) => match ident_pat.name() {\n+            Some(name) => match is_a_ref_mut_param(&param) {\n+                true => format!(\"&mut {}\", name.to_string()),\n+                false => name.to_string(),\n+            },\n+            None => \"_\".to_string(),\n+        },\n+        _ => \"_\".to_string(),\n+    });\n+    intersperse_string(args_iter, \", \")\n+}\n+\n+/// Helper function to build a function call. `None` if expected `self_name` was not provided\n+fn function_call(\n+    ast_func: &ast::Fn,\n+    param_list: &ast::ParamList,\n+    self_name: Option<&str>,\n+    is_unsafe: bool,\n+) -> Option<String> {\n+    let name = ast_func.name()?;\n+    let arguments = arguments_from_params(&param_list);\n+    let function_call = if param_list.self_param().is_some() {\n+        format!(\"{}.{}({})\", self_name?, name, arguments)\n+    } else if let Some(implementation) = self_partial_type(ast_func) {\n+        format!(\"{}::{}({})\", implementation, name, arguments)\n+    } else {\n+        format!(\"{}({})\", name, arguments)\n+    };\n+    match is_unsafe {\n+        true => Some(format!(\"unsafe {{ {} }}\", function_call)),\n+        false => Some(function_call),\n+    }\n+}\n+\n+/// Helper function to count the parameters including `self`\n+fn count_parameters(param_list: &ast::ParamList) -> usize {\n+    param_list.params().count() + if param_list.self_param().is_some() { 1 } else { 0 }\n+}\n+\n+/// Helper function to transform lines of documentation into a Rust code documentation\n+fn documentation_from_lines(doc_lines: Vec<String>, indent_level: IndentLevel) -> String {\n+    let mut result = String::new();\n+    for doc_line in doc_lines {\n+        result.push_str(\"///\");\n+        if !doc_line.is_empty() {\n+            result.push(' ');\n+            result.push_str(&doc_line);\n+        }\n+        result.push('\\n');\n+        result.push_str(&indent_level.to_string());\n+    }\n+    result\n+}\n+\n+/// Helper function to transform an array of borrowed strings to an owned `Vec<String>`\n+fn string_vec_from(string_array: &[&str]) -> Vec<String> {\n+    string_array.iter().map(|&s| s.to_owned()).collect()\n+}\n+\n+/// Helper function to build the path of the module in the which is the node\n+fn build_path(ast_func: &ast::Fn, krate_name: String) -> String {\n+    let mut path: Vec<String> = ast_func\n+        .syntax()\n+        .ancestors()\n+        .filter_map(|m| ast::Module::cast(m).and_then(|m| m.name()))\n+        .map(|m| m.to_string())\n+        .collect();\n+    path.push(krate_name);\n+    path.reverse();\n+    path.push(\n+        self_partial_type(ast_func)\n+            .or_else(|| ast_func.name().map(|n| n.to_string()))\n+            .unwrap_or_else(|| \"*\".into()),\n+    );\n+    intersperse_string(path.into_iter(), \"::\")\n+}\n+\n+/// Helper function to get the return type of a function\n+fn return_type(ast_func: &ast::Fn) -> Option<ast::Type> {\n+    ast_func.ret_type()?.ty()\n+}\n+\n+/// Helper function to determine if the function returns some data\n+fn returns_a_value(ast_func: &ast::Fn) -> bool {\n+    match return_type(ast_func) {\n+        Some(ret_type) => ![\"()\", \"!\"].contains(&ret_type.to_string().as_str()),\n+        None => false,\n+    }\n+}\n+\n+/// Helper function to concatenate string with a separator between them\n+fn intersperse_string(mut iter: impl Iterator<Item = String>, separator: &str) -> String {\n+    let mut result = String::new();\n+    if let Some(first) = iter.next() {\n+        result.push_str(&first);\n+    }\n+    for string in iter {\n+        result.push_str(separator);\n+        result.push_str(&string);\n+    }\n+    result\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn not_applicable_on_function_calls() {\n+        check_assist_not_applicable(\n+            generate_documentation_template,\n+            r#\"\n+fn hello_world() {}\n+fn calls_hello_world() {\n+    hello_world$0();\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_in_trait_impl() {\n+        check_assist_not_applicable(\n+            generate_documentation_template,\n+            r#\"\n+trait MyTrait {}\n+struct MyStruct;\n+impl MyTrait for MyStruct {\n+    fn hello_world$0();\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn supports_noop_function() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+fn no$0op() {}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::noop;\n+///\n+/// noop();\n+/// ```\n+fn noop() {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn supports_a_parameter() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+fn no$0op_with_param(_a: i32) {}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::noop_with_param;\n+///\n+/// noop_with_param(_a);\n+/// ```\n+fn noop_with_param(_a: i32) {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn detects_unsafe_function() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+unsafe fn no$0op_unsafe() {}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::noop_unsafe;\n+///\n+/// unsafe { noop_unsafe() };\n+/// ```\n+///\n+/// # Safety\n+///\n+/// .\n+unsafe fn noop_unsafe() {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn guesses_panic_macro_can_panic() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+fn panic$0s_if(a: bool) {\n+    if a {\n+        panic!();\n+    }\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::panics_if;\n+///\n+/// panics_if(a);\n+/// ```\n+///\n+/// ```should_panic\n+/// use test::panics_if;\n+///\n+/// panics_if(a); // panics\n+/// ```\n+///\n+/// # Panics\n+///\n+/// Panics if .\n+fn panics_if(a: bool) {\n+    if a {\n+        panic!();\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn guesses_assert_macro_can_panic() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+fn $0panics_if_not(a: bool) {\n+    assert!(a == true);\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::panics_if_not;\n+///\n+/// panics_if_not(a);\n+/// ```\n+///\n+/// ```should_panic\n+/// use test::panics_if_not;\n+///\n+/// panics_if_not(a); // panics\n+/// ```\n+///\n+/// # Panics\n+///\n+/// Panics if .\n+fn panics_if_not(a: bool) {\n+    assert!(a == true);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn guesses_unwrap_can_panic() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+fn $0panics_if_none(a: Option<()>) {\n+    a.unwrap();\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::panics_if_none;\n+///\n+/// panics_if_none(a);\n+/// ```\n+///\n+/// ```should_panic\n+/// use test::panics_if_none;\n+///\n+/// panics_if_none(a); // panics\n+/// ```\n+///\n+/// # Panics\n+///\n+/// Panics if .\n+fn panics_if_none(a: Option<()>) {\n+    a.unwrap();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn guesses_expect_can_panic() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+fn $0panics_if_none2(a: Option<()>) {\n+    a.expect(\"Bouh!\");\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::panics_if_none2;\n+///\n+/// panics_if_none2(a);\n+/// ```\n+///\n+/// ```should_panic\n+/// use test::panics_if_none2;\n+///\n+/// panics_if_none2(a); // panics\n+/// ```\n+///\n+/// # Panics\n+///\n+/// Panics if .\n+fn panics_if_none2(a: Option<()>) {\n+    a.expect(\"Bouh!\");\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn checks_output_in_example() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+fn returns_a_value$0() -> i32 {\n+    0\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::returns_a_value;\n+///\n+/// assert_eq!(returns_a_value(), );\n+/// ```\n+fn returns_a_value() -> i32 {\n+    0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn detects_result_output() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+fn returns_a_result$0() -> Result<i32, std::io::Error> {\n+    Ok(0)\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::returns_a_result;\n+///\n+/// assert_eq!(returns_a_result(), );\n+/// ```\n+///\n+/// # Errors\n+///\n+/// This function will return an error if .\n+fn returns_a_result() -> Result<i32, std::io::Error> {\n+    Ok(0)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn checks_ref_mut_in_example() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+fn modifies_a_value$0(a: &mut i32) {\n+    *a = 0;\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::modifies_a_value;\n+///\n+/// let mut a = ;\n+/// modifies_a_value(&mut a);\n+/// assert_eq!(a, );\n+/// ```\n+fn modifies_a_value(a: &mut i32) {\n+    *a = 0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn stores_result_if_at_least_3_params() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+fn sum3$0(a: i32, b: i32, c: i32) -> i32 {\n+    a + b + c\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::sum3;\n+///\n+/// let result = sum3(a, b, c);\n+/// assert_eq!(result, );\n+/// ```\n+fn sum3(a: i32, b: i32, c: i32) -> i32 {\n+    a + b + c\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn supports_fn_in_mods() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+mod a {\n+    mod b {\n+        fn no$0op() {}\n+    }\n+}\n+\"#,\n+            r#\"\n+mod a {\n+    mod b {\n+        /// .\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// use test::a::b::noop;\n+        ///\n+        /// noop();\n+        /// ```\n+        fn noop() {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn supports_fn_in_impl() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+struct MyStruct;\n+impl MyStruct {\n+    fn no$0op() {}\n+}\n+\"#,\n+            r#\"\n+struct MyStruct;\n+impl MyStruct {\n+    /// .\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::MyStruct;\n+    ///\n+    /// MyStruct::noop();\n+    /// ```\n+    fn noop() {}\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn detects_new() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+#[derive(Debug, PartialEq)]\n+pub struct MyGenericStruct<T> {\n+    pub x: T,\n+}\n+impl<T> MyGenericStruct<T> {\n+    pub fn new$0(x: T) -> MyGenericStruct<T> {\n+        MyGenericStruct { x }\n+    }\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug, PartialEq)]\n+pub struct MyGenericStruct<T> {\n+    pub x: T,\n+}\n+impl<T> MyGenericStruct<T> {\n+    /// Creates a new [`MyGenericStruct<T>`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::MyGenericStruct;\n+    ///\n+    /// assert_eq!(MyGenericStruct::new(x), );\n+    /// ```\n+    pub fn new(x: T) -> MyGenericStruct<T> {\n+        MyGenericStruct { x }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn detects_new_with_self() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+#[derive(Debug, PartialEq)]\n+pub struct MyGenericStruct2<T> {\n+    pub x: T,\n+}\n+impl<T> MyGenericStruct2<T> {\n+    pub fn new$0(x: T) -> Self {\n+        MyGenericStruct2 { x }\n+    }\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug, PartialEq)]\n+pub struct MyGenericStruct2<T> {\n+    pub x: T,\n+}\n+impl<T> MyGenericStruct2<T> {\n+    /// Creates a new [`MyGenericStruct2<T>`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::MyGenericStruct2;\n+    ///\n+    /// assert_eq!(MyGenericStruct2::new(x), );\n+    /// ```\n+    pub fn new(x: T) -> Self {\n+        MyGenericStruct2 { x }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn supports_method_call() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+impl<T> MyGenericStruct<T> {\n+    pub fn co$0nsume(self) {}\n+}\n+\"#,\n+            r#\"\n+impl<T> MyGenericStruct<T> {\n+    /// .\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::MyGenericStruct;\n+    ///\n+    /// let my_generic_struct = ;\n+    /// my_generic_struct.consume();\n+    /// ```\n+    pub fn consume(self) {}\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn checks_modified_self_param() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+impl<T> MyGenericStruct<T> {\n+    pub fn modi$0fy(&mut self, new_value: T) {\n+        self.x = new_value;\n+    }\n+}\n+\"#,\n+            r#\"\n+impl<T> MyGenericStruct<T> {\n+    /// .\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::MyGenericStruct;\n+    ///\n+    /// let mut my_generic_struct = ;\n+    /// my_generic_struct.modify(new_value);\n+    /// assert_eq!(my_generic_struct, );\n+    /// ```\n+    pub fn modify(&mut self, new_value: T) {\n+        self.x = new_value;\n+    }\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "61ac45637be2e4a76f60a3773bc561c21397057c", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/998b91af9c5bc4d1515f4a219cbcb8e941ab6eef/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998b91af9c5bc4d1515f4a219cbcb8e941ab6eef/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=998b91af9c5bc4d1515f4a219cbcb8e941ab6eef", "patch": "@@ -136,6 +136,7 @@ mod handlers {\n     mod generate_default_from_new;\n     mod generate_deref;\n     mod generate_derive;\n+    mod generate_documentation_template;\n     mod generate_enum_is_method;\n     mod generate_enum_projection_method;\n     mod generate_from_impl_for_enum;\n@@ -219,6 +220,7 @@ mod handlers {\n             generate_delegate_methods::generate_delegate_methods,\n             generate_deref::generate_deref,\n             generate_derive::generate_derive,\n+            generate_documentation_template::generate_documentation_template,\n             generate_enum_is_method::generate_enum_is_method,\n             generate_enum_projection_method::generate_enum_as_method,\n             generate_enum_projection_method::generate_enum_try_into_method,"}]}