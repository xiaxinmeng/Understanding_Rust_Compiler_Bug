{"sha": "8f531d9d7e058222cb13a9987a80431906d524b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNTMxZDlkN2UwNTgyMjJjYjEzYTk5ODdhODA0MzE5MDZkNTI0Yjk=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-20T21:34:17Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-20T21:34:17Z"}, "message": "progress", "tree": {"sha": "c58bfb2bb3d3e662c1f35b8dd83c6971a0aca012", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c58bfb2bb3d3e662c1f35b8dd83c6971a0aca012"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f531d9d7e058222cb13a9987a80431906d524b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f531d9d7e058222cb13a9987a80431906d524b9", "html_url": "https://github.com/rust-lang/rust/commit/8f531d9d7e058222cb13a9987a80431906d524b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f531d9d7e058222cb13a9987a80431906d524b9/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edb29ec53db18b8f119154a1b51009f35eeeeeb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/edb29ec53db18b8f119154a1b51009f35eeeeeb2", "html_url": "https://github.com/rust-lang/rust/commit/edb29ec53db18b8f119154a1b51009f35eeeeeb2"}], "stats": {"total": 678, "additions": 593, "deletions": 85}, "files": [{"sha": "e391c9a48ea3c5ad7755590ab61218a31b19221c", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f531d9d7e058222cb13a9987a80431906d524b9/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f531d9d7e058222cb13a9987a80431906d524b9/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=8f531d9d7e058222cb13a9987a80431906d524b9", "patch": "@@ -1 +1,3 @@\n-# turpl\n+# The Unsafe Rust Programming Language (Book)\n+\n+[Start at the intro](http://www.cglab.ca/~abeinges/blah/turpl/intro.html)\n\\ No newline at end of file"}, {"sha": "ae3ce9e31255289b2f8c016e06dd83d53b5e506f", "filename": "conversions.md", "status": "modified", "additions": 174, "deletions": 31, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/8f531d9d7e058222cb13a9987a80431906d524b9/conversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f531d9d7e058222cb13a9987a80431906d524b9/conversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/conversions.md?ref=8f531d9d7e058222cb13a9987a80431906d524b9", "patch": "@@ -5,8 +5,6 @@ are just there to help us use those bits right. Needing to reinterpret those pil\n of bits as different types is a common problem and Rust consequently gives you\n several ways to do that.\n \n-# Safe Rust\n-\n First we'll look at the ways that *Safe Rust* gives you to reinterpret values. The\n most trivial way to do this is to just destructure a value into its constituent\n parts and then build a new type out of them. e.g.\n@@ -31,42 +29,191 @@ fn reinterpret(foo: Foo) -> Bar {\n But this is, at best, annoying to do. For common conversions, rust provides\n more ergonomic alternatives.\n \n-## Auto-Deref\n+\n+\n+\n+# Auto-Deref\n+\n+(Maybe nix this in favour of receiver coercions)\n \n Deref is a trait that allows you to overload the unary `*` to specify a type\n you dereference to. This is largely only intended to be implemented by pointer\n types like `&`, `Box`, and `Rc`. The dot operator will automatically perform\n-automatic dereferencing, so that foo.bar() will work uniformly on `Foo`, `&Foo`, `&&Foo`,\n-`&Rc<Box<&mut&Box<Foo>>>` and so-on. Search bottoms out on the *first* match,\n+automatic dereferencing, so that foo.bar() will work uniformly on `Foo`, `&Foo`, `\n+&&Foo`, `&Rc<Box<&mut&Box<Foo>>>` and so-on. Search bottoms out on the *first* match,\n so implementing methods on pointers is generally to be avoided, as it will shadow\n \"actual\" methods.\n \n-## Coercions\n \n-Types can implicitly be coerced to change in certain contexts. These changes are generally\n-just *weakening* of types, largely focused around pointers. They mostly exist to make\n-Rust \"just work\" in more cases. For instance\n-`&mut T` coerces to `&T`, and `&T` coerces to `*const T`. The most useful coercion you will\n-actually think about it is probably the general *Deref Coercion*: `&T` coerces to `&U` when\n-`T: Deref<U>`. This enables us to pass an `&String` where an `&str` is expected, for instance.\n \n-## Casts\n \n-Casts are a superset of coercions: every coercion can be explicitly invoked via a cast,\n-but some changes require a cast. These \"true casts\" are generally regarded as dangerous or\n-problematic actions. True casts revolves around raw pointers and the primitive numeric\n-types. Here's an exhaustive list of all the true casts:\n+# Coercions\n+\n+Types can implicitly be coerced to change in certain contexts. These changes are\n+generally just *weakening* of types, largely focused around pointers and lifetimes.\n+They mostly exist to make Rust \"just work\" in more cases, and are largely harmless.\n+\n+Here's all the kinds of coercion:\n+\n+\n+Coercion is allowed between the following types:\n+\n+* `T` to `U` if `T` is a [subtype](lifetimes.html#subtyping-and-variance)\n+  of `U` (the 'identity' case);\n+\n+* `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to `T_3`\n+  (transitivity case);\n+\n+* `&mut T` to `&T`;\n+\n+* `*mut T` to `*const T`;\n+\n+* `&T` to `*const T`;\n+\n+* `&mut T` to `*mut T`;\n+\n+* `T` to `U` if `T` implements `CoerceUnsized<U>` (see below) and `T = Foo<...>`\n+  and `U = Foo<...>`;\n+\n+* From TyCtor(`T`) to TyCtor(coerce_inner(`T`));\n+\n+where TyCtor(`T`) is one of `&T`, `&mut T`, `*const T`, `*mut T`, or `Box<T>`.\n+And where coerce_inner is defined as\n+\n+* coerce_inner(`[T, ..n]`) = `[T]`;\n+\n+* coerce_inner(`T`) = `U` where `T` is a concrete type which implements the\n+  trait `U`;\n+\n+* coerce_inner(`T`) = `U` where `T` is a sub-trait of `U`;\n+\n+* coerce_inner(`Foo<..., T, ...>`) = `Foo<..., coerce_inner(T), ...>` where\n+  `Foo` is a struct and only the last field has type `T` and `T` is not part of\n+  the type of any other fields;\n+\n+* coerce_inner(`(..., T)`) = `(..., coerce_inner(T))`.\n+\n+Coercions only occur at a *coercion site*. Exhaustively, the coercion sites\n+are:\n+\n+* In `let` statements where an explicit type is given: in `let _: U = e;`, `e`\n+  is coerced to to have type `U`;\n+\n+* In statics and consts, similarly to `let` statements;\n+\n+* In argument position for function calls. The value being coerced is the actual\n+  parameter and it is coerced to the type of the formal parameter. For example,\n+  where `foo` is defined as `fn foo(x: U) { ... }` and is called with `foo(e);`,\n+  `e` is coerced to have type `U`;\n+\n+* Where a field of a struct or variant is instantiated. E.g., where `struct Foo\n+  { x: U }` and the instantiation is `Foo { x: e }`, `e` is coerced to to have\n+  type `U`;\n+\n+* The result of a function, either the final line of a block if it is not semi-\n+  colon terminated or any expression in a `return` statement. For example, for\n+  `fn foo() -> U { e }`, `e` is coerced to to have type `U`;\n \n-TODO: gank the RFC for sweet casts\n+If the expression in one of these coercion sites is a coercion-propagating\n+expression, then the relevant sub-expressions in that expression are also\n+coercion sites. Propagation recurses from these new coercion sites. Propagating\n+expressions and their relevant sub-expressions are:\n \n-For number -> number casts, there are quite a few cases to consider:\n+* array literals, where the array has type `[U, ..n]`, each sub-expression in\n+  the array literal is a coercion site for coercion to type `U`;\n+\n+* array literals with repeating syntax, where the array has type `[U, ..n]`, the\n+  repeated sub-expression is a coercion site for coercion to type `U`;\n+\n+* tuples, where a tuple is a coercion site to type `(U_0, U_1, ..., U_n)`, each\n+  sub-expression is a coercion site for the respective type, e.g., the zero-th\n+  sub-expression is a coercion site to `U_0`;\n+\n+* the box expression, if the expression has type `Box<U>`, the sub-expression is\n+  a coercion site to `U`;\n+\n+* parenthesised sub-expressions (`(e)`), if the expression has type `U`, then\n+  the sub-expression is a coercion site to `U`;\n+\n+* blocks, if a block has type `U`, then the last expression in the block (if it\n+  is not semicolon-terminated) is a coercion site to `U`. This includes blocks\n+  which are part of control flow statements, such as `if`/`else`, if the block\n+  has a known type.\n+\n+\n+Note that we do not perform coercions when matching traits (except for\n+receivers, see below). If there is an impl for some type `U` and `T` coerces to\n+`U`, that does not constitute an implementation for `T`. For example, the\n+following will not type check, even though it is OK to coerce `t` to `&T` and\n+there is an impl for `&T`:\n+\n+```\n+struct T;\n+trait Trait {}\n+\n+fn foo<X: Trait>(t: X) {}\n+\n+impl<'a> Trait for &'a T {}\n+\n+\n+fn main() {\n+    let t: &mut T = &mut T;\n+    foo(t); //~ ERROR failed to find an implementation of trait Trait for &mut T\n+}\n+```\n+\n+In a cast expression, `e as U`, the compiler will first attempt to coerce `e` to\n+`U`, only if that fails will the conversion rules for casts (see below) be\n+applied.\n+\n+\n+\n+\n+# Casts\n+\n+Casts are a superset of coercions: every coercion can be explicitly invoked via a\n+cast, but some conversions *require* a cast. These \"true casts\" are generally regarded\n+as dangerous or problematic actions. True casts revolve around raw pointers and\n+the primitive numeric types. True casts aren't checked.\n+\n+Here's an exhaustive list of all the true casts:\n+\n+ * `e` has type `T` and `T` coerces to `U`; *coercion-cast*\n+ * `e` has type `*T`, `U` is `*U_0`, and either `U_0: Sized` or\n+    unsize_kind(`T`) = unsize_kind(`U_0`); *ptr-ptr-cast*\n+ * `e` has type `*T` and `U` is a numeric type, while `T: Sized`; *ptr-addr-cast*\n+ * `e` is an integer and `U` is `*U_0`, while `U_0: Sized`; *addr-ptr-cast*\n+ * `e` has type `T` and `T` and `U` are any numeric types; *numeric-cast*\n+ * `e` is a C-like enum and `U` is an integer type; *enum-cast*\n+ * `e` has type `bool` or `char` and `U` is an integer; *prim-int-cast*\n+ * `e` has type `u8` and `U` is `char`; *u8-char-cast*\n+ * `e` has type `&[T; n]` and `U` is `*const T`; *array-ptr-cast*\n+ * `e` is a function pointer type and `U` has type `*T`,\n+   while `T: Sized`; *fptr-ptr-cast*\n+ * `e` is a function pointer type and `U` is an integer; *fptr-addr-cast*\n+\n+where `&.T` and `*T` are references of either mutability,\n+and where unsize_kind(`T`) is the kind of the unsize info\n+in `T` - the vtable for a trait definition (e.g. `fmt::Display` or\n+`Iterator`, not `Iterator<Item=u8>`) or a length (or `()` if `T: Sized`).\n+\n+Note that lengths are not adjusted when casting raw slices -\n+`T: *const [u16] as *const [u8]` creates a slice that only includes\n+half of the original memory.\n+\n+Casting is not transitive, that is, even if `e as U1 as U2` is a valid\n+expression, `e as U2` is not necessarily so (in fact it will only be valid if\n+`U1` coerces to `U2`).\n+\n+For numeric casts, there are quite a few cases to consider:\n \n * casting between two integers of the same size (e.g. i32 -> u32) is a no-op\n * casting from a smaller integer to a bigger integer (e.g. u32 -> u8) will truncate\n * casting from a larger integer to a smaller integer (e.g. u8 -> u32) will\n-    * zero-extend if unsigned\n-    * sign-extend if signed\n-* casting from a float to an integer will round the float towards zero.\n+    * zero-extend if the target is unsigned\n+    * sign-extend if the target is signed\n+* casting from a float to an integer will:\n+    * round the float towards zero if finite\n     * **NOTE: currently this will cause Undefined Behaviour if the rounded\n       value cannot be represented by the target integer type**. This is a bug\n       and will be fixed.\n@@ -86,18 +233,14 @@ well as interpret integers as addresses. However it is impossible to actually\n `unsafe`.\n \n \n-## Conversion Traits\n \n-For full formal specification of all the kinds of coercions and coercion sites, see:\n-https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n+\n+# Conversion Traits\n+\n+TODO\n \n \n \n-* Coercions\n-* Casts\n-* Conversion Traits (Into/As/...)\n \n-# Unsafe Rust\n+# Transmuting Types\n \n-* raw ptr casts\n-* mem::transmute"}, {"sha": "b955d78bd38ba128d62c63deb9d5293573c70522", "filename": "intro.md", "status": "modified", "additions": 138, "deletions": 26, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/8f531d9d7e058222cb13a9987a80431906d524b9/intro.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f531d9d7e058222cb13a9987a80431906d524b9/intro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/intro.md?ref=8f531d9d7e058222cb13a9987a80431906d524b9", "patch": "@@ -1,6 +1,11 @@\n % The Unsafe Rust Programming Language\n \n-This document seeks to complement [The Rust Programming Language][] (TRPL).\n+**This document is about advanced functionality and low-level development practices\n+in the Rust Programming Language. Most of the things discussed won't matter\n+to the average Rust programmer. However if you wish to correctly write unsafe\n+code in Rust, this text contains invaluable information.**\n+\n+This document seeks to complement [The Rust Programming Language Book][] (TRPL).\n Where TRPL introduces the language and teaches the basics, TURPL dives deep into\n the specification of the language, and all the nasty bits necessary to write\n Unsafe Rust. TURPL does not assume you have read TRPL, but does assume you know\n@@ -10,7 +15,7 @@ stack or heap, we will not explain the syntax.\n \n \n \n-# Sections\n+# Chapters\n \n * [Data Layout](data.html)\n * [Ownership and Lifetimes](lifetimes.html)\n@@ -48,7 +53,6 @@ Rust is 100% safe by default. Even when you *opt out* of safety in Rust, it is a\n action. In deciding to work with unchecked uninitialized memory, this does not\n suddenly make dangling or null pointers a problem. When using unchecked indexing on `x`,\n one does not have to suddenly worry about indexing out of bounds on `y`.\n-\n C and C++, by contrast, have pervasive unsafety baked into the language. Even the\n modern best practices like `unique_ptr` have various safety pitfalls.\n \n@@ -85,17 +89,19 @@ To be more concrete, Rust cares about preventing the following things:\n * Breaking the pointer aliasing rules (TBD) (llvm rules + noalias on &mut and & w/o UnsafeCell)\n * Invoking Undefined Behaviour (in e.g. compiler intrinsics)\n * Producing invalid primitive values:\n-\t* dangling/null references\n-\t* a `bool` that isn't 0 or 1\n-\t* an undefined `enum` discriminant\n-\t* a `char` larger than char::MAX\n-\t* A non-utf8 `str`\n+    * dangling/null references\n+    * a `bool` that isn't 0 or 1\n+    * an undefined `enum` discriminant\n+    * a `char` larger than char::MAX\n+    * A non-utf8 `str`\n * Unwinding into an FFI function\n * Causing a data race\n \n-However libraries are free to declare arbitrary requirements if they could transitively\n-cause memory safety issues. However Rust is otherwise quite permisive with respect to\n-other dubious operations. Rust considers it \"safe\" to:\n+That's it. That's all the Undefined Behaviour in Rust. Libraries are free to\n+declare arbitrary requirements if they could transitively cause memory safety\n+issues, but it all boils down to the above actions. Rust is otherwise\n+quite permisive with respect to other dubious operations. Rust considers it\n+\"safe\" to:\n \n * Deadlock\n * Leak memory\n@@ -106,27 +112,27 @@ other dubious operations. Rust considers it \"safe\" to:\n \n However any program that does such a thing is *probably* incorrect. Rust just isn't\n interested in modeling these problems, as they are much harder to prevent in general,\n-and it's basically impossible to prevent incorrect programs from getting written.\n+and it's literally impossible to prevent incorrect programs from getting written.\n \n-Their are several places `unsafe` can appear in Rust today, which can largely be\n+There are several places `unsafe` can appear in Rust today, which can largely be\n grouped into two categories:\n \n * There are unchecked contracts here. To declare you understand this, I require\n you to write `unsafe` elsewhere:\n     * On functions, `unsafe` is declaring the function to be unsafe to call. Users\n-    of the function must check the documentation to determine what this means,\n-    and then have to write `unsafe` somewhere to identify that they're aware of\n+      of the function must check the documentation to determine what this means,\n+      and then have to write `unsafe` somewhere to identify that they're aware of\n     the danger.\n     * On trait declarations, `unsafe` is declaring that *implementing* the trait\n-    is an unsafe operation, as it has contracts that other unsafe code is free to\n-    trust blindly.\n+      is an unsafe operation, as it has contracts that other unsafe code is free to\n+      trust blindly.\n \n * I am declaring that I have, to the best of my knowledge, adhered to the\n unchecked contracts:\n     * On trait implementations, `unsafe` is declaring that the contract of the\n-    `unsafe` trait has been upheld.\n+      `unsafe` trait has been upheld.\n     * On blocks, `unsafe` is declaring any unsafety from an unsafe\n-    operation to be handled, and therefore the parent function is safe.\n+      operation within to be handled, and therefore the parent function is safe.\n \n There is also `#[unsafe_no_drop_flag]`, which is a special case that exists for\n historical reasons and is in the process of being phased out. See the section on\n@@ -135,21 +141,21 @@ destructors for details.\n Some examples of unsafe functions:\n \n * `slice::get_unchecked` will perform unchecked indexing, allowing memory\n-safety to be freely violated.\n+  safety to be freely violated.\n * `ptr::offset` in an intrinsic that invokes Undefined Behaviour if it is\n-not \"in bounds\" as defined by LLVM (see the lifetimes section for details).\n+  not \"in bounds\" as defined by LLVM (see the lifetimes section for details).\n * `mem::transmute` reinterprets some value as having the given type,\n-bypassing type safety in arbitrary ways. (see the conversions section for details)\n+  bypassing type safety in arbitrary ways. (see the conversions section for details)\n * All FFI functions are `unsafe` because they can do arbitrary things.\n-C being an obvious culprit, but generally any language can do something\n-that Rust isn't happy about. (see the FFI section for details)\n+  C being an obvious culprit, but generally any language can do something\n+  that Rust isn't happy about. (see the FFI section for details)\n \n As of Rust 1.0 there are exactly two unsafe traits:\n \n * `Send` is a marker trait (it has no actual API) that promises implementors\n-are safe to send to another thread.\n+  are safe to send to another thread.\n * `Sync` is a marker trait that promises that threads can safely share\n-implementors through a shared reference.\n+  implementors through a shared reference.\n \n All other traits that declare any kind of contract *really* can't be trusted\n to adhere to their contract when memory-safety is at stake. For instance Rust has\n@@ -167,3 +173,109 @@ thread safety is a sort of fundamental thing that a program can't really guard\n against locally (even by-value message passing still requires a notion Send).\n \n \n+\n+\n+# Working with unsafe\n+\n+Rust generally only gives us the tools to talk about safety in a scoped and\n+binary manner. Unfortunately reality is significantly more complicated than that.\n+For instance, consider the following toy function:\n+\n+```rust\n+fn do_idx(idx: usize, arr: &[u8]) -> Option<u8> {\n+    if idx < arr.len() {\n+        unsafe {\n+            Some(*arr.get_unchecked(idx))\n+        }\n+    } else {\n+        None\n+    }\n+}\n+```\n+\n+Clearly, this function is safe. We check that the index is in bounds, and if it\n+is, index into the array in an unchecked manner. But even in such a trivial\n+function, the scope of the unsafe block is questionable. Consider changing the\n+`<` to a `<=`:\n+\n+```rust\n+fn do_idx(idx: usize, arr: &[u8]) -> Option<u8> {\n+    if idx <= arr.len() {\n+        unsafe {\n+            Some(*arr.get_unchecked(idx))\n+        }\n+    } else {\n+        None\n+    }\n+}\n+```\n+\n+This program is now unsound, an yet *we only modified safe code*. This is the\n+fundamental problem of safety: it's non-local. The soundness of our unsafe\n+operations necessarily depends on the state established by \"safe\" operations.\n+Although safety *is* modular (we *still* don't need to worry about about\n+unrelated safety issues like uninitialized memory), it quickly contaminates the\n+surrounding code.\n+\n+Trickier than that is when we get into actual statefulness. Consider a simple\n+implementation of `Vec`:\n+\n+```rust\n+// Note this defintion is insufficient. See the section on lifetimes.\n+struct Vec<T> {\n+    ptr: *mut T,\n+    len: usize,\n+    cap: usize,\n+}\n+\n+// Note this implementation does not correctly handle zero-sized types.\n+// We currently live in a nice imaginary world of only postive fixed-size\n+// types.\n+impl<T> Vec<T> {\n+    fn new() -> Self {\n+        Vec { ptr: heap::EMPTY, len: 0, cap: 0 }\n+    }\n+\n+    fn push(&mut self, elem: T) {\n+        if self.len == self.cap {\n+            // not important for this example\n+            self.reallocate();\n+        }\n+        unsafe {\n+            ptr::write(self.ptr.offset(len as isize), elem);\n+            self.len += 1;\n+        }\n+    }\n+\n+    fn pop(&mut self) -> Option<T> {\n+        if self.len > 0 {\n+            self.len -= 1;\n+            unsafe {\n+                Some(ptr::read(self.ptr.offset(self.len as isize)))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+```\n+\n+This code is simple enough to reasonably audit and verify. Now consider\n+adding the following method:\n+\n+```rust\n+    fn make_room(&mut self) {\n+        // grow the capacity\n+        self.cap += 1;\n+    }\n+```\n+\n+This code is safe, but it is also completely unsound. Changing the capacity\n+violates the invariants of Vec (that `cap` reflects the allocated space in the\n+Vec). This is not something the rest of `Vec` can guard against. It *has* to\n+trust the capacity field because there's no way to verify it.\n+\n+`unsafe` does more than pollute a whole function: it pollutes a whole *module*.\n+Generally, the only bullet-proof way to limit the scope of unsafe code is at the\n+module boundary with privacy.\n+"}, {"sha": "679c1dd3d59933cd14e7df4a4722ce3b89d90774", "filename": "raii.md", "status": "modified", "additions": 278, "deletions": 27, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/8f531d9d7e058222cb13a9987a80431906d524b9/raii.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f531d9d7e058222cb13a9987a80431906d524b9/raii.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/raii.md?ref=8f531d9d7e058222cb13a9987a80431906d524b9", "patch": "@@ -13,7 +13,12 @@ point, really: Rust is about control. However we are not limited to just memory.\n Pretty much every other system resource like a thread, file, or socket is exposed through\n this kind of API.\n \n-So, how does RAII work in Rust? Unlike C++, Rust does not come with a slew on builtin\n+\n+\n+\n+# Constructors\n+\n+Unlike C++, Rust does not come with a slew of builtin\n kinds of constructor. There are no Copy, Default, Assignment, Move, or whatever constructors.\n This largely has to do with Rust's philosophy of being explicit.\n \n@@ -25,20 +30,26 @@ not happening in Rust (safely).\n Assignment and copy constructors similarly don't exist because move semantics are the *default*\n in rust. At most `x = y` just moves the bits of y into the x variable. Rust does provide two\n facilities for going back to C++'s copy-oriented semantics: `Copy` and `Clone`. Clone is our\n-moral equivalent of copy constructor, but it's never implicitly invoked. You have to explicitly\n+moral equivalent of a copy constructor, but it's never implicitly invoked. You have to explicitly\n call `clone` on an element you want to be cloned. Copy is a special case of Clone where the\n-implementation is just \"duplicate the bitwise representation\". Copy types *are* implicitely\n+implementation is just \"copy the bits\". Copy types *are* implicitly\n cloned whenever they're moved, but because of the definition of Copy this just means *not*\n-treating the old copy as uninitialized; a no-op.\n+treating the old copy as uninitialized -- a no-op.\n \n While Rust provides a `Default` trait for specifying the moral equivalent of a default\n constructor, it's incredibly rare for this trait to be used. This is because variables\n-aren't implicitely initialized (see [working with uninitialized memory][uninit] for details).\n+aren't implicitly initialized (see [working with uninitialized memory][uninit] for details).\n Default is basically only useful for generic programming.\n \n-More often than not, in a concrete case a type will provide a static `new` method for any\n-kind of \"default\" constructor. This has no relation to `new` in other languages and has no\n-special meaning. It's just a naming convention.\n+In concrete contexts, a type will provide a static `new` method for any\n+kind of \"default\" constructor. This has no relation to `new` in other\n+languages and has no special meaning. It's just a naming convention.\n+\n+\n+\n+\n+\n+# Destructors\n \n What the language *does* provide is full-blown automatic destructors through the `Drop` trait,\n which provides the following method:\n@@ -49,12 +60,19 @@ fn drop(&mut self);\n \n This method gives the type time to somehow finish what it was doing. **After `drop` is run,\n Rust will recursively try to drop all of the fields of the `self` struct**. This is a\n-convenience feature so that you don't have to write \"destructor boilerplate\" dropping\n-children. **There is no way to prevent this in Rust 1.0**.  Also note that `&mut self` means\n-that even if you *could* supress recursive Drop, Rust will prevent you from e.g. moving fields\n-out of self. For most types, this is totally fine: they own all their data, there's no\n-additional state passed into drop to try to send it to, and `self` is about to be marked as\n-uninitialized (and therefore inaccessible).\n+convenience feature so that you don't have to write \"destructor boilerplate\" to drop\n+children. If a struct has no special logic for being dropped other than dropping its\n+children, then it means `Drop` doesn't need to be implemented at all!\n+\n+**There is no way to prevent this behaviour in Rust 1.0**.\n+\n+Note that taking `&mut self` means that even if you *could* suppress recursive Drop,\n+Rust will prevent you from e.g. moving fields out of self. For most types, this\n+is totally fine:\n+\n+* They own all their data (they don't contain pointers to elsewhere).\n+* There's no additional state passed into drop to try to send things.\n+* `self` is about to be marked as uninitialized (and therefore inaccessible).\n \n For instance, a custom implementation of `Box` might write `Drop` like this:\n \n@@ -73,7 +91,7 @@ impl<T> Drop for Box<T> {\n \n and this works fine because when Rust goes to drop the `ptr` field it just sees a *mut that\n has no actual `Drop` implementation. Similarly nothing can use-after-free the `ptr` because\n-the Box is completely gone.\n+the Box is immediately marked as uninitialized.\n \n However this wouldn't work:\n \n@@ -130,14 +148,14 @@ enum Link {\n }\n ```\n \n-will have its inner Box field dropped *if and only if* a value stores the Next variant.\n+will have its inner Box field dropped *if and only if* an instance stores the Next variant.\n \n In general this works really nice because you don't need to worry about adding/removing\n-dtors when you refactor your data layout. Still there's certainly many valid usecases for\n+drops when you refactor your data layout. Still there's certainly many valid usecases for\n needing to do trickier things with destructors.\n \n-The classic safe solution to blocking recursive drop semantics and allowing moving out\n-of Self is to use an Option:\n+The classic safe solution to overriding recursive drop and allowing moving out\n+of Self during `drop` is to use an Option:\n \n ```rust\n struct Box<T>{ ptr: *mut T }\n@@ -158,22 +176,255 @@ impl<T> Drop for SuperBox<T> {\n \t\tunsafe {\n \t\t\t// Hyper-optimized: deallocate the box's contents for it\n \t\t\t// without `drop`ing the contents. Need to set the `box`\n-\t\t\t// fields as `None` to prevent Rust from trying to Drop it.\n+\t\t\t// field as `None` to prevent Rust from trying to Drop it.\n \t\t\theap::deallocate(self.box.take().unwrap().ptr);\n \t\t}\n \t}\n }\n ```\n \n-However this has fairly odd semantics: you're saying that a field that *should* always be Some\n-may be None, just because that happens in the dtor. Of course this conversely makes a lot of sense:\n-you can call arbitrary methods on self during the destructor, and this should prevent you from\n-ever doing so after deinitializing the field. Not that it will prevent you from producing any other\n+However this has fairly odd semantics: you're saying that a field that *should* always\n+be Some may be None, just because that happens in the destructor. Of course this\n+conversely makes a lot of sense: you can call arbitrary methods on self during\n+the destructor, and this should prevent you from ever doing so after deinitializing\n+the field. Not that it will prevent you from producing any other\n arbitrarily invalid state in there.\n \n-On balance this is an ok choice. Certainly if you're just getting started.\n+On balance this is an ok choice. Certainly what you should reach for by default.\n+However, in the future we expect there to be a first-class way to announce that\n+a field shouldn't be automatically dropped.\n+\n+\n+\n+\n+# Leaking\n+\n+Ownership based resource management is intended to simplify composition. You\n+acquire resources when you create the object, and you release the resources\n+when it gets destroyed. Since destruction is handled for you, it means you\n+can't forget to release the resources, and it happens as soon as possible!\n+Surely this is perfect and all of our problems are solved.\n+\n+Everything is terrible and we have new and exotic problems to try to solve.\n+\n+Many people like to believe that Rust eliminates resource leaks, but this\n+is absolutely not the case, no matter how you look at it. In the strictest\n+sense, \"leaking\" is so abstract as to be unpreventable. It's quite trivial\n+to initialize a collection at the start of a program, fill it with tons of\n+objects with destructors, and then enter an infinite event loop that never\n+refers to it. The collection will sit around uselessly, holding on to its\n+precious resources until the program terminates (at which point all those\n+resources would have been reclaimed by the OS anyway).\n+\n+We may consider a more restricted form of leak: failing to free memory that\n+is unreachable. Rust also doesn't prevent this. In fact Rust has a *function\n+for doing this*: `mem::forget`. This function consumes the value it is passed\n+*and then doesn't run its destructor*.\n+\n+In the past `mem::forget` was marked as unsafe as a sort of lint against using\n+it, since failing to call a destructor is generally not a well-behaved thing to\n+do (though useful for some special unsafe code). However this was generally\n+determined to be an untenable stance to take: there are *many* ways to fail to\n+call a destructor in safe code. The most famous example is creating a cycle\n+of reference counted pointers using interior mutability.\n+\n+It is reasonable for safe code to assume that destructor leaks do not happen,\n+as any program that leaks destructors is probably wrong. However *unsafe* code\n+cannot rely on destructors to be run to be *safe*. For most types this doesn't\n+matter: if you leak the destructor then the type is *by definition* inaccessible,\n+so it doesn't matter, right? e.g. if you leak a `Box<u8>` then you waste some\n+memory but that's hardly going to violate memory-safety.\n+\n+However where we must be careful with destructor leaks are *proxy* types.\n+These are types which manage access to a distinct object, but don't actually\n+own it. Proxy objects are quite rare. Proxy objects you'll need to care about\n+are even rarer. However we'll focus on two interesting examples in the\n+standard library:\n+\n+* `vec::Drain`\n+* `Rc`\n+\n+\n+\n+\n+## Drain\n+\n+`drain` is a collections API that moves data out of the container without\n+consuming the container. This enables us to reuse the allocation of a `Vec`\n+after claiming ownership over all of its contents. drain produces an iterator\n+(Drain) that returns the contents of the Vec by-value.\n+\n+Now, consider Drain in the middle of iteration: some values have been moved out,\n+and others haven't. This means that part of the Vec is now full of logically\n+uninitialized data! We could backshift all the elements in the Vec every time we\n+remove a value, but this would have pretty catastrophic performance consequences.\n+\n+Instead, we would like Drain to *fix* the Vec's backing storage when it is\n+dropped. It should run itself to completion, backshift any elements that weren't\n+removed (drain supports subranges), and then fix Vec's `len`. It's even\n+unwinding-safe! Easy!\n+\n+Now consider the following:\n+\n+```\n+let mut vec = vec![Box::new(0); 4];\n+\n+{\n+\t// start draining, vec can no longer be accessed\n+\tlet mut drainer = vec.drain(..);\n+\n+\t// pull out two elements and immediately drop them\n+\tdrainer.next();\n+\tdrainer.next();\n+\n+\t// get rid of drainer, but don't call its destructor\n+\tmem::forget(drainer);\n+}\n+\n+// Oops, vec[0] was dropped, we're reading a pointer into free'd memory!\n+println!(\"{}\", vec[0]);\n+```\n+\n+This is pretty clearly Not Good. Unfortunately, we're kind've stuck between\n+a rock and a hard place: maintaining consistent state at every step has\n+an enormous cost (and would negate any benefits of the API). Failing to maintain\n+consistent state gives us Undefined Behaviour in safe code (making the API\n+unsound).\n+\n+So what can we do? Well, we can pick a trivially consistent state: set the Vec's\n+len to be 0 when we *start* the iteration, and fix it up if necessary in the\n+destructor. That way, if everything executes like normal we get the desired\n+behaviour with minimal overhead. But if someone has the *audacity* to mem::forget\n+us in the middle of the iteration, all that does is *leak even more* (and possibly\n+leave the Vec in an *unexpected* but consistent state). Since we've\n+accepted that mem::forget is safe, this is definitely safe. We call leaks causing\n+more leaks a *leak amplification*.\n+\n+\n+\n+\n+## Rc\n+\n+Rc is an interesting case because at first glance it doesn't appear to be a\n+proxy value at all. After all, it manages the data it points to, and dropping\n+all the Rcs for a value will drop that value. leaking an Rc doesn't seem like\n+it would be particularly dangerous. It will leave the refcount permanently\n+incremented and prevent the data from being freed or dropped, but that seems\n+just like Box, right?\n+\n+Nope.\n+\n+Let's consider a simplified implementation of Rc:\n+\n+```rust\n+struct Rc<T> {\n+\tptr: *mut RcBox<T>,\n+}\n+\n+struct RcBox<T> {\n+\tdata: T,\n+\tref_count: usize,\n+}\n+\n+impl<T> Rc<T> {\n+\tfn new(data: T) -> Self {\n+\t\tunsafe {\n+\t\t\t// Wouldn't it be nice if heap::allocate worked like this?\n+\t\t\tlet ptr = heap::allocate<RcBox<T>>();\n+\t\t\tptr::write(ptr, RcBox {\n+\t\t\t\tdata: data,\n+\t\t\t\tref_count: 1,\n+\t\t\t});\n+\t\t\tRc { ptr: ptr }\n+\t\t}\n+\t}\n+\n+\tfn clone(&self) -> Self {\n+\t\tunsafe {\n+\t\t\t(*self.ptr).ref_count += 1;\n+\t\t}\n+\t\tRc { ptr: self.ptr }\n+\t}\n+}\n+\n+impl<T> Drop for Rc<T> {\n+\tfn drop(&mut self) {\n+\t\tunsafe {\n+\t\t\tlet inner = &mut ;\n+\t\t\t(*self.ptr).ref_count -= 1;\n+\t\t\tif (*self.ptr).ref_count == 0 {\n+\t\t\t\t// drop the data and then free it\n+\t\t\t\tptr::read(self.ptr);\n+\t\t\t\theap::deallocate(self.ptr);\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+```\n+\n+This code contains an implicit and subtle assumption: ref_count can fit in a\n+`usize`, because there can't be more than `usize::MAX` Rcs in memory. However\n+this itself assumes that the ref_count accurately reflects the number of Rcs\n+in memory, which we know is false with mem::forget. Using mem::forget we can\n+overflow the ref_count, and then get it down to 0 with outstanding Rcs. Then we\n+can happily use-after-free the inner data. Bad Bad Not Good.\n+\n+This can be solved by *saturating* the ref_count, which is sound because\n+decreasing the refcount by `n` still requires `n` Rcs simultaneously living\n+in memory.\n+\n+\n+\n+\n+## thread::scoped\n+\n+The thread::scoped API intends to allow threads to be spawned that reference\n+data on the stack without any synchronization over that data. Usage looked like:\n+\n+```rust\n+let mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+{\n+\tlet guards = vec![];\n+\tfor x in &mut data {\n+\t\t// Move the mutable reference into the closure, and execute\n+\t\t// it on a different thread. The closure has a lifetime bound\n+\t\t// by the lifetime of the mutable reference `x` we store in it.\n+\t\t// The guard that is returned is in turn assigned the lifetime\n+\t\t// of the closure, so it also mutably borrows `data` as `x` did.\n+\t\t// This means we cannot access `data` until the guard goes away.\n+\t\tlet guard = thread::scoped(move || {\n+\t\t\t*x *= 2;\n+\t\t});\n+\t\t// store the thread's guard for later\n+\t\tguards.push(guard);\n+\t}\n+\t// All guards are dropped here, forcing the threads to join\n+\t// (this thread blocks here until the others terminate).\n+\t// Once the threads join, the borrow expires and the data becomes\n+\t// accessible again in this thread.\n+}\n+// data is definitely mutated here.\n+```\n+\n+In principle, this totally works! Rust's ownership system perfectly ensures it!\n+...except it relies on a destructor being called to be safe.\n+\n+```\n+let mut data = Box::new(0);\n+{\n+\tlet guard = thread::scoped(|| {\n+\t\t// This is at best a data race. At worst, it's *also* a use-after-free.\n+\t\t*data += 1;\n+\t});\n+\t// Because the guard is forgotten, expiring the loan without blocking this\n+\t// thread.\n+\tmem::forget(guard);\n+}\n+// So the Box is dropped here while the scoped thread may or may not be trying\n+// to access it.\n+```\n \n-In the future, we expect there to be a first-class way to announce that a field\n-should be automatically dropped.\n+Dang. Here the destructor running was pretty fundamental to the API, and it had\n+to be scrapped in favour of a completely different design.\n \n [uninit]: uninitialized.html\n\\ No newline at end of file"}]}