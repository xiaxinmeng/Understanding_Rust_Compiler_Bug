{"sha": "a65a9d77f3c4e0a573f9c43b51f9076e96201edc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NWE5ZDc3ZjNjNGUwYTU3M2Y5YzQzYjUxZjkwNzZlOTYyMDFlZGM=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-15T09:51:44Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-20T11:23:46Z"}, "message": "Fix accidental quadratic loops", "tree": {"sha": "49aeab48b632c18e4c7d0341cda32697fe9dbd5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49aeab48b632c18e4c7d0341cda32697fe9dbd5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a65a9d77f3c4e0a573f9c43b51f9076e96201edc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a65a9d77f3c4e0a573f9c43b51f9076e96201edc", "html_url": "https://github.com/rust-lang/rust/commit/a65a9d77f3c4e0a573f9c43b51f9076e96201edc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a65a9d77f3c4e0a573f9c43b51f9076e96201edc/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37204027b609f9bd218641c764e692335597ff26", "url": "https://api.github.com/repos/rust-lang/rust/commits/37204027b609f9bd218641c764e692335597ff26", "html_url": "https://github.com/rust-lang/rust/commit/37204027b609f9bd218641c764e692335597ff26"}], "stats": {"total": 100, "additions": 52, "deletions": 48}, "files": [{"sha": "d0cd1cf61ff10e596d6172cbc76a159792b493b4", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a65a9d77f3c4e0a573f9c43b51f9076e96201edc/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65a9d77f3c4e0a573f9c43b51f9076e96201edc/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a65a9d77f3c4e0a573f9c43b51f9076e96201edc", "patch": "@@ -271,22 +271,24 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n \n         let own_self = self_ty.is_some() as usize;\n+        // FIXME(varkor): Separating out the parameters is messy.\n+        let lifetimes: Vec<_> = generic_args.args.iter().filter_map(|arg| match arg {\n+            GenericArg::Lifetime(lt) => Some(lt),\n+            _ => None,\n+        }).collect();\n+        let types: Vec<_> = generic_args.args.iter().filter_map(|arg| match arg {\n+            GenericArg::Type(ty) => Some(ty),\n+            _ => None,\n+        }).collect();\n         let substs = Substs::for_item(tcx, def_id, |param, substs| {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => {\n-                    let mut i = param.index as usize - own_self;\n-                    for arg in &generic_args.args {\n-                        match arg {\n-                            GenericArg::Lifetime(lt) => {\n-                                if i == 0 {\n-                                    return self.ast_region_to_region(lt, Some(param)).into();\n-                                }\n-                                i -= 1;\n-                            }\n-                            _ => {}\n-                        }\n+                    let i = param.index as usize - own_self;\n+                    if let Some(lt) = lifetimes.get(i) {\n+                        self.ast_region_to_region(lt, Some(param)).into()\n+                    } else {\n+                        tcx.types.re_static.into()\n                     }\n-                    tcx.types.re_static.into()\n                 }\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     let i = param.index as usize;\n@@ -296,21 +298,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         return ty.into();\n                     }\n \n-                    let mut i = i - (lt_accepted + own_self);\n+                    let i = i - (lt_accepted + own_self);\n                     if i < ty_provided {\n                         // A provided type parameter.\n-                        for arg in &generic_args.args {\n-                            match arg {\n-                                GenericArg::Type(ty) => {\n-                                    if i == 0 {\n-                                        return self.ast_ty_to_ty(ty).into();\n-                                    }\n-                                    i -= 1;\n-                                }\n-                                _ => {}\n-                            }\n-                        }\n-                        bug!()\n+                        self.ast_ty_to_ty(&types[i]).into()\n                     } else if infer_types {\n                         // No type parameters were provided, we can infer all.\n                         if !default_needs_object_self(param) {"}, {"sha": "93739fbada2f1524b3663ba747a6ae7d3a21459e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a65a9d77f3c4e0a573f9c43b51f9076e96201edc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65a9d77f3c4e0a573f9c43b51f9076e96201edc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a65a9d77f3c4e0a573f9c43b51f9076e96201edc", "patch": "@@ -4813,11 +4813,42 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             (None, None) => (0, false)\n         };\n+        // FIXME(varkor): Separating out the parameters is messy.\n+        let mut lifetimes_type_seg = vec![];\n+        let mut types_type_seg = vec![];\n+        let mut infer_types_type_seg = true;\n+        if let Some((seg, _)) = type_segment {\n+            if let Some(ref data) = seg.args {\n+                for arg in &data.args {\n+                    match arg {\n+                        GenericArg::Lifetime(lt) => lifetimes_type_seg.push(lt),\n+                        GenericArg::Type(ty) => types_type_seg.push(ty),\n+                    }\n+                }\n+            }\n+            infer_types_type_seg = seg.infer_types;\n+        }\n+\n+        let mut lifetimes_fn_seg = vec![];\n+        let mut types_fn_seg = vec![];\n+        let mut infer_types_fn_seg = true;\n+        if let Some((seg, _)) = fn_segment {\n+            if let Some(ref data) = seg.args {\n+                for arg in &data.args {\n+                    match arg {\n+                        GenericArg::Lifetime(lt) => lifetimes_fn_seg.push(lt),\n+                        GenericArg::Type(ty) => types_fn_seg.push(ty),\n+                    }\n+                }\n+            }\n+            infer_types_fn_seg = seg.infer_types;\n+        }\n+\n         let substs = Substs::for_item(self.tcx, def.def_id(), |param, substs| {\n             let mut i = param.index as usize;\n \n-            let segment = if i < fn_start {\n-                if let GenericParamDefKind::Type {..} = param.kind {\n+            let (segment, lifetimes, types, infer_types) = if i < fn_start {\n+                if let GenericParamDefKind::Type { .. } = param.kind {\n                     // Handle Self first, so we can adjust the index to match the AST.\n                     if has_self && i == 0 {\n                         return opt_self_ty.map(|ty| ty.into()).unwrap_or_else(|| {\n@@ -4826,39 +4857,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n                 i -= has_self as usize;\n-                type_segment\n+                (type_segment, &lifetimes_type_seg, &types_type_seg, infer_types_type_seg)\n             } else {\n                 i -= fn_start;\n-                fn_segment\n+                (fn_segment, &lifetimes_fn_seg, &types_fn_seg, infer_types_fn_seg)\n             };\n \n             match param.kind {\n                 GenericParamDefKind::Lifetime => {\n-                    let lifetimes = segment.map_or(vec![], |(s, _)| {\n-                        s.args.as_ref().map_or(vec![], |data| {\n-                            data.args.iter().filter_map(|arg| match arg {\n-                                GenericArg::Lifetime(lt) => Some(lt),\n-                                _ => None,\n-                            }).collect()\n-                        })\n-                    });\n-\n                     if let Some(lifetime) = lifetimes.get(i) {\n                         AstConv::ast_region_to_region(self, lifetime, Some(param)).into()\n                     } else {\n                         self.re_infer(span, Some(param)).unwrap().into()\n                     }\n                 }\n-                GenericParamDefKind::Type {..} => {\n-                    let (types, infer_types) = segment.map_or((vec![], true), |(s, _)| {\n-                        (s.args.as_ref().map_or(vec![], |data| {\n-                            data.args.iter().filter_map(|arg| match arg {\n-                                GenericArg::Type(ty) => Some(ty),\n-                                _ => None,\n-                            }).collect()\n-                        }), s.infer_types)\n-                    });\n-\n+                GenericParamDefKind::Type { .. } => {\n                     // Skip over the lifetimes in the same segment.\n                     if let Some((_, generics)) = segment {\n                         i -= generics.own_counts().lifetimes;"}]}