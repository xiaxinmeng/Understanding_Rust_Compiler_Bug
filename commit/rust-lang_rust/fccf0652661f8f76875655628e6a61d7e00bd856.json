{"sha": "fccf0652661f8f76875655628e6a61d7e00bd856", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjY2YwNjUyNjYxZjhmNzY4NzU2NTU2MjhlNmE2MWQ3ZTAwYmQ4NTY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-10T10:03:50Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-10T10:15:58Z"}, "message": "Implement mutable/immutable alias distinction.\n\nBefore, all aliases were implicitly mutable, and writing\n&mutable was the same as writing &. Now, the two are\ndistinguished, and assignments to regular aliases are\nno longer allowed.", "tree": {"sha": "aaaa5e5a949c97fdfb8acc1e7d85185ebc46c6bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aaaa5e5a949c97fdfb8acc1e7d85185ebc46c6bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fccf0652661f8f76875655628e6a61d7e00bd856", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fccf0652661f8f76875655628e6a61d7e00bd856", "html_url": "https://github.com/rust-lang/rust/commit/fccf0652661f8f76875655628e6a61d7e00bd856", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fccf0652661f8f76875655628e6a61d7e00bd856/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "798bbd2e226c17024252192f939ce5c9ae59a99b", "url": "https://api.github.com/repos/rust-lang/rust/commits/798bbd2e226c17024252192f939ce5c9ae59a99b", "html_url": "https://github.com/rust-lang/rust/commit/798bbd2e226c17024252192f939ce5c9ae59a99b"}], "stats": {"total": 172, "additions": 108, "deletions": 64}, "files": [{"sha": "37d26a6889a44a3eeba81b93053026682d090f87", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=fccf0652661f8f76875655628e6a61d7e00bd856", "patch": "@@ -203,7 +203,7 @@ fn unop_to_str(unop op) -> str {\n \n tag mode {\n     val;\n-    alias;\n+    alias(bool);\n }\n \n type stmt = spanned[stmt_];"}, {"sha": "c2039624300bafd3e0f55c71362ba52ff8372cf1", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=fccf0652661f8f76875655628e6a61d7e00bd856", "patch": "@@ -328,8 +328,12 @@ fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty::arg], ty::t,\n     while (peek(st) as char != ']') {\n         auto mode = ty::mo_val;\n         if (peek(st) as char == '&') {\n-            mode = ty::mo_alias;\n-            st.pos = st.pos + 1u;\n+            mode = ty::mo_alias(false);\n+            st.pos += 1u;\n+            if (peek(st) as char == 'm') {\n+                mode = ty::mo_alias(true);\n+                st.pos += 1u;\n+            }\n         }\n         inputs += [rec(mode=mode, ty=parse_ty(st, sd))];\n     }"}, {"sha": "980daa401357030c0849f50b81cdd3730f0f22e9", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=fccf0652661f8f76875655628e6a61d7e00bd856", "patch": "@@ -319,16 +319,10 @@ fn parse_ty_fn(ast::proto proto, &parser p, uint lo)\n     -> ast::ty_ {\n     fn parse_fn_input_ty(&parser p) -> ast::ty_arg {\n         auto lo = p.get_lo_pos();\n-        auto mode;\n+        auto mode = ast::val;\n         if (p.peek() == token::BINOP(token::AND)) {\n             p.bump();\n-            mode = ast::alias;\n-\n-            if (eat_word(p, \"mutable\")) {\n-                // TODO: handle mutable alias args\n-            }\n-        } else {\n-            mode = ast::val;\n+            mode = ast::alias(eat_word(p, \"mutable\"));\n         }\n \n         auto t = parse_ty(p);\n@@ -598,11 +592,8 @@ fn parse_ty(&parser p) -> @ast::ty {\n fn parse_arg(&parser p) -> ast::arg {\n     let ast::mode m = ast::val;\n     if (p.peek() == token::BINOP(token::AND)) {\n-        m = ast::alias;\n         p.bump();\n-\n-        // TODO: handle mutable alias args\n-        eat_word(p, \"mutable\");\n+        m = ast::alias(eat_word(p, \"mutable\"));\n     }\n     let @ast::ty t = parse_ty(p);\n     let ast::ident i = parse_value_ident(p);"}, {"sha": "4b4b54cad2a9ffde28097f8bf5ae76098a9c5d9f", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=fccf0652661f8f76875655628e6a61d7e00bd856", "patch": "@@ -23,7 +23,12 @@ type restrict = @rec(vec[def_num] root_vars,\n                      vec[uint] depends_on,\n                      mutable valid ok);\n \n-type scope = vec[restrict];\n+type scope = rec(vec[tup(def_num, ast::mode)] args,\n+                 vec[restrict] rs);\n+fn scope(&scope sc, vec[restrict] add) -> scope {\n+    ret rec(args=sc.args, rs=sc.rs + add);\n+}\n+\n type ctx = rec(@ty::ctxt tcx,\n                resolve::def_map dm);\n \n@@ -32,13 +37,17 @@ fn check_crate(@ty::ctxt tcx, resolve::def_map dm, &@ast::crate crate) {\n     auto v = @rec(visit_fn = visit_fn,\n                   visit_expr = bind visit_expr(cx, _, _, _)\n                   with *visit::default_visitor[scope]());\n-    visit::visit_crate(*crate, [], visit::vtor(v));\n+    visit::visit_crate(*crate, rec(args=[], rs=[]), visit::vtor(v));\n }\n \n fn visit_fn(&ast::_fn f, &vec[ast::ty_param] tp, &span sp, &ident name,\n             &ast::def_id d_id, &ast::ann a, &scope sc, &vt[scope] v) {\n     visit::visit_fn_decl(f.decl, sc, v);\n-    vt(v).visit_block(f.body, [], v);\n+    auto args = [];\n+    for (ast::arg arg in f.decl.inputs) {\n+        vec::push(args, tup(arg.id._1, arg.mode));\n+    }\n+    vt(v).visit_block(f.body, rec(args=args, rs=[]), v);\n }\n \n fn visit_expr(&@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n@@ -179,12 +188,12 @@ fn check_alt(&ctx cx, &@ast::expr input, &vec[ast::arm] arms,\n         auto dnums = arm_defnums(a);\n         auto new_sc = sc;\n         if (vec::len(dnums) > 0u) {\n-            vec::push(new_sc, @rec(root_vars=roots,\n-                                   block_defnum=dnums.(0),\n-                                   bindings=dnums,\n-                                   tys=forbidden_tp,\n-                                   depends_on=deps(sc, roots),\n-                                   mutable ok=valid));\n+            new_sc = scope(sc, [@rec(root_vars=roots,\n+                                     block_defnum=dnums.(0),\n+                                     bindings=dnums,\n+                                     tys=forbidden_tp,\n+                                     depends_on=deps(sc, roots),\n+                                     mutable ok=valid)]);\n         }\n         visit::visit_arm(a, new_sc, v);\n     }\n@@ -225,7 +234,7 @@ fn check_for_each(&ctx cx, &@ast::decl decl, &@ast::expr call,\n                                tys=data.unsafe_ts,\n                                depends_on=deps(sc, data.root_vars),\n                                mutable ok=valid);\n-            visit::visit_block(block, sc + [new_sc], v);\n+            visit::visit_block(block, scope(sc, [new_sc]), v);\n         }\n     }\n }\n@@ -261,7 +270,7 @@ fn check_for(&ctx cx, &@ast::decl decl, &@ast::expr seq,\n                        tys=unsafe,\n                        depends_on=deps(sc, root_def),\n                        mutable ok=valid);\n-    visit::visit_block(block, sc + [new_sc], v);\n+    visit::visit_block(block, scope(sc, [new_sc]), v);\n }\n \n fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::ann ann, bool assign,\n@@ -270,7 +279,7 @@ fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::ann ann, bool assign,\n     if (!def_is_local(def)) { ret; }\n     auto my_defnum = ast::def_id_of_def(def)._1;\n     auto var_t = ty::expr_ty(*cx.tcx, ex);\n-    for (restrict r in sc) {\n+    for (restrict r in sc.rs) {\n         // excludes variables introduced since the alias was made\n         if (my_defnum < r.block_defnum) {\n             for (ty::t t in r.tys) {\n@@ -287,14 +296,29 @@ fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::ann ann, bool assign,\n fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src,\n                 &scope sc, &vt[scope] v) {\n     visit_expr(cx, src, sc, v);\n+    \n     alt (dest.node) {\n         case (ast::expr_path(?p, ?ann)) {\n             auto dnum = ast::def_id_of_def(cx.dm.get(ann.id))._1;\n+\n+            for (tup(def_num, ast::mode) arg in sc.args) {\n+                if (arg._0 == dnum && arg._1 == ast::alias(false)) {\n+                    cx.tcx.sess.span_err\n+                        (dest.span, \"assigning to immutable alias\");\n+                }\n+            }\n+\n             auto var_t = ty::expr_ty(*cx.tcx, dest);\n-            for (restrict r in sc) {\n+            for (restrict r in sc.rs) {\n                 if (vec::member(dnum, r.root_vars)) {\n                     r.ok = overwritten(dest.span, p);\n                 }\n+                for (def_num bnd in r.bindings) {\n+                    if (dnum == bnd) {\n+                        cx.tcx.sess.span_err\n+                            (dest.span, \"assigning to immutable alias\");\n+                    }\n+                }\n             }\n             check_var(*cx, dest, p, ann, true, sc);\n         }\n@@ -308,7 +332,7 @@ fn test_scope(&ctx cx, &scope sc, &restrict r, &ast::path p) {\n     auto prob = r.ok;\n     for (uint dep in r.depends_on) {\n         if (prob != valid) { break; }\n-        prob = sc.(dep).ok;\n+        prob = sc.rs.(dep).ok;\n     }\n     if (prob != valid) {\n         auto msg = alt (prob) {\n@@ -328,7 +352,7 @@ fn test_scope(&ctx cx, &scope sc, &restrict r, &ast::path p) {\n fn deps(&scope sc, vec[def_num] roots) -> vec[uint] {\n     auto i = 0u;\n     auto result = [];\n-    for (restrict r in sc) {\n+    for (restrict r in sc.rs) {\n         for (def_num dn in roots) {\n             if (vec::member(dn, r.bindings)) {\n                 vec::push(result, i);"}, {"sha": "bba97d38c46150ae39761a712ed2286a5e226094", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=fccf0652661f8f76875655628e6a61d7e00bd856", "patch": "@@ -250,7 +250,13 @@ mod Encode {\n                  &ast::controlflow cf, &vec[@ast::constr] constrs) {\n         w.write_char('[');\n         for (ty::arg arg in args) {\n-            if (arg.mode == ty::mo_alias) { w.write_char('&'); }\n+            alt (arg.mode) {\n+                case (ty::mo_alias(?mut)) {\n+                    w.write_char('&');\n+                    if (mut) { w.write_char('m'); }\n+                }\n+                case (ty::mo_val) {}\n+            }\n             enc_ty(w, cx, arg.ty);\n         }\n         w.write_char(']');"}, {"sha": "ee5e1c840857d9a9c9284ede35bc74208a237a0b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=fccf0652661f8f76875655628e6a61d7e00bd856", "patch": "@@ -691,12 +691,12 @@ fn type_of_explicit_args(&@crate_ctxt cx, &span sp,\n     let vec[TypeRef] atys = [];\n     for (ty::arg arg in inputs) {\n         if (ty::type_has_dynamic_size(cx.tcx, arg.ty)) {\n-            assert (arg.mode == ty::mo_alias);\n+            assert (arg.mode != ty::mo_val);\n             atys += [T_typaram_ptr(cx.tn)];\n         } else {\n            let TypeRef t;\n             alt (arg.mode) {\n-                case (ty::mo_alias) {\n+                case (ty::mo_alias(_)) {\n                     t = T_ptr(type_of_inner(cx, sp, arg.ty));\n                 }\n                 case (_) {\n@@ -762,9 +762,9 @@ fn type_of_fn_full(&@crate_ctxt cx,\n         atys +=\n             [T_fn_pair(cx.tn,\n                        type_of_fn_full(cx, sp, ast::proto_fn, none[TypeRef],\n-                                          [rec(mode=ty::mo_alias,\n-                                                  ty=output)],\n-                                          ty::mk_nil(cx.tcx), 0u))];\n+                                       [rec(mode=ty::mo_alias(false),\n+                                            ty=output)],\n+                                       ty::mk_nil(cx.tcx), 0u))];\n     }\n \n     // ... then explicit args.\n@@ -923,7 +923,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n fn type_of_arg(@local_ctxt cx, &span sp, &ty::arg arg) -> TypeRef {\n     alt (ty::struct(cx.ccx.tcx, arg.ty)) {\n         case (ty::ty_param(_)) {\n-            if (arg.mode == ty::mo_alias) {\n+            if (arg.mode != ty::mo_val) {\n                 ret T_typaram_ptr(cx.ccx.tn);\n             }\n         }\n@@ -933,7 +933,7 @@ fn type_of_arg(@local_ctxt cx, &span sp, &ty::arg arg) -> TypeRef {\n     }\n \n     auto typ;\n-    if (arg.mode == ty::mo_alias) {\n+    if (arg.mode != ty::mo_val) {\n         typ = T_ptr(type_of_inner(cx.ccx, sp, arg.ty));\n     } else {\n         typ = type_of_inner(cx.ccx, sp, arg.ty);\n@@ -4063,7 +4063,7 @@ fn trans_for_each(&@block_ctxt cx,\n     auto iter_body_llty =\n         type_of_fn_full(lcx.ccx, cx.sp, ast::proto_fn,\n                         none[TypeRef],\n-                        [rec(mode=ty::mo_alias, ty=decl_ty)],\n+                        [rec(mode=ty::mo_alias(false), ty=decl_ty)],\n                         ty::mk_nil(lcx.ccx.tcx), 0u);\n \n     let ValueRef lliterbody = decl_internal_fastcall_fn(lcx.ccx.llmod,\n@@ -4840,7 +4840,7 @@ fn trans_bind_thunk(&@local_ctxt cx,\n                     }\n                 } else if (ty::type_contains_params(cx.ccx.tcx,\n                                                    out_arg.ty)) {\n-                    assert (out_arg.mode == ty::mo_alias);\n+                    assert (out_arg.mode != ty::mo_val);\n                     val = bcx.build.PointerCast(val, llout_arg_ty);\n                 }\n \n@@ -4853,7 +4853,7 @@ fn trans_bind_thunk(&@local_ctxt cx,\n                 let ValueRef passed_arg = llvm::LLVMGetParam(llthunk, a);\n \n                 if (ty::type_contains_params(cx.ccx.tcx, out_arg.ty)) {\n-                    assert (out_arg.mode == ty::mo_alias);\n+                    assert (out_arg.mode != ty::mo_val);\n                     passed_arg = bcx.build.PointerCast(passed_arg,\n                                                        llout_arg_ty);\n                 }\n@@ -5098,7 +5098,7 @@ fn trans_arg_expr(&@block_ctxt cx,\n         auto re = trans_expr(bcx, e);\n         val = re.val;\n         bcx = re.bcx;\n-    } else if (arg.mode == ty::mo_alias) {\n+    } else if (arg.mode != ty::mo_val) {\n         let lval_result lv;\n         if (ty::is_lval(e)) {\n             lv = trans_lval(bcx, e);\n@@ -5125,7 +5125,7 @@ fn trans_arg_expr(&@block_ctxt cx,\n         bcx = re.bcx;\n     }\n \n-    if (arg.mode != ty::mo_alias) {\n+    if (arg.mode == ty::mo_val) {\n         bcx = take_ty(bcx, val, e_ty).bcx;\n     }\n     \n@@ -5930,7 +5930,7 @@ fn trans_put(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n         case (none) { }\n         case (some(?x)) {\n             auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, x);\n-            auto arg = rec(mode=ty::mo_alias, ty=e_ty);\n+            auto arg = rec(mode=ty::mo_alias(false), ty=e_ty);\n             auto arg_tys = type_of_explicit_args(cx.fcx.lcx.ccx,\n                                                  x.span, [arg]);\n             auto r = trans_arg_expr(bcx, arg, arg_tys.(0), x);\n@@ -6194,7 +6194,7 @@ fn mk_spawn_wrapper(&@block_ctxt cx,\n \n     let TypeRef wrapper_fn_type =\n         type_of_fn(cx.fcx.lcx.ccx, cx.sp, ast::proto_fn,\n-                   [rec(mode = ty::mo_alias, ty = args_ty)],\n+                   [rec(mode = ty::mo_alias(false), ty = args_ty)],\n                    ty::idx_nil,\n                    0u);\n \n@@ -6401,7 +6401,7 @@ fn trans_anon_obj(@block_ctxt cx, &span sp,\n         case (some(?fields)) {\n             addtl_fields = fields;\n             for (ast::obj_field f in fields) {\n-                addtl_fn_args += [rec(mode=ast::alias, ty=f.ty, \n+                addtl_fn_args += [rec(mode=ast::alias(false), ty=f.ty, \n                                       ident=f.ident, id=f.id)];\n             }\n         }\n@@ -7045,7 +7045,7 @@ fn copy_args_to_allocas(@fn_ctxt fcx,\n \n     let uint arg_n = 0u;\n     for (ast::arg aarg in args) {\n-        if (aarg.mode != ast::alias) {\n+        if (aarg.mode == ast::val) {\n             auto arg_t = type_of_arg(bcx.fcx.lcx, fcx.sp, arg_tys.(arg_n));\n             auto a = alloca(bcx, arg_t);\n             auto argval = bcx.fcx.llargs.get(aarg.id);\n@@ -7063,7 +7063,7 @@ fn add_cleanups_for_args(&@block_ctxt bcx,\n                          vec[ty::arg] arg_tys) {\n     let uint arg_n = 0u;\n     for (ast::arg aarg in args) {\n-        if (aarg.mode != ast::alias) {\n+        if (aarg.mode == ast::val) {\n             auto argval = bcx.fcx.llargs.get(aarg.id);\n             find_scope_cx(bcx).cleanups +=\n                 [clean(bind drop_slot(_, argval, arg_tys.(arg_n).ty))];\n@@ -7329,7 +7329,8 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::def_id oid,\n     // we're creating.\n     let vec[ast::arg] fn_args = [];\n     for (ast::obj_field f in ob.fields) {\n-        fn_args += [rec(mode=ast::alias, ty=f.ty, ident=f.ident, id=f.id)];\n+        fn_args += [rec(mode=ast::alias(false),\n+                        ty=f.ty, ident=f.ident, id=f.id)];\n     }\n     auto fcx = new_fn_ctxt(cx, sp, llctor_decl);\n \n@@ -7522,10 +7523,10 @@ fn trans_tag_variant(@local_ctxt cx, ast::def_id tag_id,\n     let vec[ast::arg] fn_args = [];\n     auto i = 0u;\n     for (ast::variant_arg varg in variant.node.args) {\n-        fn_args += [rec(mode=ast::alias,\n-                           ty=varg.ty,\n-                           ident=\"arg\" + uint::to_str(i, 10u),\n-                           id=varg.id)];\n+        fn_args += [rec(mode=ast::alias(false),\n+                        ty=varg.ty,\n+                        ident=\"arg\" + uint::to_str(i, 10u),\n+                        id=varg.id)];\n     }\n \n     assert (cx.ccx.item_ids.contains_key(variant.node.id));"}, {"sha": "79ac28b15904d899d8cb3c3fe2eb9b0a2b462167", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=fccf0652661f8f76875655628e6a61d7e00bd856", "patch": "@@ -41,7 +41,7 @@ import util::data::interner;\n \n tag mode {\n     mo_val;\n-    mo_alias;\n+    mo_alias(bool);\n }\n \n type arg = rec(mode mode, t ty);"}, {"sha": "fe7d793db7f094437ac9a8a3e55f9d5dc998ef16", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=fccf0652661f8f76875655628e6a61d7e00bd856", "patch": "@@ -179,7 +179,7 @@ fn ast_mode_to_mode(ast::mode mode) -> ty::mode {\n     auto ty_mode;\n     alt (mode) {\n         case (ast::val) { ty_mode = mo_val; }\n-        case (ast::alias) { ty_mode = mo_alias; }\n+        case (ast::alias(?mut)) { ty_mode = mo_alias(mut); }\n     }\n     ret ty_mode;\n }\n@@ -548,7 +548,7 @@ mod collect {\n         for (ast::obj_field f in obj_info.fields) {\n             auto g = bind getter(cx, _);\n             auto t_field = ast_ty_to_ty(cx.tcx, g, f.ty);\n-            vec::push[arg](t_inputs, rec(mode=ty::mo_alias, ty=t_field));\n+            vec::push(t_inputs, rec(mode=ty::mo_alias(false), ty=t_field));\n         }\n \n         let vec[@ast::constr] constrs = [];\n@@ -681,7 +681,7 @@ mod collect {\n                 let vec[arg] args = [];\n                 for (ast::variant_arg va in variant.node.args) {\n                     auto arg_ty = ast_ty_to_ty(cx.tcx, f, va.ty);\n-                    args += [rec(mode=ty::mo_alias, ty=arg_ty)];\n+                    args += [rec(mode=ty::mo_alias(false), ty=arg_ty)];\n                 }\n                 auto tag_t = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n                 // FIXME: this will be different for constrained types"}, {"sha": "2706eb55832e35933ef2cd631bd5cb6455e42e65", "filename": "src/comp/pretty/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Fpretty%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Fpretty%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fppaux.rs?ref=fccf0652661f8f76875655628e6a61d7e00bd856", "patch": "@@ -13,11 +13,11 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n \n   fn fn_input_to_str(&ctxt cx,\n                      &rec(middle::ty::mode mode, t ty) input) -> str {\n-        auto s;\n-        alt (input.mode) {\n-            case (mo_val) { s = \"\"; }\n-            case (mo_alias) { s = \"&\"; }\n-        }\n+        auto s = alt (input.mode) {\n+            case (mo_val) { \"\" }\n+            case (mo_alias(false)) { \"&\" }\n+            case (mo_alias(true)) { \"&mutable \" }\n+        };\n \n         ret s + ty_to_str(cx, input.ty);\n     }"}, {"sha": "6e1dbf8eba311b14f1d7e265668463c3a2e0a697", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=fccf0652661f8f76875655628e6a61d7e00bd856", "patch": "@@ -960,7 +960,7 @@ fn print_fn(&ps s, ast::fn_decl decl, ast::proto proto, str name,\n     popen(s);\n     fn print_arg(&ps s, &ast::arg x) {\n         ibox(s, indent_unit);\n-        if (x.mode == ast::alias) {word(s.s, \"&\");}\n+        print_alias(s, x.mode);\n         print_type(s, *x.ty);\n         space(s.s);\n         word(s.s, x.ident);\n@@ -977,6 +977,14 @@ fn print_fn(&ps s, ast::fn_decl decl, ast::proto proto, str name,\n     }\n }\n \n+fn print_alias(&ps s, ast::mode m) {\n+    alt (m) {\n+        case (ast::alias(true)) { word_space(s, \"&mutable\"); }\n+        case (ast::alias(false)) { word(s.s, \"&\"); }\n+        case (ast::val) {}\n+    }\n+}\n+\n fn print_type_params(&ps s, &vec[ast::ty_param] params) {\n     if (vec::len[ast::ty_param](params) > 0u) {\n         word(s.s, \"[\");\n@@ -1095,7 +1103,7 @@ fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n     zerobreak(s.s);\n     popen(s);\n     fn print_arg(&ps s, &ast::ty_arg input) {\n-        if (input.node.mode == ast::alias) {word(s.s, \"&\");}\n+        print_alias(s, input.node.mode);\n         print_type(s, *input.node.ty);\n     }\n     auto f = print_arg;"}, {"sha": "a00859e1a52f85096af94aec3b4ccc7f81c98ac5", "filename": "src/test/compile-fail/assign-alias.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Ftest%2Fcompile-fail%2Fassign-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccf0652661f8f76875655628e6a61d7e00bd856/src%2Ftest%2Fcompile-fail%2Fassign-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-alias.rs?ref=fccf0652661f8f76875655628e6a61d7e00bd856", "patch": "@@ -0,0 +1,10 @@\n+// xfail-stage1\n+// error-pattern:assigning to immutable alias\n+\n+fn f(&int i) {\n+    i += 2;\n+}\n+\n+fn main() {\n+    f(1);\n+}\n\\ No newline at end of file"}]}