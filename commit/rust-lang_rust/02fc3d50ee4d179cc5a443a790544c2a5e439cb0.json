{"sha": "02fc3d50ee4d179cc5a443a790544c2a5e439cb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZmMzZDUwZWU0ZDE3OWNjNWE0NDNhNzkwNTQ0YzJhNWU0MzljYjA=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-22T06:48:12Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-24T11:34:00Z"}, "message": "SSR: Refactor to not rely on recursive search for nesting of matches\n\nPreviously, submatches were handled simply by searching in placeholders\nfor more matches. That only works if we search all nodes in the tree\nrecursively. In a subsequent commit, I intend to make search not always\nbe recursive recursive. This commit prepares for that by finding all\nmatches, even if they overlap, then nesting them and removing\noverlapping matches.", "tree": {"sha": "ebef46263fa32fc04f1838b8b6a5191ce8809184", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebef46263fa32fc04f1838b8b6a5191ce8809184"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02fc3d50ee4d179cc5a443a790544c2a5e439cb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02fc3d50ee4d179cc5a443a790544c2a5e439cb0", "html_url": "https://github.com/rust-lang/rust/commit/02fc3d50ee4d179cc5a443a790544c2a5e439cb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02fc3d50ee4d179cc5a443a790544c2a5e439cb0/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "699619a65cf816b927fffa77b2b38f611d8460bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/699619a65cf816b927fffa77b2b38f611d8460bc", "html_url": "https://github.com/rust-lang/rust/commit/699619a65cf816b927fffa77b2b38f611d8460bc"}], "stats": {"total": 147, "additions": 120, "deletions": 27}, "files": [{"sha": "6d578610b4e3fd50b175bf35f99005dcc4c7f73a", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02fc3d50ee4d179cc5a443a790544c2a5e439cb0/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02fc3d50ee4d179cc5a443a790544c2a5e439cb0/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=02fc3d50ee4d179cc5a443a790544c2a5e439cb0", "patch": "@@ -4,6 +4,7 @@\n //! based on a template.\n \n mod matching;\n+mod nester;\n mod parsing;\n mod replacing;\n mod search;\n@@ -90,8 +91,10 @@ impl<'db> MatchFinder<'db> {\n     /// Returns matches for all added rules.\n     pub fn matches(&self) -> SsrMatches {\n         let mut matches = Vec::new();\n-        self.find_all_matches(&mut matches);\n-        SsrMatches { matches }\n+        for rule in &self.rules {\n+            self.find_matches_for_rule(rule, &mut matches);\n+        }\n+        nester::nest_and_remove_collisions(matches, &self.sema)\n     }\n \n     /// Finds all nodes in `file_id` whose text is exactly equal to `snippet` and attempts to match"}, {"sha": "005569f6fa7bbe431a0c073e5636c38d9ba8e00b", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02fc3d50ee4d179cc5a443a790544c2a5e439cb0/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02fc3d50ee4d179cc5a443a790544c2a5e439cb0/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=02fc3d50ee4d179cc5a443a790544c2a5e439cb0", "patch": "@@ -49,6 +49,8 @@ pub struct Match {\n     pub(crate) placeholder_values: FxHashMap<Var, PlaceholderMatch>,\n     pub(crate) ignored_comments: Vec<ast::Comment>,\n     pub(crate) rule_index: usize,\n+    /// The depth of matched_node.\n+    pub(crate) depth: usize,\n }\n \n /// Represents a `$var` in an SSR query.\n@@ -130,10 +132,12 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n             placeholder_values: FxHashMap::default(),\n             ignored_comments: Vec::new(),\n             rule_index: rule.index,\n+            depth: 0,\n         };\n         // Second matching pass, where we record placeholder matches, ignored comments and maybe do\n         // any other more expensive checks that we didn't want to do on the first pass.\n         match_state.attempt_match_node(&mut Phase::Second(&mut the_match), &rule.pattern, code)?;\n+        the_match.depth = sema.ancestors_with_macros(the_match.matched_node.clone()).count();\n         Ok(the_match)\n     }\n "}, {"sha": "b3e20579bda0d25492eb53febb239c9dc973683f", "filename": "crates/ra_ssr/src/nester.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/02fc3d50ee4d179cc5a443a790544c2a5e439cb0/crates%2Fra_ssr%2Fsrc%2Fnester.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02fc3d50ee4d179cc5a443a790544c2a5e439cb0/crates%2Fra_ssr%2Fsrc%2Fnester.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fnester.rs?ref=02fc3d50ee4d179cc5a443a790544c2a5e439cb0", "patch": "@@ -0,0 +1,98 @@\n+//! Converts a flat collection of matches into a nested form suitable for replacement. When there\n+//! are multiple matches for a node, or that overlap, priority is given to the earlier rule. Nested\n+//! matches are only permitted if the inner match is contained entirely within a placeholder of an\n+//! outer match.\n+//!\n+//! For example, if our search pattern is `foo(foo($a))` and the code had `foo(foo(foo(foo(42))))`,\n+//! then we'll get 3 matches, however only the outermost and innermost matches can be accepted. The\n+//! middle match would take the second `foo` from the outer match.\n+\n+use crate::{Match, SsrMatches};\n+use ra_syntax::SyntaxNode;\n+use rustc_hash::FxHashMap;\n+\n+pub(crate) fn nest_and_remove_collisions(\n+    mut matches: Vec<Match>,\n+    sema: &hir::Semantics<ra_ide_db::RootDatabase>,\n+) -> SsrMatches {\n+    // We sort the matches by depth then by rule index. Sorting by depth means that by the time we\n+    // see a match, any parent matches or conflicting matches will have already been seen. Sorting\n+    // by rule_index means that if there are two matches for the same node, the rule added first\n+    // will take precedence.\n+    matches.sort_by(|a, b| a.depth.cmp(&b.depth).then_with(|| a.rule_index.cmp(&b.rule_index)));\n+    let mut collector = MatchCollector::default();\n+    for m in matches {\n+        collector.add_match(m, sema);\n+    }\n+    collector.into()\n+}\n+\n+#[derive(Default)]\n+struct MatchCollector {\n+    matches_by_node: FxHashMap<SyntaxNode, Match>,\n+}\n+\n+impl MatchCollector {\n+    /// Attempts to add `m` to matches. If it conflicts with an existing match, it is discarded. If\n+    /// it is entirely within the a placeholder of an existing match, then it is added as a child\n+    /// match of the existing match.\n+    fn add_match(&mut self, m: Match, sema: &hir::Semantics<ra_ide_db::RootDatabase>) {\n+        let matched_node = m.matched_node.clone();\n+        if let Some(existing) = self.matches_by_node.get_mut(&matched_node) {\n+            try_add_sub_match(m, existing, sema);\n+            return;\n+        }\n+        for ancestor in sema.ancestors_with_macros(m.matched_node.clone()) {\n+            if let Some(existing) = self.matches_by_node.get_mut(&ancestor) {\n+                try_add_sub_match(m, existing, sema);\n+                return;\n+            }\n+        }\n+        self.matches_by_node.insert(matched_node, m);\n+    }\n+}\n+\n+/// Attempts to add `m` as a sub-match of `existing`.\n+fn try_add_sub_match(\n+    m: Match,\n+    existing: &mut Match,\n+    sema: &hir::Semantics<ra_ide_db::RootDatabase>,\n+) {\n+    for p in existing.placeholder_values.values_mut() {\n+        // Note, no need to check if p.range.file is equal to m.range.file, since we\n+        // already know we're within `existing`.\n+        if p.range.range.contains_range(m.range.range) {\n+            // Convert the inner matches in `p` into a temporary MatchCollector. When\n+            // we're done, we then convert it back into an SsrMatches. If we expected\n+            // lots of inner matches, it might be worthwhile keeping a MatchCollector\n+            // around for each placeholder match. However we expect most placeholder\n+            // will have 0 and a few will have 1. More than that should hopefully be\n+            // exceptional.\n+            let mut collector = MatchCollector::default();\n+            for m in std::mem::replace(&mut p.inner_matches.matches, Vec::new()) {\n+                collector.matches_by_node.insert(m.matched_node.clone(), m);\n+            }\n+            collector.add_match(m, sema);\n+            p.inner_matches = collector.into();\n+            break;\n+        }\n+    }\n+}\n+\n+impl From<MatchCollector> for SsrMatches {\n+    fn from(mut match_collector: MatchCollector) -> Self {\n+        let mut matches = SsrMatches::default();\n+        for (_, m) in match_collector.matches_by_node.drain() {\n+            matches.matches.push(m);\n+        }\n+        matches.matches.sort_by(|a, b| {\n+            // Order matches by file_id then by start range. This should be sufficient since ranges\n+            // shouldn't be overlapping.\n+            a.range\n+                .file_id\n+                .cmp(&b.range.file_id)\n+                .then_with(|| a.range.range.start().cmp(&b.range.range.start()))\n+        });\n+        matches\n+    }\n+}"}, {"sha": "a28e9f34146a92513b1a7649188160f7ec41ef1b", "filename": "crates/ra_ssr/src/search.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/02fc3d50ee4d179cc5a443a790544c2a5e439cb0/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02fc3d50ee4d179cc5a443a790544c2a5e439cb0/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fsearch.rs?ref=02fc3d50ee4d179cc5a443a790544c2a5e439cb0", "patch": "@@ -1,54 +1,41 @@\n //! Searching for matches.\n \n-use crate::{matching, Match, MatchFinder};\n+use crate::{matching, parsing::ParsedRule, Match, MatchFinder};\n use ra_db::FileRange;\n use ra_syntax::{ast, AstNode, SyntaxNode};\n \n impl<'db> MatchFinder<'db> {\n-    pub(crate) fn find_all_matches(&self, matches_out: &mut Vec<Match>) {\n+    /// Adds all matches for `rule` to `matches_out`. Matches may overlap in ways that make\n+    /// replacement impossible, so further processing is required in order to properly nest matches\n+    /// and remove overlapping matches. This is done in the `nesting` module.\n+    pub(crate) fn find_matches_for_rule(&self, rule: &ParsedRule, matches_out: &mut Vec<Match>) {\n         // FIXME: Use resolved paths in the pattern to find places to search instead of always\n         // scanning every node.\n-        self.slow_scan(matches_out);\n+        self.slow_scan(rule, matches_out);\n     }\n \n-    fn slow_scan(&self, matches_out: &mut Vec<Match>) {\n+    fn slow_scan(&self, rule: &ParsedRule, matches_out: &mut Vec<Match>) {\n         use ra_db::SourceDatabaseExt;\n         use ra_ide_db::symbol_index::SymbolsDatabase;\n         for &root in self.sema.db.local_roots().iter() {\n             let sr = self.sema.db.source_root(root);\n             for file_id in sr.iter() {\n                 let file = self.sema.parse(file_id);\n                 let code = file.syntax();\n-                self.slow_scan_node(code, &None, matches_out);\n+                self.slow_scan_node(code, rule, &None, matches_out);\n             }\n         }\n     }\n \n     fn slow_scan_node(\n         &self,\n         code: &SyntaxNode,\n+        rule: &ParsedRule,\n         restrict_range: &Option<FileRange>,\n         matches_out: &mut Vec<Match>,\n     ) {\n-        for rule in &self.rules {\n-            if let Ok(mut m) = matching::get_match(false, rule, &code, restrict_range, &self.sema) {\n-                // Continue searching in each of our placeholders.\n-                for placeholder_value in m.placeholder_values.values_mut() {\n-                    if let Some(placeholder_node) = &placeholder_value.node {\n-                        // Don't search our placeholder if it's the entire matched node, otherwise we'd\n-                        // find the same match over and over until we got a stack overflow.\n-                        if placeholder_node != code {\n-                            self.slow_scan_node(\n-                                placeholder_node,\n-                                restrict_range,\n-                                &mut placeholder_value.inner_matches.matches,\n-                            );\n-                        }\n-                    }\n-                }\n-                matches_out.push(m);\n-                return;\n-            }\n+        if let Ok(m) = matching::get_match(false, rule, &code, restrict_range, &self.sema) {\n+            matches_out.push(m);\n         }\n         // If we've got a macro call, we already tried matching it pre-expansion, which is the only\n         // way to match the whole macro, now try expanding it and matching the expansion.\n@@ -60,14 +47,15 @@ impl<'db> MatchFinder<'db> {\n                     // i.e. we don't want to match something that came from the macro itself.\n                     self.slow_scan_node(\n                         &expanded,\n+                        rule,\n                         &Some(self.sema.original_range(tt.syntax())),\n                         matches_out,\n                     );\n                 }\n             }\n         }\n         for child in code.children() {\n-            self.slow_scan_node(&child, restrict_range, matches_out);\n+            self.slow_scan_node(&child, rule, restrict_range, matches_out);\n         }\n     }\n }"}]}