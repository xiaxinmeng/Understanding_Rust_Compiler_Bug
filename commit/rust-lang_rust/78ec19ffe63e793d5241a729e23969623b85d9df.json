{"sha": "78ec19ffe63e793d5241a729e23969623b85d9df", "node_id": "C_kwDOAAsO6NoAKDc4ZWMxOWZmZTYzZTc5M2Q1MjQxYTcyOWUyMzk2OTYyM2I4NWQ5ZGY", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-28T05:23:16Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-01T05:16:15Z"}, "message": "`expand_deriving_clone` tweaks.\n\nImprove a comment, and panic on an impossible code path.", "tree": {"sha": "98c66126314ffa6eaa1c38d3ba07df063e175d3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98c66126314ffa6eaa1c38d3ba07df063e175d3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78ec19ffe63e793d5241a729e23969623b85d9df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78ec19ffe63e793d5241a729e23969623b85d9df", "html_url": "https://github.com/rust-lang/rust/commit/78ec19ffe63e793d5241a729e23969623b85d9df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78ec19ffe63e793d5241a729e23969623b85d9df/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "623ebbe42a72bd9942bb62526a8a0b2981448a53", "url": "https://api.github.com/repos/rust-lang/rust/commits/623ebbe42a72bd9942bb62526a8a0b2981448a53", "html_url": "https://github.com/rust-lang/rust/commit/623ebbe42a72bd9942bb62526a8a0b2981448a53"}], "stats": {"total": 50, "additions": 22, "deletions": 28}, "files": [{"sha": "d713b7e4a73f3ec7b5c75304e58530d75c4cd6e5", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/78ec19ffe63e793d5241a729e23969623b85d9df/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ec19ffe63e793d5241a729e23969623b85d9df/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=78ec19ffe63e793d5241a729e23969623b85d9df", "patch": "@@ -15,23 +15,22 @@ pub fn expand_deriving_clone(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    // check if we can use a short form\n+    // The simple form is `fn clone(&self) -> Self { *self }`, possibly with\n+    // some additional `AssertParamIsClone` assertions.\n     //\n-    // the short form is `fn clone(&self) -> Self { *self }`\n-    //\n-    // we can use the short form if:\n-    // - the item is Copy (unfortunately, all we can check is whether it's also deriving Copy)\n-    // - there are no generic parameters (after specialization this limitation can be removed)\n-    //      if we used the short form with generics, we'd have to bound the generics with\n-    //      Clone + Copy, and then there'd be no Clone impl at all if the user fills in something\n-    //      that is Clone but not Copy. and until specialization we can't write both impls.\n-    // - the item is a union with Copy fields\n-    //      Unions with generic parameters still can derive Clone because they require Copy\n-    //      for deriving, Clone alone is not enough.\n-    //      Wherever Clone is implemented for fields is irrelevant so we don't assert it.\n+    // We can use the simple form if either of the following are true.\n+    // - The type derives Copy and there are no generic parameters.  (If we\n+    //   used the simple form with generics, we'd have to bound the generics\n+    //   with Clone + Copy, and then there'd be no Clone impl at all if the\n+    //   user fills in something that is Clone but not Copy. After\n+    //   specialization we can remove this no-generics limitation.)\n+    // - The item is a union. (Unions with generic parameters still can derive\n+    //   Clone because they require Copy for deriving, Clone alone is not\n+    //   enough. Whether Clone is implemented for fields is irrelevant so we\n+    //   don't assert it.)\n     let bounds;\n     let substructure;\n-    let is_shallow;\n+    let is_simple;\n     match *item {\n         Annotatable::Item(ref annitem) => match annitem.kind {\n             ItemKind::Struct(_, Generics { ref params, .. })\n@@ -44,30 +43,25 @@ pub fn expand_deriving_clone(\n                         .any(|param| matches!(param.kind, ast::GenericParamKind::Type { .. }))\n                 {\n                     bounds = vec![];\n-                    is_shallow = true;\n+                    is_simple = true;\n                     substructure = combine_substructure(Box::new(|c, s, sub| {\n-                        cs_clone_shallow(\"Clone\", c, s, sub, false)\n+                        cs_clone_simple(\"Clone\", c, s, sub, false)\n                     }));\n                 } else {\n                     bounds = vec![];\n-                    is_shallow = false;\n+                    is_simple = false;\n                     substructure =\n                         combine_substructure(Box::new(|c, s, sub| cs_clone(\"Clone\", c, s, sub)));\n                 }\n             }\n             ItemKind::Union(..) => {\n                 bounds = vec![Literal(path_std!(marker::Copy))];\n-                is_shallow = true;\n+                is_simple = true;\n                 substructure = combine_substructure(Box::new(|c, s, sub| {\n-                    cs_clone_shallow(\"Clone\", c, s, sub, true)\n+                    cs_clone_simple(\"Clone\", c, s, sub, true)\n                 }));\n             }\n-            _ => {\n-                bounds = vec![];\n-                is_shallow = false;\n-                substructure =\n-                    combine_substructure(Box::new(|c, s, sub| cs_clone(\"Clone\", c, s, sub)));\n-            }\n+            _ => cx.span_bug(span, \"`#[derive(Clone)]` on wrong item kind\"),\n         },\n \n         _ => cx.span_bug(span, \"`#[derive(Clone)]` on trait item or impl item\"),\n@@ -95,10 +89,10 @@ pub fn expand_deriving_clone(\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand_ext(cx, mitem, item, push, is_shallow)\n+    trait_def.expand_ext(cx, mitem, item, push, is_simple)\n }\n \n-fn cs_clone_shallow(\n+fn cs_clone_simple(\n     name: &str,\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n@@ -141,7 +135,7 @@ fn cs_clone_shallow(\n             }\n             _ => cx.span_bug(\n                 trait_span,\n-                &format!(\"unexpected substructure in shallow `derive({})`\", name),\n+                &format!(\"unexpected substructure in simple `derive({})`\", name),\n             ),\n         }\n     }"}]}