{"sha": "2264c7927dbfc6124b9b756de47200ded1ca76ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNjRjNzkyN2RiZmM2MTI0YjliNzU2ZGU0NzIwMGRlZDFjYTc2YWM=", "commit": {"author": {"name": "Tommy M. McGuire", "email": "mcguire@crsr.net", "date": "2013-02-13T23:52:58Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-05-17T00:59:06Z"}, "message": "Add reverse_part, replace each_permutation, add tests", "tree": {"sha": "0cb29ca75919748ff20bba0b794b1e1ad039b05e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cb29ca75919748ff20bba0b794b1e1ad039b05e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2264c7927dbfc6124b9b756de47200ded1ca76ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2264c7927dbfc6124b9b756de47200ded1ca76ac", "html_url": "https://github.com/rust-lang/rust/commit/2264c7927dbfc6124b9b756de47200ded1ca76ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2264c7927dbfc6124b9b756de47200ded1ca76ac/comments", "author": {"login": "tmmcguire", "id": 1326568, "node_id": "MDQ6VXNlcjEzMjY1Njg=", "avatar_url": "https://avatars.githubusercontent.com/u/1326568?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmmcguire", "html_url": "https://github.com/tmmcguire", "followers_url": "https://api.github.com/users/tmmcguire/followers", "following_url": "https://api.github.com/users/tmmcguire/following{/other_user}", "gists_url": "https://api.github.com/users/tmmcguire/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmmcguire/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmmcguire/subscriptions", "organizations_url": "https://api.github.com/users/tmmcguire/orgs", "repos_url": "https://api.github.com/users/tmmcguire/repos", "events_url": "https://api.github.com/users/tmmcguire/events{/privacy}", "received_events_url": "https://api.github.com/users/tmmcguire/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00eef96a007a817533e78860e97b251258177d5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/00eef96a007a817533e78860e97b251258177d5f", "html_url": "https://github.com/rust-lang/rust/commit/00eef96a007a817533e78860e97b251258177d5f"}], "stats": {"total": 211, "additions": 193, "deletions": 18}, "files": [{"sha": "764e329a0aa4e99178544f4a207661bd6ab16458", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 193, "deletions": 18, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/2264c7927dbfc6124b9b756de47200ded1ca76ac/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2264c7927dbfc6124b9b756de47200ded1ca76ac/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=2264c7927dbfc6124b9b756de47200ded1ca76ac", "patch": "@@ -1445,6 +1445,46 @@ pub fn reverse<T>(v: &mut [T]) {\n     }\n }\n \n+/**\n+ * Reverse part of a vector in place.\n+ *\n+ * Reverse the elements in the vector between `start` and `end - 1`.\n+ *\n+ * # Arguments\n+ *\n+ * * `v` - The mutable vector to be modified\n+ *\n+ * * `start` - Index of the first element of the slice\n+ *\n+ * * `end` - Index one past the final element to be reversed.\n+ *\n+ * # Example\n+ *\n+ * Assume a mutable vector `v` contains `[1,2,3,4,5]`. After the call:\n+ *\n+ * ~~~\n+ *\n+ * reverse_part(v, 1, 4);\n+ *\n+ * ~~~\n+ *\n+ * `v` now contains `[1,4,3,2,5]`.\n+ *\n+ * # Safety note\n+ *\n+ * Behavior is undefined if `start` or `end` do not represent valid\n+ * positions in `v`.\n+ */\n+pub fn reverse_part<T>(v: &mut [T], start: uint, end : uint) {\n+    let mut i = start;\n+    let mut j = end - 1;\n+    while i < j {\n+        v[i] <-> v[j];\n+        i += 1;\n+        j -= 1;\n+    }\n+}\n+\n /// Returns a vector with the order of elements reversed\n pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n@@ -1739,31 +1779,75 @@ pub fn each2_mut<U, T>(v1: &mut [U], v2: &mut [T], f: &fn(u: &mut U, t: &mut T)\n  *\n  * The total number of permutations produced is `len(v)!`.  If `v` contains\n  * repeated elements, then some permutations are repeated.\n+ *\n+ * See [Algorithms to generate\n+ * permutations](http://en.wikipedia.org/wiki/Permutation).\n+ *\n+ *  # Arguments\n+ *\n+ *  * `values` - A vector of values from which the permutations are\n+ *  chosen\n+ *\n+ *  * `fun` - The function to iterate over the combinations\n  */\n #[cfg(not(stage0))]\n-pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) -> bool {\n-    let ln = len(v);\n-    if ln <= 1 {\n-        put(v);\n-    } else {\n-        // This does not seem like the most efficient implementation.  You\n-        // could make far fewer copies if you put your mind to it.\n-        let mut i = 0u;\n-        while i < ln {\n-            let elt = v[i];\n-            let mut rest = slice(v, 0u, i).to_vec();\n-            rest.push_all(const_slice(v, i+1u, ln));\n-            for each_permutation(rest) |permutation| {\n-                if !put(append(~[elt], permutation)) {\n-                    return false;\n-                }\n-            }\n-            i += 1u;\n+pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) {\n+    let length = values.len();\n+    let mut permutation = vec::from_fn(length, |i| values[i]);\n+    if length <= 1 {\n+        fun(permutation);\n+        return;\n+    }\n+    let mut indices = vec::from_fn(length, |i| i);\n+    loop {\n+        if !fun(permutation) { return; }\n+        // find largest k such that indices[k] < indices[k+1]\n+        // if no such k exists, all permutations have been generated\n+        let mut k = length - 2;\n+        while k > 0 && indices[k] >= indices[k+1] {\n+            k -= 1;\n+        }\n+        if k == 0 && indices[0] > indices[1] { return; }\n+        // find largest l such that indices[k] < indices[l]\n+        // k+1 is guaranteed to be such\n+        let mut l = length - 1;\n+        while indices[k] >= indices[l] {\n+            l -= 1;\n+        }\n+        // swap indices[k] and indices[l]; sort indices[k+1..]\n+        // (they're just reversed)\n+        indices[k] <-> indices[l];\n+        unsafe {\n+            reverse_part(indices, k+1, length);\n+        }\n+        // fixup permutation based on indices\n+        for uint::range(k, length) |i| {\n+            permutation[i] = values[indices[i]];\n         }\n     }\n     return true;\n }\n \n+/**\n+ * Iterate over all permutations of vector `values`.\n+ *\n+ * This is an alternative to each_permutation that uses references to\n+ * avoid copying the elements of the values vector.\n+ *\n+ * To avoid copying, the iterator will be passed a reference to a vector\n+ * containing references to the elements in the original `values` vector.\n+ *\n+ * # Arguments\n+ *\n+ * * `values` - A vector of values from which the permutations are chosen\n+ *\n+ * * `fun` - The function to iterate over the permutations\n+ */\n+#[cfg(not(stage0))]\n+pub fn each_permutation_ref<T>(values : &'v[T], fun : &fn(perm : &[&'v T]) -> bool) {\n+    each_permutation(vec::from_fn(values.len(), |i| &values[i]), fun);\n+}\n+\n /**\n  * Iterate over all contiguous windows of length `n` of the vector `v`.\n  *\n@@ -4730,6 +4814,97 @@ mod tests {\n         }\n     }\n \n+    fn dup<T:Copy>(values : &[&T]) -> ~[T] {\n+        from_fn(values.len(), |i| *values[i])\n+    }\n+\n+    #[test]\n+    fn test_reverse_part() {\n+        let mut values = [1,2,3,4,5];\n+        reverse_part(values,1,4);\n+        assert values == [1,4,3,2,5];\n+    }\n+\n+    #[test]\n+    fn test_permutations0() {\n+        let values = [];\n+        let mut v : ~[~[int]] = ~[];\n+        for each_permutation(values) |p| {\n+            v.push(vec::from_slice(p));\n+        }\n+        assert v == ~[~[]];\n+    }\n+\n+    #[test]\n+    fn test_permutations0_ref() {\n+        let values = [];\n+        let mut v : ~[~[int]] = ~[];\n+        for each_permutation_ref(values) |p| {\n+            v.push(dup(p));\n+        }\n+        assert v == ~[~[]];\n+    }\n+\n+    #[test]\n+    fn test_permutations1() {\n+        let values = [1];\n+        let mut v : ~[~[int]] = ~[];\n+        for each_permutation(values) |p| {\n+            v.push(vec::from_slice(p));\n+        }\n+        assert v == ~[~[1]];\n+    }\n+\n+    #[test]\n+    fn test_permutations1_ref() {\n+        let values = [1];\n+        let mut v : ~[~[int]] = ~[];\n+        for each_permutation_ref(values) |p| {\n+            v.push(dup(p));\n+        }\n+        assert v == ~[~[1]];\n+    }\n+\n+    #[test]\n+    fn test_permutations2() {\n+        let values = [1,2];\n+        let mut v : ~[~[int]] = ~[];\n+        for each_permutation(values) |p| {\n+            v.push(vec::from_slice(p));\n+        }\n+        assert v == ~[~[1,2],~[2,1]];\n+    }\n+\n+    #[test]\n+    fn test_permutations2_ref() {\n+        let values = [1,2];\n+        let mut v : ~[~[int]] = ~[];\n+        for each_permutation_ref(values) |p| {\n+            v.push(dup(p));\n+        }\n+        assert v == ~[~[1,2],~[2,1]];\n+    }\n+\n+    #[test]\n+    fn test_permutations3() {\n+        let values = [1,2,3];\n+        let mut v : ~[~[int]] = ~[];\n+        for each_permutation(values) |p| {\n+            v.push(vec::from_slice(p));\n+        }\n+        assert v == ~[~[1,2,3],~[1,3,2],~[2,1,3],~[2,3,1],~[3,1,2],~[3,2,1]];\n+    }\n+\n+    #[test]\n+    fn test_permutations3_ref() {\n+        let values = [1,2,3];\n+        let mut v : ~[~[int]] = ~[];\n+        for each_permutation_ref(values) |p| {\n+            v.push(dup(p));\n+        }\n+        assert v == ~[~[1,2,3],~[1,3,2],~[2,1,3],~[2,3,1],~[3,1,2],~[3,2,1]];\n+    }\n+\n     #[test]\n     fn test_each_val() {\n         use old_iter::CopyableNonstrictIter;"}]}