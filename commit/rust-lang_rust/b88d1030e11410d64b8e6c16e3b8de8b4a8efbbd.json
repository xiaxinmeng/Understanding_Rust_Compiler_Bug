{"sha": "b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4OGQxMDMwZTExNDEwZDY0YjhlNmMxNmUzYjhkZThiNGE4ZWZiYmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-17T18:26:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-17T18:26:14Z"}, "message": "auto merge of #17343 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "93ac76837a46746fa762fb29ff0dc7b824277122", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93ac76837a46746fa762fb29ff0dc7b824277122"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "html_url": "https://github.com/rust-lang/rust/commit/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d2af38611cdeeb804659b5e0695ad2c251db51a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d2af38611cdeeb804659b5e0695ad2c251db51a", "html_url": "https://github.com/rust-lang/rust/commit/4d2af38611cdeeb804659b5e0695ad2c251db51a"}, {"sha": "3a54a4ee6bb9e0ab02c2556f029c288dda3c3de1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a54a4ee6bb9e0ab02c2556f029c288dda3c3de1", "html_url": "https://github.com/rust-lang/rust/commit/3a54a4ee6bb9e0ab02c2556f029c288dda3c3de1"}], "stats": {"total": 906, "additions": 560, "deletions": 346}, "files": [{"sha": "9aa23e732abfe913a501aefe6fd5632d00c968eb", "filename": "configure", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/configure", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -453,6 +453,8 @@ valopt datadir \"${CFG_PREFIX}/share\" \"install data\"\n valopt infodir \"${CFG_PREFIX}/share/info\" \"install additional info\"\n valopt mandir \"${CFG_PREFIX}/share/man\" \"install man pages in PATH\"\n \n+valopt release-channel \"source\" \"the name of the release channel to build\"\n+\n # On windows we just store the libraries in the bin directory because\n # there's no rpath. This is where the build system itself puts libraries;\n # --libdir is used to configure the installation directory.\n@@ -481,6 +483,23 @@ CFG_BUILD=`echo \"${CFG_BUILD}\" | sed 's/-pc-mingw32/-w64-mingw32/g'`\n CFG_HOST=`echo \"${CFG_HOST}\" | sed 's/-pc-mingw32/-w64-mingw32/g'`\n CFG_TARGET=`echo \"${CFG_TARGET}\" | sed 's/-pc-mingw32/-w64-mingw32/g'`\n \n+# Validate the release channel\n+case \"$CFG_RELEASE_CHANNEL\" in\n+    (source | nightly | beta | stable)\n+\t;;\n+    (*)\n+        err \"release channel must be 'source', 'nightly', 'beta' or 'stable'\"\n+        ;;\n+esac\n+\n+# Continue supporting the old --enable-nightly flag to transition the bots\n+# XXX Remove me\n+if [ $CFG_ENABLE_NIGHTLY -eq 1 ]\n+then\n+    CFG_RELEASE_CHANNEL=nightly\n+    putvar CFG_RELEASE_CHANNEL\n+fi\n+\n step_msg \"looking for build programs\"\n \n probe_need CFG_PERL        perl\n@@ -636,7 +655,7 @@ then\n             # check that gcc, cc and g++ all point to the same compiler.\n             # note that for xcode 5, g++ points to clang, not clang++\n             if !((chk_cc gcc clang  && chk_cc g++ clang) ||\n-                (chk_cc gcc gcc  &&( chk_cc g++ g++ || chk g++ gcc))) then\n+                (chk_cc gcc gcc  &&( chk_cc g++ g++ || chk g++ gcc))); then\n                 err \"the gcc and g++ in your path point to different compilers.\n     Check which versions are in your path with gcc --version and g++ --version.\n     To resolve this problem, either fix your PATH  or run configure with --enable-clang\""}, {"sha": "6b7243541c41afb0f10f129b2367ba6dbf84ae35", "filename": "man/rustc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -1,4 +1,4 @@\n-.TH RUSTC \"1\" \"March 2014\" \"rustc 0.12.0-pre\" \"User Commands\"\n+.TH RUSTC \"1\" \"March 2014\" \"rustc 0.12.0\" \"User Commands\"\n .SH NAME\n rustc \\- The Rust compiler\n .SH SYNOPSIS"}, {"sha": "e675aca38aa9882993aeae8431fa85861f41882c", "filename": "man/rustdoc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/man%2Frustdoc.1", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/man%2Frustdoc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustdoc.1?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -1,4 +1,4 @@\n-.TH RUSTDOC \"1\" \"March 2014\" \"rustdoc 0.12.0-pre\" \"User Commands\"\n+.TH RUSTDOC \"1\" \"March 2014\" \"rustdoc 0.12.0\" \"User Commands\"\n .SH NAME\n rustdoc \\- generate documentation from Rust source code\n .SH SYNOPSIS"}, {"sha": "6667a29d4f956fd661da5e2b4a284b54fed83e33", "filename": "mk/main.mk", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -14,22 +14,32 @@\n \n # The version number\n CFG_RELEASE_NUM=0.12.0\n-CFG_RELEASE_LABEL=-pre\n \n CFG_FILENAME_EXTRA=4e7c5e5c\n \n-ifndef CFG_ENABLE_NIGHTLY\n-# This is the normal version string\n-CFG_RELEASE=$(CFG_RELEASE_NUM)$(CFG_RELEASE_LABEL)\n-CFG_PACKAGE_VERS=$(CFG_RELEASE)\n-else\n-# Modify the version label for nightly builds\n-CFG_RELEASE=$(CFG_RELEASE_NUM)$(CFG_RELEASE_LABEL)-nightly\n-# When building nightly distributables just reuse the same \"rust-nightly\" name\n-# so when we upload we'll always override the previous nighly. This doesn't actually\n-# impact the version reported by rustc - it's just for file naming.\n+ifeq ($(CFG_RELEASE_CHANNEL),stable)\n+# This is the normal semver version string, e.g. \"0.12.0\", \"0.12.0-nightly\"\n+CFG_RELEASE=$(CFG_RELEASE_NUM)\n+# This is the string used in dist artifact file names, e.g. \"0.12.0\", \"nightly\"\n+CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)\n+endif\n+ifeq ($(CFG_RELEASE_CHANNEL),beta)\n+CFG_RELEASE=$(CFG_RELEASE_NUM)-beta\n+# When building beta/nightly distributables just reuse the same \"beta\"\n+# name so when we upload we'll always override the previous\n+# nighly. This doesn't actually impact the version reported by rustc -\n+# it's just for file naming.\n+CFG_PACKAGE_VERS=beta\n+endif\n+ifeq ($(CFG_RELEASE_CHANNEL),nightly)\n+CFG_RELEASE=$(CFG_RELEASE_NUM)-nightly\n CFG_PACKAGE_VERS=nightly\n endif\n+ifeq ($(CFG_RELEASE_CHANNEL),source)\n+CFG_RELEASE=$(CFG_RELEASE_NUM)-pre\n+CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)-pre\n+endif\n+\n # The name of the package to use for creating tarballs, installers etc.\n CFG_PACKAGE_NAME=rust-$(CFG_PACKAGE_VERS)\n "}, {"sha": "4a978ccb92b53ddfd63f7081a9a3e16dc9c1c55e", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -235,7 +235,7 @@ fn partial_sum(start: uint) -> f64 {\n }\n \n fn main() {\n-    let mut futures = Vec::from_fn(1000, |ind| Future::spawn( proc() { partial_sum(ind) }));\n+    let mut futures = Vec::from_fn(200, |ind| Future::spawn( proc() { partial_sum(ind) }));\n \n     let mut final_res = 0f64;\n     for ft in futures.iter_mut()  {"}, {"sha": "2f16c783446402d3cb439a2ebe8c5cdc436ae3b7", "filename": "src/doc/guide.md", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -29,8 +29,11 @@ $ curl -s https://static.rust-lang.org/rustup.sh | sudo sh\n (If you're concerned about `curl | sudo sh`, please keep reading. Disclaimer\n below.)\n \n-If you're on Windows, please [download this .exe and run\n-it](https://static.rust-lang.org/dist/rust-nightly-install.exe).\n+If you're on Windows, please download either the [32-bit\n+installer](https://static.rust-lang.org/dist/rust-nightly-i686-w64-mingw32.exe)\n+or the [64-bit\n+installer](https://static.rust-lang.org/dist/rust-nightly-x86_64-w64-mingw32.exe)\n+and run it.\n \n If you decide you don't want Rust anymore, we'll be a bit sad, but that's okay.\n Not every programming language is great for everyone. Just pass an argument to\n@@ -185,8 +188,8 @@ Next up is this line:\n This line does all of the work in our little program. There are a number of\n details that are important here. The first is that it's indented with four\n spaces, not tabs. Please configure your editor of choice to insert four spaces\n-with the tab key. We provide some sample configurations for various editors\n-[here](https://github.com/rust-lang/rust/tree/master/src/etc).\n+with the tab key. We provide some [sample configurations for various\n+editors](https://github.com/rust-lang/rust/tree/master/src/etc).\n \n The second point is the `println!()` part. This is calling a Rust **macro**,\n which is how metaprogramming is done in Rust. If it were a function instead, it\n@@ -392,14 +395,10 @@ By the way, in these examples, `i` indicates that the number is an integer.\n \n Rust is a statically typed language, which means that we specify our types up\n front. So why does our first example compile? Well, Rust has this thing called\n-\"[Hindley-Milner type\n-inference](http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system)\",\n-named after some really smart type theorists. If you clicked that link, don't\n-be scared: what this means for you is that Rust will attempt to infer the types\n-in your program, and it's pretty good at it. If it can infer the type, Rust\n+\"type inference.\" If it can figure out what the type of something is, Rust\n doesn't require you to actually type it out.\n \n-We can add the type if we want to. Types come after a colon (`:`):\n+We can add the type if we want to, though. Types come after a colon (`:`):\n \n ```{rust}\n let x: int = 5;\n@@ -1281,15 +1280,15 @@ two main looping constructs: `for` and `while`.\n \n The `for` loop is used to loop a particular number of times. Rust's `for` loops\n work a bit differently than in other systems languages, however. Rust's `for`\n-loop doesn't look like this C `for` loop:\n+loop doesn't look like this \"C style\" `for` loop:\n \n-```{ignore,c}\n+```{c}\n for (x = 0; x < 10; x++) {\n     printf( \"%d\\n\", x );\n }\n ```\n \n-It looks like this:\n+Instead, it looks like this:\n \n ```{rust}\n for x in range(0i, 10i) {\n@@ -1312,10 +1311,9 @@ valid for the loop body. Once the body is over, the next value is fetched from\n the iterator, and we loop another time. When there are no more values, the\n `for` loop is over.\n \n-In our example, the `range` function is a function, provided by Rust, that\n-takes a start and an end position, and gives an iterator over those values. The\n-upper bound is exclusive, though, so our loop will print `0` through `9`, not\n-`10`.\n+In our example, `range` is a function that takes a start and an end position,\n+and gives an iterator over those values. The upper bound is exclusive, though,\n+so our loop will print `0` through `9`, not `10`.\n \n Rust does not have the \"C style\" `for` loop on purpose. Manually controlling\n each element of the loop is complicated and error prone, even for experienced C"}, {"sha": "f237bc2ddbc6b21e4fd2b474e7231dc3e65881ec", "filename": "src/doc/index.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -86,10 +86,10 @@ There are questions that are asked quite often, and so we've made FAQs for them:\n \n # The standard library\n \n-You can find function-level documentation for the entire standard library\n-[here](std/index.html). There's a list of crates on the left with more specific\n-sections, or you can use the search bar at the top to search for something if\n-you know its name.\n+We have [API documentation for the entire standard\n+library](std/index.html). There's a list of crates on the left with more\n+specific sections, or you can use the search bar at the top to search for\n+something if you know its name.\n \n # External documentation\n "}, {"sha": "2b80c0ff39f5a43b6c24415689f436b56c5964cb", "filename": "src/etc/kate/rust.xml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Fetc%2Fkate%2Frust.xml", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Fetc%2Fkate%2Frust.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fkate%2Frust.xml?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -7,7 +7,7 @@\n \t<!ENTITY rustIdent \"[a-zA-Z_][a-zA-Z_0-9]*\">\n \t<!ENTITY rustIntSuf \"([iu](8|16|32|64)?)?\">\n ]>\n-<language name=\"Rust\" version=\"0.12.0-pre\" kateversion=\"2.4\" section=\"Sources\" extensions=\"*.rs\" mimetype=\"text/x-rust\" priority=\"15\">\n+<language name=\"Rust\" version=\"0.12.0\" kateversion=\"2.4\" section=\"Sources\" extensions=\"*.rs\" mimetype=\"text/x-rust\" priority=\"15\">\n <highlighting>\n \t<list name=\"fn\">\n \t\t<item> fn </item>"}, {"sha": "d1b115fc9138fd33578abb7537fa35375bacf00c", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -49,7 +49,6 @@\n     \"test/bench/shootout-mandelbrot.rs\", # BSD\n     \"test/bench/shootout-meteor.rs\", # BSD\n     \"test/bench/shootout-nbody.rs\", # BSD\n-    \"test/bench/shootout-pidigits.rs\", # BSD\n     \"test/bench/shootout-regex-dna.rs\", # BSD\n     \"test/bench/shootout-reverse-complement.rs\", # BSD\n     \"test/bench/shootout-threadring.rs\", # BSD"}, {"sha": "349ae15eb32a0c58c0a59b50a95596ec807d9938", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -10,9 +10,6 @@\n \n // FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias`\n \n-#[cfg(stage0, not(test))] use core::raw;\n-#[cfg(stage0, not(test))] use util;\n-\n /// Returns a pointer to `size` bytes of memory.\n ///\n /// Behavior is undefined if the requested size is 0 or the alignment is not a\n@@ -111,21 +108,6 @@ unsafe fn exchange_free(ptr: *mut u8, size: uint, align: uint) {\n     deallocate(ptr, size, align);\n }\n \n-#[cfg(stage0, not(test))]\n-#[lang=\"closure_exchange_malloc\"]\n-#[inline]\n-#[allow(deprecated)]\n-unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint,\n-                                  align: uint) -> *mut u8 {\n-    let total_size = util::get_box_size(size, align);\n-    let p = allocate(total_size, 8);\n-\n-    let alloc = p as *mut raw::Box<()>;\n-    (*alloc).drop_glue = drop_glue;\n-\n-    alloc as *mut u8\n-}\n-\n // The minimum alignment guaranteed by the architecture. This value is used to\n // add fast paths for low alignment values. In practice, the alignment is a\n // constant at the call site and the branch will be optimized out.\n@@ -155,9 +137,6 @@ mod imp {\n                       flags: c_int) -> *mut c_void;\n         fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t,\n                       flags: c_int) -> size_t;\n-        #[cfg(stage0)]\n-        fn je_dallocx(ptr: *mut c_void, flags: c_int);\n-        #[cfg(not(stage0))]\n         fn je_sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n         fn je_nallocx(size: size_t, flags: c_int) -> size_t;\n         fn je_malloc_stats_print(write_cb: Option<extern \"C\" fn(cbopaque: *mut c_void,\n@@ -209,14 +188,6 @@ mod imp {\n     }\n \n     #[inline]\n-    #[cfg(stage0)]\n-    pub unsafe fn deallocate(ptr: *mut u8, _size: uint, align: uint) {\n-        let flags = align_to_flags(align);\n-        je_dallocx(ptr as *mut c_void, flags)\n-    }\n-\n-    #[inline]\n-    #[cfg(not(stage0))]\n     pub unsafe fn deallocate(ptr: *mut u8, size: uint, align: uint) {\n         let flags = align_to_flags(align);\n         je_sdallocx(ptr as *mut c_void, size as size_t, flags)"}, {"sha": "1c88eb6ddfa17819195e9e796fe043be80b25857", "filename": "src/libcore/fmt/rt.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -14,13 +14,6 @@\n //! These definitions are similar to their `ct` equivalents, but differ in that\n //! these can be statically allocated and are slightly optimized for the runtime\n \n-#[cfg(stage0)]\n-#[doc(hidden)]\n-pub enum Piece<'a> {\n-    String(&'a str),\n-    Argument(Argument<'a>),\n-}\n-\n #[doc(hidden)]\n pub struct Argument<'a> {\n     pub position: Position,"}, {"sha": "7e399902a4b5ebd367959b982dfa62877ea4b50c", "filename": "src/libcore/str.rs", "status": "modified", "additions": 90, "deletions": 10, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -419,8 +419,76 @@ struct TwoWaySearcher {\n     memory: uint\n }\n \n-// This is the Two-Way search algorithm, which was introduced in the paper:\n-// Crochemore, M., Perrin, D., 1991, Two-way string-matching, Journal of the ACM 38(3):651-675.\n+/*\n+    This is the Two-Way search algorithm, which was introduced in the paper:\n+    Crochemore, M., Perrin, D., 1991, Two-way string-matching, Journal of the ACM 38(3):651-675.\n+\n+    Here's some background information.\n+\n+    A *word* is a string of symbols. The *length* of a word should be a familiar\n+    notion, and here we denote it for any word x by |x|.\n+    (We also allow for the possibility of the *empty word*, a word of length zero).\n+\n+    If x is any non-empty word, then an integer p with 0 < p <= |x| is said to be a\n+    *period* for x iff for all i with 0 <= i <= |x| - p - 1, we have x[i] == x[i+p].\n+    For example, both 1 and 2 are periods for the string \"aa\". As another example,\n+    the only period of the string \"abcd\" is 4.\n+\n+    We denote by period(x) the *smallest* period of x (provided that x is non-empty).\n+    This is always well-defined since every non-empty word x has at least one period,\n+    |x|. We sometimes call this *the period* of x.\n+\n+    If u, v and x are words such that x = uv, where uv is the concatenation of u and\n+    v, then we say that (u, v) is a *factorization* of x.\n+\n+    Let (u, v) be a factorization for a word x. Then if w is a non-empty word such\n+    that both of the following hold\n+\n+      - either w is a suffix of u or u is a suffix of w\n+      - either w is a prefix of v or v is a prefix of w\n+\n+    then w is said to be a *repetition* for the factorization (u, v).\n+\n+    Just to unpack this, there are four possibilities here. Let w = \"abc\". Then we\n+    might have:\n+\n+      - w is a suffix of u and w is a prefix of v. ex: (\"lolabc\", \"abcde\")\n+      - w is a suffix of u and v is a prefix of w. ex: (\"lolabc\", \"ab\")\n+      - u is a suffix of w and w is a prefix of v. ex: (\"bc\", \"abchi\")\n+      - u is a suffix of w and v is a prefix of w. ex: (\"bc\", \"a\")\n+\n+    Note that the word vu is a repetition for any factorization (u,v) of x = uv,\n+    so every factorization has at least one repetition.\n+\n+    If x is a string and (u, v) is a factorization for x, then a *local period* for\n+    (u, v) is an integer r such that there is some word w such that |w| = r and w is\n+    a repetition for (u, v).\n+\n+    We denote by local_period(u, v) the smallest local period of (u, v). We sometimes\n+    call this *the local period* of (u, v). Provided that x = uv is non-empty, this\n+    is well-defined (because each non-empty word has at least one factorization, as\n+    noted above).\n+\n+    It can be proven that the following is an equivalent definition of a local period\n+    for a factorization (u, v): any positive integer r such that x[i] == x[i+r] for\n+    all i such that |u| - r <= i <= |u| - 1 and such that both x[i] and x[i+r] are\n+    defined. (i.e. i > 0 and i + r < |x|).\n+\n+    Using the above reformulation, it is easy to prove that\n+\n+        1 <= local_period(u, v) <= period(uv)\n+\n+    A factorization (u, v) of x such that local_period(u,v) = period(x) is called a\n+    *critical factorization*.\n+\n+    The algorithm hinges on the following theorem, which is stated without proof:\n+\n+    **Critical Factorization Theorem** Any word x has at least one critical\n+    factorization (u, v) such that |u| < period(x).\n+\n+    The purpose of maximal_suffix is to find such a critical factorization.\n+\n+*/\n impl TwoWaySearcher {\n     fn new(needle: &[u8]) -> TwoWaySearcher {\n         let (crit_pos1, period1) = TwoWaySearcher::maximal_suffix(needle, false);\n@@ -436,15 +504,19 @@ impl TwoWaySearcher {\n             period = period2;\n         }\n \n+        // This isn't in the original algorithm, as far as I'm aware.\n         let byteset = needle.iter()\n                             .fold(0, |a, &b| (1 << ((b & 0x3f) as uint)) | a);\n \n-        // The logic here (calculating crit_pos and period, the final if statement to see which\n-        // period to use for the TwoWaySearcher) is essentially an implementation of the\n-        // \"small-period\" function from the paper (p. 670)\n+        // A particularly readable explanation of what's going on here can be found\n+        // in Crochemore and Rytter's book \"Text Algorithms\", ch 13. Specifically\n+        // see the code for \"Algorithm CP\" on p. 323.\n         //\n-        // In the paper they check whether `needle.slice_to(crit_pos)` is a suffix of\n-        // `needle.slice(crit_pos, crit_pos + period)`, which is precisely what this does\n+        // What's going on is we have some critical factorization (u, v) of the\n+        // needle, and we want to determine whether u is a suffix of\n+        // v.slice_to(period). If it is, we use \"Algorithm CP1\". Otherwise we use\n+        // \"Algorithm CP2\", which is optimized for when the period of the needle\n+        // is large.\n         if needle.slice_to(crit_pos) == needle.slice(period, period + crit_pos) {\n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n@@ -466,6 +538,11 @@ impl TwoWaySearcher {\n         }\n     }\n \n+    // One of the main ideas of Two-Way is that we factorize the needle into\n+    // two halves, (u, v), and begin trying to find v in the haystack by scanning\n+    // left to right. If v matches, we try to match u by scanning right to left.\n+    // How far we can jump when we encounter a mismatch is all based on the fact\n+    // that (u, v) is a critical factorization for the needle.\n     #[inline]\n     fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool) -> Option<(uint, uint)> {\n         'search: loop {\n@@ -479,6 +556,9 @@ impl TwoWaySearcher {\n                     ((haystack[self.position + needle.len() - 1] & 0x3f)\n                      as uint)) & 1 == 0 {\n                 self.position += needle.len();\n+                if !long_period {\n+                    self.memory = 0;\n+                }\n                 continue 'search;\n             }\n \n@@ -517,9 +597,9 @@ impl TwoWaySearcher {\n         }\n     }\n \n-    // returns (i, p) where i is the \"critical position\", the starting index of\n-    // of maximal suffix, and p is the period of the suffix\n-    // see p. 668 of the paper\n+    // Computes a critical factorization (u, v) of `arr`.\n+    // Specifically, returns (i, p), where i is the starting index of v in some\n+    // critical factorization (u, v) and p = period(v)\n     #[inline]\n     fn maximal_suffix(arr: &[u8], reversed: bool) -> (uint, uint) {\n         let mut left = -1; // Corresponds to i in the paper"}, {"sha": "51bd72ec0148a5ff72253133321bb5b8c5f40e6a", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -26,6 +26,12 @@ fn strslice_issue_16589() {\n     check_contains_all_substrings(\"012345678901234567890123456789bcdabcdabcd\");\n }\n \n+#[test]\n+fn strslice_issue_16878() {\n+    assert!(!\"1234567ah012345678901ah\".contains(\"hah\"));\n+    assert!(!\"00abc01234567890123456789abc\".contains(\"bcabc\"));\n+}\n+\n \n #[test]\n fn test_strslice_contains() {"}, {"sha": "3f91ce11915afc7ec50c47bf2c5e9de364462f7a", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -19,6 +19,7 @@\n //! ## Example\n //!\n //! ```rust\n+//! # #![allow(deprecated)]\n //! use num::bigint::BigUint;\n //! use std::num::{Zero, One};\n //! use std::mem::replace;\n@@ -42,6 +43,7 @@\n //! It's easy to generate large random numbers:\n //!\n //! ```rust\n+//! # #![allow(deprecated)]\n //! use num::bigint::{ToBigInt, RandBigInt};\n //! use std::rand;\n //!"}, {"sha": "17071d22deed82d555045324c4ee01e2c285c158", "filename": "src/libnum/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibnum%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibnum%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Flib.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -18,6 +18,7 @@\n //! approximate a square root to arbitrary precision:\n //!\n //! ```\n+//! # #![allow(deprecated)]\n //! extern crate num;\n //!\n //! use num::bigint::BigInt;\n@@ -46,7 +47,9 @@\n #![feature(default_type_params)]\n \n #![crate_name = \"num\"]\n-#![experimental]\n+#![deprecated = \"This is now a cargo package located at: \\\n+                 https://github.com/rust-lang/num\"]\n+#![allow(deprecated)]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![license = \"MIT/ASL2\"]"}, {"sha": "14cf07cd5e47f01c66b5b5d7a0bccf49d29d4171", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -109,11 +109,6 @@ register_diagnostics!(\n     E0092,\n     E0093,\n     E0094,\n-    E0095,\n-    E0096,\n-    E0097,\n-    E0098,\n-    E0099,\n     E0100,\n     E0101,\n     E0102,\n@@ -153,7 +148,6 @@ register_diagnostics!(\n     E0139,\n     E0140,\n     E0141,\n-    E0142,\n     E0143,\n     E0144,\n     E0145,\n@@ -169,6 +163,5 @@ register_diagnostics!(\n     E0157,\n     E0158,\n     E0159,\n-    E0160,\n     E0161\n )"}, {"sha": "836d355d55baaa57052c44ea1f34f1f59c61d45a", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -689,11 +689,7 @@ impl LintPass for UnusedResult {\n             ast::StmtSemi(ref expr, _) => &**expr,\n             _ => return\n         };\n-        let t = ty::expr_ty(cx.tcx, expr);\n-        match ty::get(t).sty {\n-            ty::ty_nil | ty::ty_bot | ty::ty_bool => return,\n-            _ => {}\n-        }\n+\n         match expr.node {\n             ast::ExprRet(..) => return,\n             _ => {}\n@@ -702,6 +698,7 @@ impl LintPass for UnusedResult {\n         let t = ty::expr_ty(cx.tcx, expr);\n         let mut warned = false;\n         match ty::get(t).sty {\n+            ty::ty_nil | ty::ty_bot | ty::ty_bool => return,\n             ty::ty_struct(did, _) |\n             ty::ty_enum(did, _) => {\n                 if ast_util::is_local(did) {\n@@ -1107,6 +1104,41 @@ impl LintPass for UnnecessaryParens {\n     }\n }\n \n+declare_lint!(UNNECESSARY_IMPORT_BRACES, Allow,\n+              \"unnecessary braces around an imported item\")\n+\n+pub struct UnnecessaryImportBraces;\n+\n+impl LintPass for UnnecessaryImportBraces {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNNECESSARY_IMPORT_BRACES)\n+    }\n+\n+    fn check_view_item(&mut self, cx: &Context, view_item: &ast::ViewItem) {\n+        match view_item.node {\n+            ast::ViewItemUse(ref view_path) => {\n+                match view_path.node {\n+                    ast::ViewPathList(_, ref items, _) => {\n+                        if items.len() == 1 {\n+                            match items[0].node {\n+                                ast::PathListIdent {ref name, ..} => {\n+                                    let m = format!(\"braces around {} is unnecessary\",\n+                                                    token::get_ident(*name).get());\n+                                    cx.span_lint(UNNECESSARY_IMPORT_BRACES, view_item.span,\n+                                                 m.as_slice());\n+                                },\n+                                _ => ()\n+                            }\n+                        }\n+                    }\n+                    _ => ()\n+                }\n+            },\n+            _ => ()\n+        }\n+    }\n+}\n+\n declare_lint!(UNUSED_UNSAFE, Warn,\n               \"unnecessary use of an `unsafe` block\")\n "}, {"sha": "e39685705dfe0624342726b164b4f9bb5cfd2576", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -183,6 +183,7 @@ impl LintStore {\n                      NonSnakeCase,\n                      NonUppercaseStatics,\n                      UnnecessaryParens,\n+                     UnnecessaryImportBraces,\n                      UnusedUnsafe,\n                      UnsafeBlock,\n                      UnusedMut,"}, {"sha": "748e59b75ed63edee5858d2859b4dbe474c6b54a", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -325,7 +325,7 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n             };\n             DlDef(def::DefStaticMethod(did, provenance, fn_style))\n         }\n-        Type | ForeignType => DlDef(def::DefTy(did)),\n+        Type | ForeignType => DlDef(def::DefTy(did, false)),\n         Mod => DlDef(def::DefMod(did)),\n         ForeignMod => DlDef(def::DefForeignMod(did)),\n         StructVariant => {\n@@ -337,7 +337,7 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n             DlDef(def::DefVariant(enum_did, did, false))\n         }\n         Trait => DlDef(def::DefTrait(did)),\n-        Enum => DlDef(def::DefTy(did)),\n+        Enum => DlDef(def::DefTy(did, true)),\n         Impl => DlImpl(did),\n         PublicField | InheritedField => DlField,\n     }"}, {"sha": "0e888b39b8516f5d3fd3a4f1a443058c4b142aab", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -680,14 +680,14 @@ fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n     let builtin_bounds = parse_builtin_bounds(st, |x,y| conv(x,y));\n \n     let mut param_bounds = ty::ParamBounds {\n-        opt_region_bound: None,\n+        region_bounds: Vec::new(),\n         builtin_bounds: builtin_bounds,\n         trait_bounds: Vec::new()\n     };\n     loop {\n         match next(st) {\n             'R' => {\n-                param_bounds.opt_region_bound = Some(parse_region(st, |x, y| conv (x, y)));\n+                param_bounds.region_bounds.push(parse_region(st, |x, y| conv (x, y)));\n             }\n             'I' => {\n                 param_bounds.trait_bounds.push(Rc::new(parse_trait_ref(st, |x,y| conv(x,y))));"}, {"sha": "3ef1d15cf5651eafa635a51b8659087f62f24d33", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -366,7 +366,7 @@ pub fn enc_existential_bounds(w: &mut SeekableMemWriter, cx: &ctxt, bs: &ty::Exi\n pub fn enc_bounds(w: &mut SeekableMemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n     enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n \n-    for &r in bs.opt_region_bound.iter() {\n+    for &r in bs.region_bounds.iter() {\n         mywrite!(w, \"R\");\n         enc_region(w, cx, r);\n     }"}, {"sha": "880445ff38d324fffd2f1abcb2cb8efa5a90d2f4", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -454,7 +454,7 @@ impl tr for def::Def {\n             def::DefVariant(e_did.tr(dcx), v_did.tr(dcx), is_s)\n           },\n           def::DefTrait(did) => def::DefTrait(did.tr(dcx)),\n-          def::DefTy(did) => def::DefTy(did.tr(dcx)),\n+          def::DefTy(did, is_enum) => def::DefTy(did.tr(dcx), is_enum),\n           def::DefPrimTy(p) => def::DefPrimTy(p),\n           def::DefTyParam(s, did, v) => def::DefTyParam(s, did.tr(dcx), v),\n           def::DefBinding(nid, bm) => def::DefBinding(dcx.tr_id(nid), bm),"}, {"sha": "70a9b6c533772988d18108473b5bf5d8d1c222fd", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -25,7 +25,7 @@ pub enum Def {\n     DefArg(ast::NodeId, ast::BindingMode),\n     DefLocal(ast::NodeId, ast::BindingMode),\n     DefVariant(ast::DefId /* enum */, ast::DefId /* variant */, bool /* is_structure */),\n-    DefTy(ast::DefId),\n+    DefTy(ast::DefId, bool /* is_enum */),\n     DefTrait(ast::DefId),\n     DefPrimTy(ast::PrimTy),\n     DefTyParam(ParamSpace, ast::DefId, uint),\n@@ -62,7 +62,7 @@ impl Def {\n         match *self {\n             DefFn(id, _) | DefStaticMethod(id, _, _) | DefMod(id) |\n             DefForeignMod(id) | DefStatic(id, _) |\n-            DefVariant(_, id, _) | DefTy(id) | DefTyParam(_, id, _) |\n+            DefVariant(_, id, _) | DefTy(id, _) | DefTyParam(_, id, _) |\n             DefUse(id) | DefStruct(id) | DefTrait(id) | DefMethod(id, _) => {\n                 id\n             }"}, {"sha": "fee6c77a79907a387a3bd9d6fde59f2c2a39696a", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -131,8 +131,8 @@ enum LoopKind<'a> {\n     LoopLoop,\n     /// A `while` loop, with the given expression as condition.\n     WhileLoop(&'a Expr),\n-    /// A `for` loop.\n-    ForLoop,\n+    /// A `for` loop, with the given pattern to bind.\n+    ForLoop(&'a Pat),\n }\n \n #[deriving(PartialEq)]\n@@ -1024,8 +1024,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_loop(expr, WhileLoop(&**cond), &**blk, succ)\n           }\n \n-          ExprForLoop(_, ref head, ref blk, _) => {\n-            let ln = self.propagate_through_loop(expr, ForLoop, &**blk, succ);\n+          ExprForLoop(ref pat, ref head, ref blk, _) => {\n+            let ln = self.propagate_through_loop(expr, ForLoop(&**pat), &**blk, succ);\n             self.propagate_through_expr(&**head, ln)\n           }\n \n@@ -1355,7 +1355,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                expr.id, block_to_string(body));\n \n         let cond_ln = match kind {\n-            LoopLoop | ForLoop => ln,\n+            LoopLoop => ln,\n+            ForLoop(ref pat) => self.define_bindings_in_pat(*pat, ln),\n             WhileLoop(ref cond) => self.propagate_through_expr(&**cond, ln),\n         };\n         let body_ln = self.with_loop_nodes(expr.id, succ, ln, |this| {\n@@ -1367,7 +1368,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             first_merge = false;\n \n             let new_cond_ln = match kind {\n-                LoopLoop | ForLoop => ln,\n+                LoopLoop => ln,\n+                ForLoop(ref pat) => {\n+                    self.define_bindings_in_pat(*pat, ln)\n+                }\n                 WhileLoop(ref cond) => {\n                     self.propagate_through_expr(&**cond, ln)\n                 }\n@@ -1453,6 +1457,12 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n         visit::walk_expr(this, expr);\n       }\n \n+      ExprForLoop(ref pat, _, _, _) => {\n+        this.pat_bindings(&**pat, |this, ln, var, sp, id| {\n+            this.warn_about_unused(sp, id, ln, var);\n+        });\n+      }\n+\n       // no correctness conditions related to liveness\n       ExprCall(..) | ExprMethodCall(..) | ExprIf(..) | ExprMatch(..) |\n       ExprWhile(..) | ExprLoop(..) | ExprIndex(..) | ExprField(..) |\n@@ -1461,7 +1471,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ExprAgain(..) | ExprLit(_) | ExprBlock(..) |\n       ExprMac(..) | ExprAddrOf(..) | ExprStruct(..) | ExprRepeat(..) |\n       ExprParen(..) | ExprFnBlock(..) | ExprProc(..) | ExprUnboxedFn(..) |\n-      ExprPath(..) | ExprBox(..) | ExprForLoop(..) => {\n+      ExprPath(..) | ExprBox(..) => {\n         visit::walk_expr(this, expr);\n       }\n     }"}, {"sha": "4f9cc9c080f9bcab89cd1ba09a8cca16a6e49baf", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -531,7 +531,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n-          def::DefTrait(_) | def::DefTy(_) | def::DefPrimTy(_) |\n+          def::DefTrait(_) | def::DefTy(..) | def::DefPrimTy(_) |\n           def::DefTyParam(..) | def::DefTyParamBinder(..) | def::DefRegion(_) |\n           def::DefLabel(_) | def::DefSelfTy(..) | def::DefMethod(..) => {\n               Ok(Rc::new(cmt_ {"}, {"sha": "0eb684fe18e1061a5bbb472a210e9526b21fd508", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -771,7 +771,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             def::DefFn(..) => ck(\"function\"),\n             def::DefStatic(..) => ck(\"static\"),\n             def::DefVariant(..) => ck(\"variant\"),\n-            def::DefTy(..) => ck(\"type\"),\n+            def::DefTy(_, false) => ck(\"type\"),\n+            def::DefTy(_, true) => ck(\"enum\"),\n             def::DefTrait(..) => ck(\"trait\"),\n             def::DefStruct(..) => ck(\"struct\"),\n             def::DefMethod(_, Some(..)) => ck(\"trait method\"),"}, {"sha": "861ac2ffe60d7b60422dce2c916ba299bd753b58", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -1252,7 +1252,7 @@ impl<'a> Resolver<'a> {\n                                    sp);\n \n                 name_bindings.define_type\n-                    (DefTy(local_def(item.id)), sp, is_public);\n+                    (DefTy(local_def(item.id), false), sp, is_public);\n                 parent\n             }\n \n@@ -1264,7 +1264,7 @@ impl<'a> Resolver<'a> {\n                                    sp);\n \n                 name_bindings.define_type\n-                    (DefTy(local_def(item.id)), sp, is_public);\n+                    (DefTy(local_def(item.id), true), sp, is_public);\n \n                 for variant in (*enum_definition).variants.iter() {\n                     self.build_reduced_graph_for_variant(\n@@ -1287,7 +1287,7 @@ impl<'a> Resolver<'a> {\n                 let name_bindings = self.add_child(ident, parent.clone(), forbid, sp);\n \n                 // Define a name in the type namespace.\n-                name_bindings.define_type(DefTy(local_def(item.id)), sp, is_public);\n+                name_bindings.define_type(DefTy(local_def(item.id), false), sp, is_public);\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n@@ -1732,7 +1732,7 @@ impl<'a> Resolver<'a> {\n \n         match def {\n           DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n-          DefTy(def_id) => {\n+          DefTy(def_id, _) => {\n             let type_def = child_name_bindings.type_def.borrow().clone();\n             match type_def {\n               Some(TypeNsDef { module_def: Some(module_def), .. }) => {\n@@ -1823,7 +1823,7 @@ impl<'a> Resolver<'a> {\n                                                   is_public,\n                                                   DUMMY_SP)\n           }\n-          DefTy(_) => {\n+          DefTy(..) => {\n               debug!(\"(building reduced graph for external \\\n                       crate) building type {}\", final_ident);\n \n@@ -4320,7 +4320,7 @@ impl<'a> Resolver<'a> {\n \n                         // If it's a typedef, give a note\n                         match def {\n-                            DefTy(_) => {\n+                            DefTy(..) => {\n                                 self.session.span_note(\n                                                 trait_reference.path.span,\n                                                 format!(\"`type` aliases cannot \\\n@@ -4381,7 +4381,7 @@ impl<'a> Resolver<'a> {\n                 Some(ref t) => match t.node {\n                     TyPath(ref path, None, path_id) => {\n                         match this.resolve_path(id, path, TypeNS, true) {\n-                            Some((DefTy(def_id), lp)) if this.structs.contains_key(&def_id) => {\n+                            Some((DefTy(def_id, _), lp)) if this.structs.contains_key(&def_id) => {\n                                 let def = DefStruct(def_id);\n                                 debug!(\"(resolving struct) resolved `{}` to type {:?}\",\n                                        token::get_ident(path.segments\n@@ -5440,7 +5440,7 @@ impl<'a> Resolver<'a> {\n         if allowed == Everything {\n             // Look for a field with the same name in the current self_type.\n             match self.def_map.borrow().find(&node_id) {\n-                 Some(&DefTy(did))\n+                 Some(&DefTy(did, _))\n                 | Some(&DefStruct(did))\n                 | Some(&DefVariant(_, did, _)) => match self.structs.find(&did) {\n                     None => {}\n@@ -5582,7 +5582,7 @@ impl<'a> Resolver<'a> {\n                         // structs, which wouldn't result in this error.)\n                         match self.with_no_errors(|this|\n                             this.resolve_path(expr.id, path, TypeNS, false)) {\n-                            Some((DefTy(struct_id), _))\n+                            Some((DefTy(struct_id, _), _))\n                               if self.structs.contains_key(&struct_id) => {\n                                 self.resolve_error(expr.span,\n                                         format!(\"`{}` is a structure name, but \\"}, {"sha": "37ba3b75f8917ad024b7f5a6332ec8e35b34ec96", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -226,7 +226,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefMod(_) |\n             def::DefForeignMod(_) => Some(recorder::ModRef),\n             def::DefStruct(_) => Some(recorder::StructRef),\n-            def::DefTy(_) |\n+            def::DefTy(..) |\n             def::DefTrait(_) => Some(recorder::TypeRef),\n             def::DefStatic(_, _) |\n             def::DefBinding(_, _) |"}, {"sha": "1eae4ac193270f4c7870756bb87cd8b2a4a1d824", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -250,9 +250,7 @@ pub fn search_trait_and_supertraits_from_bound(tcx: &ty::ctxt,\n      * is the path to that trait/supertrait. Else `None`.\n      */\n \n-    for (bound_index, bound) in\n-        transitive_bounds(tcx, &[caller_bound]).enumerate()\n-    {\n+    for bound in transitive_bounds(tcx, &[caller_bound]) {\n         if test(bound.def_id) {\n             let vtable_param = VtableParam { bound: bound };\n             return Some(vtable_param);"}, {"sha": "51023d03c23b03c39b23d0cb6dd64b6c9c916f9f", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -557,7 +557,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n \n     let mut found: Vec<Opt> = vec![];\n-    for (i, br) in m.iter().enumerate() {\n+    for br in m.iter() {\n         let cur = *br.pats.get(col);\n         let opt = match cur.node {\n             ast::PatLit(ref l) => ConstantValue(ConstantExpr(&**l)),"}, {"sha": "77712570185d975df53e79ad2619010b8f803b08", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -1380,7 +1380,11 @@ pub fn trans_adt<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         assert_eq!(discr, 0);\n \n         match ty::expr_kind(bcx.tcx(), &*base.expr) {\n-            ty::LvalueExpr => {\n+            ty::RvalueDpsExpr | ty::RvalueDatumExpr if !ty::type_needs_drop(bcx.tcx(), ty) => {\n+                bcx = trans_into(bcx, &*base.expr, SaveIn(addr));\n+            },\n+            ty::RvalueStmtExpr => bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\"),\n+            _ => {\n                 let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n                 for &(i, t) in base.fields.iter() {\n                     let datum = base_datum.get_element(\n@@ -1389,11 +1393,7 @@ pub fn trans_adt<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n                     bcx = datum.store_to(bcx, dest);\n                 }\n-            },\n-            ty::RvalueDpsExpr | ty::RvalueDatumExpr => {\n-                bcx = trans_into(bcx, &*base.expr, SaveIn(addr));\n-            },\n-            ty::RvalueStmtExpr => bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\")\n+            }\n         }\n     }\n "}, {"sha": "09912b5458352d1741a802536f2ab7fc5468ed84", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -1008,15 +1008,16 @@ pub enum type_err {\n /// as well as the existential type parameter in an object type.\n #[deriving(PartialEq, Eq, Hash, Clone, Show)]\n pub struct ParamBounds {\n-    pub opt_region_bound: Option<ty::Region>,\n+    pub region_bounds: Vec<ty::Region>,\n     pub builtin_bounds: BuiltinBounds,\n     pub trait_bounds: Vec<Rc<TraitRef>>\n }\n \n /// Bounds suitable for an existentially quantified type parameter\n /// such as those that appear in object types or closure types. The\n /// major difference between this case and `ParamBounds` is that\n-/// general purpose trait bounds are omitted.\n+/// general purpose trait bounds are omitted and there must be\n+/// *exactly one* region.\n #[deriving(PartialEq, Eq, Hash, Clone, Show)]\n pub struct ExistentialBounds {\n     pub region_bound: ty::Region,\n@@ -3789,7 +3790,8 @@ pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n         ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n         ty_box(_) => \"Gc-ptr\".to_string(),\n         ty_uniq(_) => \"box\".to_string(),\n-        ty_vec(_, _) => \"vector\".to_string(),\n+        ty_vec(_, Some(_)) => \"array\".to_string(),\n+        ty_vec(_, None) => \"unsized array\".to_string(),\n         ty_ptr(_) => \"*-ptr\".to_string(),\n         ty_rptr(_, _) => \"&-ptr\".to_string(),\n         ty_bare_fn(_) => \"extern fn\".to_string(),\n@@ -4864,7 +4866,7 @@ pub fn required_region_bounds(tcx: &ctxt,\n         trait_bounds,\n         |trait_ref| {\n             let bounds = ty::bounds_for_trait_ref(tcx, &*trait_ref);\n-            push_region_bounds(bounds.opt_region_bound.as_slice(),\n+            push_region_bounds(bounds.region_bounds.as_slice(),\n                                bounds.builtin_bounds,\n                                &mut all_bounds);\n             debug!(\"from {}: bounds={} all_bounds={}\","}, {"sha": "48fa6f823b0e5c8fe232f08328dc494a87ad7037", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -287,7 +287,7 @@ impl TypeFoldable for ty::ExistentialBounds {\n impl TypeFoldable for ty::ParamBounds {\n     fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ParamBounds {\n         ty::ParamBounds {\n-            opt_region_bound: self.opt_region_bound.fold_with(folder),\n+            region_bounds: self.region_bounds.fold_with(folder),\n             builtin_bounds: self.builtin_bounds.fold_with(folder),\n             trait_bounds: self.trait_bounds.fold_with(folder),\n         }"}, {"sha": "00678eb6380cae7b4821775e62c99cd584ecb44c", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -438,7 +438,7 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             // FIXME(#12938): This is a hack until we have full support for\n             // DST.\n             match a_def {\n-                def::DefTy(did) | def::DefStruct(did)\n+                def::DefTy(did, _) | def::DefStruct(did)\n                         if Some(did) == this.tcx().lang_items.owned_box() => {\n                     if path.segments\n                            .iter()\n@@ -462,7 +462,7 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                               \"not enough type parameters supplied to `Box<T>`\");\n                     Some(ty::mk_err())\n                 }\n-                def::DefTy(did) | def::DefStruct(did)\n+                def::DefTy(did, _) | def::DefStruct(did)\n                         if Some(did) == this.tcx().lang_items.gc() => {\n                     if path.segments\n                            .iter()\n@@ -833,7 +833,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                      result.substs.clone(),\n                                      bounds)\n                     }\n-                    def::DefTy(did) | def::DefStruct(did) => {\n+                    def::DefTy(did, _) | def::DefStruct(did) => {\n                         ast_path_to_ty(this, rscope, did, path).ty\n                     }\n                     def::DefTyParam(space, id, n) => {"}, {"sha": "2f5b6e1fa03ba6e31aee938be56601c1e3d45071", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -2005,7 +2005,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let region_bounds =\n             ty::required_region_bounds(\n                 self.tcx(),\n-                param_bound.opt_region_bound.as_slice(),\n+                param_bound.region_bounds.as_slice(),\n                 param_bound.builtin_bounds,\n                 param_bound.trait_bounds.as_slice());\n         for &r in region_bounds.iter() {\n@@ -4937,7 +4937,7 @@ pub fn polytype_for_def(fcx: &FnCtxt,\n         return polytype_for_def(fcx, sp, *inner);\n       }\n       def::DefTrait(_) |\n-      def::DefTy(_) |\n+      def::DefTy(..) |\n       def::DefPrimTy(_) |\n       def::DefTyParam(..)=> {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found type\");"}, {"sha": "a8f2a8f6f1dbbe3357c98fd9702fdc2aaa953606", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -1880,7 +1880,7 @@ fn param_must_outlive(rcx: &Rcx,\n     let param_bound = param_env.bounds.get(param_ty.space, param_ty.idx);\n     param_bounds =\n         ty::required_region_bounds(rcx.tcx(),\n-                                   param_bound.opt_region_bound.as_slice(),\n+                                   param_bound.region_bounds.as_slice(),\n                                    param_bound.builtin_bounds,\n                                    param_bound.trait_bounds.as_slice());\n "}, {"sha": "8bcbe4b7929852d2dfa85145679e559552c68e48", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -327,7 +327,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n                 // Inspect bounds on this type parameter for any\n                 // region bounds.\n-                for &r in type_param_def.bounds.opt_region_bound.iter() {\n+                for &r in type_param_def.bounds.region_bounds.iter() {\n                     self.stack.push((r, Some(ty)));\n                     self.accumulate_from_ty(type_param_ty);\n                     self.stack.pop().unwrap();"}, {"sha": "dedb860967c341abdf34dfada4a1343056570923", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -1044,7 +1044,7 @@ fn ty_generics_for_trait(ccx: &CrateCtxt,\n         ident: special_idents::type_self,\n         def_id: local_def(param_id),\n         bounds: ty::ParamBounds {\n-            opt_region_bound: None,\n+            region_bounds: vec!(),\n             builtin_bounds: ty::empty_builtin_bounds(),\n             trait_bounds: vec!(self_trait_ref),\n         },\n@@ -1280,12 +1280,12 @@ fn conv_param_bounds(ccx: &CrateCtxt,\n         .map(|b| instantiate_trait_ref(ccx, b, param_ty.to_ty(ccx.tcx)))\n         .chain(unboxed_fn_ty_bounds)\n         .collect();\n-    let opt_region_bound =\n-        astconv::compute_opt_region_bound(\n-            ccx.tcx, span, builtin_bounds, region_bounds.as_slice(),\n-            trait_bounds.as_slice());\n+    let region_bounds: Vec<ty::Region> =\n+        region_bounds.move_iter()\n+        .map(|r| ast_region_to_region(ccx.tcx, r))\n+        .collect();\n     ty::ParamBounds {\n-        opt_region_bound: opt_region_bound,\n+        region_bounds: region_bounds,\n         builtin_bounds: builtin_bounds,\n         trait_bounds: trait_bounds,\n     }"}, {"sha": "af670f25e5626cac3a89387896b8a9f59250a29a", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -1235,7 +1235,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         Some(&d) => d\n                     };\n                     match a_def {\n-                        def::DefTy(did) | def::DefStruct(did) => {\n+                        def::DefTy(did, _) | def::DefStruct(did) => {\n                             let generics = ty::lookup_item_type(self.tcx, did).generics;\n \n                             let expected ="}, {"sha": "ccb01ca620eb77d5291dd77d90154ff178f05e5a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -87,7 +87,12 @@ fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n             ret.extend(build_impls(cx, tcx, did).into_iter());\n             clean::StructItem(build_struct(cx, tcx, did))\n         }\n-        def::DefTy(did) => {\n+        def::DefTy(did, false) => {\n+            record_extern_fqn(cx, did, clean::TypeTypedef);\n+            ret.extend(build_impls(cx, tcx, did).into_iter());\n+            build_type(cx, tcx, did)\n+        }\n+        def::DefTy(did, true) => {\n             record_extern_fqn(cx, did, clean::TypeEnum);\n             ret.extend(build_impls(cx, tcx, did).into_iter());\n             build_type(cx, tcx, did)"}, {"sha": "c03c56cd22312c8f2c2912e578c2bd4cefbdb53e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -1094,6 +1094,7 @@ pub enum TypeKind {\n     TypeStruct,\n     TypeTrait,\n     TypeVariant,\n+    TypeTypedef,\n }\n \n impl Primitive {\n@@ -2049,7 +2050,8 @@ fn resolve_type(cx: &DocContext, path: Path,\n fn register_def(cx: &DocContext, def: def::Def) -> ast::DefId {\n     let (did, kind) = match def {\n         def::DefFn(i, _) => (i, TypeFunction),\n-        def::DefTy(i) => (i, TypeEnum),\n+        def::DefTy(i, false) => (i, TypeTypedef),\n+        def::DefTy(i, true) => (i, TypeEnum),\n         def::DefTrait(i) => (i, TypeTrait),\n         def::DefStruct(i) => (i, TypeStruct),\n         def::DefMod(i) => (i, TypeModule),"}, {"sha": "6e240b0d8d4a6a2e17c4589a3d9c3d7a3bed0e27", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -45,7 +45,7 @@ impl ItemType {\n         match *self {\n             Module          => \"mod\",\n             Struct          => \"struct\",\n-            Enum            => \"type\",\n+            Enum            => \"enum\",\n             Function        => \"fn\",\n             Typedef         => \"type\",\n             Static          => \"static\","}, {"sha": "a0c4283711e689ce04568bc18b23d6fcda462dde", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -308,6 +308,7 @@ pub fn run(mut krate: clean::Crate, external_html: &ExternalHtml, dst: Path) ->\n                 clean::TypeModule => item_type::Module,\n                 clean::TypeStatic => item_type::Static,\n                 clean::TypeVariant => item_type::Variant,\n+                clean::TypeTypedef => item_type::Typedef,\n             }))\n         }).collect()\n     }).unwrap_or(HashMap::new());"}, {"sha": "7eec634405b723a55b6dc50e440464529b1353df", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -229,6 +229,8 @@ nav.sub {\n .content .highlighted.enum { background-color: #b4d1b9; }\n .content .highlighted.struct { background-color: #e7b1a0; }\n .content .highlighted.fn { background-color: #c6afb3; }\n+.content .highlighted.method { background-color: #c6afb3; }\n+.content .highlighted.ffi { background-color: #c6afb3; }\n \n .docblock.short.nowrap {\n     display: block;\n@@ -336,11 +338,13 @@ a {\n p a { color: #4e8bca; }\n p a:hover { text-decoration: underline; }\n \n-.content span.trait, .block a.current.trait { color: #ed9603; }\n-.content span.mod, .block a.current.mod { color: #4d76ae; }\n-.content span.enum, .block a.current.enum { color: #5e9766; }\n-.content span.struct, .block a.current.struct { color: #e53700; }\n-.content span.fn, .block a.current.fn { color: #8c6067; }\n+.content span.trait, .content a.trait, .block a.current.trait { color: #ed9603; }\n+.content span.mod, .content a.mod, block a.current.mod { color: #4d76ae; }\n+.content span.enum, .content a.enum, .block a.current.enum { color: #5e9766; }\n+.content span.struct, .content a.struct, .block a.current.struct { color: #e53700; }\n+.content span.fn, .content a.fn, .block a.current.fn { color: #8c6067; }\n+.content span.method, .content a.method, .block a.current.method { color: #8c6067; }\n+.content span.ffi, .content a.ffi, .block a.current.ffi { color: #8c6067; }\n .content .fnname { color: #8c6067; }\n \n .search-input {"}, {"sha": "6992a9665929586b553d9d851ef7af72a01f0155", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -555,7 +555,7 @@\n         // `rustdoc::html::item_type::ItemType` type in Rust.\n         var itemTypes = [\"mod\",\n                          \"struct\",\n-                         \"type\",\n+                         \"enum\",\n                          \"fn\",\n                          \"type\",\n                          \"static\","}, {"sha": "833c5cd0f98c9699ae24e9be3495fb4a752ab804", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -234,6 +234,7 @@ pub enum ErrorCode {\n     KeyMustBeAString,\n     ExpectedColon,\n     TrailingCharacters,\n+    TrailingComma,\n     InvalidEscape,\n     InvalidUnicodeCodePoint,\n     LoneLeadingSurrogateInHexEscape,\n@@ -274,6 +275,7 @@ pub fn error_str(error: ErrorCode) -> &'static str {\n         KeyMustBeAString => \"key must be a string\",\n         ExpectedColon => \"expected `:`\",\n         TrailingCharacters => \"trailing characters\",\n+        TrailingComma => \"trailing comma\",\n         InvalidEscape => \"invalid escape\",\n         UnrecognizedHex => \"invalid \\\\u escape (unrecognized hex)\",\n         NotFourDigit => \"invalid \\\\u escape (not four digits)\",\n@@ -1681,7 +1683,11 @@ impl<T: Iterator<char>> Parser<T> {\n     fn parse_object(&mut self, first: bool) -> JsonEvent {\n         if self.ch_is('}') {\n             if !first {\n-                self.stack.pop();\n+                if self.stack.is_empty() {\n+                    return self.error_event(TrailingComma);\n+                } else {\n+                    self.stack.pop();\n+                }\n             }\n             if self.stack.is_empty() {\n                 self.state = ParseBeforeFinish;\n@@ -2377,7 +2383,7 @@ mod tests {\n                 F64Value, StringValue, NullValue, SyntaxError, Key, Index, Stack,\n                 InvalidSyntax, InvalidNumber, EOFWhileParsingObject, EOFWhileParsingList,\n                 EOFWhileParsingValue, EOFWhileParsingString, KeyMustBeAString, ExpectedColon,\n-                TrailingCharacters};\n+                TrailingCharacters, TrailingComma};\n     use std::{i64, u64, f32, f64, io};\n     use std::collections::TreeMap;\n \n@@ -3379,6 +3385,7 @@ mod tests {\n             }\n         }\n     }\n+\n     #[test]\n     #[ignore(cfg(target_word_size = \"32\"))] // FIXME(#14064)\n     fn test_read_object_streaming() {\n@@ -3393,6 +3400,7 @@ mod tests {\n         assert_eq!(last_event(\"{\\\"a\\\":1\"),   Error(SyntaxError(EOFWhileParsingObject, 1, 7)));\n         assert_eq!(last_event(\"{\\\"a\\\":1 1\"), Error(SyntaxError(InvalidSyntax,         1, 8)));\n         assert_eq!(last_event(\"{\\\"a\\\":1,\"),  Error(SyntaxError(EOFWhileParsingObject, 1, 8)));\n+        assert_eq!(last_event(\"{\\\"a\\\":1,}\"), Error(SyntaxError(TrailingComma, 1, 8)));\n \n         assert_stream_equal(\n             \"{}\","}, {"sha": "4bd998d5ed96db4c7bd302db95ab73305b2cb039", "filename": "src/libstd/io/net/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fmod.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -19,8 +19,7 @@ pub mod addrinfo;\n pub mod tcp;\n pub mod udp;\n pub mod ip;\n-// FIXME(#12093) - this should not be called unix\n-pub mod unix;\n+pub mod pipe;\n \n fn to_rtio(ip: IpAddr) -> rtio::IpAddr {\n     match ip {"}, {"sha": "bdd58b07d8615bcb6015dd7ed481834af0f03cb3", "filename": "src/libstd/io/net/pipe.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -46,7 +46,7 @@ impl UnixStream {\n     ///\n     /// ```rust\n     /// # #![allow(unused_must_use)]\n-    /// use std::io::net::unix::UnixStream;\n+    /// use std::io::net::pipe::UnixStream;\n     ///\n     /// let server = Path::new(\"path/to/my/socket\");\n     /// let mut stream = UnixStream::connect(&server);\n@@ -164,7 +164,7 @@ impl UnixListener {\n     /// # fn main() {}\n     /// # fn foo() {\n     /// # #![allow(unused_must_use)]\n-    /// use std::io::net::unix::UnixListener;\n+    /// use std::io::net::pipe::UnixListener;\n     /// use std::io::{Listener, Acceptor};\n     ///\n     /// let server = Path::new(\"/path/to/my/socket\");", "previous_filename": "src/libstd/io/net/unix.rs"}, {"sha": "cfc5fb982b86c0b8a6bed372f3626a730dac2491", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -34,7 +34,7 @@ macro_rules! iotest (\n             use io::net::ip::*;\n             use io::net::udp::*;\n             #[cfg(unix)]\n-            use io::net::unix::*;\n+            use io::net::pipe::*;\n             use io::timer::*;\n             use io::process::*;\n             use rt::running_on_valgrind;"}, {"sha": "e1f2f43673f1578782e87f3cb618ad54def29604", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -434,8 +434,8 @@ pub mod builtin {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let home: &'static str = env!(\"HOME\");\n-    /// println!(\"the home directory at the time of compiling was: {}\", home);\n+    /// let path: &'static str = env!(\"PATH\");\n+    /// println!(\"the $PATH variable at the time of compiling was: {}\", path);\n     /// ```\n     #[macro_export]\n     macro_rules! env( ($name:expr) => ({ /* compiler built-in */ }) )"}, {"sha": "ea392c87723286f57574543fa65361d31049ec8b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -88,14 +88,13 @@ use std::mem;\n use std::rc::Rc;\n use std::iter;\n \n-#[allow(non_camel_case_types)]\n-#[deriving(PartialEq)]\n-pub enum restriction {\n-    UNRESTRICTED,\n-    RESTRICT_STMT_EXPR,\n-    RESTRICT_NO_BAR_OP,\n-    RESTRICT_NO_BAR_OR_DOUBLEBAR_OP,\n-    RESTRICT_NO_STRUCT_LITERAL,\n+bitflags! {\n+    flags Restrictions: u8 {\n+        static Unrestricted               = 0b0000,\n+        static RestrictionStmtExpr        = 0b0001,\n+        static RestrictionNoBarOp         = 0b0010,\n+        static RestrictionNoStructLiteral = 0b0100\n+    }\n }\n \n type ItemInfo = (Ident, Item_, Option<Vec<Attribute> >);\n@@ -314,7 +313,7 @@ pub struct Parser<'a> {\n     pub buffer_start: int,\n     pub buffer_end: int,\n     pub tokens_consumed: uint,\n-    pub restriction: restriction,\n+    pub restrictions: Restrictions,\n     pub quote_depth: uint, // not (yet) related to the quasiquoter\n     pub reader: Box<Reader+'a>,\n     pub interner: Rc<token::IdentInterner>,\n@@ -383,7 +382,7 @@ impl<'a> Parser<'a> {\n             buffer_start: 0,\n             buffer_end: 0,\n             tokens_consumed: 0,\n-            restriction: UNRESTRICTED,\n+            restrictions: Unrestricted,\n             quote_depth: 0,\n             obsolete_set: HashSet::new(),\n             mod_path_stack: Vec::new(),\n@@ -2189,7 +2188,7 @@ impl<'a> Parser<'a> {\n                     if self.token == token::LBRACE {\n                         // This is a struct literal, unless we're prohibited\n                         // from parsing struct literals here.\n-                        if self.restriction != RESTRICT_NO_STRUCT_LITERAL {\n+                        if !self.restrictions.contains(RestrictionNoStructLiteral) {\n                             // It's a struct literal.\n                             self.bump();\n                             let mut fields = Vec::new();\n@@ -2651,12 +2650,9 @@ impl<'a> Parser<'a> {\n \n         // Prevent dynamic borrow errors later on by limiting the\n         // scope of the borrows.\n-        match (&self.token, &self.restriction) {\n-            (&token::BINOP(token::OR), &RESTRICT_NO_BAR_OP) => return lhs,\n-            (&token::BINOP(token::OR),\n-                &RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) => return lhs,\n-            (&token::OROR, &RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) => return lhs,\n-            _ => { }\n+        if self.token == token::BINOP(token::OR) &&\n+            self.restrictions.contains(RestrictionNoBarOp) {\n+            return lhs;\n         }\n \n         let cur_opt = token_to_binop(&self.token);\n@@ -2696,15 +2692,16 @@ impl<'a> Parser<'a> {\n     pub fn parse_assign_expr(&mut self) -> P<Expr> {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n+        let restrictions = self.restrictions & RestrictionNoStructLiteral;\n         match self.token {\n           token::EQ => {\n               self.bump();\n-              let rhs = self.parse_expr();\n+              let rhs = self.parse_expr_res(restrictions);\n               self.mk_expr(lo, rhs.span.hi, ExprAssign(lhs, rhs))\n           }\n           token::BINOPEQ(op) => {\n               self.bump();\n-              let rhs = self.parse_expr();\n+              let rhs = self.parse_expr_res(restrictions);\n               let aop = match op {\n                   token::PLUS =>    BiAdd,\n                   token::MINUS =>   BiSub,\n@@ -2730,7 +2727,7 @@ impl<'a> Parser<'a> {\n     /// Parse an 'if' expression ('if' token already eaten)\n     pub fn parse_if_expr(&mut self) -> P<Expr> {\n         let lo = self.last_span.lo;\n-        let cond = self.parse_expr_res(RESTRICT_NO_STRUCT_LITERAL);\n+        let cond = self.parse_expr_res(RestrictionNoStructLiteral);\n         let thn = self.parse_block();\n         let mut els: Option<P<Expr>> = None;\n         let mut hi = thn.span.hi;\n@@ -2791,7 +2788,7 @@ impl<'a> Parser<'a> {\n         let lo = self.last_span.lo;\n         let pat = self.parse_pat();\n         self.expect_keyword(keywords::In);\n-        let expr = self.parse_expr_res(RESTRICT_NO_STRUCT_LITERAL);\n+        let expr = self.parse_expr_res(RestrictionNoStructLiteral);\n         let loop_block = self.parse_block();\n         let hi = self.span.hi;\n \n@@ -2800,7 +2797,7 @@ impl<'a> Parser<'a> {\n \n     pub fn parse_while_expr(&mut self, opt_ident: Option<ast::Ident>) -> P<Expr> {\n         let lo = self.last_span.lo;\n-        let cond = self.parse_expr_res(RESTRICT_NO_STRUCT_LITERAL);\n+        let cond = self.parse_expr_res(RestrictionNoStructLiteral);\n         let body = self.parse_block();\n         let hi = body.span.hi;\n         return self.mk_expr(lo, hi, ExprWhile(cond, body, opt_ident));\n@@ -2815,7 +2812,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_match_expr(&mut self) -> P<Expr> {\n         let lo = self.last_span.lo;\n-        let discriminant = self.parse_expr_res(RESTRICT_NO_STRUCT_LITERAL);\n+        let discriminant = self.parse_expr_res(RestrictionNoStructLiteral);\n         self.commit_expr_expecting(&*discriminant, token::LBRACE);\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::RBRACE {\n@@ -2834,7 +2831,7 @@ impl<'a> Parser<'a> {\n             guard = Some(self.parse_expr());\n         }\n         self.expect(&token::FAT_ARROW);\n-        let expr = self.parse_expr_res(RESTRICT_STMT_EXPR);\n+        let expr = self.parse_expr_res(RestrictionStmtExpr);\n \n         let require_comma =\n             !classify::expr_is_simple_block(&*expr)\n@@ -2856,15 +2853,15 @@ impl<'a> Parser<'a> {\n \n     /// Parse an expression\n     pub fn parse_expr(&mut self) -> P<Expr> {\n-        return self.parse_expr_res(UNRESTRICTED);\n+        return self.parse_expr_res(Unrestricted);\n     }\n \n-    /// Parse an expression, subject to the given restriction\n-    pub fn parse_expr_res(&mut self, r: restriction) -> P<Expr> {\n-        let old = self.restriction;\n-        self.restriction = r;\n+    /// Parse an expression, subject to the given restrictions\n+    pub fn parse_expr_res(&mut self, r: Restrictions) -> P<Expr> {\n+        let old = self.restrictions;\n+        self.restrictions = r;\n         let e = self.parse_assign_expr();\n-        self.restriction = old;\n+        self.restrictions = old;\n         return e;\n     }\n \n@@ -3153,9 +3150,9 @@ impl<'a> Parser<'a> {\n                     self.look_ahead(2, |t| {\n                         *t != token::COMMA && *t != token::RBRACKET\n                     }) {\n-                let start = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n+                let start = self.parse_expr_res(RestrictionNoBarOp);\n                 self.eat(&token::DOTDOT);\n-                let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n+                let end = self.parse_expr_res(RestrictionNoBarOp);\n                 pat = PatRange(start, end);\n             } else if is_plain_ident(&self.token) && !can_be_enum_or_struct {\n                 let id = self.parse_ident();\n@@ -3441,7 +3438,7 @@ impl<'a> Parser<'a> {\n                     check_expected_item(self, found_attrs);\n \n                     // Remainder are line-expr stmts.\n-                    let e = self.parse_expr_res(RESTRICT_STMT_EXPR);\n+                    let e = self.parse_expr_res(RestrictionStmtExpr);\n                     P(spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID)))\n                 }\n             }\n@@ -3450,7 +3447,7 @@ impl<'a> Parser<'a> {\n \n     /// Is this expression a successfully-parsed statement?\n     fn expr_is_complete(&mut self, e: &Expr) -> bool {\n-        self.restriction == RESTRICT_STMT_EXPR &&\n+        self.restrictions.contains(RestrictionStmtExpr) &&\n             !classify::expr_requires_semi_to_be_stmt(e)\n     }\n "}, {"sha": "86fa0a51f9088822850ade9258d8b4f858005245", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -1,3 +1,12 @@\n+S 2014-09-16 828e075\n+  winnt-x86_64 ce1e9d7f6967bfa368853e7c968e1626cc319951\n+  winnt-i386 a8bd994666dfe683a5d7922c7998500255780724\n+  linux-x86_64 88ff474db96c6ffc5c1dc7a43442cbe1cd88c8a2\n+  linux-i386 7a731891f726c8a0590b142a4e8924c5e8b22e8d\n+  freebsd-x86_64 e67a56f76484f775cd4836dedb2d1069ab5d7921\n+  macos-i386 f48023648a77e89086f4a2b39d76b09e4fff032d\n+  macos-x86_64 2ad6457b2b3036f87eae7581d64ee5341a07fb06\n+\n S 2014-09-10 6faa4f3\n   winnt-x86_64 939eb546469cb936441cff3b6f2478f562f77c46\n   winnt-i386 cfe4f8b519bb9d62588f9310a8f94bc919d5423b"}, {"sha": "6951ed729b27bb162c50b6a83e106dad3db99c06", "filename": "src/test/auxiliary/static_priv_by_default.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fauxiliary%2Fstatic_priv_by_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fauxiliary%2Fstatic_priv_by_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic_priv_by_default.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -24,6 +24,7 @@ mod foo {\n     pub fn b() {}\n     pub struct c;\n     pub enum d {}\n+    pub type e = int;\n \n     pub struct A(());\n \n@@ -36,21 +37,25 @@ mod foo {\n     pub fn reexported_b() {}\n     pub struct reexported_c;\n     pub enum reexported_d {}\n+    pub type reexported_e = int;\n }\n \n pub mod bar {\n     pub use foo::reexported_a as e;\n     pub use foo::reexported_b as f;\n     pub use foo::reexported_c as g;\n     pub use foo::reexported_d as h;\n+    pub use foo::reexported_e as i;\n }\n \n pub static a: int = 0;\n pub fn b() {}\n pub struct c;\n pub enum d {}\n+pub type e = int;\n \n-static i: int = 0;\n-fn j() {}\n-struct k;\n-enum l {}\n+static j: int = 0;\n+fn k() {}\n+struct l;\n+enum m {}\n+type n = int;"}, {"sha": "d22633b341289dcb97efc49428e5046ad36311f2", "filename": "src/test/bench/shootout-pidigits.rs", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/4d2af38611cdeeb804659b5e0695ad2c251db51a/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d2af38611cdeeb804659b5e0695ad2c251db51a/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pidigits.rs?ref=4d2af38611cdeeb804659b5e0695ad2c251db51a", "patch": "@@ -1,128 +0,0 @@\n-// The Computer Language Benchmarks Game\n-// http://benchmarksgame.alioth.debian.org/\n-//\n-// contributed by the Rust Project Developers\n-\n-// Copyright (c) 2013-2014 The Rust Project Developers\n-//\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions\n-// are met:\n-//\n-// - Redistributions of source code must retain the above copyright\n-//   notice, this list of conditions and the following disclaimer.\n-//\n-// - Redistributions in binary form must reproduce the above copyright\n-//   notice, this list of conditions and the following disclaimer in\n-//   the documentation and/or other materials provided with the\n-//   distribution.\n-//\n-// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n-//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n-//   names of its contributors may be used to endorse or promote\n-//   products derived from this software without specific prior\n-//   written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n-// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n-// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n-// OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-extern crate num;\n-\n-use std::from_str::FromStr;\n-use std::num::One;\n-use std::num::Zero;\n-use std::num::FromPrimitive;\n-use num::Integer;\n-use num::bigint::BigInt;\n-\n-struct Context {\n-    numer: BigInt,\n-    accum: BigInt,\n-    denom: BigInt,\n-}\n-\n-impl Context {\n-    fn new() -> Context {\n-        Context {\n-            numer: One::one(),\n-            accum: Zero::zero(),\n-            denom: One::one(),\n-        }\n-    }\n-\n-    fn from_int(i: int) -> BigInt {\n-        FromPrimitive::from_int(i).unwrap()\n-    }\n-\n-    fn extract_digit(&self) -> int {\n-        if self.numer > self.accum {return -1;}\n-        let (q, r) =\n-            (self.numer * Context::from_int(3) + self.accum)\n-            .div_rem(&self.denom);\n-        if r + self.numer >= self.denom {return -1;}\n-        q.to_int().unwrap()\n-    }\n-\n-    fn next_term(&mut self, k: int) {\n-        let y2 = Context::from_int(k * 2 + 1);\n-        self.accum = (self.accum + (self.numer << 1)) * y2;\n-        self.numer = self.numer * Context::from_int(k);\n-        self.denom = self.denom * y2;\n-    }\n-\n-    fn eliminate_digit(&mut self, d: int) {\n-        let d = Context::from_int(d);\n-        let ten = Context::from_int(10);\n-        self.accum = (self.accum - self.denom * d) * ten;\n-        self.numer = self.numer * ten;\n-    }\n-}\n-\n-fn pidigits(n: int) {\n-    let mut k = 0;\n-    let mut context = Context::new();\n-\n-    for i in range(1, n + 1) {\n-        let mut d;\n-        loop {\n-            k += 1;\n-            context.next_term(k);\n-            d = context.extract_digit();\n-            if d != -1 {break;}\n-        }\n-\n-        print!(\"{}\", d);\n-        if i % 10 == 0 {print!(\"\\t:{}\\n\", i);}\n-\n-        context.eliminate_digit(d);\n-    }\n-\n-    let m = n % 10;\n-    if m != 0 {\n-        for _ in range(m, 10) { print!(\" \"); }\n-        print!(\"\\t:{}\\n\", n);\n-    }\n-}\n-\n-fn main() {\n-    let args = std::os::args();\n-    let args = args.as_slice();\n-    let n = if args.len() < 2 {\n-        512\n-    } else {\n-        FromStr::from_str(args[1].as_slice()).unwrap()\n-    };\n-    pidigits(n);\n-}"}, {"sha": "79d4ada41e8e8b267cb7fa65b51f6a2e5c5f9c6b", "filename": "src/test/compile-fail/array-not-vector.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fcompile-fail%2Farray-not-vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fcompile-fail%2Farray-not-vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray-not-vector.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let _x: int = [1i, 2, 3]; //~ ERROR expected int, found array\n+\n+    let x: &[int] = &[1, 2, 3];\n+    let _y: &int = x; //~ ERROR expected int, found unsized array\n+}"}, {"sha": "122c1f083951f1bcd31ab8446723e82cbc00f14b", "filename": "src/test/compile-fail/issue-17283.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fcompile-fail%2Fissue-17283.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fcompile-fail%2Fissue-17283.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17283.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the parser does not attempt to parse struct literals\n+// within assignments in if expressions.\n+\n+struct Foo {\n+    foo: uint\n+}\n+\n+fn main() {\n+    let x = 1u;\n+    let y: Foo;\n+\n+    // `x { ... }` should not be interpreted as a struct literal here\n+    if x = x {\n+        //~^ ERROR mismatched types: expected `bool`, found `()` (expected bool, found ())\n+        println!(\"{}\", x);\n+    }\n+    // Explicit parentheses on the left should match behavior of above\n+    if (x = x) {\n+        //~^ ERROR mismatched types: expected `bool`, found `()` (expected bool, found ())\n+        println!(\"{}\", x);\n+    }\n+    // The struct literal interpretation is fine with explicit parentheses on the right\n+    if y = (Foo { foo: x }) {\n+        //~^ ERROR mismatched types: expected `bool`, found `()` (expected bool, found ())\n+        println!(\"{}\", x);\n+    }\n+}"}, {"sha": "c44918d9879d81113153ce876f575ed91ccddc35", "filename": "src/test/compile-fail/lint-unnecessary-import-braces.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-import-braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-import-braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-import-braces.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(unnecessary_import_braces)]\n+#![allow(dead_code)]\n+#![allow(unused_imports)]\n+\n+use test::{A}; //~ ERROR braces around A is unnecessary\n+\n+mod test {\n+    pub struct A;\n+}\n+\n+fn main() {}"}, {"sha": "41a30e23b2221776ea74fad3f8f753a2e15c7c7a", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -82,5 +82,23 @@ fn f4b() -> int {\n     }\n }\n \n+fn f5a() {\n+    for x in range(1i, 10) { }\n+    //~^ ERROR unused variable: `x`\n+}\n+\n+fn f5b() {\n+    for (x, _) in [1i, 2, 3].iter().enumerate() { }\n+    //~^ ERROR unused variable: `x`\n+}\n+\n+fn f5c() {\n+    for (_, x) in [1i, 2, 3].iter().enumerate() {\n+    //~^ ERROR unused variable: `x`\n+        continue;\n+        std::os::set_exit_status(*x); //~ WARNING unreachable statement\n+    }\n+}\n+\n fn main() {\n }"}, {"sha": "6b3c92e0028bf6e1e3ac2fcdfe1abc1432a522ae", "filename": "src/test/compile-fail/region-bounds-on-objects-and-type-parameters.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -35,10 +35,10 @@ fn test<\n     'a,\n     'b,\n     A:IsStatic,\n-    B:Is<'a>+Is2<'b>,    //~ ERROR ambiguous lifetime bound\n+    B:Is<'a>+Is2<'b>, // OK in a parameter, but not an object type.\n     C:'b+Is<'a>+Is2<'b>,\n     D:Is<'a>+Is2<'static>,\n-    E:'a+'b //~ ERROR only a single explicit lifetime bound is permitted\n+    E:'a+'b           // OK in a parameter, but not an object type.\n >() { }\n \n fn main() { }"}, {"sha": "cec785c6e9666f188d3eb8668dea2e047ad9b019", "filename": "src/test/compile-fail/regions-close-over-type-parameter-multiple.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Various tests where we over type parameters with multiple lifetime\n+// bounds.\n+\n+trait SomeTrait { fn get(&self) -> int; }\n+\n+fn make_object_good1<'a,'b,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'a> {\n+    // A outlives 'a AND 'b...\n+    box v as Box<SomeTrait+'a> // ...hence this type is safe.\n+}\n+\n+fn make_object_good2<'a,'b,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'b> {\n+    // A outlives 'a AND 'b...\n+    box v as Box<SomeTrait+'b> // ...hence this type is safe.\n+}\n+\n+fn make_object_bad<'a,'b,'c,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'c> {\n+    // A outlives 'a AND 'b...but not 'c.\n+    box v as Box<SomeTrait+'a> //~ ERROR mismatched types\n+}\n+\n+fn main() {\n+}"}, {"sha": "43be96965d01f05bfd0736e5313da04e45311fc7", "filename": "src/test/compile-fail/xcrate-private-by-default.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -20,22 +20,26 @@ fn main() {\n     static_priv_by_default::b;\n     static_priv_by_default::c;\n     foo::<static_priv_by_default::d>();\n+    foo::<static_priv_by_default::e>();\n \n     // publicly re-exported items should be available\n     static_priv_by_default::bar::e;\n     static_priv_by_default::bar::f;\n     static_priv_by_default::bar::g;\n     foo::<static_priv_by_default::bar::h>();\n+    foo::<static_priv_by_default::bar::i>();\n \n     // private items at the top should be inaccessible\n-    static_priv_by_default::i;\n-    //~^ ERROR: static `i` is private\n     static_priv_by_default::j;\n-    //~^ ERROR: function `j` is private\n+    //~^ ERROR: static `j` is private\n     static_priv_by_default::k;\n-    //~^ ERROR: struct `k` is private\n-    foo::<static_priv_by_default::l>();\n-    //~^ ERROR: type `l` is private\n+    //~^ ERROR: function `k` is private\n+    static_priv_by_default::l;\n+    //~^ ERROR: struct `l` is private\n+    foo::<static_priv_by_default::m>();\n+    //~^ ERROR: enum `m` is private\n+    foo::<static_priv_by_default::n>();\n+    //~^ ERROR: type `n` is private\n \n     // public items in a private mod should be inaccessible\n     static_priv_by_default::foo::a;\n@@ -45,5 +49,7 @@ fn main() {\n     static_priv_by_default::foo::c;\n     //~^ ERROR: struct `c` is private\n     foo::<static_priv_by_default::foo::d>();\n-    //~^ ERROR: type `d` is private\n+    //~^ ERROR: enum `d` is private\n+    foo::<static_priv_by_default::foo::e>();\n+    //~^ ERROR: type `e` is private\n }"}, {"sha": "50583c7d127d884ae9e75e8dbaf290f7f9c554d2", "filename": "src/test/run-pass/issue-17302.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Frun-pass%2Fissue-17302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Frun-pass%2Fissue-17302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17302.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static mut DROPPED: [bool, ..2] = [false, false];\n+\n+struct A(uint);\n+struct Foo { _a: A, _b: int }\n+\n+impl Drop for A {\n+    fn drop(&mut self) {\n+        let A(i) = *self;\n+        unsafe { DROPPED[i] = true; }\n+    }\n+}\n+\n+fn main() {\n+    {\n+        Foo {\n+            _a: A(0),\n+            ..Foo { _a: A(1), _b: 2 }\n+        };\n+    }\n+    unsafe {\n+        assert!(DROPPED[0]);\n+        assert!(DROPPED[1]);\n+    }\n+}"}, {"sha": "5dba80ad38a16750875502c170b9af4a5876ae7f", "filename": "src/test/run-pass/regions-close-over-type-parameter-successfully.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Frun-pass%2Fregions-close-over-type-parameter-successfully.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd/src%2Ftest%2Frun-pass%2Fregions-close-over-type-parameter-successfully.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-close-over-type-parameter-successfully.rs?ref=b88d1030e11410d64b8e6c16e3b8de8b4a8efbbd", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A test where we (successfully) close over a reference into\n+// an object.\n+\n+trait SomeTrait { fn get(&self) -> int; }\n+\n+impl<'a> SomeTrait for &'a int {\n+    fn get(&self) -> int {\n+        **self\n+    }\n+}\n+\n+fn make_object<'a,A:SomeTrait+'a>(v: A) -> Box<SomeTrait+'a> {\n+    box v as Box<SomeTrait+'a>\n+}\n+\n+fn main() {\n+    let i: int = 22;\n+    let obj = make_object(&i);\n+    assert_eq!(22, obj.get());\n+}"}]}