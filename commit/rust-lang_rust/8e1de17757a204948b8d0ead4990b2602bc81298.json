{"sha": "8e1de17757a204948b8d0ead4990b2602bc81298", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlMWRlMTc3NTdhMjA0OTQ4YjhkMGVhZDQ5OTBiMjYwMmJjODEyOTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-10-28T21:37:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-08T21:52:36Z"}, "message": "Create a new pass to resolve named lifetimes; rscope is not only\nused to indicate when anonymous regions (i.e., &T) are permitted", "tree": {"sha": "cb5319c4925395e9d350ec027b92163517fc61ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb5319c4925395e9d350ec027b92163517fc61ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e1de17757a204948b8d0ead4990b2602bc81298", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e1de17757a204948b8d0ead4990b2602bc81298", "html_url": "https://github.com/rust-lang/rust/commit/8e1de17757a204948b8d0ead4990b2602bc81298", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e1de17757a204948b8d0ead4990b2602bc81298/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a594a999fbccf04710c9dfea3ef3d231c14e1bd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a594a999fbccf04710c9dfea3ef3d231c14e1bd1", "html_url": "https://github.com/rust-lang/rust/commit/a594a999fbccf04710c9dfea3ef3d231c14e1bd1"}], "stats": {"total": 1048, "additions": 644, "deletions": 404}, "files": [{"sha": "380991266822ca217a6e12979b9736443b86de41", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=8e1de17757a204948b8d0ead4990b2602bc81298", "patch": "@@ -239,6 +239,9 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         time(time_passes, \"resolution\", (), |_|\n              middle::resolve::resolve_crate(sess, lang_items, crate));\n \n+    let named_region_map = time(time_passes, \"lifetime resolution\", (),\n+                                |_| middle::resolve_lifetime::crate(sess, crate));\n+\n     time(time_passes, \"looking for entry point\", (),\n          |_| middle::entry::find_entry_point(sess, crate, ast_map));\n \n@@ -251,8 +254,8 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     let rp_set = time(time_passes, \"region parameterization inference\", (), |_|\n                       middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n \n-    let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n-                            region_map, rp_set, lang_items);\n+    let ty_cx = ty::mk_ctxt(sess, def_map, named_region_map, ast_map, freevars,\n+                            region_map, lang_items);\n \n     // passes are timed inside typeck\n     let (method_map, vtable_map) = typeck::check_crate("}, {"sha": "98260be99023012e2c52e4305b98411f810c84e0", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=8e1de17757a204948b8d0ead4990b2602bc81298", "patch": "@@ -0,0 +1,321 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Name resolution for lifetimes.\n+ *\n+ * Name resolution for lifetimes follows MUCH simpler rules than the\n+ * full resolve. For example, lifetime names are never exported or\n+ * used between functions, and they operate in a purely top-down\n+ * way. Therefore we break lifetime name resolution into a separate pass.\n+ */\n+\n+use driver::session;\n+use std::hashmap::HashMap;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use syntax::opt_vec::OptVec;\n+use syntax::parse::token::special_idents;\n+use syntax::print::pprust::{lifetime_to_str};\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+\n+// maps the id of each lifetime reference to the lifetime decl\n+// that it corresponds to\n+pub type NamedRegionMap = HashMap<ast::NodeId, ast::DefRegion>;\n+\n+struct LifetimeContext {\n+    sess: session::Session,\n+    named_region_map: @mut NamedRegionMap,\n+}\n+\n+enum ScopeChain<'self> {\n+    ItemScope(&'self OptVec<ast::Lifetime>),\n+    FnScope(ast::NodeId, &'self OptVec<ast::Lifetime>, &'self ScopeChain<'self>),\n+    BlockScope(ast::NodeId, &'self ScopeChain<'self>),\n+    RootScope\n+}\n+\n+pub fn crate(sess: session::Session,\n+             crate: &ast::Crate)\n+             -> @mut NamedRegionMap {\n+    let mut ctxt = LifetimeContext {\n+        sess: sess,\n+        named_region_map: @mut HashMap::new()\n+    };\n+    visit::walk_crate(&mut ctxt, crate, &RootScope);\n+    sess.abort_if_errors();\n+    ctxt.named_region_map\n+}\n+\n+impl<'self> Visitor<&'self ScopeChain<'self>> for LifetimeContext {\n+    fn visit_item(&mut self,\n+                  item: @ast::item,\n+                  _: &'self ScopeChain<'self>) {\n+        let scope = match item.node {\n+            ast::item_fn(*) | // fn lifetimes get added in visit_fn below\n+            ast::item_mod(*) |\n+            ast::item_mac(*) |\n+            ast::item_foreign_mod(*) |\n+            ast::item_static(*) => {\n+                RootScope\n+            }\n+            ast::item_ty(_, ref generics) |\n+            ast::item_enum(_, ref generics) |\n+            ast::item_struct(_, ref generics) |\n+            ast::item_impl(ref generics, _, _, _) |\n+            ast::item_trait(ref generics, _, _) => {\n+                self.check_lifetime_names(&generics.lifetimes);\n+                ItemScope(&generics.lifetimes)\n+            }\n+        };\n+        debug!(\"entering scope {:?}\", scope);\n+        visit::walk_item(self, item, &scope);\n+        debug!(\"exiting scope {:?}\", scope);\n+    }\n+\n+    fn visit_fn(&mut self,\n+                fk: &visit::fn_kind,\n+                fd: &ast::fn_decl,\n+                b: &ast::Block,\n+                s: Span,\n+                n: ast::NodeId,\n+                scope: &'self ScopeChain<'self>) {\n+        match *fk {\n+            visit::fk_item_fn(_, generics, _, _) |\n+            visit::fk_method(_, generics, _) => {\n+                let scope1 = FnScope(n, &generics.lifetimes, scope);\n+                self.check_lifetime_names(&generics.lifetimes);\n+                debug!(\"pushing fn scope id={} due to item/method\", n);\n+                visit::walk_fn(self, fk, fd, b, s, n, &scope1);\n+                debug!(\"popping fn scope id={} due to item/method\", n);\n+            }\n+            visit::fk_anon(*) | visit::fk_fn_block(*) => {\n+                visit::walk_fn(self, fk, fd, b, s, n, scope);\n+            }\n+        }\n+    }\n+\n+    fn visit_ty(&mut self,\n+                ty: &ast::Ty,\n+                scope: &'self ScopeChain<'self>) {\n+        match ty.node {\n+            ast::ty_closure(@ast::TyClosure { lifetimes: ref lifetimes, _ }) |\n+            ast::ty_bare_fn(@ast::TyBareFn { lifetimes: ref lifetimes, _ }) => {\n+                let scope1 = FnScope(ty.id, lifetimes, scope);\n+                self.check_lifetime_names(lifetimes);\n+                debug!(\"pushing fn scope id={} due to type\", ty.id);\n+                visit::walk_ty(self, ty, &scope1);\n+                debug!(\"popping fn scope id={} due to type\", ty.id);\n+            }\n+            _ => {\n+                visit::walk_ty(self, ty, scope);\n+            }\n+        }\n+    }\n+\n+    fn visit_ty_method(&mut self,\n+                       m: &ast::TypeMethod,\n+                       scope: &'self ScopeChain<'self>) {\n+        let scope1 = FnScope(m.id, &m.generics.lifetimes, scope);\n+        self.check_lifetime_names(&m.generics.lifetimes);\n+        debug!(\"pushing fn scope id={} due to ty_method\", m.id);\n+        visit::walk_ty_method(self, m, &scope1);\n+        debug!(\"popping fn scope id={} due to ty_method\", m.id);\n+    }\n+\n+    fn visit_block(&mut self,\n+                   b: &ast::Block,\n+                   scope: &'self ScopeChain<'self>) {\n+        let scope1 = BlockScope(b.id, scope);\n+        debug!(\"pushing block scope {}\", b.id);\n+        visit::walk_block(self, b, &scope1);\n+        debug!(\"popping block scope {}\", b.id);\n+    }\n+\n+    fn visit_lifetime_ref(&mut self,\n+                          lifetime_ref: &ast::Lifetime,\n+                          scope: &'self ScopeChain<'self>) {\n+        if lifetime_ref.ident == special_idents::statik {\n+            self.insert_lifetime(lifetime_ref, ast::DefStaticRegion);\n+            return;\n+        }\n+        self.resolve_lifetime_ref(lifetime_ref, scope);\n+    }\n+}\n+\n+impl LifetimeContext {\n+    fn resolve_lifetime_ref(&self,\n+                            lifetime_ref: &ast::Lifetime,\n+                            scope: &ScopeChain) {\n+        // Walk up the scope chain, tracking the number of fn scopes\n+        // that we pass through, until we find a lifetime with the\n+        // given name or we run out of scopes. If we encounter a code\n+        // block, then the lifetime is not bound but free, so switch\n+        // over to `resolve_free_lifetime_ref()` to complete the\n+        // search.\n+        let mut depth = 0;\n+        let mut scope = scope;\n+        loop {\n+            match *scope {\n+                BlockScope(id, s) => {\n+                    return self.resolve_free_lifetime_ref(id, lifetime_ref, s);\n+                }\n+\n+                RootScope => {\n+                    break;\n+                }\n+\n+                ItemScope(lifetimes) => {\n+                    match search_lifetimes(lifetimes, lifetime_ref) {\n+                        Some((index, decl_id)) => {\n+                            let def = ast::DefTypeBoundRegion(index, decl_id);\n+                            self.insert_lifetime(lifetime_ref, def);\n+                            return;\n+                        }\n+                        None => {\n+                            break;\n+                        }\n+                    }\n+                }\n+\n+                FnScope(id, lifetimes, s) => {\n+                    match search_lifetimes(lifetimes, lifetime_ref) {\n+                        Some((_index, decl_id)) => {\n+                            let def = ast::DefFnBoundRegion(id, depth, decl_id);\n+                            self.insert_lifetime(lifetime_ref, def);\n+                            return;\n+                        }\n+\n+                        None => {\n+                            depth += 1;\n+                            scope = s;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.unresolved_lifetime_ref(lifetime_ref);\n+    }\n+\n+    fn resolve_free_lifetime_ref(&self,\n+                                 scope_id: ast::NodeId,\n+                                 lifetime_ref: &ast::Lifetime,\n+                                 scope: &ScopeChain) {\n+        // Walk up the scope chain, tracking the outermost free scope,\n+        // until we encounter a scope that contains the named lifetime\n+        // or we run out of scopes.\n+        let mut scope_id = scope_id;\n+        let mut scope = scope;\n+        let mut search_result = None;\n+        loop {\n+            match *scope {\n+                BlockScope(id, s) => {\n+                    scope_id = id;\n+                    scope = s;\n+                }\n+\n+                RootScope => {\n+                    break;\n+                }\n+\n+                ItemScope(lifetimes) => {\n+                    search_result = search_lifetimes(lifetimes, lifetime_ref);\n+                    break;\n+                }\n+\n+                FnScope(_, lifetimes, s) => {\n+                    search_result = search_lifetimes(lifetimes, lifetime_ref);\n+                    if search_result.is_some() {\n+                        break;\n+                    }\n+                    scope = s;\n+                }\n+            }\n+        }\n+\n+        match search_result {\n+            Some((_depth, decl_id)) => {\n+                let def = ast::DefFreeRegion(scope_id, decl_id);\n+                self.insert_lifetime(lifetime_ref, def);\n+            }\n+\n+            None => {\n+                self.unresolved_lifetime_ref(lifetime_ref);\n+            }\n+        }\n+\n+    }\n+\n+    fn unresolved_lifetime_ref(&self,\n+                               lifetime_ref: &ast::Lifetime) {\n+        self.sess.span_err(\n+            lifetime_ref.span,\n+            format!(\"use of undeclared lifetime name `'{}`\",\n+                    self.sess.str_of(lifetime_ref.ident)));\n+    }\n+\n+    fn check_lifetime_names(&self, lifetimes: &OptVec<ast::Lifetime>) {\n+        for i in range(0, lifetimes.len()) {\n+            let lifetime_i = lifetimes.get(i);\n+\n+            let special_idents = [special_idents::statik];\n+            for lifetime in lifetimes.iter() {\n+                if special_idents.iter().any(|&i| i == lifetime.ident) {\n+                    self.sess.span_err(\n+                        lifetime.span,\n+                        format!(\"illegal lifetime parameter name: `{}`\",\n+                                self.sess.str_of(lifetime.ident)));\n+                }\n+            }\n+\n+            for j in range(i + 1, lifetimes.len()) {\n+                let lifetime_j = lifetimes.get(j);\n+\n+                if lifetime_i.ident == lifetime_j.ident {\n+                    self.sess.span_err(\n+                        lifetime_j.span,\n+                        format!(\"lifetime name `'{}` declared twice in \\\n+                                the same scope\",\n+                                self.sess.str_of(lifetime_j.ident)));\n+                }\n+            }\n+        }\n+    }\n+\n+    fn insert_lifetime(&self,\n+                       lifetime_ref: &ast::Lifetime,\n+                       def: ast::DefRegion) {\n+        if lifetime_ref.id == ast::DUMMY_NODE_ID {\n+            self.sess.span_bug(lifetime_ref.span,\n+                               \"Lifetime reference not renumbered, \\\n+                               probably a bug in syntax::fold\");\n+        }\n+\n+        debug!(\"lifetime_ref={} id={} resolved to {:?}\",\n+                lifetime_to_str(lifetime_ref,\n+                                self.sess.intr()),\n+                lifetime_ref.id,\n+                def);\n+        self.named_region_map.insert(lifetime_ref.id, def);\n+    }\n+}\n+\n+fn search_lifetimes(lifetimes: &OptVec<ast::Lifetime>,\n+                    lifetime_ref: &ast::Lifetime)\n+                    -> Option<(uint, ast::NodeId)> {\n+    for (i, lifetime_decl) in lifetimes.iter().enumerate() {\n+        if lifetime_decl.ident == lifetime_ref.ident {\n+            return Some((i, lifetime_decl.id));\n+        }\n+    }\n+    return None;\n+}"}, {"sha": "09f24b327f43949d91eab1e20aef4c89fd684482", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8e1de17757a204948b8d0ead4990b2602bc81298", "patch": "@@ -17,6 +17,7 @@ use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n use middle::lang_items::OpaqueStructLangItem;\n use middle::freevars;\n use middle::resolve;\n+use middle::resolve_lifetime;\n use middle::ty;\n use middle::subst::Subst;\n use middle::typeck;\n@@ -258,6 +259,8 @@ struct ctxt_ {\n     sess: session::Session,\n     def_map: resolve::DefMap,\n \n+    named_region_map: @mut resolve_lifetime::NamedRegionMap,\n+\n     region_maps: @mut middle::region::RegionMaps,\n     region_paramd_items: middle::region::region_paramd_items,\n \n@@ -919,13 +922,15 @@ pub fn new_ty_hash<V:'static>() -> @mut HashMap<t, V> {\n \n pub fn mk_ctxt(s: session::Session,\n                dm: resolve::DefMap,\n+               named_region_map: @mut resolve_lifetime::NamedRegionMap,\n                amap: ast_map::map,\n                freevars: freevars::freevar_map,\n                region_maps: @mut middle::region::RegionMaps,\n                region_paramd_items: middle::region::region_paramd_items,\n                lang_items: middle::lang_items::LanguageItems)\n             -> ctxt {\n     @ctxt_ {\n+        named_region_map: named_region_map,\n         diag: s.diagnostic(),\n         interner: @mut HashMap::new(),\n         next_id: @mut primitives::LAST_PRIMITIVE_ID,"}, {"sha": "11d995762ee72083c59815c1f35ee0773b97e837", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 88, "deletions": 101, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=8e1de17757a204948b8d0ead4990b2602bc81298", "patch": "@@ -23,13 +23,10 @@\n  * In the check phase, when the @FnCtxt is used as the `AstConv`,\n  * `get_item_ty()` just looks up the item type in `tcx.tcache`.\n  *\n- * The `RegionScope` trait controls how region references are\n- * handled.  It has two methods which are used to resolve anonymous\n- * region references (e.g., `&T`) and named region references (e.g.,\n- * `&a.T`).  There are numerous region scopes that can be used, but most\n- * commonly you want either `EmptyRscope`, which permits only the static\n- * region, or `TypeRscope`, which permits the self region if the type in\n- * question is parameterized by a region.\n+ * The `RegionScope` trait controls what happens when the user does\n+ * not specify a region in some location where a region is required\n+ * (e.g., if the user writes `&Foo` as a type rather than `&'a Foo`).\n+ * See the `rscope` module for more details.\n  *\n  * Unlike the `AstConv` trait, the region scope can change as we descend\n  * the type.  This is to accommodate the fact that (a) fn types are binding\n@@ -57,20 +54,17 @@ use middle::const_eval;\n use middle::ty::{substs};\n use middle::ty::{ty_param_substs_and_ty};\n use middle::ty;\n-use middle::typeck::rscope::in_binding_rscope;\n-use middle::typeck::rscope::{RegionScope, RegionError};\n-use middle::typeck::rscope::RegionParamNames;\n+use middle::typeck::rscope;\n+use middle::typeck::rscope::{RegionScope};\n use middle::typeck::lookup_def_tcx;\n \n-use std::result;\n+use std::vec;\n use syntax::abi::AbiSet;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n use syntax::print::pprust::{lifetime_to_str, path_to_str};\n-use syntax::parse::token::special_idents;\n-use util::common::indenter;\n \n pub trait AstConv {\n     fn tcx(&self) -> ty::ctxt;\n@@ -81,55 +75,83 @@ pub trait AstConv {\n     fn ty_infer(&self, span: Span) -> ty::t;\n }\n \n-pub fn get_region_reporting_err(\n+pub fn ast_region_to_region(\n     tcx: ty::ctxt,\n-    span: Span,\n-    a_r: &Option<ast::Lifetime>,\n-    res: Result<ty::Region, RegionError>) -> ty::Region\n+    lifetime: &ast::Lifetime)\n+    -> ty::Region\n {\n-    match res {\n-        result::Ok(r) => r,\n-        result::Err(ref e) => {\n-            let descr = match a_r {\n-                &None => ~\"anonymous lifetime\",\n-                &Some(ref a) => format!(\"lifetime {}\",\n-                                lifetime_to_str(a, tcx.sess.intr()))\n-            };\n-            tcx.sess.span_err(\n-                span,\n-                format!(\"Illegal {}: {}\",\n-                     descr, e.msg));\n-            e.replacement\n+    let r = match tcx.named_region_map.find(&lifetime.id) {\n+        None => {\n+            // should have been recorded by the `resolve_lifetime` pass\n+            tcx.sess.span_bug(lifetime.span, \"unresolved lifetime\");\n         }\n-    }\n+\n+        Some(&ast::DefStaticRegion) => {\n+            ty::re_static\n+        }\n+\n+        Some(&ast::DefFnBoundRegion(binder_id, _, id)) => {\n+            ty::re_fn_bound(binder_id, ty::br_named(ast_util::local_def(id),\n+                                                    lifetime.ident))\n+        }\n+\n+        Some(&ast::DefTypeBoundRegion(index, id)) => {\n+            ty::re_type_bound(id, index, lifetime.ident)\n+        }\n+\n+        Some(&ast::DefFreeRegion(scope_id, id)) => {\n+            ty::re_free(ty::FreeRegion {\n+                    scope_id: scope_id,\n+                    bound_region: ty::br_named(ast_util::local_def(id),\n+                                               lifetime.ident)\n+                })\n+        }\n+    };\n+\n+    debug!(\"ast_region_to_region(lifetime={} id={}) yields {}\",\n+            lifetime_to_str(lifetime, tcx.sess.intr()),\n+            lifetime.id,\n+            r.repr(tcx));\n+\n+    r\n }\n \n-pub fn ast_region_to_region<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+pub fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     default_span: Span,\n     opt_lifetime: &Option<ast::Lifetime>) -> ty::Region\n {\n-    let (span, res) = match opt_lifetime {\n-        &None => {\n-            (default_span, rscope.anon_region(default_span))\n-        }\n-        &Some(ref lifetime) if lifetime.ident == special_idents::statik => {\n-            (lifetime.span, Ok(ty::re_static))\n+    let r = match *opt_lifetime {\n+        Some(ref lifetime) => {\n+            ast_region_to_region(this.tcx(), lifetime)\n         }\n-        &Some(ref lifetime) if lifetime.ident == special_idents::self_ => {\n-            (lifetime.span, rscope.self_region(lifetime.span))\n-        }\n-        &Some(ref lifetime) => {\n-            (lifetime.span, rscope.named_region(lifetime.span,\n-                                                lifetime.ident))\n+\n+        None => {\n+            match rscope.anon_regions(default_span, 1) {\n+                None => {\n+                    debug!(\"optional region in illegal location\");\n+                    this.tcx().sess.span_err(\n+                        default_span, \"missing lifetime specifier\");\n+                    ty::re_static\n+                }\n+\n+                Some(rs) => {\n+                    rs[0]\n+                }\n+            }\n         }\n     };\n \n-    get_region_reporting_err(this.tcx(), span, opt_lifetime, res)\n+    debug!(\"opt_ast_region_to_region(opt_lifetime={:?}) yields {}\",\n+            opt_lifetime.as_ref().map(\n+                |e| lifetime_to_str(e, this.tcx().sess.intr())),\n+            r.repr(this.tcx()));\n+\n+    r\n }\n \n-fn ast_path_substs<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     def_id: ast::DefId,\n@@ -200,7 +222,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope + Clone + 'static>(\n }\n \n pub fn ast_path_to_substs_and_ty<AC:AstConv,\n-                                 RS:RegionScope + Clone + 'static>(\n+                                 RS:RegionScope>(\n                                  this: &AC,\n                                  rscope: &RS,\n                                  did: ast::DefId,\n@@ -217,7 +239,7 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,\n     ty_param_substs_and_ty { substs: substs, ty: ty }\n }\n \n-pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     trait_def_id: ast::DefId,\n@@ -240,7 +262,7 @@ pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     return trait_ref;\n }\n \n-pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>(\n         this: &AC,\n         rscope: &RS,\n         did: ast::DefId,\n@@ -262,10 +284,10 @@ pub static NO_TPS: uint = 2;\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n-pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n+pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n     this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t {\n \n-    fn ast_mt_to_mt<AC:AstConv, RS:RegionScope + Clone + 'static>(\n+    fn ast_mt_to_mt<AC:AstConv, RS:RegionScope>(\n         this: &AC, rscope: &RS, mt: &ast::mt) -> ty::mt {\n \n         ty::mt {ty: ast_ty_to_ty(this, rscope, mt.ty), mutbl: mt.mutbl}\n@@ -274,7 +296,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n     // Handle @, ~, and & being able to mean estrs and evecs.\n     // If a_seq_ty is a str or a vec, make it an estr/evec.\n     // Also handle first-class trait types.\n-    fn mk_pointer<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+    fn mk_pointer<AC:AstConv,RS:RegionScope>(\n         this: &AC,\n         rscope: &RS,\n         a_seq_ty: &ast::mt,\n@@ -387,7 +409,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n         ty::mk_ptr(tcx, ast_mt_to_mt(this, rscope, mt))\n       }\n       ast::ty_rptr(ref region, ref mt) => {\n-        let r = ast_region_to_region(this, rscope, ast_ty.span, region);\n+        let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n+        debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n         mk_pointer(this, rscope, mt, ty::vstore_slice(r),\n                    |tmt| ty::mk_rptr(tcx, r, tmt))\n       }\n@@ -551,7 +574,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n }\n \n pub fn ty_of_arg<AC:AstConv,\n-                 RS:RegionScope + Clone + 'static>(\n+                 RS:RegionScope>(\n                  this: &AC,\n                  rscope: &RS,\n                  a: &ast::arg,\n@@ -564,42 +587,12 @@ pub fn ty_of_arg<AC:AstConv,\n     }\n }\n \n-pub fn bound_lifetimes<AC:AstConv>(\n-    this: &AC,\n-    ast_lifetimes: &OptVec<ast::Lifetime>) -> OptVec<ast::Ident>\n-{\n-    /*!\n-     *\n-     * Converts a list of lifetimes into a list of bound identifier\n-     * names.  Does not permit special names like 'static or 'this to\n-     * be bound.  Note that this function is for use in closures,\n-     * methods, and fn definitions.  It is legal to bind 'this in a\n-     * type.  Eventually this distinction should go away and the same\n-     * rules should apply everywhere ('this would not be a special name\n-     * at that point).\n-     */\n-\n-    let special_idents = [special_idents::statik, special_idents::self_];\n-    let mut bound_lifetime_names = opt_vec::Empty;\n-    ast_lifetimes.map_to_vec(|ast_lifetime| {\n-        if special_idents.iter().any(|&i| i == ast_lifetime.ident) {\n-            this.tcx().sess.span_err(\n-                ast_lifetime.span,\n-                format!(\"illegal lifetime parameter name: `{}`\",\n-                     lifetime_to_str(ast_lifetime, this.tcx().sess.intr())));\n-        } else {\n-            bound_lifetime_names.push(ast_lifetime.ident);\n-        }\n-    });\n-    bound_lifetime_names\n-}\n-\n struct SelfInfo {\n     untransformed_self_ty: ty::t,\n     explicit_self: ast::explicit_self\n }\n \n-pub fn ty_of_method<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+pub fn ty_of_method<AC:AstConv>(\n     this: &AC,\n     rscope: &RS,\n     purity: ast::purity,\n@@ -643,10 +636,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n-    let bound_lifetime_names = bound_lifetimes(this, lifetimes);\n-    let rb =\n-        in_binding_rscope(rscope,\n-                          RegionParamNames(bound_lifetime_names.clone()));\n+    let rb = rscope::BindingRscope::new(id);\n \n     let opt_transformed_self_ty = do opt_self_info.map |self_info| {\n         transform_self_ty(this, &rb, self_info)\n@@ -671,7 +661,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n                 }\n             });\n \n-    fn transform_self_ty<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+    fn transform_self_ty<AC:AstConv,RS:RegionScope>(\n         this: &AC,\n         rscope: &RS,\n         self_info: &SelfInfo) -> Option<ty::t>\n@@ -683,9 +673,9 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n             }\n             ast::sty_region(ref lifetime, mutability) => {\n                 let region =\n-                    ast_region_to_region(this, rscope,\n-                                         self_info.explicit_self.span,\n-                                         lifetime);\n+                    opt_ast_region_to_region(this, rscope,\n+                                             self_info.explicit_self.span,\n+                                             lifetime);\n                 Some(ty::mk_rptr(this.tcx(), region,\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n                                          mutbl: mutability}))\n@@ -704,7 +694,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     }\n }\n \n-pub fn ty_of_closure<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     sigil: ast::Sigil,\n@@ -729,8 +719,8 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     // resolve the function bound region in the original region\n     // scope `rscope`, not the scope of the function parameters\n     let bound_region = match opt_lifetime {\n-        &Some(_) => {\n-            ast_region_to_region(this, rscope, span, opt_lifetime)\n+        &Some(ref lifetime) => {\n+            ast_region_to_region(this.tcx(), lifetime)\n         }\n         &None => {\n             match sigil {\n@@ -741,18 +731,15 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope + Clone + 'static>(\n                 }\n                 ast::BorrowedSigil => {\n                     // &fn() defaults as normal for an omitted lifetime:\n-                    ast_region_to_region(this, rscope, span, opt_lifetime)\n+                    opt_ast_region_to_region(this, rscope, span, opt_lifetime)\n                 }\n             }\n         }\n     };\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n-    let bound_lifetime_names = bound_lifetimes(this, lifetimes);\n-    let rb =\n-        in_binding_rscope(rscope,\n-                          RegionParamNames(bound_lifetime_names.clone()));\n+    let rb = rscope::BindingRscope::new(id);\n \n     let input_tys = do decl.inputs.iter().enumerate().map |(i, a)| {\n         let expected_arg_ty = do expected_sig.as_ref().and_then |e| {"}, {"sha": "2c48eb04ee6dc83481b3457f58b55fcafaa9c8ae", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 33, "deletions": 286, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=8e1de17757a204948b8d0ead4990b2602bc81298", "patch": "@@ -11,312 +11,59 @@\n \n use middle::ty;\n \n-use std::result;\n+use std::vec;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n-use syntax::opt_vec;\n-use syntax::parse::token::special_idents;\n-\n-#[deriving(ToStr)]\n-pub struct RegionError {\n-    msg: ~str,\n-    replacement: ty::Region\n-}\n \n pub trait RegionScope {\n-    fn anon_region(&self, span: Span) -> Result<ty::Region, RegionError>;\n-    fn self_region(&self, span: Span) -> Result<ty::Region, RegionError>;\n-    fn named_region(&self, span: Span, id: ast::Ident)\n-                      -> Result<ty::Region, RegionError>;\n-}\n-\n-#[deriving(Clone)]\n-pub struct EmptyRscope;\n-impl RegionScope for EmptyRscope {\n-    fn anon_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n-        result::Err(RegionError {\n-            msg: ~\"only 'static is allowed here\",\n-            replacement: ty::re_static\n-        })\n-    }\n-    fn self_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n-        self.anon_region(_span)\n-    }\n-    fn named_region(&self, _span: Span, _id: ast::Ident)\n-        -> Result<ty::Region, RegionError>\n-    {\n-        self.anon_region(_span)\n-    }\n-}\n-\n-#[deriving(Clone)]\n-pub struct RegionParamNames(OptVec<ast::Ident>);\n-\n-impl RegionParamNames {\n-    fn has_self(&self) -> bool {\n-        self.has_ident(special_idents::self_)\n-    }\n-\n-    fn has_ident(&self, ident: ast::Ident) -> bool {\n-        for region_param_name in self.iter() {\n-            if *region_param_name == ident {\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n-    pub fn add_generics(&mut self, generics: &ast::Generics) {\n-        match generics.lifetimes {\n-            opt_vec::Empty => {}\n-            opt_vec::Vec(ref new_lifetimes) => {\n-                match **self {\n-                    opt_vec::Empty => {\n-                        *self = RegionParamNames(\n-                            opt_vec::Vec(new_lifetimes.map(|lt| lt.ident)));\n-                    }\n-                    opt_vec::Vec(ref mut existing_lifetimes) => {\n-                        for new_lifetime in new_lifetimes.iter() {\n-                            existing_lifetimes.push(new_lifetime.ident);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // Convenience function to produce the error for an unresolved name. The\n-    // optional argument specifies a custom replacement.\n-    pub fn undeclared_name(custom_replacement: Option<ty::Region>)\n-                        -> Result<ty::Region, RegionError> {\n-        let replacement = match custom_replacement {\n-            None => ty::re_bound(ty::br_self),\n-            Some(custom_replacement) => custom_replacement\n-        };\n-        Err(RegionError {\n-            msg: ~\"this lifetime must be declared\",\n-            replacement: replacement\n-        })\n-    }\n-\n-    pub fn from_generics(generics: &ast::Generics) -> RegionParamNames {\n-        match generics.lifetimes {\n-            opt_vec::Empty => RegionParamNames(opt_vec::Empty),\n-            opt_vec::Vec(ref lifetimes) => {\n-                RegionParamNames(opt_vec::Vec(lifetimes.map(|lt| lt.ident)))\n-            }\n-        }\n-    }\n-\n-    pub fn from_lifetimes(lifetimes: &opt_vec::OptVec<ast::Lifetime>)\n-                       -> RegionParamNames {\n-        match *lifetimes {\n-            opt_vec::Empty => RegionParamNames::new(),\n-            opt_vec::Vec(ref v) => {\n-                RegionParamNames(opt_vec::Vec(v.map(|lt| lt.ident)))\n-            }\n-        }\n-    }\n-\n-    fn new() -> RegionParamNames {\n-        RegionParamNames(opt_vec::Empty)\n-    }\n-}\n-\n-#[deriving(Clone)]\n-struct RegionParameterization {\n-    variance: ty::region_variance,\n-    region_param_names: RegionParamNames,\n-}\n-\n-impl RegionParameterization {\n-    pub fn from_variance_and_generics(variance: Option<ty::region_variance>,\n-                                      generics: &ast::Generics)\n-                                   -> Option<RegionParameterization> {\n-        match variance {\n-            None => None,\n-            Some(variance) => {\n-                Some(RegionParameterization {\n-                    variance: variance,\n-                    region_param_names:\n-                        RegionParamNames::from_generics(generics),\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-#[deriving(Clone)]\n-pub struct MethodRscope {\n-    explicit_self: ast::explicit_self_,\n-    variance: Option<ty::region_variance>,\n-    region_param_names: RegionParamNames,\n-}\n-\n-impl MethodRscope {\n-    // `generics` here refers to the generics of the outer item (impl or\n-    // trait).\n-    pub fn new(explicit_self: ast::explicit_self_,\n-               variance: Option<ty::region_variance>,\n-               rcvr_generics: &ast::Generics)\n-            -> MethodRscope {\n-        let region_param_names =\n-            RegionParamNames::from_generics(rcvr_generics);\n-        MethodRscope {\n-            explicit_self: explicit_self,\n-            variance: variance,\n-            region_param_names: region_param_names\n-        }\n-    }\n-\n-    pub fn region_param_names(&self) -> RegionParamNames {\n-        self.region_param_names.clone()\n-    }\n-}\n-\n-impl RegionScope for MethodRscope {\n-    fn anon_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n-        result::Err(RegionError {\n-            msg: ~\"anonymous lifetimes are not permitted here\",\n-            replacement: ty::re_bound(ty::br_self)\n-        })\n-    }\n-    fn self_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n-        assert!(self.variance.is_some());\n-        match self.variance {\n-            None => {}  // must be borrowed self, so this is OK\n-            Some(_) => {\n-                if !self.region_param_names.has_self() {\n-                    return Err(RegionError {\n-                        msg: ~\"the `self` lifetime must be declared\",\n-                        replacement: ty::re_bound(ty::br_self)\n-                    })\n-                }\n-            }\n-        }\n-        result::Ok(ty::re_bound(ty::br_self))\n-    }\n-    fn named_region(&self, span: Span, id: ast::Ident)\n-                      -> Result<ty::Region, RegionError> {\n-        if !self.region_param_names.has_ident(id) {\n-            return RegionParamNames::undeclared_name(None);\n-        }\n-        do EmptyRscope.named_region(span, id).or_else |_e| {\n-            result::Err(RegionError {\n-                msg: ~\"lifetime is not in scope\",\n-                replacement: ty::re_bound(ty::br_self)\n-            })\n-        }\n-    }\n+    fn anon_regions(&self,\n+                    span: Span,\n+                    count: uint)\n+                    -> Option<~[ty::Region]>;\n }\n \n-#[deriving(Clone)]\n-pub struct TypeRscope(Option<RegionParameterization>);\n-\n-impl TypeRscope {\n-    fn replacement(&self) -> ty::Region {\n-        if self.is_some() {\n-            ty::re_bound(ty::br_self)\n-        } else {\n-            ty::re_static\n-        }\n-    }\n-}\n-impl RegionScope for TypeRscope {\n-    fn anon_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n-        result::Err(RegionError {\n-            msg: ~\"anonymous lifetimes are not permitted here\",\n-            replacement: self.replacement()\n-        })\n-    }\n-    fn self_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n-        match **self {\n-            None => {\n-                // if the self region is used, region parameterization should\n-                // have inferred that this type is RP\n-                fail!(\"region parameterization should have inferred that \\\n-                        this type is RP\");\n-            }\n-            Some(ref region_parameterization) => {\n-                if !region_parameterization.region_param_names.has_self() {\n-                    return Err(RegionError {\n-                        msg: ~\"the `self` lifetime must be declared\",\n-                        replacement: ty::re_bound(ty::br_self)\n-                    })\n-                }\n-            }\n-        }\n-        result::Ok(ty::re_bound(ty::br_self))\n-    }\n-    fn named_region(&self, span: Span, id: ast::Ident)\n-                      -> Result<ty::Region, RegionError> {\n-        do EmptyRscope.named_region(span, id).or_else |_e| {\n-            result::Err(RegionError {\n-                msg: ~\"only 'self is allowed as part of a type declaration\",\n-                replacement: self.replacement()\n-            })\n-        }\n-    }\n-}\n+// A scope in which all regions must be explicitly named\n+pub struct ExplicitRscope;\n \n-pub fn bound_self_region(rp: Option<ty::region_variance>)\n-                      -> OptVec<ty::Region> {\n-    match rp {\n-      Some(_) => opt_vec::with(ty::re_bound(ty::br_self)),\n-      None => opt_vec::Empty\n+impl RegionScope for ExplicitRscope {\n+    fn anon_regions(&self,\n+                    _span: Span,\n+                    _count: uint)\n+                    -> Option<~[ty::Region]> {\n+        None\n     }\n }\n \n pub struct BindingRscope {\n-    base: @RegionScope,\n-    anon_bindings: @mut uint,\n-    region_param_names: RegionParamNames,\n+    binder_id: ast::NodeId,\n+    anon_bindings: @mut uint\n }\n \n-impl Clone for BindingRscope {\n-    fn clone(&self) -> BindingRscope {\n+impl BindingRscope {\n+    pub fn new(binder_id: ast::NodeId) -> BindingRscope {\n         BindingRscope {\n-            base: self.base,\n-            anon_bindings: self.anon_bindings,\n-            region_param_names: self.region_param_names.clone(),\n+            binder_id: binder_id,\n+            anon_bindings: @mut 0\n         }\n     }\n }\n \n-pub fn in_binding_rscope<RS:RegionScope + Clone + 'static>(\n-        this: &RS,\n-        region_param_names: RegionParamNames)\n-     -> BindingRscope {\n-    let base = @(*this).clone();\n-    let base = base as @RegionScope;\n-    BindingRscope {\n-        base: base,\n-        anon_bindings: @mut 0,\n-        region_param_names: region_param_names,\n-    }\n-}\n-\n impl RegionScope for BindingRscope {\n-    fn anon_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n+    fn anon_regions(&self,\n+                    _: Span,\n+                    count: uint)\n+                    -> Option<~[ty::Region]> {\n         let idx = *self.anon_bindings;\n-        *self.anon_bindings += 1;\n-        result::Ok(ty::re_bound(ty::br_anon(idx)))\n-    }\n-    fn self_region(&self, span: Span) -> Result<ty::Region, RegionError> {\n-        self.base.self_region(span)\n-    }\n-    fn named_region(&self,\n-                    span: Span,\n-                    id: ast::Ident) -> Result<ty::Region, RegionError>\n-    {\n-        do self.base.named_region(span, id).or_else |_e| {\n-            let result = ty::re_bound(ty::br_named(id));\n-            if self.region_param_names.has_ident(id) {\n-                result::Ok(result)\n-            } else {\n-                RegionParamNames::undeclared_name(Some(result))\n-            }\n-        }\n+        *self.anon_bindings += count;\n+        Some(vec::from_fn(count, |i| ty::re_fn_bound(self.binder_id,\n+                                                     ty::br_anon(idx + i))))\n     }\n }\n+\n+pub fn bound_type_regions(defs: &[ty::RegionParameterDef])\n+                          -> OptVec<ty::Region> {\n+    assert!(defs.iter().all(|def| def.def_id.crate == ast::LOCAL_CRATE));\n+    defs.iter().enumerate().map(\n+        |(i, def)| ty::re_type_bound(def.def_id.node, i, def.ident)).collect()\n+}"}, {"sha": "c0c2e2822f1621331d699bb5284b7b0cae19ef6c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8e1de17757a204948b8d0ead4990b2602bc81298", "patch": "@@ -251,6 +251,20 @@ pub enum Def {\n     DefMethod(DefId /* method */, Option<DefId> /* trait */),\n }\n \n+#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n+pub enum DefRegion {\n+    DefStaticRegion,\n+    DefTypeBoundRegion(/* index */ uint, /* lifetime decl */ NodeId),\n+    DefFnBoundRegion(/* binder_id */ NodeId, /* depth */ uint, /* lifetime decl */ NodeId),\n+    DefFreeRegion(/* block scope */ NodeId, /* lifetime decl */ NodeId),\n+}\n+\n+#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n+pub struct DefNamedRegion {\n+    node_id: NodeId,\n+    depth: uint,\n+}\n+\n // The set of MetaItems that define the compilation environment of the crate,\n // used to drive conditional compilation\n pub type CrateConfig = ~[@MetaItem];"}, {"sha": "60127be87b6ef7d48ee96d75b8119eb402fdff97", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 88, "deletions": 15, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8e1de17757a204948b8d0ead4990b2602bc81298", "patch": "@@ -90,7 +90,32 @@ pub trait Visitor<E:Clone> {\n         walk_struct_def(self, s, i, g, n, e)\n     }\n     fn visit_struct_field(&mut self, s:@struct_field, e:E) { walk_struct_field(self, s, e) }\n-    fn visit_mac(&mut self, m:&mac, e:E) { walk_mac(self, m, e); }\n+    fn visit_opt_lifetime_ref(&mut self,\n+                              _span: Span,\n+                              opt_lifetime: &Option<Lifetime>,\n+                              env: E) {\n+        /*!\n+         * Visits an optional reference to a lifetime. The `span` is\n+         * the span of some surrounding reference should opt_lifetime\n+         * be None.\n+         */\n+        match *opt_lifetime {\n+            Some(ref l) => self.visit_lifetime_ref(l, env),\n+            None => ()\n+        }\n+    }\n+    fn visit_lifetime_ref(&mut self, _lifetime: &Lifetime, _e: E) {\n+        /*! Visits a reference to a lifetime */\n+    }\n+    fn visit_lifetime_decl(&mut self, _lifetime: &Lifetime, _e: E) {\n+        /*! Visits a declaration of a lifetime */\n+    }\n+    fn visit_explicit_self(&mut self, es: &explicit_self, e: E) {\n+        walk_explicit_self(self, es, e)\n+    }\n+    fn visit_mac(&mut self, macro:&mac, e:E) {\n+        walk_mac(self, macro, e)\n+    }\n }\n \n pub fn walk_crate<E:Clone, V:Visitor<E>>(visitor: &mut V, crate: &Crate, env: E) {\n@@ -119,6 +144,18 @@ pub fn walk_local<E:Clone, V:Visitor<E>>(visitor: &mut V, local: &Local, env: E)\n     }\n }\n \n+fn walk_explicit_self<E:Clone, V:Visitor<E>>(visitor: &mut V,\n+                                             explicit_self: &explicit_self,\n+                                             env: E) {\n+    match explicit_self.node {\n+        sty_static | sty_value(_) | sty_box(_) | sty_uniq(_) => {\n+        }\n+        sty_region(ref lifetime, _) => {\n+            visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime, env)\n+        }\n+    }\n+}\n+\n fn walk_trait_ref<E:Clone, V:Visitor<E>>(visitor: &mut V,\n                             trait_ref: &ast::trait_ref,\n                             env: E) {\n@@ -221,8 +258,11 @@ pub fn skip_ty<E, V:Visitor<E>>(_: &mut V, _: &Ty, _: E) {\n pub fn walk_ty<E:Clone, V:Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n     match typ.node {\n         ty_box(ref mutable_type) | ty_uniq(ref mutable_type) |\n-        ty_vec(ref mutable_type) | ty_ptr(ref mutable_type) |\n-        ty_rptr(_, ref mutable_type) => {\n+        ty_vec(ref mutable_type) | ty_ptr(ref mutable_type) => {\n+            visitor.visit_ty(mutable_type.ty, env)\n+        }\n+        ty_rptr(ref lifetime, ref mutable_type) => {\n+            visitor.visit_opt_lifetime_ref(typ.span, lifetime, env.clone());\n             visitor.visit_ty(mutable_type.ty, env)\n         }\n         ty_tup(ref tuple_element_types) => {\n@@ -231,19 +271,27 @@ pub fn walk_ty<E:Clone, V:Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n             }\n         }\n         ty_closure(ref function_declaration) => {\n-             for argument in function_declaration.decl.inputs.iter() {\n+            for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&argument.ty, env.clone())\n-             }\n-             visitor.visit_ty(&function_declaration.decl.output, env.clone());\n-             for bounds in function_declaration.bounds.iter() {\n+            }\n+            visitor.visit_ty(&function_declaration.decl.output, env.clone());\n+            for bounds in function_declaration.bounds.iter() {\n                 walk_ty_param_bounds(visitor, bounds, env.clone())\n-             }\n+            }\n+            visitor.visit_opt_lifetime_ref(\n+                typ.span,\n+                &function_declaration.region,\n+                env.clone());\n+            walk_lifetime_decls(visitor, &function_declaration.lifetimes,\n+                                env.clone());\n         }\n         ty_bare_fn(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&argument.ty, env.clone())\n             }\n-            visitor.visit_ty(&function_declaration.decl.output, env.clone())\n+            visitor.visit_ty(&function_declaration.decl.output, env.clone());\n+            walk_lifetime_decls(visitor, &function_declaration.lifetimes,\n+                                env.clone());\n         }\n         ty_path(ref path, ref bounds, _) => {\n             walk_path(visitor, path, env.clone());\n@@ -262,10 +310,21 @@ pub fn walk_ty<E:Clone, V:Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n     }\n }\n \n+fn walk_lifetime_decls<E:Clone, V:Visitor<E>>(visitor: &mut V,\n+                                              lifetimes: &OptVec<Lifetime>,\n+                                              env: E) {\n+    for l in lifetimes.iter() {\n+        visitor.visit_lifetime_decl(l, env.clone());\n+    }\n+}\n+\n pub fn walk_path<E:Clone, V:Visitor<E>>(visitor: &mut V, path: &Path, env: E) {\n     for segment in path.segments.iter() {\n         for typ in segment.types.iter() {\n-            visitor.visit_ty(typ, env.clone())\n+            visitor.visit_ty(typ, env.clone());\n+        }\n+        for lifetime in segment.lifetimes.iter() {\n+            visitor.visit_lifetime_ref(lifetime, env.clone());\n         }\n     }\n }\n@@ -354,6 +413,7 @@ pub fn walk_generics<E:Clone, V:Visitor<E>>(visitor: &mut V,\n     for type_parameter in generics.ty_params.iter() {\n         walk_ty_param_bounds(visitor, &type_parameter.bounds, env.clone())\n     }\n+    walk_lifetime_decls(visitor, &generics.lifetimes, env);\n }\n \n pub fn walk_fn_decl<E:Clone, V:Visitor<E>>(visitor: &mut V,\n@@ -385,18 +445,31 @@ pub fn walk_fn<E:Clone, V:Visitor<E>>(visitor: &mut V,\n                          function_kind: &fn_kind,\n                          function_declaration: &fn_decl,\n                          function_body: &Block,\n-                         _: Span,\n+                         _span: Span,\n                          _: NodeId,\n                          env: E) {\n     walk_fn_decl(visitor, function_declaration, env.clone());\n-    let generics = generics_of_fn(function_kind);\n-    visitor.visit_generics(&generics, env.clone());\n+\n+    match *function_kind {\n+        fk_item_fn(_, generics, _, _) => {\n+            visitor.visit_generics(generics, env.clone());\n+        }\n+        fk_method(_, generics, method) => {\n+            visitor.visit_generics(generics, env.clone());\n+\n+            visitor.visit_explicit_self(&method.explicit_self, env.clone());\n+        }\n+        fk_anon(*) | fk_fn_block(*) => {\n+        }\n+    }\n+\n     visitor.visit_block(function_body, env)\n }\n \n pub fn walk_ty_method<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                                method_type: &TypeMethod,\n-                                env: E) {\n+                                             method_type: &TypeMethod,\n+                                             env: E) {\n+    visitor.visit_explicit_self(&method_type.explicit_self, env.clone());\n     for argument_type in method_type.decl.inputs.iter() {\n         visitor.visit_ty(&argument_type.ty, env.clone())\n     }"}, {"sha": "518fe0b00b6ce7c743de9f0ba701bb644bafe24e", "filename": "src/test/compile-fail/regions-name-duplicated.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Ftest%2Fcompile-fail%2Fregions-name-duplicated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Ftest%2Fcompile-fail%2Fregions-name-duplicated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-name-duplicated.rs?ref=8e1de17757a204948b8d0ead4990b2602bc81298", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<'a, 'a> { //~ ERROR lifetime name `'a` declared twice\n+    x: &'a int\n+}\n+\n+fn main() {}"}, {"sha": "c1170654dd294c7b00e43bed3e0c6e8b04eb333d", "filename": "src/test/compile-fail/regions-name-static.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Ftest%2Fcompile-fail%2Fregions-name-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Ftest%2Fcompile-fail%2Fregions-name-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-name-static.rs?ref=8e1de17757a204948b8d0ead4990b2602bc81298", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<'static> { //~ ERROR illegal lifetime parameter name: `static`\n+    x: &'static int\n+}\n+\n+fn main() {}"}, {"sha": "abff33e05149126f18c4da94dfc48d7234b26fa0", "filename": "src/test/compile-fail/regions-name-undeclared.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Ftest%2Fcompile-fail%2Fregions-name-undeclared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e1de17757a204948b8d0ead4990b2602bc81298/src%2Ftest%2Fcompile-fail%2Fregions-name-undeclared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-name-undeclared.rs?ref=8e1de17757a204948b8d0ead4990b2602bc81298", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that lifetime resolver enforces the lifetime name scoping\n+// rules correctly in various scenarios.\n+\n+struct Foo<'a> {\n+    x: &'a int\n+}\n+\n+impl<'a> Foo<'a> {\n+    // &'a is inherited:\n+    fn m1(&self, arg: &'a int) { }\n+    fn m2(&'a self) { }\n+    fn m3(&self, arg: Foo<'a>) { }\n+\n+    // &'b is not:\n+    fn m4(&self, arg: &'b int) { } //~ ERROR undeclared lifetime\n+    fn m5(&'b self) { } //~ ERROR undeclared lifetime\n+    fn m6(&self, arg: Foo<'b>) { } //~ ERROR undeclared lifetime\n+}\n+\n+fn bar<'a>(x: &'a int) {\n+    // &'a is visible to code:\n+    let y: &'a int = x;\n+\n+    // &'a is not visible to *items*:\n+    type X = Option<&'a int>; //~ ERROR undeclared lifetime\n+    enum E {\n+        E1(&'a int) //~ ERROR undeclared lifetime\n+    }\n+    struct S {\n+        f: &'a int //~ ERROR undeclared lifetime\n+    }\n+    fn f(a: &'a int) { } //~ ERROR undeclared lifetime\n+\n+    // &'a CAN be declared on functions and used then:\n+    fn g<'a>(a: &'a int) { } // OK\n+    fn h(a: &fn<'a>(&'a int)) { } // OK\n+}\n+\n+// Test nesting of lifetimes in fn type declarations\n+fn fn_types(a: &'a int, //~ ERROR undeclared lifetime\n+            b: &fn<'a>(a: &'a int,\n+                       b: &'b int, //~ ERROR undeclared lifetime\n+                       c: &fn<'b>(a: &'a int,\n+                                  b: &'b int),\n+                       d: &'b int), //~ ERROR undeclared lifetime\n+            c: &'a int) //~ ERROR undeclared lifetime\n+{\n+}\n+\n+pub fn main() {}"}]}