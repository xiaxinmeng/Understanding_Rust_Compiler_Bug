{"sha": "51c2325dd7cdfb8c12ec55421270903df7f26d3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxYzIzMjVkZDdjZGZiOGMxMmVjNTU0MjEyNzA5MDNkZjdmMjZkM2U=", "commit": {"author": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-03-18T19:20:01Z"}, "committer": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-04-20T10:30:00Z"}, "message": "move closures to seperate fns, remove known problems", "tree": {"sha": "93c67c2891e295f37259d60004dec6a16991a08e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93c67c2891e295f37259d60004dec6a16991a08e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51c2325dd7cdfb8c12ec55421270903df7f26d3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51c2325dd7cdfb8c12ec55421270903df7f26d3e", "html_url": "https://github.com/rust-lang/rust/commit/51c2325dd7cdfb8c12ec55421270903df7f26d3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51c2325dd7cdfb8c12ec55421270903df7f26d3e/comments", "author": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40bbdffc89edb4c3841a8b23c41d4092206e940c", "url": "https://api.github.com/repos/rust-lang/rust/commits/40bbdffc89edb4c3841a8b23c41d4092206e940c", "html_url": "https://github.com/rust-lang/rust/commit/40bbdffc89edb4c3841a8b23c41d4092206e940c"}], "stats": {"total": 99, "additions": 49, "deletions": 50}, "files": [{"sha": "cc1de314d016a10f7be41278f2fabfa54aef82f1", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/51c2325dd7cdfb8c12ec55421270903df7f26d3e/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51c2325dd7cdfb8c12ec55421270903df7f26d3e/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=51c2325dd7cdfb8c12ec55421270903df7f26d3e", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{match_type, paths, span_lint_and_help};\n use if_chain::if_chain;\n-use rustc_hir::{Expr, ExprKind, MatchSource, StmtKind};\n+use rustc_hir::{Arm, Expr, ExprKind, MatchSource, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -11,7 +11,7 @@ declare_clippy_lint! {\n     /// **Why is this bad?** The Mutex lock remains held for the whole\n     /// `if let ... else` block and deadlocks.\n     ///\n-    /// **Known problems:** This lint does not generate an auto-applicable suggestion.\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     ///\n@@ -49,47 +49,7 @@ impl LateLintPass<'_, '_> for IfLetMutex {\n             if match_type(cx, ty, &paths::MUTEX); // make sure receiver is Mutex\n             if method_chain_names(op, 10).iter().any(|s| s == \"lock\"); // and lock is called\n \n-            if arms.iter().any(|arm| if_chain! {\n-                if let ExprKind::Block(ref block, _l) = arm.body.kind;\n-                if block.stmts.iter().any(|stmt| match stmt.kind {\n-                    StmtKind::Local(l) => if_chain! {\n-                        if let Some(ex) = l.init;\n-                        if let ExprKind::MethodCall(_, _, _) = op.kind;\n-                        if method_chain_names(ex, 10).iter().any(|s| s == \"lock\"); // and lock is called\n-                        then {\n-                            match_type_method_chain(cx, ex, 5)\n-                        } else {\n-                            false\n-                        }\n-                    },\n-                    StmtKind::Expr(e) => if_chain! {\n-                        if let ExprKind::MethodCall(_, _, _) = e.kind;\n-                        if method_chain_names(e, 10).iter().any(|s| s == \"lock\"); // and lock is called\n-                        then {\n-                            match_type_method_chain(cx, ex, 5)\n-                        } else {\n-                            false\n-                        }\n-                    },\n-                    StmtKind::Semi(e) => if_chain! {\n-                        if let ExprKind::MethodCall(_, _, _) = e.kind;\n-                        if method_chain_names(e, 10).iter().any(|s| s == \"lock\"); // and lock is called\n-                        then {\n-                            match_type_method_chain(cx, ex, 5)\n-                        } else {\n-                            false\n-                        }\n-                    },\n-                    _ => {\n-                        false\n-                    },\n-                });\n-                then {\n-                    true\n-                } else {\n-                    false\n-                }\n-            });\n+            if arms.iter().any(|arm| matching_arm(arm, op, ex, cx));\n             then {\n                 span_lint_and_help(\n                     cx,\n@@ -103,6 +63,52 @@ impl LateLintPass<'_, '_> for IfLetMutex {\n     }\n }\n \n+fn matching_arm(arm: &Arm<'_>, op: &Expr<'_>, ex: &Expr<'_>, cx: &LateContext<'_, '_>) -> bool {\n+    if_chain! {\n+        if let ExprKind::Block(ref block, _l) = arm.body.kind;\n+        if block.stmts.iter().any(|stmt| matching_stmt(stmt, op, ex, cx));\n+        then {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+fn matching_stmt(stmt: &Stmt<'_>, op: &Expr<'_>, ex: &Expr<'_>, cx: &LateContext<'_, '_>) -> bool {\n+    match stmt.kind {\n+        StmtKind::Local(l) => if_chain! {\n+            if let Some(ex) = l.init;\n+            if let ExprKind::MethodCall(_, _, _) = op.kind;\n+            if method_chain_names(ex, 10).iter().any(|s| s == \"lock\"); // and lock is called\n+            then {\n+                match_type_method_chain(cx, ex, 5)\n+            } else {\n+                false\n+            }\n+        },\n+        StmtKind::Expr(e) => if_chain! {\n+            if let ExprKind::MethodCall(_, _, _) = e.kind;\n+            if method_chain_names(e, 10).iter().any(|s| s == \"lock\"); // and lock is called\n+            then {\n+                match_type_method_chain(cx, ex, 5)\n+            } else {\n+                false\n+            }\n+        },\n+        StmtKind::Semi(e) => if_chain! {\n+            if let ExprKind::MethodCall(_, _, _) = e.kind;\n+            if method_chain_names(e, 10).iter().any(|s| s == \"lock\"); // and lock is called\n+            then {\n+                match_type_method_chain(cx, ex, 5)\n+            } else {\n+                false\n+            }\n+        },\n+        _ => false,\n+    }\n+}\n+\n /// Return the names of `max_depth` number of methods called in the chain.\n fn method_chain_names<'tcx>(expr: &'tcx Expr<'tcx>, max_depth: usize) -> Vec<String> {\n     let mut method_names = Vec::with_capacity(max_depth);"}, {"sha": "651eb949a5bec890041e98e6cea52638ca1fdcac", "filename": "tests/ui/redundant_pattern_matching.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51c2325dd7cdfb8c12ec55421270903df7f26d3e/tests%2Fui%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51c2325dd7cdfb8c12ec55421270903df7f26d3e/tests%2Fui%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching.rs?ref=51c2325dd7cdfb8c12ec55421270903df7f26d3e", "patch": "@@ -113,10 +113,3 @@ fn returns_unit() {\n         false\n     };\n }\n-\n-fn issue_5271() {\n-    let hello = Some(String::from(\"hello\"));\n-    let _x = match hello {\n-        s @ _ => drop(s),\n-    };\n-}"}]}