{"sha": "0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjZjNlOWZkZGNkYjI4NWJmYjQ5MzFmMWU1OTIzZTllMjllNzYxYmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-04T15:40:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-04T15:40:56Z"}, "message": "Auto merge of #1497 - samrat:posix-fs-refactor, r=oli-obk\n\nAdd `impl FileDescriptor` for stdin, stdout, stderr\n\n- Use `FileDescriptor::read` for stdin reads\n- Use `FileDescriptor::write` for stdout/err writes\n- Handle stdout/err reads in `FileDescriptor::read`\n\nThe `FileDescriptor` trait was added in PR #1495\n\nCloses #1486", "tree": {"sha": "477928c84ff5ef86efe7f341e02083a50310faf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/477928c84ff5ef86efe7f341e02083a50310faf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd", "html_url": "https://github.com/rust-lang/rust/commit/0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446", "url": "https://api.github.com/repos/rust-lang/rust/commits/69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446", "html_url": "https://github.com/rust-lang/rust/commit/69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446"}, {"sha": "bdef57ea45594752f904983effc81fe938fbdfe9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdef57ea45594752f904983effc81fe938fbdfe9", "html_url": "https://github.com/rust-lang/rust/commit/bdef57ea45594752f904983effc81fe938fbdfe9"}], "stats": {"total": 180, "additions": 107, "deletions": 73}, "files": [{"sha": "151ab95f1e3c4d278d89a0972ce9ec0b2cda9350", "filename": "src/shims/posix/foreign_items.rs", "status": "modified", "additions": 2, "deletions": 69, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd/src%2Fshims%2Fposix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd/src%2Fshims%2Fposix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fforeign_items.rs?ref=0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd", "patch": "@@ -1,6 +1,3 @@\n-use std::convert::TryFrom;\n-use std::io::{self, Read, Write};\n-\n use log::trace;\n \n use rustc_middle::mir;\n@@ -67,43 +64,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_scalar(buf)?.check_init()?;\n                 let count = this.read_scalar(count)?.to_machine_usize(this)?;\n-                let result = if fd == 0 {\n-\n-                    this.check_no_isolation(\"read\")?;\n-\n-                    // We cap the number of read bytes to the largest\n-                    // value that we are able to fit in both the\n-                    // host's and target's `isize`. This saves us from\n-                    // having to handle overflows later.\n-                    let count = count.min(this.machine_isize_max() as u64).min(isize::MAX as u64);\n-\n-                    // We want to read at most `count` bytes. We are\n-                    // sure that `count` is not negative because it\n-                    // was a target's `usize`. Also we are sure that\n-                    // its smaller than `usize::MAX` because it is a\n-                    // host's `isize`.\n-                    let mut buffer = vec![0; count as usize];\n-                    let res = io::stdin()\n-                        .read(&mut buffer)\n-                        // `Stdin::read` never returns a value larger\n-                        // than `count`, so this cannot fail.\n-                        .map(|c| i64::try_from(c).unwrap());\n-\n-                    match res {\n-                        Ok(bytes) => {\n-                            this.memory.write_bytes(buf, buffer)?;\n-                            i64::try_from(bytes).unwrap()\n-                        },\n-                        Err(e) => {\n-                            this.set_last_error_from_io_error(e)?;\n-                            -1\n-                        },\n-                    }\n-                } else if fd == 1 || fd == 2 {\n-                    throw_unsup_format!(\"cannot read from stdout/stderr\")\n-                } else {\n-                    this.read(fd, buf, count)?\n-                };\n+                let result = this.read(fd, buf, count)?;\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"write\" => {\n@@ -112,35 +73,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let buf = this.read_scalar(buf)?.check_init()?;\n                 let count = this.read_scalar(n)?.to_machine_usize(this)?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, count);\n-                let result = if fd == 0 {\n-                    throw_unsup_format!(\"cannot write to stdin\")\n-                } else if fd == 1 || fd == 2 {\n-                    // stdout/stderr\n-\n-                    let buf_cont = this.memory.read_bytes(buf, Size::from_bytes(count))?;\n-                    // We need to flush to make sure this actually appears on the screen\n-                    let res = if fd == 1 {\n-                        // Stdout is buffered, flush to make sure it appears on the screen.\n-                        // This is the write() syscall of the interpreted program, we want it\n-                        // to correspond to a write() syscall on the host -- there is no good\n-                        // in adding extra buffering here.\n-                        let res = io::stdout().write(buf_cont);\n-                        io::stdout().flush().unwrap();\n-                        res\n-                    } else {\n-                        // No need to flush, stderr is not buffered.\n-                        io::stderr().write(buf_cont)\n-                    };\n-                    match res {\n-                        Ok(n) => i64::try_from(n).unwrap(),\n-                        Err(e) => {\n-                            this.set_last_error_from_io_error(e)?;\n-                            -1\n-                        }\n-                    }\n-                } else {\n-                    this.write(fd, buf, count)?\n-                };\n+                let result = this.write(fd, buf, count)?;\n                 // Now, `result` is the value we return back to the program.\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }"}, {"sha": "3e1ba3976f776a783fce15a674c6f8facbf03b69", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 78, "deletions": 4, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd", "patch": "@@ -48,11 +48,85 @@ impl<'tcx> FileDescriptor<'tcx> for FileHandle {\n     }\n }\n \n-#[derive(Debug, Default)]\n+impl<'tcx> FileDescriptor<'tcx> for io::Stdin {\n+    fn as_file_handle(&self) -> InterpResult<'tcx, &FileHandle> {\n+        throw_unsup_format!(\"stdin cannot be used as FileHandle\");\n+    }\n+\n+    fn read(&mut self, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        Ok(Read::read(self, bytes))\n+    }\n+\n+    fn write(&mut self, _bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        throw_unsup_format!(\"cannot write to stdin\");\n+    }\n+\n+    fn seek(&mut self, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+        throw_unsup_format!(\"cannot seek on stdin\");\n+    }\n+}\n+\n+impl<'tcx> FileDescriptor<'tcx> for io::Stdout {\n+    fn as_file_handle(&self) -> InterpResult<'tcx, &FileHandle> {\n+        throw_unsup_format!(\"stdout cannot be used as FileHandle\");\n+    }\n+\n+    fn read(&mut self, _bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        throw_unsup_format!(\"cannot read from stdout\");\n+    }\n+\n+    fn write(&mut self, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        let result = Write::write(self, bytes);\n+        // Stdout is buffered, flush to make sure it appears on the\n+        // screen.  This is the write() syscall of the interpreted\n+        // program, we want it to correspond to a write() syscall on\n+        // the host -- there is no good in adding extra buffering\n+        // here.\n+        io::stdout().flush().unwrap();\n+\n+        Ok(result)\n+    }\n+\n+    fn seek(&mut self, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+        throw_unsup_format!(\"cannot seek on stdout\");\n+    }\n+}\n+\n+impl<'tcx> FileDescriptor<'tcx> for io::Stderr {\n+    fn as_file_handle(&self) -> InterpResult<'tcx, &FileHandle> {\n+        throw_unsup_format!(\"stdout cannot be used as FileHandle\");\n+    }\n+\n+    fn read(&mut self, _bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        throw_unsup_format!(\"cannot read from stderr\");\n+    }\n+\n+    fn write(&mut self, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        Ok(Write::write(self, bytes))\n+    }\n+\n+    fn seek(&mut self, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+        throw_unsup_format!(\"cannot seek on stderr\");\n+    }\n+}\n+\n+#[derive(Debug)]\n pub struct FileHandler<'tcx> {\n     handles: BTreeMap<i32, Box<dyn FileDescriptor<'tcx>>>,\n }\n \n+impl<'tcx> Default for FileHandler<'tcx> {\n+    fn default() -> Self {\n+        let mut handles = BTreeMap::new();\n+        handles.insert(0i32, Box::new(io::stdin()) as Box<dyn FileDescriptor<'_>>);\n+        handles.insert(1i32, Box::new(io::stdout()) as Box<dyn FileDescriptor<'_>>);\n+        handles.insert(2i32, Box::new(io::stderr()) as Box<dyn FileDescriptor<'_>>);\n+        FileHandler {\n+            handles\n+        }\n+    }\n+}\n+\n \n // fd numbers 0, 1, and 2 are reserved for stdin, stdout, and stderr\n const MIN_NORMAL_FILE_FD: i32 = 3;\n@@ -485,7 +559,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         this.check_no_isolation(\"read\")?;\n-        assert!(fd >= 3);\n \n         trace!(\"Reading from FD {}, size {}\", fd, count);\n \n@@ -537,8 +610,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"write\")?;\n-        assert!(fd >= 3);\n+        if fd >= 3 {\n+            this.check_no_isolation(\"write\")?;\n+        }\n \n         // Check that the *entire* buffer is actually valid memory.\n         this.memory.check_ptr_access("}, {"sha": "17f1735f6aded51894c1babcf2fa9ffb33fbef2b", "filename": "tests/compile-fail/fs/read_from_stdout.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd/tests%2Fcompile-fail%2Ffs%2Fread_from_stdout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd/tests%2Fcompile-fail%2Ffs%2Fread_from_stdout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffs%2Fread_from_stdout.rs?ref=0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -Zmiri-disable-isolation\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() -> std::io::Result<()> {\n+    let mut bytes = [0u8; 512];\n+    unsafe {\n+        libc::read(1, bytes.as_mut_ptr() as *mut libc::c_void, 512); //~ ERROR cannot read from stdout\n+    }\n+    Ok(())\n+}"}, {"sha": "c2754636c860c9d74bf0c7e7c7f8f198bf2715cb", "filename": "tests/compile-fail/fs/write_to_stdin.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd/tests%2Fcompile-fail%2Ffs%2Fwrite_to_stdin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd/tests%2Fcompile-fail%2Ffs%2Fwrite_to_stdin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffs%2Fwrite_to_stdin.rs?ref=0cf3e9fddcdb285bfb4931f1e5923e9e29e761bd", "patch": "@@ -0,0 +1,13 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() -> std::io::Result<()> {\n+    let bytes = b\"hello\";\n+    unsafe {\n+        libc::write(0, bytes.as_ptr() as *const libc::c_void, 5); //~ ERROR cannot write to stdin\n+    }\n+    Ok(())\n+}"}]}