{"sha": "20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e", "node_id": "C_kwDOAAsO6NoAKDIwYTVlOWZkN2NkZjNmOWIzZTYwZjFmNGQ1MjE0OGI1ZmY0NTgxOWU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-07-31T21:39:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-31T21:39:44Z"}, "message": "Rollup merge of #99986 - WaffleLapkin:record_struct_wrap_suggestion, r=compiler-errors\n\nAdd wrap suggestions for record variants\n\nThis PR adds a suggestions to wrap an expression in a record struct/variant when encountering mismatched types, similarly to a suggestion to wrap expression in a tuple struct that was added before.\n\nAn example:\n```rust\nstruct B {\n    f: u8,\n}\n\nenum E {\n    A(u32),\n    B { f: u8 },\n}\n\nfn main() {\n    let _: B = 1;\n    let _: E = 1;\n}\n```\n```text\nerror[E0308]: mismatched types\n  --> ./t.rs:11:16\n   |\n11 |     let _: B = 1;\n   |            -   ^ expected struct `B`, found integer\n   |            |\n   |            expected due to this\n   |\nhelp: try wrapping the expression in `B`\n   |\n11 |     let _: B = B { f: 1 };\n   |                ++++++   +\n\nerror[E0308]: mismatched types\n  --> ./t.rs:12:16\n   |\n12 |     let _: E = 1;\n   |            -   ^ expected enum `E`, found integer\n   |            |\n   |            expected due to this\n   |\nhelp: try wrapping the expression in a variant of `E`\n   |\n12 |     let _: E = E::A(1);\n   |                +++++ +\n12 |     let _: E = E::B { f: 1 };\n   |                +++++++++   +\n```\n\nr? `@compiler-errors`", "tree": {"sha": "7a857226acc4b887c04914a6693071fbcc7aa833", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a857226acc4b887c04914a6693071fbcc7aa833"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi5vahCRBK7hj4Ov3rIwAA1IIIAFXE+ns6+9olVqyWGdxmhOiP\ncfIbdPq1vu6qb5jc/YtXqkBqbc7o1Yv7BwpY52oWX2BUxsRpgt5jWTJgK8X3pujh\nRPoqZZ67q8y2sx/x+CRzvFaOf1KCq4VYxLk7XyGUo3Js+11CmOwvkSoi18opMd7T\nfYaXkcjEy8umJ0QLUTv+hAg1Jp7Sy4ujPnWDVruQJaGCwaHskJRfVAMhXbO1r42x\nUvBMFP2ph0hQQfWSuOTwuH8PDNlykRhN3Ee/uQq4RT0795rvuQyrlGBSgpiW6hla\nE78BWmtlS2Mwq23Xa2HvszWEMWzOIPftjBBtt9R2qwtZrmqEZTJSCwJa+H/DOGU=\n=HM+0\n-----END PGP SIGNATURE-----\n", "payload": "tree 7a857226acc4b887c04914a6693071fbcc7aa833\nparent e4fcee579ea33fb2b38ddb947850d5ee612e6479\nparent 1c2ea78f29f6c24d210728ccee177d13d235a9df\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1659303584 +0200\ncommitter GitHub <noreply@github.com> 1659303584 +0200\n\nRollup merge of #99986 - WaffleLapkin:record_struct_wrap_suggestion, r=compiler-errors\n\nAdd wrap suggestions for record variants\n\nThis PR adds a suggestions to wrap an expression in a record struct/variant when encountering mismatched types, similarly to a suggestion to wrap expression in a tuple struct that was added before.\n\nAn example:\n```rust\nstruct B {\n    f: u8,\n}\n\nenum E {\n    A(u32),\n    B { f: u8 },\n}\n\nfn main() {\n    let _: B = 1;\n    let _: E = 1;\n}\n```\n```text\nerror[E0308]: mismatched types\n  --> ./t.rs:11:16\n   |\n11 |     let _: B = 1;\n   |            -   ^ expected struct `B`, found integer\n   |            |\n   |            expected due to this\n   |\nhelp: try wrapping the expression in `B`\n   |\n11 |     let _: B = B { f: 1 };\n   |                ++++++   +\n\nerror[E0308]: mismatched types\n  --> ./t.rs:12:16\n   |\n12 |     let _: E = 1;\n   |            -   ^ expected enum `E`, found integer\n   |            |\n   |            expected due to this\n   |\nhelp: try wrapping the expression in a variant of `E`\n   |\n12 |     let _: E = E::A(1);\n   |                +++++ +\n12 |     let _: E = E::B { f: 1 };\n   |                +++++++++   +\n```\n\nr? `@compiler-errors`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e", "html_url": "https://github.com/rust-lang/rust/commit/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4fcee579ea33fb2b38ddb947850d5ee612e6479", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4fcee579ea33fb2b38ddb947850d5ee612e6479", "html_url": "https://github.com/rust-lang/rust/commit/e4fcee579ea33fb2b38ddb947850d5ee612e6479"}, {"sha": "1c2ea78f29f6c24d210728ccee177d13d235a9df", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c2ea78f29f6c24d210728ccee177d13d235a9df", "html_url": "https://github.com/rust-lang/rust/commit/1c2ea78f29f6c24d210728ccee177d13d235a9df"}], "stats": {"total": 72, "additions": 48, "deletions": 24}, "files": [{"sha": "f0110645551af94740851e5a3c434469c6a64a92", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e", "patch": "@@ -1,5 +1,6 @@\n use crate::check::FnCtxt;\n use rustc_infer::infer::InferOk;\n+use rustc_middle::middle::stability::EvalResult;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::ObligationCause;\n \n@@ -363,18 +364,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            let compatible_variants: Vec<(String, Option<String>)> = expected_adt\n+            let compatible_variants: Vec<(String, _, _, Option<String>)> = expected_adt\n                 .variants()\n                 .iter()\n                 .filter(|variant| {\n-                    variant.fields.len() == 1 && variant.ctor_kind == hir::def::CtorKind::Fn\n+                    variant.fields.len() == 1\n                 })\n                 .filter_map(|variant| {\n                     let sole_field = &variant.fields[0];\n \n                     let field_is_local = sole_field.did.is_local();\n                     let field_is_accessible =\n-                        sole_field.vis.is_accessible_from(expr.hir_id.owner.to_def_id(), self.tcx);\n+                        sole_field.vis.is_accessible_from(expr.hir_id.owner.to_def_id(), self.tcx)\n+                        // Skip suggestions for unstable public fields (for example `Pin::pointer`)\n+                        && matches!(self.tcx.eval_stability(sole_field.did, None, expr.span, None), EvalResult::Allow | EvalResult::Unmarked);\n \n                     if !field_is_local && !field_is_accessible {\n                         return None;\n@@ -391,33 +394,45 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Some(path) = variant_path.strip_prefix(\"std::prelude::\")\n                             && let Some((_, path)) = path.split_once(\"::\")\n                         {\n-                            return Some((path.to_string(), note_about_variant_field_privacy));\n+                            return Some((path.to_string(), variant.ctor_kind, sole_field.name, note_about_variant_field_privacy));\n                         }\n-                        Some((variant_path, note_about_variant_field_privacy))\n+                        Some((variant_path, variant.ctor_kind, sole_field.name, note_about_variant_field_privacy))\n                     } else {\n                         None\n                     }\n                 })\n                 .collect();\n \n-            let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n-                Some(ident) => format!(\"{ident}: \"),\n-                None => String::new(),\n+            let suggestions_for = |variant: &_, ctor, field_name| {\n+                let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+                    Some(ident) => format!(\"{ident}: \"),\n+                    None => String::new(),\n+                };\n+\n+                let (open, close) = match ctor {\n+                    hir::def::CtorKind::Fn => (\"(\".to_owned(), \")\"),\n+                    hir::def::CtorKind::Fictive => (format!(\" {{ {field_name}: \"), \" }\"),\n+\n+                    // unit variants don't have fields\n+                    hir::def::CtorKind::Const => unreachable!(),\n+                };\n+\n+                vec![\n+                    (expr.span.shrink_to_lo(), format!(\"{prefix}{variant}{open}\")),\n+                    (expr.span.shrink_to_hi(), close.to_owned()),\n+                ]\n             };\n \n             match &compatible_variants[..] {\n                 [] => { /* No variants to format */ }\n-                [(variant, note)] => {\n+                [(variant, ctor_kind, field_name, note)] => {\n                     // Just a single matching variant.\n                     err.multipart_suggestion_verbose(\n                         &format!(\n                             \"try wrapping the expression in `{variant}`{note}\",\n                             note = note.as_deref().unwrap_or(\"\")\n                         ),\n-                        vec![\n-                            (expr.span.shrink_to_lo(), format!(\"{prefix}{variant}(\")),\n-                            (expr.span.shrink_to_hi(), \")\".to_string()),\n-                        ],\n+                        suggestions_for(&**variant, *ctor_kind, *field_name),\n                         Applicability::MaybeIncorrect,\n                     );\n                 }\n@@ -428,12 +443,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             \"try wrapping the expression in a variant of `{}`\",\n                             self.tcx.def_path_str(expected_adt.did())\n                         ),\n-                        compatible_variants.into_iter().map(|(variant, _)| {\n-                            vec![\n-                                (expr.span.shrink_to_lo(), format!(\"{prefix}{variant}(\")),\n-                                (expr.span.shrink_to_hi(), \")\".to_string()),\n-                            ]\n-                        }),\n+                        compatible_variants.into_iter().map(\n+                            |(variant, ctor_kind, field_name, _)| {\n+                                suggestions_for(&variant, ctor_kind, field_name)\n+                            },\n+                        ),\n                         Applicability::MaybeIncorrect,\n                     );\n                 }"}, {"sha": "b1c7dc2a7f67297f2e108551b5f70e135ea7092a", "filename": "src/test/ui/did_you_mean/compatible-variants.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.rs?ref=20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e", "patch": "@@ -66,7 +66,7 @@ fn main() {\n }\n \n enum A {\n-    B { b: B},\n+    B { b: B },\n }\n \n struct A2(B);\n@@ -77,13 +77,12 @@ enum B {\n }\n \n fn foo() {\n-    // We don't want to suggest `A::B(B::Fst)` here.\n     let a: A = B::Fst;\n     //~^ ERROR mismatched types\n+    //~| HELP try wrapping\n }\n \n fn bar() {\n-    // But we _do_ want to suggest `A2(B::Fst)` here!\n     let a: A2 = B::Fst;\n     //~^ ERROR mismatched types\n     //~| HELP try wrapping"}, {"sha": "fe81da19833a7e2baba18c922b3c834d8578aea6", "filename": "src/test/ui/did_you_mean/compatible-variants.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr?ref=20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e", "patch": "@@ -191,15 +191,20 @@ LL |     let _ = Foo { bar: Some(bar) };\n    |                   ++++++++++   +\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:81:16\n+  --> $DIR/compatible-variants.rs:80:16\n    |\n LL |     let a: A = B::Fst;\n    |            -   ^^^^^^ expected enum `A`, found enum `B`\n    |            |\n    |            expected due to this\n+   |\n+help: try wrapping the expression in `A::B`\n+   |\n+LL |     let a: A = A::B { b: B::Fst };\n+   |                +++++++++        +\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:87:17\n+  --> $DIR/compatible-variants.rs:86:17\n    |\n LL |     let a: A2 = B::Fst;\n    |            --   ^^^^^^ expected struct `A2`, found enum `B`"}, {"sha": "eb96c2480630eb140f8fe135cac027b34678056b", "filename": "src/test/ui/did_you_mean/issue-42764.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.rs?ref=20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e", "patch": "@@ -26,4 +26,5 @@ struct Context { wrapper: Wrapper }\n fn overton() {\n     let _c = Context { wrapper: Payload{} };\n     //~^ ERROR mismatched types\n+    //~| try wrapping the expression in `Wrapper`\n }"}, {"sha": "6a7fd8fe251dc16c06e50e2ff5f0db20780036a8", "filename": "src/test/ui/did_you_mean/issue-42764.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.stderr?ref=20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e", "patch": "@@ -25,6 +25,11 @@ error[E0308]: mismatched types\n    |\n LL |     let _c = Context { wrapper: Payload{} };\n    |                                 ^^^^^^^^^ expected struct `Wrapper`, found struct `Payload`\n+   |\n+help: try wrapping the expression in `Wrapper`\n+   |\n+LL |     let _c = Context { wrapper: Wrapper { payload: Payload{} } };\n+   |                                 ++++++++++++++++++           +\n \n error: aborting due to 2 previous errors\n "}]}