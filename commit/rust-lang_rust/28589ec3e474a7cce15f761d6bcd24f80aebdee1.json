{"sha": "28589ec3e474a7cce15f761d6bcd24f80aebdee1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NTg5ZWMzZTQ3NGE3Y2NlMTVmNzYxZDZiY2QyNGY4MGFlYmRlZTE=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-07-26T08:48:54Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-31T13:15:09Z"}, "message": "async-llvm(10): Factor compile output files cleanup into separate functions.", "tree": {"sha": "a49061a8f47c7ac0c52badf6427b3ed2bf0509cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a49061a8f47c7ac0c52badf6427b3ed2bf0509cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28589ec3e474a7cce15f761d6bcd24f80aebdee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28589ec3e474a7cce15f761d6bcd24f80aebdee1", "html_url": "https://github.com/rust-lang/rust/commit/28589ec3e474a7cce15f761d6bcd24f80aebdee1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28589ec3e474a7cce15f761d6bcd24f80aebdee1/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccb970be4c28490a02ce8564e7d0bd00601ad322", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccb970be4c28490a02ce8564e7d0bd00601ad322", "html_url": "https://github.com/rust-lang/rust/commit/ccb970be4c28490a02ce8564e7d0bd00601ad322"}], "stats": {"total": 186, "additions": 101, "deletions": 85}, "files": [{"sha": "bae50da3209d06584ba0d8b57aa7219c450d4229", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 101, "deletions": 85, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/28589ec3e474a7cce15f761d6bcd24f80aebdee1/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28589ec3e474a7cce15f761d6bcd24f80aebdee1/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=28589ec3e474a7cce15f761d6bcd24f80aebdee1", "patch": "@@ -656,6 +656,11 @@ pub struct CompiledModules {\n     pub allocator_module: Option<CompiledModule>,\n }\n \n+fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n+    sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n+    sess.opts.output_types.contains_key(&OutputType::Exe)\n+}\n+\n pub fn run_passes(sess: &Session,\n                   trans: &OngoingCrateTranslation,\n                   modules: Vec<ModuleTranslation>,\n@@ -723,12 +728,7 @@ pub fn run_passes(sess: &Session,\n     // Emit bitcode files for the crate if we're emitting an rlib.\n     // Whenever an rlib is created, the bitcode is inserted into the\n     // archive in order to allow LTO against it.\n-    let needs_crate_bitcode =\n-            sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n-            sess.opts.output_types.contains_key(&OutputType::Exe);\n-    let needs_crate_object =\n-            sess.opts.output_types.contains_key(&OutputType::Exe);\n-    if needs_crate_bitcode {\n+    if need_crate_bitcode_for_rlib(sess) {\n         modules_config.emit_bc = true;\n     }\n \n@@ -842,7 +842,26 @@ pub fn run_passes(sess: &Session,\n     shared_emitter_main.check(sess, false);\n     sess.diagnostic().abort_if_errors();\n \n-    // If in incr. comp. mode, preserve the `.o` files for potential re-use\n+    copy_module_artifacts_into_incr_comp_cache(sess, &compiled_modules, crate_output);\n+\n+    produce_final_output_artifacts(sess, &compiled_modules, crate_output);\n+\n+    // FIXME: time_llvm_passes support - does this use a global context or\n+    // something?\n+    if sess.opts.cg.codegen_units == 1 && sess.time_llvm_passes() {\n+        unsafe { llvm::LLVMRustPrintPassTimings(); }\n+    }\n+\n+    *trans.result.borrow_mut() = Some(compiled_modules);\n+}\n+\n+fn copy_module_artifacts_into_incr_comp_cache(sess: &Session,\n+                                              compiled_modules: &CompiledModules,\n+                                              crate_output: &OutputFilenames) {\n+    if sess.opts.incremental.is_none() {\n+        return;\n+    }\n+\n     for module in compiled_modules.modules.iter() {\n         let mut files = vec![];\n \n@@ -858,86 +877,88 @@ pub fn run_passes(sess: &Session,\n \n         save_trans_partition(sess, &module.name, module.symbol_name_hash, &files);\n     }\n+}\n \n+fn produce_final_output_artifacts(sess: &Session,\n+                                  compiled_modules: &CompiledModules,\n+                                  crate_output: &OutputFilenames) {\n     let mut user_wants_bitcode = false;\n     let mut user_wants_objects = false;\n-    {\n-        // Produce final compile outputs.\n-        let copy_gracefully = |from: &Path, to: &Path| {\n-            if let Err(e) = fs::copy(from, to) {\n-                sess.err(&format!(\"could not copy {:?} to {:?}: {}\", from, to, e));\n-            }\n-        };\n \n-        let copy_if_one_unit = |output_type: OutputType,\n-                                keep_numbered: bool| {\n-            if compiled_modules.modules.len() == 1 {\n-                // 1) Only one codegen unit.  In this case it's no difficulty\n-                //    to copy `foo.0.x` to `foo.x`.\n-                let module_name = Some(&compiled_modules.modules[0].name[..]);\n-                let path = crate_output.temp_path(output_type, module_name);\n-                copy_gracefully(&path,\n-                                &crate_output.path(output_type));\n-                if !sess.opts.cg.save_temps && !keep_numbered {\n-                    // The user just wants `foo.x`, not `foo.#module-name#.x`.\n-                    remove(sess, &path);\n-                }\n+    // Produce final compile outputs.\n+    let copy_gracefully = |from: &Path, to: &Path| {\n+        if let Err(e) = fs::copy(from, to) {\n+            sess.err(&format!(\"could not copy {:?} to {:?}: {}\", from, to, e));\n+        }\n+    };\n+\n+    let copy_if_one_unit = |output_type: OutputType,\n+                            keep_numbered: bool| {\n+        if compiled_modules.modules.len() == 1 {\n+            // 1) Only one codegen unit.  In this case it's no difficulty\n+            //    to copy `foo.0.x` to `foo.x`.\n+            let module_name = Some(&compiled_modules.modules[0].name[..]);\n+            let path = crate_output.temp_path(output_type, module_name);\n+            copy_gracefully(&path,\n+                            &crate_output.path(output_type));\n+            if !sess.opts.cg.save_temps && !keep_numbered {\n+                // The user just wants `foo.x`, not `foo.#module-name#.x`.\n+                remove(sess, &path);\n+            }\n+        } else {\n+            let ext = crate_output.temp_path(output_type, None)\n+                                  .extension()\n+                                  .unwrap()\n+                                  .to_str()\n+                                  .unwrap()\n+                                  .to_owned();\n+\n+            if crate_output.outputs.contains_key(&output_type) {\n+                // 2) Multiple codegen units, with `--emit foo=some_name`.  We have\n+                //    no good solution for this case, so warn the user.\n+                sess.warn(&format!(\"ignoring emit path because multiple .{} files \\\n+                                    were produced\", ext));\n+            } else if crate_output.single_output_file.is_some() {\n+                // 3) Multiple codegen units, with `-o some_name`.  We have\n+                //    no good solution for this case, so warn the user.\n+                sess.warn(&format!(\"ignoring -o because multiple .{} files \\\n+                                    were produced\", ext));\n             } else {\n-                let ext = crate_output.temp_path(output_type, None)\n-                                      .extension()\n-                                      .unwrap()\n-                                      .to_str()\n-                                      .unwrap()\n-                                      .to_owned();\n-\n-                if crate_output.outputs.contains_key(&output_type) {\n-                    // 2) Multiple codegen units, with `--emit foo=some_name`.  We have\n-                    //    no good solution for this case, so warn the user.\n-                    sess.warn(&format!(\"ignoring emit path because multiple .{} files \\\n-                                        were produced\", ext));\n-                } else if crate_output.single_output_file.is_some() {\n-                    // 3) Multiple codegen units, with `-o some_name`.  We have\n-                    //    no good solution for this case, so warn the user.\n-                    sess.warn(&format!(\"ignoring -o because multiple .{} files \\\n-                                        were produced\", ext));\n-                } else {\n-                    // 4) Multiple codegen units, but no explicit name.  We\n-                    //    just leave the `foo.0.x` files in place.\n-                    // (We don't have to do any work in this case.)\n-                }\n+                // 4) Multiple codegen units, but no explicit name.  We\n+                //    just leave the `foo.0.x` files in place.\n+                // (We don't have to do any work in this case.)\n             }\n-        };\n+        }\n+    };\n \n-        // Flag to indicate whether the user explicitly requested bitcode.\n-        // Otherwise, we produced it only as a temporary output, and will need\n-        // to get rid of it.\n-        for output_type in output_types.keys() {\n-            match *output_type {\n-                OutputType::Bitcode => {\n-                    user_wants_bitcode = true;\n-                    // Copy to .bc, but always keep the .0.bc.  There is a later\n-                    // check to figure out if we should delete .0.bc files, or keep\n-                    // them for making an rlib.\n-                    copy_if_one_unit(OutputType::Bitcode, true);\n-                }\n-                OutputType::LlvmAssembly => {\n-                    copy_if_one_unit(OutputType::LlvmAssembly, false);\n-                }\n-                OutputType::Assembly => {\n-                    copy_if_one_unit(OutputType::Assembly, false);\n-                }\n-                OutputType::Object => {\n-                    user_wants_objects = true;\n-                    copy_if_one_unit(OutputType::Object, true);\n-                }\n-                OutputType::Mir |\n-                OutputType::Metadata |\n-                OutputType::Exe |\n-                OutputType::DepInfo => {}\n+    // Flag to indicate whether the user explicitly requested bitcode.\n+    // Otherwise, we produced it only as a temporary output, and will need\n+    // to get rid of it.\n+    for output_type in crate_output.outputs.keys() {\n+        match *output_type {\n+            OutputType::Bitcode => {\n+                user_wants_bitcode = true;\n+                // Copy to .bc, but always keep the .0.bc.  There is a later\n+                // check to figure out if we should delete .0.bc files, or keep\n+                // them for making an rlib.\n+                copy_if_one_unit(OutputType::Bitcode, true);\n+            }\n+            OutputType::LlvmAssembly => {\n+                copy_if_one_unit(OutputType::LlvmAssembly, false);\n             }\n+            OutputType::Assembly => {\n+                copy_if_one_unit(OutputType::Assembly, false);\n+            }\n+            OutputType::Object => {\n+                user_wants_objects = true;\n+                copy_if_one_unit(OutputType::Object, true);\n+            }\n+            OutputType::Mir |\n+            OutputType::Metadata |\n+            OutputType::Exe |\n+            OutputType::DepInfo => {}\n         }\n     }\n-    let user_wants_bitcode = user_wants_bitcode;\n \n     // Clean up unwanted temporary files.\n \n@@ -969,6 +990,9 @@ pub fn run_passes(sess: &Session,\n         // If you change how this works, also update back::link::link_rlib,\n         // where .#module-name#.bc files are (maybe) deleted after making an\n         // rlib.\n+        let needs_crate_bitcode = need_crate_bitcode_for_rlib(sess);\n+        let needs_crate_object = crate_output.outputs.contains_key(&OutputType::Exe);\n+\n         let keep_numbered_bitcode = needs_crate_bitcode ||\n                 (user_wants_bitcode && sess.opts.cg.codegen_units > 1);\n \n@@ -1009,14 +1033,6 @@ pub fn run_passes(sess: &Session,\n     //  - #crate#.crate.metadata.o\n     //  - #crate#.bc\n     // These are used in linking steps and will be cleaned up afterward.\n-\n-    // FIXME: time_llvm_passes support - does this use a global context or\n-    // something?\n-    if sess.opts.cg.codegen_units == 1 && sess.time_llvm_passes() {\n-        unsafe { llvm::LLVMRustPrintPassTimings(); }\n-    }\n-\n-    *trans.result.borrow_mut() = Some(compiled_modules);\n }\n \n pub fn dump_incremental_data(trans: &CrateTranslation) {"}]}