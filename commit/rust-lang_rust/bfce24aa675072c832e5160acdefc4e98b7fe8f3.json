{"sha": "bfce24aa675072c832e5160acdefc4e98b7fe8f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmY2UyNGFhNjc1MDcyYzgzMmU1MTYwYWNkZWZjNGU5OGI3ZmU4ZjM=", "commit": {"author": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2020-04-16T19:36:32Z"}, "committer": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2020-04-23T22:14:07Z"}, "message": "Modify `as_local_hir_id` to return a bare `HirId`", "tree": {"sha": "0f34ec764cbfad806fa1880f0125edf93b0af9e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f34ec764cbfad806fa1880f0125edf93b0af9e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfce24aa675072c832e5160acdefc4e98b7fe8f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfce24aa675072c832e5160acdefc4e98b7fe8f3", "html_url": "https://github.com/rust-lang/rust/commit/bfce24aa675072c832e5160acdefc4e98b7fe8f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfce24aa675072c832e5160acdefc4e98b7fe8f3/comments", "author": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6148db719f34a35099eff46097b5d2d9770892e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6148db719f34a35099eff46097b5d2d9770892e9", "html_url": "https://github.com/rust-lang/rust/commit/6148db719f34a35099eff46097b5d2d9770892e9"}], "stats": {"total": 553, "additions": 248, "deletions": 305}, "files": [{"sha": "c97b547946ebb28d2f195bdccebb7d5ff282ec8b", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -210,7 +210,7 @@ impl CodegenCx<'ll, 'tcx> {\n         debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n \n         let g = if let Some(id) =\n-            def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+            def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n         {\n             let llty = self.layout_of(ty).llvm_type(self);\n             let (g, attrs) = match self.tcx.hir().get(id) {"}, {"sha": "9faddf254d7e53835d1d163c98b6eb08f88d4252", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -362,7 +362,7 @@ fn upstream_drop_glue_for_provider<'tcx>(\n \n fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     if let Some(def_id) = def_id.as_local() {\n-        !tcx.reachable_set(LOCAL_CRATE).contains(&tcx.hir().as_local_hir_id(def_id).unwrap())\n+        !tcx.reachable_set(LOCAL_CRATE).contains(&tcx.hir().as_local_hir_id(def_id))\n     } else {\n         bug!(\"is_unreachable_local_definition called with non-local DefId: {:?}\", def_id)\n     }"}, {"sha": "033c2973af6eec8245b00de80d91a76e5cc559e2", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -342,8 +342,8 @@ impl Definitions {\n     }\n \n     #[inline]\n-    pub fn as_local_hir_id(&self, def_id: LocalDefId) -> Option<hir::HirId> {\n-        Some(self.local_def_id_to_hir_id(def_id))\n+    pub fn as_local_hir_id(&self, def_id: LocalDefId) -> hir::HirId {\n+        self.local_def_id_to_hir_id(def_id)\n     }\n \n     #[inline]"}, {"sha": "dd1d08a75ae198f4c308f70090cb51cff34728a1", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -191,7 +191,7 @@ fn msg_span_from_early_bound_and_free_regions(\n     let sm = tcx.sess.source_map();\n \n     let scope = region.free_region_binding_scope(tcx);\n-    let node = tcx.hir().as_local_hir_id(scope.expect_local()).unwrap();\n+    let node = tcx.hir().as_local_hir_id(scope.expect_local());\n     let tag = match tcx.hir().find(node) {\n         Some(Node::Block(_) | Node::Expr(_)) => \"body\",\n         Some(Node::Item(it)) => item_scope_tag(&it),\n@@ -1786,7 +1786,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             // Get the `hir::Param` to verify whether it already has any bounds.\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n-                            let id = hir.as_local_hir_id(def_id).unwrap();\n+                            let id = hir.as_local_hir_id(def_id);\n                             let mut has_bounds = false;\n                             if let Node::GenericParam(param) = hir.get(id) {\n                                 has_bounds = !param.bounds.is_empty();"}, {"sha": "e02a90c7b5f3de41e5ddfcc6cb2174bc2aec771a", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -30,7 +30,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n             if let Some(hir_id) =\n-                def_id.as_local().map(|def_id| self.tcx().hir().as_local_hir_id(def_id).unwrap())\n+                def_id.as_local().map(|def_id| self.tcx().hir().as_local_hir_id(def_id))\n             {\n                 let fndecl = match self.tcx().hir().get(hir_id) {\n                     Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref m, ..), .. })"}, {"sha": "ca051cecbb8c4fcc11542c9714b417e5d56aff57", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             {\n                 let hir = &self.tcx().hir();\n                 if let Some(hir_id) =\n-                    free_region.scope.as_local().map(|def_id| hir.as_local_hir_id(def_id).unwrap())\n+                    free_region.scope.as_local().map(|def_id| hir.as_local_hir_id(def_id))\n                 {\n                     if let Node::Expr(Expr { kind: Closure(_, _, _, closure_span, None), .. }) =\n                         hir.get(hir_id)"}, {"sha": "5c45f7584360698a41037ef8b102bb7c1312fc7c", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         };\n \n         let hir = &self.tcx().hir();\n-        let hir_id = hir.as_local_hir_id(id.as_local()?)?;\n+        let hir_id = hir.as_local_hir_id(id.as_local()?);\n         let body_id = hir.maybe_body_owned_by(hir_id)?;\n         let body = hir.body(body_id);\n         let owner_id = hir.body_owner(body_id);"}, {"sha": "5b25204f21b1dcaa377173ac8b220e84703ce2c4", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -436,9 +436,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 // If the trait is private, add the impl items to `private_traits` so they don't get\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.res.def_id();\n-                if let Some(hir_id) = real_trait\n-                    .as_local()\n-                    .map(|def_id| cx.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                if let Some(hir_id) =\n+                    real_trait.as_local().map(|def_id| cx.tcx.hir().as_local_hir_id(def_id))\n                 {\n                     if let Some(Node::Item(item)) = cx.tcx.hir().find(hir_id) {\n                         if let hir::VisibilityKind::Inherited = item.vis.node {\n@@ -612,10 +611,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n             let mut impls = HirIdSet::default();\n             cx.tcx.for_each_impl(debug, |d| {\n                 if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n-                    if let Some(hir_id) = ty_def\n-                        .did\n-                        .as_local()\n-                        .map(|def_id| cx.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                    if let Some(hir_id) =\n+                        ty_def.did.as_local().map(|def_id| cx.tcx.hir().as_local_hir_id(def_id))\n                     {\n                         impls.insert(hir_id);\n                     }"}, {"sha": "c4ac875fec537158044082c8fa8034edf90e9d5a", "filename": "src/librustc_lint/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -364,7 +364,7 @@ fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n         lint_store: unerased_lint_store(tcx),\n-        last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id).unwrap(),\n+        last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id),\n         generics: None,\n         only_module: true,\n     };"}, {"sha": "746ce1a28cb62feffa65f01e51bfd3eced15797f", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -617,7 +617,7 @@ impl EncodeContext<'tcx> {\n             ctor: variant.ctor_def_id.map(|did| did.index),\n         };\n \n-        let enum_id = tcx.hir().as_local_hir_id(def.did.expect_local()).unwrap();\n+        let enum_id = tcx.hir().as_local_hir_id(def.did.expect_local());\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n@@ -663,7 +663,7 @@ impl EncodeContext<'tcx> {\n \n         // Variant constructors have the same visibility as the parent enums, unless marked as\n         // non-exhaustive, in which case they are lowered to `pub(crate)`.\n-        let enum_id = tcx.hir().as_local_hir_id(def.did.expect_local()).unwrap();\n+        let enum_id = tcx.hir().as_local_hir_id(def.did.expect_local());\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(enum_vis, enum_id, tcx);\n         if variant.is_field_list_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n@@ -729,7 +729,7 @@ impl EncodeContext<'tcx> {\n         let def_id = field.did;\n         debug!(\"EncodeContext::encode_field({:?})\", def_id);\n \n-        let variant_id = tcx.hir().as_local_hir_id(variant.def_id.expect_local()).unwrap();\n+        let variant_id = tcx.hir().as_local_hir_id(variant.def_id.expect_local());\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n         record!(self.tables.kind[def_id] <- EntryKind::Field);\n@@ -756,7 +756,7 @@ impl EncodeContext<'tcx> {\n             ctor: Some(def_id.index),\n         };\n \n-        let struct_id = tcx.hir().as_local_hir_id(adt_def.did.expect_local()).unwrap();\n+        let struct_id = tcx.hir().as_local_hir_id(adt_def.did.expect_local());\n         let struct_vis = &tcx.hir().expect_item(struct_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(struct_vis, struct_id, tcx);\n         for field in &variant.fields {\n@@ -818,7 +818,7 @@ impl EncodeContext<'tcx> {\n         debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n         let ast_item = tcx.hir().expect_trait_item(hir_id);\n         let trait_item = tcx.associated_item(def_id);\n \n@@ -909,7 +909,7 @@ impl EncodeContext<'tcx> {\n         debug!(\"EncodeContext::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let hir_id = self.tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+        let hir_id = self.tcx.hir().as_local_hir_id(def_id.expect_local());\n         let ast_item = self.tcx.hir().expect_impl_item(hir_id);\n         let impl_item = self.tcx.associated_item(def_id);\n \n@@ -1313,7 +1313,7 @@ impl EncodeContext<'tcx> {\n \n         // NOTE(eddyb) `tcx.type_of(def_id)` isn't used because it's fully generic,\n         // including on the signature, which is inferred in `typeck_tables_of.\n-        let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n         let ty = self.tcx.typeck_tables_of(def_id).node_type(hir_id);\n \n         let def_id = def_id.to_def_id();\n@@ -1341,7 +1341,7 @@ impl EncodeContext<'tcx> {\n \n     fn encode_info_for_anon_const(&mut self, def_id: LocalDefId) {\n         debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n-        let id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let id = self.tcx.hir().as_local_hir_id(def_id);\n         let body_id = self.tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n         let def_id = def_id.to_def_id();"}, {"sha": "4786426792c3d2555dbbb3ab1c4cfa014e996308", "filename": "src/librustc_middle/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -181,6 +181,6 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n }\n \n fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n     def_id == hir_id.owner\n }"}, {"sha": "8860fe7ff9783f6c33d82a3f104d844b86ef4a7f", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -198,7 +198,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn as_local_hir_id(&self, def_id: LocalDefId) -> Option<HirId> {\n+    pub fn as_local_hir_id(&self, def_id: LocalDefId) -> HirId {\n         self.tcx.definitions.as_local_hir_id(def_id)\n     }\n \n@@ -449,7 +449,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_module(&self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n-        let hir_id = self.as_local_hir_id(module).unwrap();\n+        let hir_id = self.as_local_hir_id(module);\n         match self.get_entry(hir_id).node {\n             Node::Item(&Item { span, kind: ItemKind::Mod(ref m), .. }) => (m, span, hir_id),\n             Node::Crate(item) => (&item.module, item.span, hir_id),\n@@ -482,11 +482,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n-        if let Some(id) = id.as_local() {\n-            self.as_local_hir_id(id).map(|id| self.get(id))\n-        } else {\n-            None\n-        }\n+        if let Some(id) = id.as_local() { Some(self.get(self.as_local_hir_id(id))) } else { None }\n     }\n \n     pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics<'hir>> {\n@@ -887,11 +883,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n-        if let Some(id) = id.as_local() {\n-            self.as_local_hir_id(id).map(|id| self.span(id))\n-        } else {\n-            None\n-        }\n+        if let Some(id) = id.as_local() { Some(self.span(self.as_local_hir_id(id))) } else { None }\n     }\n \n     pub fn res_span(&self, res: Res) -> Option<Span> {\n@@ -1092,7 +1084,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n pub fn provide(providers: &mut Providers<'_>) {\n     providers.def_kind = |tcx, def_id| {\n         if let Some(def_id) = def_id.as_local() {\n-            tcx.hir().def_kind(tcx.hir().as_local_hir_id(def_id).unwrap())\n+            tcx.hir().def_kind(tcx.hir().as_local_hir_id(def_id))\n         } else {\n             bug!(\"calling local def_kind query provider for upstream DefId: {:?}\", def_id);\n         }"}, {"sha": "7ab66411b21093ab18d14deb91c7456407709e9c", "filename": "src/librustc_middle/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -68,13 +68,13 @@ impl<'tcx> TyCtxt<'tcx> {\n pub fn provide(providers: &mut Providers<'_>) {\n     providers.parent_module_from_def_id = |tcx, id| {\n         let hir = tcx.hir();\n-        hir.local_def_id(hir.get_module_parent_node(hir.as_local_hir_id(id).unwrap()))\n+        hir.local_def_id(hir.get_module_parent_node(hir.as_local_hir_id(id)))\n     };\n     providers.hir_crate = |tcx, _| tcx.untracked_crate;\n     providers.index_hir = map::index_hir;\n     providers.hir_module_items = |tcx, id| {\n         let hir = tcx.hir();\n-        let module = hir.as_local_hir_id(id).unwrap();\n+        let module = hir.as_local_hir_id(id);\n         &tcx.untracked_crate.modules[&module]\n     };\n     providers.hir_owner = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].signature;"}, {"sha": "c3eeea7662ba94517d647636acf2b7c268bf0d03", "filename": "src/librustc_middle/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -554,7 +554,7 @@ impl<'tcx> ScopeTree {\n     pub fn early_free_scope(&self, tcx: TyCtxt<'tcx>, br: &ty::EarlyBoundRegion) -> Scope {\n         let param_owner = tcx.parent(br.def_id).unwrap();\n \n-        let param_owner_id = tcx.hir().as_local_hir_id(param_owner.expect_local()).unwrap();\n+        let param_owner_id = tcx.hir().as_local_hir_id(param_owner.expect_local());\n         let scope = tcx\n             .hir()\n             .maybe_body_owned_by(param_owner_id)\n@@ -595,7 +595,7 @@ impl<'tcx> ScopeTree {\n         // on the same function that they ended up being freed in.\n         assert_eq!(param_owner, fr.scope);\n \n-        let param_owner_id = tcx.hir().as_local_hir_id(param_owner.expect_local()).unwrap();\n+        let param_owner_id = tcx.hir().as_local_hir_id(param_owner.expect_local());\n         let body_id = tcx.hir().body_owned_by(param_owner_id);\n         Scope { id: tcx.hir().body(body_id).value.hir_id.local_id, data: ScopeData::CallSite }\n     }"}, {"sha": "93b031c5d884da0ba4734fead679e20e26c5caca", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -2338,9 +2338,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }\n \n                     AggregateKind::Closure(def_id, substs) => ty::tls::with(|tcx| {\n-                        if let Some(hir_id) = def_id\n-                            .as_local()\n-                            .map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+                        if let Some(hir_id) =\n+                            def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n                         {\n                             let name = if tcx.sess.opts.debugging_opts.span_free_formats {\n                                 let substs = tcx.lift(&substs).unwrap();\n@@ -2367,9 +2366,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }),\n \n                     AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n-                        if let Some(hir_id) = def_id\n-                            .as_local()\n-                            .map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+                        if let Some(hir_id) =\n+                            def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n                         {\n                             let name = format!(\"[generator@{:?}]\", tcx.hir().span(hir_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);"}, {"sha": "fd1d410f0516079be5096df84519393608c0648c", "filename": "src/librustc_middle/mir/mono.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmono.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -198,10 +198,10 @@ impl<'tcx> MonoItem<'tcx> {\n     pub fn local_span(&self, tcx: TyCtxt<'tcx>) -> Option<Span> {\n         match *self {\n             MonoItem::Fn(Instance { def, .. }) => {\n-                def.def_id().as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+                def.def_id().as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n             }\n             MonoItem::Static(def_id) => {\n-                def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+                def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n             }\n             MonoItem::GlobalAsm(hir_id) => Some(hir_id),\n         }\n@@ -343,9 +343,9 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             // instances into account. The others don't matter for\n                             // the codegen tests and can even make item order\n                             // unstable.\n-                            InstanceDef::Item(def_id) => def_id\n-                                .as_local()\n-                                .map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap()),\n+                            InstanceDef::Item(def_id) => {\n+                                def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n+                            }\n                             InstanceDef::VtableShim(..)\n                             | InstanceDef::ReifyShim(..)\n                             | InstanceDef::Intrinsic(..)\n@@ -357,7 +357,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n                         }\n                     }\n                     MonoItem::Static(def_id) => {\n-                        def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+                        def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n                     }\n                     MonoItem::GlobalAsm(hir_id) => Some(hir_id),\n                 },"}, {"sha": "51bbb9016b6a2fd102dc32cf257c600295281e1b", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -277,7 +277,7 @@ rustc_queries! {\n         /// per-type-parameter predicates for resolving `T::AssocTy`.\n         query type_param_predicates(key: (DefId, DefId)) -> ty::GenericPredicates<'tcx> {\n             desc { |tcx| \"computing the bounds for type parameter `{}`\", {\n-                let id = tcx.hir().as_local_hir_id(key.1.expect_local()).unwrap();\n+                let id = tcx.hir().as_local_hir_id(key.1.expect_local());\n                 tcx.hir().ty_param_name(id)\n             }}\n         }"}, {"sha": "7797374259cb768296a8473e45e8574587afdb88", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -1413,8 +1413,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             _ => return None, // not a free region\n         };\n \n-        let hir_id =\n-            self.hir().as_local_hir_id(suitable_region_binding_scope.expect_local()).unwrap();\n+        let hir_id = self.hir().as_local_hir_id(suitable_region_binding_scope.expect_local());\n         let is_impl_item = match self.hir().find(hir_id) {\n             Some(Node::Item(..) | Node::TraitItem(..)) => false,\n             Some(Node::ImplItem(..)) => {\n@@ -1432,7 +1431,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn return_type_impl_trait(&self, scope_def_id: DefId) -> Option<(Ty<'tcx>, Span)> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return `None`.\n-        let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local()).unwrap();\n+        let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());\n         match self.hir().get(hir_id) {\n             Node::Item(item) => {\n                 match item.kind {"}, {"sha": "b785f79e1f35eb97c0b27667636964051369ab26", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -2669,12 +2669,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn opt_item_name(self, def_id: DefId) -> Option<Ident> {\n         def_id\n             .as_local()\n-            .and_then(|def_id| self.hir().get(self.hir().as_local_hir_id(def_id).unwrap()).ident())\n+            .and_then(|def_id| self.hir().get(self.hir().as_local_hir_id(def_id)).ident())\n     }\n \n     pub fn opt_associated_item(self, def_id: DefId) -> Option<AssocItem> {\n         let is_associated_item = if let Some(def_id) = def_id.as_local() {\n-            match self.hir().get(self.hir().as_local_hir_id(def_id).unwrap()) {\n+            match self.hir().get(self.hir().as_local_hir_id(def_id)) {\n                 Node::TraitItem(_) | Node::ImplItem(_) => true,\n                 _ => false,\n             }\n@@ -2827,7 +2827,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Gets the attributes of a definition.\n     pub fn get_attrs(self, did: DefId) -> Attributes<'tcx> {\n         if let Some(did) = did.as_local() {\n-            self.hir().attrs(self.hir().as_local_hir_id(did).unwrap())\n+            self.hir().attrs(self.hir().as_local_hir_id(did))\n         } else {\n             self.item_attrs(did)\n         }\n@@ -2866,7 +2866,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n         if let Some(impl_did) = impl_did.as_local() {\n-            let hir_id = self.hir().as_local_hir_id(impl_did).unwrap();\n+            let hir_id = self.hir().as_local_hir_id(impl_did);\n             Ok(self.hir().span(hir_id))\n         } else {\n             Err(self.crate_name(impl_did.krate))\n@@ -2927,7 +2927,7 @@ pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     if let Some(def_id) = def_id.as_local() {\n-        if let Node::Item(item) = tcx.hir().get(tcx.hir().as_local_hir_id(def_id).unwrap()) {\n+        if let Node::Item(item) = tcx.hir().get(tcx.hir().as_local_hir_id(def_id)) {\n             if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.kind {\n                 return opaque_ty.impl_trait_fn;\n             }"}, {"sha": "200ccf42c01fefba22cb8cb46a1813fa553e24fb", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -609,7 +609,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                 // FIXME(eddyb) should use `def_span`.\n                 if let Some(hir_id) =\n-                    did.as_local().map(|did| self.tcx().hir().as_local_hir_id(did).unwrap())\n+                    did.as_local().map(|did| self.tcx().hir().as_local_hir_id(did))\n                 {\n                     p!(write(\"@{:?}\", self.tcx().hir().span(hir_id)));\n \n@@ -655,7 +655,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                 // FIXME(eddyb) should use `def_span`.\n                 if let Some(hir_id) =\n-                    did.as_local().map(|did| self.tcx().hir().as_local_hir_id(did).unwrap())\n+                    did.as_local().map(|did| self.tcx().hir().as_local_hir_id(did))\n                 {\n                     if self.tcx().sess.opts.debugging_opts.span_free_formats {\n                         p!(write(\"@\"), print_def_path(did, substs));"}, {"sha": "ac5477edcc3c0c8a920b56ad1e69bd4bc03fc23d", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -2266,7 +2266,7 @@ impl<'tcx> Const<'tcx> {\n             ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {\n                 // Find the name and index of the const parameter by indexing the generics of\n                 // the parent item and construct a `ParamConst`.\n-                let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+                let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n                 let item_id = tcx.hir().get_parent_node(hir_id);\n                 let item_def_id = tcx.hir().local_def_id(item_id);\n                 let generics = tcx.generics_of(item_def_id.to_def_id());"}, {"sha": "ef66e96381fadc30f20b18f1d08bafbd60f4e7da", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -192,7 +192,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let needs_note = match ty.kind {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck_tables_of(id);\n-                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(id.expect_local()).unwrap();\n+                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(id.expect_local());\n \n                     tables.closure_kind_origins().get(hir_id).is_none()\n                 }\n@@ -867,7 +867,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if let Some(fn_hir_id) = self\n                 .mir_def_id\n                 .as_local()\n-                .map(|def_id| self.infcx.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                .map(|def_id| self.infcx.tcx.hir().as_local_hir_id(def_id))\n             {\n                 err.span_label(\n                     drop_span,\n@@ -1786,7 +1786,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n         debug!(\"annotate_fn_sig: did={:?} sig={:?}\", did, sig);\n         let is_closure = self.infcx.tcx.is_closure(did);\n-        let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(did.as_local()?)?;\n+        let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(did.as_local()?);\n         let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(fn_hir_id)?;\n \n         // We need to work out which arguments to highlight. We do this by looking"}, {"sha": "16c5bf1518dabe2bf30d8684c86de09c0af1e275", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -97,7 +97,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n                 if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind {\n-                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(did.expect_local()).unwrap();\n+                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(did.expect_local());\n \n                     if let Some((span, name)) =\n                         self.infcx.tcx.typeck_tables_of(did).closure_kind_origins().get(hir_id)\n@@ -119,7 +119,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Check if we are just moving a closure after it has been invoked.\n         if let Some(target) = target {\n             if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind {\n-                let hir_id = self.infcx.tcx.hir().as_local_hir_id(did.expect_local()).unwrap();\n+                let hir_id = self.infcx.tcx.hir().as_local_hir_id(did.expect_local());\n \n                 if let Some((span, name)) =\n                     self.infcx.tcx.typeck_tables_of(did).closure_kind_origins().get(hir_id)\n@@ -803,7 +803,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             \"closure_span: def_id={:?} target_place={:?} places={:?}\",\n             def_id, target_place, places\n         );\n-        let hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id.as_local()?)?;\n+        let hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id.as_local()?);\n         let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(.., body_id, args_span, _) = expr {"}, {"sha": "1a4876db0ded35181e338d3a2fb80648df76ec9a", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -492,7 +492,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err.span_label(sp, format!(\"cannot {}\", act));\n \n         let hir = self.infcx.tcx.hir();\n-        let closure_id = hir.as_local_hir_id(self.mir_def_id.expect_local()).unwrap();\n+        let closure_id = hir.as_local_hir_id(self.mir_def_id.expect_local());\n         let fn_call_id = hir.get_parent_node(closure_id);\n         let node = hir.get(fn_call_id);\n         let item_id = hir.get_parent_item(fn_call_id);\n@@ -691,7 +691,7 @@ fn annotate_struct_field(\n         if let ty::Adt(def, _) = ty.kind {\n             let field = def.all_fields().nth(field.index())?;\n             // Use the HIR types to construct the diagnostic message.\n-            let hir_id = tcx.hir().as_local_hir_id(field.did.as_local()?)?;\n+            let hir_id = tcx.hir().as_local_hir_id(field.did.as_local()?);\n             let node = tcx.hir().find(hir_id)?;\n             // Now we're dealing with the actual struct that we're going to suggest a change to,\n             // we can expect a field that is an immutable reference to a type."}, {"sha": "37e2e0475048d7007f661714175d2c17b7ff9cd5", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -237,12 +237,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 }\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_hir_id = self\n-                        .infcx\n-                        .tcx\n-                        .hir()\n-                        .as_local_hir_id(self.mir_def_id.expect_local())\n-                        .unwrap();\n+                    let mir_hir_id =\n+                        self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id.expect_local());\n                     let def_ty = self.regioncx.universal_regions().defining_ty;\n \n                     if let DefiningTy::Closure(_, substs) = def_ty {\n@@ -328,7 +324,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n     ) -> Option<RegionName> {\n-        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id.as_local()?)?;\n+        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id.as_local()?);\n         let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n         match argument_hir_ty.kind {\n@@ -639,7 +635,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id.expect_local()).unwrap();\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id.expect_local());\n \n         let (return_span, mir_description) = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n@@ -691,7 +687,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id.expect_local()).unwrap();\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id.expect_local());\n \n         let yield_span = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {"}, {"sha": "7c7251c913492e8b7a1e59dbd0e9b3830db93237", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -116,7 +116,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let tcx = infcx.tcx;\n     let param_env = tcx.param_env(def_id);\n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id);\n \n     let mut local_names = IndexVec::from_elem(None, &input_body.local_decls);\n     for var_debug_info in &input_body.var_debug_info {"}, {"sha": "e6099ba91922526019bf90d01fadb9537502f1df", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -224,7 +224,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         let tcx = infcx.tcx;\n-        let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).unwrap();\n+        let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id);\n         UniversalRegionsBuilder { infcx, mir_def_id: mir_def_id.to_def_id(), mir_hir_id, param_env }\n             .build()\n     }"}, {"sha": "6d0a02ee3a47f0b9c98c34c07ec0c317c3052ec5", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -342,7 +342,7 @@ pub fn const_eval_raw_provider<'tcx>(\n                     // validation thus preventing such a hard error from being a backwards\n                     // compatibility hazard\n                     Some(DefKind::Const | DefKind::AssocConst) => {\n-                        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+                        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n                         err.report_as_lint(\n                             tcx.at(tcx.def_span(def_id)),\n                             \"any use of this value will cause an error\",\n@@ -365,7 +365,7 @@ pub fn const_eval_raw_provider<'tcx>(\n                                 err.report_as_lint(\n                                     tcx.at(span),\n                                     \"reaching this expression at runtime will panic or abort\",\n-                                    tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap(),\n+                                    tcx.hir().as_local_hir_id(def_id.expect_local()),\n                                     Some(err.span),\n                                 )\n                             }"}, {"sha": "74f8a1cb6d1246627d1133cb90d5a2714b2cb725", "filename": "src/librustc_mir/const_eval/fn_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -90,7 +90,7 @@ pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n /// said intrinsic is on the whitelist for being const callable.\n fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n \n     let node = tcx.hir().get(hir_id);\n "}, {"sha": "802b8897bb983c33f2f135d0265cf47da53cd000", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -430,9 +430,7 @@ fn check_recursion_limit<'tcx>(\n     // infinite expansion.\n     if adjusted_recursion_depth > *tcx.sess.recursion_limit.get() {\n         let error = format!(\"reached the recursion limit while instantiating `{}`\", instance);\n-        if let Some(hir_id) =\n-            def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n-        {\n+        if let Some(hir_id) = def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id)) {\n             tcx.sess.span_fatal(tcx.hir().span(hir_id), &error);\n         } else {\n             tcx.sess.fatal(&error);"}, {"sha": "46a46aa5ae953aa288e12ef9231c53dc0995e6f6", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -72,7 +72,7 @@ impl ConstKind {\n     pub fn for_item(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Option<Self> {\n         use hir::BodyOwnerKind as HirKind;\n \n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id);\n \n         let mode = match tcx.hir().body_owner_kind(hir_id) {\n             HirKind::Closure => return None,"}, {"sha": "f9f32247c948703b9bd05120c8d962fdaf9fa36b", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -190,7 +190,7 @@ impl Validator<'a, 'mir, 'tcx> {\n             const_kind == Some(ConstKind::Static) && !tcx.has_attr(def_id, sym::thread_local);\n \n         if should_check_for_sync {\n-            let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+            let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n             check_return_ty_is_sync(tcx, &body, hir_id);\n         }\n     }"}, {"sha": "567fb61e0e8c9ebcf52e6dc69e7f01e2b00f5370", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -469,7 +469,7 @@ fn check_unused_unsafe(\n     used_unsafe: &FxHashSet<hir::HirId>,\n     unsafe_blocks: &mut Vec<(hir::HirId, bool)>,\n ) {\n-    let body_id = tcx.hir().maybe_body_owned_by(tcx.hir().as_local_hir_id(def_id).unwrap());\n+    let body_id = tcx.hir().maybe_body_owned_by(tcx.hir().as_local_hir_id(def_id));\n \n     let body_id = match body_id {\n         Some(body) => body,\n@@ -494,7 +494,7 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult\n \n     let param_env = tcx.param_env(def_id);\n \n-    let id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let (const_context, min_const_fn) = match tcx.hir().body_owner_kind(id) {\n         hir::BodyOwnerKind::Closure => (false, false),\n         hir::BodyOwnerKind::Fn => (is_const_fn(tcx, def_id), is_min_const_fn(tcx, def_id)),\n@@ -516,7 +516,7 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult\n }\n \n fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: DefId) {\n-    let lint_hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let lint_hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n \n     tcx.struct_span_lint_hir(SAFE_PACKED_BORROWS, lint_hir_id, tcx.def_span(def_id), |lint| {\n         // FIXME: when we make this a hard error, this should have its"}, {"sha": "92859577d79cd728d34eee54678bd31f62efad99", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -66,7 +66,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         }\n \n         use rustc_middle::hir::map::blocks::FnLikeNode;\n-        let hir_id = tcx.hir().as_local_hir_id(source.def_id().expect_local()).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(source.def_id().expect_local());\n \n         let is_fn_like = FnLikeNode::from_node(tcx.hir().get(hir_id)).is_some();\n         let is_assoc_const = match tcx.def_kind(source.def_id()) {"}, {"sha": "523d6a160287329b78f27395c959b777bb32b1be", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -69,7 +69,7 @@ impl Inliner<'tcx> {\n         let param_env = self.tcx.param_env(self.source.def_id()).with_reveal_all();\n \n         // Only do inlining into fn bodies.\n-        let id = self.tcx.hir().as_local_hir_id(self.source.def_id().expect_local()).unwrap();\n+        let id = self.tcx.hir().as_local_hir_id(self.source.def_id().expect_local());\n         if self.tcx.hir().body_owner_kind(id).is_fn_or_closure() && self.source.promoted.is_none() {\n             for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated() {\n                 if let Some(callsite) =\n@@ -94,14 +94,10 @@ impl Inliner<'tcx> {\n                     continue;\n                 }\n \n-                let callee_hir_id = self.tcx.hir().as_local_hir_id(callsite.callee.expect_local());\n-\n-                let callee_body = if let Some(callee_hir_id) = callee_hir_id {\n-                    let self_hir_id = self\n-                        .tcx\n-                        .hir()\n-                        .as_local_hir_id(self.source.def_id().expect_local())\n-                        .unwrap();\n+                let callee_body = if let Some(callee_def_id) = callsite.callee.as_local() {\n+                    let callee_hir_id = self.tcx.hir().as_local_hir_id(callee_def_id);\n+                    let self_hir_id =\n+                        self.tcx.hir().as_local_hir_id(self.source.def_id().expect_local());\n                     // Avoid a cycle here by only using `optimized_mir` only if we have\n                     // a lower `HirId` than the callee. This ensures that the callee will\n                     // not inline us. This trick only works without incremental compilation."}, {"sha": "a7217369bab37b538890bef5fb8dcf2d98d7cacd", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -13,7 +13,7 @@ type McfResult = Result<(), (Span, Cow<'static, str>)>;\n pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -> McfResult {\n     // Prevent const trait methods from being annotated as `stable`.\n     if tcx.features().staged_api {\n-        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n         if crate::const_eval::is_parent_const_impl_raw(tcx, hir_id) {\n             return Err((body.span, \"trait methods cannot be stable const fn\".into()));\n         }"}, {"sha": "c6eefcc5ecaf1e89be3f4fd6d86bb786f3492066", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -285,7 +285,7 @@ fn dump_matched_mir_node<'tcx>(\n ) {\n     let mut file_path = PathBuf::new();\n     file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n-    let item_id = tcx.hir().as_local_hir_id(source.def_id().expect_local()).unwrap();\n+    let item_id = tcx.hir().as_local_hir_id(source.def_id().expect_local());\n     let file_name = format!(\"rustc.node{}{}-liveness.mir\", item_id, pass_name);\n     file_path.push(&file_name);\n     let _ = fs::File::create(&file_path).and_then(|file| {"}, {"sha": "4dbe4bf7628e0f5e01b84961f053a707a6cd5fb8", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -27,7 +27,7 @@ crate fn mir_built(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::steal::Steal<Body<'_>\n \n /// Construct the MIR for a given `DefId`.\n fn mir_build(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Body<'_> {\n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id);\n \n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span) = match tcx.hir().get(id) {"}, {"sha": "0ef6d24d07b48120cbc6dbe5d22dd4e19995c25a", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -690,7 +690,7 @@ fn convert_path_expr<'a, 'tcx>(\n         }\n \n         Res::Def(DefKind::ConstParam, def_id) => {\n-            let hir_id = cx.tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+            let hir_id = cx.tcx.hir().as_local_hir_id(def_id.expect_local());\n             let item_id = cx.tcx.hir().get_parent_node(hir_id);\n             let item_def_id = cx.tcx.hir().local_def_id(item_id);\n             let generics = cx.tcx.generics_of(item_def_id);"}, {"sha": "c90634e511bb1f1f90eaa06ca2b3a55a2037bc79", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -23,7 +23,7 @@ use std::slice;\n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match def_id.as_local() {\n         None => return,\n-        Some(id) => tcx.hir().body_owned_by(tcx.hir().as_local_hir_id(id).unwrap()),\n+        Some(id) => tcx.hir().body_owned_by(tcx.hir().as_local_hir_id(id)),\n     };\n \n     let mut visitor ="}, {"sha": "38f5df3e70557bd3d130b3f379724211a06e918f", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -11,7 +11,7 @@ use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n use rustc_span::Span;\n \n crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(hir_id)) {\n         if let FnKind::Closure(_) = fn_like_node.kind() {\n@@ -37,7 +37,7 @@ crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n \n         vis.reachable_recursive_calls.sort();\n \n-        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n         let sp = tcx.sess.source_map().guess_head_span(tcx.hir().span(hir_id));\n         tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION, hir_id, sp, |lint| {\n             let mut db = lint.build(\"function cannot return without recursing\");"}, {"sha": "261386f70d9453a8f4ee47951c724c8bae079902", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -53,7 +53,7 @@ struct MarkSymbolVisitor<'a, 'tcx> {\n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn check_def_id(&mut self, def_id: DefId) {\n         if let Some(def_id) = def_id.as_local() {\n-            let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+            let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n             if should_explore(self.tcx, hir_id) || self.struct_constructors.contains_key(&hir_id) {\n                 self.worklist.push(hir_id);\n             }\n@@ -63,7 +63,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn insert_def_id(&mut self, def_id: DefId) {\n         if let Some(def_id) = def_id.as_local() {\n-            let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+            let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n             debug_assert!(!should_explore(self.tcx, hir_id));\n             self.live_symbols.insert(hir_id);\n         }\n@@ -453,7 +453,7 @@ fn create_and_seed_worklist<'tcx>(\n         .chain(\n             // Seed entry point\n             tcx.entry_fn(LOCAL_CRATE)\n-                .map(|(def_id, _)| tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap()),\n+                .map(|(def_id, _)| tcx.hir().as_local_hir_id(def_id.expect_local())),\n         )\n         .collect::<Vec<_>>();\n \n@@ -538,7 +538,7 @@ impl DeadVisitor<'tcx> {\n         for &impl_did in inherent_impls.iter() {\n             for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n                 if let Some(item_hir_id) =\n-                    item_did.as_local().map(|did| self.tcx.hir().as_local_hir_id(did).unwrap())\n+                    item_did.as_local().map(|did| self.tcx.hir().as_local_hir_id(did))\n                 {\n                     if self.live_symbols.contains(&item_hir_id) {\n                         return true;"}, {"sha": "d913486cb0e1890745387692110154918f452d5e", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -53,13 +53,9 @@ fn method_might_be_inlined(\n             return true;\n         }\n     }\n-    if let Some(impl_hir_id) = tcx.hir().as_local_hir_id(impl_src) {\n-        match tcx.hir().find(impl_hir_id) {\n-            Some(Node::Item(item)) => item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n-            Some(..) | None => span_bug!(impl_item.span, \"impl did is not an item\"),\n-        }\n-    } else {\n-        span_bug!(impl_item.span, \"found a foreign impl as a parent of a local method\")\n+    match tcx.hir().find(tcx.hir().as_local_hir_id(impl_src)) {\n+        Some(Node::Item(item)) => item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n+        Some(..) | None => span_bug!(impl_item.span, \"impl did is not an item\"),\n     }\n }\n \n@@ -108,9 +104,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n             }\n             Some(res) => {\n                 if let Some((hir_id, def_id)) = res.opt_def_id().and_then(|def_id| {\n-                    def_id\n-                        .as_local()\n-                        .map(|def_id| (self.tcx.hir().as_local_hir_id(def_id).unwrap(), def_id))\n+                    def_id.as_local().map(|def_id| (self.tcx.hir().as_local_hir_id(def_id), def_id))\n                 }) {\n                     if self.def_id_represents_local_inlined_item(def_id.to_def_id()) {\n                         self.worklist.push(hir_id);\n@@ -144,7 +138,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n         let hir_id = match def_id.as_local() {\n-            Some(def_id) => self.tcx.hir().as_local_hir_id(def_id).unwrap(),\n+            Some(def_id) => self.tcx.hir().as_local_hir_id(def_id),\n             None => {\n                 return false;\n             }\n@@ -176,7 +170,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n-                            let impl_hir_id = self.tcx.hir().as_local_hir_id(impl_did).unwrap();\n+                            let impl_hir_id = self.tcx.hir().as_local_hir_id(impl_did);\n                             match self.tcx.hir().expect_item(impl_hir_id).kind {\n                                 hir::ItemKind::Impl { .. } => {\n                                     let generics = self.tcx.generics_of(impl_did);\n@@ -362,9 +356,8 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n                 // FIXME(#53488) remove `let`\n                 let tcx = self.tcx;\n                 self.worklist.extend(\n-                    tcx.provided_trait_methods(trait_def_id).map(|assoc| {\n-                        tcx.hir().as_local_hir_id(assoc.def_id.expect_local()).unwrap()\n-                    }),\n+                    tcx.provided_trait_methods(trait_def_id)\n+                        .map(|assoc| tcx.hir().as_local_hir_id(assoc.def_id.expect_local())),\n                 );\n             }\n         }\n@@ -403,8 +396,7 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet\n     reachable_context.worklist.extend(access_levels.map.iter().map(|(id, _)| *id));\n     for item in tcx.lang_items().items().iter() {\n         if let Some(did) = *item {\n-            if let Some(hir_id) = did.as_local().map(|did| tcx.hir().as_local_hir_id(did).unwrap())\n-            {\n+            if let Some(hir_id) = did.as_local().map(|did| tcx.hir().as_local_hir_id(did)) {\n                 reachable_context.worklist.push(hir_id);\n             }\n         }"}, {"sha": "927e6a7e712b5da783d157b724edce42ead2043c", "filename": "src/librustc_passes/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_passes%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_passes%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fregion.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -807,7 +807,7 @@ fn region_scope_tree(tcx: TyCtxt<'_>, def_id: DefId) -> &ScopeTree {\n         return tcx.region_scope_tree(closure_base_def_id);\n     }\n \n-    let id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx,"}, {"sha": "fb986caa415c9d62a62e6ac9ca573dc8c0dcd82c", "filename": "src/librustc_passes/upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_passes%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_passes%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fupvars.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -15,7 +15,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n             return None;\n         }\n \n-        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n         let body = tcx.hir().body(tcx.hir().maybe_body_owned_by(hir_id)?);\n \n         let mut local_collector = LocalCollector::default();"}, {"sha": "7e1a53d4c3f13cd3a97c75e9df08da44a50f857b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -235,7 +235,7 @@ fn def_id_visibility<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n ) -> (ty::Visibility, Span, &'static str) {\n-    match def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap()) {\n+    match def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id)) {\n         Some(hir_id) => {\n             let vis = match tcx.hir().get(hir_id) {\n                 Node::Item(item) => &item.vis,\n@@ -446,7 +446,7 @@ impl VisibilityLike for Option<AccessLevel> {\n     fn new_min(find: &FindMin<'_, '_, Self>, def_id: DefId) -> Self {\n         cmp::min(\n             if let Some(hir_id) =\n-                def_id.as_local().map(|def_id| find.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                def_id.as_local().map(|def_id| find.tcx.hir().as_local_hir_id(def_id))\n             {\n                 find.access_levels.map.get(&hir_id).cloned()\n             } else {\n@@ -549,9 +549,8 @@ impl EmbargoVisitor<'tcx> {\n                 if export.vis.is_accessible_from(defining_mod, self.tcx) {\n                     if let Res::Def(def_kind, def_id) = export.res {\n                         let vis = def_id_visibility(self.tcx, def_id).0;\n-                        if let Some(hir_id) = def_id\n-                            .as_local()\n-                            .map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                        if let Some(hir_id) =\n+                            def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n                         {\n                             self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n                         }\n@@ -660,7 +659,7 @@ impl EmbargoVisitor<'tcx> {\n                 // there will be no corresponding item.\n                 .filter(|def_id| def_id.index != CRATE_DEF_INDEX || def_id.krate != LOCAL_CRATE)\n                 .and_then(|def_id| {\n-                    def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                    def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n                 })\n                 .map(|module_hir_id| self.tcx.hir().expect_item(module_hir_id))\n             {\n@@ -917,7 +916,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                         if let Some(def_id) = export.res.opt_def_id() {\n                             if let Some(hir_id) = def_id\n                                 .as_local()\n-                                .map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                                .map(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n                             {\n                                 self.update(hir_id, Some(AccessLevel::Exported));\n                             }\n@@ -1007,7 +1006,7 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n     }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n         if let Some(def_id) = def_id.as_local() {\n-            let hir_id = self.ev.tcx.hir().as_local_hir_id(def_id).unwrap();\n+            let hir_id = self.ev.tcx.hir().as_local_hir_id(def_id);\n             if let ((ty::Visibility::Public, ..), _)\n             | (_, Some(AccessLevel::ReachableFromImplTrait)) =\n                 (def_id_visibility(self.tcx(), def_id.to_def_id()), self.access_level)\n@@ -1457,7 +1456,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         if let Some(did) = did.as_local() {\n             // .. and it corresponds to a private type in the AST (this returns\n             // `None` for type parameters).\n-            match self.tcx.hir().find(self.tcx.hir().as_local_hir_id(did).unwrap()) {\n+            match self.tcx.hir().find(self.tcx.hir().as_local_hir_id(did)) {\n                 Some(Node::Item(ref item)) => !item.vis.node.is_pub(),\n                 Some(_) | None => false,\n             }\n@@ -1576,7 +1575,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                         let did = tr.path.res.def_id();\n \n                         if let Some(did) = did.as_local() {\n-                            self.trait_is_public(self.tcx.hir().as_local_hir_id(did).unwrap())\n+                            self.trait_is_public(self.tcx.hir().as_local_hir_id(did))\n                         } else {\n                             true // external traits must be public\n                         }\n@@ -1837,7 +1836,7 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n         }\n \n         let hir_id = match def_id.as_local() {\n-            Some(def_id) => self.tcx.hir().as_local_hir_id(def_id).unwrap(),\n+            Some(def_id) => self.tcx.hir().as_local_hir_id(def_id),\n             None => return false,\n         };\n "}, {"sha": "8d9110f9a57dd4cf914fb1e37983b43fd54bea4e", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -598,7 +598,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         if let Some(Region::LateBound(_, def_id, _)) = def {\n                             if let Some(hir_id) = def_id\n                                 .as_local()\n-                                .map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                                .map(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n                             {\n                                 // Ensure that the parent of the def is an item, not HRTB\n                                 let parent_id = self.tcx.hir().get_parent_node(hir_id);\n@@ -1169,8 +1169,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n                     if let Some(def) =\n                         lifetimes.get(&hir::ParamName::Plain(label.normalize_to_macros_2_0()))\n                     {\n-                        let hir_id =\n-                            tcx.hir().as_local_hir_id(def.id().unwrap().expect_local()).unwrap();\n+                        let hir_id = tcx.hir().as_local_hir_id(def.id().unwrap().expect_local());\n \n                         signal_shadowing_problem(\n                             tcx,\n@@ -1541,7 +1540,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             match lifetimeuseset {\n                 Some(LifetimeUseSet::One(lifetime)) => {\n-                    let hir_id = self.tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+                    let hir_id = self.tcx.hir().as_local_hir_id(def_id.expect_local());\n                     debug!(\"hir id first={:?}\", hir_id);\n                     if let Some((id, span, name)) = match self.tcx.hir().get(hir_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n@@ -1562,7 +1561,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         if let Some(parent_def_id) = self.tcx.parent(def_id) {\n                             if let Some(parent_hir_id) = parent_def_id\n                                 .as_local()\n-                                .map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                                .map(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n                             {\n                                 // lifetimes in `derive` expansions don't count (Issue #53738)\n                                 if self\n@@ -1605,7 +1604,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     debug!(\"not one use lifetime\");\n                 }\n                 None => {\n-                    let hir_id = self.tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+                    let hir_id = self.tcx.hir().as_local_hir_id(def_id.expect_local());\n                     if let Some((id, span, name)) = match self.tcx.hir().get(hir_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n                             hir_lifetime.hir_id,\n@@ -1961,7 +1960,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             let map = &self.map;\n             let unsubst = if let Some(id) =\n-                def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n             {\n                 &map.object_lifetime_defaults[&id]\n             } else {\n@@ -2668,11 +2667,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Binder { ref lifetimes, s, .. } => {\n                     if let Some(&def) = lifetimes.get(&param.name.normalize_to_macros_2_0()) {\n-                        let hir_id = self\n-                            .tcx\n-                            .hir()\n-                            .as_local_hir_id(def.id().unwrap().expect_local())\n-                            .unwrap();\n+                        let hir_id =\n+                            self.tcx.hir().as_local_hir_id(def.id().unwrap().expect_local());\n \n                         signal_shadowing_problem(\n                             self.tcx,"}, {"sha": "5a1c6491f86d812ad3f336eb34f51c0a05214f93", "filename": "src/librustc_symbol_mangling/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_symbol_mangling%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_symbol_mangling%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Flib.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -175,7 +175,7 @@ fn compute_symbol_name(\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n             return tcx.sess.generate_proc_macro_decls_symbol(disambiguator);\n         }\n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id);\n         match tcx.hir().get(hir_id) {\n             Node::ForeignItem(_) => true,\n             _ => false,"}, {"sha": "8af9d7ea90488aa5a15ed0427f9aef3ceb382574", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -1037,7 +1037,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     // }\n                     // ```\n                     if let Some(opaque_hir_id) =\n-                        def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+                        def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n                     {\n                         let parent_def_id = self.parent_def_id;\n                         let def_scope_default = || {\n@@ -1219,7 +1219,7 @@ pub fn may_define_opaque_type(\n     def_id: LocalDefId,\n     opaque_hir_id: hir::HirId,\n ) -> bool {\n-    let mut hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let mut hir_id = tcx.hir().as_local_hir_id(def_id);\n \n     // Named opaque types can be defined by any siblings or children of siblings.\n     let scope = tcx.hir().get_defining_scope(opaque_hir_id);"}, {"sha": "fa9f1c9a7d97a8291ea1cd4c797960c236f0c13f", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -507,8 +507,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             self.tcx.sess.source_map().guess_head_span(\n                                 self.tcx.hir().span_if_local(closure_def_id).unwrap(),\n                             );\n-                        let hir_id =\n-                            self.tcx.hir().as_local_hir_id(closure_def_id.expect_local()).unwrap();\n+                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id.expect_local());\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n                             closure_span,"}, {"sha": "88b9d257795f79f775f6a93ad49dfba834fcaa2c", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -430,7 +430,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             };\n \n         let hir = self.tcx.hir();\n-        let hir_id = hir.as_local_hir_id(def_id.as_local()?)?;\n+        let hir_id = hir.as_local_hir_id(def_id.as_local()?);\n         let parent_node = hir.get_parent_node(hir_id);\n         match hir.find(parent_node) {\n             Some(hir::Node::Stmt(hir::Stmt { kind: hir::StmtKind::Local(local), .. })) => {\n@@ -1237,7 +1237,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         let generator_body = generator_did\n             .as_local()\n-            .map(|def_id| hir.as_local_hir_id(def_id).unwrap())\n+            .map(|def_id| hir.as_local_hir_id(def_id))\n             .and_then(|hir_id| hir.maybe_body_owned_by(hir_id))\n             .map(|body_id| hir.body(body_id));\n         let mut visitor = AwaitsVisitor::default();\n@@ -1388,7 +1388,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             .tcx\n                             .parent(generator_did)\n                             .and_then(|parent_did| parent_did.as_local())\n-                            .and_then(|parent_did| hir.as_local_hir_id(parent_did))\n+                            .map(|parent_did| hir.as_local_hir_id(parent_did))\n                             .and_then(|parent_hir_id| hir.opt_name(parent_hir_id))\n                             .map(|name| {\n                                 format!(\"future returned by `{}` is not {}\", name, trait_name)"}, {"sha": "61583669c6b5caf9a6b2ed4607e58cf314d877b6", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -452,7 +452,7 @@ fn report_conflicting_impls(\n             };\n             tcx.struct_span_lint_hir(\n                 lint,\n-                tcx.hir().as_local_hir_id(impl_def_id).unwrap(),\n+                tcx.hir().as_local_hir_id(impl_def_id),\n                 impl_span,\n                 decorate,\n             )"}, {"sha": "e7fa245fd4055fb55373bd98916f7b534ed75b2a", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -174,7 +174,7 @@ crate fn environment(tcx: TyCtxt<'_>, def_id: DefId) -> Environment<'_> {\n         // could bound lifetimes.\n         .map(Clause::ForAll);\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let node = tcx.hir().get(hir_id);\n \n     enum NodeKind {"}, {"sha": "16f395a4fec8dcbf3dc17649990d0c56dba8a4d5", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -128,7 +128,7 @@ fn associated_item_from_impl_item_ref(\n }\n \n fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n-    let id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let parent_id = tcx.hir().get_parent_item(id);\n     let parent_def_id = tcx.hir().local_def_id(parent_id);\n     let parent_item = tcx.hir().expect_item(parent_id);\n@@ -166,7 +166,7 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n }\n \n fn impl_defaultness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Defaultness {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let item = tcx.hir().expect_item(hir_id);\n     if let hir::ItemKind::Impl { defaultness, .. } = item.kind {\n         defaultness\n@@ -200,7 +200,7 @@ fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtSizedConstrain\n }\n \n fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n-    let id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let item = tcx.hir().expect_item(id);\n     match item.kind {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n@@ -267,7 +267,7 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n \n     let body_id = def_id\n         .as_local()\n-        .map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+        .map(|def_id| tcx.hir().as_local_hir_id(def_id))\n         .map_or(hir::CRATE_HIR_ID, |id| {\n             tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)\n         });\n@@ -355,7 +355,7 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n \n /// Check if a function is async.\n fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n \n     let node = tcx.hir().get(hir_id);\n "}, {"sha": "63b8eb224cec26f3966bd6c89c0d42843807b809", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -147,7 +147,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         def: Option<&ty::GenericParamDef>,\n     ) -> ty::Region<'tcx> {\n         let tcx = self.tcx();\n-        let lifetime_name = |def_id| tcx.hir().name(tcx.hir().as_local_hir_id(def_id).unwrap());\n+        let lifetime_name = |def_id| tcx.hir().name(tcx.hir().as_local_hir_id(def_id));\n \n         let r = match tcx.named_region(lifetime.hir_id) {\n             Some(rl::Region::Static) => tcx.lifetimes.re_static,\n@@ -1990,7 +1990,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"find_bound_for_assoc_item: predicates={:#?}\", predicates);\n \n-        let param_hir_id = tcx.hir().as_local_hir_id(ty_param_def_id).unwrap();\n+        let param_hir_id = tcx.hir().as_local_hir_id(ty_param_def_id);\n         let param_name = tcx.hir().ty_param_name(param_hir_id);\n         self.one_bound_for_assoc_type(\n             || {\n@@ -2374,7 +2374,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             let parent_def_id = def_id\n                 .and_then(|def_id| {\n-                    def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+                    def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n                 })\n                 .map(|hir_id| tcx.hir().get_parent_did(hir_id).to_def_id());\n \n@@ -2669,7 +2669,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(path.segments);\n \n-                let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+                let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n                 let item_id = tcx.hir().get_parent_node(hir_id);\n                 let item_def_id = tcx.hir().local_def_id(item_id);\n                 let generics = tcx.generics_of(item_def_id);"}, {"sha": "8070ad1712025a6758bdb5285a099dd689eb28e2", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -1393,7 +1393,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 let ty = AstConv::ast_ty_to_ty(fcx, ty);\n                 // Get the `impl Trait`'s `DefId`.\n                 if let ty::Opaque(def_id, _) = ty.kind {\n-                    let hir_id = fcx.tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+                    let hir_id = fcx.tcx.hir().as_local_hir_id(def_id.expect_local());\n                     // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n                     // get the `Trait`'s `DefId`.\n                     if let hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }) ="}, {"sha": "f834f74d5df18e76b15e2fa431824cc36f483f50", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -76,7 +76,7 @@ fn compare_predicate_entailment<'tcx>(\n     // This node-id should be used for the `body_id` field on each\n     // `ObligationCause` (and the `FnCtxt`). This is what\n     // `regionck_item` expects.\n-    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id.expect_local()).unwrap();\n+    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id.expect_local());\n \n     let cause = ObligationCause {\n         span: impl_m_span,\n@@ -399,7 +399,7 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n     trait_sig: ty::FnSig<'tcx>,\n ) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n-    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id.expect_local()).unwrap();\n+    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id.expect_local());\n     let (impl_m_output, impl_m_iter) = match tcx.hir().expect_impl_item(impl_m_hir_id).kind {\n         ImplItemKind::Fn(ref impl_m_sig, _) => {\n             (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter())\n@@ -410,7 +410,7 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n     match *terr {\n         TypeError::Mutability => {\n             if let Some(trait_m_hir_id) =\n-                trait_m.def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+                trait_m.def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n             {\n                 let trait_m_iter = match tcx.hir().expect_trait_item(trait_m_hir_id).kind {\n                     TraitItemKind::Fn(ref trait_m_sig, _) => trait_m_sig.decl.inputs.iter(),\n@@ -439,7 +439,7 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n         }\n         TypeError::Sorts(ExpectedFound { .. }) => {\n             if let Some(trait_m_hir_id) =\n-                trait_m.def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+                trait_m.def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n             {\n                 let (trait_m_output, trait_m_iter) =\n                     match tcx.hir().expect_trait_item(trait_m_hir_id).kind {\n@@ -592,7 +592,7 @@ fn compare_number_of_generics<'tcx>(\n             err_occurred = true;\n \n             let (trait_spans, impl_trait_spans) = if let Some(trait_hir_id) =\n-                trait_.def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+                trait_.def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n             {\n                 let trait_item = tcx.hir().expect_trait_item(trait_hir_id);\n                 if trait_item.generics.params.is_empty() {\n@@ -618,7 +618,7 @@ fn compare_number_of_generics<'tcx>(\n                 (trait_span.map(|s| vec![s]), vec![])\n             };\n \n-            let impl_hir_id = tcx.hir().as_local_hir_id(impl_.def_id.expect_local()).unwrap();\n+            let impl_hir_id = tcx.hir().as_local_hir_id(impl_.def_id.expect_local());\n             let impl_item = tcx.hir().expect_impl_item(impl_hir_id);\n             let impl_item_impl_trait_spans: Vec<Span> = impl_item\n                 .generics\n@@ -710,7 +710,7 @@ fn compare_number_of_method_arguments<'tcx>(\n     let impl_number_args = impl_m_fty.inputs().skip_binder().len();\n     if trait_number_args != impl_number_args {\n         let trait_span = if let Some(def_id) = trait_m.def_id.as_local() {\n-            let trait_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+            let trait_id = tcx.hir().as_local_hir_id(def_id);\n             match tcx.hir().expect_trait_item(trait_id).kind {\n                 TraitItemKind::Fn(ref trait_m_sig, _) => {\n                     let pos = if trait_number_args > 0 { trait_number_args - 1 } else { 0 };\n@@ -733,7 +733,7 @@ fn compare_number_of_method_arguments<'tcx>(\n         } else {\n             trait_item_span\n         };\n-        let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id.expect_local()).unwrap();\n+        let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id.expect_local());\n         let impl_span = match tcx.hir().expect_impl_item(impl_m_hir_id).kind {\n             ImplItemKind::Fn(ref impl_m_sig, _) => {\n                 let pos = if impl_number_args > 0 { impl_number_args - 1 } else { 0 };\n@@ -815,7 +815,7 @@ fn compare_synthetic_generics<'tcx>(\n         impl_m_type_params.zip(trait_m_type_params)\n     {\n         if impl_synthetic != trait_synthetic {\n-            let impl_hir_id = tcx.hir().as_local_hir_id(impl_def_id.expect_local()).unwrap();\n+            let impl_hir_id = tcx.hir().as_local_hir_id(impl_def_id.expect_local());\n             let impl_span = tcx.hir().span(impl_hir_id);\n             let trait_span = tcx.def_span(trait_def_id);\n             let mut err = struct_span_err!(\n@@ -836,10 +836,10 @@ fn compare_synthetic_generics<'tcx>(\n                         // FIXME: this is obviously suboptimal since the name can already be used\n                         // as another generic argument\n                         let new_name = tcx.sess.source_map().span_to_snippet(trait_span).ok()?;\n-                        let trait_m = tcx.hir().as_local_hir_id(trait_m.def_id.as_local()?)?;\n+                        let trait_m = tcx.hir().as_local_hir_id(trait_m.def_id.as_local()?);\n                         let trait_m = tcx.hir().trait_item(hir::TraitItemId { hir_id: trait_m });\n \n-                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id.as_local()?)?;\n+                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id.as_local()?);\n                         let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n \n                         // in case there are no generics, take the spot between the function name\n@@ -873,7 +873,7 @@ fn compare_synthetic_generics<'tcx>(\n                 (None, Some(hir::SyntheticTyParamKind::ImplTrait)) => {\n                     err.span_label(impl_span, \"expected `impl Trait`, found generic parameter\");\n                     (|| {\n-                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id.as_local()?)?;\n+                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id.as_local()?);\n                         let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n                         let input_tys = match impl_m.kind {\n                             hir::ImplItemKind::Fn(ref sig, _) => sig.decl.inputs,\n@@ -966,7 +966,7 @@ crate fn compare_const_impl<'tcx>(\n \n         // Create a parameter environment that represents the implementation's\n         // method.\n-        let impl_c_hir_id = tcx.hir().as_local_hir_id(impl_c.def_id.expect_local()).unwrap();\n+        let impl_c_hir_id = tcx.hir().as_local_hir_id(impl_c.def_id.expect_local());\n \n         // Compute placeholder form of impl and trait const tys.\n         let impl_ty = tcx.type_of(impl_c.def_id);\n@@ -1011,7 +1011,7 @@ crate fn compare_const_impl<'tcx>(\n             );\n \n             let trait_c_hir_id =\n-                trait_c.def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap());\n+                trait_c.def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id));\n             let trait_c_span = trait_c_hir_id.map(|trait_c_hir_id| {\n                 // Add a label to the Span containing just the type of the const\n                 match tcx.hir().expect_trait_item(trait_c_hir_id).kind {\n@@ -1099,7 +1099,7 @@ fn compare_type_predicate_entailment(\n     // This `HirId` should be used for the `body_id` field on each\n     // `ObligationCause` (and the `FnCtxt`). This is what\n     // `regionck_item` expects.\n-    let impl_ty_hir_id = tcx.hir().as_local_hir_id(impl_ty.def_id.expect_local()).unwrap();\n+    let impl_ty_hir_id = tcx.hir().as_local_hir_id(impl_ty.def_id.expect_local());\n     let cause = ObligationCause {\n         span: impl_ty_span,\n         body_id: impl_ty_hir_id,"}, {"sha": "078401ee6a81526aa86afddeaf0ed3b27cabf383", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -71,7 +71,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     drop_impl_ty: Ty<'tcx>,\n     self_type_did: DefId,\n ) -> Result<(), ErrorReported> {\n-    let drop_impl_hir_id = tcx.hir().as_local_hir_id(drop_impl_did).unwrap();\n+    let drop_impl_hir_id = tcx.hir().as_local_hir_id(drop_impl_did);\n \n     // check that the impl type can be made to match the trait type.\n \n@@ -190,7 +190,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     // absent. So we report an error that the Drop impl injected a\n     // predicate that is not present on the struct definition.\n \n-    let self_type_hir_id = tcx.hir().as_local_hir_id(self_type_did).unwrap();\n+    let self_type_hir_id = tcx.hir().as_local_hir_id(self_type_did);\n \n     // We can assume the predicates attached to struct/enum definition\n     // hold."}, {"sha": "2bca5e7582526bb086ba9edfd0cb665cd47cf892", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -1626,7 +1626,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         let param_def_id = generic_param.def_id;\n         let param_hir_id = match param_def_id.as_local() {\n-            Some(x) => self.tcx.hir().as_local_hir_id(x).unwrap(),\n+            Some(x) => self.tcx.hir().as_local_hir_id(x),\n             None => return,\n         };\n         let param_span = self.tcx.hir().span(param_hir_id);"}, {"sha": "dc94a57882da791c28461f320f2128a6c4f62a16", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -580,9 +580,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             {\n                                 if let ty::Adt(def, _) = p.skip_binder().trait_ref.self_ty().kind {\n                                     let node = def.did.as_local().map(|def_id| {\n-                                        self.tcx\n-                                            .hir()\n-                                            .get(self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                                        self.tcx.hir().get(self.tcx.hir().as_local_hir_id(def_id))\n                                     });\n                                     if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n                                         if let Some(g) = kind.generics() {\n@@ -857,7 +855,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         candidates: Vec<DefId>,\n     ) {\n         let module_did = self.tcx.parent_module(self.body_id);\n-        let module_id = self.tcx.hir().as_local_hir_id(module_did).unwrap();\n+        let module_id = self.tcx.hir().as_local_hir_id(module_did);\n         let krate = self.tcx.hir().krate();\n         let (span, found_use) = UsePlacementFinder::check(self.tcx, krate, module_id);\n         if let Some(span) = span {\n@@ -961,7 +959,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .filter(|item| {\n                                 if let ty::AssocKind::Fn = item.kind {\n                                     let id = item.def_id.as_local().map(|def_id| {\n-                                        self.tcx.hir().as_local_hir_id(def_id).unwrap()\n+                                        self.tcx.hir().as_local_hir_id(def_id)\n                                     });\n                                     if let Some(hir::Node::TraitItem(hir::TraitItem {\n                                         kind: hir::TraitItemKind::Fn(fn_sig, method),\n@@ -1054,10 +1052,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let generics = self.tcx.generics_of(table_owner.to_def_id());\n                     let type_param = generics.type_param(param, self.tcx);\n                     let hir = &self.tcx.hir();\n-                    if let Some(id) = type_param\n-                        .def_id\n-                        .as_local()\n-                        .map(|def_id| hir.as_local_hir_id(def_id).unwrap())\n+                    if let Some(id) =\n+                        type_param.def_id.as_local().map(|def_id| hir.as_local_hir_id(def_id))\n                     {\n                         // Get the `hir::Param` to verify whether it already has any bounds.\n                         // We do this to avoid suggesting code that ends up as `T: FooBar`,"}, {"sha": "51e3bc4cae406ba97184d1749857f9bfe8b5f61c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -977,7 +977,7 @@ fn diagnostic_only_typeck_tables_of<'tcx>(\n ) -> &ty::TypeckTables<'tcx> {\n     assert!(def_id.is_local());\n     let fallback = move || {\n-        let span = tcx.hir().span(tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap());\n+        let span = tcx.hir().span(tcx.hir().as_local_hir_id(def_id.expect_local()));\n         tcx.sess.delay_span_bug(span, \"diagnostic only typeck table used\");\n         tcx.types.err\n     };\n@@ -996,7 +996,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n         return tcx.typeck_tables_of(outer_def_id);\n     }\n \n-    let id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let span = tcx.hir().span(id);\n \n     // Figure out what primary body this item has.\n@@ -1333,7 +1333,7 @@ fn check_fn<'a, 'tcx>(\n     }\n \n     let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id).to_def_id());\n-    let outer_hir_id = hir.as_local_hir_id(outer_def_id.expect_local()).unwrap();\n+    let outer_hir_id = hir.as_local_hir_id(outer_def_id.expect_local());\n     GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id }.visit_body(body);\n \n     // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n@@ -1448,7 +1448,7 @@ fn check_fn<'a, 'tcx>(\n     // Check that the main return type implements the termination trait.\n     if let Some(term_id) = tcx.lang_items().termination() {\n         if let Some((def_id, EntryFnType::Main)) = tcx.entry_fn(LOCAL_CRATE) {\n-            let main_id = hir.as_local_hir_id(def_id.expect_local()).unwrap();\n+            let main_id = hir.as_local_hir_id(def_id.expect_local());\n             if main_id == fn_id {\n                 let substs = tcx.mk_substs_trait(declared_ret_ty, &[]);\n                 let trait_ref = ty::TraitRef::new(term_id, substs);\n@@ -1626,7 +1626,7 @@ fn check_opaque<'tcx>(\n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n /// in \"inheriting lifetimes\".\n fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n-    let item = tcx.hir().expect_item(tcx.hir().as_local_hir_id(def_id).unwrap());\n+    let item = tcx.hir().expect_item(tcx.hir().as_local_hir_id(def_id));\n     debug!(\n         \"check_opaque_for_inheriting_lifetimes: def_id={:?} span={:?} item={:?}\",\n         def_id, span, item\n@@ -2460,34 +2460,32 @@ fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: &ty::AdtDef) {\n                 );\n \n                 let hir = tcx.hir();\n-                if let Some(hir_id) = hir.as_local_hir_id(def_spans[0].0.expect_local()) {\n-                    if let Node::Item(Item { ident, .. }) = hir.get(hir_id) {\n-                        err.span_note(\n-                            tcx.def_span(def_spans[0].0),\n-                            &format!(\"`{}` has a `#[repr(align)]` attribute\", ident),\n-                        );\n-                    }\n+                let hir_id = hir.as_local_hir_id(def_spans[0].0.expect_local());\n+                if let Node::Item(Item { ident, .. }) = hir.get(hir_id) {\n+                    err.span_note(\n+                        tcx.def_span(def_spans[0].0),\n+                        &format!(\"`{}` has a `#[repr(align)]` attribute\", ident),\n+                    );\n                 }\n \n                 if def_spans.len() > 2 {\n                     let mut first = true;\n                     for (adt_def, span) in def_spans.iter().skip(1).rev() {\n-                        if let Some(hir_id) = hir.as_local_hir_id(adt_def.expect_local()) {\n-                            if let Node::Item(Item { ident, .. }) = hir.get(hir_id) {\n-                                err.span_note(\n-                                    *span,\n-                                    &if first {\n-                                        format!(\n-                                            \"`{}` contains a field of type `{}`\",\n-                                            tcx.type_of(def.did),\n-                                            ident\n-                                        )\n-                                    } else {\n-                                        format!(\"...which contains a field of type `{}`\", ident)\n-                                    },\n-                                );\n-                                first = false;\n-                            }\n+                        let hir_id = hir.as_local_hir_id(adt_def.expect_local());\n+                        if let Node::Item(Item { ident, .. }) = hir.get(hir_id) {\n+                            err.span_note(\n+                                *span,\n+                                &if first {\n+                                    format!(\n+                                        \"`{}` contains a field of type `{}`\",\n+                                        tcx.type_of(def.did),\n+                                        ident\n+                                    )\n+                                } else {\n+                                    format!(\"...which contains a field of type `{}`\", ident)\n+                                },\n+                            );\n+                            first = false;\n                         }\n                     }\n                 }\n@@ -2696,7 +2694,7 @@ pub fn check_enum<'tcx>(\n         // Check for duplicate discriminant values\n         if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n             let variant_did = def.variants[VariantIdx::new(i)].def_id;\n-            let variant_i_hir_id = tcx.hir().as_local_hir_id(variant_did.expect_local()).unwrap();\n+            let variant_i_hir_id = tcx.hir().as_local_hir_id(variant_did.expect_local());\n             let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n             let i_span = match variant_i.disr_expr {\n                 Some(ref expr) => tcx.hir().span(expr.hir_id),\n@@ -2757,7 +2755,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n \n     fn get_type_parameter_bounds(&self, _: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n         let tcx = self.tcx;\n-        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n         let item_id = tcx.hir().ty_param_owner(hir_id);\n         let item_def_id = tcx.hir().local_def_id(item_id);\n         let generics = tcx.generics_of(item_def_id);\n@@ -4974,7 +4972,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     sugg_call = fields.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n                     match def_id\n                         .as_local()\n-                        .map(|def_id| hir.as_local_hir_id(def_id).unwrap())\n+                        .map(|def_id| hir.as_local_hir_id(def_id))\n                         .and_then(|hir_id| hir.def_kind(hir_id))\n                     {\n                         Some(hir::def::DefKind::Ctor(hir::def::CtorOf::Variant, _)) => {"}, {"sha": "ffe1dcbd444039c6702ac13a991c63e2d8ce34f4", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n /// the types first.\n pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n     let item = tcx.hir().expect_item(hir_id);\n \n     debug!(\n@@ -184,7 +184,7 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n }\n \n pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n     let trait_item = tcx.hir().expect_trait_item(hir_id);\n \n     let method_sig = match trait_item.kind {\n@@ -258,7 +258,7 @@ fn check_object_unsafe_self_trait_by_name(tcx: TyCtxt<'_>, item: &hir::TraitItem\n }\n \n pub fn check_impl_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n     let impl_item = tcx.hir().expect_impl_item(hir_id);\n \n     let method_sig = match impl_item.kind {\n@@ -878,7 +878,7 @@ fn check_opaque_types<'fcx, 'tcx>(\n                 // FIXME(eddyb) is  `generics.parent.is_none()` correct? It seems\n                 // potentially risky wrt associated types in `impl`s.\n                 if generics.parent.is_none() && def_id.is_local() {\n-                    let opaque_hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+                    let opaque_hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n                     if may_define_opaque_type(tcx, fn_def_id, opaque_hir_id) {\n                         trace!(\"check_opaque_types: may define, generics={:#?}\", generics);\n                         let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();"}, {"sha": "56714a4fa679313dd8ba713125b2c8a21e71ec74", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -427,7 +427,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_opaque_types(&mut self, span: Span) {\n         for (&def_id, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n-            let hir_id = self.tcx().hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+            let hir_id = self.tcx().hir().as_local_hir_id(def_id.expect_local());\n             let instantiated_ty = self.resolve(&opaque_defn.concrete_ty, &hir_id);\n \n             debug_assert!(!instantiated_ty.has_escaping_bound_vars());"}, {"sha": "da93462fe2681330bb20f973f73967966b9adcc4", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -89,10 +89,8 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n             // Note that if we carry through to the `extern_mod_stmt_cnum` query\n             // below it'll cause a panic because `def_id` is actually bogus at this\n             // point in time otherwise.\n-            if let Some(id) = tcx.hir().as_local_hir_id(def_id.expect_local()) {\n-                if tcx.hir().find(id).is_none() {\n-                    return false;\n-                }\n+            if tcx.hir().find(tcx.hir().as_local_hir_id(def_id.expect_local())).is_none() {\n+                return false;\n             }\n             true\n         })\n@@ -115,7 +113,7 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     });\n \n     for extern_crate in &crates_to_lint {\n-        let id = tcx.hir().as_local_hir_id(extern_crate.def_id.expect_local()).unwrap();\n+        let id = tcx.hir().as_local_hir_id(extern_crate.def_id.expect_local());\n         let item = tcx.hir().expect_item(id);\n \n         // If the crate is fully unused, we suggest removing it altogether."}, {"sha": "c01c4d90c8e17b2f1ffef1400e1818810184cb18", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -53,7 +53,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n         return;\n     }\n \n-    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).expect(\"foreign Drop impl on non-ADT\");\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did);\n     let sp = match tcx.hir().expect_item(impl_hir_id).kind {\n         ItemKind::Impl { self_ty, .. } => self_ty.span,\n         _ => bug!(\"expected Drop impl item\"),\n@@ -72,12 +72,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n \n-    let impl_hir_id = if let Some(n) = tcx.hir().as_local_hir_id(impl_did) {\n-        n\n-    } else {\n-        debug!(\"visit_implementation_of_copy(): impl not in this crate\");\n-        return;\n-    };\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did);\n \n     let self_type = tcx.type_of(impl_did);\n     debug!(\"visit_implementation_of_copy: self_type={:?} (bound)\", self_type);\n@@ -152,7 +147,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n \n     let dispatch_from_dyn_trait = tcx.lang_items().dispatch_from_dyn_trait().unwrap();\n \n-    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).unwrap();\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did);\n     let span = tcx.hir().span(impl_hir_id);\n \n     let source = tcx.type_of(impl_did);\n@@ -326,7 +321,7 @@ pub fn coerce_unsized_info(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedI\n     });\n \n     // this provider should only get invoked for local def-ids\n-    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did.expect_local()).unwrap();\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did.expect_local());\n \n     let source = tcx.type_of(impl_did);\n     let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();"}, {"sha": "a831beb2be253089a22d4b95d118262dd32d0c69", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -269,7 +269,7 @@ impl ItemCtxt<'tcx> {\n     }\n \n     pub fn hir_id(&self) -> hir::HirId {\n-        self.tcx.hir().as_local_hir_id(self.item_def_id.expect_local()).unwrap()\n+        self.tcx.hir().as_local_hir_id(self.item_def_id.expect_local())\n     }\n \n     pub fn node(&self) -> hir::Node<'tcx> {\n@@ -486,7 +486,7 @@ fn type_param_predicates(\n     // written inline like `<T: Foo>` or in a where-clause like\n     // `where T: Foo`.\n \n-    let param_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let param_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let param_owner = tcx.hir().ty_param_owner(param_id);\n     let param_owner_def_id = tcx.hir().local_def_id(param_owner);\n     let generics = tcx.generics_of(param_owner_def_id);\n@@ -508,7 +508,7 @@ fn type_param_predicates(\n         .unwrap_or_default();\n     let mut extend = None;\n \n-    let item_hir_id = tcx.hir().as_local_hir_id(item_def_id.expect_local()).unwrap();\n+    let item_hir_id = tcx.hir().as_local_hir_id(item_def_id.expect_local());\n     let ast_generics = match tcx.hir().get(item_hir_id) {\n         Node::TraitItem(item) => &item.generics,\n \n@@ -814,7 +814,7 @@ fn convert_variant(\n     parent_did: LocalDefId,\n ) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Ident, Span> = Default::default();\n-    let hir_id = tcx.hir().as_local_hir_id(variant_did.unwrap_or(parent_did)).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(variant_did.unwrap_or(parent_did));\n     let fields = def\n         .fields()\n         .iter()\n@@ -865,7 +865,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n     use rustc_hir::*;\n \n     let def_id = def_id.expect_local();\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n     let item = match tcx.hir().get(hir_id) {\n         Node::Item(item) => item,\n         _ => bug!(),\n@@ -952,7 +952,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n /// the transitive super-predicates are converted.\n fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredicates<'_> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n-    let trait_hir_id = tcx.hir().as_local_hir_id(trait_def_id.expect_local()).unwrap();\n+    let trait_hir_id = tcx.hir().as_local_hir_id(trait_def_id.expect_local());\n \n     let item = match tcx.hir().get(trait_hir_id) {\n         Node::Item(item) => item,\n@@ -1003,7 +1003,7 @@ fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredi\n }\n \n fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TraitDef {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let item = tcx.hir().expect_item(hir_id);\n \n     let (is_auto, unsafety) = match item.kind {\n@@ -1161,7 +1161,7 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n \n     let node = tcx.hir().get(hir_id);\n     let parent_def_id = match node {\n@@ -1459,7 +1459,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n     use rustc_hir::Node::*;\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n@@ -1557,7 +1557,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     match tcx.hir().expect_item(hir_id).kind {\n         hir::ItemKind::Impl { ref of_trait, .. } => of_trait.as_ref().map(|ast_trait_ref| {\n             let selfty = tcx.type_of(def_id);\n@@ -1568,7 +1568,7 @@ fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n }\n \n fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let is_rustc_reservation = tcx.has_attr(def_id, sym::rustc_reservation_impl);\n     let item = tcx.hir().expect_item(hir_id);\n     match &item.kind {\n@@ -1702,7 +1702,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n         }\n     }\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let node = tcx.hir().get(hir_id);\n \n     let mut is_trait = None;\n@@ -2557,7 +2557,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     if codegen_fn_attrs.flags.intersects(CodegenFnAttrFlags::NO_SANITIZE_ANY) {\n         if codegen_fn_attrs.inline == InlineAttr::Always {\n             if let (Some(no_sanitize_span), Some(inline_span)) = (no_sanitize_span, inline_span) {\n-                let hir_id = tcx.hir().as_local_hir_id(id.expect_local()).unwrap();\n+                let hir_id = tcx.hir().as_local_hir_id(id.expect_local());\n                 tcx.struct_span_lint_hir(\n                     lint::builtin::INLINE_NO_SANITIZE,\n                     hir_id,"}, {"sha": "7fa55ecbeb911efd996e64d7ef4b335fb963f698", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -21,7 +21,7 @@ use super::{bad_placeholder_type, is_suggestable_infer_ty};\n pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n@@ -514,7 +514,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n         }\n     }\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n     let scope = tcx.hir().get_defining_scope(hir_id);\n     let mut locator = ConstraintLocator { def_id: def_id.to_def_id(), tcx, found: None };\n "}, {"sha": "c7ef07bde30cf9c8ad1ea68e0997d56f8856672a", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -346,7 +346,7 @@ fn check_predicates<'tcx>(\n         if let Some(obligations) = wf::obligations(\n             infcx,\n             tcx.param_env(impl1_def_id),\n-            tcx.hir().as_local_hir_id(impl1_def_id).unwrap(),\n+            tcx.hir().as_local_hir_id(impl1_def_id),\n             ty,\n             span,\n         ) {"}, {"sha": "7ca81e5d6b6c6569dd8a12bb15d15d3e34192e2f", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -153,7 +153,7 @@ fn require_same_types<'tcx>(\n }\n \n fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: LocalDefId) {\n-    let main_id = tcx.hir().as_local_hir_id(main_def_id).unwrap();\n+    let main_id = tcx.hir().as_local_hir_id(main_def_id);\n     let main_span = tcx.def_span(main_def_id);\n     let main_t = tcx.type_of(main_def_id);\n     match main_t.kind {\n@@ -232,7 +232,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: LocalDefId) {\n }\n \n fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: LocalDefId) {\n-    let start_id = tcx.hir().as_local_hir_id(start_def_id).unwrap();\n+    let start_id = tcx.hir().as_local_hir_id(start_def_id);\n     let start_span = tcx.def_span(start_def_id);\n     let start_t = tcx.type_of(start_def_id);\n     match start_t.kind {"}, {"sha": "15c72f8704f65edb8b37418485a0ebd8df24ef12", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -57,7 +57,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n \n         debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n \n-        let hir_id = self.tcx.hir().as_local_hir_id(item_did).expect(\"expected local def-id\");\n+        let hir_id = self.tcx.hir().as_local_hir_id(item_did);\n         let item = match self.tcx.hir().get(hir_id) {\n             Node::Item(item) => item,\n             _ => bug!(),"}, {"sha": "15e0473bbf5967c1e95260590ef6990088c85033", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -18,7 +18,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate<'_>, Span)] {\n-    let id = tcx.hir().as_local_hir_id(item_def_id.expect_local()).unwrap();\n+    let id = tcx.hir().as_local_hir_id(item_def_id.expect_local());\n \n     match tcx.hir().get(id) {\n         Node::Item(item) => match item.kind {"}, {"sha": "3ec3ef2f30c922bc7ee9b0e6111c7e3207203a7f", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             return;\n         }\n \n-        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let id = tcx.hir().as_local_hir_id(def_id);\n         let inferred_start = self.terms_cx.inferred_starts[&id];\n         let current_item = &CurrentItem { inferred_start };\n         match tcx.type_of(def_id).kind {\n@@ -378,7 +378,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         }\n \n         let (local, remote) = if let Some(id) =\n-            def_id.as_local().map(|def_id| self.tcx().hir().as_local_hir_id(def_id).unwrap())\n+            def_id.as_local().map(|def_id| self.tcx().hir().as_local_hir_id(def_id))\n         {\n             (Some(self.terms_cx.inferred_starts[&id]), None)\n         } else {"}, {"sha": "2d78ac4b3c58fe10dd08c0267ccbb45f19c5f8c4", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -38,7 +38,7 @@ fn crate_variances(tcx: TyCtxt<'_>, crate_num: CrateNum) -> &CrateVariancesMap<'\n }\n \n fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n-    let id = tcx.hir().as_local_hir_id(item_def_id.expect_local()).unwrap();\n+    let id = tcx.hir().as_local_hir_id(item_def_id.expect_local());\n     let unsupported = || {\n         // Variance not relevant.\n         span_bug!(tcx.hir().span(id), \"asked to compute variance for wrong kind of item\")"}, {"sha": "fe585826d2205c164c5afd2aa94cea752476efb5", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -94,9 +94,7 @@ fn lang_items(tcx: TyCtxt<'_>) -> Vec<(hir::HirId, Vec<ty::Variance>)> {\n     all.into_iter() // iterating over (Option<DefId>, Variance)\n         .filter(|&(ref d, _)| d.is_some())\n         .map(|(d, v)| (d.unwrap(), v)) // (DefId, Variance)\n-        .filter_map(|(d, v)| {\n-            d.as_local().map(|d| tcx.hir().as_local_hir_id(d).unwrap()).map(|n| (n, v))\n-        }) // (HirId, Variance)\n+        .filter_map(|(d, v)| d.as_local().map(|d| tcx.hir().as_local_hir_id(d)).map(|n| (n, v))) // (HirId, Variance)\n         .collect()\n }\n "}, {"sha": "7a25f07bfe968cedac170c07ccdb916f0d8d346b", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -340,15 +340,14 @@ pub fn build_impl(\n         }\n     }\n \n-    let for_ =\n-        if let Some(hir_id) = did.as_local().map(|did| tcx.hir().as_local_hir_id(did).unwrap()) {\n-            match tcx.hir().expect_item(hir_id).kind {\n-                hir::ItemKind::Impl { self_ty, .. } => self_ty.clean(cx),\n-                _ => panic!(\"did given to build_impl was not an impl\"),\n-            }\n-        } else {\n-            tcx.type_of(did).clean(cx)\n-        };\n+    let for_ = if let Some(hir_id) = did.as_local().map(|did| tcx.hir().as_local_hir_id(did)) {\n+        match tcx.hir().expect_item(hir_id).kind {\n+            hir::ItemKind::Impl { self_ty, .. } => self_ty.clean(cx),\n+            _ => panic!(\"did given to build_impl was not an impl\"),\n+        }\n+    } else {\n+        tcx.type_of(did).clean(cx)\n+    };\n \n     // Only inline impl if the implementing type is\n     // reachable in rustdoc generated documentation\n@@ -362,7 +361,7 @@ pub fn build_impl(\n \n     let predicates = tcx.explicit_predicates_of(did);\n     let (trait_items, generics) = if let Some(hir_id) =\n-        did.as_local().map(|did| tcx.hir().as_local_hir_id(did).unwrap())\n+        did.as_local().map(|did| tcx.hir().as_local_hir_id(did))\n     {\n         match tcx.hir().expect_item(hir_id).kind {\n             hir::ItemKind::Impl { ref generics, ref items, .. } => (\n@@ -489,7 +488,7 @@ fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>)\n }\n \n pub fn print_inlined_const(cx: &DocContext<'_>, did: DefId) -> String {\n-    if let Some(hir_id) = did.as_local().map(|did| cx.tcx.hir().as_local_hir_id(did).unwrap()) {\n+    if let Some(hir_id) = did.as_local().map(|did| cx.tcx.hir().as_local_hir_id(did)) {\n         rustc_hir_pretty::id_to_string(&cx.tcx.hir(), hir_id)\n     } else {\n         cx.tcx.rendered_const(did)\n@@ -502,7 +501,7 @@ fn build_const(cx: &DocContext<'_>, did: DefId) -> clean::Constant {\n         expr: print_inlined_const(cx, did),\n         value: clean::utils::print_evaluated_const(cx, did),\n         is_literal: did.as_local().map_or(false, |did| {\n-            clean::utils::is_literal_expr(cx, cx.tcx.hir().as_local_hir_id(did).unwrap())\n+            clean::utils::is_literal_expr(cx, cx.tcx.hir().as_local_hir_id(did))\n         }),\n     }\n }"}, {"sha": "a685b4a73cd38f5d26aa2727426f24620508925c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -1379,9 +1379,8 @@ impl Clean<Type> for hir::Ty<'_> {\n                 let mut alias = None;\n                 if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n                     // Substitute private type aliases\n-                    if let Some(hir_id) = def_id\n-                        .as_local()\n-                        .map(|def_id| cx.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                    if let Some(hir_id) =\n+                        def_id.as_local().map(|def_id| cx.tcx.hir().as_local_hir_id(def_id))\n                     {\n                         if !cx.renderinfo.borrow().access_levels.is_exported(def_id) {\n                             alias = Some(&cx.tcx.hir().expect_item(hir_id).kind);"}, {"sha": "de101a20fc59382874434f4e7530dc3b0d409e12", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -474,7 +474,7 @@ pub fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n     match n.val {\n         ty::ConstKind::Unevaluated(def_id, _, promoted) => {\n             let mut s = if let Some(hir_id) =\n-                def_id.as_local().map(|def_id| cx.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                def_id.as_local().map(|def_id| cx.tcx.hir().as_local_hir_id(def_id))\n             {\n                 print_const_expr(cx, cx.tcx.hir().body_owned_by(hir_id))\n             } else {"}, {"sha": "91e60f81cec530b5b3f56919f9bf36f1e7641862", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -144,7 +144,7 @@ impl<'tcx> DocContext<'tcx> {\n         if self.all_fake_def_ids.borrow().contains(&def_id) {\n             None\n         } else {\n-            def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+            def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n         }\n     }\n "}, {"sha": "2f10171e616e53a2846ea921fe19210222083105", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -335,10 +335,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n         let item_hir_id = if item.is_mod() {\n-            if let Some(id) = item\n-                .def_id\n-                .as_local()\n-                .map(|def_id| self.cx.tcx.hir().as_local_hir_id(def_id).unwrap())\n+            if let Some(id) =\n+                item.def_id.as_local().map(|def_id| self.cx.tcx.hir().as_local_hir_id(def_id))\n             {\n                 Some(id)\n             } else {"}, {"sha": "2050c6c57bab08ef3635ed42ac7f7fa1b43df7a8", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfce24aa675072c832e5160acdefc4e98b7fe8f3/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=bfce24aa675072c832e5160acdefc4e98b7fe8f3", "patch": "@@ -332,7 +332,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n \n         let res_hir_id = match res_did.as_local() {\n-            Some(n) => tcx.hir().as_local_hir_id(n).unwrap(),\n+            Some(n) => tcx.hir().as_local_hir_id(n),\n             None => return false,\n         };\n "}]}