{"sha": "c2788a88ca1991040eca2ffefc0b88eebdfcc582", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyNzg4YTg4Y2ExOTkxMDQwZWNhMmZmZWZjMGI4OGVlYmRmY2M1ODI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-08-17T23:38:51Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-08-20T20:56:48Z"}, "message": "resolve: Refactor away `MacroBinding`\n\n`fn resolve_legacy_scope` can now resolve only to `macro_rules!` items,\n`fn resolve_lexical_macro_path_segment` is for everything else - modularized macros, preludes", "tree": {"sha": "71f5fa46cac966eae019df7bc957db0c4e369073", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71f5fa46cac966eae019df7bc957db0c4e369073"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2788a88ca1991040eca2ffefc0b88eebdfcc582", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2788a88ca1991040eca2ffefc0b88eebdfcc582", "html_url": "https://github.com/rust-lang/rust/commit/c2788a88ca1991040eca2ffefc0b88eebdfcc582", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2788a88ca1991040eca2ffefc0b88eebdfcc582/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23e9a1def59ae7cc852181e9395cb467ffdbd46e", "url": "https://api.github.com/repos/rust-lang/rust/commits/23e9a1def59ae7cc852181e9395cb467ffdbd46e", "html_url": "https://github.com/rust-lang/rust/commit/23e9a1def59ae7cc852181e9395cb467ffdbd46e"}], "stats": {"total": 276, "additions": 160, "deletions": 116}, "files": [{"sha": "0614e8714583f21b208677faf44caab78ed65024", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c2788a88ca1991040eca2ffefc0b88eebdfcc582", "patch": "@@ -80,7 +80,7 @@ use std::mem::replace;\n use rustc_data_structures::sync::Lrc;\n \n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n-use macros::{InvocationData, LegacyBinding, MacroBinding};\n+use macros::{InvocationData, LegacyBinding};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -3529,7 +3529,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             } else if opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n                 self.resolve_lexical_macro_path_segment(ident, ns, record_used, record_used,\n-                                                        false, path_span).map(MacroBinding::binding)\n+                                                        false, path_span).map(|(b, _)| b)\n             } else {\n                 let record_used_id =\n                     if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };"}, {"sha": "bab98fb91da02ad37399ffbfda2968a007a660af", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 71, "deletions": 105, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=c2788a88ca1991040eca2ffefc0b88eebdfcc582", "patch": "@@ -43,6 +43,9 @@ use std::cell::Cell;\n use std::mem;\n use rustc_data_structures::sync::Lrc;\n \n+crate struct FromPrelude(bool);\n+crate struct FromExpansion(bool);\n+\n #[derive(Clone)]\n pub struct InvocationData<'a> {\n     pub module: Cell<Module<'a>>,\n@@ -80,6 +83,12 @@ pub struct LegacyBinding<'a> {\n     pub span: Span,\n }\n \n+impl<'a> LegacyBinding<'a> {\n+    fn def(&self) -> Def {\n+        Def::Macro(self.def_id, MacroKind::Bang)\n+    }\n+}\n+\n pub struct ProcMacError {\n     crate_name: Symbol,\n     name: Symbol,\n@@ -88,37 +97,6 @@ pub struct ProcMacError {\n     warn_msg: &'static str,\n }\n \n-#[derive(Copy, Clone)]\n-pub enum MacroBinding<'a> {\n-    Legacy(&'a LegacyBinding<'a>),\n-    Global(&'a NameBinding<'a>),\n-    Modern(&'a NameBinding<'a>),\n-}\n-\n-impl<'a> MacroBinding<'a> {\n-    pub fn span(self) -> Span {\n-        match self {\n-            MacroBinding::Legacy(binding) => binding.span,\n-            MacroBinding::Global(binding) | MacroBinding::Modern(binding) => binding.span,\n-        }\n-    }\n-\n-    pub fn binding(self) -> &'a NameBinding<'a> {\n-        match self {\n-            MacroBinding::Global(binding) | MacroBinding::Modern(binding) => binding,\n-            MacroBinding::Legacy(_) => panic!(\"unexpected MacroBinding::Legacy\"),\n-        }\n-    }\n-\n-    pub fn def_ignoring_ambiguity(self) -> Def {\n-        match self {\n-            MacroBinding::Legacy(binding) => Def::Macro(binding.def_id, MacroKind::Bang),\n-            MacroBinding::Global(binding) | MacroBinding::Modern(binding) =>\n-                binding.def_ignoring_ambiguity(),\n-        }\n-    }\n-}\n-\n impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -498,12 +476,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, path[0], false);\n-        let result = if let Some(MacroBinding::Legacy(binding)) = legacy_resolution {\n-            Ok(Def::Macro(binding.def_id, MacroKind::Bang))\n+        let result = if let Some((legacy_binding, _)) = legacy_resolution {\n+            Ok(legacy_binding.def())\n         } else {\n             match self.resolve_lexical_macro_path_segment(path[0], MacroNS, false, force,\n                                                           kind == MacroKind::Attr, span) {\n-                Ok(binding) => Ok(binding.binding().def_ignoring_ambiguity()),\n+                Ok((binding, _)) => Ok(binding.def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n                 Err(Determinacy::Determined) => {\n                     self.found_unresolved_macro = true;\n@@ -556,14 +534,15 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     // (e.g. `foo` in `foo::bar!(); or `foo!();`).\n     // This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n     // expansion and import resolution (perhaps they can be merged in the future).\n-    pub fn resolve_lexical_macro_path_segment(&mut self,\n-                                              mut ident: Ident,\n-                                              ns: Namespace,\n-                                              record_used: bool,\n-                                              force: bool,\n-                                              is_attr: bool,\n-                                              path_span: Span)\n-                                              -> Result<MacroBinding<'a>, Determinacy> {\n+    crate fn resolve_lexical_macro_path_segment(\n+        &mut self,\n+        mut ident: Ident,\n+        ns: Namespace,\n+        record_used: bool,\n+        force: bool,\n+        is_attr: bool,\n+        path_span: Span\n+    ) -> Result<(&'a NameBinding<'a>, FromPrelude), Determinacy> {\n         // General principles:\n         // 1. Not controlled (user-defined) names should have higher priority than controlled names\n         //    built into the language or standard library. This way we can add new names into the\n@@ -603,7 +582,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         //     m::mac!();\n         // }\n         // This includes names from globs and from macro expansions.\n-        let mut potentially_ambiguous_result: Option<MacroBinding> = None;\n+        let mut potentially_ambiguous_result: Option<(&NameBinding, FromPrelude)> = None;\n \n         enum WhereToResolve<'a> {\n             Module(Module<'a>),\n@@ -631,11 +610,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         path_span,\n                     );\n                     self.current_module = orig_current_module;\n-                    binding.map(MacroBinding::Modern)\n+                    binding.map(|binding| (binding, FromPrelude(false)))\n                 }\n                 WhereToResolve::MacroPrelude => {\n                     match self.macro_prelude.get(&ident.name).cloned() {\n-                        Some(binding) => Ok(MacroBinding::Global(binding)),\n+                        Some(binding) => Ok((binding, FromPrelude(true))),\n                         None => Err(Determinacy::Determined),\n                     }\n                 }\n@@ -647,7 +626,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::Builtin),\n                                        ty::Visibility::Public, ident.span, Mark::root())\n                                        .to_name_binding(self.arenas);\n-                        Ok(MacroBinding::Global(binding))\n+                        Ok((binding, FromPrelude(true)))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -670,7 +649,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                         let binding = (crate_root, ty::Visibility::Public,\n                                        ident.span, Mark::root()).to_name_binding(self.arenas);\n-                        Ok(MacroBinding::Global(binding))\n+                        Ok((binding, FromPrelude(true)))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -679,7 +658,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     if use_prelude && is_known_tool(ident.name) {\n                         let binding = (Def::ToolMod, ty::Visibility::Public,\n                                        ident.span, Mark::root()).to_name_binding(self.arenas);\n-                        Ok(MacroBinding::Global(binding))\n+                        Ok((binding, FromPrelude(true)))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -696,7 +675,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                                 false,\n                                 path_span,\n                             ) {\n-                                result = Ok(MacroBinding::Global(binding));\n+                                result = Ok((binding, FromPrelude(true)));\n                             }\n                         }\n                     }\n@@ -707,7 +686,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                             self.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n                         let binding = (Def::PrimTy(prim_ty), ty::Visibility::Public,\n                                        ident.span, Mark::root()).to_name_binding(self.arenas);\n-                        Ok(MacroBinding::Global(binding))\n+                        Ok((binding, FromPrelude(true)))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -746,18 +725,16 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         return Ok(result);\n                     }\n \n-                    let binding = result.binding();\n-\n                     // Found a solution that is ambiguous with a previously found solution.\n                     // Push an ambiguity error for later reporting and\n                     // return something for better recovery.\n                     if let Some(previous_result) = potentially_ambiguous_result {\n-                        if binding.def() != previous_result.binding().def() {\n+                        if result.0.def() != previous_result.0.def() {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 span: path_span,\n                                 name: ident.name,\n-                                b1: previous_result.binding(),\n-                                b2: binding,\n+                                b1: previous_result.0,\n+                                b2: result.0,\n                                 lexical: true,\n                             });\n                             return Ok(previous_result);\n@@ -767,7 +744,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     // Found a solution that's not an ambiguity yet, but is \"suspicious\" and\n                     // can participate in ambiguities later on.\n                     // Remember it and go search for other solutions in outer scopes.\n-                    if binding.is_glob_import() || binding.expansion != Mark::root() {\n+                    if result.0.is_glob_import() || result.0.expansion != Mark::root() {\n                         potentially_ambiguous_result = Some(result);\n \n                         continue_search!();\n@@ -797,20 +774,19 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             let binding = (Def::NonMacroAttr(NonMacroAttrKind::Custom),\n                            ty::Visibility::Public, ident.span, Mark::root())\n                            .to_name_binding(self.arenas);\n-            Ok(MacroBinding::Global(binding))\n+            Ok((binding, FromPrelude(true)))\n         } else {\n             Err(determinacy)\n         }\n     }\n \n-    pub fn resolve_legacy_scope(&mut self,\n-                                mut scope: &'a Cell<LegacyScope<'a>>,\n-                                ident: Ident,\n-                                record_used: bool)\n-                                -> Option<MacroBinding<'a>> {\n+    crate fn resolve_legacy_scope(&mut self,\n+                                  mut scope: &'a Cell<LegacyScope<'a>>,\n+                                  ident: Ident,\n+                                  record_used: bool)\n+                                  -> Option<(&'a LegacyBinding<'a>, FromExpansion)> {\n         let ident = ident.modern();\n         let mut relative_depth: u32 = 0;\n-        let mut binding = None;\n         loop {\n             match scope.get() {\n                 LegacyScope::Empty => break,\n@@ -835,23 +811,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         if record_used && relative_depth > 0 {\n                             self.disallowed_shadowing.push(potential_binding);\n                         }\n-                        binding = Some(potential_binding);\n-                        break\n+                        return Some((potential_binding, FromExpansion(relative_depth > 0)));\n                     }\n                     scope = &potential_binding.parent;\n                 }\n             };\n         }\n \n-        let binding = if let Some(binding) = binding {\n-            MacroBinding::Legacy(binding)\n-        } else if let Some(binding) = self.macro_prelude.get(&ident.name).cloned() {\n-            MacroBinding::Global(binding)\n-        } else {\n-            return None;\n-        };\n-\n-        Some(binding)\n+        None\n     }\n \n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n@@ -873,10 +840,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, true, true,\n                                                                      kind == MacroKind::Attr, span);\n \n-            let check_consistency = |this: &Self, binding: MacroBinding| {\n+            let check_consistency = |this: &Self, new_def: Def| {\n                 if let Some(def) = def {\n                     if this.ambiguity_errors.is_empty() && this.disallowed_shadowing.is_empty() &&\n-                       binding.def_ignoring_ambiguity() != def {\n+                       new_def != def && new_def != Def::Err {\n                         // Make sure compilation does not succeed if preferred macro resolution\n                         // has changed after the macro had been expanded. In theory all such\n                         // situations should be reported as ambiguity errors, so this is span-bug.\n@@ -895,17 +862,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             };\n \n             match (legacy_resolution, resolution) {\n-                (Some(MacroBinding::Legacy(legacy_binding)), Ok(MacroBinding::Modern(binding))) => {\n-                    if legacy_binding.def_id != binding.def_ignoring_ambiguity().def_id() {\n-                        let msg1 = format!(\"`{}` could refer to the macro defined here\", ident);\n-                        let msg2 =\n-                            format!(\"`{}` could also refer to the macro imported here\", ident);\n-                        self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", ident))\n-                            .span_note(legacy_binding.span, &msg1)\n-                            .span_note(binding.span, &msg2)\n-                            .emit();\n-                    }\n-                },\n                 (None, Err(_)) => {\n                     assert!(def.is_none());\n                     let bang = if kind == MacroKind::Bang { \"!\" } else { \"\" };\n@@ -915,26 +871,32 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     self.suggest_macro_name(&ident.as_str(), kind, &mut err, span);\n                     err.emit();\n                 },\n-                (Some(MacroBinding::Modern(_)), _) | (_, Ok(MacroBinding::Legacy(_))) => {\n-                    span_bug!(span, \"impossible macro resolution result\");\n-                }\n+                (Some((legacy_binding, _)), Ok((binding, FromPrelude(false)))) |\n+                (Some((legacy_binding, FromExpansion(true))), Ok((binding, FromPrelude(true)))) => {\n+                    if legacy_binding.def() != binding.def_ignoring_ambiguity() {\n+                        let msg1 = format!(\"`{}` could refer to the macro defined here\", ident);\n+                        let msg2 =\n+                            format!(\"`{}` could also refer to the macro imported here\", ident);\n+                        self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", ident))\n+                            .span_note(legacy_binding.span, &msg1)\n+                            .span_note(binding.span, &msg2)\n+                            .emit();\n+                    }\n+                },\n+                // OK, non-macro-expanded legacy wins over macro prelude even if defs are different\n+                (Some((legacy_binding, FromExpansion(false))), Ok((_, FromPrelude(true)))) |\n                 // OK, unambiguous resolution\n-                (Some(binding), Err(_)) | (None, Ok(binding)) |\n-                // OK, legacy wins over global even if their definitions are different\n-                (Some(binding @ MacroBinding::Legacy(_)), Ok(MacroBinding::Global(_))) |\n-                // OK, modern wins over global even if their definitions are different\n-                (Some(MacroBinding::Global(_)), Ok(binding @ MacroBinding::Modern(_))) => {\n-                    check_consistency(self, binding);\n+                (Some((legacy_binding, _)), Err(_)) => {\n+                    check_consistency(self, legacy_binding.def());\n                 }\n-                (Some(MacroBinding::Global(binding1)), Ok(MacroBinding::Global(binding2))) => {\n-                    if binding1.def() != binding2.def() {\n-                        span_bug!(span, \"mismatch between same global macro resolutions\");\n+                // OK, unambiguous resolution\n+                (None, Ok((binding, FromPrelude(from_prelude)))) => {\n+                    check_consistency(self, binding.def_ignoring_ambiguity());\n+                    if from_prelude {\n+                        self.record_use(ident, MacroNS, binding, span);\n+                        self.err_if_macro_use_proc_macro(ident.name, span, binding);\n                     }\n-                    check_consistency(self, MacroBinding::Global(binding1));\n-\n-                    self.record_use(ident, MacroNS, binding1, span);\n-                    self.err_if_macro_use_proc_macro(ident.name, span, binding1);\n-                },\n+                }\n             };\n         }\n     }\n@@ -1056,7 +1018,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     /// Error if `ext` is a Macros 1.1 procedural macro being imported by `#[macro_use]`\n     fn err_if_macro_use_proc_macro(&mut self, name: Name, use_span: Span,\n                                    binding: &NameBinding<'a>) {\n-        let krate = binding.def().def_id().krate;\n+        let krate = match binding.def() {\n+            Def::NonMacroAttr(..) | Def::Err => return,\n+            Def::Macro(def_id, _) => def_id.krate,\n+            _ => unreachable!(),\n+        };\n \n         // Plugin-based syntax extensions are exempt from this check\n         if krate == BUILTIN_MACROS_CRATE { return; }"}, {"sha": "9def03e94506a529ed964209c5a847153198444c", "filename": "src/test/ui-fulldeps/proc-macro/macro-namespace-reserved-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr?ref=c2788a88ca1991040eca2ffefc0b88eebdfcc582", "patch": "@@ -17,19 +17,19 @@ LL |     MyTrait!(); //~ ERROR can't use a procedural macro from the same crate\n    |     ^^^^^^^\n \n error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:44:3\n+  --> $DIR/macro-namespace-reserved-2.rs:43:3\n    |\n LL | #[my_macro] //~ ERROR can't use a procedural macro from the same crate that defines it\n    |   ^^^^^^^^\n \n error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:46:3\n+  --> $DIR/macro-namespace-reserved-2.rs:45:3\n    |\n LL | #[my_macro_attr] //~ ERROR can't use a procedural macro from the same crate that defines it\n    |   ^^^^^^^^^^^^^\n \n error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:48:3\n+  --> $DIR/macro-namespace-reserved-2.rs:47:3\n    |\n LL | #[MyTrait] //~ ERROR can't use a procedural macro from the same crate that defines it\n    |   ^^^^^^^"}, {"sha": "1b21e3ba5f3a7fe70d5c5bc0883baa56e0979590", "filename": "src/test/ui/imports/issue-53269.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Ftest%2Fui%2Fimports%2Fissue-53269.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Ftest%2Fui%2Fimports%2Fissue-53269.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53269.rs?ref=c2788a88ca1991040eca2ffefc0b88eebdfcc582", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ambiguity between a `macro_rules` macro and a non-existent import recovered as `Def::Err`\n+\n+macro_rules! mac { () => () }\n+\n+mod m {\n+    use nonexistent_module::mac; //~ ERROR unresolved import `nonexistent_module`\n+\n+    mac!(); //~ ERROR `mac` is ambiguous\n+}\n+\n+fn main() {}"}, {"sha": "183cf925954390e2eba25fc34d2ad77662ae4835", "filename": "src/test/ui/imports/issue-53269.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr?ref=c2788a88ca1991040eca2ffefc0b88eebdfcc582", "patch": "@@ -0,0 +1,26 @@\n+error[E0432]: unresolved import `nonexistent_module`\n+  --> $DIR/issue-53269.rs:16:9\n+   |\n+LL |     use nonexistent_module::mac; //~ ERROR unresolved import `nonexistent_module`\n+   |         ^^^^^^^^^^^^^^^^^^ Maybe a missing `extern crate nonexistent_module;`?\n+\n+error: `mac` is ambiguous\n+  --> $DIR/issue-53269.rs:18:5\n+   |\n+LL |     mac!(); //~ ERROR `mac` is ambiguous\n+   |     ^^^\n+   |\n+note: `mac` could refer to the macro defined here\n+  --> $DIR/issue-53269.rs:13:1\n+   |\n+LL | macro_rules! mac { () => () }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: `mac` could also refer to the macro imported here\n+  --> $DIR/issue-53269.rs:16:9\n+   |\n+LL |     use nonexistent_module::mac; //~ ERROR unresolved import `nonexistent_module`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "82ae75e8198ac438b0a56bdaa2976144ae214ffb", "filename": "src/test/ui/imports/issue-53512.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Ftest%2Fui%2Fimports%2Fissue-53512.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Ftest%2Fui%2Fimports%2Fissue-53512.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53512.rs?ref=c2788a88ca1991040eca2ffefc0b88eebdfcc582", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Macro from prelude is shadowed by non-existent import recovered as `Def::Err`.\n+\n+use std::assert; //~ ERROR unresolved import `std::assert`\n+\n+fn main() {\n+    assert!(true);\n+}"}, {"sha": "e79e759f6c69fc06105454d47169d2ddeff0c386", "filename": "src/test/ui/imports/issue-53512.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Ftest%2Fui%2Fimports%2Fissue-53512.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Ftest%2Fui%2Fimports%2Fissue-53512.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53512.stderr?ref=c2788a88ca1991040eca2ffefc0b88eebdfcc582", "patch": "@@ -0,0 +1,9 @@\n+error[E0432]: unresolved import `std::assert`\n+  --> $DIR/issue-53512.rs:13:5\n+   |\n+LL | use std::assert; //~ ERROR unresolved import `std::assert`\n+   |     ^^^^^^^^^^^ no `assert` in the root\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "ec3f4107e38fcd7dd0c8afe3d1079fbaf79080aa", "filename": "src/test/ui/imports/shadow_builtin_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.rs?ref=c2788a88ca1991040eca2ffefc0b88eebdfcc582", "patch": "@@ -37,10 +37,10 @@ mod m4 {\n \n mod m5 {\n     macro_rules! m { () => {\n-        macro_rules! panic { () => {} } //~ ERROR `panic` is already in scope\n+        macro_rules! panic { () => {} }\n     } }\n     m!();\n-    panic!();\n+    panic!(); //~ ERROR `panic` is ambiguous\n }\n \n #[macro_use(n)]"}, {"sha": "263e24baff4d3693d892a9dec9910dfd0fb50f7f", "filename": "src/test/ui/imports/shadow_builtin_macros.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2788a88ca1991040eca2ffefc0b88eebdfcc582/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr?ref=c2788a88ca1991040eca2ffefc0b88eebdfcc582", "patch": "@@ -1,13 +1,18 @@\n-error: `panic` is already in scope\n+error: `panic` is ambiguous\n+  --> $DIR/shadow_builtin_macros.rs:43:5\n+   |\n+LL |     panic!(); //~ ERROR `panic` is ambiguous\n+   |     ^^^^^\n+   |\n+note: `panic` could refer to the macro defined here\n   --> $DIR/shadow_builtin_macros.rs:40:9\n    |\n-LL |         macro_rules! panic { () => {} } //~ ERROR `panic` is already in scope\n+LL |         macro_rules! panic { () => {} }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |     } }\n LL |     m!();\n    |     ----- in this macro invocation\n-   |\n-   = note: macro-expanded `macro_rules!`s may not shadow existing macros (see RFC 1560)\n+note: `panic` could also refer to the macro imported here\n \n error[E0659]: `panic` is ambiguous\n   --> $DIR/shadow_builtin_macros.rs:25:14"}]}