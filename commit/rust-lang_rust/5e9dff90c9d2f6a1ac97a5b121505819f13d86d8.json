{"sha": "5e9dff90c9d2f6a1ac97a5b121505819f13d86d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlOWRmZjkwYzlkMmY2YTFhYzk3YTViMTIxNTA1ODE5ZjEzZDg2ZDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-20T10:52:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-20T10:52:01Z"}, "message": "auto merge of #8638 : pnkfelix/rust/fsk-visitor-vpar-defaults-step5, r=huonw\n\n\"non-mechanical\" : there was lots more hacking than the other more-mechanical ports Felix did.\r\n\r\nr? @huonw.  (Or @nikomatsakis ; I just want someone to sanity-check this.  Its not a thing of beauty.)\r\n\r\nFollowup to #8623.  (See #8527, which was step 1 of 5, for the full outline.  Part of #7081.)\r\n\r\nNotes on the change follow.\r\n\r\nThere's also a strange pattern that I hacked in to accommodate the\r\nOuter/Inner traversal structure of the existing code (which was\r\npreviously encoding this by untying the Y-combinator style knot of the\r\nvtable, and then retying it but superimposing new methods that \"stop\r\nat items\").  I hope either I or someone else can come back in the\r\nfuture and replace this ugliness with something more natural.\r\n\r\nAdded boilerplate macro; all the OuterLint definitions are the same\r\n(but must be abstracted over implementing struct, thus the macro).\r\n\r\nRevised lint.rs use declarations to make ast references explicit.\r\nAlso removed unused imports.", "tree": {"sha": "9fce0b821f2d66232c9fc3a4a93c1d3d71a684d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fce0b821f2d66232c9fc3a4a93c1d3d71a684d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e9dff90c9d2f6a1ac97a5b121505819f13d86d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e9dff90c9d2f6a1ac97a5b121505819f13d86d8", "html_url": "https://github.com/rust-lang/rust/commit/5e9dff90c9d2f6a1ac97a5b121505819f13d86d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e9dff90c9d2f6a1ac97a5b121505819f13d86d8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c099242a1a9536e73485830f6b06c4ab2eea8958", "url": "https://api.github.com/repos/rust-lang/rust/commits/c099242a1a9536e73485830f6b06c4ab2eea8958", "html_url": "https://github.com/rust-lang/rust/commit/c099242a1a9536e73485830f6b06c4ab2eea8958"}, {"sha": "9b82d50f6d1dcd154fd1753dfd5d6d02e8a42d73", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b82d50f6d1dcd154fd1753dfd5d6d02e8a42d73", "html_url": "https://github.com/rust-lang/rust/commit/9b82d50f6d1dcd154fd1753dfd5d6d02e8a42d73"}], "stats": {"total": 613, "additions": 431, "deletions": 182}, "files": [{"sha": "eb42724e800384892da559f32881132235a5d47c", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 431, "deletions": 182, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/5e9dff90c9d2f6a1ac97a5b121505819f13d86d8/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9dff90c9d2f6a1ac97a5b121505819f13d86d8/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=5e9dff90c9d2f6a1ac97a5b121505819f13d86d8", "patch": "@@ -31,7 +31,8 @@ use syntax::attr::AttrMetaMethods;\n use syntax::codemap::span;\n use syntax::codemap;\n use syntax::parse::token;\n-use syntax::{ast, oldvisit, ast_util, visit};\n+use syntax::{ast, ast_util, visit};\n+use syntax::visit::Visitor;\n \n /**\n  * A 'lint' check is a kind of miscellaneous constraint that a user _might_\n@@ -300,6 +301,42 @@ pub fn get_lint_dict() -> LintDict {\n     return map;\n }\n \n+trait OuterLint {\n+    fn process_item(@mut self, i:@ast::item, e:@mut Context);\n+    fn process_fn(@mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n+                  b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context);\n+\n+    // Returned inner variant will not proceed past subitems.\n+    // Supports decomposition of simple lints into subitem-traversing\n+    // outer lint visitor and subitem-stopping inner lint visitor.\n+    fn inner_variant(@mut self) -> @mut InnerLint;\n+}\n+\n+trait InnerLint {\n+    fn descend_item(@mut self, i:&ast::item, e:@mut Context);\n+    fn descend_crate(@mut self, crate: &ast::Crate, env: @mut Context);\n+    fn descend_fn(@mut self,\n+                  function_kind: &visit::fn_kind,\n+                  function_declaration: &ast::fn_decl,\n+                  function_body: &ast::Block,\n+                  sp: span,\n+                  id: ast::NodeId,\n+                  env: @mut Context);\n+}\n+\n+impl<V:Visitor<@mut Context>> InnerLint for V {\n+    fn descend_item(@mut self, i:&ast::item, e:@mut Context) {\n+        visit::walk_item(self, i, e);\n+    }\n+    fn descend_crate(@mut self, crate: &ast::Crate, env: @mut Context) {\n+        visit::walk_crate(self, crate, env);\n+    }\n+    fn descend_fn(@mut self, fk: &visit::fn_kind, fd: &ast::fn_decl, fb: &ast::Block,\n+                  sp: span, id: ast::NodeId, env: @mut Context) {\n+        visit::walk_fn(self, fk, fd, fb, sp, id, env);\n+    }\n+}\n+\n enum AnyVisitor {\n     // This is a pair so every visitor can visit every node. When a lint pass\n     // is registered, another visitor is created which stops at all items\n@@ -308,10 +345,12 @@ enum AnyVisitor {\n     // first element. This means that when visiting a node, the original\n     // recursive call can use the original visitor's method, although the\n     // recursing visitor supplied to the method is the item stopping visitor.\n-    OldVisitor(oldvisit::vt<@mut Context>, oldvisit::vt<@mut Context>),\n+    OldVisitor(@mut OuterLint, @mut InnerLint),\n     NewVisitor(@mut visit::Visitor<()>),\n }\n \n+type VCObj = @mut Visitor<@mut Context>;\n+\n struct Context {\n     // All known lint modes (string versions)\n     dict: @LintDict,\n@@ -469,8 +508,8 @@ impl Context {\n         }\n     }\n \n-    fn add_oldvisit_lint(&mut self, v: oldvisit::vt<@mut Context>) {\n-        self.visitors.push(OldVisitor(v, item_stopping_visitor(v)));\n+    fn add_oldvisit_lint(&mut self, v: @mut OuterLint) {\n+        self.visitors.push(OldVisitor(v, v.inner_variant()));\n     }\n \n     fn add_lint(&mut self, v: @mut visit::Visitor<()>) {\n@@ -485,7 +524,8 @@ impl Context {\n                 for visitor in self.visitors.iter() {\n                     match *visitor {\n                         OldVisitor(orig, stopping) => {\n-                            (orig.visit_item)(it, (self, stopping));\n+                            orig.process_item(it, self);\n+                            stopping.descend_item(it, self);\n                         }\n                         NewVisitor(new_visitor) => {\n                             let new_visitor = new_visitor;\n@@ -498,7 +538,7 @@ impl Context {\n                 for visitor in self.visitors.iter() {\n                     match *visitor {\n                         OldVisitor(_, stopping) => {\n-                            oldvisit::visit_crate(c, (self, stopping))\n+                            stopping.descend_crate(c, self)\n                         }\n                         NewVisitor(new_visitor) => {\n                             let mut new_visitor = new_visitor;\n@@ -514,15 +554,9 @@ impl Context {\n                 for visitor in self.visitors.iter() {\n                     match *visitor {\n                         OldVisitor(orig, stopping) => {\n-                            let fk = oldvisit::fk_method(m.ident,\n-                                                         &m.generics,\n-                                                         m);\n-                            (orig.visit_fn)(&fk,\n-                                            &m.decl,\n-                                            &m.body,\n-                                            m.span,\n-                                            m.id,\n-                                            (self, stopping));\n+                            let fk = visit::fk_method(m.ident, &m.generics, m);\n+                            orig.process_fn(&fk, &m.decl, &m.body, m.span, m.id, self);\n+                            stopping.descend_fn(&fk, &m.decl, &m.body, m.span, m.id, self);\n                         }\n                         NewVisitor(new_visitor) => {\n                             let fk = visit::fk_method(m.ident,\n@@ -575,26 +609,73 @@ pub fn each_lint(sess: session::Session,\n     true\n }\n \n-// Take a visitor, and modify it so that it will not proceed past subitems.\n-// This is used to make the simple visitors used for the lint passes\n-// not traverse into subitems, since that is handled by the outer\n-// lint visitor.\n-fn item_stopping_visitor<E>(outer: oldvisit::vt<E>) -> oldvisit::vt<E> {\n-    oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_item: |_i, (_e, _v)| { },\n-        visit_fn: |fk, fd, b, s, id, (e, v)| {\n+trait SubitemStoppableVisitor : Visitor<@mut Context> {\n+    fn is_running_on_items(&mut self) -> bool;\n+\n+    fn visit_item_action(&mut self, _i:@ast::item, _e:@mut Context) {\n+        // fill in with particular action without recursion if desired\n+    }\n+\n+    fn visit_fn_action(&mut self, _fk:&visit::fn_kind, _fd:&ast::fn_decl,\n+                       _b:&ast::Block, _s:span, _n:ast::NodeId, _e:@mut Context) {\n+        // fill in with particular action without recursion if desired\n+    }\n+\n+    // The two OVERRIDE methods:\n+    //\n+    //   OVERRIDE_visit_item\n+    //   OVERRIDE_visit_fn\n+    //\n+    // *must* be included as initial reimplementations of the standard\n+    // default behavior of visit_item and visit_fn for every impl of\n+    // Visitor, in order to recreate the effect of having two variant\n+    // Outer/Inner behaviors of lint visitors.  (See earlier versions\n+    // of this module to see what the original encoding was of this\n+    // emulated behavior.)\n+\n+    fn OVERRIDE_visit_item(&mut self, i:@ast::item, e:@mut Context) {\n+        if self.is_running_on_items() {\n+            self.visit_item_action(i, e);\n+            visit::walk_item(self, i, e);\n+        }\n+    }\n+\n+    fn OVERRIDE_visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n+                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+        if self.is_running_on_items() {\n+            self.visit_fn_action(fk, fd, b, s, n, e);\n+            visit::walk_fn(self, fk, fd, b, s, n, e);\n+        } else {\n             match *fk {\n-                oldvisit::fk_method(*) => {}\n-                _ => (outer.visit_fn)(fk, fd, b, s, id, (e, v))\n+                visit::fk_method(*) => {}\n+                _ => {\n+                    self.visit_fn_action(fk, fd, b, s, n, e);\n+                    visit::walk_fn(self, fk, fd, b, s, n, e);\n+                }\n             }\n-        },\n-    .. **outer})\n+        }\n+    }\n }\n \n-fn lint_while_true() -> oldvisit::vt<@mut Context> {\n-    oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_expr: |e,\n-                     (cx, vt): (@mut Context, oldvisit::vt<@mut Context>)| {\n+struct WhileTrueLintVisitor { stopping_on_items: bool }\n+\n+\n+impl SubitemStoppableVisitor for WhileTrueLintVisitor {\n+    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n+}\n+\n+impl Visitor<@mut Context> for WhileTrueLintVisitor {\n+    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n+        self.OVERRIDE_visit_item(i, e);\n+    }\n+\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n+                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n+    }\n+\n+    fn visit_expr(&mut self, e:@ast::expr, cx:@mut Context) {\n+\n             match e.node {\n                 ast::expr_while(cond, _) => {\n                     match cond.node {\n@@ -610,14 +691,41 @@ fn lint_while_true() -> oldvisit::vt<@mut Context> {\n                 }\n                 _ => ()\n             }\n-            oldvisit::visit_expr(e, (cx, vt));\n-        },\n-        .. *oldvisit::default_visitor()\n-    })\n+            visit::walk_expr(self, e, cx);\n+    }\n+}\n+\n+macro_rules! outer_lint_boilerplate_impl(\n+    ($Visitor:ident) =>\n+    (\n+        impl OuterLint for $Visitor {\n+            fn process_item(@mut self, i:@ast::item, e:@mut Context) {\n+                self.visit_item_action(i, e);\n+            }\n+            fn process_fn(@mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n+                          b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+                self.visit_fn_action(fk, fd, b, s, n, e);\n+            }\n+            fn inner_variant(@mut self) -> @mut InnerLint {\n+                @mut $Visitor { stopping_on_items: true } as @mut InnerLint\n+            }\n+        }\n+    ))\n+\n+outer_lint_boilerplate_impl!(WhileTrueLintVisitor)\n+\n+fn lint_while_true() -> @mut OuterLint {\n+    @mut WhileTrueLintVisitor{ stopping_on_items: false } as @mut OuterLint\n }\n \n-fn lint_type_limits() -> oldvisit::vt<@mut Context> {\n-    fn is_valid<T:cmp::Ord>(binop: ast::binop, v: T,\n+struct TypeLimitsLintVisitor { stopping_on_items: bool }\n+\n+impl SubitemStoppableVisitor for TypeLimitsLintVisitor {\n+    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n+}\n+\n+impl TypeLimitsLintVisitor {\n+    fn is_valid<T:cmp::Ord>(&mut self, binop: ast::binop, v: T,\n             min: T, max: T) -> bool {\n         match binop {\n             ast::lt => v <= max,\n@@ -629,7 +737,7 @@ fn lint_type_limits() -> oldvisit::vt<@mut Context> {\n         }\n     }\n \n-    fn rev_binop(binop: ast::binop) -> ast::binop {\n+    fn rev_binop(&mut self, binop: ast::binop) -> ast::binop {\n         match binop {\n             ast::lt => ast::gt,\n             ast::le => ast::ge,\n@@ -641,7 +749,7 @@ fn lint_type_limits() -> oldvisit::vt<@mut Context> {\n \n     // for int & uint, be conservative with the warnings, so that the\n     // warnings are consistent between 32- and 64-bit platforms\n-    fn int_ty_range(int_ty: ast::int_ty) -> (i64, i64) {\n+    fn int_ty_range(&mut self, int_ty: ast::int_ty) -> (i64, i64) {\n         match int_ty {\n             ast::ty_i =>    (i64::min_value,        i64::max_value),\n             ast::ty_char => (u32::min_value as i64, u32::max_value as i64),\n@@ -652,7 +760,7 @@ fn lint_type_limits() -> oldvisit::vt<@mut Context> {\n         }\n     }\n \n-    fn uint_ty_range(uint_ty: ast::uint_ty) -> (u64, u64) {\n+    fn uint_ty_range(&mut self, uint_ty: ast::uint_ty) -> (u64, u64) {\n         match uint_ty {\n             ast::ty_u =>   (u64::min_value,         u64::max_value),\n             ast::ty_u8 =>  (u8::min_value   as u64, u8::max_value   as u64),\n@@ -662,7 +770,8 @@ fn lint_type_limits() -> oldvisit::vt<@mut Context> {\n         }\n     }\n \n-    fn check_limits(cx: &Context,\n+    fn check_limits(&mut self,\n+                    cx: &Context,\n                     binop: ast::binop,\n                     l: @ast::expr,\n                     r: @ast::expr)\n@@ -675,13 +784,13 @@ fn lint_type_limits() -> oldvisit::vt<@mut Context> {\n         // Normalize the binop so that the literal is always on the RHS in\n         // the comparison\n         let norm_binop = if swap {\n-            rev_binop(binop)\n+            self.rev_binop(binop)\n         } else {\n             binop\n         };\n         match ty::get(ty::expr_ty(cx.tcx, expr)).sty {\n             ty::ty_int(int_ty) => {\n-                let (min, max) = int_ty_range(int_ty);\n+                let (min, max) = self.int_ty_range(int_ty);\n                 let lit_val: i64 = match lit.node {\n                     ast::expr_lit(@li) => match li.node {\n                         ast::lit_int(v, _) => v,\n@@ -691,10 +800,10 @@ fn lint_type_limits() -> oldvisit::vt<@mut Context> {\n                     },\n                     _ => fail!()\n                 };\n-                is_valid(norm_binop, lit_val, min, max)\n+                self.is_valid(norm_binop, lit_val, min, max)\n             }\n             ty::ty_uint(uint_ty) => {\n-                let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n+                let (min, max): (u64, u64) = self.uint_ty_range(uint_ty);\n                 let lit_val: u64 = match lit.node {\n                     ast::expr_lit(@li) => match li.node {\n                         ast::lit_int(v, _) => v as u64,\n@@ -704,38 +813,51 @@ fn lint_type_limits() -> oldvisit::vt<@mut Context> {\n                     },\n                     _ => fail!()\n                 };\n-                is_valid(norm_binop, lit_val, min, max)\n+                self.is_valid(norm_binop, lit_val, min, max)\n             }\n             _ => true\n         }\n     }\n \n-    fn is_comparison(binop: ast::binop) -> bool {\n+    fn is_comparison(&mut self, binop: ast::binop) -> bool {\n         match binop {\n             ast::eq | ast::lt | ast::le |\n             ast::ne | ast::ge | ast::gt => true,\n             _ => false\n         }\n     }\n+}\n+\n+impl Visitor<@mut Context> for TypeLimitsLintVisitor {\n+    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n+        self.OVERRIDE_visit_item(i, e);\n+    }\n+\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n+                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n+    }\n+\n+    fn visit_expr(&mut self, e:@ast::expr, cx:@mut Context) {\n \n-    oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_expr: |e,\n-                     (cx, vt): (@mut Context, oldvisit::vt<@mut Context>)| {\n             match e.node {\n                 ast::expr_binary(_, ref binop, l, r) => {\n-                    if is_comparison(*binop)\n-                        && !check_limits(cx, *binop, l, r) {\n+                    if self.is_comparison(*binop)\n+                        && !self.check_limits(cx, *binop, l, r) {\n                         cx.span_lint(type_limits, e.span,\n                                      \"comparison is useless due to type limits\");\n                     }\n                 }\n                 _ => ()\n             }\n-            oldvisit::visit_expr(e, (cx, vt));\n-        },\n+            visit::walk_expr(self, e, cx);\n+    }\n+}\n \n-        .. *oldvisit::default_visitor()\n-    })\n+outer_lint_boilerplate_impl!(TypeLimitsLintVisitor)\n+\n+fn lint_type_limits() -> @mut OuterLint {\n+    @mut TypeLimitsLintVisitor{ stopping_on_items: false } as @mut OuterLint\n }\n \n fn check_item_ctypes(cx: &Context, it: &ast::item) {\n@@ -841,22 +963,54 @@ fn check_item_heap(cx: &Context, it: &ast::item) {\n     }\n }\n \n-fn lint_heap() -> oldvisit::vt<@mut Context> {\n-    oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_expr: |e,\n-                     (cx, vt): (@mut Context, oldvisit::vt<@mut Context>)| {\n+struct HeapLintVisitor { stopping_on_items: bool }\n+\n+impl SubitemStoppableVisitor for HeapLintVisitor {\n+    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n+}\n+\n+impl Visitor<@mut Context> for HeapLintVisitor {\n+    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n+        self.OVERRIDE_visit_item(i, e);\n+    }\n+\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n+                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n+    }\n+\n+    fn visit_expr(&mut self, e:@ast::expr, cx:@mut Context) {\n             let ty = ty::expr_ty(cx.tcx, e);\n             check_type(cx, e.span, ty);\n-            oldvisit::visit_expr(e, (cx, vt));\n-        },\n-        .. *oldvisit::default_visitor()\n-    })\n+            visit::walk_expr(self, e, cx);\n+    }\n+}\n+\n+outer_lint_boilerplate_impl!(HeapLintVisitor)\n+\n+fn lint_heap() -> @mut OuterLint {\n+    @mut HeapLintVisitor { stopping_on_items: false } as @mut OuterLint\n+}\n+\n+struct PathStatementLintVisitor {\n+    stopping_on_items: bool\n+}\n+\n+impl SubitemStoppableVisitor for PathStatementLintVisitor {\n+    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n }\n \n-fn lint_path_statement() -> oldvisit::vt<@mut Context> {\n-    oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_stmt: |s,\n-                     (cx, vt): (@mut Context, oldvisit::vt<@mut Context>)| {\n+impl Visitor<@mut Context> for PathStatementLintVisitor {\n+    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n+        self.OVERRIDE_visit_item(i, e);\n+    }\n+\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n+                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n+    }\n+\n+    fn visit_stmt(&mut self, s:@ast::stmt, cx:@mut Context) {\n             match s.node {\n                 ast::stmt_semi(\n                     @ast::expr { node: ast::expr_path(_), _ },\n@@ -867,10 +1021,15 @@ fn lint_path_statement() -> oldvisit::vt<@mut Context> {\n                 }\n                 _ => ()\n             }\n-            oldvisit::visit_stmt(s, (cx, vt));\n-        },\n-        .. *oldvisit::default_visitor()\n-    })\n+            visit::walk_stmt(self, s, cx);\n+\n+    }\n+}\n+\n+outer_lint_boilerplate_impl!(PathStatementLintVisitor)\n+\n+fn lint_path_statement() -> @mut OuterLint {\n+    @mut PathStatementLintVisitor{ stopping_on_items: false } as @mut OuterLint\n }\n \n fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n@@ -928,10 +1087,24 @@ fn check_item_non_uppercase_statics(cx: &Context, it: &ast::item) {\n     }\n }\n \n-fn lint_unused_unsafe() -> oldvisit::vt<@mut Context> {\n-    oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_expr: |e,\n-                     (cx, vt): (@mut Context, oldvisit::vt<@mut Context>)| {\n+struct UnusedUnsafeLintVisitor { stopping_on_items: bool }\n+\n+impl SubitemStoppableVisitor for UnusedUnsafeLintVisitor {\n+    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n+}\n+\n+impl Visitor<@mut Context> for UnusedUnsafeLintVisitor {\n+    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n+        self.OVERRIDE_visit_item(i, e);\n+    }\n+\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n+                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n+    }\n+\n+    fn visit_expr(&mut self, e:@ast::expr, cx:@mut Context) {\n+\n             match e.node {\n                 ast::expr_block(ref blk) if blk.rules == ast::UnsafeBlock => {\n                     if !cx.tcx.used_unsafe.contains(&blk.id) {\n@@ -941,14 +1114,20 @@ fn lint_unused_unsafe() -> oldvisit::vt<@mut Context> {\n                 }\n                 _ => ()\n             }\n-            oldvisit::visit_expr(e, (cx, vt));\n-        },\n-        .. *oldvisit::default_visitor()\n-    })\n+            visit::walk_expr(self, e, cx);\n+    }\n+}\n+\n+outer_lint_boilerplate_impl!(UnusedUnsafeLintVisitor)\n+\n+fn lint_unused_unsafe() -> @mut OuterLint {\n+    @mut UnusedUnsafeLintVisitor{ stopping_on_items: false } as @mut OuterLint\n }\n \n-fn lint_unused_mut() -> oldvisit::vt<@mut Context> {\n-    fn check_pat(cx: &Context, p: @ast::pat) {\n+struct UnusedMutLintVisitor { stopping_on_items: bool }\n+\n+impl UnusedMutLintVisitor {\n+    fn check_pat(&mut self, cx: &Context, p: @ast::pat) {\n         let mut used = false;\n         let mut bindings = 0;\n         do pat_util::pat_bindings(cx.tcx.def_map, p) |_, id, _, _| {\n@@ -965,39 +1144,60 @@ fn lint_unused_mut() -> oldvisit::vt<@mut Context> {\n         }\n     }\n \n-    fn visit_fn_decl(cx: &Context, fd: &ast::fn_decl) {\n+    fn visit_fn_decl(&mut self, cx: &Context, fd: &ast::fn_decl) {\n         for arg in fd.inputs.iter() {\n             if arg.is_mutbl {\n-                check_pat(cx, arg.pat);\n+                self.check_pat(cx, arg.pat);\n             }\n         }\n     }\n+}\n+\n+impl SubitemStoppableVisitor for UnusedMutLintVisitor {\n+    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n+\n+    fn visit_fn_action(&mut self, _a:&visit::fn_kind, fd:&ast::fn_decl,\n+                       _b:&ast::Block, _c:span, _d:ast::NodeId, cx:@mut Context) {\n+            self.visit_fn_decl(cx, fd);\n+    }\n+}\n \n-    oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_local: |l,\n-                      (cx, vt): (@mut Context, oldvisit::vt<@mut Context>)| {\n+impl Visitor<@mut Context> for UnusedMutLintVisitor {\n+    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n+        self.OVERRIDE_visit_item(i, e);\n+    }\n+\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n+                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n+    }\n+\n+\n+    fn visit_local(&mut self, l:@ast::Local, cx:@mut Context) {\n             if l.is_mutbl {\n-                check_pat(cx, l.pat);\n+                self.check_pat(cx, l.pat);\n             }\n-            oldvisit::visit_local(l, (cx, vt));\n-        },\n-        visit_fn: |a, fd, b, c, d, (cx, vt)| {\n-            visit_fn_decl(cx, fd);\n-            oldvisit::visit_fn(a, fd, b, c, d, (cx, vt));\n-        },\n-        visit_ty_method: |tm, (cx, vt)| {\n-            visit_fn_decl(cx, &tm.decl);\n-            oldvisit::visit_ty_method(tm, (cx, vt));\n-        },\n-        visit_trait_method: |tm, (cx, vt)| {\n+            visit::walk_local(self, l, cx);\n+    }\n+\n+    fn visit_ty_method(&mut self, tm:&ast::TypeMethod, cx:@mut Context) {\n+            self.visit_fn_decl(cx, &tm.decl);\n+            visit::walk_ty_method(self, tm, cx);\n+    }\n+\n+    fn visit_trait_method(&mut self, tm:&ast::trait_method, cx:@mut Context) {\n             match *tm {\n-                ast::required(ref tm) => visit_fn_decl(cx, &tm.decl),\n-                ast::provided(m) => visit_fn_decl(cx, &m.decl)\n+                ast::required(ref tm) => self.visit_fn_decl(cx, &tm.decl),\n+                ast::provided(m) => self.visit_fn_decl(cx, &m.decl)\n             }\n-            oldvisit::visit_trait_method(tm, (cx, vt));\n-        },\n-        .. *oldvisit::default_visitor()\n-    })\n+            visit::walk_trait_method(self, tm, cx);\n+    }\n+}\n+\n+outer_lint_boilerplate_impl!(UnusedMutLintVisitor)\n+\n+fn lint_unused_mut() -> @mut OuterLint {\n+    @mut UnusedMutLintVisitor{ stopping_on_items: false } as @mut OuterLint\n }\n \n fn lint_session(cx: @mut Context) -> @mut visit::Visitor<()> {\n@@ -1013,10 +1213,32 @@ fn lint_session(cx: @mut Context) -> @mut visit::Visitor<()> {\n     }, false)\n }\n \n-fn lint_unnecessary_allocations() -> oldvisit::vt<@mut Context> {\n+struct UnnecessaryAllocationLintVisitor { stopping_on_items: bool }\n+\n+impl SubitemStoppableVisitor for UnnecessaryAllocationLintVisitor {\n+    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n+}\n+\n+impl Visitor<@mut Context> for UnnecessaryAllocationLintVisitor {\n+    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n+        self.OVERRIDE_visit_item(i, e);\n+    }\n+\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n+                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n+    }\n+\n+    fn visit_expr(&mut self, e:@ast::expr, cx:@mut Context) {\n+            self.check(cx, e);\n+            visit::walk_expr(self, e, cx);\n+    }\n+}\n+\n+impl UnnecessaryAllocationLintVisitor {\n     // Warn if string and vector literals with sigils are immediately borrowed.\n     // Those can have the sigil removed.\n-    fn check(cx: &Context, e: &ast::expr) {\n+    fn check(&mut self, cx: &Context, e: &ast::expr) {\n         match e.node {\n             ast::expr_vstore(e2, ast::expr_vstore_uniq) |\n             ast::expr_vstore(e2, ast::expr_vstore_box) => {\n@@ -1042,19 +1264,19 @@ fn lint_unnecessary_allocations() -> oldvisit::vt<@mut Context> {\n             _ => ()\n         }\n     }\n+}\n \n-    oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_expr: |e,\n-                     (cx, vt): (@mut Context, oldvisit::vt<@mut Context>)| {\n-            check(cx, e);\n-            oldvisit::visit_expr(e, (cx, vt));\n-        },\n-        .. *oldvisit::default_visitor()\n-    })\n+outer_lint_boilerplate_impl!(UnnecessaryAllocationLintVisitor)\n+\n+fn lint_unnecessary_allocations() -> @mut OuterLint {\n+    @mut UnnecessaryAllocationLintVisitor{ stopping_on_items: false } as @mut OuterLint\n }\n \n-fn lint_missing_doc() -> oldvisit::vt<@mut Context> {\n-    fn check_attrs(cx: @mut Context,\n+struct MissingDocLintVisitor { stopping_on_items: bool }\n+\n+impl MissingDocLintVisitor {\n+    fn check_attrs(&mut self,\n+                   cx: @mut Context,\n                    attrs: &[ast::Attribute],\n                    sp: span,\n                    msg: &str) {\n@@ -1069,46 +1291,62 @@ fn lint_missing_doc() -> oldvisit::vt<@mut Context> {\n         // otherwise, warn!\n         cx.span_lint(missing_doc, sp, msg);\n     }\n+}\n+\n+impl Visitor<@mut Context> for MissingDocLintVisitor {\n+    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n+        self.OVERRIDE_visit_item(i, e);\n+    }\n \n-    oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_ty_method: |m, (cx, vt)| {\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n+                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n+    }\n+\n+    fn visit_ty_method(&mut self, m:&ast::TypeMethod, cx:@mut Context) {\n             // All ty_method objects are linted about because they're part of a\n             // trait (no visibility)\n-            check_attrs(cx, m.attrs, m.span,\n+            self.check_attrs(cx, m.attrs, m.span,\n                         \"missing documentation for a method\");\n-            oldvisit::visit_ty_method(m, (cx, vt));\n-        },\n+            visit::walk_ty_method(self, m, cx);\n+    }\n+}\n+\n+impl SubitemStoppableVisitor for MissingDocLintVisitor {\n+    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n+\n+    fn visit_fn_action(&mut self, fk:&visit::fn_kind, _d:&ast::fn_decl,\n+                       _b:&ast::Block, sp:span, _id:ast::NodeId, cx:@mut Context) {\n \n-        visit_fn: |fk, d, b, sp, id, (cx, vt)| {\n             // Only warn about explicitly public methods. Soon implicit\n             // public-ness will hopefully be going away.\n             match *fk {\n-                oldvisit::fk_method(_, _, m) if m.vis == ast::public => {\n+                visit::fk_method(_, _, m) if m.vis == ast::public => {\n                     // If we're in a trait implementation, no need to duplicate\n                     // documentation\n                     if !cx.in_trait_impl {\n-                        check_attrs(cx, m.attrs, sp,\n+                        self.check_attrs(cx, m.attrs, sp,\n                                     \"missing documentation for a method\");\n                     }\n                 }\n \n                 _ => {}\n             }\n-            oldvisit::visit_fn(fk, d, b, sp, id, (cx, vt));\n-        },\n+    }\n+\n+    fn visit_item_action(&mut self, it:@ast::item, cx:@mut Context) {\n \n-        visit_item: |it, (cx, vt)| {\n             match it.node {\n                 // Go ahead and match the fields here instead of using\n                 // visit_struct_field while we have access to the enclosing\n                 // struct's visibility\n                 ast::item_struct(sdef, _) if it.vis == ast::public => {\n-                    check_attrs(cx, it.attrs, it.span,\n+                    self.check_attrs(cx, it.attrs, it.span,\n                                 \"missing documentation for a struct\");\n                     for field in sdef.fields.iter() {\n                         match field.node.kind {\n                             ast::named_field(_, vis) if vis != ast::private => {\n-                                check_attrs(cx, field.node.attrs, field.span,\n+                                self.check_attrs(cx, field.node.attrs, field.span,\n                                             \"missing documentation for a field\");\n                             }\n                             ast::unnamed_field | ast::named_field(*) => {}\n@@ -1117,23 +1355,77 @@ fn lint_missing_doc() -> oldvisit::vt<@mut Context> {\n                 }\n \n                 ast::item_trait(*) if it.vis == ast::public => {\n-                    check_attrs(cx, it.attrs, it.span,\n+                    self.check_attrs(cx, it.attrs, it.span,\n                                 \"missing documentation for a trait\");\n                 }\n \n                 ast::item_fn(*) if it.vis == ast::public => {\n-                    check_attrs(cx, it.attrs, it.span,\n+                    self.check_attrs(cx, it.attrs, it.span,\n                                 \"missing documentation for a function\");\n                 }\n \n                 _ => {}\n-            };\n+            }\n+    }\n+}\n+\n+outer_lint_boilerplate_impl!(MissingDocLintVisitor)\n+\n+fn lint_missing_doc() -> @mut OuterLint {\n+    @mut MissingDocLintVisitor { stopping_on_items: false } as @mut OuterLint\n+}\n+\n+struct LintCheckVisitor;\n+\n+impl Visitor<@mut Context> for LintCheckVisitor {\n+\n+    fn visit_item(&mut self, it:@ast::item, cx: @mut Context) {\n+\n+                do cx.with_lint_attrs(it.attrs) {\n+                    match it.node {\n+                        ast::item_impl(_, Some(*), _, _) => {\n+                            cx.in_trait_impl = true;\n+                        }\n+                        _ => {}\n+                    }\n+                    check_item_ctypes(cx, it);\n+                    check_item_non_camel_case_types(cx, it);\n+                    check_item_non_uppercase_statics(cx, it);\n+                    check_item_heap(cx, it);\n+\n+                    cx.process(Item(it));\n+                    visit::walk_item(self, it, cx);\n+                    cx.in_trait_impl = false;\n+                }\n+    }\n \n-            oldvisit::visit_item(it, (cx, vt));\n-        },\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, decl:&ast::fn_decl,\n+                body:&ast::Block, span:span, id:ast::NodeId, cx:@mut Context) {\n \n-        .. *oldvisit::default_visitor()\n-    })\n+                match *fk {\n+                    visit::fk_method(_, _, m) => {\n+                        do cx.with_lint_attrs(m.attrs) {\n+                            cx.process(Method(m));\n+                            visit::walk_fn(self,\n+                                               fk,\n+                                               decl,\n+                                               body,\n+                                               span,\n+                                               id,\n+                                               cx);\n+                        }\n+                    }\n+                    _ => {\n+                        visit::walk_fn(self,\n+                                           fk,\n+                                           decl,\n+                                           body,\n+                                           span,\n+                                           id,\n+                                           cx);\n+                    }\n+                }\n+    }\n }\n \n pub fn check_crate(tcx: ty::ctxt, crate: @ast::Crate) {\n@@ -1172,52 +1464,9 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::Crate) {\n     do cx.with_lint_attrs(crate.attrs) {\n         cx.process(Crate(crate));\n \n-        oldvisit::visit_crate(crate, (cx, oldvisit::mk_vt(@oldvisit::Visitor {\n-            visit_item: |it,\n-                         (cx, vt):\n-                            (@mut Context, oldvisit::vt<@mut Context>)| {\n-                do cx.with_lint_attrs(it.attrs) {\n-                    match it.node {\n-                        ast::item_impl(_, Some(*), _, _) => {\n-                            cx.in_trait_impl = true;\n-                        }\n-                        _ => {}\n-                    }\n-                    check_item_ctypes(cx, it);\n-                    check_item_non_camel_case_types(cx, it);\n-                    check_item_non_uppercase_statics(cx, it);\n-                    check_item_heap(cx, it);\n+        let mut visitor = LintCheckVisitor;\n \n-                    cx.process(Item(it));\n-                    oldvisit::visit_item(it, (cx, vt));\n-                    cx.in_trait_impl = false;\n-                }\n-            },\n-            visit_fn: |fk, decl, body, span, id, (cx, vt)| {\n-                match *fk {\n-                    oldvisit::fk_method(_, _, m) => {\n-                        do cx.with_lint_attrs(m.attrs) {\n-                            cx.process(Method(m));\n-                            oldvisit::visit_fn(fk,\n-                                               decl,\n-                                               body,\n-                                               span,\n-                                               id,\n-                                               (cx, vt));\n-                        }\n-                    }\n-                    _ => {\n-                        oldvisit::visit_fn(fk,\n-                                           decl,\n-                                           body,\n-                                           span,\n-                                           id,\n-                                           (cx, vt));\n-                    }\n-                }\n-            },\n-            .. *oldvisit::default_visitor()\n-        })));\n+        visit::walk_crate(&mut visitor, crate, cx);\n     }\n \n     // If we missed any lints added to the session, then there's a bug somewhere"}]}