{"sha": "dffea43fc1102bdfe16d88ed412c23d4f0f08d9d", "node_id": "C_kwDOAAsO6NoAKGRmZmVhNDNmYzExMDJiZGZlMTZkODhlZDQxMmMyM2Q0ZjBmMDhkOWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-07T03:35:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-07T03:35:10Z"}, "message": "Auto merge of #106180 - RalfJung:dereferenceable-generators, r=nbdd0121\n\nmake &mut !Unpin not dereferenceable, and Box<!Unpin> not noalias\n\nSee https://github.com/rust-lang/unsafe-code-guidelines/issues/381 and [this LLVM discussion](https://discourse.llvm.org/t/interaction-of-noalias-and-dereferenceable/66979). The exact semantics of how `noalias` and `dereferenceable` interact are unclear, and `@comex` found a case of LLVM actually exploiting that ambiguity for optimizations. I think for now we should treat LLVM `dereferenceable` as implying a \"fake read\" to happen immediately at the top of the function (standing in for the spurious reads that LLVM might introduce), and that fake read is subject to all the usual `noalias` restrictions. This means we cannot put `dereferenceable` on `&mut !Unpin` references as those references can alias with other references that are being read and written inside the function (e.g. for self-referential generators), meaning the fake read introduces aliasing conflicts with those other accesses.\n\nFor `&` this is already not a problem due to https://github.com/rust-lang/rust/pull/98017 which removed the `dereferenceable` attribute for other reasons.\n\nRegular `&mut Unpin` references are unaffected, so I hope the impact of this is going to be tiny.\n\nThe first commit does some refactoring of the `PointerKind` enum since I found the old code very confusing each time I had to touch it. It doesn't change behavior.\n\nFixes https://github.com/rust-lang/miri/issues/2714\n\nEDIT: Turns out our `Box<!Unpin>` treatment was incorrect, too, so the PR also fixes that now (in codegen and Miri): we do not put `noalias` on these boxes any more.", "tree": {"sha": "586e4b0654ddcf6e78ba98498deb33ed10c49c98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/586e4b0654ddcf6e78ba98498deb33ed10c49c98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d", "html_url": "https://github.com/rust-lang/rust/commit/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35d6d70a64d8db139a700ccfdb31824bbf4ba350", "url": "https://api.github.com/repos/rust-lang/rust/commits/35d6d70a64d8db139a700ccfdb31824bbf4ba350", "html_url": "https://github.com/rust-lang/rust/commit/35d6d70a64d8db139a700ccfdb31824bbf4ba350"}, {"sha": "1ef16874b5ef79e193526cd23eebd30d45826360", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ef16874b5ef79e193526cd23eebd30d45826360", "html_url": "https://github.com/rust-lang/rust/commit/1ef16874b5ef79e193526cd23eebd30d45826360"}], "stats": {"total": 464, "additions": 245, "deletions": 219}, "files": [{"sha": "0306cb5ce6abd7615d068c093cff045333e2e26b", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=dffea43fc1102bdfe16d88ed412c23d4f0f08d9d", "patch": "@@ -1439,21 +1439,12 @@ impl<V: Idx> fmt::Debug for LayoutS<V> {\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum PointerKind {\n-    /// Most general case, we know no restrictions to tell LLVM.\n-    SharedMutable,\n-\n-    /// `&T` where `T` contains no `UnsafeCell`, is `dereferenceable`, `noalias` and `readonly`.\n-    Frozen,\n-\n-    /// `&mut T` which is `dereferenceable` and `noalias` but not `readonly`.\n-    UniqueBorrowed,\n-\n-    /// `&mut !Unpin`, which is `dereferenceable` but neither `noalias` nor `readonly`.\n-    UniqueBorrowedPinned,\n-\n-    /// `Box<T>`, which is `noalias` (even on return types, unlike the above) but neither `readonly`\n-    /// nor `dereferenceable`.\n-    UniqueOwned,\n+    /// Shared reference. `frozen` indicates the absence of any `UnsafeCell`.\n+    SharedRef { frozen: bool },\n+    /// Mutable reference. `unpin` indicates the absence of any pinned data.\n+    MutableRef { unpin: bool },\n+    /// Box. `unpin` indicates the absence of any pinned data.\n+    Box { unpin: bool },\n }\n \n /// Note that this information is advisory only, and backends are free to ignore it."}, {"sha": "4c2855821384bcf4ed35bda7e3635eaacdcc1e7d", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 95, "deletions": 106, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=dffea43fc1102bdfe16d88ed412c23d4f0f08d9d", "patch": "@@ -818,125 +818,114 @@ where\n         let tcx = cx.tcx();\n         let param_env = cx.param_env();\n \n-        let pointee_info =\n-            match *this.ty.kind() {\n-                ty::RawPtr(mt) if offset.bytes() == 0 => {\n-                    tcx.layout_of(param_env.and(mt.ty)).ok().map(|layout| PointeeInfo {\n-                        size: layout.size,\n-                        align: layout.align.abi,\n-                        safe: None,\n-                    })\n-                }\n-                ty::FnPtr(fn_sig) if offset.bytes() == 0 => {\n-                    tcx.layout_of(param_env.and(tcx.mk_fn_ptr(fn_sig))).ok().map(|layout| {\n-                        PointeeInfo { size: layout.size, align: layout.align.abi, safe: None }\n-                    })\n-                }\n-                ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n-                    let kind = if tcx.sess.opts.optimize == OptLevel::No {\n-                        // Use conservative pointer kind if not optimizing. This saves us the\n-                        // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n-                        // attributes in LLVM have compile-time cost even in unoptimized builds).\n-                        PointerKind::SharedMutable\n-                    } else {\n-                        match mt {\n-                            hir::Mutability::Not => {\n-                                if ty.is_freeze(tcx, cx.param_env()) {\n-                                    PointerKind::Frozen\n-                                } else {\n-                                    PointerKind::SharedMutable\n-                                }\n-                            }\n-                            hir::Mutability::Mut => {\n-                                // References to self-referential structures should not be considered\n-                                // noalias, as another pointer to the structure can be obtained, that\n-                                // is not based-on the original reference. We consider all !Unpin\n-                                // types to be potentially self-referential here.\n-                                if ty.is_unpin(tcx, cx.param_env()) {\n-                                    PointerKind::UniqueBorrowed\n-                                } else {\n-                                    PointerKind::UniqueBorrowedPinned\n-                                }\n-                            }\n-                        }\n-                    };\n+        let pointee_info = match *this.ty.kind() {\n+            ty::RawPtr(mt) if offset.bytes() == 0 => {\n+                tcx.layout_of(param_env.and(mt.ty)).ok().map(|layout| PointeeInfo {\n+                    size: layout.size,\n+                    align: layout.align.abi,\n+                    safe: None,\n+                })\n+            }\n+            ty::FnPtr(fn_sig) if offset.bytes() == 0 => {\n+                tcx.layout_of(param_env.and(tcx.mk_fn_ptr(fn_sig))).ok().map(|layout| PointeeInfo {\n+                    size: layout.size,\n+                    align: layout.align.abi,\n+                    safe: None,\n+                })\n+            }\n+            ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n+                // Use conservative pointer kind if not optimizing. This saves us the\n+                // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n+                // attributes in LLVM have compile-time cost even in unoptimized builds).\n+                let optimize = tcx.sess.opts.optimize != OptLevel::No;\n+                let kind = match mt {\n+                    hir::Mutability::Not => PointerKind::SharedRef {\n+                        frozen: optimize && ty.is_freeze(tcx, cx.param_env()),\n+                    },\n+                    hir::Mutability::Mut => PointerKind::MutableRef {\n+                        unpin: optimize && ty.is_unpin(tcx, cx.param_env()),\n+                    },\n+                };\n \n-                    tcx.layout_of(param_env.and(ty)).ok().map(|layout| PointeeInfo {\n-                        size: layout.size,\n-                        align: layout.align.abi,\n-                        safe: Some(kind),\n-                    })\n-                }\n+                tcx.layout_of(param_env.and(ty)).ok().map(|layout| PointeeInfo {\n+                    size: layout.size,\n+                    align: layout.align.abi,\n+                    safe: Some(kind),\n+                })\n+            }\n \n-                _ => {\n-                    let mut data_variant = match this.variants {\n-                        // Within the discriminant field, only the niche itself is\n-                        // always initialized, so we only check for a pointer at its\n-                        // offset.\n-                        //\n-                        // If the niche is a pointer, it's either valid (according\n-                        // to its type), or null (which the niche field's scalar\n-                        // validity range encodes). This allows using\n-                        // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n-                        // this will continue to work as long as we don't start\n-                        // using more niches than just null (e.g., the first page of\n-                        // the address space, or unaligned pointers).\n-                        Variants::Multiple {\n-                            tag_encoding: TagEncoding::Niche { untagged_variant, .. },\n-                            tag_field,\n-                            ..\n-                        } if this.fields.offset(tag_field) == offset => {\n-                            Some(this.for_variant(cx, untagged_variant))\n-                        }\n-                        _ => Some(this),\n-                    };\n+            _ => {\n+                let mut data_variant = match this.variants {\n+                    // Within the discriminant field, only the niche itself is\n+                    // always initialized, so we only check for a pointer at its\n+                    // offset.\n+                    //\n+                    // If the niche is a pointer, it's either valid (according\n+                    // to its type), or null (which the niche field's scalar\n+                    // validity range encodes). This allows using\n+                    // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n+                    // this will continue to work as long as we don't start\n+                    // using more niches than just null (e.g., the first page of\n+                    // the address space, or unaligned pointers).\n+                    Variants::Multiple {\n+                        tag_encoding: TagEncoding::Niche { untagged_variant, .. },\n+                        tag_field,\n+                        ..\n+                    } if this.fields.offset(tag_field) == offset => {\n+                        Some(this.for_variant(cx, untagged_variant))\n+                    }\n+                    _ => Some(this),\n+                };\n \n-                    if let Some(variant) = data_variant {\n-                        // We're not interested in any unions.\n-                        if let FieldsShape::Union(_) = variant.fields {\n-                            data_variant = None;\n-                        }\n+                if let Some(variant) = data_variant {\n+                    // We're not interested in any unions.\n+                    if let FieldsShape::Union(_) = variant.fields {\n+                        data_variant = None;\n                     }\n+                }\n \n-                    let mut result = None;\n-\n-                    if let Some(variant) = data_variant {\n-                        // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n-                        // (requires passing in the expected address space from the caller)\n-                        let ptr_end = offset + Pointer(AddressSpace::DATA).size(cx);\n-                        for i in 0..variant.fields.count() {\n-                            let field_start = variant.fields.offset(i);\n-                            if field_start <= offset {\n-                                let field = variant.field(cx, i);\n-                                result = field.to_result().ok().and_then(|field| {\n-                                    if ptr_end <= field_start + field.size {\n-                                        // We found the right field, look inside it.\n-                                        let field_info =\n-                                            field.pointee_info_at(cx, offset - field_start);\n-                                        field_info\n-                                    } else {\n-                                        None\n-                                    }\n-                                });\n-                                if result.is_some() {\n-                                    break;\n+                let mut result = None;\n+\n+                if let Some(variant) = data_variant {\n+                    // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+                    // (requires passing in the expected address space from the caller)\n+                    let ptr_end = offset + Pointer(AddressSpace::DATA).size(cx);\n+                    for i in 0..variant.fields.count() {\n+                        let field_start = variant.fields.offset(i);\n+                        if field_start <= offset {\n+                            let field = variant.field(cx, i);\n+                            result = field.to_result().ok().and_then(|field| {\n+                                if ptr_end <= field_start + field.size {\n+                                    // We found the right field, look inside it.\n+                                    let field_info =\n+                                        field.pointee_info_at(cx, offset - field_start);\n+                                    field_info\n+                                } else {\n+                                    None\n                                 }\n+                            });\n+                            if result.is_some() {\n+                                break;\n                             }\n                         }\n                     }\n+                }\n \n-                    // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n-                    if let Some(ref mut pointee) = result {\n-                        if let ty::Adt(def, _) = this.ty.kind() {\n-                            if def.is_box() && offset.bytes() == 0 {\n-                                pointee.safe = Some(PointerKind::UniqueOwned);\n-                            }\n+                // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n+                if let Some(ref mut pointee) = result {\n+                    if let ty::Adt(def, _) = this.ty.kind() {\n+                        if def.is_box() && offset.bytes() == 0 {\n+                            let optimize = tcx.sess.opts.optimize != OptLevel::No;\n+                            pointee.safe = Some(PointerKind::Box {\n+                                unpin: optimize && this.ty.boxed_ty().is_unpin(tcx, cx.param_env()),\n+                            });\n                         }\n                     }\n-\n-                    result\n                 }\n-            };\n+\n+                result\n+            }\n+        };\n \n         debug!(\n             \"pointee_info_at (offset={:?}, type kind: {:?}) => {:?}\","}, {"sha": "ad5527f5a778b89bb11ba49c9f95c23f3b307491", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=dffea43fc1102bdfe16d88ed412c23d4f0f08d9d", "patch": "@@ -254,15 +254,18 @@ fn adjust_for_rust_scalar<'tcx>(\n         if let Some(kind) = pointee.safe {\n             attrs.pointee_align = Some(pointee.align);\n \n-            // `Box` (`UniqueBorrowed`) are not necessarily dereferenceable\n-            // for the entire duration of the function as they can be deallocated\n-            // at any time. Same for shared mutable references. If LLVM had a\n-            // way to say \"dereferenceable on entry\" we could use it here.\n+            // `Box` are not necessarily dereferenceable for the entire duration of the function as\n+            // they can be deallocated at any time. Same for non-frozen shared references (see\n+            // <https://github.com/rust-lang/rust/pull/98017>), and for mutable references to\n+            // potentially self-referential types (see\n+            // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>). If LLVM had a way\n+            // to say \"dereferenceable on entry\" we could use it here.\n             attrs.pointee_size = match kind {\n-                PointerKind::UniqueBorrowed\n-                | PointerKind::UniqueBorrowedPinned\n-                | PointerKind::Frozen => pointee.size,\n-                PointerKind::SharedMutable | PointerKind::UniqueOwned => Size::ZERO,\n+                PointerKind::Box { .. }\n+                | PointerKind::SharedRef { frozen: false }\n+                | PointerKind::MutableRef { unpin: false } => Size::ZERO,\n+                PointerKind::SharedRef { frozen: true }\n+                | PointerKind::MutableRef { unpin: true } => pointee.size,\n             };\n \n             // The aliasing rules for `Box<T>` are still not decided, but currently we emit\n@@ -275,26 +278,24 @@ fn adjust_for_rust_scalar<'tcx>(\n             // versions at all anymore. We still support turning it off using -Zmutable-noalias.\n             let noalias_mut_ref = cx.tcx.sess.opts.unstable_opts.mutable_noalias;\n \n-            // `&mut` pointer parameters never alias other parameters,\n-            // or mutable global data\n+            // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as both\n+            // `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely on memory\n+            // dependencies rather than pointer equality. However this only applies to arguments,\n+            // not return values.\n             //\n-            // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n-            // and can be marked as both `readonly` and `noalias`, as\n-            // LLVM's definition of `noalias` is based solely on memory\n-            // dependencies rather than pointer equality\n+            // `&mut T` and `Box<T>` where `T: Unpin` are unique and hence `noalias`.\n             let no_alias = match kind {\n-                PointerKind::SharedMutable | PointerKind::UniqueBorrowedPinned => false,\n-                PointerKind::UniqueBorrowed => noalias_mut_ref,\n-                PointerKind::UniqueOwned => noalias_for_box,\n-                PointerKind::Frozen => true,\n+                PointerKind::SharedRef { frozen } => frozen,\n+                PointerKind::MutableRef { unpin } => unpin && noalias_mut_ref,\n+                PointerKind::Box { unpin } => unpin && noalias_for_box,\n             };\n             // We can never add `noalias` in return position; that LLVM attribute has some very surprising semantics\n             // (see <https://github.com/rust-lang/unsafe-code-guidelines/issues/385#issuecomment-1368055745>).\n             if no_alias && !is_return {\n                 attrs.set(ArgAttribute::NoAlias);\n             }\n \n-            if kind == PointerKind::Frozen && !is_return {\n+            if matches!(kind, PointerKind::SharedRef { frozen: true }) && !is_return {\n                 attrs.set(ArgAttribute::ReadOnly);\n             }\n         }"}, {"sha": "106e93751d21904c363c07bf26413a75505c78a7", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=dffea43fc1102bdfe16d88ed412c23d4f0f08d9d", "patch": "@@ -81,21 +81,18 @@ impl NewPermission {\n                         protector: None,\n                     }\n                 } else if pointee.is_unpin(*cx.tcx, cx.param_env()) {\n-                    // A regular full mutable reference.\n+                    // A regular full mutable reference. On `FnEntry` this is `noalias` and `dereferenceable`.\n                     NewPermission::Uniform {\n                         perm: Permission::Unique,\n                         access: Some(AccessKind::Write),\n                         protector,\n                     }\n                 } else {\n+                    // `!Unpin` dereferences do not get `noalias` nor `dereferenceable`.\n                     NewPermission::Uniform {\n                         perm: Permission::SharedReadWrite,\n-                        // FIXME: We emit `dereferenceable` for `!Unpin` mutable references, so we\n-                        // should do fake accesses here. But then we run into\n-                        // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>, so for now\n-                        // we don't do that.\n                         access: None,\n-                        protector,\n+                        protector: None,\n                     }\n                 }\n             }\n@@ -109,6 +106,7 @@ impl NewPermission {\n                 }\n             }\n             ty::Ref(_, _pointee, Mutability::Not) => {\n+                // Shared references. If frozen, these get `noalias` and `dereferenceable`; otherwise neither.\n                 NewPermission::FreezeSensitive {\n                     freeze_perm: Permission::SharedReadOnly,\n                     freeze_access: Some(AccessKind::Read),\n@@ -137,6 +135,32 @@ impl NewPermission {\n         }\n     }\n \n+    fn from_box_ty<'tcx>(\n+        ty: Ty<'tcx>,\n+        kind: RetagKind,\n+        cx: &crate::MiriInterpCx<'_, 'tcx>,\n+    ) -> Self {\n+        // `ty` is not the `Box` but the field of the Box with this pointer (due to allocator handling).\n+        let pointee = ty.builtin_deref(true).unwrap().ty;\n+        if pointee.is_unpin(*cx.tcx, cx.param_env()) {\n+            // A regular box. On `FnEntry` this is `noalias`, but not `dereferenceable` (hence only\n+            // a weak protector).\n+            NewPermission::Uniform {\n+                perm: Permission::Unique,\n+                access: Some(AccessKind::Write),\n+                protector: (kind == RetagKind::FnEntry)\n+                    .then_some(ProtectorKind::WeakProtector),\n+            }\n+        } else {\n+            // `!Unpin` boxes do not get `noalias` nor `dereferenceable`.\n+            NewPermission::Uniform {\n+                perm: Permission::SharedReadWrite,\n+                access: None,\n+                protector: None,\n+            }\n+        }\n+    }\n+\n     fn protector(&self) -> Option<ProtectorKind> {\n         match self {\n             NewPermission::Uniform { protector, .. } => *protector,\n@@ -916,12 +940,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n             fn visit_box(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n                 // Boxes get a weak protectors, since they may be deallocated.\n-                let new_perm = NewPermission::Uniform {\n-                    perm: Permission::Unique,\n-                    access: Some(AccessKind::Write),\n-                    protector: (self.kind == RetagKind::FnEntry)\n-                        .then_some(ProtectorKind::WeakProtector),\n-                };\n+                let new_perm = NewPermission::from_box_ty(place.layout.ty, self.kind, self.ecx);\n                 self.retag_ptr_inplace(place, new_perm, self.retag_cause)\n             }\n "}, {"sha": "fd67dccd14df6d826b0767b726fd31f827d37f3d", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35d6d70a64d8db139a700ccfdb31824bbf4ba350/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35d6d70a64d8db139a700ccfdb31824bbf4ba350/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs?ref=35d6d70a64d8db139a700ccfdb31824bbf4ba350", "patch": "@@ -1,16 +0,0 @@\n-//@error-pattern: /deallocating while item \\[SharedReadWrite for .*\\] is strongly protected/\n-use std::marker::PhantomPinned;\n-\n-pub struct NotUnpin(i32, PhantomPinned);\n-\n-fn inner(x: &mut NotUnpin, f: fn(&mut NotUnpin)) {\n-    // `f` may mutate, but it may not deallocate!\n-    f(x)\n-}\n-\n-fn main() {\n-    inner(Box::leak(Box::new(NotUnpin(0, PhantomPinned))), |x| {\n-        let raw = x as *mut _;\n-        drop(unsafe { Box::from_raw(raw) });\n-    });\n-}"}, {"sha": "47cfa0de7258c1fe0263442c8387a6d7b3d7a7d9", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector2.stderr", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/35d6d70a64d8db139a700ccfdb31824bbf4ba350/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/35d6d70a64d8db139a700ccfdb31824bbf4ba350/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr?ref=35d6d70a64d8db139a700ccfdb31824bbf4ba350", "patch": "@@ -1,38 +0,0 @@\n-error: Undefined Behavior: deallocating while item [SharedReadWrite for <TAG>] is strongly protected by call ID\n-  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   |\n-LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [SharedReadWrite for <TAG>] is strongly protected by call ID\n-   |\n-   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n-   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-   = note: BACKTRACE:\n-   = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   = note: inside `<std::alloc::Global as std::alloc::Allocator>::deallocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   = note: inside `alloc::alloc::box_free::<NotUnpin, std::alloc::Global>` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   = note: inside `std::ptr::drop_in_place::<std::boxed::Box<NotUnpin>> - shim(Some(std::boxed::Box<NotUnpin>))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n-   = note: inside `std::mem::drop::<std::boxed::Box<NotUnpin>>` at RUSTLIB/core/src/mem/mod.rs:LL:CC\n-note: inside closure\n-  --> $DIR/deallocate_against_protector2.rs:LL:CC\n-   |\n-LL |         drop(unsafe { Box::from_raw(raw) });\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: inside `<[closure@$DIR/deallocate_against_protector2.rs:LL:CC] as std::ops::FnOnce<(&mut NotUnpin,)>>::call_once - shim` at RUSTLIB/core/src/ops/function.rs:LL:CC\n-note: inside `inner`\n-  --> $DIR/deallocate_against_protector2.rs:LL:CC\n-   |\n-LL |     f(x)\n-   |     ^^^^\n-note: inside `main`\n-  --> $DIR/deallocate_against_protector2.rs:LL:CC\n-   |\n-LL | /     inner(Box::leak(Box::new(NotUnpin(0, PhantomPinned))), |x| {\n-LL | |         let raw = x as *mut _;\n-LL | |         drop(unsafe { Box::from_raw(raw) });\n-LL | |     });\n-   | |______^\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}, {"sha": "6994def16a1da3f537c9fb78bdc4a8622c2d13d5", "filename": "src/tools/miri/tests/pass/stacked-borrows/future-self-referential.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs?ref=dffea43fc1102bdfe16d88ed412c23d4f0f08d9d", "patch": "@@ -26,6 +26,19 @@ impl Future for Delay {\n     }\n }\n \n+fn mk_waker() -> Waker {\n+    use std::sync::Arc;\n+\n+    struct MyWaker;\n+    impl Wake for MyWaker {\n+        fn wake(self: Arc<Self>) {\n+            unimplemented!()\n+        }\n+    }\n+\n+    Waker::from(Arc::new(MyWaker))\n+}\n+\n async fn do_stuff() {\n     (&mut Delay::new(1)).await;\n }\n@@ -73,16 +86,7 @@ impl Future for DoStuff {\n }\n \n fn run_fut<T>(fut: impl Future<Output = T>) -> T {\n-    use std::sync::Arc;\n-\n-    struct MyWaker;\n-    impl Wake for MyWaker {\n-        fn wake(self: Arc<Self>) {\n-            unimplemented!()\n-        }\n-    }\n-\n-    let waker = Waker::from(Arc::new(MyWaker));\n+    let waker = mk_waker();\n     let mut context = Context::from_waker(&waker);\n \n     let mut pinned = pin!(fut);\n@@ -94,7 +98,37 @@ fn run_fut<T>(fut: impl Future<Output = T>) -> T {\n     }\n }\n \n+fn self_referential_box() {\n+    let waker = mk_waker();\n+    let cx = &mut Context::from_waker(&waker);\n+\n+    async fn my_fut() -> i32 {\n+        let val = 10;\n+        let val_ref = &val;\n+\n+        let _ = Delay::new(1).await;\n+\n+        *val_ref\n+    }\n+\n+    fn box_poll<F: Future>(\n+        mut f: Pin<Box<F>>,\n+        cx: &mut Context<'_>,\n+    ) -> (Pin<Box<F>>, Poll<F::Output>) {\n+        let p = f.as_mut().poll(cx);\n+        (f, p)\n+    }\n+\n+    let my_fut = Box::pin(my_fut());\n+    let (my_fut, p1) = box_poll(my_fut, cx);\n+    assert!(p1.is_pending());\n+    let (my_fut, p2) = box_poll(my_fut, cx);\n+    assert!(p2.is_ready());\n+    drop(my_fut);\n+}\n+\n fn main() {\n     run_fut(do_stuff());\n     run_fut(DoStuff::new());\n+    self_referential_box();\n }"}, {"sha": "8e78efa73c751578c9c3b7849553bb62fcd32e31", "filename": "src/tools/miri/tests/pass/stacked-borrows/stacked-borrows.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs?ref=dffea43fc1102bdfe16d88ed412c23d4f0f08d9d", "patch": "@@ -19,6 +19,7 @@ fn main() {\n     array_casts();\n     mut_below_shr();\n     wide_raw_ptr_in_tuple();\n+    not_unpin_not_protected();\n }\n \n // Make sure that reading from an `&mut` does, like reborrowing to `&`,\n@@ -219,3 +220,22 @@ fn wide_raw_ptr_in_tuple() {\n     // Make sure the fn ptr part of the vtable is still fine.\n     r.type_id();\n }\n+\n+fn not_unpin_not_protected() {\n+    // `&mut !Unpin`, at least for now, does not get `noalias` nor `dereferenceable`, so we also\n+    // don't add protectors. (We could, but until we have a better idea for where we want to go with\n+    // the self-referntial-generator situation, it does not seem worth the potential trouble.)\n+    use std::marker::PhantomPinned;\n+\n+    pub struct NotUnpin(i32, PhantomPinned);\n+\n+    fn inner(x: &mut NotUnpin, f: fn(&mut NotUnpin)) {\n+        // `f` may mutate, but it may not deallocate!\n+        f(x)\n+    }\n+\n+    inner(Box::leak(Box::new(NotUnpin(0, PhantomPinned))), |x| {\n+        let raw = x as *mut _;\n+        drop(unsafe { Box::from_raw(raw) });\n+    });\n+}"}, {"sha": "0c62e0d35e36d91624e2ac519e56f1cc72d9c91e", "filename": "tests/codegen/function-arguments-noopt.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/tests%2Fcodegen%2Ffunction-arguments-noopt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/tests%2Fcodegen%2Ffunction-arguments-noopt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ffunction-arguments-noopt.rs?ref=dffea43fc1102bdfe16d88ed412c23d4f0f08d9d", "patch": "@@ -29,6 +29,12 @@ pub fn borrow(x: &i32) -> &i32 {\n   x\n }\n \n+// CHECK: align 4 {{i32\\*|ptr}} @borrow_mut({{i32\\*|ptr}} align 4 %x)\n+#[no_mangle]\n+pub fn borrow_mut(x: &mut i32) -> &mut i32 {\n+  x\n+}\n+\n // CHECK-LABEL: @borrow_call\n #[no_mangle]\n pub fn borrow_call(x: &i32, f: fn(&i32) -> &i32) -> &i32 {"}, {"sha": "96dfde18683e34b2c3ab452a79920edd040a72a1", "filename": "tests/codegen/function-arguments.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/tests%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d/tests%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ffunction-arguments.rs?ref=dffea43fc1102bdfe16d88ed412c23d4f0f08d9d", "patch": "@@ -85,6 +85,12 @@ pub fn option_nonzero_int(x: Option<NonZeroU64>) -> Option<NonZeroU64> {\n pub fn readonly_borrow(_: &i32) {\n }\n \n+// CHECK: noundef align 4 dereferenceable(4) {{i32\\*|ptr}} @readonly_borrow_ret()\n+#[no_mangle]\n+pub fn readonly_borrow_ret() -> &'static i32 {\n+  loop {}\n+}\n+\n // CHECK: @static_borrow({{i32\\*|ptr}} noalias noundef readonly align 4 dereferenceable(4) %_1)\n // static borrow may be captured\n #[no_mangle]\n@@ -115,9 +121,17 @@ pub fn mutable_unsafe_borrow(_: &mut UnsafeInner) {\n pub fn mutable_borrow(_: &mut i32) {\n }\n \n+// CHECK: noundef align 4 dereferenceable(4) {{i32\\*|ptr}} @mutable_borrow_ret()\n+#[no_mangle]\n+pub fn mutable_borrow_ret() -> &'static mut i32 {\n+  loop {}\n+}\n+\n #[no_mangle]\n-// CHECK: @mutable_notunpin_borrow({{i32\\*|ptr}} noundef align 4 dereferenceable(4) %_1)\n+// CHECK: @mutable_notunpin_borrow({{i32\\*|ptr}} noundef nonnull align 4 %_1)\n // This one is *not* `noalias` because it might be self-referential.\n+// It is also not `dereferenceable` due to\n+// <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>.\n pub fn mutable_notunpin_borrow(_: &mut NotUnpin) {\n }\n \n@@ -167,6 +181,12 @@ pub fn _box(x: Box<i32>) -> Box<i32> {\n   x\n }\n \n+// CHECK: noundef nonnull align 4 {{i32\\*|ptr}} @notunpin_box({{i32\\*|ptr}} noundef nonnull align 4 %x)\n+#[no_mangle]\n+pub fn notunpin_box(x: Box<NotUnpin>) -> Box<NotUnpin> {\n+  x\n+}\n+\n // CHECK: @struct_return({{%S\\*|ptr}} noalias nocapture noundef sret(%S) dereferenceable(32){{( %0)?}})\n #[no_mangle]\n pub fn struct_return() -> S {\n@@ -233,12 +253,12 @@ pub fn trait_raw(_: *const dyn Drop) {\n \n // CHECK: @trait_box({{\\{\\}\\*|ptr}} noalias noundef nonnull align 1{{( %0)?}}, {{.+}} noalias noundef readonly align {{.*}} dereferenceable({{.*}}){{( %1)?}})\n #[no_mangle]\n-pub fn trait_box(_: Box<dyn Drop>) {\n+pub fn trait_box(_: Box<dyn Drop + Unpin>) {\n }\n \n // CHECK: { {{i8\\*|ptr}}, {{i8\\*|ptr}} } @trait_option({{i8\\*|ptr}} noalias noundef align 1 %x.0, {{i8\\*|ptr}} %x.1)\n #[no_mangle]\n-pub fn trait_option(x: Option<Box<dyn Drop>>) -> Option<Box<dyn Drop>> {\n+pub fn trait_option(x: Option<Box<dyn Drop + Unpin>>) -> Option<Box<dyn Drop + Unpin>> {\n   x\n }\n "}]}