{"sha": "b422373d862082b1a27bd7d0e2319a31ad745aae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0MjIzNzNkODYyMDgyYjFhMjdiZDdkMGUyMzE5YTMxYWQ3NDVhYWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-15T18:41:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-15T18:41:05Z"}, "message": "auto merge of #15426 : aochagavia/rust/str, r=alexcrichton\n\n* Deprecated `str::from_utf8_owned` in favor of `String::from_utf8`\r\n* Deprecated `str::from_utf8_lossy` in favor of `String::from_utf8_lossy`\r\n* Deprecated `str::from_utf16` in favor of `String::from_utf16`\r\n* Deprecated `str::from_utf16_lossy` in favor of `String::from_utf16_lossy`\r\n* Deprecated `str::from_chars` in favor of `String::from_chars`\r\n* Deprecated `str::from_char` in favor of `String::from_char` and `.to_string()`\r\n* Deprecated `str::from_byte` in favor of `String::from_byte`\r\n\r\n[breaking-change]", "tree": {"sha": "f0728d449ed0b611c7d49d991209388f3b3a518f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0728d449ed0b611c7d49d991209388f3b3a518f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b422373d862082b1a27bd7d0e2319a31ad745aae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b422373d862082b1a27bd7d0e2319a31ad745aae", "html_url": "https://github.com/rust-lang/rust/commit/b422373d862082b1a27bd7d0e2319a31ad745aae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b422373d862082b1a27bd7d0e2319a31ad745aae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd54321c085da9e40dd340b738547f7287e3c579", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd54321c085da9e40dd340b738547f7287e3c579", "html_url": "https://github.com/rust-lang/rust/commit/cd54321c085da9e40dd340b738547f7287e3c579"}, {"sha": "584fbde5d1f9e0048592b44195263dfea0ee8231", "url": "https://api.github.com/repos/rust-lang/rust/commits/584fbde5d1f9e0048592b44195263dfea0ee8231", "html_url": "https://github.com/rust-lang/rust/commit/584fbde5d1f9e0048592b44195263dfea0ee8231"}], "stats": {"total": 1097, "additions": 534, "deletions": 563}, "files": [{"sha": "28ff2c18ad3baf5fb9af65d0c272e768aa5ca252", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::str;\n use std::io::process::{ProcessExit, Command, Process, ProcessOutput};\n use std::dynamic_lib::DynamicLibrary;\n \n@@ -25,7 +24,7 @@ fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n     // Add the new dylib search path var\n     let var = DynamicLibrary::envvar();\n     let newpath = DynamicLibrary::create_path(path.as_slice());\n-    let newpath = str::from_utf8(newpath.as_slice()).unwrap().to_string();\n+    let newpath = String::from_utf8(newpath).unwrap();\n     cmd.env(var.to_string(), newpath);\n }\n \n@@ -55,8 +54,8 @@ pub fn run(lib_path: &str,\n \n             Some(Result {\n                 status: status,\n-                out: str::from_utf8(output.as_slice()).unwrap().to_string(),\n-                err: str::from_utf8(error.as_slice()).unwrap().to_string()\n+                out: String::from_utf8(output).unwrap(),\n+                err: String::from_utf8(error).unwrap()\n             })\n         },\n         Err(..) => None"}, {"sha": "0c325a0d65aef660e8f891bce0868885afc34b46", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -158,7 +158,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n     let src = File::open(testfile).read_to_end().unwrap();\n-    let src = str::from_utf8(src.as_slice()).unwrap().to_string();\n+    let src = String::from_utf8(src.clone()).unwrap();\n     let mut srcs = vec!(src);\n \n     let mut round = 0;\n@@ -185,10 +185,10 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n         Some(ref file) => {\n             let filepath = testfile.dir_path().join(file);\n             let s = File::open(&filepath).read_to_end().unwrap();\n-            str::from_utf8(s.as_slice()).unwrap().to_string()\n-          }\n-          None => { (*srcs.get(srcs.len() - 2u)).clone() }\n-        };\n+            String::from_utf8(s).unwrap()\n+        }\n+        None => { (*srcs.get(srcs.len() - 2u)).clone() }\n+    };\n     let mut actual = (*srcs.get(srcs.len() - 1u)).clone();\n \n     if props.pp_exact.is_some() {\n@@ -582,8 +582,8 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n                     process.wait_with_output().unwrap();\n \n                 (status,\n-                 str::from_utf8(output.as_slice()).unwrap().to_string(),\n-                 str::from_utf8(error.as_slice()).unwrap().to_string())\n+                 String::from_utf8(output).unwrap(),\n+                 String::from_utf8(error).unwrap())\n             },\n             Err(e) => {\n                 fatal(format!(\"Failed to setup Python process for \\\n@@ -813,7 +813,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n                 c\n             }\n         } ).collect();\n-        str::from_chars(c.as_slice()).to_string()\n+        String::from_chars(c.as_slice())\n     }\n \n     #[cfg(target_os = \"win32\")]"}, {"sha": "c2bde31b85981fac8987b2e115f7013c4196724f", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 21, "deletions": 393, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -94,66 +94,27 @@ pub use unicode::{Words, UnicodeStrSlice};\n Section: Creating a string\n */\n \n-/// Consumes a vector of bytes to create a new utf-8 string.\n-///\n-/// Returns `Err` with the original vector if the vector contains invalid\n-/// UTF-8.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::str;\n-/// let hello_vec = vec![104, 101, 108, 108, 111];\n-/// let string = str::from_utf8_owned(hello_vec);\n-/// assert_eq!(string, Ok(\"hello\".to_string()));\n-/// ```\n+/// Deprecated. Replaced by `String::from_utf8`\n+#[deprecated = \"Replaced by `String::from_utf8`\"]\n pub fn from_utf8_owned(vv: Vec<u8>) -> Result<String, Vec<u8>> {\n     String::from_utf8(vv)\n }\n \n-/// Convert a byte to a UTF-8 string\n-///\n-/// # Failure\n-///\n-/// Fails if invalid UTF-8\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::str;\n-/// let string = str::from_byte(104);\n-/// assert_eq!(string.as_slice(), \"h\");\n-/// ```\n+/// Deprecated. Replaced by `String::from_byte`\n+#[deprecated = \"Replaced by String::from_byte\"]\n pub fn from_byte(b: u8) -> String {\n     assert!(b < 128u8);\n     String::from_char(1, b as char)\n }\n \n-/// Convert a char to a string\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::str;\n-/// let string = str::from_char('b');\n-/// assert_eq!(string.as_slice(), \"b\");\n-/// ```\n+/// Deprecated. Use `String::from_char` or `char::to_string()` instead\n+#[deprecated = \"use String::from_char or char.to_string()\"]\n pub fn from_char(ch: char) -> String {\n-    let mut buf = String::new();\n-    buf.push_char(ch);\n-    buf\n+    String::from_char(1, ch)\n }\n \n-/// Convert a vector of chars to a string\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::str;\n-/// let chars = ['h', 'e', 'l', 'l', 'o'];\n-/// let string = str::from_chars(chars);\n-/// assert_eq!(string.as_slice(), \"hello\");\n-/// ```\n+/// Deprecated. Replaced by `String::from_chars`\n+#[deprecated = \"use String::from_chars instead\"]\n pub fn from_chars(chs: &[char]) -> String {\n     chs.iter().map(|c| *c).collect()\n }\n@@ -377,51 +338,16 @@ pub fn replace(s: &str, from: &str, to: &str) -> String {\n Section: Misc\n */\n \n-/// Decode a UTF-16 encoded vector `v` into a string, returning `None`\n-/// if `v` contains any invalid data.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::str;\n-///\n-/// // \ud834\udd1emusic\n-/// let mut v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///              0x0073, 0x0069, 0x0063];\n-/// assert_eq!(str::from_utf16(v), Some(\"\ud834\udd1emusic\".to_string()));\n-///\n-/// // \ud834\udd1emu<invalid>ic\n-/// v[4] = 0xD800;\n-/// assert_eq!(str::from_utf16(v), None);\n-/// ```\n+/// Deprecated. Use `String::from_utf16`.\n+#[deprecated = \"Replaced by String::from_utf16\"]\n pub fn from_utf16(v: &[u16]) -> Option<String> {\n-    let mut s = String::with_capacity(v.len() / 2);\n-    for c in utf16_items(v) {\n-        match c {\n-            ScalarValue(c) => s.push_char(c),\n-            LoneSurrogate(_) => return None\n-        }\n-    }\n-    Some(s)\n+    String::from_utf16(v)\n }\n \n-/// Decode a UTF-16 encoded vector `v` into a string, replacing\n-/// invalid data with the replacement character (U+FFFD).\n-///\n-/// # Example\n-/// ```rust\n-/// use std::str;\n-///\n-/// // \ud834\udd1emus<invalid>ic<invalid>\n-/// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///          0x0073, 0xDD1E, 0x0069, 0x0063,\n-///          0xD834];\n-///\n-/// assert_eq!(str::from_utf16_lossy(v),\n-///            \"\ud834\udd1emus\\uFFFDic\\uFFFD\".to_string());\n-/// ```\n+/// Deprecated. Use `String::from_utf16_lossy`.\n+#[deprecated = \"Replaced by String::from_utf16_lossy\"]\n pub fn from_utf16_lossy(v: &[u16]) -> String {\n-    utf16_items(v).map(|c| c.to_char_lossy()).collect()\n+    String::from_utf16_lossy(v)\n }\n \n // Return the initial codepoint accumulator for the first byte.\n@@ -436,131 +362,10 @@ macro_rules! utf8_acc_cont_byte(\n     ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n )\n \n-static TAG_CONT_U8: u8 = 128u8;\n-\n-/// Converts a vector of bytes to a new utf-8 string.\n-/// Any invalid utf-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// let input = b\"Hello \\xF0\\x90\\x80World\";\n-/// let output = std::str::from_utf8_lossy(input);\n-/// assert_eq!(output.as_slice(), \"Hello \\uFFFDWorld\");\n-/// ```\n+/// Deprecated. Use `String::from_utf8_lossy`.\n+#[deprecated = \"Replaced by String::from_utf8_lossy\"]\n pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n-    if is_utf8(v) {\n-        return Slice(unsafe { mem::transmute(v) })\n-    }\n-\n-    static REPLACEMENT: &'static [u8] = b\"\\xEF\\xBF\\xBD\"; // U+FFFD in UTF-8\n-    let mut i = 0;\n-    let total = v.len();\n-    fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n-        unsafe { *xs.unsafe_ref(i) }\n-    }\n-    fn safe_get(xs: &[u8], i: uint, total: uint) -> u8 {\n-        if i >= total {\n-            0\n-        } else {\n-            unsafe_get(xs, i)\n-        }\n-    }\n-\n-    let mut res = String::with_capacity(total);\n-\n-    if i > 0 {\n-        unsafe {\n-            res.push_bytes(v.slice_to(i))\n-        };\n-    }\n-\n-    // subseqidx is the index of the first byte of the subsequence we're looking at.\n-    // It's used to copy a bunch of contiguous good codepoints at once instead of copying\n-    // them one by one.\n-    let mut subseqidx = 0;\n-\n-    while i < total {\n-        let i_ = i;\n-        let byte = unsafe_get(v, i);\n-        i += 1;\n-\n-        macro_rules! error(() => ({\n-            unsafe {\n-                if subseqidx != i_ {\n-                    res.push_bytes(v.slice(subseqidx, i_));\n-                }\n-                subseqidx = i;\n-                res.push_bytes(REPLACEMENT);\n-            }\n-        }))\n-\n-        if byte < 128u8 {\n-            // subseqidx handles this\n-        } else {\n-            let w = utf8_char_width(byte);\n-\n-            match w {\n-                2 => {\n-                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n-                        error!();\n-                        continue;\n-                    }\n-                    i += 1;\n-                }\n-                3 => {\n-                    match (byte, safe_get(v, i, total)) {\n-                        (0xE0        , 0xA0 .. 0xBF) => (),\n-                        (0xE1 .. 0xEC, 0x80 .. 0xBF) => (),\n-                        (0xED        , 0x80 .. 0x9F) => (),\n-                        (0xEE .. 0xEF, 0x80 .. 0xBF) => (),\n-                        _ => {\n-                            error!();\n-                            continue;\n-                        }\n-                    }\n-                    i += 1;\n-                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n-                        error!();\n-                        continue;\n-                    }\n-                    i += 1;\n-                }\n-                4 => {\n-                    match (byte, safe_get(v, i, total)) {\n-                        (0xF0        , 0x90 .. 0xBF) => (),\n-                        (0xF1 .. 0xF3, 0x80 .. 0xBF) => (),\n-                        (0xF4        , 0x80 .. 0x8F) => (),\n-                        _ => {\n-                            error!();\n-                            continue;\n-                        }\n-                    }\n-                    i += 1;\n-                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n-                        error!();\n-                        continue;\n-                    }\n-                    i += 1;\n-                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n-                        error!();\n-                        continue;\n-                    }\n-                    i += 1;\n-                }\n-                _ => {\n-                    error!();\n-                    continue;\n-                }\n-            }\n-        }\n-    }\n-    if subseqidx < total {\n-        unsafe {\n-            res.push_bytes(v.slice(subseqidx, total))\n-        };\n-    }\n-    Owned(res.into_string())\n+    String::from_utf8_lossy(v)\n }\n \n /*\n@@ -804,7 +609,6 @@ pub mod raw {\n     #[test]\n     fn test_from_buf_len() {\n         use slice::ImmutableVector;\n-        use str::StrAllocating;\n \n         unsafe {\n             let a = vec![65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n@@ -1009,8 +813,7 @@ mod tests {\n     use std::default::Default;\n     use std::char::Char;\n     use std::clone::Clone;\n-    use std::cmp::{Equal, Greater, Less, Ord, Eq, PartialOrd, PartialEq, Equiv};\n-    use std::result::{Ok, Err};\n+    use std::cmp::{Equal, Greater, Less, Ord, PartialOrd, Equiv};\n     use std::option::{Some, None};\n     use std::ptr::RawPtr;\n     use std::iter::{Iterator, DoubleEndedIterator};\n@@ -1676,95 +1479,6 @@ mod tests {\n         assert!(!\"\".contains_char('a'));\n     }\n \n-    #[test]\n-    fn test_utf16() {\n-        let pairs =\n-            [(String::from_str(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\"),\n-              vec![0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n-                0xd800_u16, 0xdf3b_u16, 0xd800_u16, 0xdf46_u16,\n-                0xd800_u16, 0xdf39_u16, 0xd800_u16, 0xdf3b_u16,\n-                0xd800_u16, 0xdf30_u16, 0x000a_u16]),\n-\n-             (String::from_str(\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\"),\n-              vec![0xd801_u16, 0xdc12_u16, 0xd801_u16,\n-                0xdc49_u16, 0xd801_u16, 0xdc2e_u16, 0xd801_u16,\n-                0xdc40_u16, 0xd801_u16, 0xdc32_u16, 0xd801_u16,\n-                0xdc4b_u16, 0x0020_u16, 0xd801_u16, 0xdc0f_u16,\n-                0xd801_u16, 0xdc32_u16, 0xd801_u16, 0xdc4d_u16,\n-                0x000a_u16]),\n-\n-             (String::from_str(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\"),\n-              vec![0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n-                0xd800_u16, 0xdf0b_u16, 0xd800_u16, 0xdf04_u16,\n-                0xd800_u16, 0xdf11_u16, 0xd800_u16, 0xdf09_u16,\n-                0x00b7_u16, 0xd800_u16, 0xdf0c_u16, 0xd800_u16,\n-                0xdf04_u16, 0xd800_u16, 0xdf15_u16, 0xd800_u16,\n-                0xdf04_u16, 0xd800_u16, 0xdf0b_u16, 0xd800_u16,\n-                0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]),\n-\n-             (String::from_str(\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\"),\n-              vec![0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n-                0xd801_u16, 0xdc88_u16, 0xd801_u16, 0xdc91_u16,\n-                0xd801_u16, 0xdc9b_u16, 0xd801_u16, 0xdc92_u16,\n-                0x0020_u16, 0xd801_u16, 0xdc95_u16, 0xd801_u16,\n-                0xdc93_u16, 0x0020_u16, 0xd801_u16, 0xdc88_u16,\n-                0xd801_u16, 0xdc9a_u16, 0xd801_u16, 0xdc8d_u16,\n-                0x0020_u16, 0xd801_u16, 0xdc8f_u16, 0xd801_u16,\n-                0xdc9c_u16, 0xd801_u16, 0xdc92_u16, 0xd801_u16,\n-                0xdc96_u16, 0xd801_u16, 0xdc86_u16, 0x0020_u16,\n-                0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n-                0x000a_u16 ]),\n-             // Issue #12318, even-numbered non-BMP planes\n-             (String::from_str(\"\\U00020000\"),\n-              vec![0xD840, 0xDC00])];\n-\n-        for p in pairs.iter() {\n-            let (s, u) = (*p).clone();\n-            let s_as_utf16 = s.as_slice().utf16_units().collect::<Vec<u16>>();\n-            let u_as_string = from_utf16(u.as_slice()).unwrap();\n-\n-            assert!(is_utf16(u.as_slice()));\n-            assert_eq!(s_as_utf16, u);\n-\n-            assert_eq!(u_as_string, s);\n-            assert_eq!(from_utf16_lossy(u.as_slice()), s);\n-\n-            assert_eq!(from_utf16(s_as_utf16.as_slice()).unwrap(), s);\n-            assert_eq!(u_as_string.as_slice().utf16_units().collect::<Vec<u16>>(), u);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_utf16_invalid() {\n-        // completely positive cases tested above.\n-        // lead + eof\n-        assert_eq!(from_utf16([0xD800]), None);\n-        // lead + lead\n-        assert_eq!(from_utf16([0xD800, 0xD800]), None);\n-\n-        // isolated trail\n-        assert_eq!(from_utf16([0x0061, 0xDC00]), None);\n-\n-        // general\n-        assert_eq!(from_utf16([0xD800, 0xd801, 0xdc8b, 0xD800]), None);\n-    }\n-\n-    #[test]\n-    fn test_utf16_lossy() {\n-        // completely positive cases tested above.\n-        // lead + eof\n-        assert_eq!(from_utf16_lossy([0xD800]), String::from_str(\"\\uFFFD\"));\n-        // lead + lead\n-        assert_eq!(from_utf16_lossy([0xD800, 0xD800]), String::from_str(\"\\uFFFD\\uFFFD\"));\n-\n-        // isolated trail\n-        assert_eq!(from_utf16_lossy([0x0061, 0xDC00]), String::from_str(\"a\\uFFFD\"));\n-\n-        // general\n-        assert_eq!(from_utf16_lossy([0xD800, 0xd801, 0xdc8b, 0xD800]),\n-                   String::from_str(\"\\uFFFD\ud801\udc8b\\uFFFD\"));\n-    }\n-\n     #[test]\n     fn test_truncate_utf16_at_nul() {\n         let v = [];\n@@ -1790,7 +1504,7 @@ mod tests {\n         let mut pos = 0;\n         for ch in v.iter() {\n             assert!(s.char_at(pos) == *ch);\n-            pos += from_char(*ch).len();\n+            pos += String::from_char(1, *ch).len();\n         }\n     }\n \n@@ -1801,7 +1515,7 @@ mod tests {\n         let mut pos = s.len();\n         for ch in v.iter().rev() {\n             assert!(s.char_at_reverse(pos) == *ch);\n-            pos -= from_char(*ch).len();\n+            pos -= String::from_char(1, *ch).len();\n         }\n     }\n \n@@ -2175,54 +1889,6 @@ String::from_str(\"\\u1111\\u1171\\u11b6\"));\n         assert_eq!(from_utf8(xs), None);\n     }\n \n-    #[test]\n-    fn test_str_from_utf8_owned() {\n-        let xs = Vec::from_slice(b\"hello\");\n-        assert_eq!(from_utf8_owned(xs), Ok(String::from_str(\"hello\")));\n-\n-        let xs = Vec::from_slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes());\n-        assert_eq!(from_utf8_owned(xs), Ok(String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\")));\n-\n-        let xs = Vec::from_slice(b\"hello\\xFF\");\n-        assert_eq!(from_utf8_owned(xs),\n-                   Err(Vec::from_slice(b\"hello\\xFF\")));\n-    }\n-\n-    #[test]\n-    fn test_str_from_utf8_lossy() {\n-        let xs = b\"hello\";\n-        assert_eq!(from_utf8_lossy(xs), Slice(\"hello\"));\n-\n-        let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n-        assert_eq!(from_utf8_lossy(xs), Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n-\n-        let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(String::from_str(\"Hello\\uFFFD There\\uFFFD Goodbye\")));\n-\n-        let xs = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n-        assert_eq!(from_utf8_lossy(xs),\n-                   Owned(String::from_str(\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\")));\n-\n-        let xs = b\"\\xF5foo\\xF5\\x80bar\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFDfoo\\uFFFD\\uFFFDbar\")));\n-\n-        let xs = b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\")));\n-\n-        let xs = b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\";\n-        assert_eq!(from_utf8_lossy(xs),\n-                   Owned(String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\")));\n-\n-        let xs = b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\\n-                                               foo\\U00010000bar\")));\n-\n-        // surrogates\n-        let xs = b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFD\\uFFFD\\uFFFDfoo\\\n-                                               \\uFFFD\\uFFFD\\uFFFDbar\")));\n-    }\n-\n     #[test]\n     fn test_maybe_owned_traits() {\n         let s = Slice(\"abcde\");\n@@ -2288,10 +1954,8 @@ String::from_str(\"\\u1111\\u1171\\u11b6\"));\n mod bench {\n     use test::Bencher;\n     use super::*;\n-    use vec::Vec;\n     use std::iter::{Iterator, DoubleEndedIterator};\n     use std::collections::Collection;\n-    use std::slice::Vector;\n \n     #[bench]\n     fn char_iterator(b: &mut Bencher) {\n@@ -2432,42 +2096,6 @@ mod bench {\n         });\n     }\n \n-    #[bench]\n-    fn from_utf8_lossy_100_ascii(b: &mut Bencher) {\n-        let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\\n-                  Lorem ipsum dolor sit amet, consectetur. \";\n-\n-        assert_eq!(100, s.len());\n-        b.iter(|| {\n-            let _ = from_utf8_lossy(s);\n-        });\n-    }\n-\n-    #[bench]\n-    fn from_utf8_lossy_100_multibyte(b: &mut Bencher) {\n-        let s = \"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\".as_bytes();\n-        assert_eq!(100, s.len());\n-        b.iter(|| {\n-            let _ = from_utf8_lossy(s);\n-        });\n-    }\n-\n-    #[bench]\n-    fn from_utf8_lossy_invalid(b: &mut Bencher) {\n-        let s = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n-        b.iter(|| {\n-            let _ = from_utf8_lossy(s);\n-        });\n-    }\n-\n-    #[bench]\n-    fn from_utf8_lossy_100_invalid(b: &mut Bencher) {\n-        let s = Vec::from_elem(100, 0xF5u8);\n-        b.iter(|| {\n-            let _ = from_utf8_lossy(s.as_slice());\n-        });\n-    }\n-\n     #[bench]\n     fn bench_connect(b: &mut Bencher) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";"}, {"sha": "5450f2d7c31a3778b63ca8947341e55f96f62311", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 401, "deletions": 14, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -21,7 +21,7 @@ use core::raw::Slice;\n use {Collection, Mutable};\n use hash;\n use str;\n-use str::{CharRange, StrAllocating};\n+use str::{CharRange, StrAllocating, MaybeOwned, Owned, Slice};\n use vec::Vec;\n \n /// A growable string stored as a UTF-8 encoded buffer.\n@@ -75,6 +75,14 @@ impl String {\n     ///\n     /// Returns `Err` with the original vector if the vector contains invalid\n     /// UTF-8.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let hello_vec = vec![104, 101, 108, 108, 111];\n+    /// let string = String::from_utf8(hello_vec);\n+    /// assert_eq!(string, Ok(\"hello\".to_string()));\n+    /// ```\n     #[inline]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, Vec<u8>> {\n         if str::is_utf8(vec.as_slice()) {\n@@ -84,6 +92,189 @@ impl String {\n         }\n     }\n \n+    /// Converts a vector of bytes to a new utf-8 string.\n+    /// Any invalid utf-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let input = b\"Hello \\xF0\\x90\\x80World\";\n+    /// let output = String::from_utf8_lossy(input);\n+    /// assert_eq!(output.as_slice(), \"Hello \\uFFFDWorld\");\n+    /// ```\n+    pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n+        if str::is_utf8(v) {\n+            return Slice(unsafe { mem::transmute(v) })\n+        }\n+\n+        static TAG_CONT_U8: u8 = 128u8;\n+        static REPLACEMENT: &'static [u8] = b\"\\xEF\\xBF\\xBD\"; // U+FFFD in UTF-8\n+        let mut i = 0;\n+        let total = v.len();\n+        fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n+            unsafe { *xs.unsafe_ref(i) }\n+        }\n+        fn safe_get(xs: &[u8], i: uint, total: uint) -> u8 {\n+            if i >= total {\n+                0\n+            } else {\n+                unsafe_get(xs, i)\n+            }\n+        }\n+\n+        let mut res = String::with_capacity(total);\n+\n+        if i > 0 {\n+            unsafe {\n+                res.push_bytes(v.slice_to(i))\n+            };\n+        }\n+\n+        // subseqidx is the index of the first byte of the subsequence we're looking at.\n+        // It's used to copy a bunch of contiguous good codepoints at once instead of copying\n+        // them one by one.\n+        let mut subseqidx = 0;\n+\n+        while i < total {\n+            let i_ = i;\n+            let byte = unsafe_get(v, i);\n+            i += 1;\n+\n+            macro_rules! error(() => ({\n+                unsafe {\n+                    if subseqidx != i_ {\n+                        res.push_bytes(v.slice(subseqidx, i_));\n+                    }\n+                    subseqidx = i;\n+                    res.push_bytes(REPLACEMENT);\n+                }\n+            }))\n+\n+            if byte < 128u8 {\n+                // subseqidx handles this\n+            } else {\n+                let w = str::utf8_char_width(byte);\n+\n+                match w {\n+                    2 => {\n+                        if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                            error!();\n+                            continue;\n+                        }\n+                        i += 1;\n+                    }\n+                    3 => {\n+                        match (byte, safe_get(v, i, total)) {\n+                            (0xE0        , 0xA0 .. 0xBF) => (),\n+                            (0xE1 .. 0xEC, 0x80 .. 0xBF) => (),\n+                            (0xED        , 0x80 .. 0x9F) => (),\n+                            (0xEE .. 0xEF, 0x80 .. 0xBF) => (),\n+                            _ => {\n+                                error!();\n+                                continue;\n+                            }\n+                        }\n+                        i += 1;\n+                        if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                            error!();\n+                            continue;\n+                        }\n+                        i += 1;\n+                    }\n+                    4 => {\n+                        match (byte, safe_get(v, i, total)) {\n+                            (0xF0        , 0x90 .. 0xBF) => (),\n+                            (0xF1 .. 0xF3, 0x80 .. 0xBF) => (),\n+                            (0xF4        , 0x80 .. 0x8F) => (),\n+                            _ => {\n+                                error!();\n+                                continue;\n+                            }\n+                        }\n+                        i += 1;\n+                        if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                            error!();\n+                            continue;\n+                        }\n+                        i += 1;\n+                        if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                            error!();\n+                            continue;\n+                        }\n+                        i += 1;\n+                    }\n+                    _ => {\n+                        error!();\n+                        continue;\n+                    }\n+                }\n+            }\n+        }\n+        if subseqidx < total {\n+            unsafe {\n+                res.push_bytes(v.slice(subseqidx, total))\n+            };\n+        }\n+        Owned(res.into_string())\n+    }\n+\n+    /// Decode a UTF-16 encoded vector `v` into a `String`, returning `None`\n+    /// if `v` contains any invalid data.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// // \ud834\udd1emusic\n+    /// let mut v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+    ///              0x0073, 0x0069, 0x0063];\n+    /// assert_eq!(String::from_utf16(v), Some(\"\ud834\udd1emusic\".to_string()));\n+    ///\n+    /// // \ud834\udd1emu<invalid>ic\n+    /// v[4] = 0xD800;\n+    /// assert_eq!(String::from_utf16(v), None);\n+    /// ```\n+    pub fn from_utf16(v: &[u16]) -> Option<String> {\n+        let mut s = String::with_capacity(v.len() / 2);\n+        for c in str::utf16_items(v) {\n+            match c {\n+                str::ScalarValue(c) => s.push_char(c),\n+                str::LoneSurrogate(_) => return None\n+            }\n+        }\n+        Some(s)\n+    }\n+\n+    /// Decode a UTF-16 encoded vector `v` into a string, replacing\n+    /// invalid data with the replacement character (U+FFFD).\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// // \ud834\udd1emus<invalid>ic<invalid>\n+    /// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+    ///          0x0073, 0xDD1E, 0x0069, 0x0063,\n+    ///          0xD834];\n+    ///\n+    /// assert_eq!(String::from_utf16_lossy(v),\n+    ///            \"\ud834\udd1emus\\uFFFDic\\uFFFD\".to_string());\n+    /// ```\n+    pub fn from_utf16_lossy(v: &[u16]) -> String {\n+        str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n+    }\n+\n+    /// Convert a vector of chars to a string\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let chars = ['h', 'e', 'l', 'l', 'o'];\n+    /// let string = String::from_chars(chars);\n+    /// assert_eq!(string.as_slice(), \"hello\");\n+    /// ```\n+    #[inline]\n+    pub fn from_chars(chs: &[char]) -> String {\n+        chs.iter().map(|c| *c).collect()\n+    }\n+\n     /// Return the underlying byte buffer, encoded as UTF-8.\n     #[inline]\n     pub fn into_bytes(self) -> Vec<u8> {\n@@ -115,6 +306,23 @@ impl String {\n         buf\n     }\n \n+    /// Convert a byte to a UTF-8 string\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if invalid UTF-8\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let string = String::from_byte(104);\n+    /// assert_eq!(string.as_slice(), \"h\");\n+    /// ```\n+    pub fn from_byte(b: u8) -> String {\n+        assert!(b < 128u8);\n+        String::from_char(1, b as char)\n+    }\n+\n     /// Pushes the given string onto this string buffer.\n     #[inline]\n     pub fn push_str(&mut self, string: &str) {\n@@ -366,29 +574,155 @@ mod tests {\n     use test::Bencher;\n \n     use Mutable;\n-    use str::{Str, StrSlice};\n+    use str;\n+    use str::{Str, StrSlice, Owned, Slice};\n     use super::String;\n+    use vec::Vec;\n \n     #[test]\n     fn test_from_str() {\n       let owned: Option<::std::string::String> = from_str(\"string\");\n       assert_eq!(owned.as_ref().map(|s| s.as_slice()), Some(\"string\"));\n     }\n \n-    #[bench]\n-    fn bench_with_capacity(b: &mut Bencher) {\n-        b.iter(|| {\n-            String::with_capacity(100)\n-        });\n+    #[test]\n+    fn test_from_utf8() {\n+        let xs = Vec::from_slice(b\"hello\");\n+        assert_eq!(String::from_utf8(xs), Ok(String::from_str(\"hello\")));\n+\n+        let xs = Vec::from_slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes());\n+        assert_eq!(String::from_utf8(xs), Ok(String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\")));\n+\n+        let xs = Vec::from_slice(b\"hello\\xFF\");\n+        assert_eq!(String::from_utf8(xs),\n+                   Err(Vec::from_slice(b\"hello\\xFF\")));\n     }\n \n-    #[bench]\n-    fn bench_push_str(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        b.iter(|| {\n-            let mut r = String::new();\n-            r.push_str(s);\n-        });\n+    #[test]\n+    fn test_from_utf8_lossy() {\n+        let xs = b\"hello\";\n+        assert_eq!(String::from_utf8_lossy(xs), Slice(\"hello\"));\n+\n+        let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n+        assert_eq!(String::from_utf8_lossy(xs), Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+\n+        let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n+        assert_eq!(String::from_utf8_lossy(xs),\n+                   Owned(String::from_str(\"Hello\\uFFFD There\\uFFFD Goodbye\")));\n+\n+        let xs = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n+        assert_eq!(String::from_utf8_lossy(xs),\n+                   Owned(String::from_str(\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\")));\n+\n+        let xs = b\"\\xF5foo\\xF5\\x80bar\";\n+        assert_eq!(String::from_utf8_lossy(xs),\n+                   Owned(String::from_str(\"\\uFFFDfoo\\uFFFD\\uFFFDbar\")));\n+\n+        let xs = b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\";\n+        assert_eq!(String::from_utf8_lossy(xs),\n+                   Owned(String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\")));\n+\n+        let xs = b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\";\n+        assert_eq!(String::from_utf8_lossy(xs),\n+                   Owned(String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\")));\n+\n+        let xs = b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\";\n+        assert_eq!(String::from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\\n+                                               foo\\U00010000bar\")));\n+\n+        // surrogates\n+        let xs = b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\";\n+        assert_eq!(String::from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFD\\uFFFD\\uFFFDfoo\\\n+                                               \\uFFFD\\uFFFD\\uFFFDbar\")));\n+    }\n+\n+    #[test]\n+    fn test_from_utf16() {\n+        let pairs =\n+            [(String::from_str(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\"),\n+              vec![0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n+                0xd800_u16, 0xdf3b_u16, 0xd800_u16, 0xdf46_u16,\n+                0xd800_u16, 0xdf39_u16, 0xd800_u16, 0xdf3b_u16,\n+                0xd800_u16, 0xdf30_u16, 0x000a_u16]),\n+\n+             (String::from_str(\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\"),\n+              vec![0xd801_u16, 0xdc12_u16, 0xd801_u16,\n+                0xdc49_u16, 0xd801_u16, 0xdc2e_u16, 0xd801_u16,\n+                0xdc40_u16, 0xd801_u16, 0xdc32_u16, 0xd801_u16,\n+                0xdc4b_u16, 0x0020_u16, 0xd801_u16, 0xdc0f_u16,\n+                0xd801_u16, 0xdc32_u16, 0xd801_u16, 0xdc4d_u16,\n+                0x000a_u16]),\n+\n+             (String::from_str(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\"),\n+              vec![0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n+                0xd800_u16, 0xdf0b_u16, 0xd800_u16, 0xdf04_u16,\n+                0xd800_u16, 0xdf11_u16, 0xd800_u16, 0xdf09_u16,\n+                0x00b7_u16, 0xd800_u16, 0xdf0c_u16, 0xd800_u16,\n+                0xdf04_u16, 0xd800_u16, 0xdf15_u16, 0xd800_u16,\n+                0xdf04_u16, 0xd800_u16, 0xdf0b_u16, 0xd800_u16,\n+                0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]),\n+\n+             (String::from_str(\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\"),\n+              vec![0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n+                0xd801_u16, 0xdc88_u16, 0xd801_u16, 0xdc91_u16,\n+                0xd801_u16, 0xdc9b_u16, 0xd801_u16, 0xdc92_u16,\n+                0x0020_u16, 0xd801_u16, 0xdc95_u16, 0xd801_u16,\n+                0xdc93_u16, 0x0020_u16, 0xd801_u16, 0xdc88_u16,\n+                0xd801_u16, 0xdc9a_u16, 0xd801_u16, 0xdc8d_u16,\n+                0x0020_u16, 0xd801_u16, 0xdc8f_u16, 0xd801_u16,\n+                0xdc9c_u16, 0xd801_u16, 0xdc92_u16, 0xd801_u16,\n+                0xdc96_u16, 0xd801_u16, 0xdc86_u16, 0x0020_u16,\n+                0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n+                0x000a_u16 ]),\n+             // Issue #12318, even-numbered non-BMP planes\n+             (String::from_str(\"\\U00020000\"),\n+              vec![0xD840, 0xDC00])];\n+\n+        for p in pairs.iter() {\n+            let (s, u) = (*p).clone();\n+            let s_as_utf16 = s.as_slice().utf16_units().collect::<Vec<u16>>();\n+            let u_as_string = String::from_utf16(u.as_slice()).unwrap();\n+\n+            assert!(str::is_utf16(u.as_slice()));\n+            assert_eq!(s_as_utf16, u);\n+\n+            assert_eq!(u_as_string, s);\n+            assert_eq!(String::from_utf16_lossy(u.as_slice()), s);\n+\n+            assert_eq!(String::from_utf16(s_as_utf16.as_slice()).unwrap(), s);\n+            assert_eq!(u_as_string.as_slice().utf16_units().collect::<Vec<u16>>(), u);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_utf16_invalid() {\n+        // completely positive cases tested above.\n+        // lead + eof\n+        assert_eq!(String::from_utf16([0xD800]), None);\n+        // lead + lead\n+        assert_eq!(String::from_utf16([0xD800, 0xD800]), None);\n+\n+        // isolated trail\n+        assert_eq!(String::from_utf16([0x0061, 0xDC00]), None);\n+\n+        // general\n+        assert_eq!(String::from_utf16([0xD800, 0xd801, 0xdc8b, 0xD800]), None);\n+    }\n+\n+    #[test]\n+    fn test_from_utf16_lossy() {\n+        // completely positive cases tested above.\n+        // lead + eof\n+        assert_eq!(String::from_utf16_lossy([0xD800]), String::from_str(\"\\uFFFD\"));\n+        // lead + lead\n+        assert_eq!(String::from_utf16_lossy([0xD800, 0xD800]), String::from_str(\"\\uFFFD\\uFFFD\"));\n+\n+        // isolated trail\n+        assert_eq!(String::from_utf16_lossy([0x0061, 0xDC00]), String::from_str(\"a\\uFFFD\"));\n+\n+        // general\n+        assert_eq!(String::from_utf16_lossy([0xD800, 0xd801, 0xdc8b, 0xD800]),\n+                   String::from_str(\"\\uFFFD\ud801\udc8b\\uFFFD\"));\n     }\n \n     #[test]\n@@ -492,4 +826,57 @@ mod tests {\n         assert_eq!(b.len(), 7);\n         assert_eq!(b.as_slice(), \"1234522\");\n     }\n+\n+    #[bench]\n+    fn bench_with_capacity(b: &mut Bencher) {\n+        b.iter(|| {\n+            String::with_capacity(100)\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_push_str(b: &mut Bencher) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+        b.iter(|| {\n+            let mut r = String::new();\n+            r.push_str(s);\n+        });\n+    }\n+\n+    #[bench]\n+    fn from_utf8_lossy_100_ascii(b: &mut Bencher) {\n+        let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\\n+                  Lorem ipsum dolor sit amet, consectetur. \";\n+\n+        assert_eq!(100, s.len());\n+        b.iter(|| {\n+            let _ = String::from_utf8_lossy(s);\n+        });\n+    }\n+\n+    #[bench]\n+    fn from_utf8_lossy_100_multibyte(b: &mut Bencher) {\n+        let s = \"\u00f0\u0090\u0152\u20ac\u00f0\u0090\u0152\u2013\u00f0\u0090\u0152\u2039\u00f0\u0090\u0152\u201e\u00f0\u0090\u0152\u2018\u00f0\u0090\u0152\u2030\u00e0\u00b8\u203a\u00e0\u00b8\u00a3\u00d8\u00af\u00d9\u02c6\u00d9\u201e\u00d8\u00a9\\\n+            \u00d8\u00a7\u00d9\u201e\u00d9\u0192\u00d9\u02c6\u00d9\u0160\u00d8\u00aa\u00e0\u00b8\u2014\u00e0\u00b8\u00a8\u00e0\u00b9\u201e\u00e0\u00b8\u2014\u00e0\u00b8\u00a2\u00e4\u00b8\u00ad\u00e5\u008d\u017d\u00f0\u0090\u008d\u2026\u00f0\u0090\u0152\u00bf\u00f0\u0090\u0152\u00bb\u00f0\u0090\u008d\u2020\u00f0\u0090\u0152\u00b9\u00f0\u0090\u0152\u00bb\u00f0\u0090\u0152\u00b0\".as_bytes();\n+        assert_eq!(100, s.len());\n+        b.iter(|| {\n+            let _ = String::from_utf8_lossy(s);\n+        });\n+    }\n+\n+    #[bench]\n+    fn from_utf8_lossy_invalid(b: &mut Bencher) {\n+        let s = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n+        b.iter(|| {\n+            let _ = String::from_utf8_lossy(s);\n+        });\n+    }\n+\n+    #[bench]\n+    fn from_utf8_lossy_100_invalid(b: &mut Bencher) {\n+        let s = Vec::from_elem(100, 0xF5u8);\n+        b.iter(|| {\n+            let _ = String::from_utf8_lossy(s.as_slice());\n+        });\n+    }\n }"}, {"sha": "9755d54a1320591f506118285c8d8b288a1489ef", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -575,7 +575,6 @@ struct P {a: int, b: f64}\n \n #[test]\n fn test_repr() {\n-    use std::str;\n     use std::io::stdio::println;\n     use std::char::is_alphabetic;\n     use std::mem::swap;\n@@ -584,7 +583,7 @@ fn test_repr() {\n     fn exact_test<T>(t: &T, e:&str) {\n         let mut m = io::MemWriter::new();\n         write_repr(&mut m as &mut io::Writer, t).unwrap();\n-        let s = str::from_utf8(m.unwrap().as_slice()).unwrap().to_string();\n+        let s = String::from_utf8(m.unwrap()).unwrap();\n         assert_eq!(s.as_slice(), e);\n     }\n "}, {"sha": "0f8fa2618027fa02d7d7354cd6c0faec5217dc65", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -378,7 +378,7 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n                 } else {\n                     let fp_vec = vec::raw::from_buf(fp_buf, libc::wcslen(fp_buf) as uint);\n                     let fp_trimmed = str::truncate_utf16_at_nul(fp_vec.as_slice());\n-                    let fp_str = str::from_utf16(fp_trimmed)\n+                    let fp_str = String::from_utf16(fp_trimmed)\n                             .expect(\"rust_list_dir_wfd_fp_buf returned invalid UTF-16\");\n                     paths.push(Path::new(fp_str));\n                 }"}, {"sha": "109d32f69b9678342caf8ea463325f0ad6d2b413", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -13,7 +13,6 @@ use std::cmp;\n use std::fmt;\n use std::iter;\n use std::num;\n-use std::str;\n \n /// Static data containing Unicode ranges for general categories and scripts.\n use unicode::regex::{UNICODE_CLASSES, PERLD, PERLS, PERLW};\n@@ -510,7 +509,7 @@ impl<'a> Parser<'a> {\n             };\n         self.chari = closer;\n         let greed = try!(self.get_next_greedy());\n-        let inner = str::from_chars(\n+        let inner = String::from_chars(\n             self.chars.as_slice().slice(start + 1, closer));\n \n         // Parse the min and max values from the regex.\n@@ -944,7 +943,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn slice(&self, start: uint, end: uint) -> String {\n-        str::from_chars(self.chars.as_slice().slice(start, end)).to_string()\n+        String::from_chars(self.chars.as_slice().slice(start, end))\n     }\n }\n "}, {"sha": "2a606ccd0cee33c976585c75279e1c9bdaee627e", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -10,7 +10,6 @@\n #![allow(non_snake_case_functions)]\n \n use std::rand::{Rng, task_rng};\n-use std::str;\n use stdtest::Bencher;\n \n use regex::{Regex, NoExpand};\n@@ -163,7 +162,7 @@ fn gen_text(n: uint) -> String {\n             *b = '\\n' as u8\n         }\n     }\n-    str::from_utf8(bytes.as_slice()).unwrap().to_string()\n+    String::from_utf8(bytes).unwrap()\n }\n \n throughput!(easy0_32, easy0(), 32)"}, {"sha": "6fa8a1530234e15b4f4f8392deb327be96b0c89e", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -61,7 +61,7 @@ pub fn llvm_err(sess: &Session, msg: String) -> ! {\n             sess.fatal(msg.as_slice());\n         } else {\n             let err = CString::new(cstr, true);\n-            let err = str::from_utf8_lossy(err.as_bytes());\n+            let err = String::from_utf8_lossy(err.as_bytes());\n             sess.fatal(format!(\"{}: {}\",\n                                msg.as_slice(),\n                                err.as_slice()).as_slice());\n@@ -380,8 +380,7 @@ pub mod write {\n                     sess.note(format!(\"{}\", &cmd).as_slice());\n                     let mut note = prog.error.clone();\n                     note.push_all(prog.output.as_slice());\n-                    sess.note(str::from_utf8(note.as_slice()).unwrap()\n-                                                             .as_slice());\n+                    sess.note(str::from_utf8(note.as_slice()).unwrap());\n                     sess.abort_if_errors();\n                 }\n             },\n@@ -1177,8 +1176,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n                 sess.note(format!(\"{}\", &cmd).as_slice());\n                 let mut output = prog.error.clone();\n                 output.push_all(prog.output.as_slice());\n-                sess.note(str::from_utf8(output.as_slice()).unwrap()\n-                                                           .as_slice());\n+                sess.note(str::from_utf8(output.as_slice()).unwrap());\n                 sess.abort_if_errors();\n             }\n         },"}, {"sha": "3fd402c90fdd87a7d8e116c4e38ef585191fbaa7", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -20,7 +20,6 @@ use metadata;\n use std::any::AnyRefExt;\n use std::io;\n use std::os;\n-use std::str;\n use std::task::TaskBuilder;\n \n use syntax::ast;\n@@ -82,8 +81,7 @@ fn run_compiler(args: &[String]) {\n             let ifile = matches.free.get(0).as_slice();\n             if ifile == \"-\" {\n                 let contents = io::stdin().read_to_end().unwrap();\n-                let src = str::from_utf8(contents.as_slice()).unwrap()\n-                                                             .to_string();\n+                let src = String::from_utf8(contents).unwrap();\n                 (StrInput(src), None)\n             } else {\n                 (FileInput(Path::new(ifile)), Some(Path::new(ifile)))"}, {"sha": "87333499ec3a2f2a10b1a2ce32abd8b770a5b4cd", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -35,7 +35,6 @@ use std::hash::Hash;\n use std::hash;\n use std::io::MemWriter;\n use std::mem;\n-use std::str;\n use std::collections::HashMap;\n use syntax::abi;\n use syntax::ast::*;\n@@ -619,7 +618,7 @@ fn encode_visibility(ebml_w: &mut Encoder, visibility: Visibility) {\n         Public => 'y',\n         Inherited => 'i',\n     };\n-    ebml_w.wr_str(str::from_char(ch).as_slice());\n+    ebml_w.wr_str(ch.to_string().as_slice());\n     ebml_w.end_tag();\n }\n \n@@ -1922,5 +1921,5 @@ pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> String {\n         tcx: tcx,\n         abbrevs: &RefCell::new(HashMap::new())\n     }, t);\n-    str::from_utf8_owned(Vec::from_slice(wr.get_ref())).unwrap().to_string()\n+    String::from_utf8(wr.unwrap()).unwrap()\n }"}, {"sha": "ecdc736790dbeb1a4f7a25ea9088a35b2fd28502", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -13,7 +13,6 @@\n //! This module uses libsyntax's lexer to provide token-based highlighting for\n //! the HTML documentation generated by rustdoc.\n \n-use std::str;\n use std::io;\n \n use syntax::parse;\n@@ -37,7 +36,7 @@ pub fn highlight(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n          class,\n          id,\n          &mut out).unwrap();\n-    str::from_utf8_lossy(out.unwrap().as_slice()).to_string()\n+    String::from_utf8_lossy(out.unwrap().as_slice()).into_string()\n }\n \n /// Exhausts the `lexer` writing the output into `out`."}, {"sha": "244fada5b9adad07787661991342c9ff2d337020", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -460,7 +460,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n \n     try!(write!(&mut w, \"]}};\"));\n \n-    Ok(str::from_utf8(w.unwrap().as_slice()).unwrap().to_string())\n+    Ok(String::from_utf8(w.unwrap()).unwrap())\n }\n \n fn write_shared(cx: &Context,\n@@ -723,9 +723,9 @@ impl<'a> SourceCollector<'a> {\n \n         // Remove the utf-8 BOM if any\n         let contents = if contents.starts_with(\"\\ufeff\") {\n-            contents.as_slice().slice_from(3)\n+            contents.slice_from(3)\n         } else {\n-            contents.as_slice()\n+            contents\n         };\n \n         // Create the intermediate directories"}, {"sha": "2cbac090835edf95b730f2e353cbfc4d3008196c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -29,7 +29,6 @@ extern crate time;\n \n use std::io;\n use std::io::{File, MemWriter};\n-use std::str;\n use std::gc::Gc;\n use serialize::{json, Decodable, Encodable};\n use externalfiles::ExternalHtml;\n@@ -429,7 +428,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n             let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n             krate.encode(&mut encoder).unwrap();\n         }\n-        str::from_utf8_owned(w.unwrap()).unwrap()\n+        String::from_utf8(w.unwrap()).unwrap()\n     };\n     let crate_json = match json::from_str(crate_json_str.as_slice()) {\n         Ok(j) => j,"}, {"sha": "80a8a06edda6b36cfc0fa9a3c83b3e5b59e1429c", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -146,7 +146,7 @@ impl<'a> ToBase64 for &'a [u8] {\n         }\n \n         unsafe {\n-            str::raw::from_utf8(v.as_slice()).to_string()\n+            str::raw::from_utf8_owned(v)\n         }\n     }\n }"}, {"sha": "3083c06c8773f5d1bd9a075eb51325bee168a490", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -45,7 +45,7 @@ impl<'a> ToHex for &'a [u8] {\n         }\n \n         unsafe {\n-            str::raw::from_utf8(v.as_slice()).to_string()\n+            str::raw::from_utf8_owned(v)\n         }\n     }\n }"}, {"sha": "f7301abef51f23b485b8c79f279df477edf8bc8b", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -240,7 +240,7 @@ pub fn decode<T: ::Decodable<Decoder, DecoderError>>(s: &str) -> DecodeResult<T>\n /// Shortcut function to encode a `T` into a JSON `String`\n pub fn encode<'a, T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> String {\n     let buff = Encoder::buffer_encode(object);\n-    str::from_utf8_owned(buff).unwrap()\n+    String::from_utf8(buff).unwrap()\n }\n \n impl fmt::Show for ErrorCode {\n@@ -517,8 +517,7 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n             let mut check_encoder = Encoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let out = str::from_utf8_owned(buf.unwrap()).unwrap();\n-        let out = out.as_slice();\n+        let out = str::from_utf8(buf.get_ref()).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n@@ -762,8 +761,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n             let mut check_encoder = PrettyEncoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let out = str::from_utf8_owned(buf.unwrap()).unwrap();\n-        let out = out.as_slice();\n+        let out = str::from_utf8(buf.get_ref()).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n@@ -810,7 +808,7 @@ impl Json {\n     pub fn to_pretty_str(&self) -> String {\n         let mut s = MemWriter::new();\n         self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n-        str::from_utf8_owned(s.unwrap()).unwrap()\n+        String::from_utf8(s.unwrap()).unwrap()\n     }\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n@@ -1728,14 +1726,14 @@ impl<T: Iterator<char>> Builder<T> {\n /// Decodes a json value from an `&mut io::Reader`\n pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, BuilderError> {\n     let contents = match rdr.read_to_end() {\n-        Ok(c) => c,\n+        Ok(c)  => c,\n         Err(e) => return Err(io_error_to_error(e))\n     };\n-    let s = match str::from_utf8_owned(contents) {\n-        Ok(s) => s,\n-        _ => return Err(SyntaxError(NotUtf8, 0, 0))\n+    let s = match str::from_utf8(contents.as_slice()) {\n+        Some(s) => s,\n+        _       => return Err(SyntaxError(NotUtf8, 0, 0))\n     };\n-    let mut builder = Builder::new(s.as_slice().chars());\n+    let mut builder = Builder::new(s.chars());\n     builder.build()\n }\n "}, {"sha": "b9c86e2b23586b49b22ad845e677b90ba79002ea", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -19,7 +19,6 @@ use mem;\n use option::{Option, Some, None};\n use slice::{ImmutableVector, MutableVector, Vector};\n use str::{OwnedStr, Str, StrAllocating, StrSlice};\n-use str;\n use string::String;\n use to_str::{IntoStr};\n use vec::Vec;\n@@ -438,7 +437,7 @@ unsafe fn str_map_bytes(string: String, map: &'static [u8]) -> String {\n         *b = map[*b as uint];\n     }\n \n-    String::from_str(str::from_utf8(bytes.as_slice()).unwrap())\n+    String::from_utf8(bytes).unwrap()\n }\n \n #[inline]\n@@ -525,7 +524,6 @@ static ASCII_UPPER_MAP: &'static [u8] = &[\n mod tests {\n     use prelude::*;\n     use super::*;\n-    use str::from_char;\n     use char::from_u32;\n     use vec::Vec;\n     use str::StrSlice;\n@@ -677,8 +675,8 @@ mod tests {\n         while i <= 500 {\n             let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n                         else { i };\n-            assert_eq!(from_char(from_u32(i).unwrap()).as_slice().to_ascii_upper(),\n-                       from_char(from_u32(upper).unwrap()).to_string())\n+            assert_eq!((from_u32(i).unwrap()).to_string().as_slice().to_ascii_upper(),\n+                       (from_u32(upper).unwrap()).to_string())\n             i += 1;\n         }\n     }\n@@ -693,8 +691,8 @@ mod tests {\n         while i <= 500 {\n             let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n                         else { i };\n-            assert_eq!(from_char(from_u32(i).unwrap()).as_slice().to_ascii_lower(),\n-                       from_char(from_u32(lower).unwrap()).to_string())\n+            assert_eq!((from_u32(i).unwrap()).to_string().as_slice().to_ascii_lower(),\n+                       (from_u32(lower).unwrap()).to_string())\n             i += 1;\n         }\n     }\n@@ -709,8 +707,8 @@ mod tests {\n         while i <= 500 {\n             let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n                         else { i };\n-            assert_eq!(from_char(from_u32(i).unwrap()).to_string().into_ascii_upper(),\n-                       from_char(from_u32(upper).unwrap()).to_string())\n+            assert_eq!((from_u32(i).unwrap()).to_string().into_ascii_upper(),\n+                       (from_u32(upper).unwrap()).to_string())\n             i += 1;\n         }\n     }\n@@ -726,8 +724,8 @@ mod tests {\n         while i <= 500 {\n             let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n                         else { i };\n-            assert_eq!(from_char(from_u32(i).unwrap()).to_string().into_ascii_lower(),\n-                       from_char(from_u32(lower).unwrap()).to_string())\n+            assert_eq!((from_u32(i).unwrap()).to_string().into_ascii_lower(),\n+                       (from_u32(lower).unwrap()).to_string())\n             i += 1;\n         }\n     }\n@@ -747,11 +745,8 @@ mod tests {\n             let c = i;\n             let lower = if 'A' as u32 <= c && c <= 'Z' as u32 { c + 'a' as u32 - 'A' as u32 }\n                         else { c };\n-            assert!(from_char(from_u32(i).unwrap()).as_slice()\n-                                                   .eq_ignore_ascii_case(\n-                                                       from_char(\n-                                                           from_u32(lower)\n-                                                            .unwrap()).as_slice()));\n+            assert!((from_u32(i).unwrap()).to_string().as_slice().eq_ignore_ascii_case(\n+                    (from_u32(lower).unwrap()).to_string().as_slice()));\n             i += 1;\n         }\n     }"}, {"sha": "b9c6220c0e2de8751a63880c332264a4e3a75981", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -417,10 +417,7 @@ the `}` character is escaped with `}}`.\n use io::Writer;\n use io;\n use result::{Ok, Err};\n-use str::{Str, StrAllocating};\n-use str;\n use string;\n-use slice::Vector;\n \n pub use core::fmt::{Formatter, Result, FormatWriter, rt};\n pub use core::fmt::{Show, Bool, Char, Signed, Unsigned, Octal, Binary};\n@@ -464,7 +461,7 @@ pub use core::fmt::{secret_pointer};\n pub fn format(args: &Arguments) -> string::String{\n     let mut output = io::MemWriter::new();\n     let _ = write!(&mut output, \"{}\", args);\n-    str::from_utf8(output.unwrap().as_slice()).unwrap().into_string()\n+    string::String::from_utf8(output.unwrap()).unwrap()\n }\n \n impl<'a> Writer for Formatter<'a> {"}, {"sha": "d49c56b4704402dfa77ea958a77a3e6aabe993ed", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -999,9 +999,9 @@ mod test {\n             let mut read_buf = [0, .. 1028];\n             let read_str = match check!(read_stream.read(read_buf)) {\n                 -1|0 => fail!(\"shouldn't happen\"),\n-                n => str::from_utf8(read_buf.slice_to(n)).unwrap().to_owned()\n+                n => str::from_utf8(read_buf.slice_to(n)).unwrap().to_string()\n             };\n-            assert_eq!(read_str, message.to_owned());\n+            assert_eq!(read_str.as_slice(), message);\n         }\n         check!(unlink(filename));\n     })"}, {"sha": "0df2bb0f57c5a253f830859183357292b2a1c1ca", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -705,9 +705,9 @@ pub trait Reader {\n     /// UTF-8 bytes.\n     fn read_to_string(&mut self) -> IoResult<String> {\n         self.read_to_end().and_then(|s| {\n-            match str::from_utf8(s.as_slice()) {\n-                Some(s) => Ok(String::from_str(s)),\n-                None => Err(standard_error(InvalidInput)),\n+            match String::from_utf8(s) {\n+                Ok(s)  => Ok(s),\n+                Err(_) => Err(standard_error(InvalidInput)),\n             }\n         })\n     }\n@@ -1440,9 +1440,9 @@ pub trait Buffer: Reader {\n     /// valid UTF-8 sequence of bytes.\n     fn read_line(&mut self) -> IoResult<String> {\n         self.read_until('\\n' as u8).and_then(|line|\n-            match str::from_utf8(line.as_slice()) {\n-                Some(s) => Ok(String::from_str(s)),\n-                None => Err(standard_error(InvalidInput)),\n+            match String::from_utf8(line) {\n+                Ok(s)  => Ok(s),\n+                Err(_) => Err(standard_error(InvalidInput)),\n             }\n         )\n     }"}, {"sha": "1eee69834948fb24db130a6550d8f9acdef6d6a1", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -14,7 +14,6 @@\n \n use prelude::*;\n \n-use str;\n use fmt;\n use os;\n use io::{IoResult, IoError};\n@@ -313,16 +312,15 @@ impl Command {\n     ///\n     /// ```\n     /// use std::io::Command;\n-    /// use std::str;\n     ///\n     /// let output = match Command::new(\"cat\").arg(\"foot.txt\").output() {\n     ///     Ok(output) => output,\n     ///     Err(e) => fail!(\"failed to execute process: {}\", e),\n     /// };\n     ///\n     /// println!(\"status: {}\", output.status);\n-    /// println!(\"stdout: {}\", str::from_utf8_lossy(output.output.as_slice()));\n-    /// println!(\"stderr: {}\", str::from_utf8_lossy(output.error.as_slice()));\n+    /// println!(\"stdout: {}\", String::from_utf8_lossy(output.output.as_slice()));\n+    /// println!(\"stderr: {}\", String::from_utf8_lossy(output.error.as_slice()));\n     /// ```\n     pub fn output(&self) -> IoResult<ProcessOutput> {\n         self.spawn().and_then(|p| p.wait_with_output())\n@@ -353,9 +351,9 @@ impl fmt::Show for Command {\n     /// non-utf8 data is lossily converted using the utf8 replacement\n     /// character.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{}\", str::from_utf8_lossy(self.program.as_bytes_no_nul())));\n+        try!(write!(f, \"{}\", String::from_utf8_lossy(self.program.as_bytes_no_nul())));\n         for arg in self.args.iter() {\n-            try!(write!(f, \" '{}'\", str::from_utf8_lossy(arg.as_bytes_no_nul())));\n+            try!(write!(f, \" '{}'\", String::from_utf8_lossy(arg.as_bytes_no_nul())));\n         }\n         Ok(())\n     }\n@@ -813,8 +811,7 @@ mod tests {\n         use os;\n         let prog = pwd_cmd().spawn().unwrap();\n \n-        let output = str::from_utf8(prog.wait_with_output().unwrap()\n-                                        .output.as_slice()).unwrap().to_string();\n+        let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n         let parent_dir = os::getcwd();\n         let child_dir = Path::new(output.as_slice().trim());\n \n@@ -832,8 +829,7 @@ mod tests {\n         let parent_dir = os::getcwd().dir_path();\n         let prog = pwd_cmd().cwd(&parent_dir).spawn().unwrap();\n \n-        let output = str::from_utf8(prog.wait_with_output().unwrap()\n-                                        .output.as_slice()).unwrap().to_string();\n+        let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n         let child_dir = Path::new(output.as_slice().trim().into_string());\n \n         let parent_stat = parent_dir.stat().unwrap();\n@@ -867,8 +863,7 @@ mod tests {\n         if running_on_valgrind() { return; }\n \n         let prog = env_cmd().spawn().unwrap();\n-        let output = str::from_utf8(prog.wait_with_output().unwrap()\n-                                        .output.as_slice()).unwrap().to_string();\n+        let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -884,9 +879,7 @@ mod tests {\n         if running_on_valgrind() { return; }\n \n         let mut prog = env_cmd().spawn().unwrap();\n-        let output = str::from_utf8(prog.wait_with_output()\n-                                        .unwrap().output.as_slice())\n-                                   .unwrap().to_string();\n+        let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -908,7 +901,7 @@ mod tests {\n         let new_env = vec![(\"RUN_TEST_NEW_ENV\", \"123\")];\n         let prog = env_cmd().env_set_all(new_env.as_slice()).spawn().unwrap();\n         let result = prog.wait_with_output().unwrap();\n-        let output = str::from_utf8_lossy(result.output.as_slice()).into_string();\n+        let output = String::from_utf8_lossy(result.output.as_slice()).into_string();\n \n         assert!(output.as_slice().contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);"}, {"sha": "96d3b3e3e6a5390fed602624e6ccbe32ce2aad12", "filename": "src/libstd/os.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -137,7 +137,7 @@ pub fn getcwd() -> Path {\n             fail!();\n         }\n     }\n-    Path::new(str::from_utf16(str::truncate_utf16_at_nul(buf))\n+    Path::new(String::from_utf16(str::truncate_utf16_at_nul(buf))\n               .expect(\"GetCurrentDirectoryW returned invalid UTF-16\"))\n }\n \n@@ -151,7 +151,6 @@ pub mod win32 {\n     use slice::{MutableVector, ImmutableVector};\n     use string::String;\n     use str::StrSlice;\n-    use str;\n     use vec::Vec;\n \n     pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD)\n@@ -180,7 +179,7 @@ pub mod win32 {\n                     // We want to explicitly catch the case when the\n                     // closure returned invalid UTF-16, rather than\n                     // set `res` to None and continue.\n-                    let s = str::from_utf16(sub)\n+                    let s = String::from_utf16(sub)\n                         .expect(\"fill_utf16_buf_and_decode: closure created invalid UTF-16\");\n                     res = option::Some(s)\n                 }\n@@ -208,7 +207,7 @@ fn with_env_lock<T>(f: || -> T) -> T {\n /// Returns a vector of (variable, value) pairs, for all the environment\n /// variables of the current process.\n ///\n-/// Invalid UTF-8 bytes are replaced with \\uFFFD. See `str::from_utf8_lossy()`\n+/// Invalid UTF-8 bytes are replaced with \\uFFFD. See `String::from_utf8_lossy()`\n /// for details.\n ///\n /// # Example\n@@ -223,8 +222,8 @@ fn with_env_lock<T>(f: || -> T) -> T {\n /// ```\n pub fn env() -> Vec<(String,String)> {\n     env_as_bytes().move_iter().map(|(k,v)| {\n-        let k = String::from_str(str::from_utf8_lossy(k.as_slice()).as_slice());\n-        let v = String::from_str(str::from_utf8_lossy(v.as_slice()).as_slice());\n+        let k = String::from_utf8_lossy(k.as_slice()).into_string();\n+        let v = String::from_utf8_lossy(v.as_slice()).into_string();\n         (k,v)\n     }).collect()\n }\n@@ -266,7 +265,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n                 let p = &*ch.offset(i);\n                 let len = ptr::position(p, |c| *c == 0);\n                 raw::buf_as_slice(p, len, |s| {\n-                    result.push(str::from_utf16_lossy(s).into_bytes());\n+                    result.push(String::from_utf16_lossy(s).into_bytes());\n                 });\n                 i += len as int + 1;\n             }\n@@ -316,7 +315,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n /// None if the variable isn't set.\n ///\n /// Any invalid UTF-8 bytes in the value are replaced by \\uFFFD. See\n-/// `str::from_utf8_lossy()` for details.\n+/// `String::from_utf8_lossy()` for details.\n ///\n /// # Failure\n ///\n@@ -334,7 +333,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n /// }\n /// ```\n pub fn getenv(n: &str) -> Option<String> {\n-    getenv_as_bytes(n).map(|v| String::from_str(str::from_utf8_lossy(v.as_slice()).as_slice()))\n+    getenv_as_bytes(n).map(|v| String::from_utf8_lossy(v.as_slice()).into_string())\n }\n \n #[cfg(unix)]\n@@ -1050,7 +1049,7 @@ pub fn error_string(errnum: uint) -> String {\n                 return format!(\"OS Error {} (FormatMessageW() returned error {})\", errnum, fm_err);\n             }\n \n-            let msg = str::from_utf16(str::truncate_utf16_at_nul(buf));\n+            let msg = String::from_utf16(str::truncate_utf16_at_nul(buf));\n             match msg {\n                 Some(msg) => format!(\"OS Error {}: {}\", errnum, msg),\n                 None => format!(\"OS Error {} (FormatMessageW() returned invalid UTF-16)\", errnum),\n@@ -1186,7 +1185,7 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n fn real_args() -> Vec<String> {\n     real_args_as_bytes().move_iter()\n                         .map(|v| {\n-                            str::from_utf8_lossy(v.as_slice()).into_string()\n+                            String::from_utf8_lossy(v.as_slice()).into_string()\n                         }).collect()\n }\n \n@@ -1207,7 +1206,7 @@ fn real_args() -> Vec<String> {\n \n         // Push it onto the list.\n         let opt_s = slice::raw::buf_as_slice(ptr as *const _, len, |buf| {\n-            str::from_utf16(str::truncate_utf16_at_nul(buf))\n+            String::from_utf16(str::truncate_utf16_at_nul(buf))\n         });\n         opt_s.expect(\"CommandLineToArgvW returned invalid UTF-16\")\n     });\n@@ -1244,7 +1243,7 @@ extern \"system\" {\n /// via the command line).\n ///\n /// The arguments are interpreted as utf-8, with invalid bytes replaced with \\uFFFD.\n-/// See `str::from_utf8_lossy` for details.\n+/// See `String::from_utf8_lossy` for details.\n /// # Example\n ///\n /// ```rust"}, {"sha": "ececfab5f743301a4e241b1cf85da2b3ab9e1161", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -72,7 +72,7 @@ use fmt;\n use iter::Iterator;\n use option::{Option, None, Some};\n use str;\n-use str::{MaybeOwned, Str, StrSlice, from_utf8_lossy};\n+use str::{MaybeOwned, Str, StrSlice};\n use string::String;\n use slice::Vector;\n use slice::{ImmutableEqVector, ImmutableVector};\n@@ -483,7 +483,7 @@ impl<'a, P: GenericPath> Display<'a, P> {\n     /// unicode replacement char. This involves allocation.\n     #[inline]\n     pub fn as_maybe_owned(&self) -> MaybeOwned<'a> {\n-        from_utf8_lossy(if self.filename {\n+        String::from_utf8_lossy(if self.filename {\n             match self.path.filename() {\n                 None => &[],\n                 Some(v) => v"}, {"sha": "d01a1b5b1313ccba4d99abb6a816cec6d6194b68", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -992,12 +992,11 @@ mod imp {\n mod test {\n     use prelude::*;\n     use io::MemWriter;\n-    use str;\n \n     macro_rules! t( ($a:expr, $b:expr) => ({\n         let mut m = MemWriter::new();\n         super::demangle(&mut m, $a).unwrap();\n-        assert_eq!(str::from_utf8(m.unwrap().as_slice()).unwrap().to_owned(), $b.to_owned());\n+        assert_eq!(String::from_utf8(m.unwrap()).unwrap(), $b.to_string());\n     }) )\n \n     #[test]"}, {"sha": "703adcbd335521723e94eb5fd20202a86014b2ec", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -22,7 +22,6 @@ use print::pprust;\n use std::gc::Gc;\n use std::io::File;\n use std::rc::Rc;\n-use std::str;\n \n // These macros all relate to the file system; they either return\n // the column/row/filename of the expression, or they include\n@@ -122,17 +121,17 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n         Ok(bytes) => bytes,\n     };\n-    match str::from_utf8(bytes.as_slice()) {\n-        Some(src) => {\n+    match String::from_utf8(bytes) {\n+        Ok(src) => {\n             // Add this input file to the code map to make it available as\n             // dependency information\n             let filename = file.display().to_string();\n-            let interned = token::intern_and_get_ident(src);\n-            cx.codemap().new_filemap(filename, src.to_string());\n+            let interned = token::intern_and_get_ident(src.as_slice());\n+            cx.codemap().new_filemap(filename, src);\n \n             base::MacExpr::new(cx.expr_str(sp, interned))\n         }\n-        None => {\n+        Err(_) => {\n             cx.span_err(sp,\n                         format!(\"{} wasn't a utf-8 file\",\n                                 file.display()).as_slice());"}, {"sha": "c53638ed07d13fc5a9124cc173beb70a957aa4bb", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -339,7 +339,7 @@ pub fn gather_comments_and_literals(span_diagnostic: &diagnostic::SpanHandler,\n                                     srdr: &mut io::Reader)\n                                  -> (Vec<Comment>, Vec<Literal>) {\n     let src = srdr.read_to_end().unwrap();\n-    let src = str::from_utf8(src.as_slice()).unwrap().to_string();\n+    let src = String::from_utf8(src).unwrap();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let mut rdr = lexer::StringReader::new_raw(span_diagnostic, filemap);"}, {"sha": "d524622f8ecf59ad9a36eb22badd0ff88f4dd504", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -30,7 +30,6 @@ use std::gc::Gc;\n use std::io::{IoResult, MemWriter};\n use std::io;\n use std::mem;\n-use std::str;\n \n pub enum AnnNode<'a> {\n     NodeBlock(&'a ast::Block),\n@@ -138,7 +137,7 @@ pub fn to_string(f: |&mut State| -> IoResult<()>) -> String {\n         // downcasts.\n         let (_, wr): (uint, Box<MemWriter>) = mem::transmute_copy(&s.s.out);\n         let result =\n-            str::from_utf8_owned(Vec::from_slice(wr.get_ref())).unwrap();\n+            String::from_utf8(Vec::from_slice(wr.get_ref())).unwrap();\n         mem::forget(wr);\n         result.to_string()\n     }"}, {"sha": "94ed7fbbf306e02a71b54eb7a24de294eb7b669c", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -14,7 +14,6 @@\n \n use std::collections::HashMap;\n use std::io;\n-use std::str;\n use super::super::TermInfo;\n \n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n@@ -214,9 +213,9 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n \n     // don't read NUL\n     let bytes = try!(file.read_exact(names_bytes as uint - 1));\n-    let names_str = match str::from_utf8(bytes.as_slice()) {\n-        Some(s) => s.to_string(),\n-        None => return Err(\"input not utf-8\".to_string()),\n+    let names_str = match String::from_utf8(bytes) {\n+        Ok(s)  => s,\n+        Err(_) => return Err(\"input not utf-8\".to_string()),\n     };\n \n     let term_names: Vec<String> = names_str.as_slice()"}, {"sha": "7ad14d797549391cf69e8b554829a08a6c1fa8e5", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -14,7 +14,7 @@\n \n use std::io::File;\n use std::os::getenv;\n-use std::{os, str};\n+use std::os;\n \n /// Return path to database entry for `term`\n pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n@@ -59,7 +59,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n     // Look for the terminal in all of the search directories\n     for p in dirs_to_search.iter() {\n         if p.exists() {\n-            let f = str::from_char(first_char);\n+            let f = first_char.to_string();\n             let newp = p.join_many([f.as_slice(), term]);\n             if newp.exists() {\n                 return Some(box newp);"}, {"sha": "a857bc7535d9c3250061f2f376dede132923c088", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -60,7 +60,6 @@ use std::io::stdio::StdWriter;\n use std::io::{File, ChanReader, ChanWriter};\n use std::io;\n use std::os;\n-use std::str;\n use std::string::String;\n use std::task::TaskBuilder;\n \n@@ -636,7 +635,7 @@ impl<T: Writer> ConsoleTestState<T> {\n             if stdout.len() > 0 {\n                 fail_out.push_str(format!(\"---- {} stdout ----\\n\\t\",\n                                           f.name.as_slice()).as_slice());\n-                let output = str::from_utf8_lossy(stdout.as_slice());\n+                let output = String::from_utf8_lossy(stdout.as_slice());\n                 fail_out.push_str(output.as_slice()\n                                         .replace(\"\\n\", \"\\n\\t\")\n                                         .as_slice());\n@@ -873,7 +872,7 @@ fn should_sort_failures_before_printing_them() {\n \n     st.write_failures().unwrap();\n     let s = match st.out {\n-        Raw(ref m) => str::from_utf8_lossy(m.get_ref()),\n+        Raw(ref m) => String::from_utf8_lossy(m.get_ref()),\n         Pretty(_) => unreachable!()\n     };\n "}, {"sha": "51696521165325596e99ad4df8464255dc3699ba", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -457,7 +457,6 @@ mod tests {\n     use stats::write_5_number_summary;\n     use stats::write_boxplot;\n     use std::io;\n-    use std::str;\n     use std::f64;\n \n     macro_rules! assert_approx_eq(\n@@ -1030,7 +1029,7 @@ mod tests {\n             use std::io::MemWriter;\n             let mut m = MemWriter::new();\n             write_boxplot(&mut m as &mut io::Writer, s, 30).unwrap();\n-            let out = str::from_utf8(m.unwrap().as_slice()).unwrap().to_string();\n+            let out = String::from_utf8(m.unwrap()).unwrap();\n             assert_eq!(out, expected);\n         }\n "}, {"sha": "41ba448754d08fd2efc491fcb41e2dcb1902472c", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -31,7 +31,6 @@ extern crate libc;\n use std::io::BufReader;\n use std::num;\n use std::string::String;\n-use std::str;\n \n static NSEC_PER_SEC: i32 = 1_000_000_000_i32;\n \n@@ -486,9 +485,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n         if c == range.ch {\n             Ok(range.next)\n         } else {\n-            Err(format!(\"Expected {}, found {}\",\n-                str::from_char(c),\n-                str::from_char(range.ch)))\n+            Err(format!(\"Expected {}, found {}\", c, range.ch))\n         }\n     }\n \n@@ -789,7 +786,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n           }\n           '%' => parse_char(s, pos, '%'),\n           ch => {\n-            Err(format!(\"unknown formatting type: {}\", str::from_char(ch)))\n+            Err(format!(\"unknown formatting type: {}\", ch))\n           }\n         }\n     }\n@@ -1086,7 +1083,7 @@ pub fn strftime(format: &str, tm: &Tm) -> String {\n         }\n     }\n \n-    str::from_utf8(buf.as_slice()).unwrap().to_string()\n+    String::from_utf8(buf).unwrap()\n }\n \n #[cfg(test)]"}, {"sha": "233743175b503f748a19c41251febe8dcf2e1474", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -81,7 +81,6 @@ use std::num::FromStrRadix;\n use std::rand;\n use std::rand::Rng;\n use std::slice;\n-use std::str;\n \n use serialize::{Encoder, Encodable, Decoder, Decodable};\n \n@@ -327,7 +326,7 @@ impl Uuid {\n             *s.get_mut(i*2+0) = digit.as_bytes()[0];\n             *s.get_mut(i*2+1) = digit.as_bytes()[1];\n         }\n-        str::from_utf8(s.as_slice()).unwrap().to_string()\n+        String::from_utf8(s).unwrap()\n     }\n \n     /// Returns a string of hexadecimal digits, separated into groups with a hyphen.\n@@ -685,7 +684,7 @@ mod test {\n         let hs = uuid1.to_hyphenated_str();\n         let ss = uuid1.to_string();\n \n-        let hsn = str::from_chars(hs.as_slice()\n+        let hsn = String::from_chars(hs.as_slice()\n                                     .chars()\n                                     .filter(|&c| c != '-')\n                                     .collect::<Vec<char>>()"}, {"sha": "fffe146f7f4d4019a96f62fc0a15d9c584230a1d", "filename": "src/test/run-fail/glob-use-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Ftest%2Frun-fail%2Fglob-use-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Ftest%2Frun-fail%2Fglob-use-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fglob-use-std.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -16,7 +16,7 @@\n use std::*;\n \n fn main() {\n-    str::from_byte('a' as u8); // avoid an unused import message\n+    String::from_byte(b'a'); // avoid an unused import message\n \n     fail!(\"fail works\")\n }"}, {"sha": "c436958171d3be1081befc91f90935a7c20ed077", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{char, os, str};\n+use std::{char, os};\n use std::io::{File, Command};\n use std::rand::{task_rng, Rng};\n \n@@ -61,7 +61,7 @@ fn main() {\n                                           main_file.as_str()\n                                                    .unwrap()).as_slice())\n                              .output().unwrap();\n-        let err = str::from_utf8_lossy(result.error.as_slice());\n+        let err = String::from_utf8_lossy(result.error.as_slice());\n \n         // positive test so that this test will be updated when the\n         // compiler changes."}, {"sha": "913f1318ebf846e0d5226ab1f7267b1802f4df98", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{char, os, str};\n+use std::{char, os};\n use std::io::{File, Command};\n use std::rand::{task_rng, Rng};\n \n@@ -57,7 +57,7 @@ fn main() {\n                                                    .unwrap()).as_slice())\n                              .output().unwrap();\n \n-        let err = str::from_utf8_lossy(result.error.as_slice());\n+        let err = String::from_utf8_lossy(result.error.as_slice());\n \n         // the span should end the line (e.g no extra ~'s)\n         let expected_span = format!(\"^{}\\n\", \"~\".repeat(n - 1));"}, {"sha": "e0cd91adb1c595724bdd945be55d390032824141", "filename": "src/test/run-pass/issue-11881.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11881.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -14,7 +14,6 @@ use serialize::{Encodable, Encoder};\n use serialize::json;\n use serialize::ebml::writer;\n use std::io::MemWriter;\n-use std::str::from_utf8_owned;\n \n #[deriving(Encodable)]\n struct Foo {"}, {"sha": "84f303de7057b43ffc1efff1e7a9cefb07206b9f", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -20,7 +20,6 @@\n // Extern mod controls linkage. Use controls the visibility of names to modules that are\n // already linked in. Using WriterUtil allows us to use the write_line method.\n \n-use std::str;\n use std::slice;\n use std::fmt;\n \n@@ -100,9 +99,7 @@ impl fmt::Show for AsciiArt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Convert each line into a string.\n         let lines = self.lines.iter()\n-                              .map(|line| {\n-                                  str::from_chars(line.as_slice()).to_string()\n-                              })\n+                              .map(|line| String::from_chars(line.as_slice()))\n                               .collect::<Vec<String>>();\n \n         // Concatenate the lines together using a new-line."}, {"sha": "7f2f9f9ece83de1ffc9398d49b99b99db0be3ea2", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -12,7 +12,6 @@\n \n use std::io::process::Command;\n use std::os;\n-use std::str;\n \n // lifted from the test module\n // Inlining to avoid llvm turning the recursive functions into tail calls,\n@@ -42,12 +41,12 @@ fn main() {\n     } else {\n         let silent = Command::new(args[0].as_slice()).arg(\"silent\").output().unwrap();\n         assert!(!silent.status.success());\n-        let error = str::from_utf8_lossy(silent.error.as_slice());\n+        let error = String::from_utf8_lossy(silent.error.as_slice());\n         assert!(error.as_slice().contains(\"has overflowed its stack\"));\n \n         let loud = Command::new(args[0].as_slice()).arg(\"loud\").output().unwrap();\n         assert!(!loud.status.success());\n-        let error = str::from_utf8_lossy(silent.error.as_slice());\n+        let error = String::from_utf8_lossy(silent.error.as_slice());\n         assert!(error.as_slice().contains(\"has overflowed its stack\"));\n     }\n }"}, {"sha": "d26a17d19f80783b89d4348604e367554e687a86", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b422373d862082b1a27bd7d0e2319a31ad745aae/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=b422373d862082b1a27bd7d0e2319a31ad745aae", "patch": "@@ -13,13 +13,13 @@ use std::str;\n pub fn main() {\n     // Chars of 1, 2, 3, and 4 bytes\n     let chs: Vec<char> = vec!('e', '\u00e9', '\u20ac', '\\U00010000');\n-    let s: String = str::from_chars(chs.as_slice()).to_string();\n+    let s: String = String::from_chars(chs.as_slice()).to_string();\n     let schs: Vec<char> = s.as_slice().chars().collect();\n \n     assert!(s.len() == 10u);\n     assert!(s.as_slice().char_len() == 4u);\n     assert!(schs.len() == 4u);\n-    assert!(str::from_chars(schs.as_slice()).to_string() == s);\n+    assert!(String::from_chars(schs.as_slice()) == s);\n     assert!(s.as_slice().char_at(0u) == 'e');\n     assert!(s.as_slice().char_at(1u) == '\u00e9');\n "}]}