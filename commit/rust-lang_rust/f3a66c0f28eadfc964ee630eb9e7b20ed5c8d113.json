{"sha": "f3a66c0f28eadfc964ee630eb9e7b20ed5c8d113", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYTY2YzBmMjhlYWRmYzk2NGVlNjMwZWI5ZTdiMjBlZDVjOGQxMTM=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-11-10T09:39:28Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-11-10T09:39:28Z"}, "message": "Merge pull request #449 from Manishearth/shadow_visitor\n\nuse visitor for contains_self", "tree": {"sha": "84c59fe0d6f9cbdd79fd816c883da6838159c9aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84c59fe0d6f9cbdd79fd816c883da6838159c9aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3a66c0f28eadfc964ee630eb9e7b20ed5c8d113", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3a66c0f28eadfc964ee630eb9e7b20ed5c8d113", "html_url": "https://github.com/rust-lang/rust/commit/f3a66c0f28eadfc964ee630eb9e7b20ed5c8d113", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3a66c0f28eadfc964ee630eb9e7b20ed5c8d113/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12d1d6f9e85e05aacda5ba722db4348e97ed8e8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/12d1d6f9e85e05aacda5ba722db4348e97ed8e8f", "html_url": "https://github.com/rust-lang/rust/commit/12d1d6f9e85e05aacda5ba722db4348e97ed8e8f"}, {"sha": "aea2eb7da7ef9db34ee225abd3b625f428c00202", "url": "https://api.github.com/repos/rust-lang/rust/commits/aea2eb7da7ef9db34ee225abd3b625f428c00202", "html_url": "https://github.com/rust-lang/rust/commit/aea2eb7da7ef9db34ee225abd3b625f428c00202"}], "stats": {"total": 100, "additions": 12, "deletions": 88}, "files": [{"sha": "ca45ed11ab8ea6455947f23071ba1c5408f3e4e9", "filename": "src/shadow.rs", "status": "modified", "additions": 12, "deletions": 88, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f3a66c0f28eadfc964ee630eb9e7b20ed5c8d113/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a66c0f28eadfc964ee630eb9e7b20ed5c8d113/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=f3a66c0f28eadfc964ee630eb9e7b20ed5c8d113", "patch": "@@ -2,7 +2,7 @@ use std::ops::Deref;\n use rustc_front::hir::*;\n use reexport::*;\n use syntax::codemap::Span;\n-use rustc_front::visit::FnKind;\n+use rustc_front::visit::{Visitor, FnKind};\n \n use rustc::lint::*;\n use rustc::middle::def::Def::{DefVariant, DefStruct};\n@@ -269,97 +269,21 @@ fn path_eq_name(name: Name, path: &Path) -> bool {\n         path.segments[0].identifier.name == name\n }\n \n-fn contains_self(name: Name, expr: &Expr) -> bool {\n-    match expr.node {\n-        // the \"self\" name itself (maybe)\n-        ExprPath(_, ref path) => path_eq_name(name, path),\n-        // no subexprs\n-        ExprLit(_) => false,\n-        // one subexpr\n-        ExprUnary(_, ref e) | ExprField(ref e, _) |\n-        ExprTupField(ref e, _) | ExprAddrOf(_, ref e) | ExprBox(ref e) |\n-        ExprCast(ref e, _) =>\n-            contains_self(name, e),\n-        // two subexprs\n-        ExprBinary(_, ref l, ref r) | ExprIndex(ref l, ref r) |\n-        ExprAssign(ref l, ref r) | ExprAssignOp(_, ref l, ref r) |\n-        ExprRepeat(ref l, ref r) =>\n-            contains_self(name, l) || contains_self(name, r),\n-        // one optional subexpr\n-        ExprRet(ref oe) =>\n-            oe.as_ref().map_or(false, |ref e| contains_self(name, e)),\n-        // two optional subexprs\n-        ExprRange(ref ol, ref or) =>\n-            ol.as_ref().map_or(false, |ref e| contains_self(name, e)) ||\n-            or.as_ref().map_or(false, |ref e| contains_self(name, e)),\n-        // one subblock\n-        ExprBlock(ref block) | ExprLoop(ref block, _) |\n-        ExprClosure(_, _, ref block) =>\n-            contains_block_self(name, block),\n-        // one vec\n-        ExprMethodCall(_, _, ref v) | ExprVec(ref v) | ExprTup(ref v) =>\n-            v.iter().any(|ref a| contains_self(name, a)),\n-        // one expr, one vec\n-        ExprCall(ref fun, ref args) =>\n-            contains_self(name, fun) ||\n-            args.iter().any(|ref a| contains_self(name, a)),\n-        // special ones\n-        ExprIf(ref cond, ref then, ref otherwise) =>\n-            contains_self(name, cond) || contains_block_self(name, then) ||\n-            otherwise.as_ref().map_or(false, |ref e| contains_self(name, e)),\n-        ExprWhile(ref e, ref block, _)  =>\n-            contains_self(name, e) || contains_block_self(name, block),\n-        ExprMatch(ref e, ref arms, _) =>\n-            contains_self(name, e) ||\n-            arms.iter().any(\n-                |ref arm|\n-                arm.pats.iter().any(|ref pat| contains_pat_self(name, pat)) ||\n-                arm.guard.as_ref().map_or(false, |ref g| contains_self(name, g)) ||\n-                contains_self(name, &arm.body)),\n-        ExprStruct(_, ref fields, ref other) =>\n-            fields.iter().any(|ref f| contains_self(name, &f.expr)) ||\n-            other.as_ref().map_or(false, |ref e| contains_self(name, e)),\n-        _ => false,\n-    }\n+struct ContainsSelf {\n+    name: Name,\n+    result: bool\n }\n \n-fn contains_block_self(name: Name, block: &Block) -> bool {\n-    for stmt in &block.stmts {\n-        match stmt.node {\n-            StmtDecl(ref decl, _) =>\n-            if let DeclLocal(ref local) = decl.node {\n-                //TODO: We don't currently handle the case where the name\n-                //is shadowed wiithin the block; this means code including this\n-                //degenerate pattern will get the wrong warning.\n-                if let Some(ref init) = local.init {\n-                    if contains_self(name, init) { return true; }\n-                }\n-            },\n-            StmtExpr(ref e, _) | StmtSemi(ref e, _) =>\n-                if contains_self(name, e) { return true }\n+impl<'v> Visitor<'v> for ContainsSelf {\n+    fn visit_name(&mut self, _: Span, name: Name) {\n+        if self.name == name {\n+            self.result = true;\n         }\n     }\n-    if let Some(ref e) = block.expr { contains_self(name, e) } else { false }\n }\n \n-fn contains_pat_self(name: Name, pat: &Pat) -> bool {\n-    match pat.node {\n-        PatIdent(_, ref ident, ref inner) => name == ident.node.name ||\n-            inner.as_ref().map_or(false, |ref p| contains_pat_self(name, p)),\n-        PatEnum(_, ref opats) => opats.as_ref().map_or(false,\n-            |pats| pats.iter().any(|p| contains_pat_self(name, p))),\n-        PatQPath(_, ref path) => path_eq_name(name, path),\n-        PatStruct(_, ref fieldpats, _) => fieldpats.iter().any(\n-            |ref fp| contains_pat_self(name, &fp.node.pat)),\n-        PatTup(ref ps) => ps.iter().any(|ref p| contains_pat_self(name, p)),\n-        PatBox(ref p) |\n-        PatRegion(ref p, _) => contains_pat_self(name, p),\n-        PatRange(ref from, ref until) =>\n-            contains_self(name, from) || contains_self(name, until),\n-        PatVec(ref pre, ref opt, ref post) =>\n-            pre.iter().any(|ref p| contains_pat_self(name, p)) ||\n-                opt.as_ref().map_or(false, |ref p| contains_pat_self(name, p)) ||\n-                post.iter().any(|ref p| contains_pat_self(name, p)),\n-        _ => false,\n-    }\n+fn contains_self(name: Name, expr: &Expr) -> bool {\n+    let mut cs = ContainsSelf { name: name, result: false };\n+    cs.visit_expr(expr);\n+    cs.result\n }"}]}