{"sha": "f7cd97f7863fb9ee017aacec134589c211786c88", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3Y2Q5N2Y3ODYzZmI5ZWUwMTdhYWNlYzEzNDU4OWMyMTE3ODZjODg=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-02-20T01:16:42Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-03-05T22:13:10Z"}, "message": "Add ast_const_to_const\n\nCo-Authored-By: Gabriel Smith <yodaldevoid@users.noreply.github.com>", "tree": {"sha": "824f8601a85cdedb032edd93f95725ac768088ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/824f8601a85cdedb032edd93f95725ac768088ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7cd97f7863fb9ee017aacec134589c211786c88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7cd97f7863fb9ee017aacec134589c211786c88", "html_url": "https://github.com/rust-lang/rust/commit/f7cd97f7863fb9ee017aacec134589c211786c88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7cd97f7863fb9ee017aacec134589c211786c88/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f761c414b12f3851ddef7b5849bb8fdcf8d75d44", "url": "https://api.github.com/repos/rust-lang/rust/commits/f761c414b12f3851ddef7b5849bb8fdcf8d75d44", "html_url": "https://github.com/rust-lang/rust/commit/f761c414b12f3851ddef7b5849bb8fdcf8d75d44"}], "stats": {"total": 85, "additions": 74, "deletions": 11}, "files": [{"sha": "1dec2d483b80f9ffc5dac8f39f418c3e1041255b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 74, "deletions": 11, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f7cd97f7863fb9ee017aacec134589c211786c88/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7cd97f7863fb9ee017aacec134589c211786c88/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f7cd97f7863fb9ee017aacec134589c211786c88", "patch": "@@ -3,7 +3,7 @@\n //! instance of `AstConv`.\n \n use errors::{Applicability, DiagnosticId};\n-use crate::hir::{self, GenericArg, GenericArgs};\n+use crate::hir::{self, GenericArg, GenericArgs, ExprKind};\n use crate::hir::def::Def;\n use crate::hir::def_id::DefId;\n use crate::hir::HirVec;\n@@ -16,6 +16,7 @@ use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::{GenericParamDef, GenericParamDefKind};\n use rustc::ty::subst::{Kind, Subst, InternalSubsts, SubstsRef};\n use rustc::ty::wf::object_region_bounds;\n+use rustc::mir::interpret::ConstValue;\n use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi;\n use crate::require_c_abi_if_c_variadic;\n@@ -273,6 +274,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let param_counts = def.own_counts();\n         let arg_counts = args.own_counts();\n         let infer_lifetimes = position != GenericArgPosition::Type && arg_counts.lifetimes == 0;\n+        let infer_consts = position != GenericArgPosition::Type && arg_counts.consts == 0;\n \n         let mut defaults: ty::GenericParamCount = Default::default();\n         for param in &def.params {\n@@ -281,6 +283,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     defaults.types += has_default as usize\n                 }\n+                GenericParamDefKind::Const => {\n+                    // FIXME(const_generics:defaults)\n+                }\n             };\n         }\n \n@@ -311,11 +316,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n         }\n \n-        let check_kind_count = |kind,\n-                                required,\n-                                permitted,\n-                                provided,\n-                                offset| {\n+        let check_kind_count = |kind, required, permitted, provided, offset| {\n+            debug!(\n+                \"check_kind_count: kind: {} required: {} permitted: {} provided: {} offset: {}\",\n+                kind,\n+                required,\n+                permitted,\n+                provided,\n+                offset\n+            );\n             // We enforce the following: `required` <= `provided` <= `permitted`.\n             // For kinds without defaults (i.e., lifetimes), `required == permitted`.\n             // For other kinds (i.e., types), `permitted` may be greater than `required`.\n@@ -384,6 +393,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 0,\n             );\n         }\n+        // FIXME(const_generics:defaults)\n+        if !infer_consts || arg_counts.consts > param_counts.consts {\n+            check_kind_count(\n+                \"const\",\n+                param_counts.consts,\n+                param_counts.consts,\n+                arg_counts.consts,\n+                arg_counts.lifetimes + arg_counts.types,\n+            );\n+        }\n+        // Note that type errors are currently be emitted *after* const errors.\n         if !infer_types\n             || arg_counts.types > param_counts.types - defaults.types - has_self as usize {\n             check_kind_count(\n@@ -495,7 +515,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     (Some(&arg), Some(&param)) => {\n                         match (arg, &param.kind) {\n                             (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime)\n-                            | (GenericArg::Type(_), GenericParamDefKind::Type { .. }) => {\n+                            | (GenericArg::Type(_), GenericParamDefKind::Type { .. })\n+                            | (GenericArg::Const(_), GenericParamDefKind::Const) => {\n                                 substs.push(provided_kind(param, arg));\n                                 args.next();\n                                 params.next();\n@@ -606,6 +627,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n                         self.ast_ty_to_ty(&ty).into()\n                     }\n+                    (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n+                        self.ast_const_to_const(&ct.value, tcx.type_of(param.def_id)).into()\n+                    }\n                     _ => unreachable!(),\n                 }\n             },\n@@ -654,6 +678,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                             tcx.types.err.into()\n                         }\n                     }\n+                    GenericParamDefKind::Const => {\n+                        // FIXME(const_generics:defaults)\n+                        // We've already errored above about the mismatch.\n+                        tcx.types.err.into()\n+                    }\n                 }\n             },\n         );\n@@ -1609,6 +1638,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             // Case 3. Reference to a top-level value.\n             Def::Fn(def_id) |\n             Def::Const(def_id) |\n+            Def::ConstParam(def_id) |\n             Def::Static(def_id, _) => {\n                 path_segs.push(PathSeg(def_id, last));\n             }\n@@ -1797,10 +1827,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, def, segment, false).0\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n-                let length_def_id = tcx.hir().local_def_id_from_hir_id(length.hir_id);\n-                let substs = InternalSubsts::identity_for_item(tcx, length_def_id);\n-                let length = ty::LazyConst::Unevaluated(length_def_id, substs);\n-                let length = tcx.mk_lazy_const(length);\n+                let length = self.ast_const_to_const(length, tcx.types.usize);\n                 let array_ty = tcx.mk_ty(ty::Array(self.ast_ty_to_ty(&ty), length));\n                 self.normalize_ty(ast_ty.span, array_ty)\n             }\n@@ -1837,6 +1864,42 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         result_ty\n     }\n \n+    pub fn ast_const_to_const(\n+        &self,\n+        ast_const: &hir::AnonConst,\n+        ty: Ty<'tcx>\n+    ) -> &'tcx ty::LazyConst<'tcx> {\n+        debug!(\"ast_const_to_const(id={:?}, ast_const={:?})\", ast_const.id, ast_const);\n+\n+        let tcx = self.tcx();\n+        let def_id = tcx.hir().local_def_id(ast_const.id);\n+\n+        let mut lazy_const = ty::LazyConst::Unevaluated(\n+            def_id,\n+            Substs::identity_for_item(tcx, def_id)\n+        );\n+\n+        let expr = &tcx.hir().body(ast_const.body).value;\n+        if let ExprKind::Path(ref qpath) = expr.node {\n+            if let hir::QPath::Resolved(_, ref path) = qpath {\n+                if let Def::ConstParam(def_id) = path.def {\n+                    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+                    let item_id = tcx.hir().get_parent_node(node_id);\n+                    let item_def_id = tcx.hir().local_def_id(item_id);\n+                    let generics = tcx.generics_of(item_def_id);\n+                    let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(node_id)];\n+                    let name = tcx.hir().name(node_id).as_interned_str();\n+                    lazy_const = ty::LazyConst::Evaluated(ty::Const {\n+                        val: ConstValue::Param(ty::ParamConst::new(index, name)),\n+                        ty,\n+                    })\n+                }\n+            }\n+        };\n+\n+        tcx.mk_lazy_const(lazy_const)\n+    }\n+\n     pub fn impl_trait_ty_to_ty(\n         &self,\n         def_id: DefId,"}]}