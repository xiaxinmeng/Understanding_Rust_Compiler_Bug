{"sha": "efa069d28818dd074afd2c7cee776907b63ca012", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYTA2OWQyODgxOGRkMDc0YWZkMmM3Y2VlNzc2OTA3YjYzY2EwMTI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T11:41:19Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T11:55:45Z"}, "message": "internal: start new diagnostics API\n\nAt the moment, this moves only a single diagnostic, but the idea is\nreafactor the rest to use the same pattern. We are going to have a\nsingle file per diagnostic. This file will define diagnostics code,\nrendering range and fixes, if any. It'll also have all of the tests.\nThis is similar to how we deal with assists.\n\nAfter we refactor all diagnostics to follow this pattern, we'll probably\nmove them to a new `ide_diagnostics` crate.\n\nNot that we intentionally want to test all diagnostics on this layer,\ndespite the fact that they are generally emitted in the guts on the\ncompiler. Diagnostics care to much about the end presentation\ndetails/fixes to be worth-while \"unit\" testing. So, we'll unit-test only\nthe primary output of compilation process (types and name res tables),\nand will use integrated UI tests for diagnostics.", "tree": {"sha": "39f3ff2d5154bb62df5e4611f7054e1f7e96eb2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39f3ff2d5154bb62df5e4611f7054e1f7e96eb2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efa069d28818dd074afd2c7cee776907b63ca012", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efa069d28818dd074afd2c7cee776907b63ca012", "html_url": "https://github.com/rust-lang/rust/commit/efa069d28818dd074afd2c7cee776907b63ca012", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efa069d28818dd074afd2c7cee776907b63ca012/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "546be18e3a91e4844b0dacc76c9f055397b6d89e", "url": "https://api.github.com/repos/rust-lang/rust/commits/546be18e3a91e4844b0dacc76c9f055397b6d89e", "html_url": "https://github.com/rust-lang/rust/commit/546be18e3a91e4844b0dacc76c9f055397b6d89e"}], "stats": {"total": 206, "additions": 123, "deletions": 83}, "files": [{"sha": "5e2f94698975539b44b64a0e51049e0bf890d343", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/efa069d28818dd074afd2c7cee776907b63ca012/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa069d28818dd074afd2c7cee776907b63ca012/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=efa069d28818dd074afd2c7cee776907b63ca012", "patch": "@@ -15,31 +15,30 @@ pub use crate::diagnostics_sink::{\n     Diagnostic, DiagnosticCode, DiagnosticSink, DiagnosticSinkBuilder,\n };\n \n-// Diagnostic: unresolved-module\n-//\n-// This diagnostic is triggered if rust-analyzer is unable to discover referred module.\n+macro_rules! diagnostics {\n+    ($($diag:ident)*) => {\n+        pub enum AnyDiagnostic {$(\n+            $diag(Box<$diag>),\n+        )*}\n+\n+        $(\n+            impl From<$diag> for AnyDiagnostic {\n+                fn from(d: $diag) -> AnyDiagnostic {\n+                    AnyDiagnostic::$diag(Box::new(d))\n+                }\n+            }\n+        )*\n+    };\n+}\n+\n+diagnostics![UnresolvedModule];\n+\n #[derive(Debug)]\n pub struct UnresolvedModule {\n-    pub file: HirFileId,\n-    pub decl: AstPtr<ast::Module>,\n+    pub decl: InFile<AstPtr<ast::Module>>,\n     pub candidate: String,\n }\n \n-impl Diagnostic for UnresolvedModule {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"unresolved-module\")\n-    }\n-    fn message(&self) -> String {\n-        \"unresolved module\".to_string()\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.decl.clone().into())\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n // Diagnostic: unresolved-extern-crate\n //\n // This diagnostic is triggered if rust-analyzer is unable to discover referred extern crate."}, {"sha": "ff6c68dbcce60f1a888543ad6b3603669d5f3fb4", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/efa069d28818dd074afd2c7cee776907b63ca012/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa069d28818dd074afd2c7cee776907b63ca012/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=efa069d28818dd074afd2c7cee776907b63ca012", "patch": "@@ -80,18 +80,18 @@ use tt::{Ident, Leaf, Literal, TokenTree};\n \n use crate::{\n     db::{DefDatabase, HirDatabase},\n-    diagnostics::{\n-        BreakOutsideOfLoop, InactiveCode, InternalBailedOut, MacroError, MismatchedArgCount,\n-        MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr, MissingPatFields,\n-        MissingUnsafe, NoSuchField, RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap,\n-        UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n-        UnresolvedModule, UnresolvedProcMacro,\n-    },\n     diagnostics_sink::DiagnosticSink,\n };\n \n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n+    diagnostics::{\n+        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, InternalBailedOut, MacroError,\n+        MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n+        MissingPatFields, MissingUnsafe, NoSuchField, RemoveThisSemicolon,\n+        ReplaceFilterMapNextWithFindMap, UnimplementedBuiltinMacro, UnresolvedExternCrate,\n+        UnresolvedImport, UnresolvedMacroCall, UnresolvedModule, UnresolvedProcMacro,\n+    },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope},\n };\n@@ -460,10 +460,11 @@ impl Module {\n         db: &dyn HirDatabase,\n         sink: &mut DiagnosticSink,\n         internal_diagnostics: bool,\n-    ) {\n+    ) -> Vec<AnyDiagnostic> {\n         let _p = profile::span(\"Module::diagnostics\").detail(|| {\n             format!(\"{:?}\", self.name(db).map_or(\"<unknown>\".into(), |name| name.to_string()))\n         });\n+        let mut acc: Vec<AnyDiagnostic> = Vec::new();\n         let def_map = self.id.def_map(db.upcast());\n         for diag in def_map.diagnostics() {\n             if diag.in_module != self.id.local_id {\n@@ -473,11 +474,13 @@ impl Module {\n             match &diag.kind {\n                 DefDiagnosticKind::UnresolvedModule { ast: declaration, candidate } => {\n                     let decl = declaration.to_node(db.upcast());\n-                    sink.push(UnresolvedModule {\n-                        file: declaration.file_id,\n-                        decl: AstPtr::new(&decl),\n-                        candidate: candidate.clone(),\n-                    })\n+                    acc.push(\n+                        UnresolvedModule {\n+                            decl: InFile::new(declaration.file_id, AstPtr::new(&decl)),\n+                            candidate: candidate.clone(),\n+                        }\n+                        .into(),\n+                    )\n                 }\n                 DefDiagnosticKind::UnresolvedExternCrate { ast } => {\n                     let item = ast.to_node(db.upcast());\n@@ -610,7 +613,7 @@ impl Module {\n                 crate::ModuleDef::Module(m) => {\n                     // Only add diagnostics from inline modules\n                     if def_map[m.id.local_id].origin.is_inline() {\n-                        m.diagnostics(db, sink, internal_diagnostics)\n+                        acc.extend(m.diagnostics(db, sink, internal_diagnostics))\n                     }\n                 }\n                 _ => {\n@@ -626,6 +629,7 @@ impl Module {\n                 }\n             }\n         }\n+        acc\n     }\n \n     pub fn declarations(self, db: &dyn HirDatabase) -> Vec<ModuleDef> {"}, {"sha": "c82deca9c46b9911eb6136145aa2863d389178b7", "filename": "crates/hir_def/src/nameres/tests/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efa069d28818dd074afd2c7cee776907b63ca012/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa069d28818dd074afd2c7cee776907b63ca012/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs?ref=efa069d28818dd074afd2c7cee776907b63ca012", "patch": "@@ -78,20 +78,6 @@ fn dedup_unresolved_import_from_unresolved_crate() {\n     );\n }\n \n-#[test]\n-fn unresolved_module() {\n-    check_diagnostics(\n-        r\"\n-        //- /lib.rs\n-        mod foo;\n-          mod bar;\n-        //^^^^^^^^ UnresolvedModule\n-        mod baz {}\n-        //- /foo.rs\n-        \",\n-    );\n-}\n-\n #[test]\n fn inactive_item() {\n     // Additional tests in `cfg` crate. This only tests disabled cfgs."}, {"sha": "075aae8d514444992c428def7daaea09058bd478", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/efa069d28818dd074afd2c7cee776907b63ca012/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa069d28818dd074afd2c7cee776907b63ca012/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=efa069d28818dd074afd2c7cee776907b63ca012", "patch": "@@ -4,6 +4,8 @@\n //! macro-expanded files, but we need to present them to the users in terms of\n //! original files. So we need to map the ranges.\n \n+mod unresolved_module;\n+\n mod fixes;\n mod field_shorthand;\n mod unlinked_file;\n@@ -12,7 +14,7 @@ use std::cell::RefCell;\n \n use hir::{\n     db::AstDatabase,\n-    diagnostics::{Diagnostic as _, DiagnosticCode, DiagnosticSinkBuilder},\n+    diagnostics::{AnyDiagnostic, Diagnostic as _, DiagnosticCode, DiagnosticSinkBuilder},\n     InFile, Semantics,\n };\n use ide_assists::AssistResolveStrategy;\n@@ -42,6 +44,12 @@ pub struct Diagnostic {\n }\n \n impl Diagnostic {\n+    fn new(code: &'static str, message: impl Into<String>, range: TextRange) -> Diagnostic {\n+        let message = message.into();\n+        let code = Some(DiagnosticCode(code));\n+        Self { message, range, severity: Severity::Error, fixes: None, unused: false, code }\n+    }\n+\n     fn error(range: TextRange, message: String) -> Self {\n         Self { message, range, severity: Severity::Error, fixes: None, unused: false, code: None }\n     }\n@@ -82,6 +90,13 @@ pub struct DiagnosticsConfig {\n     pub disabled: FxHashSet<String>,\n }\n \n+struct DiagnosticsContext<'a> {\n+    config: &'a DiagnosticsConfig,\n+    sema: Semantics<'a, RootDatabase>,\n+    #[allow(unused)]\n+    resolve: &'a AssistResolveStrategy,\n+}\n+\n pub(crate) fn diagnostics(\n     db: &RootDatabase,\n     config: &DiagnosticsConfig,\n@@ -108,9 +123,6 @@ pub(crate) fn diagnostics(\n     }\n     let res = RefCell::new(res);\n     let sink_builder = DiagnosticSinkBuilder::new()\n-        .on::<hir::diagnostics::UnresolvedModule, _>(|d| {\n-            res.borrow_mut().push(diagnostic_with_fix(d, &sema, resolve));\n-        })\n         .on::<hir::diagnostics::MissingFields, _>(|d| {\n             res.borrow_mut().push(diagnostic_with_fix(d, &sema, resolve));\n         })\n@@ -204,16 +216,33 @@ pub(crate) fn diagnostics(\n             );\n         });\n \n+    let mut diags = Vec::new();\n     let internal_diagnostics = cfg!(test);\n     match sema.to_module_def(file_id) {\n-        Some(m) => m.diagnostics(db, &mut sink, internal_diagnostics),\n+        Some(m) => diags = m.diagnostics(db, &mut sink, internal_diagnostics),\n         None => {\n             sink.push(UnlinkedFile { file_id, node: SyntaxNodePtr::new(parse.tree().syntax()) });\n         }\n     }\n \n     drop(sink);\n-    res.into_inner()\n+\n+    let mut res = res.into_inner();\n+\n+    let ctx = DiagnosticsContext { config, sema, resolve };\n+    for diag in diags {\n+        let d = match diag {\n+            AnyDiagnostic::UnresolvedModule(d) => unresolved_module::render(&ctx, &d),\n+        };\n+        if let Some(code) = d.code {\n+            if ctx.config.disabled.contains(code.as_str()) {\n+                continue;\n+            }\n+        }\n+        res.push(d)\n+    }\n+\n+    res\n }\n \n fn diagnostic_with_fix<D: DiagnosticWithFixes>("}, {"sha": "8640d723124840dedad1d7e77773470a29acb383", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efa069d28818dd074afd2c7cee776907b63ca012/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa069d28818dd074afd2c7cee776907b63ca012/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=efa069d28818dd074afd2c7cee776907b63ca012", "patch": "@@ -5,7 +5,6 @@ mod create_field;\n mod fill_missing_fields;\n mod remove_semicolon;\n mod replace_with_find_map;\n-mod unresolved_module;\n mod wrap_tail_expr;\n \n use hir::{diagnostics::Diagnostic, Semantics};"}, {"sha": "abf53a57c0ca2f77193e9f0a5b173c851cd98676", "filename": "crates/ide/src/diagnostics/unresolved_module.rs", "status": "renamed", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/efa069d28818dd074afd2c7cee776907b63ca012/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa069d28818dd074afd2c7cee776907b63ca012/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_module.rs?ref=efa069d28818dd074afd2c7cee776907b63ca012", "patch": "@@ -1,39 +1,59 @@\n-use hir::{db::AstDatabase, diagnostics::UnresolvedModule, Semantics};\n-use ide_assists::{Assist, AssistResolveStrategy};\n-use ide_db::{base_db::AnchoredPathBuf, source_change::FileSystemEdit, RootDatabase};\n+use hir::db::AstDatabase;\n+use ide_assists::Assist;\n+use ide_db::{base_db::AnchoredPathBuf, source_change::FileSystemEdit};\n use syntax::AstNode;\n \n-use crate::diagnostics::{fix, DiagnosticWithFixes};\n+use crate::diagnostics::{fix, Diagnostic, DiagnosticsContext};\n \n-impl DiagnosticWithFixes for UnresolvedModule {\n-    fn fixes(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Vec<Assist>> {\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        let unresolved_module = self.decl.to_node(&root);\n-        Some(vec![fix(\n-            \"create_module\",\n-            \"Create module\",\n-            FileSystemEdit::CreateFile {\n-                dst: AnchoredPathBuf {\n-                    anchor: self.file.original_file(sema.db),\n-                    path: self.candidate.clone(),\n-                },\n-                initial_contents: \"\".to_string(),\n-            }\n-            .into(),\n-            unresolved_module.syntax().text_range(),\n-        )])\n-    }\n+// Diagnostic: unresolved-module\n+//\n+// This diagnostic is triggered if rust-analyzer is unable to discover referred module.\n+pub(super) fn render(ctx: &DiagnosticsContext<'_>, d: &hir::UnresolvedModule) -> Diagnostic {\n+    Diagnostic::new(\n+        \"unresolved-module\",\n+        \"unresolved module\",\n+        ctx.sema.diagnostics_display_range(d.decl.clone().map(|it| it.into())).range,\n+    )\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::UnresolvedModule) -> Option<Vec<Assist>> {\n+    let root = ctx.sema.db.parse_or_expand(d.decl.file_id)?;\n+    let unresolved_module = d.decl.value.to_node(&root);\n+    Some(vec![fix(\n+        \"create_module\",\n+        \"Create module\",\n+        FileSystemEdit::CreateFile {\n+            dst: AnchoredPathBuf {\n+                anchor: d.decl.file_id.original_file(ctx.sema.db),\n+                path: d.candidate.clone(),\n+            },\n+            initial_contents: \"\".to_string(),\n+        }\n+        .into(),\n+        unresolved_module.syntax().text_range(),\n+    )])\n }\n \n #[cfg(test)]\n mod tests {\n     use expect_test::expect;\n \n-    use crate::diagnostics::tests::check_expect;\n+    use crate::diagnostics::tests::{check_diagnostics, check_expect};\n+\n+    #[test]\n+    fn unresolved_module() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs\n+mod foo;\n+  mod bar;\n+//^^^^^^^^ unresolved module\n+mod baz {}\n+//- /foo.rs\n+\"#,\n+        );\n+    }\n \n     #[test]\n     fn test_unresolved_module_diagnostic() {", "previous_filename": "crates/ide/src/diagnostics/fixes/unresolved_module.rs"}, {"sha": "f2ba8efef5f0567665f0065dd5f663cbe520e5f6", "filename": "xtask/src/tidy.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/efa069d28818dd074afd2c7cee776907b63ca012/xtask%2Fsrc%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa069d28818dd074afd2c7cee776907b63ca012/xtask%2Fsrc%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Ftidy.rs?ref=efa069d28818dd074afd2c7cee776907b63ca012", "patch": "@@ -372,7 +372,10 @@ impl TidyDocs {\n                 self.contains_fixme.push(path.to_path_buf());\n             }\n         } else {\n-            if text.contains(\"// Feature:\") || text.contains(\"// Assist:\") {\n+            if text.contains(\"// Feature:\")\n+                || text.contains(\"// Assist:\")\n+                || text.contains(\"// Diagnostic:\")\n+            {\n                 return;\n             }\n             self.missing_docs.push(path.display().to_string());"}]}