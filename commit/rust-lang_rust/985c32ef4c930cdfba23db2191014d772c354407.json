{"sha": "985c32ef4c930cdfba23db2191014d772c354407", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NWMzMmVmNGM5MzBjZGZiYTIzZGIyMTkxMDE0ZDc3MmMzNTQ0MDc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-28T10:01:45Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-01T15:51:37Z"}, "message": "Partially implement destructuring locals\n\nYou can now say\n\n    let {bcx, val} = some_result_returner();\n\nSimilar for loop variables. Assigning to such variables is not safe\nyet. Function arguments also remain a TODO.", "tree": {"sha": "f9cfb1ad055221eb63cfd22e49cbe18d59dcf520", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9cfb1ad055221eb63cfd22e49cbe18d59dcf520"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/985c32ef4c930cdfba23db2191014d772c354407", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/985c32ef4c930cdfba23db2191014d772c354407", "html_url": "https://github.com/rust-lang/rust/commit/985c32ef4c930cdfba23db2191014d772c354407", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/985c32ef4c930cdfba23db2191014d772c354407/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48ec25da423cd6535e6354a00fa6c98f3f2b4065", "url": "https://api.github.com/repos/rust-lang/rust/commits/48ec25da423cd6535e6354a00fa6c98f3f2b4065", "html_url": "https://github.com/rust-lang/rust/commit/48ec25da423cd6535e6354a00fa6c98f3f2b4065"}], "stats": {"total": 558, "additions": 308, "deletions": 250}, "files": [{"sha": "75b3dbf658cccaf1fe638837f5aff770ca2f410d", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -127,7 +127,7 @@ fn visit_decl(cx: &@ctx, d: &@ast::decl, sc: &scope, v: &vt[scope]) {\n     visit::visit_decl(d, sc, v);\n     alt d.node {\n       ast::decl_local(locs) {\n-        for loc: @ast::local  in locs {\n+        for loc: @ast::local in locs {\n             alt loc.node.init {\n               some(init) {\n                 if init.op == ast::init_move {\n@@ -298,14 +298,12 @@ fn check_alt(cx: &ctx, input: &@ast::expr, arms: &ast::arm[], sc: &scope,\n         let dnums = arm_defnums(a);\n         let new_sc = sc;\n         if ivec::len(dnums) > 0u {\n-            new_sc =\n-                @(*sc +\n-                      ~[@{root_vars: roots,\n-                          block_defnum: dnums.(0),\n-                          bindings: dnums,\n-                          tys: forbidden_tp,\n-                          depends_on: deps(sc, roots),\n-                          mutable ok: valid}]);\n+            new_sc = @(*sc + ~[@{root_vars: roots,\n+                                 block_defnum: dnums.(ivec::len(dnums) - 1u),\n+                                 bindings: dnums,\n+                                 tys: forbidden_tp,\n+                                 depends_on: deps(sc, roots),\n+                                 mutable ok: valid}]);\n         }\n         visit::visit_arm(a, new_sc, v);\n     }\n@@ -336,14 +334,16 @@ fn check_for_each(cx: &ctx, local: &@ast::local, call: &@ast::expr,\n     alt call.node {\n       ast::expr_call(f, args) {\n         let data = check_call(cx, f, args, sc);\n-        let defnum = local.node.id;\n-        let new_sc =\n-            @{root_vars: data.root_vars,\n-              block_defnum: defnum,\n-              bindings: ~[defnum],\n-              tys: data.unsafe_ts,\n-              depends_on: deps(sc, data.root_vars),\n-              mutable ok: valid};\n+        let bindings = ~[];\n+        for p: @ast::pat in ast::pat_bindings(local.node.pat) {\n+            bindings += ~[p.id];\n+        }\n+        let new_sc = @{root_vars: data.root_vars,\n+                       block_defnum: bindings.(ivec::len(bindings) - 1u),\n+                       bindings: bindings,\n+                       tys: data.unsafe_ts,\n+                       depends_on: deps(sc, data.root_vars),\n+                       mutable ok: valid};\n         visit::visit_block(blk, @(*sc + ~[new_sc]), v);\n       }\n     }\n@@ -352,7 +352,6 @@ fn check_for_each(cx: &ctx, local: &@ast::local, call: &@ast::expr,\n fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n              sc: &scope, v: &vt[scope]) {\n     visit::visit_expr(seq, sc, v);\n-    let defnum = local.node.id;\n     let root = expr_root(cx, seq, false);\n     let root_def =\n         alt path_def_id(cx, root.ex) { some(did) { ~[did.node] } _ { ~[] } };\n@@ -371,13 +370,16 @@ fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n                                     util::ppaux::ty_to_str(cx.tcx, seq_t));\n       }\n     }\n-    let new_sc =\n-        @{root_vars: root_def,\n-          block_defnum: defnum,\n-          bindings: ~[defnum],\n-          tys: unsafe,\n-          depends_on: deps(sc, root_def),\n-          mutable ok: valid};\n+    let bindings = ~[];\n+    for p: @ast::pat in ast::pat_bindings(local.node.pat) {\n+        bindings += ~[p.id];\n+    }\n+    let new_sc = @{root_vars: root_def,\n+                   block_defnum: bindings.(ivec::len(bindings) - 1u),\n+                   bindings: bindings,\n+                   tys: unsafe,\n+                   depends_on: deps(sc, root_def),\n+                   mutable ok: valid};\n     visit::visit_block(blk, @(*sc + ~[new_sc]), v);\n }\n \n@@ -388,10 +390,10 @@ fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n     let my_defnum = ast::def_id_of_def(def).node;\n     let var_t = ty::expr_ty(cx.tcx, ex);\n     for r: restrict  in *sc {\n-\n         // excludes variables introduced since the alias was made\n+        // FIXME This does not work anymore, now that we have macros.\n         if my_defnum < r.block_defnum {\n-            for t: ty::t  in r.tys {\n+            for t: ty::t in r.tys {\n                 if ty_can_unsafely_include(cx, t, var_t, assign) {\n                     r.ok = val_taken(ex.span, p);\n                 }\n@@ -489,15 +491,14 @@ fn test_scope(cx: &ctx, sc: &scope, r: &restrict, p: &ast::path) {\n         prob = sc.(dep).ok;\n     }\n     if prob != valid {\n-        let msg =\n-            alt prob {\n-              overwritten(sp, wpt) {\n-                {span: sp, msg: \"overwriting \" + ast::path_name(wpt)}\n-              }\n-              val_taken(sp, vpt) {\n-                {span: sp, msg: \"taking the value of \" + ast::path_name(vpt)}\n-              }\n-            };\n+        let msg = alt prob {\n+          overwritten(sp, wpt) {\n+            {span: sp, msg: \"overwriting \" + ast::path_name(wpt)}\n+          }\n+          val_taken(sp, vpt) {\n+            {span: sp, msg: \"taking the value of \" + ast::path_name(vpt)}\n+          }\n+        };\n         cx.tcx.sess.span_err(msg.span,\n                              msg.msg + \" will invalidate alias \" +\n                                  ast::path_name(p) + \", which is still used\");"}, {"sha": "fa44001e330ad3e36bb0e00e1bff6aed7b85fc3b", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -69,7 +69,9 @@ fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n         }\n     }\n     fn walk_local(e: env, local: &@ast::local) {\n-        set_add(e.decls, local.node.id);\n+        for b: @ast::pat in ast::pat_bindings(local.node.pat) {\n+            set_add(e.decls, b.id);\n+        }\n     }\n     fn walk_pat(e: env, p: &@ast::pat) {\n         alt p.node { ast::pat_bind(_) { set_add(e.decls, p.id); } _ { } }\n@@ -131,9 +133,13 @@ fn annotate_freevars(sess: &session::session, def_map: &resolve::def_map,\n             fn start_walk(b: &ast::blk, v: &visit::vt[()]) {\n                 v.visit_block(b, (), v);\n             }\n+            let bound = ~[];\n+            for b: @ast::pat in ast::pat_bindings(local.node.pat){\n+                bound += ~[b.id];\n+            }\n             let vars =\n                 collect_freevars(e.def_map, e.sess, bind start_walk(body, _),\n-                                 ~[local.node.id]);\n+                                 bound);\n             e.freevars.insert(body.node.id, vars);\n           }\n           _ { }"}, {"sha": "e341855978d93fbf6a5dfdefe18f24f17822b77c", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 58, "deletions": 61, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -255,6 +255,7 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n           visit_item: visit_item_with_scope,\n           visit_block: visit_block_with_scope,\n           visit_arm: bind walk_arm(e, _, _, _),\n+          visit_pat: bind walk_pat(e, _, _, _),\n           visit_expr: bind walk_expr(e, _, _, _),\n           visit_ty: bind walk_ty(e, _, _, _),\n           visit_constr: bind walk_constr(e, _, _, _, _, _),\n@@ -289,33 +290,23 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n         maybe_insert(e, id, lookup_path_strict(*e, sc, sp, p.node, ns_value));\n     }\n     fn walk_arm(e: @env, a: &ast::arm, sc: &scopes, v: &vt[scopes]) {\n-        for p: @ast::pat  in a.pats { walk_pat(*e, sc, p); }\n         visit_arm_with_scope(a, sc, v);\n     }\n-    fn walk_pat(e: &env, sc: &scopes, pat: &@ast::pat) {\n+    fn walk_pat(e: &@env, pat: &@ast::pat, sc: &scopes, v: &vt[scopes]) {\n+        visit::visit_pat(pat, sc, v);\n         alt pat.node {\n-          ast::pat_tag(p, children) {\n-            let fnd = lookup_path_strict(e, sc, p.span, p.node, ns_value);\n-            if option::is_some(fnd) {\n-                alt option::get(fnd) {\n-                  ast::def_variant(did, vid) {\n-                    e.def_map.insert(pat.id, option::get(fnd));\n-                    for child: @ast::pat  in children {\n-                        walk_pat(e, sc, child);\n-                    }\n-                  }\n-                  _ {\n-                    e.sess.span_err(p.span,\n-                                    \"not a tag variant: \" +\n-                                        ast::path_name(p));\n-                  }\n-                }\n+          ast::pat_tag(p, _) {\n+            let fnd = lookup_path_strict(*e, sc, p.span, p.node, ns_value);\n+            alt option::get(fnd) {\n+              ast::def_variant(did, vid) {\n+                e.def_map.insert(pat.id, option::get(fnd));\n+              }\n+              _ {\n+                e.sess.span_err\n+                    (p.span, \"not a tag variant: \" + ast::path_name(p));\n+              }\n             }\n           }\n-          ast::pat_rec(fields, _) {\n-            for f: ast::field_pat  in fields { walk_pat(e, sc, f.pat); }\n-          }\n-          ast::pat_box(inner) { walk_pat(e, sc, inner); }\n           _ { }\n         }\n     }\n@@ -653,14 +644,18 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n           }\n           scope_loop(local) {\n             if ns == ns_value {\n-                if str::eq(local.node.ident, name) {\n-                    ret some(ast::def_local(local_def(local.node.id)));\n+                alt lookup_in_pat(name, *local.node.pat) {\n+                  some(did) { ret some(ast::def_local(did)); }\n+                  _ {}\n                 }\n             }\n           }\n           scope_block(b) { ret lookup_in_block(name, b.node, ns); }\n           scope_arm(a) {\n-            if ns == ns_value { ret lookup_in_pat(name, *a.pats.(0)); }\n+            if ns == ns_value {\n+                ret option::map(ast::def_binding,\n+                                lookup_in_pat(name, *a.pats.(0)));\n+            }\n           }\n         }\n         ret none[def];\n@@ -716,11 +711,11 @@ fn lookup_in_ty_params(name: &ident, ty_params: &ast::ty_param[]) ->\n     ret none[def];\n }\n \n-fn lookup_in_pat(name: &ident, pat: &ast::pat) -> option::t[def] {\n+fn lookup_in_pat(name: &ident, pat: &ast::pat) -> option::t[def_id] {\n     alt pat.node {\n       ast::pat_bind(p_name) {\n         if str::eq(p_name, name) {\n-            ret some(ast::def_binding(local_def(pat.id)));\n+            ret some(local_def(pat.id));\n         }\n       }\n       ast::pat_wild. { }\n@@ -739,7 +734,7 @@ fn lookup_in_pat(name: &ident, pat: &ast::pat) -> option::t[def] {\n       }\n       ast::pat_box(inner) { ret lookup_in_pat(name, *inner); }\n     }\n-    ret none[def];\n+    ret none;\n }\n \n fn lookup_in_fn(name: &ident, decl: &ast::fn_decl,\n@@ -777,14 +772,17 @@ fn lookup_in_obj(name: &ident, ob: &ast::_obj, ty_params: &ast::ty_param[],\n \n fn lookup_in_block(name: &ident, b: &ast::blk_, ns: namespace) ->\n    option::t[def] {\n-    for st: @ast::stmt  in b.stmts {\n+    for st: @ast::stmt in b.stmts {\n         alt st.node {\n           ast::stmt_decl(d, _) {\n             alt d.node {\n               ast::decl_local(locs) {\n-                for loc: @ast::local  in locs {\n-                    if ns == ns_value && str::eq(name, loc.node.ident) {\n-                        ret some(ast::def_local(local_def(loc.node.id)));\n+                for loc: @ast::local in locs {\n+                    if ns == ns_value {\n+                        alt lookup_in_pat(name, *loc.node.pat) {\n+                          some(did) { ret some(ast::def_local(did)); }\n+                          _ {}\n+                        }\n                     }\n                 }\n               }\n@@ -1154,22 +1152,20 @@ fn lookup_external(e: &env, cnum: int, ids: &ident[], ns: namespace) ->\n fn check_for_collisions(e: &@env, c: &ast::crate) {\n     // Module indices make checking those relatively simple -- just check each\n     // name for multiple entities in the same namespace.\n-\n-    for each m: @{key: ast::node_id, val: @indexed_mod}  in e.mod_map.items()\n-             {\n-        for each name: @{key: ident, val: list[mod_index_entry]}  in\n-                 m.val.index.items() {\n+    for each m: @{key: ast::node_id, val: @indexed_mod}\n+        in e.mod_map.items() {\n+        for each name: @{key: ident, val: list[mod_index_entry]}\n+            in m.val.index.items() {\n             check_mod_name(*e, name.key, name.val);\n         }\n     }\n     // Other scopes have to be checked the hard way.\n-\n-    let v =\n-        @{visit_item: bind check_item(e, _, _, _),\n-          visit_block: bind check_block(e, _, _, _),\n-          visit_arm: bind check_arm(e, _, _, _),\n-          visit_expr: bind check_expr(e, _, _, _),\n-          visit_ty: bind check_ty(e, _, _, _) with *visit::default_visitor()};\n+    let v = @{visit_item: bind check_item(e, _, _, _),\n+              visit_block: bind check_block(e, _, _, _),\n+              visit_arm: bind check_arm(e, _, _, _),\n+              visit_expr: bind check_expr(e, _, _, _),\n+              visit_ty: bind check_ty(e, _, _, _)\n+              with *visit::default_visitor()};\n     visit::visit_crate(c, (), visit::mk_vt(v));\n }\n \n@@ -1244,29 +1240,30 @@ fn check_item(e: &@env, i: &@ast::item, x: &(), v: &vt[()]) {\n     }\n }\n \n+fn check_pat(ch: checker, p: &@ast::pat) {\n+    alt p.node {\n+      ast::pat_bind(name) { add_name(ch, p.span, name); }\n+      ast::pat_tag(_, children) {\n+        for child: @ast::pat in children { check_pat(ch, child); }\n+      }\n+      ast::pat_rec(fields, _) {\n+        for f: ast::field_pat  in fields { check_pat(ch, f.pat); }\n+      }\n+      ast::pat_box(inner) { check_pat(ch, inner); }\n+      _ { }\n+    }\n+}\n+\n fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt[()]) {\n     visit::visit_arm(a, x, v);\n-    fn walk_pat(ch: checker, p: &@ast::pat) {\n-        alt p.node {\n-          ast::pat_bind(name) { add_name(ch, p.span, name); }\n-          ast::pat_tag(_, children) {\n-            for child: @ast::pat  in children { walk_pat(ch, child); }\n-          }\n-          ast::pat_rec(fields, _) {\n-            for f: ast::field_pat  in fields { walk_pat(ch, f.pat); }\n-          }\n-          ast::pat_box(inner) { walk_pat(ch, inner); }\n-          _ { }\n-        }\n-    }\n     let ch0 = checker(*e, \"binding\");\n-    walk_pat(ch0, a.pats.(0));\n+    check_pat(ch0, a.pats.(0));\n     let seen0 = ch0.seen;\n     let i = ivec::len(a.pats);\n     while i > 1u {\n         i -= 1u;\n         let ch = checker(*e, \"binding\");\n-        walk_pat(ch, a.pats.(i));\n+        check_pat(ch, a.pats.(i));\n \n         // Ensure the bindings introduced in this pattern are the same as in\n         // the first pattern.\n@@ -1297,8 +1294,8 @@ fn check_block(e: &@env, b: &ast::blk, x: &(), v: &vt[()]) {\n           ast::stmt_decl(d, _) {\n             alt d.node {\n               ast::decl_local(locs) {\n-                for loc: @ast::local  in locs {\n-                    add_name(values, d.span, loc.node.ident);\n+                for loc: @ast::local in locs {\n+                    check_pat(values, loc.node.pat);\n                 }\n               }\n               ast::decl_item(it) {"}, {"sha": "90ce96e415f8e91022bb88c6a60bf6645bc77f3e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -956,9 +956,8 @@ fn get_derived_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool,\n     bcx = align.bcx;\n     let v;\n     if escapes {\n-        let  /* for root*/\n-\n-            tydescs =\n+        /* for root*/\n+        let tydescs =\n             alloca(bcx,\n                    T_array(T_ptr(bcx_ccx(bcx).tydesc_type), 1u + n_params));\n         let i = 0;\n@@ -3620,8 +3619,10 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n                                       outer_next_cx, \"for loop scope\");\n         cx.build.Br(scope_cx.llbb);\n         let local_res = alloc_local(scope_cx, local);\n-        let bcx = copy_val(local_res.bcx, INIT, local_res.val, curr, t).bcx;\n+        let loc_r = copy_val(local_res.bcx, INIT, local_res.val, curr, t);\n         add_clean(scope_cx, local_res.val, t);\n+        let bcx = trans_alt::bind_irrefutable_pat\n+            (loc_r.bcx, local.node.pat, local_res.val, cx.fcx.lllocals);\n         bcx = trans_block(bcx, body, return).bcx;\n         if !bcx.build.is_terminated() {\n             bcx.build.Br(next_cx.llbb);\n@@ -3915,7 +3916,6 @@ fn trans_for_each(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n \n     // FIXME: possibly support alias-mode here?\n     let decl_ty = node_id_type(lcx.ccx, local.node.id);\n-    let decl_id = local.node.id;\n     let upvars = get_freevars(lcx.ccx.tcx, body.node.id);\n \n     let llenv = build_environment(cx, upvars);\n@@ -3941,9 +3941,11 @@ fn trans_for_each(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n     // environment pointer.\n     load_environment(cx, fcx, llenv.ptrty, upvars);\n \n-    // Add an upvar for the loop variable alias.\n-    fcx.llupvars.insert(decl_id, llvm::LLVMGetParam(fcx.llfn, 3u));\n     let bcx = new_top_block_ctxt(fcx);\n+    // Add bindings for the loop variable alias.\n+    bcx = trans_alt::bind_irrefutable_pat\n+        (bcx, local.node.pat, llvm::LLVMGetParam(fcx.llfn, 3u),\n+         bcx.fcx.llupvars);\n     let lltop = bcx.llbb;\n     let r = trans_block(bcx, body, return);\n     finish_fn(fcx, lltop);\n@@ -5884,23 +5886,19 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n     ret rslt(bcx, pair);\n }\n \n-fn init_local(cx: &@block_ctxt, local: &@ast::local) -> result {\n+fn init_local(bcx: @block_ctxt, local: &@ast::local) -> result {\n+    let ty = node_id_type(bcx_ccx(bcx), local.node.id);\n+    let llptr = bcx.fcx.lllocals.get(local.node.id);\n     // Make a note to drop this slot on the way out.\n-\n-    assert (cx.fcx.lllocals.contains_key(local.node.id));\n-    let llptr = cx.fcx.lllocals.get(local.node.id);\n-    let ty = node_id_type(bcx_ccx(cx), local.node.id);\n-    let bcx = cx;\n-    add_clean(cx, llptr, ty);\n+    add_clean(bcx, llptr, ty);\n     alt local.node.init {\n       some(init) {\n         alt init.op {\n           ast::init_assign. {\n             // Use the type of the RHS because if it's _|_, the LHS\n             // type might be something else, but we don't want to copy\n             // the value.\n-\n-            ty = node_id_type(bcx_ccx(cx), init.expr.id);\n+            ty = node_id_type(bcx_ccx(bcx), init.expr.id);\n             let sub = trans_lval(bcx, init.expr);\n             bcx = move_val_if_temp(sub.res.bcx, INIT, llptr, sub, ty).bcx;\n           }\n@@ -5912,6 +5910,8 @@ fn init_local(cx: &@block_ctxt, local: &@ast::local) -> result {\n       }\n       _ { bcx = zero_alloca(bcx, llptr, ty).bcx; }\n     }\n+    bcx = trans_alt::bind_irrefutable_pat(bcx, local.node.pat, llptr,\n+                                          bcx.fcx.lllocals);\n     ret rslt(bcx, llptr);\n }\n \n@@ -6032,15 +6032,14 @@ fn trans_block_cleanups(cx: &@block_ctxt, cleanup_cx: &@block_ctxt) ->\n }\n \n iter block_locals(b: &ast::blk) -> @ast::local {\n-\n     // FIXME: putting from inside an iter block doesn't work, so we can't\n     // use the index here.\n     for s: @ast::stmt  in b.node.stmts {\n         alt s.node {\n           ast::stmt_decl(d, _) {\n             alt d.node {\n               ast::decl_local(locals) {\n-                for local: @ast::local  in locals { put local; }\n+                for local: @ast::local in locals { put local; }\n               }\n               _ {/* fall through */ }\n             }\n@@ -6110,26 +6109,31 @@ fn alloc_ty(cx: &@block_ctxt, t: &ty::t) -> result {\n fn alloc_local(cx: &@block_ctxt, local: &@ast::local) -> result {\n     let t = node_id_type(bcx_ccx(cx), local.node.id);\n     let r = alloc_ty(cx, t);\n-    if bcx_ccx(cx).sess.get_opts().debuginfo {\n-        llvm::LLVMSetValueName(r.val, str::buf(local.node.ident));\n+    alt local.node.pat.node {\n+      ast::pat_bind(ident) {\n+        if bcx_ccx(cx).sess.get_opts().debuginfo {\n+            llvm::LLVMSetValueName(r.val, str::buf(ident));\n+        }\n+      }\n+      _ {}\n     }\n-    r.bcx.fcx.lllocals.insert(local.node.id, r.val);\n     ret r;\n }\n \n fn trans_block(cx: &@block_ctxt, b: &ast::blk, output: &out_method) ->\n    result {\n     let bcx = cx;\n-    for each local: @ast::local  in block_locals(b) {\n+    for each local: @ast::local in block_locals(b) {\n         // FIXME Update bcx.sp\n-        bcx = alloc_local(bcx, local).bcx;\n+        let r = alloc_local(bcx, local);\n+        bcx = r.bcx;\n+        bcx.fcx.lllocals.insert(local.node.id, r.val);\n     }\n     let r = rslt(bcx, C_nil());\n     for s: @ast::stmt  in b.node.stmts {\n         r = trans_stmt(bcx, *s);\n         bcx = r.bcx;\n \n-\n         // If we hit a terminator, control won't go any further so\n         // we're in dead-code land. Stop here.\n         if is_terminated(bcx) { ret r; }"}, {"sha": "c77a345126684fd5f60fd21ea744bc356edbfb5e", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -176,8 +176,8 @@ fn get_options(ccx: &@crate_ctxt, m: &match, col: uint) -> opt[] {\n }\n \n fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n-                        vdefs: &{tg: def_id, var: def_id}, val: ValueRef) ->\n-   {vals: ValueRef[], bcx: @block_ctxt} {\n+                        vdefs: &{tg: def_id, var: def_id}, val: ValueRef)\n+    -> {vals: ValueRef[], bcx: @block_ctxt} {\n     let ccx = bcx.fcx.lcx.ccx;\n     let ty_param_substs = ty::node_id_to_type_params(ccx.tcx, pat_id);\n     let blobptr = val;\n@@ -246,7 +246,6 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: ValueRef[],\n     let ccx = bcx.fcx.lcx.ccx;\n     let pat_id = 0;\n     for br: match_branch  in m {\n-\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n         if pat_id == 0 { pat_id = br.pats.(col).id; }\n@@ -259,7 +258,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: ValueRef[],\n         let fields =\n             alt ty::struct(ccx.tcx, rec_ty) { ty::ty_rec(fields) { fields } };\n         let rec_vals = ~[];\n-        for field_name: ast::ident  in rec_fields {\n+        for field_name: ast::ident in rec_fields {\n             let ix: uint =\n                 ty::field_idx(ccx.sess, {lo: 0u, hi: 0u}, field_name, fields);\n             let r = trans::GEP_tup_like(bcx, rec_ty, val, ~[0, ix as int]);\n@@ -436,6 +435,47 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &ast::arm[],\n     ret rslt(trans::join_branches(cx, arm_results), C_nil());\n }\n \n+// Not alt-related, but similar to the pattern-munging code above\n+fn bind_irrefutable_pat(bcx: @block_ctxt, pat: &@ast::pat, val: ValueRef,\n+                        table: hashmap[ast::node_id, ValueRef])\n+    -> @block_ctxt {\n+    let ccx = bcx.fcx.lcx.ccx;\n+    alt pat.node {\n+      ast::pat_bind(_) {\n+        table.insert(pat.id, val);\n+      }\n+      ast::pat_tag(_, sub) {\n+        if ivec::len(sub) == 0u { ret bcx; }\n+        let vdefs = ast::variant_def_ids(ccx.tcx.def_map.get(pat.id));\n+        let args = extract_variant_args(bcx, pat.id, vdefs, val);\n+        let i = 0;\n+        for argval: ValueRef in args.vals {\n+            bcx = bind_irrefutable_pat(bcx, sub.(i), argval, table);\n+            i += 1;\n+        }\n+      }\n+      ast::pat_rec(fields, _) {\n+        let rec_ty = ty::node_id_to_monotype(ccx.tcx, pat.id);\n+        let rec_fields =\n+            alt ty::struct(ccx.tcx, rec_ty) { ty::ty_rec(fields) { fields } };\n+        for f: ast::field_pat in fields {\n+            let ix: uint =\n+                ty::field_idx(ccx.sess, pat.span, f.ident, rec_fields);\n+            let r = trans::GEP_tup_like(bcx, rec_ty, val, ~[0, ix as int]);\n+            bcx = bind_irrefutable_pat(r.bcx, f.pat, r.val, table);\n+        }\n+      }\n+      ast::pat_box(inner) {\n+        let box = bcx.build.Load(val);\n+        let unboxed = bcx.build.InBoundsGEP\n+            (box, ~[C_int(0), C_int(back::abi::box_rc_field_body)]);\n+        bcx = bind_irrefutable_pat(bcx, inner, unboxed, table);\n+      }\n+      ast::pat_wild. | ast::pat_lit(_) {}\n+    }\n+    ret bcx;\n+}\n+\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil"}, {"sha": "d59c07a7cd870666cf20208df2f2b184b3c040df", "filename": "src/comp/middle/trans_dps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -580,9 +580,9 @@ fn trans_lit_common(ccx: &@crate_ctxt, lit: &ast::lit) -> ValueRef {\n }\n \n fn trans_init_local(bcx: &@block_ctxt, local: &@ast::local) -> @block_ctxt {\n-    let llptr = bcx_fcx(bcx).lllocals.get(local.node.id);\n+    let llptr = bcx_fcx(bcx).lllocals.get(local.node.pat.id); // FIXME DESTR\n \n-    let t = type_of_node(bcx_ccx(bcx), local.node.id);\n+    let t = type_of_node(bcx_ccx(bcx), local.node.pat.id);\n     tc::add_clean(bcx, llptr, t);\n \n "}, {"sha": "f0bebcfc0c56081c7d8611d5c9c6eb486278b8ec", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -44,7 +44,9 @@ fn collect_ids_stmt(s: &@stmt, rs: @mutable node_id[]) {\n }\n \n fn collect_ids_local(l: &@local, rs: @mutable node_id[]) {\n-    *rs += ~[l.node.id];\n+    for p: @pat in pat_bindings(l.node.pat) {\n+        *rs += ~[p.id];\n+    }\n }\n \n fn node_ids_in_fn(f: &_fn, tps: &ty_param[], sp: &span, i: &fn_ident,"}, {"sha": "7ad070446f8f9018e594fc5ddf38e1b0c2d985b5", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -1037,24 +1037,29 @@ fn ast_constr_to_sp_constr(tcx: &ty::ctxt, args: &arg[], c: &@constr) ->\n     ret respan(c.span, tconstr);\n }\n \n-type binding = {lhs: option::t[inst], rhs: option::t[initializer]};\n+type binding = {lhs: inst[], rhs: option::t[initializer]};\n \n-fn local_to_binding(loc : &@local) -> binding {\n-    {lhs: some({ident: loc.node.ident, node: loc.node.id}),\n+fn local_to_bindings(loc : &@local) -> binding {\n+    let lhs = ~[];\n+    for p: @pat in pat_bindings(loc.node.pat) {\n+        let ident = alt p.node { pat_bind(name) { name } };\n+        lhs += ~[{ident: ident, node: p.id}];\n+    }\n+    {lhs: lhs,\n      rhs: loc.node.init}\n }\n \n fn locals_to_bindings(locals : &(@local)[]) -> binding[] {\n-    ivec::map(local_to_binding, locals)\n+    ivec::map(local_to_bindings, locals)\n }\n \n fn anon_bindings(es : &(@expr)[]) -> binding[] {\n     fn expr_to_initializer(e : &@expr) -> initializer {\n         {op: init_assign, expr: e}\n     }\n     ret ivec::map(fn (e : &@expr) -> binding {\n-                    {lhs: none,\n-                     rhs: some(expr_to_initializer(e)) } },\n+        {lhs: ~[],\n+         rhs: some(expr_to_initializer(e)) } },\n                   es);\n }\n "}, {"sha": "4dd9750c7dbc12d9a5498b0739b02e532bc59470", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -14,8 +14,11 @@ import syntax::ast::respan;\n type ctxt = {cs: @mutable sp_constr[], tcx: ty::ctxt};\n \n fn collect_local(loc: &@local, cx: &ctxt, v: &visit::vt[ctxt]) {\n-    log \"collect_local: pushing \" + loc.node.ident;\n-    *cx.cs += ~[respan(loc.span, ninit(loc.node.id, loc.node.ident))];\n+    for p: @pat in pat_bindings(loc.node.pat) {\n+        let ident = alt p.node { pat_bind(id) { id } };\n+        log \"collect_local: pushing \" + ident;\n+        *cx.cs += ~[respan(loc.span, ninit(p.id, ident))];\n+    }\n     visit::visit_local(loc, cx, v);\n }\n "}, {"sha": "84c75fa168684e51e40242d92847ff110f652a0a", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -133,12 +133,14 @@ fn find_pre_post_loop(fcx: &fn_ctxt, l: &@local, index: &@expr, body: &blk,\n                       id: node_id) {\n     find_pre_post_expr(fcx, index);\n     find_pre_post_block(fcx, body);\n-    let v_init = ninit(l.node.id, l.node.ident);\n-    relax_precond_block(fcx, bit_num(fcx, v_init) as node_id, body);\n-\n-    // Hack: for-loop index variables are frequently ignored,\n-    // so we pretend they're used\n-    use_var(fcx, l.node.id);\n+    for p: @pat in pat_bindings(l.node.pat) {\n+        let ident = alt p.node { pat_bind(id) { id } };\n+        let v_init = ninit(p.id, ident);\n+        relax_precond_block(fcx, bit_num(fcx, v_init) as node_id, body);\n+        // Hack: for-loop index variables are frequently ignored,\n+        // so we pretend they're used\n+        use_var(fcx, p.id);\n+    }\n \n     let loop_precond =\n         seq_preconds(fcx,\n@@ -573,41 +575,47 @@ fn find_pre_post_stmt(fcx: &fn_ctxt, s: &stmt) {\n         alt adecl.node {\n           decl_local(alocals) {\n             for alocal: @local  in alocals {\n+                let bindings = pat_bindings(alocal.node.pat);\n                 alt alocal.node.init {\n                   some(an_init) {\n                     /* LHS always becomes initialized,\n                      whether or not this is a move */\n-\n                     find_pre_post_expr(fcx, an_init.expr);\n-                    copy_pre_post(fcx.ccx, alocal.node.id, an_init.expr);\n+                    for p: @pat in bindings {\n+                        copy_pre_post(fcx.ccx, p.id, an_init.expr);\n+                    }\n                     /* Inherit ann from initializer, and add var being\n                        initialized to the postcondition */\n-\n                     copy_pre_post(fcx.ccx, id, an_init.expr);\n \n                     alt an_init.expr.node {\n                       expr_path(p) {\n-                        copy_in_postcond(fcx, id,\n-                                         {ident: alocal.node.ident,\n-                                          node: alocal.node.id},\n-                                         {ident:\n+                        for pat: @pat in bindings {\n+                            let ident = alt pat.node { pat_bind(n) { n } };\n+                            copy_in_postcond(fcx, id,\n+                                             {ident: ident, node: pat.id},\n+                                             {ident:\n                                               path_to_ident(fcx.ccx.tcx, p),\n-                                          node: an_init.expr.id},\n-                                         op_to_oper_ty(an_init.op));\n+                                              node: an_init.expr.id},\n+                                             op_to_oper_ty(an_init.op));\n+                        }\n                       }\n                       _ { }\n                     }\n \n-                    gen(fcx, id, ninit(alocal.node.id, alocal.node.ident));\n-\n+                    for p: @pat in bindings {\n+                      let ident = alt p.node { pat_bind(name) { name } };\n+                      gen(fcx, id, ninit(p.id, ident));\n+                    }\n \n                     if an_init.op == init_move && is_path(an_init.expr) {\n                         forget_in_postcond(fcx, id, an_init.expr.id);\n                     }\n                   }\n                   none. {\n-                    clear_pp(node_id_to_ts_ann(fcx.ccx,\n-                                               alocal.node.id).conditions);\n+                    for p: @pat in bindings {\n+                        clear_pp(node_id_to_ts_ann(fcx.ccx, p.id).conditions);\n+                    }\n                     clear_pp(node_id_to_ts_ann(fcx.ccx, id).conditions);\n                   }\n                 }"}, {"sha": "90a7cd88effb25148f852e4b4366a70e9dc8e754", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -74,8 +74,7 @@ fn seq_states(fcx: &fn_ctxt, pres: &prestate, bindings: &binding[])\n             changed |= find_pre_post_state_expr(fcx, post, an_init.expr)\n                 || changed;\n             post = tritv_clone(expr_poststate(fcx.ccx, an_init.expr));\n-            alt (b.lhs) {\n-              some(i) {\n+            for i: inst in b.lhs {\n                 alt (an_init.expr.node) {\n                   expr_path(p) {\n                     handle_move_or_copy(fcx, post, p, an_init.expr.id, i,\n@@ -84,22 +83,12 @@ fn seq_states(fcx: &fn_ctxt, pres: &prestate, bindings: &binding[])\n                   _ {}\n                 }\n                 set_in_poststate_ident(fcx, i.node, i.ident, post);\n-              }\n-              _ {\n-                //This is an expression that doesn't get named.\n-                // So, nothing more to do.\n-              }\n             }\n-           }\n-         none {\n-            alt (b.lhs) {\n-              some(i) {\n-                // variable w/o an initializer\n-                 clear_in_poststate_ident_(fcx, i.node, i.ident, post);\n-               }\n-              none { fcx.ccx.tcx.sess.bug(\"seq_states: binding has \\\n-                               neither an lhs nor an rhs\");\n-              }\n+          }\n+          none {\n+            for i: inst in b.lhs {\n+                // variables w/o an initializer\n+                clear_in_poststate_ident_(fcx, i.node, i.ident, post);\n             }\n           }\n         }\n@@ -217,10 +206,13 @@ fn find_pre_post_state_loop(fcx: &fn_ctxt, pres: prestate, l: &@local,\n         set_prestate_ann(fcx.ccx, id, loop_pres) |\n             find_pre_post_state_expr(fcx, pres, index);\n \n-    // Make sure the index var is considered initialized\n+    // Make sure the index vars are considered initialized\n     // in the body\n     let index_post = tritv_clone(expr_poststate(fcx.ccx, index));\n-    set_in_poststate_ident(fcx, l.node.id, l.node.ident, index_post);\n+    for p: @pat in pat_bindings(l.node.pat) {\n+        let ident = alt p.node { pat_bind(name) { name } };\n+        set_in_poststate_ident(fcx, p.id, ident, index_post);\n+    }\n \n     changed |= find_pre_post_state_block(fcx, index_post, body);\n "}, {"sha": "faabbfe6898c9346656962bbc9cbfe729a064554", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -39,7 +39,6 @@ export constr_general;\n export constr_table;\n export count_ty_params;\n export ctxt;\n-export decl_local_ty;\n export def_has_ty_params;\n export eq_ty;\n export expr_has_ty_params;\n@@ -1893,10 +1892,6 @@ fn expr_has_ty_params(cx: &ctxt, expr: &@ast::expr) -> bool {\n     ret node_id_has_type_params(cx, expr.id);\n }\n \n-fn decl_local_ty(cx: &ctxt, l: &@ast::local) -> t {\n-    ret node_id_to_type(cx, l.node.id);\n-}\n-\n fn stmt_node_id(s: &@ast::stmt) -> ast::node_id {\n     alt s.node {\n       ast::stmt_decl(_, id) { ret id; }"}, {"sha": "84482ce46cfa89128c9d63d87e3a8831d1efb014", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 30, "deletions": 39, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -52,10 +52,8 @@ type ty_table = hashmap[ast::def_id, ty::t];\n \n // Used for typechecking the methods of an object.\n tag obj_info {\n-\n     // Regular objects have a node_id at compile time.\n     regular_obj(ast::obj_field[], ast::node_id);\n-\n     // Anonymous objects only have a type at compile time.  It's optional\n     // because not all anonymous objects have a inner_obj to attach to.\n     anon_obj(ast::obj_field[], option::t[ty::sty]);\n@@ -84,9 +82,8 @@ fn lookup_local(fcx: &@fn_ctxt, sp: &span, id: ast::node_id) -> int {\n     alt fcx.locals.find(id) {\n       some(x) { x }\n       _ {\n-        fcx.ccx.tcx.sess.span_fatal(sp,\n-                                    \"internal error looking up a \\\n-              local var\")\n+        fcx.ccx.tcx.sess.span_fatal\n+            (sp, \"internal error looking up a local var\")\n       }\n     }\n }\n@@ -95,13 +92,19 @@ fn lookup_def(fcx: &@fn_ctxt, sp: &span, id: ast::node_id) -> ast::def {\n     alt fcx.ccx.tcx.def_map.find(id) {\n       some(x) { x }\n       _ {\n-        fcx.ccx.tcx.sess.span_fatal(sp,\n-                                    \"internal error looking up \\\n-              a definition\")\n+        fcx.ccx.tcx.sess.span_fatal\n+            (sp, \"internal error looking up a definition\")\n       }\n     }\n }\n \n+fn ident_for_local(loc: &@ast::local) -> ast::ident {\n+    ret alt loc.node.pat.node {\n+      ast::pat_bind(name) { name }\n+      _ { \"local\" } // FIXME DESTR\n+    };\n+}\n+\n // Returns the type parameter count and the type for the given definition.\n fn ty_param_kinds_and_ty_for_def(fcx: &@fn_ctxt, sp: &span, defn: &ast::def)\n    -> ty_param_kinds_and_ty {\n@@ -134,15 +137,13 @@ fn ty_param_kinds_and_ty_for_def(fcx: &@fn_ctxt, sp: &span, defn: &ast::def)\n       ast::def_mod(_) {\n         // Hopefully part of a path.\n         // TODO: return a type that's more poisonous, perhaps?\n-\n         ret {kinds: no_kinds, ty: ty::mk_nil(fcx.ccx.tcx)};\n       }\n       ast::def_ty(_) {\n         fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found type\");\n       }\n       _ {\n         // FIXME: handle other names.\n-\n         fcx.ccx.tcx.sess.unimpl(\"definition variant\");\n       }\n     }\n@@ -190,7 +191,6 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n         }\n     } else {\n         // We will acquire the type parameters through unification.\n-\n         let ty_substs: ty::t[] = ~[];\n         let i = 0u;\n         while i < ty_param_count {\n@@ -213,16 +213,13 @@ fn ast_mode_to_mode(mode: ast::mode) -> ty::mode {\n \n \n // Type tests\n-fn structurally_resolved_type(fcx: &@fn_ctxt, sp: &span, typ: ty::t) ->\n+fn structurally_resolved_type(fcx: &@fn_ctxt, sp: &span, tp: ty::t) ->\n    ty::t {\n-    let r =\n-        ty::unify::resolve_type_structure(fcx.ccx.tcx, fcx.var_bindings, typ);\n-    alt r {\n+    alt ty::unify::resolve_type_structure(fcx.ccx.tcx, fcx.var_bindings, tp) {\n       fix_ok(typ_s) { ret typ_s; }\n       fix_err(_) {\n-        fcx.ccx.tcx.sess.span_fatal(sp,\n-                                    \"the type of this value must be \\\n-                                        known in this context\");\n+        fcx.ccx.tcx.sess.span_fatal\n+            (sp, \"the type of this value must be known in this context\");\n       }\n     }\n }\n@@ -763,12 +760,10 @@ mod collect {\n         alt it.node {\n           ast::item_mod(_) {\n             // ignore item_mod, it has no type.\n-\n           }\n           ast::item_native_mod(native_mod) {\n             // Propagate the native ABI down to convert_native() below,\n             // but otherwise do nothing, as native modules have no types.\n-\n             *abi = some[ast::native_abi](native_mod.abi);\n           }\n           ast::item_tag(variants, ty_params) {\n@@ -779,18 +774,16 @@ mod collect {\n           ast::item_obj(object, ty_params, ctor_id) {\n             // Now we need to call ty_of_obj_ctor(); this is the type that\n             // we write into the table for this item.\n-\n             ty_of_item(cx, it);\n \n-            let tpt =\n-                ty_of_obj_ctor(cx, it.ident, object, ctor_id, ty_params);\n+            let tpt = ty_of_obj_ctor(cx, it.ident, object,\n+                                     ctor_id, ty_params);\n             write::ty_only(cx.tcx, ctor_id, tpt.ty);\n             // Write the methods into the type table.\n             //\n             // FIXME: Inefficient; this ends up calling\n             // get_obj_method_types() twice. (The first time was above in\n             // ty_of_obj().)\n-\n             let method_types = get_obj_method_types(cx, object);\n             let i = 0u;\n             while i < ivec::len[@ast::method](object.methods) {\n@@ -803,7 +796,6 @@ mod collect {\n             //\n             // FIXME: We want to use uint::range() here, but that causes\n             // an assertion in trans.\n-\n             let args = ty::ty_fn_args(cx.tcx, tpt.ty);\n             i = 0u;\n             while i < ivec::len[ty::arg](args) {\n@@ -833,7 +825,6 @@ mod collect {\n             // This call populates the type cache with the converted type\n             // of the item in passing. All we have to do here is to write\n             // it into the node type table.\n-\n             let tpt = ty_of_item(cx, it);\n             write::ty_only(cx.tcx, it.id, tpt.ty);\n           }\n@@ -844,13 +835,11 @@ mod collect {\n         // As above, this call populates the type table with the converted\n         // type of the native item. We simply write it into the node type\n         // table.\n-\n         let tpt =\n             ty_of_native_item(cx, i, option::get[ast::native_abi]({ *abi }));\n         alt i.node {\n           ast::native_item_ty. {\n             // FIXME: Native types have no annotation. Should they? --pcw\n-\n           }\n           ast::native_item_fn(_, _, _) {\n             write::ty_only(cx.tcx, i.id, tpt.ty);\n@@ -860,11 +849,9 @@ mod collect {\n     fn collect_item_types(tcx: &ty::ctxt, crate: &@ast::crate) {\n         // We have to propagate the surrounding ABI to the native items\n         // contained within the native module.\n-\n         let abi = @mutable none[ast::native_abi];\n         let cx = @{tcx: tcx};\n-        let visit =\n-            visit::mk_simple_visitor\n+        let visit = visit::mk_simple_visitor\n             (@{visit_item: bind convert(cx, abi, _),\n                visit_native_item: bind convert_native(cx, abi, _)\n                with *visit::default_simple_visitor()});\n@@ -1211,6 +1198,8 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n               local_names: &hashmap[ast::node_id, ast::ident],\n               nvi: @mutable int, nid: ast::node_id, ident: &ast::ident,\n               ty_opt: option::t[ty::t]) {\n+        // FIXME DESTR\n+        if locals.contains_key(nid) { ret; }\n         let var_id = next_var_id(nvi);\n         locals.insert(nid, var_id);\n         local_names.insert(nid, ident);\n@@ -1277,13 +1266,13 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n           none. {\n             // Auto slot.\n             assign(ccx.tcx, vb, locals, local_names, nvi, local.node.id,\n-                   local.node.ident, none);\n+                   ident_for_local(local), none);\n           }\n           some(ast_ty) {\n             // Explicitly typed slot.\n             let local_ty = ast_ty_to_ty_crate(ccx, ast_ty);\n             assign(ccx.tcx, vb, locals, local_names, nvi, local.node.id,\n-                   local.node.ident, some[ty::t](local_ty));\n+                   ident_for_local(local), some(local_ty));\n           }\n         }\n         visit::visit_local(local, e, v);\n@@ -1623,7 +1612,8 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         let bot = check_decl_local(fcx, local);\n         check_block(fcx, body);\n         // Unify type of decl with element type of the seq\n-        demand::simple(fcx, local.span, ty::decl_local_ty(fcx.ccx.tcx, local),\n+        demand::simple(fcx, local.span,\n+                       ty::node_id_to_type(fcx.ccx.tcx, local.node.id),\n                        element_ty);\n         let typ = ty::mk_nil(fcx.ccx.tcx);\n         write::ty_only_fixup(fcx, node_id, typ);\n@@ -1807,7 +1797,6 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         }\n         // The definition doesn't take type parameters. If the programmer\n         // supplied some, that's an error.\n-\n         if ivec::len[@ast::ty](pth.node.types) > 0u {\n             fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                         \"this kind of value does not \\\n@@ -2532,22 +2521,24 @@ fn check_decl_initializer(fcx: &@fn_ctxt, nid: ast::node_id,\n }\n \n fn check_decl_local(fcx: &@fn_ctxt, local: &@ast::local) -> bool {\n-    let a_id = local.node.id;\n     let bot = false;\n-    alt fcx.locals.find(a_id) {\n+\n+    alt fcx.locals.find(local.node.id) {\n       none. {\n         fcx.ccx.tcx.sess.bug(\"check_decl_local: local id not found \" +\n-                                 local.node.ident);\n+                             ident_for_local(local));\n       }\n       some(i) {\n         let t = ty::mk_var(fcx.ccx.tcx, i);\n-        write::ty_only_fixup(fcx, a_id, t);\n+        write::ty_only_fixup(fcx, local.node.id, t);\n         alt local.node.init {\n           some(init) {\n             bot = check_decl_initializer(fcx, local.node.id, init);\n           }\n           _ {/* fall through */ }\n         }\n+        let id_map = ast::pat_id_map(local.node.pat);\n+        check_pat(fcx, id_map, local.node.pat, t);\n       }\n     }\n     ret bot;"}, {"sha": "5dfe6ba74637e70a7b3a1146cb27222108720360", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -142,7 +142,7 @@ fn pat_id_map(pat: &@pat) -> pat_id_map {\n     fn walk(map: &pat_id_map, pat: &@pat) {\n         alt pat.node {\n           pat_bind(name) { map.insert(name, pat.id); }\n-          pat_tag(_, sub) { for p: @pat  in sub { walk(map, p); } }\n+          pat_tag(_, sub) { for p: @pat in sub { walk(map, p); } }\n           pat_rec(fields, _) {\n             for f: field_pat  in fields { walk(map, f.pat); }\n           }\n@@ -154,6 +154,26 @@ fn pat_id_map(pat: &@pat) -> pat_id_map {\n     ret map;\n }\n \n+// FIXME This wanted to be an iter, but bug #791 got in the way.\n+fn pat_bindings(pat: &@pat) -> (@pat)[] {\n+    let found = ~[];\n+    fn recur(found: &mutable (@pat)[], pat: &@pat) {\n+        alt pat.node {\n+          pat_bind(_) { found += ~[pat]; }\n+          pat_tag(_, sub) {\n+            for p in sub { recur(found, p); }\n+          }\n+          pat_rec(fields, _) {\n+            for f: field_pat in fields { recur(found, f.pat); }\n+          }\n+          pat_box(sub) { recur(found, sub); }\n+          pat_wild. | pat_lit(_) {}\n+        }\n+    }\n+    recur(found, pat);\n+    ret found;\n+}\n+\n tag mutability { mut; imm; maybe_mut; }\n \n tag kind { kind_pinned; kind_shared; kind_unique; }\n@@ -240,12 +260,10 @@ tag init_op { init_assign; init_recv; init_move; }\n \n type initializer = {op: init_op, expr: @expr};\n \n-type local_ =\n-    {ty: option::t[@ty],\n-     infer: bool,\n-     ident: ident,\n-     init: option::t[initializer],\n-     id: node_id};\n+type local_ = {ty: option::t[@ty],\n+               pat: @pat,\n+               init: option::t[initializer],\n+               id: node_id};\n \n type local = spanned[local_];\n "}, {"sha": "e2bb0380c0474e815bdf2273526d931dd50f528a", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -486,16 +486,14 @@ fn noop_fold_path(p: &path_, fld: ast_fold) -> path_ {\n \n fn noop_fold_local(l: &local_, fld: ast_fold) -> local_ {\n     ret {ty: option::map(fld.fold_ty, l.ty),\n-         infer: l.infer,\n-         ident: fld.fold_ident(l.ident),\n-         init:\n-             alt l.init {\n-               option::none[initializer]. { l.init }\n-               option::some[initializer](init) {\n-                 option::some[initializer]({op: init.op,\n-                                            expr: fld.fold_expr(init.expr)})\n-               }\n-             },\n+         pat: fld.fold_pat(l.pat),\n+         init: alt l.init {\n+           option::none[initializer]. { l.init }\n+           option::some[initializer](init) {\n+             option::some[initializer]({op: init.op,\n+                                        expr: fld.fold_expr(init.expr)})\n+           }\n+         },\n          id: l.id};\n }\n "}, {"sha": "9c929390bd2266d2a3d5c2a3ccc3fb12562d6e2a", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -1337,9 +1337,6 @@ fn parse_alt_expr(p: &parser) -> @ast::expr {\n     expect(p, token::LBRACE);\n     let arms: ast::arm[] = ~[];\n     while p.peek() != token::RBRACE {\n-        // Optionally eat the case keyword.\n-        // FIXME remove this (and the optional parens) once we've updated our\n-        // code to not use the old syntax\n         let pats = parse_pats(p);\n         let blk = parse_block(p);\n         arms += ~[{pats: pats, block: blk}];\n@@ -1472,7 +1469,7 @@ fn parse_pat(p: &parser) -> @ast::pat {\n                          _ { true }\n                        }) {\n             hi = p.get_hi_pos();\n-            pat = ast::pat_bind(parse_ident(p));\n+            pat = ast::pat_bind(parse_value_ident(p));\n         } else {\n             let tag_path = parse_path_and_ty_param_substs(p);\n             hi = tag_path.span.hi;\n@@ -1497,14 +1494,13 @@ fn parse_pat(p: &parser) -> @ast::pat {\n \n fn parse_local(p: &parser, allow_init: bool) -> @ast::local {\n     let lo = p.get_lo_pos();\n-    let ident = parse_value_ident(p);\n+    let pat = parse_pat(p);\n     let ty = none;\n     if eat(p, token::COLON) { ty = some(parse_ty(p)); }\n     let init = if allow_init { parse_initializer(p) } else { none };\n     ret @spanned(lo, p.get_last_hi_pos(),\n                  {ty: ty,\n-                  infer: false,\n-                  ident: ident,\n+                  pat: pat,\n                   init: init,\n                   id: p.get_id()});\n }"}, {"sha": "7533eced7cfa04fdc4297ecc982d25846ee348c0", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -1002,15 +1002,16 @@ fn print_decl(s: &ps, decl: &@ast::decl) {\n         ibox(s, indent_unit);\n         word_nbsp(s, \"let\");\n         fn print_local(s: &ps, loc: &@ast::local) {\n+            ibox(s, indent_unit);\n+            print_pat(s, loc.node.pat);\n             alt loc.node.ty {\n               some(ty) {\n-                ibox(s, indent_unit);\n-                word_space(s, loc.node.ident + \":\");\n+                word_space(s, \":\");\n                 print_type(s, *ty);\n-                end(s);\n               }\n-              _ { word(s.s, loc.node.ident); }\n+              _ { }\n             }\n+            end(s);\n             alt loc.node.init {\n               some(init) {\n                 nbsp(s);\n@@ -1034,7 +1035,7 @@ fn print_decl(s: &ps, decl: &@ast::decl) {\n fn print_ident(s: &ps, ident: &ast::ident) { word(s.s, ident); }\n \n fn print_for_decl(s: &ps, loc: &@ast::local, coll: &@ast::expr) {\n-    word(s.s, loc.node.ident);\n+    print_pat(s, loc.node.pat);\n     alt loc.node.ty {\n       some(t) { word_space(s, \":\"); print_type(s, *t); }\n       none. { }"}, {"sha": "673fa46d466cd85a13c1b85561a8ae2aabfb6efe", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -78,6 +78,7 @@ fn visit_mod[E](m: &_mod, sp: &span, e: &E, v: &vt[E]) {\n fn visit_view_item[E](vi: &@view_item, e: &E, v: &vt[E]) { }\n \n fn visit_local[E](loc: &@local, e: &E, v: &vt[E]) {\n+    v.visit_pat(loc.node.pat, e, v);\n     alt loc.node.ty { none. { } some(t) { v.visit_ty(t, e, v); } }\n     alt loc.node.init { none. { } some(i) { v.visit_expr(i.expr, e, v); } }\n }"}, {"sha": "7687dce937018b4dc44a87aca83d17218868fdf6", "filename": "src/lib/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/985c32ef4c930cdfba23db2191014d772c354407/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985c32ef4c930cdfba23db2191014d772c354407/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=985c32ef4c930cdfba23db2191014d772c354407", "patch": "@@ -237,7 +237,7 @@ fn position_pred[T](f: fn(&T) -> bool , v: &vec[T]) -> option::t[uint] {\n }\n \n fn member[T](x: &T, v: &array[T]) -> bool {\n-    for elt: T  in v { if x == elt { ret true; } }\n+    for elt: T in v { if x == elt { ret true; } }\n     ret false;\n }\n "}]}