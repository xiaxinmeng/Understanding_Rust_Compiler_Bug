{"sha": "9653f790333d1270f36f1614e85d8a7b54193e75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NTNmNzkwMzMzZDEyNzBmMzZmMTYxNGU4NWQ4YTdiNTQxOTNlNzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-29T12:35:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-29T12:35:39Z"}, "message": "Auto merge of #54660 - kennytm:rollup, r=kennytm\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #54564 (Add 1.29.1 release notes)\n - #54567 (Include path in stamp hash for debuginfo tests)\n - #54577 (rustdoc: give proc-macros their own pages)\n - #54590 (std: Don't let `rust_panic` get inlined)\n - #54598 (Remove useless lifetimes from `Pin` `impl`s.)\n - #54604 (Added help message for `self_in_typedefs` feature gate)\n - #54635 (Improve docs for std::io::Seek)\n - #54645 (Compute Android gdb version in compiletest)", "tree": {"sha": "854a3f96041f7734a63a7b197ccd968b3674cd9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/854a3f96041f7734a63a7b197ccd968b3674cd9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9653f790333d1270f36f1614e85d8a7b54193e75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9653f790333d1270f36f1614e85d8a7b54193e75", "html_url": "https://github.com/rust-lang/rust/commit/9653f790333d1270f36f1614e85d8a7b54193e75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9653f790333d1270f36f1614e85d8a7b54193e75/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e7bc060c1564b19742fd241f40a02c9210e445c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e7bc060c1564b19742fd241f40a02c9210e445c", "html_url": "https://github.com/rust-lang/rust/commit/7e7bc060c1564b19742fd241f40a02c9210e445c"}, {"sha": "def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "html_url": "https://github.com/rust-lang/rust/commit/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6"}], "stats": {"total": 948, "additions": 671, "deletions": 277}, "files": [{"sha": "08470e731d8e7390f89d8479f0d9a363089268ad", "filename": "RELEASES.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -1,3 +1,16 @@\n+Version 1.29.1 (2018-09-25)\n+===========================\n+\n+Security Notes\n+--------------\n+\n+- The standard library's `str::repeat` function contained an out of bounds write\n+  caused by an integer overflow. This has been fixed by deterministically\n+  panicking when an overflow happens.\n+\n+  Thank you to Scott McMurray for responsibily disclosing this vulnerability to\n+  us.\n+\n Version 1.29.0 (2018-09-13)\n ==========================\n "}, {"sha": "0224560af4c764657e5e667e40434f731b8aba7d", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -293,21 +293,21 @@ where\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, P: fmt::Debug> fmt::Debug for Pin<P> {\n+impl<P: fmt::Debug> fmt::Debug for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&self.pointer, f)\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, P: fmt::Display> fmt::Display for Pin<P> {\n+impl<P: fmt::Display> fmt::Display for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&self.pointer, f)\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, P: fmt::Pointer> fmt::Pointer for Pin<P> {\n+impl<P: fmt::Pointer> fmt::Pointer for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Pointer::fmt(&self.pointer, f)\n     }\n@@ -319,10 +319,10 @@ impl<'a, P: fmt::Pointer> fmt::Pointer for Pin<P> {\n // for other reasons, though, so we just need to take care not to allow such\n // impls to land in std.\n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, P, U> CoerceUnsized<Pin<U>> for Pin<P>\n+impl<P, U> CoerceUnsized<Pin<U>> for Pin<P>\n where\n     P: CoerceUnsized<U>,\n {}\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, P> Unpin for Pin<P> {}\n+impl<P> Unpin for Pin<P> {}"}, {"sha": "6187e091319e0f03fcd44ce8b2a3ed2fe62ce40f", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -539,7 +539,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n                 .emit();\n         } else if has_guard && !cx.tcx.allow_bind_by_move_patterns_with_guards() {\n             let mut err = struct_span_err!(cx.tcx.sess, p.span, E0008,\n-                                       \"cannot bind by-move into a pattern guard\");\n+                                           \"cannot bind by-move into a pattern guard\");\n             err.span_label(p.span, \"moves value into pattern guard\");\n             if cx.tcx.sess.opts.unstable_features.is_nightly_build() && cx.tcx.use_mir_borrowck() {\n                 err.help(\"add #![feature(bind_by_move_pattern_guards)] to the \\"}, {"sha": "5e3f7470099117c806abfd11e5eba77ee59fe066", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -42,8 +42,9 @@ use rustc::lint;\n use rustc::hir::def::*;\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n-use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n+use rustc::session::config::nightly_options;\n+use rustc::ty;\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n use rustc_metadata::creader::CrateLoader;\n@@ -1381,6 +1382,9 @@ pub struct Resolver<'a, 'b: 'a> {\n     /// The current self type if inside an impl (used for better errors).\n     current_self_type: Option<Ty>,\n \n+    /// The current self item if inside an ADT (used for better errors).\n+    current_self_item: Option<NodeId>,\n+\n     /// The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n \n@@ -1710,6 +1714,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             current_trait_ref: None,\n             current_self_type: None,\n+            current_self_item: None,\n \n             primitive_type_table: PrimitiveTypeTable::new(),\n \n@@ -2186,15 +2191,17 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn resolve_adt(&mut self, item: &Item, generics: &Generics) {\n-        self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind), |this| {\n-            let item_def_id = this.definitions.local_def_id(item.id);\n-            if this.session.features_untracked().self_in_typedefs {\n-                this.with_self_rib(Def::SelfTy(None, Some(item_def_id)), |this| {\n+        self.with_current_self_item(item, |this| {\n+            this.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind), |this| {\n+                let item_def_id = this.definitions.local_def_id(item.id);\n+                if this.session.features_untracked().self_in_typedefs {\n+                    this.with_self_rib(Def::SelfTy(None, Some(item_def_id)), |this| {\n+                        visit::walk_item(this, item);\n+                    });\n+                } else {\n                     visit::walk_item(this, item);\n-                });\n-            } else {\n-                visit::walk_item(this, item);\n-            }\n+                }\n+            });\n         });\n     }\n \n@@ -2435,6 +2442,15 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         result\n     }\n \n+    fn with_current_self_item<T, F>(&mut self, self_item: &Item, f: F) -> T\n+        where F: FnOnce(&mut Resolver) -> T\n+    {\n+        let previous_value = replace(&mut self.current_self_item, Some(self_item.id));\n+        let result = f(self);\n+        self.current_self_item = previous_value;\n+        result\n+    }\n+\n     /// This is called to resolve a trait reference from an `impl` (i.e. `impl Trait for Foo`)\n     fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n         where F: FnOnce(&mut Resolver, Option<DefId>) -> T\n@@ -3004,6 +3020,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     \"traits and impls\"\n                 };\n                 err.span_label(span, format!(\"`Self` is only available in {}\", available_in));\n+                if this.current_self_item.is_some() && nightly_options::is_nightly_build() {\n+                    err.help(\"add #![feature(self_in_typedefs)] to the crate attributes \\\n+                              to enable\");\n+                }\n                 return (err, Vec::new());\n             }\n             if is_self_value(path, ns) {"}, {"sha": "ec4483204f05ebe02838e14c5e084d0df76fa35a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -17,6 +17,9 @@ use check::FnCtxt;\n use hir::def_id::DefId;\n use hir::def::Def;\n use namespace::Namespace;\n+use rustc::hir;\n+use rustc::lint;\n+use rustc::session::config::nightly_options;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, ObligationCause};\n use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TraitRef, TypeFoldable};\n@@ -28,8 +31,6 @@ use rustc::middle::stability;\n use syntax::ast;\n use syntax::util::lev_distance::{lev_distance, find_best_match_for_name};\n use syntax_pos::{Span, symbol::Symbol};\n-use rustc::hir;\n-use rustc::lint;\n use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n@@ -1073,9 +1074,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             self.tcx.item_path_str(stable_pick.item.def_id),\n         ));\n \n-        if ::rustc::session::config::nightly_options::is_nightly_build() {\n+        if nightly_options::is_nightly_build() {\n             for (candidate, feature) in unstable_candidates {\n-                diag.note(&format!(\n+                diag.help(&format!(\n                     \"add #![feature({})] to the crate attributes to enable `{}`\",\n                     feature,\n                     self.tcx.item_path_str(candidate.item.def_id),"}, {"sha": "a435712ac3d6ce75ae6f52e5995eb5c550d5bf7f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -13,7 +13,7 @@\n use std::iter::once;\n \n use syntax::ast;\n-use syntax::ext::base::MacroKind;\n+use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax_pos::Span;\n \n use rustc::hir;\n@@ -105,12 +105,12 @@ pub fn try_inline(cx: &DocContext, def: Def, name: ast::Name, visited: &mut FxHa\n             record_extern_fqn(cx, did, clean::TypeKind::Const);\n             clean::ConstantItem(build_const(cx, did))\n         }\n-        // FIXME(misdreavus): if attributes/derives come down here we should probably document them\n-        // separately\n+        // FIXME: proc-macros don't propagate attributes or spans across crates, so they look empty\n         Def::Macro(did, MacroKind::Bang) => {\n-            record_extern_fqn(cx, did, clean::TypeKind::Macro);\n-            if let Some(mac) = build_macro(cx, did, name) {\n-                clean::MacroItem(mac)\n+            let mac = build_macro(cx, did, name);\n+            if let clean::MacroItem(..) = mac {\n+                record_extern_fqn(cx, did, clean::TypeKind::Macro);\n+                mac\n             } else {\n                 return None;\n             }\n@@ -442,31 +442,41 @@ fn build_static(cx: &DocContext, did: DefId, mutable: bool) -> clean::Static {\n     }\n }\n \n-fn build_macro(cx: &DocContext, did: DefId, name: ast::Name) -> Option<clean::Macro> {\n+fn build_macro(cx: &DocContext, did: DefId, name: ast::Name) -> clean::ItemEnum {\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n-    let def = match cx.cstore.load_macro_untracked(did, cx.sess()) {\n-        LoadedMacro::MacroDef(macro_def) => macro_def,\n-        // FIXME(jseyfried): document proc macro re-exports\n-        LoadedMacro::ProcMacro(..) => return None,\n-    };\n-\n-    let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.node {\n-        let tts: Vec<_> = def.stream().into_trees().collect();\n-        tts.chunks(4).map(|arm| arm[0].span()).collect()\n-    } else {\n-        unreachable!()\n-    };\n-\n-    let source = format!(\"macro_rules! {} {{\\n{}}}\",\n-                         name.clean(cx),\n-                         matchers.iter().map(|span| {\n-                             format!(\"    {} => {{ ... }};\\n\", span.to_src(cx))\n-                         }).collect::<String>());\n+    match cx.cstore.load_macro_untracked(did, cx.sess()) {\n+        LoadedMacro::MacroDef(def) => {\n+            let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.node {\n+                let tts: Vec<_> = def.stream().into_trees().collect();\n+                tts.chunks(4).map(|arm| arm[0].span()).collect()\n+            } else {\n+                unreachable!()\n+            };\n+\n+            let source = format!(\"macro_rules! {} {{\\n{}}}\",\n+                                 name.clean(cx),\n+                                 matchers.iter().map(|span| {\n+                                     format!(\"    {} => {{ ... }};\\n\", span.to_src(cx))\n+                                 }).collect::<String>());\n+\n+            clean::MacroItem(clean::Macro {\n+                source,\n+                imported_from: Some(imported_from).clean(cx),\n+            })\n+        }\n+        LoadedMacro::ProcMacro(ext) => {\n+            let helpers = match &*ext {\n+                &SyntaxExtension::ProcMacroDerive(_, ref syms, ..) => { syms.clean(cx) }\n+                _ => Vec::new(),\n+            };\n+\n+            clean::ProcMacroItem(clean::ProcMacro {\n+                kind: ext.kind(),\n+                helpers,\n+            })\n+        }\n+    }\n \n-    Some(clean::Macro {\n-        source,\n-        imported_from: Some(imported_from).clean(cx),\n-    })\n }\n \n /// A trait's generics clause actually contains all of the predicates for all of"}, {"sha": "a91f2fd7474f5b7b28e1136bcd9c0521d404d83a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -21,6 +21,7 @@ pub use self::Visibility::{Public, Inherited};\n use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, AttrStyle, Ident};\n use syntax::attr;\n+use syntax::ext::base::MacroKind;\n use syntax::source_map::{dummy_spanned, Spanned};\n use syntax::ptr::P;\n use syntax::symbol::keywords::{self, Keyword};\n@@ -527,6 +528,7 @@ pub enum ItemEnum {\n     /// `type`s from an extern block\n     ForeignTypeItem,\n     MacroItem(Macro),\n+    ProcMacroItem(ProcMacro),\n     PrimitiveItem(PrimitiveType),\n     AssociatedConstItem(Type, Option<String>),\n     AssociatedTypeItem(Vec<GenericBound>, Option<Type>),\n@@ -588,6 +590,7 @@ impl Clean<Item> for doctree::Module {\n         items.extend(self.traits.iter().map(|x| x.clean(cx)));\n         items.extend(self.impls.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n+        items.extend(self.proc_macros.iter().map(|x| x.clean(cx)));\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n@@ -2191,6 +2194,8 @@ pub enum TypeKind {\n     Typedef,\n     Foreign,\n     Macro,\n+    Attr,\n+    Derive,\n }\n \n pub trait GetDefId {\n@@ -3727,7 +3732,12 @@ pub fn register_def(cx: &DocContext, def: Def) -> DefId {\n         Def::Static(i, _) => (i, TypeKind::Static),\n         Def::Variant(i) => (cx.tcx.parent_def_id(i).expect(\"cannot get parent def id\"),\n                             TypeKind::Enum),\n-        Def::Macro(i, _) => (i, TypeKind::Macro),\n+        Def::Macro(i, mac_kind) => match mac_kind {\n+            MacroKind::Bang => (i, TypeKind::Macro),\n+            MacroKind::Attr => (i, TypeKind::Attr),\n+            MacroKind::Derive => (i, TypeKind::Derive),\n+            MacroKind::ProcMacroStub => unreachable!(),\n+        },\n         Def::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n         Def::SelfTy(_, Some(impl_def_id)) => {\n             return impl_def_id\n@@ -3782,6 +3792,30 @@ impl Clean<Item> for doctree::Macro {\n     }\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub struct ProcMacro {\n+    pub kind: MacroKind,\n+    pub helpers: Vec<String>,\n+}\n+\n+impl Clean<Item> for doctree::ProcMacro {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            visibility: Some(Public),\n+            stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n+            inner: ProcMacroItem(ProcMacro {\n+                kind: self.kind,\n+                helpers: self.helpers.clean(cx),\n+            }),\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Stability {\n     pub level: stability::StabilityLevel,"}, {"sha": "4a6a4ee09ea1a0276af9ad19b6e9c924c221edf0", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -15,6 +15,7 @@ pub use self::StructType::*;\n use syntax::ast;\n use syntax::ast::{Name, NodeId};\n use syntax::attr;\n+use syntax::ext::base::MacroKind;\n use syntax::ptr::P;\n use syntax::source_map::Spanned;\n use syntax_pos::{self, Span};\n@@ -46,6 +47,7 @@ pub struct Module {\n     pub impls: Vec<Impl>,\n     pub foreigns: Vec<hir::ForeignMod>,\n     pub macros: Vec<Macro>,\n+    pub proc_macros: Vec<ProcMacro>,\n     pub is_crate: bool,\n }\n \n@@ -75,6 +77,7 @@ impl Module {\n             impls      : Vec::new(),\n             foreigns   : Vec::new(),\n             macros     : Vec::new(),\n+            proc_macros: Vec::new(),\n             is_crate   : false,\n         }\n     }\n@@ -264,6 +267,17 @@ pub struct Import {\n     pub whence: Span,\n }\n \n+pub struct ProcMacro {\n+    pub name: Name,\n+    pub id: NodeId,\n+    pub kind: MacroKind,\n+    pub helpers: Vec<Name>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub whence: Span,\n+    pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n+}\n+\n pub fn struct_type_from_def(vdata: &hir::VariantData) -> StructType {\n     match *vdata {\n         hir::VariantData::Struct(..) => Plain,"}, {"sha": "acb8f6a66dfcb42ff3d87c4fdb52ca4186dfac0d", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -11,6 +11,7 @@\n //! Item types.\n \n use std::fmt;\n+use syntax::ext::base::MacroKind;\n use clean;\n \n /// Item type. Corresponds to `clean::ItemEnum` variants.\n@@ -19,6 +20,11 @@ use clean;\n /// discriminants. JavaScript then is used to decode them into the original value.\n /// Consequently, every change to this type should be synchronized to\n /// the `itemTypes` mapping table in `static/main.js`.\n+///\n+/// In addition, code in `html::render` uses this enum to generate CSS classes, page prefixes, and\n+/// module headings. If you are adding to this enum and want to ensure that the sidebar also prints\n+/// a heading, edit the listing in `html/render.rs`, function `sidebar_module`. This uses an\n+/// ordering based on a helper function inside `item_module`, in the same file.\n #[derive(Copy, PartialEq, Clone, Debug)]\n pub enum ItemType {\n     Module          = 0,\n@@ -44,6 +50,8 @@ pub enum ItemType {\n     ForeignType     = 20,\n     Keyword         = 21,\n     Existential     = 22,\n+    ProcAttribute   = 23,\n+    ProcDerive      = 24,\n }\n \n \n@@ -88,6 +96,12 @@ impl<'a> From<&'a clean::Item> for ItemType {\n             clean::AssociatedTypeItem(..)  => ItemType::AssociatedType,\n             clean::ForeignTypeItem         => ItemType::ForeignType,\n             clean::KeywordItem(..)         => ItemType::Keyword,\n+            clean::ProcMacroItem(ref mac)  => match mac.kind {\n+                MacroKind::Bang            => ItemType::Macro,\n+                MacroKind::Attr            => ItemType::ProcAttribute,\n+                MacroKind::Derive          => ItemType::ProcDerive,\n+                MacroKind::ProcMacroStub   => unreachable!(),\n+            }\n             clean::StrippedItem(..)        => unreachable!(),\n         }\n     }\n@@ -107,7 +121,9 @@ impl From<clean::TypeKind> for ItemType {\n             clean::TypeKind::Variant  => ItemType::Variant,\n             clean::TypeKind::Typedef  => ItemType::Typedef,\n             clean::TypeKind::Foreign  => ItemType::ForeignType,\n-            clean::TypeKind::Macro  => ItemType::Macro,\n+            clean::TypeKind::Macro    => ItemType::Macro,\n+            clean::TypeKind::Attr     => ItemType::ProcAttribute,\n+            clean::TypeKind::Derive   => ItemType::ProcDerive,\n         }\n     }\n }\n@@ -138,6 +154,8 @@ impl ItemType {\n             ItemType::ForeignType     => \"foreigntype\",\n             ItemType::Keyword         => \"keyword\",\n             ItemType::Existential     => \"existential\",\n+            ItemType::ProcAttribute   => \"attr\",\n+            ItemType::ProcDerive      => \"derive\",\n         }\n     }\n \n@@ -166,7 +184,9 @@ impl ItemType {\n             ItemType::Constant |\n             ItemType::AssociatedConst => NameSpace::Value,\n \n-            ItemType::Macro => NameSpace::Macro,\n+            ItemType::Macro |\n+            ItemType::ProcAttribute |\n+            ItemType::ProcDerive => NameSpace::Macro,\n \n             ItemType::Keyword => NameSpace::Keyword,\n         }"}, {"sha": "1c61e73fae03cdd0f8346bee6244c05bfd517256", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -56,6 +56,7 @@ use externalfiles::ExternalHtml;\n \n use serialize::json::{ToJson, Json, as_json};\n use syntax::ast;\n+use syntax::ext::base::MacroKind;\n use syntax::source_map::FileName;\n use syntax::feature_gate::UnstableFeatures;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n@@ -1595,6 +1596,8 @@ struct AllTypes {\n     statics: FxHashSet<ItemEntry>,\n     constants: FxHashSet<ItemEntry>,\n     keywords: FxHashSet<ItemEntry>,\n+    attributes: FxHashSet<ItemEntry>,\n+    derives: FxHashSet<ItemEntry>,\n }\n \n impl AllTypes {\n@@ -1613,6 +1616,8 @@ impl AllTypes {\n             statics: new_set(100),\n             constants: new_set(100),\n             keywords: new_set(100),\n+            attributes: new_set(100),\n+            derives: new_set(100),\n         }\n     }\n \n@@ -1634,6 +1639,8 @@ impl AllTypes {\n                 ItemType::Existential => self.existentials.insert(ItemEntry::new(new_url, name)),\n                 ItemType::Static => self.statics.insert(ItemEntry::new(new_url, name)),\n                 ItemType::Constant => self.constants.insert(ItemEntry::new(new_url, name)),\n+                ItemType::ProcAttribute => self.attributes.insert(ItemEntry::new(new_url, name)),\n+                ItemType::ProcDerive => self.derives.insert(ItemEntry::new(new_url, name)),\n                 _ => true,\n             };\n         }\n@@ -1673,6 +1680,8 @@ impl fmt::Display for AllTypes {\n         print_entries(f, &self.primitives, \"Primitives\", \"primitives\")?;\n         print_entries(f, &self.traits, \"Traits\", \"traits\")?;\n         print_entries(f, &self.macros, \"Macros\", \"macros\")?;\n+        print_entries(f, &self.attributes, \"Attribute Macros\", \"attributes\")?;\n+        print_entries(f, &self.derives, \"Derive Macros\", \"derives\")?;\n         print_entries(f, &self.functions, \"Functions\", \"functions\")?;\n         print_entries(f, &self.typedefs, \"Typedefs\", \"typedefs\")?;\n         print_entries(f, &self.existentials, \"Existentials\", \"existentials\")?;\n@@ -2155,6 +2164,12 @@ impl<'a> fmt::Display for Item<'a> {\n             clean::EnumItem(..) => write!(fmt, \"Enum \")?,\n             clean::TypedefItem(..) => write!(fmt, \"Type Definition \")?,\n             clean::MacroItem(..) => write!(fmt, \"Macro \")?,\n+            clean::ProcMacroItem(ref mac) => match mac.kind {\n+                MacroKind::Bang => write!(fmt, \"Macro \")?,\n+                MacroKind::Attr => write!(fmt, \"Attribute Macro \")?,\n+                MacroKind::Derive => write!(fmt, \"Derive Macro \")?,\n+                MacroKind::ProcMacroStub => unreachable!(),\n+            }\n             clean::PrimitiveItem(..) => write!(fmt, \"Primitive Type \")?,\n             clean::StaticItem(..) | clean::ForeignStaticItem(..) => write!(fmt, \"Static \")?,\n             clean::ConstantItem(..) => write!(fmt, \"Constant \")?,\n@@ -2191,6 +2206,7 @@ impl<'a> fmt::Display for Item<'a> {\n             clean::EnumItem(ref e) => item_enum(fmt, self.cx, self.item, e),\n             clean::TypedefItem(ref t, _) => item_typedef(fmt, self.cx, self.item, t),\n             clean::MacroItem(ref m) => item_macro(fmt, self.cx, self.item, m),\n+            clean::ProcMacroItem(ref m) => item_proc_macro(fmt, self.cx, self.item, m),\n             clean::PrimitiveItem(ref p) => item_primitive(fmt, self.cx, self.item, p),\n             clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) =>\n                 item_static(fmt, self.cx, self.item, i),\n@@ -4079,11 +4095,12 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                 write!(fmt,\n                        \"<div class='block version'>\\\n                         <p>Version {}</p>\\\n-                        </div>\n-                        <a id='all-types' href='all.html'><p>See all {}'s items</p></a>\",\n-                       version,\n-                       it.name.as_ref().unwrap())?;\n+                        </div>\",\n+                       version)?;\n             }\n+\n+            write!(fmt, \"<a id='all-types' href='all.html'><p>See all {}'s items</p></a>\",\n+                   it.name.as_ref().expect(\"crates always have a name\"))?;\n         }\n \n         write!(fmt, \"<div class=\\\"sidebar-elems\\\">\")?;\n@@ -4523,6 +4540,8 @@ fn item_ty_to_strs(ty: &ItemType) -> (&'static str, &'static str) {\n         ItemType::ForeignType     => (\"foreign-types\", \"Foreign Types\"),\n         ItemType::Keyword         => (\"keywords\", \"Keywords\"),\n         ItemType::Existential     => (\"existentials\", \"Existentials\"),\n+        ItemType::ProcAttribute   => (\"attributes\", \"Attribute Macros\"),\n+        ItemType::ProcDerive      => (\"derives\", \"Derive Macros\"),\n     }\n }\n \n@@ -4598,6 +4617,39 @@ fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)\n }\n \n+fn item_proc_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item, m: &clean::ProcMacro)\n+    -> fmt::Result\n+{\n+    let name = it.name.as_ref().expect(\"proc-macros always have names\");\n+    match m.kind {\n+        MacroKind::Bang => {\n+            write!(w, \"<pre class='rust macro'>\")?;\n+            write!(w, \"{}!() {{ /* proc-macro */ }}\", name)?;\n+            write!(w, \"</pre>\")?;\n+        }\n+        MacroKind::Attr => {\n+            write!(w, \"<pre class='rust attr'>\")?;\n+            write!(w, \"#[{}]\", name)?;\n+            write!(w, \"</pre>\")?;\n+        }\n+        MacroKind::Derive => {\n+            write!(w, \"<pre class='rust derive'>\")?;\n+            write!(w, \"#[derive({})]\", name)?;\n+            if !m.helpers.is_empty() {\n+                writeln!(w, \"\\n{{\")?;\n+                writeln!(w, \"    // Attributes available to this derive:\")?;\n+                for attr in &m.helpers {\n+                    writeln!(w, \"    #[{}]\", attr)?;\n+                }\n+                write!(w, \"}}\")?;\n+            }\n+            write!(w, \"</pre>\")?;\n+        }\n+        _ => {}\n+    }\n+    document(w, cx, it)\n+}\n+\n fn item_primitive(w: &mut fmt::Formatter, cx: &Context,\n                   it: &clean::Item,\n                   _p: &clean::PrimitiveType) -> fmt::Result {"}, {"sha": "6307dda454da892b261ed71c8d2d40e908956df3", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -39,7 +39,10 @@\n                      \"associatedconstant\",\n                      \"union\",\n                      \"foreigntype\",\n-                     \"keyword\"];\n+                     \"keyword\",\n+                     \"existential\",\n+                     \"attr\",\n+                     \"derive\"];\n \n     var search_input = document.getElementsByClassName('search-input')[0];\n "}, {"sha": "34a1d71beecfcdf863f5fdc29b89549b9c7fadaf", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -124,6 +124,8 @@ pre {\n .content .highlighted.tymethod { background-color: #4950ed; }\n .content .highlighted.type { background-color: #38902c; }\n .content .highlighted.foreigntype { background-color: #b200d6; }\n+.content .highlighted.attr,\n+.content .highlighted.derive,\n .content .highlighted.macro { background-color: #217d1c; }\n .content .highlighted.constant,\n .content .highlighted.static { background-color: #0063cc; }\n@@ -134,6 +136,8 @@ pre {\n .content span.struct, .content a.struct, .block a.current.struct { color: #2dbfb8; }\n .content span.type, .content a.type, .block a.current.type { color: #ff7f00; }\n .content span.foreigntype, .content a.foreigntype, .block a.current.foreigntype { color: #dd7de8; }\n+.content span.attr, .content a.attr, .block a.current.attr,\n+.content span.derive, .content a.derive, .block a.current.derive,\n .content span.macro, .content a.macro, .block a.current.macro { color: #09bd00; }\n .content span.union, .content a.union, .block a.current.union { color: #a6ae37; }\n .content span.constant, .content a.constant, .block a.current.constant,"}, {"sha": "8218b1b371ea72fcba87a0e3fb2205ef90c34355", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -124,6 +124,8 @@ pre {\n .content .highlighted.tymethod { background-color: #c6afb3; }\n .content .highlighted.type { background-color: #ffc891; }\n .content .highlighted.foreigntype { background-color: #f5c4ff; }\n+.content .highlighted.attr,\n+.content .highlighted.derive,\n .content .highlighted.macro { background-color: #8ce488; }\n .content .highlighted.constant,\n .content .highlighted.static { background-color: #c3e0ff; }\n@@ -134,6 +136,8 @@ pre {\n .content span.struct, .content a.struct, .block a.current.struct { color: #ad448e; }\n .content span.type, .content a.type, .block a.current.type { color: #ba5d00; }\n .content span.foreigntype, .content a.foreigntype, .block a.current.foreigntype { color: #cd00e2; }\n+.content span.attr, .content a.attr, .block a.current.attr,\n+.content span.derive, .content a.derive, .block a.current.derive,\n .content span.macro, .content a.macro, .block a.current.macro { color: #068000; }\n .content span.union, .content a.union, .block a.current.union { color: #767b27; }\n .content span.constant, .content a.constant, .block a.current.constant,"}, {"sha": "d00eb3257d43c6a5aacb537390c24361fcceb10d", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -249,6 +249,9 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             // tymethods/macros have no control over privacy\n             clean::MacroItem(..) | clean::TyMethodItem(..) => {}\n \n+            // Proc-macros are always public\n+            clean::ProcMacroItem(..) => {}\n+\n             // Primitives are never stripped\n             clean::PrimitiveItem(..) => {}\n "}, {"sha": "92d8dbed0718a5a1ecefde7e31024384de4b5188", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 67, "deletions": 15, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -15,6 +15,7 @@ use std::mem;\n \n use syntax::ast;\n use syntax::attr;\n+use syntax::ext::base::MacroKind;\n use syntax::source_map::Spanned;\n use syntax_pos::{self, Span};\n \n@@ -168,24 +169,75 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         }\n     }\n \n-    pub fn visit_fn(&mut self, item: &hir::Item,\n+    pub fn visit_fn(&mut self, om: &mut Module, item: &hir::Item,\n                     name: ast::Name, fd: &hir::FnDecl,\n                     header: hir::FnHeader,\n                     gen: &hir::Generics,\n-                    body: hir::BodyId) -> Function {\n+                    body: hir::BodyId) {\n         debug!(\"Visiting fn\");\n-        Function {\n-            id: item.id,\n-            vis: item.vis.clone(),\n-            stab: self.stability(item.id),\n-            depr: self.deprecation(item.id),\n-            attrs: item.attrs.clone(),\n-            decl: fd.clone(),\n-            name,\n-            whence: item.span,\n-            generics: gen.clone(),\n-            header,\n-            body,\n+        let macro_kind = item.attrs.iter().filter_map(|a| {\n+            if a.check_name(\"proc_macro\") {\n+                Some(MacroKind::Bang)\n+            } else if a.check_name(\"proc_macro_derive\") {\n+                Some(MacroKind::Derive)\n+            } else if a.check_name(\"proc_macro_attribute\") {\n+                Some(MacroKind::Attr)\n+            } else {\n+                None\n+            }\n+        }).next();\n+        match macro_kind {\n+            Some(kind) => {\n+                let name = if kind == MacroKind::Derive {\n+                    item.attrs.lists(\"proc_macro_derive\")\n+                              .filter_map(|mi| mi.name())\n+                              .next()\n+                              .expect(\"proc-macro derives require a name\")\n+                } else {\n+                    name\n+                };\n+\n+                let mut helpers = Vec::new();\n+                for mi in item.attrs.lists(\"proc_macro_derive\") {\n+                    if !mi.check_name(\"attributes\") {\n+                        continue;\n+                    }\n+\n+                    if let Some(list) = mi.meta_item_list() {\n+                        for inner_mi in list {\n+                            if let Some(name) = inner_mi.name() {\n+                                helpers.push(name);\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                om.proc_macros.push(ProcMacro {\n+                    name,\n+                    id: item.id,\n+                    kind,\n+                    helpers,\n+                    attrs: item.attrs.clone(),\n+                    whence: item.span,\n+                    stab: self.stability(item.id),\n+                    depr: self.deprecation(item.id),\n+                });\n+            }\n+            None => {\n+                om.fns.push(Function {\n+                    id: item.id,\n+                    vis: item.vis.clone(),\n+                    stab: self.stability(item.id),\n+                    depr: self.deprecation(item.id),\n+                    attrs: item.attrs.clone(),\n+                    decl: fd.clone(),\n+                    name,\n+                    whence: item.span,\n+                    generics: gen.clone(),\n+                    header,\n+                    body,\n+                });\n+            }\n         }\n     }\n \n@@ -425,7 +477,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n             hir::ItemKind::Union(ref sd, ref gen) =>\n                 om.unions.push(self.visit_union_data(item, name, sd, gen)),\n             hir::ItemKind::Fn(ref fd, header, ref gen, body) =>\n-                om.fns.push(self.visit_fn(item, name, &**fd, header, gen, body)),\n+                self.visit_fn(om, item, name, &**fd, header, gen, body),\n             hir::ItemKind::Ty(ref ty, ref gen) => {\n                 let t = Typedef {\n                     ty: ty.clone(),"}, {"sha": "e263db24fc2c80cf9b429c2d4e150e6952bbc3f1", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -1204,8 +1204,8 @@ pub trait Write {\n pub trait Seek {\n     /// Seek to an offset, in bytes, in a stream.\n     ///\n-    /// A seek beyond the end of a stream is allowed, but implementation\n-    /// defined.\n+    /// A seek beyond the end of a stream is allowed, but behavior is defined\n+    /// by the implementation.\n     ///\n     /// If the seek operation completed successfully,\n     /// this method returns the new position from the start of the stream."}, {"sha": "f79c986cc89e454603eb3aa283a45d97c09461f4", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -517,6 +517,7 @@ pub fn update_count_then_panic(msg: Box<dyn Any + Send>) -> ! {\n }\n \n /// A private no-mangle function on which to slap yer breakpoints.\n+#[inline(never)]\n #[no_mangle]\n #[allow(private_no_mangle_fns)] // yes we get it, but we like breakpoints\n pub fn rust_panic(mut msg: &mut dyn BoxMeUp) -> ! {"}, {"sha": "6aac070c45bd9d777c18867e49a500fd28efd9b3", "filename": "src/test/rustdoc/inline_cross/auxiliary/proc_macro.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fproc_macro.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type=\"proc-macro\"]\n+#![crate_name=\"some_macros\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+/// a proc-macro that swallows its input and does nothing.\n+#[proc_macro]\n+pub fn some_proc_macro(_input: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}\n+\n+/// a proc-macro attribute that passes its item through verbatim.\n+#[proc_macro_attribute]\n+pub fn some_proc_attr(_attr: TokenStream, item: TokenStream) -> TokenStream {\n+    item\n+}\n+\n+/// a derive attribute that adds nothing to its input.\n+#[proc_macro_derive(SomeDerive)]\n+pub fn some_derive(_item: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}\n+"}, {"sha": "a879258f82aee8a58ac7d254d2b7da99f2b6b687", "filename": "src/test/rustdoc/inline_cross/proc_macro.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Ftest%2Frustdoc%2Finline_cross%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Ftest%2Frustdoc%2Finline_cross%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fproc_macro.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage1\n+// aux-build:proc_macro.rs\n+// build-aux-docs\n+\n+// FIXME: if/when proc-macros start exporting their doc attributes across crates, we can turn on\n+// cross-crate inlining for them\n+\n+extern crate some_macros;\n+\n+// @has proc_macro/index.html\n+// @has - '//a/@href' '../some_macros/macro.some_proc_macro.html'\n+// @has - '//a/@href' '../some_macros/attr.some_proc_attr.html'\n+// @has - '//a/@href' '../some_macros/derive.SomeDerive.html'\n+// @!has proc_macro/macro.some_proc_macro.html\n+// @!has proc_macro/attr.some_proc_attr.html\n+// @!has proc_macro/derive.SomeDerive.html\n+pub use some_macros::{some_proc_macro, some_proc_attr, SomeDerive};"}, {"sha": "bfd194701c85db8714742757102117ea51984446", "filename": "src/test/rustdoc/proc-macro.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Ftest%2Frustdoc%2Fproc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Ftest%2Frustdoc%2Fproc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fproc-macro.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage1\n+\n+#![crate_type=\"proc-macro\"]\n+#![crate_name=\"some_macros\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+// @has some_macros/index.html\n+// @has - '//h2' 'Macros'\n+// @has - '//h2' 'Attribute Macros'\n+// @has - '//h2' 'Derive Macros'\n+// @!has - '//h2' 'Functions'\n+\n+// @has some_macros/all.html\n+// @has - '//a[@href=\"macro.some_proc_macro.html\"]' 'some_proc_macro'\n+// @has - '//a[@href=\"attr.some_proc_attr.html\"]' 'some_proc_attr'\n+// @has - '//a[@href=\"derive.SomeDerive.html\"]' 'SomeDerive'\n+// @!has - '//a/@href' 'fn.some_proc_macro.html'\n+// @!has - '//a/@href' 'fn.some_proc_attr.html'\n+// @!has - '//a/@href' 'fn.some_derive.html'\n+\n+// @has some_macros/index.html '//a/@href' 'macro.some_proc_macro.html'\n+// @!has - '//a/@href' 'fn.some_proc_macro.html'\n+// @has some_macros/macro.some_proc_macro.html\n+// @!has some_macros/fn.some_proc_macro.html\n+/// a proc-macro that swallows its input and does nothing.\n+#[proc_macro]\n+pub fn some_proc_macro(_input: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}\n+\n+// @has some_macros/index.html '//a/@href' 'attr.some_proc_attr.html'\n+// @!has - '//a/@href' 'fn.some_proc_attr.html'\n+// @has some_macros/attr.some_proc_attr.html\n+// @!has some_macros/fn.some_proc_attr.html\n+/// a proc-macro attribute that passes its item through verbatim.\n+#[proc_macro_attribute]\n+pub fn some_proc_attr(_attr: TokenStream, item: TokenStream) -> TokenStream {\n+    item\n+}\n+\n+// @has some_macros/index.html '//a/@href' 'derive.SomeDerive.html'\n+// @!has - '//a/@href' 'fn.some_derive.html'\n+// @has some_macros/derive.SomeDerive.html\n+// @!has some_macros/fn.some_derive.html\n+/// a derive attribute that adds nothing to its input.\n+#[proc_macro_derive(SomeDerive)]\n+pub fn some_derive(_item: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}"}, {"sha": "ab04953f3e50c1f6943d8e3b656e886b490a362f", "filename": "src/test/ui/feature-gates/feature-gate-self_in_typedefs.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self_in_typedefs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self_in_typedefs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self_in_typedefs.stderr?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -3,6 +3,8 @@ error[E0411]: cannot find type `Self` in this scope\n    |\n LL |     Cons(T, &'a Self)\n    |                 ^^^^ `Self` is only available in traits and impls\n+   |\n+   = help: add #![feature(self_in_typedefs)] to the crate attributes to enable\n \n error: aborting due to previous error\n "}, {"sha": "2851af4891e5a0c776c9f691f3044f3e91afab16", "filename": "src/test/ui/inference/inference_unstable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Ftest%2Fui%2Finference%2Finference_unstable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Ftest%2Fui%2Finference%2Finference_unstable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Finference_unstable.stderr?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -8,5 +8,5 @@ LL |     assert_eq!('x'.ipu_flatten(), 1);\n    = warning: once this method is added to the standard library, the ambiguity may cause an error or change in behavior!\n    = note: for more information, see issue #48919 <https://github.com/rust-lang/rust/issues/48919>\n    = help: call with fully qualified syntax `inference_unstable_itertools::IpuItertools::ipu_flatten(...)` to keep using the current method\n-   = note: add #![feature(ipu_flatten)] to the crate attributes to enable `inference_unstable_iterator::IpuIterator::ipu_flatten`\n+   = help: add #![feature(ipu_flatten)] to the crate attributes to enable `inference_unstable_iterator::IpuIterator::ipu_flatten`\n "}, {"sha": "2fa459bec9455d930b8f5d3176078fba774e2d1c", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -278,7 +278,10 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         }\n     }\n \n-    let (gdb, gdb_version, gdb_native_rust) = analyze_gdb(matches.opt_str(\"gdb\"));\n+    let target = opt_str2(matches.opt_str(\"target\"));\n+    let android_cross_path = opt_path(matches, \"android-cross-path\");\n+    let (gdb, gdb_version, gdb_native_rust) = analyze_gdb(matches.opt_str(\"gdb\"), &target,\n+                                                          &android_cross_path);\n \n     let color = match matches.opt_str(\"color\").as_ref().map(|x| &**x) {\n         Some(\"auto\") | None => ColorConfig::AutoColor,\n@@ -318,15 +321,15 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         runtool: matches.opt_str(\"runtool\"),\n         host_rustcflags: matches.opt_str(\"host-rustcflags\"),\n         target_rustcflags: matches.opt_str(\"target-rustcflags\"),\n-        target: opt_str2(matches.opt_str(\"target\")),\n+        target: target,\n         host: opt_str2(matches.opt_str(\"host\")),\n         gdb,\n         gdb_version,\n         gdb_native_rust,\n         lldb_version: extract_lldb_version(matches.opt_str(\"lldb-version\")),\n         llvm_version: matches.opt_str(\"llvm-version\"),\n         system_llvm: matches.opt_present(\"system-llvm\"),\n-        android_cross_path: opt_path(matches, \"android-cross-path\"),\n+        android_cross_path: android_cross_path,\n         adb_path: opt_str2(matches.opt_str(\"adb-path\")),\n         adb_test_dir: opt_str2(matches.opt_str(\"adb-test-dir\")),\n         adb_device_status: opt_str2(matches.opt_str(\"target\")).contains(\"android\")\n@@ -780,23 +783,46 @@ fn make_test_closure(\n     }))\n }\n \n+/// Returns true if the given target is an Android target for the\n+/// purposes of GDB testing.\n+fn is_android_gdb_target(target: &String) -> bool {\n+    match &target[..] {\n+        \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\" => true,\n+        _ => false,\n+    }\n+}\n+\n /// Returns (Path to GDB, GDB Version, GDB has Rust Support)\n-fn analyze_gdb(gdb: Option<String>) -> (Option<String>, Option<u32>, bool) {\n+fn analyze_gdb(gdb: Option<String>, target: &String, android_cross_path: &PathBuf)\n+               -> (Option<String>, Option<u32>, bool) {\n     #[cfg(not(windows))]\n     const GDB_FALLBACK: &str = \"gdb\";\n     #[cfg(windows)]\n     const GDB_FALLBACK: &str = \"gdb.exe\";\n \n     const MIN_GDB_WITH_RUST: u32 = 7011010;\n \n+    let fallback_gdb = || {\n+        if is_android_gdb_target(target) {\n+            let mut gdb_path = match android_cross_path.to_str() {\n+                Some(x) => x.to_owned(),\n+                None => panic!(\"cannot find android cross path\"),\n+            };\n+            gdb_path.push_str(\"/bin/gdb\");\n+            gdb_path\n+        } else {\n+            GDB_FALLBACK.to_owned()\n+        }\n+    };\n+\n     let gdb = match gdb {\n-        None => GDB_FALLBACK,\n-        Some(ref s) if s.is_empty() => GDB_FALLBACK, // may be empty if configure found no gdb\n-        Some(ref s) => s,\n+        None => fallback_gdb(),\n+        Some(ref s) if s.is_empty() => fallback_gdb(), // may be empty if configure found no gdb\n+        Some(ref s) => s.to_owned(),\n     };\n \n     let mut version_line = None;\n-    if let Ok(output) = Command::new(gdb).arg(\"--version\").output() {\n+    if let Ok(output) = Command::new(&gdb).arg(\"--version\").output() {\n         if let Some(first_line) = String::from_utf8_lossy(&output.stdout).lines().next() {\n             version_line = Some(first_line.to_string());\n         }\n@@ -809,7 +835,7 @@ fn analyze_gdb(gdb: Option<String>) -> (Option<String>, Option<u32>, bool) {\n \n     let gdb_native_rust = version.map_or(false, |v| v >= MIN_GDB_WITH_RUST);\n \n-    (Some(gdb.to_owned()), version, gdb_native_rust)\n+    (Some(gdb), version, gdb_native_rust)\n }\n \n fn extract_gdb_version(full_version_line: &str) -> Option<u32> {"}, {"sha": "63a282c227c246b764ccb46abaaaceb747993fe2", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 203, "deletions": 194, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9653f790333d1270f36f1614e85d8a7b54193e75/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=9653f790333d1270f36f1614e85d8a7b54193e75", "patch": "@@ -38,6 +38,7 @@ use std::process::{Child, Command, ExitStatus, Output, Stdio};\n use std::str;\n \n use extract_gdb_version;\n+use is_android_gdb_target;\n \n #[cfg(windows)]\n fn disable_error_reporting<F: FnOnce() -> R, R>(f: F) -> R {\n@@ -224,6 +225,19 @@ pub fn run(config: Config, testpaths: &TestPaths, revision: Option<&str>) {\n pub fn compute_stamp_hash(config: &Config) -> String {\n     let mut hash = DefaultHasher::new();\n     config.stage_id.hash(&mut hash);\n+    match config.mode {\n+        DebugInfoGdb => match config.gdb {\n+            None => env::var_os(\"PATH\").hash(&mut hash),\n+            Some(ref s) if s.is_empty() => env::var_os(\"PATH\").hash(&mut hash),\n+            Some(ref s) => s.hash(&mut hash),\n+        },\n+        DebugInfoLldb => {\n+            env::var_os(\"PATH\").hash(&mut hash);\n+            env::var_os(\"PYTHONPATH\").hash(&mut hash);\n+        },\n+\n+        _ => {},\n+    };\n     format!(\"{:x}\", hash.finish())\n }\n \n@@ -666,222 +680,217 @@ impl<'test> TestCx<'test> {\n         let exe_file = self.make_exe_name();\n \n         let debugger_run_result;\n-        match &*self.config.target {\n-            \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\" => {\n-                cmds = cmds.replace(\"run\", \"continue\");\n+        if is_android_gdb_target(&self.config.target) {\n+            cmds = cmds.replace(\"run\", \"continue\");\n \n-                let tool_path = match self.config.android_cross_path.to_str() {\n-                    Some(x) => x.to_owned(),\n-                    None => self.fatal(\"cannot find android cross path\"),\n-                };\n+            let tool_path = match self.config.android_cross_path.to_str() {\n+                Some(x) => x.to_owned(),\n+                None => self.fatal(\"cannot find android cross path\"),\n+            };\n \n-                // write debugger script\n-                let mut script_str = String::with_capacity(2048);\n-                script_str.push_str(&format!(\"set charset {}\\n\", Self::charset()));\n-                script_str.push_str(&format!(\"set sysroot {}\\n\", tool_path));\n-                script_str.push_str(&format!(\"file {}\\n\", exe_file.to_str().unwrap()));\n-                script_str.push_str(\"target remote :5039\\n\");\n-                script_str.push_str(&format!(\n-                    \"set solib-search-path \\\n-                     ./{}/stage2/lib/rustlib/{}/lib/\\n\",\n-                    self.config.host, self.config.target\n-                ));\n-                for line in &breakpoint_lines {\n-                    script_str.push_str(\n-                        &format!(\n-                            \"break {:?}:{}\\n\",\n-                            self.testpaths.file.file_name().unwrap().to_string_lossy(),\n-                            *line\n-                        )[..],\n-                    );\n-                }\n-                script_str.push_str(&cmds);\n-                script_str.push_str(\"\\nquit\\n\");\n-\n-                debug!(\"script_str = {}\", script_str);\n-                self.dump_output_file(&script_str, \"debugger.script\");\n-\n-                let adb_path = &self.config.adb_path;\n-\n-                Command::new(adb_path)\n-                    .arg(\"push\")\n-                    .arg(&exe_file)\n-                    .arg(&self.config.adb_test_dir)\n-                    .status()\n-                    .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n-\n-                Command::new(adb_path)\n-                    .args(&[\"forward\", \"tcp:5039\", \"tcp:5039\"])\n-                    .status()\n-                    .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n-\n-                let adb_arg = format!(\n-                    \"export LD_LIBRARY_PATH={}; \\\n-                     gdbserver{} :5039 {}/{}\",\n-                    self.config.adb_test_dir.clone(),\n-                    if self.config.target.contains(\"aarch64\") {\n-                        \"64\"\n-                    } else {\n-                        \"\"\n-                    },\n-                    self.config.adb_test_dir.clone(),\n-                    exe_file.file_name().unwrap().to_str().unwrap()\n+            // write debugger script\n+            let mut script_str = String::with_capacity(2048);\n+            script_str.push_str(&format!(\"set charset {}\\n\", Self::charset()));\n+            script_str.push_str(&format!(\"set sysroot {}\\n\", tool_path));\n+            script_str.push_str(&format!(\"file {}\\n\", exe_file.to_str().unwrap()));\n+            script_str.push_str(\"target remote :5039\\n\");\n+            script_str.push_str(&format!(\n+                \"set solib-search-path \\\n+                 ./{}/stage2/lib/rustlib/{}/lib/\\n\",\n+                self.config.host, self.config.target\n+            ));\n+            for line in &breakpoint_lines {\n+                script_str.push_str(\n+                    &format!(\n+                        \"break {:?}:{}\\n\",\n+                        self.testpaths.file.file_name().unwrap().to_string_lossy(),\n+                        *line\n+                    )[..],\n                 );\n+            }\n+            script_str.push_str(&cmds);\n+            script_str.push_str(\"\\nquit\\n\");\n \n-                debug!(\"adb arg: {}\", adb_arg);\n-                let mut adb = Command::new(adb_path)\n-                    .args(&[\"shell\", &adb_arg])\n-                    .stdout(Stdio::piped())\n-                    .stderr(Stdio::inherit())\n-                    .spawn()\n-                    .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n-\n-                // Wait for the gdbserver to print out \"Listening on port ...\"\n-                // at which point we know that it's started and then we can\n-                // execute the debugger below.\n-                let mut stdout = BufReader::new(adb.stdout.take().unwrap());\n-                let mut line = String::new();\n-                loop {\n-                    line.truncate(0);\n-                    stdout.read_line(&mut line).unwrap();\n-                    if line.starts_with(\"Listening on port 5039\") {\n-                        break;\n-                    }\n-                }\n-                drop(stdout);\n-\n-                let debugger_script = self.make_out_name(\"debugger.script\");\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                let debugger_opts = vec![\n-                    \"-quiet\".to_owned(),\n-                    \"-batch\".to_owned(),\n-                    \"-nx\".to_owned(),\n-                    format!(\"-command={}\", debugger_script.to_str().unwrap()),\n-                ];\n-\n-                let mut gdb_path = tool_path;\n-                gdb_path.push_str(\"/bin/gdb\");\n-                let Output {\n-                    status,\n-                    stdout,\n-                    stderr,\n-                } = Command::new(&gdb_path)\n-                    .args(&debugger_opts)\n-                    .output()\n-                    .expect(&format!(\"failed to exec `{:?}`\", gdb_path));\n-                let cmdline = {\n-                    let mut gdb = Command::new(&format!(\"{}-gdb\", self.config.target));\n-                    gdb.args(&debugger_opts);\n-                    let cmdline = self.make_cmdline(&gdb, \"\");\n-                    logv(self.config, format!(\"executing {}\", cmdline));\n-                    cmdline\n-                };\n+            debug!(\"script_str = {}\", script_str);\n+            self.dump_output_file(&script_str, \"debugger.script\");\n \n-                debugger_run_result = ProcRes {\n-                    status,\n-                    stdout: String::from_utf8(stdout).unwrap(),\n-                    stderr: String::from_utf8(stderr).unwrap(),\n-                    cmdline,\n-                };\n-                if adb.kill().is_err() {\n-                    println!(\"Adb process is already finished.\");\n+            let adb_path = &self.config.adb_path;\n+\n+            Command::new(adb_path)\n+                .arg(\"push\")\n+                .arg(&exe_file)\n+                .arg(&self.config.adb_test_dir)\n+                .status()\n+                .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n+\n+            Command::new(adb_path)\n+                .args(&[\"forward\", \"tcp:5039\", \"tcp:5039\"])\n+                .status()\n+                .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n+\n+            let adb_arg = format!(\n+                \"export LD_LIBRARY_PATH={}; \\\n+                 gdbserver{} :5039 {}/{}\",\n+                self.config.adb_test_dir.clone(),\n+                if self.config.target.contains(\"aarch64\") {\n+                    \"64\"\n+                } else {\n+                    \"\"\n+                },\n+                self.config.adb_test_dir.clone(),\n+                exe_file.file_name().unwrap().to_str().unwrap()\n+            );\n+\n+            debug!(\"adb arg: {}\", adb_arg);\n+            let mut adb = Command::new(adb_path)\n+                .args(&[\"shell\", &adb_arg])\n+                .stdout(Stdio::piped())\n+                .stderr(Stdio::inherit())\n+                .spawn()\n+                .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n+\n+            // Wait for the gdbserver to print out \"Listening on port ...\"\n+            // at which point we know that it's started and then we can\n+            // execute the debugger below.\n+            let mut stdout = BufReader::new(adb.stdout.take().unwrap());\n+            let mut line = String::new();\n+            loop {\n+                line.truncate(0);\n+                stdout.read_line(&mut line).unwrap();\n+                if line.starts_with(\"Listening on port 5039\") {\n+                    break;\n                 }\n             }\n+            drop(stdout);\n \n-            _ => {\n-                let rust_src_root = self\n-                    .config\n-                    .find_rust_src_root()\n-                    .expect(\"Could not find Rust source root\");\n-                let rust_pp_module_rel_path = Path::new(\"./src/etc\");\n-                let rust_pp_module_abs_path = rust_src_root\n-                    .join(rust_pp_module_rel_path)\n-                    .to_str()\n-                    .unwrap()\n-                    .to_owned();\n-                // write debugger script\n-                let mut script_str = String::with_capacity(2048);\n-                script_str.push_str(&format!(\"set charset {}\\n\", Self::charset()));\n-                script_str.push_str(\"show version\\n\");\n-\n-                match self.config.gdb_version {\n-                    Some(version) => {\n-                        println!(\n-                            \"NOTE: compiletest thinks it is using GDB version {}\",\n-                            version\n-                        );\n+            let debugger_script = self.make_out_name(\"debugger.script\");\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n+            let debugger_opts = vec![\n+                \"-quiet\".to_owned(),\n+                \"-batch\".to_owned(),\n+                \"-nx\".to_owned(),\n+                format!(\"-command={}\", debugger_script.to_str().unwrap()),\n+            ];\n \n-                        if version > extract_gdb_version(\"7.4\").unwrap() {\n-                            // Add the directory containing the pretty printers to\n-                            // GDB's script auto loading safe path\n-                            script_str.push_str(&format!(\n-                                \"add-auto-load-safe-path {}\\n\",\n-                                rust_pp_module_abs_path.replace(r\"\\\", r\"\\\\\")\n-                            ));\n-                        }\n-                    }\n-                    _ => {\n-                        println!(\n-                            \"NOTE: compiletest does not know which version of \\\n-                             GDB it is using\"\n-                        );\n+            let gdb_path = self.config.gdb.as_ref().unwrap();\n+            let Output {\n+                status,\n+                stdout,\n+                stderr,\n+            } = Command::new(&gdb_path)\n+                .args(&debugger_opts)\n+                .output()\n+                .expect(&format!(\"failed to exec `{:?}`\", gdb_path));\n+            let cmdline = {\n+                let mut gdb = Command::new(&format!(\"{}-gdb\", self.config.target));\n+                gdb.args(&debugger_opts);\n+                let cmdline = self.make_cmdline(&gdb, \"\");\n+                logv(self.config, format!(\"executing {}\", cmdline));\n+                cmdline\n+            };\n+\n+            debugger_run_result = ProcRes {\n+                status,\n+                stdout: String::from_utf8(stdout).unwrap(),\n+                stderr: String::from_utf8(stderr).unwrap(),\n+                cmdline,\n+            };\n+            if adb.kill().is_err() {\n+                println!(\"Adb process is already finished.\");\n+            }\n+        } else {\n+            let rust_src_root = self\n+                .config\n+                .find_rust_src_root()\n+                .expect(\"Could not find Rust source root\");\n+            let rust_pp_module_rel_path = Path::new(\"./src/etc\");\n+            let rust_pp_module_abs_path = rust_src_root\n+                .join(rust_pp_module_rel_path)\n+                .to_str()\n+                .unwrap()\n+                .to_owned();\n+            // write debugger script\n+            let mut script_str = String::with_capacity(2048);\n+            script_str.push_str(&format!(\"set charset {}\\n\", Self::charset()));\n+            script_str.push_str(\"show version\\n\");\n+\n+            match self.config.gdb_version {\n+                Some(version) => {\n+                    println!(\n+                        \"NOTE: compiletest thinks it is using GDB version {}\",\n+                        version\n+                    );\n+\n+                    if version > extract_gdb_version(\"7.4\").unwrap() {\n+                        // Add the directory containing the pretty printers to\n+                        // GDB's script auto loading safe path\n+                        script_str.push_str(&format!(\n+                            \"add-auto-load-safe-path {}\\n\",\n+                            rust_pp_module_abs_path.replace(r\"\\\", r\"\\\\\")\n+                        ));\n                     }\n                 }\n+                _ => {\n+                    println!(\n+                        \"NOTE: compiletest does not know which version of \\\n+                         GDB it is using\"\n+                    );\n+                }\n+            }\n \n-                // The following line actually doesn't have to do anything with\n-                // pretty printing, it just tells GDB to print values on one line:\n-                script_str.push_str(\"set print pretty off\\n\");\n+            // The following line actually doesn't have to do anything with\n+            // pretty printing, it just tells GDB to print values on one line:\n+            script_str.push_str(\"set print pretty off\\n\");\n \n-                // Add the pretty printer directory to GDB's source-file search path\n-                script_str.push_str(&format!(\"directory {}\\n\", rust_pp_module_abs_path));\n+            // Add the pretty printer directory to GDB's source-file search path\n+            script_str.push_str(&format!(\"directory {}\\n\", rust_pp_module_abs_path));\n \n-                // Load the target executable\n-                script_str.push_str(&format!(\n-                    \"file {}\\n\",\n-                    exe_file.to_str().unwrap().replace(r\"\\\", r\"\\\\\")\n-                ));\n+            // Load the target executable\n+            script_str.push_str(&format!(\n+                \"file {}\\n\",\n+                exe_file.to_str().unwrap().replace(r\"\\\", r\"\\\\\")\n+            ));\n \n-                // Force GDB to print values in the Rust format.\n-                if self.config.gdb_native_rust {\n-                    script_str.push_str(\"set language rust\\n\");\n-                }\n+            // Force GDB to print values in the Rust format.\n+            if self.config.gdb_native_rust {\n+                script_str.push_str(\"set language rust\\n\");\n+            }\n \n-                // Add line breakpoints\n-                for line in &breakpoint_lines {\n-                    script_str.push_str(&format!(\n-                        \"break '{}':{}\\n\",\n-                        self.testpaths.file.file_name().unwrap().to_string_lossy(),\n-                        *line\n-                    ));\n-                }\n+            // Add line breakpoints\n+            for line in &breakpoint_lines {\n+                script_str.push_str(&format!(\n+                    \"break '{}':{}\\n\",\n+                    self.testpaths.file.file_name().unwrap().to_string_lossy(),\n+                    *line\n+                ));\n+            }\n \n-                script_str.push_str(&cmds);\n-                script_str.push_str(\"\\nquit\\n\");\n+            script_str.push_str(&cmds);\n+            script_str.push_str(\"\\nquit\\n\");\n \n-                debug!(\"script_str = {}\", script_str);\n-                self.dump_output_file(&script_str, \"debugger.script\");\n+            debug!(\"script_str = {}\", script_str);\n+            self.dump_output_file(&script_str, \"debugger.script\");\n \n-                let debugger_script = self.make_out_name(\"debugger.script\");\n+            let debugger_script = self.make_out_name(\"debugger.script\");\n \n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                let debugger_opts = vec![\n-                    \"-quiet\".to_owned(),\n-                    \"-batch\".to_owned(),\n-                    \"-nx\".to_owned(),\n-                    format!(\"-command={}\", debugger_script.to_str().unwrap()),\n-                ];\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n+            let debugger_opts = vec![\n+                \"-quiet\".to_owned(),\n+                \"-batch\".to_owned(),\n+                \"-nx\".to_owned(),\n+                format!(\"-command={}\", debugger_script.to_str().unwrap()),\n+            ];\n \n-                let mut gdb = Command::new(self.config.gdb.as_ref().unwrap());\n-                gdb.args(&debugger_opts)\n-                    .env(\"PYTHONPATH\", rust_pp_module_abs_path);\n+            let mut gdb = Command::new(self.config.gdb.as_ref().unwrap());\n+            gdb.args(&debugger_opts)\n+                .env(\"PYTHONPATH\", rust_pp_module_abs_path);\n \n-                debugger_run_result = self.compose_and_run(\n-                    gdb,\n-                    self.config.run_lib_path.to_str().unwrap(),\n-                    None,\n-                    None,\n-                );\n-            }\n+            debugger_run_result = self.compose_and_run(\n+                gdb,\n+                self.config.run_lib_path.to_str().unwrap(),\n+                None,\n+                None,\n+            );\n         }\n \n         if !debugger_run_result.status.success() {"}]}