{"sha": "0cf96131f444f15a2a4ac80f46a86f35fad8309a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjZjk2MTMxZjQ0NGYxNWEyYTRhYzgwZjQ2YTg2ZjM1ZmFkODMwOWE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-03-03T17:56:24Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-03-16T20:14:42Z"}, "message": "Refactor away `NestedMetaItemKind`\n\nRemove methods `Attribute::span` and `MetaItem::span` duplicating public fields", "tree": {"sha": "25433e9ca0b8fe821bdc78151a0a8e656a31cbc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25433e9ca0b8fe821bdc78151a0a8e656a31cbc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cf96131f444f15a2a4ac80f46a86f35fad8309a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cf96131f444f15a2a4ac80f46a86f35fad8309a", "html_url": "https://github.com/rust-lang/rust/commit/0cf96131f444f15a2a4ac80f46a86f35fad8309a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cf96131f444f15a2a4ac80f46a86f35fad8309a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63116d313dbc1e8f7f0fa4a729aea8e4f824b370", "url": "https://api.github.com/repos/rust-lang/rust/commits/63116d313dbc1e8f7f0fa4a729aea8e4f824b370", "html_url": "https://github.com/rust-lang/rust/commit/63116d313dbc1e8f7f0fa4a729aea8e4f824b370"}], "stats": {"total": 271, "additions": 126, "deletions": 145}, "files": [{"sha": "8602d159ba9603fd5ee7f5a9ca2d69d5d0daaecf", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -233,7 +233,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n                 _ => continue,\n             };\n             self.emit_repr_error(\n-                hint.span,\n+                hint.span(),\n                 item.span,\n                 &format!(\"attribute should be applied to {}\", allowed_targets),\n                 &format!(\"not {} {}\", article, allowed_targets),\n@@ -242,7 +242,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n \n         // Just point at all repr hints if there are any incompatibilities.\n         // This is not ideal, but tracking precisely which ones are at fault is a huge hassle.\n-        let hint_spans = hints.iter().map(|hint| hint.span);\n+        let hint_spans = hints.iter().map(|hint| hint.span());\n \n         // Error on repr(transparent, <anything else>).\n         if is_transparent && hints.len() > 1 {"}, {"sha": "496ccc888b61ad032be79b1dd5104977058a8159", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -360,9 +360,7 @@ fn hash_token<'a, 'gcx, W: StableHasherResult>(\n     }\n }\n \n-impl_stable_hash_for_spanned!(::syntax::ast::NestedMetaItemKind);\n-\n-impl_stable_hash_for!(enum ::syntax::ast::NestedMetaItemKind {\n+impl_stable_hash_for!(enum ::syntax::ast::NestedMetaItem {\n     MetaItem(meta_item),\n     Literal(lit)\n });"}, {"sha": "19e899ceb421f72497f406b1532d95c7a52810a3", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -258,7 +258,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                 let meta_item = match li.meta_item() {\n                     Some(meta_item) if meta_item.is_word() => meta_item,\n                     _ => {\n-                        let mut err = bad_attr(li.span);\n+                        let mut err = bad_attr(li.span());\n                         if let Some(item) = li.meta_item() {\n                             if let ast::MetaItemKind::NameValue(_) = item.node {\n                                 if item.path == \"reason\" {\n@@ -290,7 +290,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                 let name = meta_item.path.segments.last().expect(\"empty lint name\").ident.name;\n                 match store.check_lint_name(&name.as_str(), tool_name) {\n                     CheckLintNameResult::Ok(ids) => {\n-                        let src = LintSource::Node(name, li.span, reason);\n+                        let src = LintSource::Node(name, li.span(), reason);\n                         for id in ids {\n                             specs.insert(*id, (level, src));\n                         }\n@@ -301,7 +301,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                             Ok(ids) => {\n                                 let complete_name = &format!(\"{}::{}\", tool_name.unwrap(), name);\n                                 let src = LintSource::Node(\n-                                    Symbol::intern(complete_name), li.span, reason\n+                                    Symbol::intern(complete_name), li.span(), reason\n                                 );\n                                 for id in ids {\n                                     specs.insert(*id, (level, src));\n@@ -323,18 +323,18 @@ impl<'a> LintLevelsBuilder<'a> {\n                                     lint,\n                                     lvl,\n                                     src,\n-                                    Some(li.span.into()),\n+                                    Some(li.span().into()),\n                                     &msg,\n                                 );\n                                 err.span_suggestion(\n-                                    li.span,\n+                                    li.span(),\n                                     \"change it to\",\n                                     new_lint_name.to_string(),\n                                     Applicability::MachineApplicable,\n                                 ).emit();\n \n                                 let src = LintSource::Node(\n-                                    Symbol::intern(&new_lint_name), li.span, reason\n+                                    Symbol::intern(&new_lint_name), li.span(), reason\n                                 );\n                                 for id in ids {\n                                     specs.insert(*id, (level, src));\n@@ -361,11 +361,11 @@ impl<'a> LintLevelsBuilder<'a> {\n                                                               lint,\n                                                               level,\n                                                               src,\n-                                                              Some(li.span.into()),\n+                                                              Some(li.span().into()),\n                                                               &msg);\n                         if let Some(new_name) = renamed {\n                             err.span_suggestion(\n-                                li.span,\n+                                li.span(),\n                                 \"use the new name\",\n                                 new_name,\n                                 Applicability::MachineApplicable\n@@ -384,12 +384,12 @@ impl<'a> LintLevelsBuilder<'a> {\n                                                 lint,\n                                                 level,\n                                                 src,\n-                                                Some(li.span.into()),\n+                                                Some(li.span().into()),\n                                                 &msg);\n \n                         if let Some(suggestion) = suggestion {\n                             db.span_suggestion(\n-                                li.span,\n+                                li.span(),\n                                 \"did you mean\",\n                                 suggestion.to_string(),\n                                 Applicability::MachineApplicable,"}, {"sha": "d0acaf674ae74f12b0b8b2afd32db4a53575b3b8", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n             {\n                 if let Some(items) = item.meta_item_list() {\n                     if let Ok(subcommand) =\n-                        Self::parse(tcx, trait_def_id, &items, item.span, false)\n+                        Self::parse(tcx, trait_def_id, &items, item.span(), false)\n                     {\n                         subcommands.push(subcommand);\n                     } else {\n@@ -118,7 +118,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n             }\n \n             // nothing found\n-            parse_error(tcx, item.span,\n+            parse_error(tcx, item.span(),\n                         \"this attribute must have a valid value\",\n                         \"expected value here\",\n                         Some(r#\"eg `#[rustc_on_unimplemented(message=\"foo\")]`\"#));"}, {"sha": "c964f4cb19b8b01fbda9db15c2ee5461494a096a", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -104,7 +104,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                     value = Some(ident.name),\n                 _ =>\n                     // FIXME better-encapsulate meta_item (don't directly access `node`)\n-                    span_bug!(list_item.span(), \"unexpected meta-item {:?}\", list_item.node),\n+                    span_bug!(list_item.span(), \"unexpected meta-item {:?}\", list_item),\n             }\n         }\n         value"}, {"sha": "2c83501c86f523f8359add23cff00bed8209c457", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -153,7 +153,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n                     return value;\n                 } else {\n                     self.tcx.sess.span_fatal(\n-                        item.span,\n+                        item.span(),\n                         &format!(\"associated value expected for `{}`\", name));\n                 }\n             }"}, {"sha": "5551cf6b3b604b970f1425a0e3ed7d5f8480479e", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -430,13 +430,13 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n             if DepNode::has_label_string(label) {\n                 if out.contains(label) {\n                     self.tcx.sess.span_fatal(\n-                        item.span,\n+                        item.span(),\n                         &format!(\"dep-node label `{}` is repeated\", label));\n                 }\n                 out.insert(label.to_string());\n             } else {\n                 self.tcx.sess.span_fatal(\n-                    item.span,\n+                    item.span(),\n                     &format!(\"dep-node label `{}` not recognized\", label));\n             }\n         }\n@@ -582,7 +582,7 @@ fn expect_associated_value(tcx: TyCtxt<'_, '_, '_>, item: &NestedMetaItem) -> as\n             \"expected an associated value\".to_string()\n         };\n \n-        tcx.sess.span_fatal(item.span, &msg);\n+        tcx.sess.span_fatal(item.span(), &msg);\n     }\n }\n "}, {"sha": "80786992cd95699eef98ee5d211ac52d577e177e", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n                         k => {\n                             struct_span_err!(self.tcx.sess, m.span, E0458,\n                                       \"unknown kind: `{}`\", k)\n-                                .span_label(item.span, \"unknown kind\").emit();\n+                                .span_label(item.span(), \"unknown kind\").emit();\n                             cstore::NativeUnknown\n                         }\n                     };"}, {"sha": "373bcf7f0e2f3a4ab86479035bae7634c5d71d84", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> VarianceTest<'a, 'tcx> {\n \n                         _ => {\n                             self.tcx.sess.span_err(\n-                                meta_item.span,\n+                                meta_item.span(),\n                                 &format!(\"unrecognized field name `{}`\", name),\n                             );\n                         }"}, {"sha": "bd11e0ce8023aa6dbb10c620943626f1f24c0981", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -59,7 +59,7 @@ pub fn load_plugins(sess: &Session,\n                 match plugin.ident_str() {\n                     Some(name) if !plugin.is_value_str() => {\n                         let args = plugin.meta_item_list().map(ToOwned::to_owned);\n-                        loader.load_plugin(plugin.span, name, args.unwrap_or_default());\n+                        loader.load_plugin(plugin.span(), name, args.unwrap_or_default());\n                     },\n                     _ => call_malformed_plugin_attribute(sess, attr.span),\n                 }"}, {"sha": "12b87b9c9aa18ab40f211c34599ddce50ae030fe", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -813,12 +813,12 @@ impl<'a> Resolver<'a> {\n                         MetaItemKind::List(nested_metas) => for nested_meta in nested_metas {\n                             match nested_meta.ident() {\n                                 Some(ident) if nested_meta.is_word() => single_imports.push(ident),\n-                                _ => ill_formed(nested_meta.span),\n+                                _ => ill_formed(nested_meta.span()),\n                             }\n                         }\n                         MetaItemKind::NameValue(..) => ill_formed(meta.span),\n                     }\n-                    None => ill_formed(attr.span()),\n+                    None => ill_formed(attr.span),\n                 }\n             }\n         }"}, {"sha": "10e9613bf21a23497c42d6bd476856dad5d778a9", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -2326,7 +2326,7 @@ fn from_target_feature(\n         if !item.check_name(\"enable\") {\n             let msg = \"#[target_feature(..)] only accepts sub-keys of `enable` \\\n                        currently\";\n-            tcx.sess.span_err(item.span, &msg);\n+            tcx.sess.span_err(item.span(), &msg);\n             continue;\n         }\n \n@@ -2336,7 +2336,7 @@ fn from_target_feature(\n             None => {\n                 let msg = \"#[target_feature] attribute must be of the form \\\n                            #[target_feature(enable = \\\"..\\\")]\";\n-                tcx.sess.span_err(item.span, &msg);\n+                tcx.sess.span_err(item.span(), &msg);\n                 continue;\n             }\n         };\n@@ -2352,7 +2352,7 @@ fn from_target_feature(\n                          this target\",\n                         feature\n                     );\n-                    let mut err = tcx.sess.struct_span_err(item.span, &msg);\n+                    let mut err = tcx.sess.struct_span_err(item.span(), &msg);\n \n                     if feature.starts_with(\"+\") {\n                         let valid = whitelist.contains_key(&feature[1..]);\n@@ -2387,7 +2387,7 @@ fn from_target_feature(\n                 feature_gate::emit_feature_err(\n                     &tcx.sess.parse_sess,\n                     feature_gate.as_ref().unwrap(),\n-                    item.span,\n+                    item.span(),\n                     feature_gate::GateIssue::Language,\n                     &format!(\"the target feature `{}` is currently unstable\", feature),\n                 );\n@@ -2549,7 +2549,7 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                 } else {\n                     span_err!(\n                         tcx.sess.diagnostic(),\n-                        items[0].span,\n+                        items[0].span(),\n                         E0535,\n                         \"invalid argument\"\n                     );\n@@ -2583,7 +2583,7 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                 } else if list_contains_name(&items[..], \"speed\") {\n                     OptimizeAttr::Speed\n                 } else {\n-                    err(items[0].span, \"invalid argument\");\n+                    err(items[0].span(), \"invalid argument\");\n                     OptimizeAttr::None\n                 }\n             }"}, {"sha": "69445451503cc7404d7b5b2c1325e30569cdfa15", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -8,7 +8,7 @@ use std::fmt::{self, Write};\n use std::ops;\n \n use syntax::symbol::Symbol;\n-use syntax::ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind, LitKind};\n+use syntax::ast::{MetaItem, MetaItemKind, NestedMetaItem, LitKind};\n use syntax::parse::ParseSess;\n use syntax::feature_gate::Features;\n \n@@ -41,9 +41,9 @@ pub struct InvalidCfgError {\n impl Cfg {\n     /// Parses a `NestedMetaItem` into a `Cfg`.\n     fn parse_nested(nested_cfg: &NestedMetaItem) -> Result<Cfg, InvalidCfgError> {\n-        match nested_cfg.node {\n-            NestedMetaItemKind::MetaItem(ref cfg) => Cfg::parse(cfg),\n-            NestedMetaItemKind::Literal(ref lit) => Err(InvalidCfgError {\n+        match nested_cfg {\n+            NestedMetaItem::MetaItem(ref cfg) => Cfg::parse(cfg),\n+            NestedMetaItem::Literal(ref lit) => Err(InvalidCfgError {\n                 msg: \"unexpected literal\",\n                 span: lit.span,\n             }),\n@@ -442,9 +442,9 @@ mod test {\n                 path: Path::from_ident(Ident::from_str(stringify!($name))),\n                 node: MetaItemKind::List(vec![\n                     $(\n-                        dummy_spanned(NestedMetaItemKind::MetaItem(\n+                        NestedMetaItem::MetaItem(\n                             dummy_meta_item_word(stringify!($list)),\n-                        )),\n+                        ),\n                     )*\n                 ]),\n                 span: DUMMY_SP,\n@@ -456,7 +456,7 @@ mod test {\n                 path: Path::from_ident(Ident::from_str(stringify!($name))),\n                 node: MetaItemKind::List(vec![\n                     $(\n-                        dummy_spanned(NestedMetaItemKind::MetaItem($list)),\n+                        NestedMetaItem::MetaItem($list),\n                     )*\n                 ]),\n                 span: DUMMY_SP,"}, {"sha": "3aea661f6bec5ef0d9d49c3da4e3348590e6a653", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -777,15 +777,15 @@ pub struct Attributes {\n impl Attributes {\n     /// Extracts the content from an attribute `#[doc(cfg(content))]`.\n     fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n-        use syntax::ast::NestedMetaItemKind::MetaItem;\n+        use syntax::ast::NestedMetaItem::MetaItem;\n \n         if let ast::MetaItemKind::List(ref nmis) = mi.node {\n             if nmis.len() == 1 {\n-                if let MetaItem(ref cfg_mi) = nmis[0].node {\n+                if let MetaItem(ref cfg_mi) = nmis[0] {\n                     if cfg_mi.check_name(\"cfg\") {\n                         if let ast::MetaItemKind::List(ref cfg_nmis) = cfg_mi.node {\n                             if cfg_nmis.len() == 1 {\n-                                if let MetaItem(ref content_mi) = cfg_nmis[0].node {\n+                                if let MetaItem(ref content_mi) = cfg_nmis[0] {\n                                     return Some(content_mi);\n                                 }\n                             }"}, {"sha": "1a0da73880cfcdc1178b32c832af43d09dc1b064", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -443,14 +443,11 @@ pub struct Crate {\n     pub span: Span,\n }\n \n-/// A spanned compile-time attribute list item.\n-pub type NestedMetaItem = Spanned<NestedMetaItemKind>;\n-\n /// Possible values inside of compile-time attribute lists.\n ///\n /// E.g., the '..' in `#[name(..)]`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum NestedMetaItemKind {\n+pub enum NestedMetaItem {\n     /// A full MetaItem, for recursive meta items.\n     MetaItem(MetaItem),\n     /// A literal.\n@@ -2207,7 +2204,7 @@ pub struct Item {\n impl Item {\n     /// Return the span that encompasses the attributes.\n     pub fn span_with_attributes(&self) -> Span {\n-        self.attrs.iter().fold(self.span, |acc, attr| acc.to(attr.span()))\n+        self.attrs.iter().fold(self.span, |acc, attr| acc.to(attr.span))\n     }\n }\n "}, {"sha": "cdfb83c6e56c8ca6f44caab293dd2af51ce5ca36", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -1,6 +1,6 @@\n //! Parsing and validation of builtin attributes\n \n-use crate::ast::{self, Attribute, MetaItem, NestedMetaItemKind};\n+use crate::ast::{self, Attribute, MetaItem, NestedMetaItem};\n use crate::feature_gate::{Features, GatedCfg};\n use crate::parse::ParseSess;\n \n@@ -240,7 +240,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                         } else {\n                             handle_errors(\n                                 sess,\n-                                meta.span,\n+                                meta.span(),\n                                 AttrError::UnsupportedLiteral(\n                                     \"unsupported literal\",\n                                     false,\n@@ -271,11 +271,11 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                             })\n                         }\n                         (None, _) => {\n-                            handle_errors(sess, attr.span(), AttrError::MissingSince);\n+                            handle_errors(sess, attr.span, AttrError::MissingSince);\n                             continue\n                         }\n                         _ => {\n-                            span_err!(diagnostic, attr.span(), E0543, \"missing 'reason'\");\n+                            span_err!(diagnostic, attr.span, E0543, \"missing 'reason'\");\n                             continue\n                         }\n                     }\n@@ -291,13 +291,13 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                     if let Some(feature) = feature {\n                         rustc_const_unstable = Some(feature);\n                     } else {\n-                        span_err!(diagnostic, attr.span(), E0629, \"missing 'feature'\");\n+                        span_err!(diagnostic, attr.span, E0629, \"missing 'feature'\");\n                         continue\n                     }\n                 }\n                 \"unstable\" => {\n                     if stab.is_some() {\n-                        handle_errors(sess, attr.span(), AttrError::MultipleStabilityLevels);\n+                        handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n                         break\n                     }\n \n@@ -313,7 +313,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                                 _ => {\n                                     handle_errors(\n                                         sess,\n-                                        meta.span,\n+                                        meta.span(),\n                                         AttrError::UnknownMetaItem(\n                                             mi.path.to_string(),\n                                             &[\"feature\", \"reason\", \"issue\"]\n@@ -325,7 +325,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                         } else {\n                             handle_errors(\n                                 sess,\n-                                meta.span,\n+                                meta.span(),\n                                 AttrError::UnsupportedLiteral(\n                                     \"unsupported literal\",\n                                     false,\n@@ -344,7 +344,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                                         if let Ok(issue) = issue.as_str().parse() {\n                                             issue\n                                         } else {\n-                                            span_err!(diagnostic, attr.span(), E0545,\n+                                            span_err!(diagnostic, attr.span, E0545,\n                                                       \"incorrect 'issue'\");\n                                             continue\n                                         }\n@@ -357,26 +357,26 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                             })\n                         }\n                         (None, _, _) => {\n-                            handle_errors(sess, attr.span(), AttrError::MissingFeature);\n+                            handle_errors(sess, attr.span, AttrError::MissingFeature);\n                             continue\n                         }\n                         _ => {\n-                            span_err!(diagnostic, attr.span(), E0547, \"missing 'issue'\");\n+                            span_err!(diagnostic, attr.span, E0547, \"missing 'issue'\");\n                             continue\n                         }\n                     }\n                 }\n                 \"stable\" => {\n                     if stab.is_some() {\n-                        handle_errors(sess, attr.span(), AttrError::MultipleStabilityLevels);\n+                        handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n                         break\n                     }\n \n                     let mut feature = None;\n                     let mut since = None;\n                     for meta in metas {\n-                        match &meta.node {\n-                            NestedMetaItemKind::MetaItem(mi) => {\n+                        match meta {\n+                            NestedMetaItem::MetaItem(mi) => {\n                                 match mi.ident_str() {\n                                     Some(\"feature\") =>\n                                         if !get(mi, &mut feature) { continue 'outer },\n@@ -385,7 +385,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                                     _ => {\n                                         handle_errors(\n                                             sess,\n-                                            meta.span,\n+                                            meta.span(),\n                                             AttrError::UnknownMetaItem(\n                                                 mi.path.to_string(), &[\"since\", \"note\"],\n                                             ),\n@@ -394,7 +394,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                                     }\n                                 }\n                             },\n-                            NestedMetaItemKind::Literal(lit) => {\n+                            NestedMetaItem::Literal(lit) => {\n                                 handle_errors(\n                                     sess,\n                                     lit.span,\n@@ -421,11 +421,11 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                             })\n                         }\n                         (None, _) => {\n-                            handle_errors(sess, attr.span(), AttrError::MissingFeature);\n+                            handle_errors(sess, attr.span, AttrError::MissingFeature);\n                             continue\n                         }\n                         _ => {\n-                            handle_errors(sess, attr.span(), AttrError::MissingSince);\n+                            handle_errors(sess, attr.span, AttrError::MissingSince);\n                             continue\n                         }\n                     }\n@@ -520,7 +520,7 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n                 if !mi.is_meta_item() {\n                     handle_errors(\n                         sess,\n-                        mi.span,\n+                        mi.span(),\n                         AttrError::UnsupportedLiteral(\n                             \"unsupported literal\",\n                             false\n@@ -633,8 +633,8 @@ fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n                 let mut since = None;\n                 let mut note = None;\n                 for meta in list {\n-                    match &meta.node {\n-                        NestedMetaItemKind::MetaItem(mi) => {\n+                    match meta {\n+                        NestedMetaItem::MetaItem(mi) => {\n                             match mi.ident_str() {\n                                 Some(\"since\") => if !get(mi, &mut since) { continue 'outer },\n                                 Some(\"note\") => if !get(mi, &mut note) { continue 'outer },\n@@ -649,7 +649,7 @@ fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n                                 }\n                             }\n                         }\n-                        NestedMetaItemKind::Literal(lit) => {\n+                        NestedMetaItem::Literal(lit) => {\n                             handle_errors(\n                                 sess,\n                                 lit.span,\n@@ -718,7 +718,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                 if !item.is_meta_item() {\n                     handle_errors(\n                         sess,\n-                        item.span,\n+                        item.span(),\n                         AttrError::UnsupportedLiteral(\n                             \"meta item in `repr` must be an identifier\",\n                             false,\n@@ -775,28 +775,28 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                         };\n                     }\n                     if let Some(literal_error) = literal_error {\n-                        span_err!(diagnostic, item.span, E0589,\n+                        span_err!(diagnostic, item.span(), E0589,\n                                   \"invalid `repr(align)` attribute: {}\", literal_error);\n                     }\n                 } else {\n                     if let Some(meta_item) = item.meta_item() {\n                         if meta_item.check_name(\"align\") {\n                             if let MetaItemKind::NameValue(ref value) = meta_item.node {\n                                 recognised = true;\n-                                let mut err = struct_span_err!(diagnostic, item.span, E0693,\n+                                let mut err = struct_span_err!(diagnostic, item.span(), E0693,\n                                     \"incorrect `repr(align)` attribute format\");\n                                 match value.node {\n                                     ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n                                         err.span_suggestion(\n-                                            item.span,\n+                                            item.span(),\n                                             \"use parentheses instead\",\n                                             format!(\"align({})\", int),\n                                             Applicability::MachineApplicable\n                                         );\n                                     }\n                                     ast::LitKind::Str(s, _) => {\n                                         err.span_suggestion(\n-                                            item.span,\n+                                            item.span(),\n                                             \"use parentheses instead\",\n                                             format!(\"align({})\", s),\n                                             Applicability::MachineApplicable\n@@ -811,7 +811,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                 }\n                 if !recognised {\n                     // Not a word we recognize\n-                    span_err!(diagnostic, item.span, E0552,\n+                    span_err!(diagnostic, item.span(), E0552,\n                               \"unrecognized representation hint\");\n                 }\n             }"}, {"sha": "1a8faa43fff7c1fc065312eb6935c09c1a652a4d", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 20, "deletions": 31, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -13,7 +13,7 @@ pub use StabilityLevel::*;\n \n use crate::ast;\n use crate::ast::{AttrId, Attribute, AttrStyle, Name, Ident, Path, PathSegment};\n-use crate::ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n+use crate::ast::{MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind, GenericParam};\n use crate::mut_visit::visit_clobber;\n use crate::source_map::{BytePos, Spanned, respan, dummy_spanned};\n@@ -64,27 +64,22 @@ pub fn is_known_lint_tool(m_item: Ident) -> bool {\n }\n \n impl NestedMetaItem {\n-    /// Returns the MetaItem if self is a NestedMetaItemKind::MetaItem.\n+    /// Returns the MetaItem if self is a NestedMetaItem::MetaItem.\n     pub fn meta_item(&self) -> Option<&MetaItem> {\n-        match self.node {\n-            NestedMetaItemKind::MetaItem(ref item) => Some(item),\n+        match *self {\n+            NestedMetaItem::MetaItem(ref item) => Some(item),\n             _ => None\n         }\n     }\n \n-    /// Returns the Lit if self is a NestedMetaItemKind::Literal.\n+    /// Returns the Lit if self is a NestedMetaItem::Literal.\n     pub fn literal(&self) -> Option<&Lit> {\n-        match self.node {\n-            NestedMetaItemKind::Literal(ref lit) => Some(lit),\n+        match *self {\n+            NestedMetaItem::Literal(ref lit) => Some(lit),\n             _ => None\n         }\n     }\n \n-    /// Returns the Span for `self`.\n-    pub fn span(&self) -> Span {\n-        self.span\n-    }\n-\n     /// Returns `true` if this list item is a MetaItem with a name of `name`.\n     pub fn check_name(&self, name: &str) -> bool {\n         self.meta_item().map_or(false, |meta_item| meta_item.check_name(name))\n@@ -191,10 +186,6 @@ impl Attribute {\n         self.tokens.is_empty()\n     }\n \n-    pub fn span(&self) -> Span {\n-        self.span\n-    }\n-\n     pub fn is_meta_item_list(&self) -> bool {\n         self.meta_item_list().is_some()\n     }\n@@ -253,8 +244,6 @@ impl MetaItem {\n         }\n     }\n \n-    pub fn span(&self) -> Span { self.span }\n-\n     pub fn check_name(&self, name: &str) -> bool {\n         self.path == name\n     }\n@@ -369,7 +358,7 @@ pub fn mk_word_item(ident: Ident) -> MetaItem {\n }\n \n pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n-    respan(ident.span, NestedMetaItemKind::MetaItem(mk_word_item(ident)))\n+    NestedMetaItem::MetaItem(mk_word_item(ident))\n }\n \n pub fn mk_attr_id() -> AttrId {\n@@ -545,7 +534,7 @@ impl MetaItemKind {\n                     if i > 0 {\n                         tokens.push(TokenTree::Token(span, Token::Comma).into());\n                     }\n-                    item.node.tokens().append_to_tree_and_joint_vec(&mut tokens);\n+                    item.tokens().append_to_tree_and_joint_vec(&mut tokens);\n                 }\n                 TokenTree::Delimited(\n                     DelimSpan::from_single(span),\n@@ -579,8 +568,8 @@ impl MetaItemKind {\n         let mut tokens = delimited.into_trees().peekable();\n         let mut result = Vec::new();\n         while let Some(..) = tokens.peek() {\n-            let item = NestedMetaItemKind::from_tokens(&mut tokens)?;\n-            result.push(respan(item.span(), item));\n+            let item = NestedMetaItem::from_tokens(&mut tokens)?;\n+            result.push(item);\n             match tokens.next() {\n                 None | Some(TokenTree::Token(_, Token::Comma)) => {}\n                 _ => return None,\n@@ -590,32 +579,32 @@ impl MetaItemKind {\n     }\n }\n \n-impl NestedMetaItemKind {\n-    fn span(&self) -> Span {\n+impl NestedMetaItem {\n+    pub fn span(&self) -> Span {\n         match *self {\n-            NestedMetaItemKind::MetaItem(ref item) => item.span,\n-            NestedMetaItemKind::Literal(ref lit) => lit.span,\n+            NestedMetaItem::MetaItem(ref item) => item.span,\n+            NestedMetaItem::Literal(ref lit) => lit.span,\n         }\n     }\n \n     fn tokens(&self) -> TokenStream {\n         match *self {\n-            NestedMetaItemKind::MetaItem(ref item) => item.tokens(),\n-            NestedMetaItemKind::Literal(ref lit) => lit.tokens(),\n+            NestedMetaItem::MetaItem(ref item) => item.tokens(),\n+            NestedMetaItem::Literal(ref lit) => lit.tokens(),\n         }\n     }\n \n-    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<NestedMetaItemKind>\n+    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<NestedMetaItem>\n         where I: Iterator<Item = TokenTree>,\n     {\n         if let Some(TokenTree::Token(span, token)) = tokens.peek().cloned() {\n             if let Some(node) = LitKind::from_token(token) {\n                 tokens.next();\n-                return Some(NestedMetaItemKind::Literal(respan(span, node)));\n+                return Some(NestedMetaItem::Literal(respan(span, node)));\n             }\n         }\n \n-        MetaItem::from_tokens(tokens).map(NestedMetaItemKind::MetaItem)\n+        MetaItem::from_tokens(tokens).map(NestedMetaItem::MetaItem)\n     }\n }\n "}, {"sha": "c300ffc2d61b9259f4adb9e77ef5d45bcb263f0f", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -181,13 +181,13 @@ impl<'a> StripUnconfigured<'a> {\n             if nested_meta_items.is_empty() {\n                 return error(meta_item.span, \"`cfg` predicate is not specified\", \"\");\n             } else if nested_meta_items.len() > 1 {\n-                return error(nested_meta_items.last().unwrap().span,\n+                return error(nested_meta_items.last().unwrap().span(),\n                              \"multiple `cfg` predicates are specified\", \"\");\n             }\n \n             match nested_meta_items[0].meta_item() {\n                 Some(meta_item) => attr::cfg_matches(meta_item, self.sess, self.features),\n-                None => error(nested_meta_items[0].span,\n+                None => error(nested_meta_items[0].span(),\n                               \"`cfg` predicate key cannot be a literal\", \"\"),\n             }\n         })"}, {"sha": "82358679c0e824281559710d016b9a29b12db51d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -1520,23 +1520,23 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                             self.cx.source_map().new_source_file(filename.into(), src);\n \n                             let include_info = vec![\n-                                dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n+                                ast::NestedMetaItem::MetaItem(\n                                     attr::mk_name_value_item_str(\n                                         Ident::from_str(\"file\"),\n                                         dummy_spanned(file),\n                                     ),\n-                                )),\n-                                dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n+                                ),\n+                                ast::NestedMetaItem::MetaItem(\n                                     attr::mk_name_value_item_str(\n                                         Ident::from_str(\"contents\"),\n                                         dummy_spanned(src_interned),\n                                     ),\n-                                )),\n+                                ),\n                             ];\n \n                             let include_ident = Ident::from_str(\"include\");\n                             let item = attr::mk_list_item(DUMMY_SP, include_ident, include_info);\n-                            items.push(dummy_spanned(ast::NestedMetaItemKind::MetaItem(item)));\n+                            items.push(ast::NestedMetaItem::MetaItem(item));\n                         }\n                         Err(e) => {\n                             let lit = it\n@@ -1569,7 +1569,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     }\n                 } else {\n                     let mut err = self.cx.struct_span_err(\n-                        it.span,\n+                        it.span(),\n                         &format!(\"expected path to external documentation\"),\n                     );\n \n@@ -1590,7 +1590,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     };\n \n                     err.span_suggestion(\n-                        it.span,\n+                        it.span(),\n                         \"provide a file path with `=`\",\n                         format!(\"include = \\\"{}\\\"\", path),\n                         applicability,"}, {"sha": "9beaabb0cd58ba857fc6b3175427568826aa10f9", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -2061,7 +2061,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n \n             if incomplete_features.iter().any(|f| *f == name) {\n                 span_handler.struct_span_warn(\n-                    mi.span,\n+                    mi.span(),\n                     &format!(\n                         \"the feature `{}` is incomplete and may cause the compiler to crash\",\n                         name\n@@ -2102,7 +2102,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n             let name = match mi.ident() {\n                 Some(ident) if mi.is_word() => ident.name,\n                 _ => {\n-                    span_err!(span_handler, mi.span, E0556,\n+                    span_err!(span_handler, mi.span(), E0556,\n                             \"malformed feature, expected just one word\");\n                     continue\n                 }\n@@ -2111,7 +2111,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n             if let Some(edition) = edition_enabled_features.get(&name) {\n                 struct_span_warn!(\n                     span_handler,\n-                    mi.span,\n+                    mi.span(),\n                     E0705,\n                     \"the feature `{}` is included in the Rust {} edition\",\n                     name,\n@@ -2128,32 +2128,32 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n             if let Some((.., set)) = ACTIVE_FEATURES.iter().find(|f| name == f.0) {\n                 if let Some(allowed) = allow_features.as_ref() {\n                     if allowed.iter().find(|f| *f == name.as_str()).is_none() {\n-                        span_err!(span_handler, mi.span, E0725,\n+                        span_err!(span_handler, mi.span(), E0725,\n                                   \"the feature `{}` is not in the list of allowed features\",\n                                   name);\n                         continue;\n                     }\n                 }\n \n-                set(&mut features, mi.span);\n-                features.declared_lang_features.push((name, mi.span, None));\n+                set(&mut features, mi.span());\n+                features.declared_lang_features.push((name, mi.span(), None));\n                 continue\n             }\n \n             let removed = REMOVED_FEATURES.iter().find(|f| name == f.0);\n             let stable_removed = STABLE_REMOVED_FEATURES.iter().find(|f| name == f.0);\n             if let Some((.., reason)) = removed.or(stable_removed) {\n-                feature_removed(span_handler, mi.span, *reason);\n+                feature_removed(span_handler, mi.span(), *reason);\n                 continue\n             }\n \n             if let Some((_, since, ..)) = ACCEPTED_FEATURES.iter().find(|f| name == f.0) {\n                 let since = Some(Symbol::intern(since));\n-                features.declared_lang_features.push((name, mi.span, since));\n+                features.declared_lang_features.push((name, mi.span(), since));\n                 continue\n             }\n \n-            features.declared_lib_features.push((name, mi.span));\n+            features.declared_lib_features.push((name, mi.span()));\n         }\n     }\n "}, {"sha": "462346df7d76d4a66255eb1bbb75cde7ac4a8d9c", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -539,12 +539,10 @@ pub fn noop_visit_macro_def<T: MutVisitor>(macro_def: &mut MacroDef, vis: &mut T\n }\n \n pub fn noop_visit_meta_list_item<T: MutVisitor>(li: &mut NestedMetaItem, vis: &mut T) {\n-    let Spanned { node, span } = li;\n-    match node {\n-        NestedMetaItemKind::MetaItem(mi) => vis.visit_meta_item(mi),\n-        NestedMetaItemKind::Literal(_lit) => {}\n+    match li {\n+        NestedMetaItem::MetaItem(mi) => vis.visit_meta_item(mi),\n+        NestedMetaItem::Literal(_lit) => {}\n     }\n-    vis.visit_span(span);\n }\n \n pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {"}, {"sha": "e5571757e820b87caa712139da5d59fc0ab09890", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -1,6 +1,5 @@\n use crate::attr;\n use crate::ast;\n-use crate::source_map::respan;\n use crate::parse::{SeqSep, PResult};\n use crate::parse::token::{self, Nonterminal, DelimToken};\n use crate::parse::parser::{Parser, TokenType, PathStyle};\n@@ -272,14 +271,14 @@ impl<'a> Parser<'a> {\n \n         match self.parse_unsuffixed_lit() {\n             Ok(lit) => {\n-                return Ok(respan(lo.to(self.prev_span), ast::NestedMetaItemKind::Literal(lit)))\n+                return Ok(ast::NestedMetaItem::Literal(lit))\n             }\n             Err(ref mut err) => self.diagnostic().cancel(err)\n         }\n \n         match self.parse_meta_item() {\n             Ok(mi) => {\n-                return Ok(respan(lo.to(self.prev_span), ast::NestedMetaItemKind::MetaItem(mi)))\n+                return Ok(ast::NestedMetaItem::MetaItem(mi))\n             }\n             Err(ref mut err) => self.diagnostic().cancel(err)\n         }"}, {"sha": "e04e127ccf15a8e800eef58068452b5170b3768a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -768,11 +768,11 @@ pub trait PrintState<'a> {\n     }\n \n     fn print_meta_list_item(&mut self, item: &ast::NestedMetaItem) -> io::Result<()> {\n-        match item.node {\n-            ast::NestedMetaItemKind::MetaItem(ref mi) => {\n+        match item {\n+            ast::NestedMetaItem::MetaItem(ref mi) => {\n                 self.print_meta_item(mi)\n             },\n-            ast::NestedMetaItemKind::Literal(ref lit) => {\n+            ast::NestedMetaItem::Literal(ref lit) => {\n                 self.print_literal(lit)\n             }\n         }"}, {"sha": "6f03c5854036c4e99c18429647a678e420bc2b10", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -435,7 +435,7 @@ fn get_test_runner(sd: &errors::Handler, krate: &ast::Crate) -> Option<ast::Path\n     let test_attr = attr::find_by_name(&krate.attrs, \"test_runner\")?;\n     test_attr.meta_item_list().map(|meta_list| {\n         if meta_list.len() != 1 {\n-            sd.span_fatal(test_attr.span(),\n+            sd.span_fatal(test_attr.span,\n                 \"#![test_runner(..)] accepts exactly 1 argument\").raise()\n         }\n         match meta_list[0].meta_item() {"}, {"sha": "d5f37aff222ef4e70dac2eec9b130392a2b3a160", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -109,7 +109,7 @@ impl<'a> CollectProcMacros<'a> {\n             None => return,\n         };\n         if list.len() != 1 && list.len() != 2 {\n-            self.handler.span_err(attr.span(),\n+            self.handler.span_err(attr.span,\n                                   \"attribute must have either one or two arguments\");\n             return\n         }\n@@ -129,7 +129,7 @@ impl<'a> CollectProcMacros<'a> {\n         };\n \n         if !trait_ident.can_be_raw() {\n-            self.handler.span_err(trait_attr.span(),\n+            self.handler.span_err(trait_attr.span,\n                                   &format!(\"`{}` cannot be a name of derive macro\", trait_ident));\n         }\n         if deriving::is_builtin_trait(trait_ident.name) {\n@@ -164,7 +164,7 @@ impl<'a> CollectProcMacros<'a> {\n                 };\n                 if !ident.can_be_raw() {\n                     self.handler.span_err(\n-                        attr.span(),\n+                        attr.span,\n                         &format!(\"`{}` cannot be a name of derive helper attribute\", ident),\n                     );\n                 }\n@@ -262,8 +262,8 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n                                 to the same function\", attr.path, prev_attr.path)\n                     };\n \n-                    self.handler.struct_span_err(attr.span(), &msg)\n-                        .span_note(prev_attr.span(), \"Previous attribute here\")\n+                    self.handler.struct_span_err(attr.span, &msg)\n+                        .span_note(prev_attr.span, \"Previous attribute here\")\n                         .emit();\n \n                     return;\n@@ -288,7 +288,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n             let msg = format!(\"the `#[{}]` attribute may only be used on bare functions\",\n                               attr.path);\n \n-            self.handler.span_err(attr.span(), &msg);\n+            self.handler.span_err(attr.span, &msg);\n             return;\n         }\n \n@@ -300,7 +300,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n             let msg = format!(\"the `#[{}]` attribute is only usable with crates of the \\\n                               `proc-macro` crate type\", attr.path);\n \n-            self.handler.span_err(attr.span(), &msg);\n+            self.handler.span_err(attr.span, &msg);\n             return;\n         }\n "}, {"sha": "0dbcb7ce0b7e21a351324b7c35a742d7a75dea61", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf96131f444f15a2a4ac80f46a86f35fad8309a/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=0cf96131f444f15a2a4ac80f46a86f35fad8309a", "patch": "@@ -227,7 +227,7 @@ fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n                         .and_then(|mi| mi.value_str());\n                     if list.len() != 1 || msg.is_none() {\n                         sd.struct_span_warn(\n-                            attr.span(),\n+                            attr.span,\n                             \"argument must be of the form: \\\n                              `expected = \\\"error message\\\"`\"\n                         ).note(\"Errors in this attribute were erroneously \\"}]}