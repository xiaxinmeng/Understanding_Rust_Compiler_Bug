{"sha": "efda49712b35009c0096217ce2aa262fc5ab8174", "node_id": "C_kwDOAAsO6NoAKGVmZGE0OTcxMmIzNTAwOWMwMDk2MjE3Y2UyYWEyNjJmYzVhYjgxNzQ", "commit": {"author": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2022-09-04T16:53:29Z"}, "committer": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2022-09-04T18:06:26Z"}, "message": "proc_macro/bridge: use the cross-thread executor for nested proc-macros\n\nWhile working on some other changes in the bridge, I noticed that when\nrunning a nested proc-macro (which is currently only possible using\nthe unstable `TokenStream::expand_expr`), any symbols held by the\nproc-macro client would be invalidated, as the same thread would be used\nfor the nested macro by default, and the interner doesn't handle nested\nuse.\n\nAfter discussing with @eddyb, we decided the best approach might be to\nforce the use of the cross-thread executor for nested invocations, as it\nwill never re-use thread-local storage, avoiding the issue. This\nshouldn't impact performance, as expand_expr is still unstable, and\ninfrequently used.\n\nThis was chosen rather than making the client symbol interner handle\nnested invocations, as that would require replacing the internal\ninterner `Vec` with a `BTreeMap` (as valid symbol id ranges could now be\ndisjoint), and the symbol interner is known to be fairly perf-sensitive.\n\nThis patch adds checks to the execution strategy to use the cross-thread\nexecutor when doing nested invocations. An alternative implementation\nstrategy could be to track this information in the `ExtCtxt`, however a\nthread-local in the `proc_macro` crate was chosen to add an assertion so\nthat `rust-analyzer` is aware of the issue if it implements\n`expand_expr` in the future.\n\nr? @eddyb", "tree": {"sha": "d883f1393ce90018bd05cae7ad3a943211f7659b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d883f1393ce90018bd05cae7ad3a943211f7659b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efda49712b35009c0096217ce2aa262fc5ab8174", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efda49712b35009c0096217ce2aa262fc5ab8174", "html_url": "https://github.com/rust-lang/rust/commit/efda49712b35009c0096217ce2aa262fc5ab8174", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efda49712b35009c0096217ce2aa262fc5ab8174/comments", "author": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b11bf65e4aaa125952b6479a63f36e9e83efc32c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b11bf65e4aaa125952b6479a63f36e9e83efc32c", "html_url": "https://github.com/rust-lang/rust/commit/b11bf65e4aaa125952b6479a63f36e9e83efc32c"}], "stats": {"total": 60, "additions": 56, "deletions": 4}, "files": [{"sha": "8202c40d63170464fe96cb2bc49f8df605100c20", "filename": "library/proc_macro/src/bridge/server.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/efda49712b35009c0096217ce2aa262fc5ab8174/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efda49712b35009c0096217ce2aa262fc5ab8174/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs?ref=efda49712b35009c0096217ce2aa262fc5ab8174", "patch": "@@ -2,6 +2,7 @@\n \n use super::*;\n \n+use std::cell::Cell;\n use std::marker::PhantomData;\n \n // FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n@@ -143,6 +144,38 @@ pub trait ExecutionStrategy {\n     ) -> Buffer;\n }\n \n+thread_local! {\n+    /// While running a proc-macro with the same-thread executor, this flag will\n+    /// be set, forcing nested proc-macro invocations (e.g. due to\n+    /// `TokenStream::expand_expr`) to be run using a cross-thread executor.\n+    ///\n+    /// This is required as the thread-local state in the proc_macro client does\n+    /// not handle being re-entered, and will invalidate all `Symbol`s when\n+    /// entering a nested macro.\n+    static ALREADY_RUNNING_SAME_THREAD: Cell<bool> = Cell::new(false);\n+}\n+\n+/// Keep `ALREADY_RUNNING_SAME_THREAD` (see also its documentation)\n+/// set to `true`, preventing same-thread reentrance.\n+struct RunningSameThreadGuard(());\n+\n+impl RunningSameThreadGuard {\n+    fn new() -> Self {\n+        let already_running = ALREADY_RUNNING_SAME_THREAD.replace(true);\n+        assert!(\n+            !already_running,\n+            \"same-thread nesting (\\\"reentrance\\\") of proc macro executions is not supported\"\n+        );\n+        RunningSameThreadGuard(())\n+    }\n+}\n+\n+impl Drop for RunningSameThreadGuard {\n+    fn drop(&mut self) {\n+        ALREADY_RUNNING_SAME_THREAD.set(false);\n+    }\n+}\n+\n pub struct MaybeCrossThread<P> {\n     cross_thread: bool,\n     marker: PhantomData<P>,\n@@ -165,7 +198,7 @@ where\n         run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n         force_show_panics: bool,\n     ) -> Buffer {\n-        if self.cross_thread {\n+        if self.cross_thread || ALREADY_RUNNING_SAME_THREAD.get() {\n             <CrossThread<P>>::new().run_bridge_and_client(\n                 dispatcher,\n                 input,\n@@ -188,6 +221,8 @@ impl ExecutionStrategy for SameThread {\n         run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n         force_show_panics: bool,\n     ) -> Buffer {\n+        let _guard = RunningSameThreadGuard::new();\n+\n         let mut dispatch = |buf| dispatcher.dispatch(buf);\n \n         run_client(BridgeConfig {"}, {"sha": "1d6ef8a13610a1be1294e9af0943f5da4f7e94e3", "filename": "src/test/ui/proc-macro/auxiliary/expand-expr.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/efda49712b35009c0096217ce2aa262fc5ab8174/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fexpand-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efda49712b35009c0096217ce2aa262fc5ab8174/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fexpand-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fexpand-expr.rs?ref=efda49712b35009c0096217ce2aa262fc5ab8174", "patch": "@@ -80,13 +80,21 @@ fn assert_ts_eq(lhs: &TokenStream, rhs: &TokenStream) {\n pub fn expand_expr_is(input: TokenStream) -> TokenStream {\n     let mut iter = input.into_iter();\n     let mut expected_tts = Vec::new();\n-    loop {\n+    let comma = loop {\n         match iter.next() {\n-            Some(TokenTree::Punct(ref p)) if p.as_char() == ',' => break,\n+            Some(TokenTree::Punct(p)) if p.as_char() == ',' => break p,\n             Some(tt) => expected_tts.push(tt),\n             None => panic!(\"expected comma\"),\n         }\n-    }\n+    };\n+\n+    // Make sure that `Ident` and `Literal` objects from this proc-macro's\n+    // environment are not invalidated when `expand_expr` recursively invokes\n+    // another macro by taking a local copy, and checking it after the fact.\n+    let pre_expand_span = comma.span();\n+    let pre_expand_ident = Ident::new(\"ident\", comma.span());\n+    let pre_expand_literal = Literal::string(\"literal\");\n+    let pre_expand_call_site = Span::call_site();\n \n     let expected = expected_tts.into_iter().collect::<TokenStream>();\n     let expanded = iter.collect::<TokenStream>().expand_expr().expect(\"expand_expr failed\");\n@@ -100,6 +108,15 @@ pub fn expand_expr_is(input: TokenStream) -> TokenStream {\n     // Also compare the raw tts to make sure they line up.\n     assert_ts_eq(&expected, &expanded);\n \n+    assert!(comma.span().eq(&pre_expand_span), \"pre-expansion span is still equal\");\n+    assert_eq!(pre_expand_ident.to_string(), \"ident\", \"pre-expansion identifier is still valid\");\n+    assert_eq!(\n+        pre_expand_literal.to_string(),\n+        \"\\\"literal\\\"\",\n+        \"pre-expansion literal is still valid\"\n+    );\n+    assert!(Span::call_site().eq(&pre_expand_call_site), \"pre-expansion call-site is still equal\");\n+\n     TokenStream::new()\n }\n "}]}