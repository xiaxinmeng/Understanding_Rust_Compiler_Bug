{"sha": "43221a684db39d6f9b72db9f099c24e8e51f1dc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMjIxYTY4NGRiMzlkNmY5YjcyZGI5ZjA5OWMyNGU4ZTUxZjFkYzQ=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-22T20:10:43Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-26T11:11:11Z"}, "message": "Move a function to make its adjacent impl block easier to discover", "tree": {"sha": "c14c627fa3fa5cce1d28a178df9aa5acc84a7d8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c14c627fa3fa5cce1d28a178df9aa5acc84a7d8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43221a684db39d6f9b72db9f099c24e8e51f1dc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43221a684db39d6f9b72db9f099c24e8e51f1dc4", "html_url": "https://github.com/rust-lang/rust/commit/43221a684db39d6f9b72db9f099c24e8e51f1dc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43221a684db39d6f9b72db9f099c24e8e51f1dc4/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eea51e34275086158af22de1b55a4fd0bd39a4a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/eea51e34275086158af22de1b55a4fd0bd39a4a3", "html_url": "https://github.com/rust-lang/rust/commit/eea51e34275086158af22de1b55a4fd0bd39a4a3"}], "stats": {"total": 82, "additions": 43, "deletions": 39}, "files": [{"sha": "115511fa70a0075568ef0e22ce71a7dbabbd02f5", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 43, "deletions": 39, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/43221a684db39d6f9b72db9f099c24e8e51f1dc4/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43221a684db39d6f9b72db9f099c24e8e51f1dc4/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=43221a684db39d6f9b72db9f099c24e8e51f1dc4", "patch": "@@ -17,6 +17,46 @@ use crate::interpret::{\n \n use super::error::*;\n \n+impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n+    /// Evaluate a const function where all arguments (if any) are zero-sized types.\n+    /// The evaluation is memoized thanks to the query system.\n+    ///\n+    /// Returns `true` if the call has been evaluated.\n+    fn try_eval_const_fn_call(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        args: &[OpTy<'tcx>],\n+    ) -> InterpResult<'tcx, bool> {\n+        trace!(\"try_eval_const_fn_call: {:?}\", instance);\n+        // Because `#[track_caller]` adds an implicit non-ZST argument, we also cannot\n+        // perform this optimization on items tagged with it.\n+        if instance.def.requires_caller_location(self.tcx()) {\n+            return Ok(false);\n+        }\n+        // For the moment we only do this for functions which take no arguments\n+        // (or all arguments are ZSTs) so that we don't memoize too much.\n+        if args.iter().any(|a| !a.layout.is_zst()) {\n+            return Ok(false);\n+        }\n+\n+        let gid = GlobalId { instance, promoted: None };\n+\n+        let place = self.const_eval_raw(gid)?;\n+        let dest = match ret {\n+            Some((dest, _)) => dest,\n+            // Don't memoize diverging function calls.\n+            None => return Ok(false),\n+        };\n+\n+        self.copy_op(place.into(), dest)?;\n+\n+        self.return_to_block(ret.map(|r| r.1))?;\n+        self.dump_place(*dest);\n+        return Ok(true);\n+    }\n+}\n+\n /// Number of steps until the detector even starts doing anything.\n /// Also, a warning is shown to the user when this number is reached.\n const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n@@ -318,42 +358,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n }\n \n-impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n-    /// Evaluate a const function where all arguments (if any) are zero-sized types.\n-    /// The evaluation is memoized thanks to the query system.\n-    ///\n-    /// Returns `true` if the call has been evaluated.\n-    fn try_eval_const_fn_call(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        args: &[OpTy<'tcx>],\n-    ) -> InterpResult<'tcx, bool> {\n-        trace!(\"try_eval_const_fn_call: {:?}\", instance);\n-        // Because `#[track_caller]` adds an implicit non-ZST argument, we also cannot\n-        // perform this optimization on items tagged with it.\n-        if instance.def.requires_caller_location(self.tcx()) {\n-            return Ok(false);\n-        }\n-        // For the moment we only do this for functions which take no arguments\n-        // (or all arguments are ZSTs) so that we don't memoize too much.\n-        if args.iter().any(|a| !a.layout.is_zst()) {\n-            return Ok(false);\n-        }\n-\n-        let gid = GlobalId { instance, promoted: None };\n-\n-        let place = self.const_eval_raw(gid)?;\n-        let dest = match ret {\n-            Some((dest, _)) => dest,\n-            // Don't memoize diverging function calls.\n-            None => return Ok(false),\n-        };\n-\n-        self.copy_op(place.into(), dest)?;\n-\n-        self.return_to_block(ret.map(|r| r.1))?;\n-        self.dump_place(*dest);\n-        return Ok(true);\n-    }\n-}\n+// Please do not add any code below the above `Machine` trait impl. I (oli-obk) plan more cleanups\n+// so we can end up having a file with just that impl, but for now, let's keep the impl discoverable\n+// at the bottom of this file."}]}