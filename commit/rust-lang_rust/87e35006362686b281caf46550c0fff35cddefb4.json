{"sha": "87e35006362686b281caf46550c0fff35cddefb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ZTM1MDA2MzYyNjg2YjI4MWNhZjQ2NTUwYzBmZmYzNWNkZGVmYjQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-12-08T18:13:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-08T18:13:54Z"}, "message": "Merge #6765\n\n6765: Fix file range computation in macros r=jonas-schievink a=jonas-schievink\n\nThis also aligns the diagnostics behavior of `TestDB` with the one from the real IDE (by making the logic from `semantics.rs` a method on `InFile<&SyntaxNode>`), which makes bugs like this easier to find.\r\n\r\nThis should fix the misplaced diagnostics seen in https://github.com/rust-analyzer/rust-analyzer/issues/6747 and other issues.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "67b9f5e41749a89b85b3f4ce49fec62b4a85da82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67b9f5e41749a89b85b3f4ce49fec62b4a85da82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87e35006362686b281caf46550c0fff35cddefb4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfz8JiCRBK7hj4Ov3rIwAAdHIIAKsTmZb9e+/n8754u7rhl7ya\nda5MoqGlno7VVenlh+Bl+ZyB8tw4lzrfKNzMsZAhYK8OEQTwjlSiwukNnlBx1TMw\nfZ0ZAo6yGR1mpco7xKvlDdIaoeqLWF/51OFRgRvnHLnA7o+NbmtS2Srorjfgr5Z+\nuM7J7SZt+PCR9EUwTW4Vl+rYRkoK9nZFxUW8vXXMGD0YkP7n69rFhO+mTvjuPLGT\nNV0hX7N+Ne3UyjGGA62CznJdcnI2BzRA0s6etSNfOyqM+EAQT2goDw8U3cf2JIyR\nyhx9z1JzpzyfZ506oY1AZAULPQD5FUuuO/oivQqHssEGMWw1oVAmt6XxFi2Tnz0=\n=u2Je\n-----END PGP SIGNATURE-----\n", "payload": "tree 67b9f5e41749a89b85b3f4ce49fec62b4a85da82\nparent b01981e6364a9de26a52adefac10e7aebfb85874\nparent da5027138d93c59aeb25aab5021276969f074992\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1607451234 +0000\ncommitter GitHub <noreply@github.com> 1607451234 +0000\n\nMerge #6765\n\n6765: Fix file range computation in macros r=jonas-schievink a=jonas-schievink\n\nThis also aligns the diagnostics behavior of `TestDB` with the one from the real IDE (by making the logic from `semantics.rs` a method on `InFile<&SyntaxNode>`), which makes bugs like this easier to find.\r\n\r\nThis should fix the misplaced diagnostics seen in https://github.com/rust-analyzer/rust-analyzer/issues/6747 and other issues.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87e35006362686b281caf46550c0fff35cddefb4", "html_url": "https://github.com/rust-lang/rust/commit/87e35006362686b281caf46550c0fff35cddefb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87e35006362686b281caf46550c0fff35cddefb4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b01981e6364a9de26a52adefac10e7aebfb85874", "url": "https://api.github.com/repos/rust-lang/rust/commits/b01981e6364a9de26a52adefac10e7aebfb85874", "html_url": "https://github.com/rust-lang/rust/commit/b01981e6364a9de26a52adefac10e7aebfb85874"}, {"sha": "da5027138d93c59aeb25aab5021276969f074992", "url": "https://api.github.com/repos/rust-lang/rust/commits/da5027138d93c59aeb25aab5021276969f074992", "html_url": "https://github.com/rust-lang/rust/commit/da5027138d93c59aeb25aab5021276969f074992"}], "stats": {"total": 187, "additions": 89, "deletions": 98}, "files": [{"sha": "302a524918a61a69d4bff808c46bbd599c9d6f98", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87e35006362686b281caf46550c0fff35cddefb4/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e35006362686b281caf46550c0fff35cddefb4/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=87e35006362686b281caf46550c0fff35cddefb4", "patch": "@@ -39,7 +39,7 @@ pub use crate::{\n         Struct, Trait, Type, TypeAlias, TypeParam, Union, VariantDef,\n     },\n     has_source::HasSource,\n-    semantics::{original_range, PathResolution, Semantics, SemanticsScope},\n+    semantics::{PathResolution, Semantics, SemanticsScope},\n };\n \n pub use hir_def::{"}, {"sha": "4315ad48b9c4b31b7736b22fdc11bde73c68485e", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 4, "deletions": 72, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/87e35006362686b281caf46550c0fff35cddefb4/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e35006362686b281caf46550c0fff35cddefb4/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=87e35006362686b281caf46550c0fff35cddefb4", "patch": "@@ -13,10 +13,7 @@ use hir_expand::{hygiene::Hygiene, name::AsName, ExpansionInfo};\n use hir_ty::associated_type_shorthand_candidates;\n use itertools::Itertools;\n use rustc_hash::{FxHashMap, FxHashSet};\n-use syntax::{\n-    algo::{find_node_at_offset, skip_trivia_token},\n-    ast, AstNode, Direction, SyntaxNode, SyntaxToken, TextRange, TextSize,\n-};\n+use syntax::{algo::find_node_at_offset, ast, AstNode, SyntaxNode, SyntaxToken, TextSize};\n \n use crate::{\n     code_model::Access,\n@@ -25,7 +22,7 @@ use crate::{\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, SourceAnalyzer},\n     AssocItem, Callable, Crate, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef,\n-    Module, ModuleDef, Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, VariantDef,\n+    Module, ModuleDef, Name, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, VariantDef,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -372,15 +369,15 @@ impl<'db> SemanticsImpl<'db> {\n \n     fn original_range(&self, node: &SyntaxNode) -> FileRange {\n         let node = self.find_file(node.clone());\n-        original_range(self.db, node.as_ref())\n+        node.as_ref().original_file_range(self.db.upcast())\n     }\n \n     fn diagnostics_display_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n         let src = diagnostics.display_source();\n         let root = self.db.parse_or_expand(src.file_id).unwrap();\n         let node = src.value.to_node(&root);\n         self.cache(root, src.file_id);\n-        original_range(self.db, src.with_value(&node))\n+        src.with_value(&node).original_file_range(self.db.upcast())\n     }\n \n     fn ancestors_with_macros(&self, node: SyntaxNode) -> impl Iterator<Item = SyntaxNode> + '_ {\n@@ -771,68 +768,3 @@ impl<'a> SemanticsScope<'a> {\n         resolve_hir_path(self.db, &self.resolver, &path)\n     }\n }\n-\n-// FIXME: Change `HasSource` trait to work with `Semantics` and remove this?\n-pub fn original_range(db: &dyn HirDatabase, node: InFile<&SyntaxNode>) -> FileRange {\n-    if let Some(range) = original_range_opt(db, node) {\n-        let original_file = range.file_id.original_file(db.upcast());\n-        if range.file_id == original_file.into() {\n-            return FileRange { file_id: original_file, range: range.value };\n-        }\n-\n-        log::error!(\"Fail to mapping up more for {:?}\", range);\n-        return FileRange { file_id: range.file_id.original_file(db.upcast()), range: range.value };\n-    }\n-\n-    // Fall back to whole macro call\n-    if let Some(expansion) = node.file_id.expansion_info(db.upcast()) {\n-        if let Some(call_node) = expansion.call_node() {\n-            return FileRange {\n-                file_id: call_node.file_id.original_file(db.upcast()),\n-                range: call_node.value.text_range(),\n-            };\n-        }\n-    }\n-\n-    FileRange { file_id: node.file_id.original_file(db.upcast()), range: node.value.text_range() }\n-}\n-\n-fn original_range_opt(\n-    db: &dyn HirDatabase,\n-    node: InFile<&SyntaxNode>,\n-) -> Option<InFile<TextRange>> {\n-    let expansion = node.file_id.expansion_info(db.upcast())?;\n-\n-    // the input node has only one token ?\n-    let single = skip_trivia_token(node.value.first_token()?, Direction::Next)?\n-        == skip_trivia_token(node.value.last_token()?, Direction::Prev)?;\n-\n-    Some(node.value.descendants().find_map(|it| {\n-        let first = skip_trivia_token(it.first_token()?, Direction::Next)?;\n-        let first = ascend_call_token(db, &expansion, node.with_value(first))?;\n-\n-        let last = skip_trivia_token(it.last_token()?, Direction::Prev)?;\n-        let last = ascend_call_token(db, &expansion, node.with_value(last))?;\n-\n-        if (!single && first == last) || (first.file_id != last.file_id) {\n-            return None;\n-        }\n-\n-        Some(first.with_value(first.value.text_range().cover(last.value.text_range())))\n-    })?)\n-}\n-\n-fn ascend_call_token(\n-    db: &dyn HirDatabase,\n-    expansion: &ExpansionInfo,\n-    token: InFile<SyntaxToken>,\n-) -> Option<InFile<SyntaxToken>> {\n-    let (mapped, origin) = expansion.map_token_up(token.as_ref())?;\n-    if origin != Origin::Call {\n-        return None;\n-    }\n-    if let Some(info) = mapped.file_id.expansion_info(db.upcast()) {\n-        return ascend_call_token(db, &info, mapped);\n-    }\n-    Some(mapped)\n-}"}, {"sha": "f8b150850819e7a28702b9fae046c90ec6332002", "filename": "crates/hir_def/src/test_db.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87e35006362686b281caf46550c0fff35cddefb4/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e35006362686b281caf46550c0fff35cddefb4/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftest_db.rs?ref=87e35006362686b281caf46550c0fff35cddefb4", "patch": "@@ -158,17 +158,11 @@ impl TestDB {\n             let src = d.display_source();\n             let root = db.parse_or_expand(src.file_id).unwrap();\n \n-            // Place all diagnostics emitted in macro files on the original caller.\n-            // Note that this does *not* match IDE behavior.\n-            let mut src = src.map(|ptr| ptr.to_node(&root));\n-            while let Some(exp) = src.file_id.call_node(db) {\n-                src = exp;\n-            }\n+            let node = src.map(|ptr| ptr.to_node(&root));\n+            let frange = node.as_ref().original_file_range(db);\n \n-            let file_id = src.file_id.original_file(db);\n-            let range = src.value.text_range();\n             let message = d.message().to_owned();\n-            actual.entry(file_id).or_default().push((range, message));\n+            actual.entry(frange.file_id).or_default().push((frange.range, message));\n         });\n \n         for (file_id, diags) in actual.iter_mut() {"}, {"sha": "1a942851434b750c37bd295d064a3d73eaeed15e", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 67, "deletions": 3, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/87e35006362686b281caf46550c0fff35cddefb4/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e35006362686b281caf46550c0fff35cddefb4/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=87e35006362686b281caf46550c0fff35cddefb4", "patch": "@@ -20,11 +20,11 @@ pub use mbe::{ExpandError, ExpandResult};\n use std::hash::Hash;\n use std::sync::Arc;\n \n-use base_db::{impl_intern_key, salsa, CrateId, FileId};\n+use base_db::{impl_intern_key, salsa, CrateId, FileId, FileRange};\n use syntax::{\n-    algo,\n+    algo::{self, skip_trivia_token},\n     ast::{self, AstNode},\n-    SyntaxNode, SyntaxToken, TextSize,\n+    Direction, SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::ast_id_map::FileAstId;\n@@ -445,6 +445,70 @@ impl InFile<SyntaxNode> {\n     }\n }\n \n+impl<'a> InFile<&'a SyntaxNode> {\n+    pub fn original_file_range(self, db: &dyn db::AstDatabase) -> FileRange {\n+        if let Some(range) = original_range_opt(db, self) {\n+            let original_file = range.file_id.original_file(db);\n+            if range.file_id == original_file.into() {\n+                return FileRange { file_id: original_file, range: range.value };\n+            }\n+\n+            log::error!(\"Fail to mapping up more for {:?}\", range);\n+            return FileRange { file_id: range.file_id.original_file(db), range: range.value };\n+        }\n+\n+        // Fall back to whole macro call.\n+        let mut node = self.cloned();\n+        while let Some(call_node) = node.file_id.call_node(db) {\n+            node = call_node;\n+        }\n+\n+        let orig_file = node.file_id.original_file(db);\n+        assert_eq!(node.file_id, orig_file.into());\n+        FileRange { file_id: orig_file, range: node.value.text_range() }\n+    }\n+}\n+\n+fn original_range_opt(\n+    db: &dyn db::AstDatabase,\n+    node: InFile<&SyntaxNode>,\n+) -> Option<InFile<TextRange>> {\n+    let expansion = node.file_id.expansion_info(db)?;\n+\n+    // the input node has only one token ?\n+    let single = skip_trivia_token(node.value.first_token()?, Direction::Next)?\n+        == skip_trivia_token(node.value.last_token()?, Direction::Prev)?;\n+\n+    Some(node.value.descendants().find_map(|it| {\n+        let first = skip_trivia_token(it.first_token()?, Direction::Next)?;\n+        let first = ascend_call_token(db, &expansion, node.with_value(first))?;\n+\n+        let last = skip_trivia_token(it.last_token()?, Direction::Prev)?;\n+        let last = ascend_call_token(db, &expansion, node.with_value(last))?;\n+\n+        if (!single && first == last) || (first.file_id != last.file_id) {\n+            return None;\n+        }\n+\n+        Some(first.with_value(first.value.text_range().cover(last.value.text_range())))\n+    })?)\n+}\n+\n+fn ascend_call_token(\n+    db: &dyn db::AstDatabase,\n+    expansion: &ExpansionInfo,\n+    token: InFile<SyntaxToken>,\n+) -> Option<InFile<SyntaxToken>> {\n+    let (mapped, origin) = expansion.map_token_up(token.as_ref())?;\n+    if origin != Origin::Call {\n+        return None;\n+    }\n+    if let Some(info) = mapped.file_id.expansion_info(db) {\n+        return ascend_call_token(db, &info, mapped);\n+    }\n+    Some(mapped)\n+}\n+\n impl InFile<SyntaxToken> {\n     pub fn ancestors_with_macros(\n         self,"}, {"sha": "4790d648a8899069ff917ea8d713130eebb74afb", "filename": "crates/ide/src/display/navigation_target.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/87e35006362686b281caf46550c0fff35cddefb4/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e35006362686b281caf46550c0fff35cddefb4/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=87e35006362686b281caf46550c0fff35cddefb4", "patch": "@@ -1,7 +1,7 @@\n //! FIXME: write short doc here\n \n use either::Either;\n-use hir::{original_range, AssocItem, FieldSource, HasSource, InFile, ModuleSource};\n+use hir::{AssocItem, FieldSource, HasSource, InFile, ModuleSource};\n use ide_db::base_db::{FileId, SourceDatabase};\n use ide_db::{defs::Definition, RootDatabase};\n use syntax::{\n@@ -62,7 +62,8 @@ impl NavigationTarget {\n     pub(crate) fn from_module_to_decl(db: &RootDatabase, module: hir::Module) -> NavigationTarget {\n         let name = module.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n         if let Some(src) = module.declaration_source(db) {\n-            let frange = original_range(db, src.as_ref().map(|it| it.syntax()));\n+            let node = src.as_ref().map(|it| it.syntax());\n+            let frange = node.original_file_range(db);\n             let mut res = NavigationTarget::from_syntax(\n                 frange.file_id,\n                 name,\n@@ -104,8 +105,8 @@ impl NavigationTarget {\n         let name =\n             node.value.name().map(|it| it.text().clone()).unwrap_or_else(|| SmolStr::new(\"_\"));\n         let focus_range =\n-            node.value.name().map(|it| original_range(db, node.with_value(it.syntax())).range);\n-        let frange = original_range(db, node.map(|it| it.syntax()));\n+            node.value.name().map(|it| node.with_value(it.syntax()).original_file_range(db).range);\n+        let frange = node.map(|it| it.syntax()).original_file_range(db);\n \n         NavigationTarget::from_syntax(\n             frange.file_id,\n@@ -124,7 +125,7 @@ impl NavigationTarget {\n     ) -> NavigationTarget {\n         let name =\n             named.value.name().map(|it| it.text().clone()).unwrap_or_else(|| SmolStr::new(\"_\"));\n-        let frange = original_range(db, node.map(|it| it.syntax()));\n+        let frange = node.map(|it| it.syntax()).original_file_range(db);\n \n         NavigationTarget::from_syntax(\n             frange.file_id,\n@@ -236,7 +237,7 @@ impl ToNav for hir::Module {\n                 (node.syntax(), node.name().map(|it| it.syntax().text_range()))\n             }\n         };\n-        let frange = original_range(db, src.with_value(syntax));\n+        let frange = src.with_value(syntax).original_file_range(db);\n         NavigationTarget::from_syntax(frange.file_id, name, focus, frange.range, syntax.kind())\n     }\n }\n@@ -246,14 +247,14 @@ impl ToNav for hir::ImplDef {\n         let src = self.source(db);\n         let derive_attr = self.is_builtin_derive(db);\n         let frange = if let Some(item) = &derive_attr {\n-            original_range(db, item.syntax())\n+            item.syntax().original_file_range(db)\n         } else {\n-            original_range(db, src.as_ref().map(|it| it.syntax()))\n+            src.as_ref().map(|it| it.syntax()).original_file_range(db)\n         };\n         let focus_range = if derive_attr.is_some() {\n             None\n         } else {\n-            src.value.self_ty().map(|ty| original_range(db, src.with_value(ty.syntax())).range)\n+            src.value.self_ty().map(|ty| src.with_value(ty.syntax()).original_file_range(db).range)\n         };\n \n         NavigationTarget::from_syntax(\n@@ -278,7 +279,7 @@ impl ToNav for hir::Field {\n                 res\n             }\n             FieldSource::Pos(it) => {\n-                let frange = original_range(db, src.with_value(it.syntax()));\n+                let frange = src.with_value(it.syntax()).original_file_range(db);\n                 NavigationTarget::from_syntax(\n                     frange.file_id,\n                     \"\".into(),\n@@ -331,7 +332,7 @@ impl ToNav for hir::Local {\n             }\n             Either::Right(it) => it.syntax().clone(),\n         };\n-        let full_range = original_range(db, src.with_value(&node));\n+        let full_range = src.with_value(&node).original_file_range(db);\n         let name = match self.name(db) {\n             Some(it) => it.to_string().into(),\n             None => \"\".into(),"}, {"sha": "58d284d4717b7abcd1df829481519fd749c309b8", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87e35006362686b281caf46550c0fff35cddefb4/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e35006362686b281caf46550c0fff35cddefb4/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=87e35006362686b281caf46550c0fff35cddefb4", "patch": "@@ -8,7 +8,7 @@ use std::{\n \n use hir::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n-    original_range, AssocItem, Crate, HasSource, HirDisplay, ModuleDef,\n+    AssocItem, Crate, HasSource, HirDisplay, ModuleDef,\n };\n use hir_def::FunctionId;\n use hir_ty::{Ty, TypeWalk};\n@@ -232,7 +232,7 @@ impl AnalysisStatsCmd {\n                             // But also, we should just turn the type mismatches into diagnostics and provide these\n                             let root = db.parse_or_expand(src.file_id).unwrap();\n                             let node = src.map(|e| e.to_node(&root).syntax().clone());\n-                            let original_range = original_range(db, node.as_ref());\n+                            let original_range = node.as_ref().original_file_range(db);\n                             let path = vfs.file_path(original_range.file_id);\n                             let line_index =\n                                 host.analysis().file_line_index(original_range.file_id).unwrap();"}]}