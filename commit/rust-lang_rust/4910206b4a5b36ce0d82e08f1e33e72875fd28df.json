{"sha": "4910206b4a5b36ce0d82e08f1e33e72875fd28df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5MTAyMDZiNGE1YjM2Y2UwZDgyZTA4ZjFlMzNlNzI4NzVmZDI4ZGY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-19T16:15:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-19T16:15:06Z"}, "message": "Rollup merge of #73261 - estebank:generics-sized, r=nikomatsakis\n\nSuggest `?Sized` when applicable for ADTs\n\nAddress #71790, fix #27964.", "tree": {"sha": "d8e7dbb9c3f5a5a5159a47c8543ba9f225550a27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8e7dbb9c3f5a5a5159a47c8543ba9f225550a27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4910206b4a5b36ce0d82e08f1e33e72875fd28df", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe7OSKCRBK7hj4Ov3rIwAAdHIIAEa9pTqw/vMB4ALtn91eJgOE\nY4FMvpcjzWim5gM26FYupHRtNBScj2Cg5XwZTnPq1ZUHOe4DHcslmCR/55xxdEZV\nT1SBeL6pnTrvThfAVFEoPg2amUOHHgqsefewUPhfy3+jLKmawrgz9B6GNT0nsZLl\nRD6kzMVEggu5f2icGBTLehR9m0oMJpoftw4jfkI3Nj/KzEBhh+C5OqxBLAFMSpv4\nWbnWFentMhUAiSbn4a+7CFKzJR4SdqVAkNsdejf7B2gq/M/ABUgVGBPC/S2vtYwj\n+Bt2X76Gakw2IMeBMRvio87Kn9A4Vs8ZQVmWimFZEHpoODMahg4sI/ApES4+ojs=\n=/uN2\n-----END PGP SIGNATURE-----\n", "payload": "tree d8e7dbb9c3f5a5a5159a47c8543ba9f225550a27\nparent 17064dae1a91fb7a96f68508a052826d0f4e1d8a\nparent 40b27ff5f3828abd8d1ab951853bf70b5fbf6ed5\nauthor Manish Goregaokar <manishsmail@gmail.com> 1592583306 -0700\ncommitter GitHub <noreply@github.com> 1592583306 -0700\n\nRollup merge of #73261 - estebank:generics-sized, r=nikomatsakis\n\nSuggest `?Sized` when applicable for ADTs\n\nAddress #71790, fix #27964.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4910206b4a5b36ce0d82e08f1e33e72875fd28df", "html_url": "https://github.com/rust-lang/rust/commit/4910206b4a5b36ce0d82e08f1e33e72875fd28df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4910206b4a5b36ce0d82e08f1e33e72875fd28df/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17064dae1a91fb7a96f68508a052826d0f4e1d8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/17064dae1a91fb7a96f68508a052826d0f4e1d8a", "html_url": "https://github.com/rust-lang/rust/commit/17064dae1a91fb7a96f68508a052826d0f4e1d8a"}, {"sha": "40b27ff5f3828abd8d1ab951853bf70b5fbf6ed5", "url": "https://api.github.com/repos/rust-lang/rust/commits/40b27ff5f3828abd8d1ab951853bf70b5fbf6ed5", "html_url": "https://github.com/rust-lang/rust/commit/40b27ff5f3828abd8d1ab951853bf70b5fbf6ed5"}], "stats": {"total": 386, "additions": 352, "deletions": 34}, "files": [{"sha": "e7d63c138f3976bcf1de64f61d84674285930fa1", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -2741,14 +2741,8 @@ impl Node<'_> {\n     pub fn generics(&self) -> Option<&Generics<'_>> {\n         match self {\n             Node::TraitItem(TraitItem { generics, .. })\n-            | Node::ImplItem(ImplItem { generics, .. })\n-            | Node::Item(Item {\n-                kind:\n-                    ItemKind::Trait(_, _, generics, ..)\n-                    | ItemKind::Impl { generics, .. }\n-                    | ItemKind::Fn(_, generics, _),\n-                ..\n-            }) => Some(generics),\n+            | Node::ImplItem(ImplItem { generics, .. }) => Some(generics),\n+            Node::Item(item) => item.kind.generics(),\n             _ => None,\n         }\n     }"}, {"sha": "060877f80adefd9dc6b1fb0c563f5159a5cabdc5", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 130, "deletions": 26, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n@@ -25,7 +26,7 @@ use rustc_middle::ty::{\n     TypeFoldable, WithConstness,\n };\n use rustc_session::DiagnosticMessageId;\n-use rustc_span::{ExpnKind, Span, DUMMY_SP};\n+use rustc_span::{ExpnKind, MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n \n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -1695,36 +1696,95 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n-        if let (\n-            ty::PredicateKind::Trait(pred, _),\n-            ObligationCauseCode::BindingObligation(item_def_id, span),\n-        ) = (obligation.predicate.kind(), &obligation.cause.code)\n-        {\n-            if let (Some(generics), true) = (\n-                self.tcx.hir().get_if_local(*item_def_id).as_ref().and_then(|n| n.generics()),\n-                Some(pred.def_id()) == self.tcx.lang_items().sized_trait(),\n-            ) {\n-                for param in generics.params {\n-                    if param.span == *span\n-                        && !param.bounds.iter().any(|bound| {\n-                            bound.trait_ref().and_then(|trait_ref| trait_ref.trait_def_id())\n-                                == self.tcx.lang_items().sized_trait()\n-                        })\n-                    {\n-                        let (span, separator) = match param.bounds {\n-                            [] => (span.shrink_to_hi(), \":\"),\n-                            [.., bound] => (bound.span().shrink_to_hi(), \" +\"),\n-                        };\n-                        err.span_suggestion_verbose(\n-                            span,\n-                            \"consider relaxing the implicit `Sized` restriction\",\n-                            format!(\"{} ?Sized\", separator),\n-                            Applicability::MachineApplicable,\n+        let (pred, item_def_id, span) =\n+            match (obligation.predicate.kind(), &obligation.cause.code.peel_derives()) {\n+                (\n+                    ty::PredicateKind::Trait(pred, _),\n+                    ObligationCauseCode::BindingObligation(item_def_id, span),\n+                ) => (pred, item_def_id, span),\n+                _ => return,\n+            };\n+\n+        let node = match (\n+            self.tcx.hir().get_if_local(*item_def_id),\n+            Some(pred.def_id()) == self.tcx.lang_items().sized_trait(),\n+        ) {\n+            (Some(node), true) => node,\n+            _ => return,\n+        };\n+        let generics = match node.generics() {\n+            Some(generics) => generics,\n+            None => return,\n+        };\n+        for param in generics.params {\n+            if param.span != *span\n+                || param.bounds.iter().any(|bound| {\n+                    bound.trait_ref().and_then(|trait_ref| trait_ref.trait_def_id())\n+                        == self.tcx.lang_items().sized_trait()\n+                })\n+            {\n+                continue;\n+            }\n+            match node {\n+                hir::Node::Item(\n+                    item\n+                    @\n+                    hir::Item {\n+                        kind:\n+                            hir::ItemKind::Enum(..)\n+                            | hir::ItemKind::Struct(..)\n+                            | hir::ItemKind::Union(..),\n+                        ..\n+                    },\n+                ) => {\n+                    // Suggesting `T: ?Sized` is only valid in an ADT if `T` is only used in a\n+                    // borrow. `struct S<'a, T: ?Sized>(&'a T);` is valid, `struct S<T: ?Sized>(T);`\n+                    // is not.\n+                    let mut visitor = FindTypeParam {\n+                        param: param.name.ident().name,\n+                        invalid_spans: vec![],\n+                        nested: false,\n+                    };\n+                    visitor.visit_item(item);\n+                    if !visitor.invalid_spans.is_empty() {\n+                        let mut multispan: MultiSpan = param.span.into();\n+                        multispan.push_span_label(\n+                            param.span,\n+                            format!(\"this could be changed to `{}: ?Sized`...\", param.name.ident()),\n+                        );\n+                        for sp in visitor.invalid_spans {\n+                            multispan.push_span_label(\n+                                sp,\n+                                format!(\n+                                    \"...if indirection was used here: `Box<{}>`\",\n+                                    param.name.ident(),\n+                                ),\n+                            );\n+                        }\n+                        err.span_help(\n+                            multispan,\n+                            &format!(\n+                                \"you could relax the implicit `Sized` bound on `{T}` if it were \\\n+                                 used through indirection like `&{T}` or `Box<{T}>`\",\n+                                T = param.name.ident(),\n+                            ),\n                         );\n                         return;\n                     }\n                 }\n+                _ => {}\n             }\n+            let (span, separator) = match param.bounds {\n+                [] => (span.shrink_to_hi(), \":\"),\n+                [.., bound] => (bound.span().shrink_to_hi(), \" +\"),\n+            };\n+            err.span_suggestion_verbose(\n+                span,\n+                \"consider relaxing the implicit `Sized` restriction\",\n+                format!(\"{} ?Sized\", separator),\n+                Applicability::MachineApplicable,\n+            );\n+            return;\n         }\n     }\n \n@@ -1744,6 +1804,50 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n     }\n }\n \n+/// Look for type `param` in an ADT being used only through a reference to confirm that suggesting\n+/// `param: ?Sized` would be a valid constraint.\n+struct FindTypeParam {\n+    param: rustc_span::Symbol,\n+    invalid_spans: Vec<Span>,\n+    nested: bool,\n+}\n+\n+impl<'v> Visitor<'v> for FindTypeParam {\n+    type Map = rustc_hir::intravisit::ErasedMap<'v>;\n+\n+    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n+        hir::intravisit::NestedVisitorMap::None\n+    }\n+\n+    fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n+        // We collect the spans of all uses of the \"bare\" type param, like in `field: T` or\n+        // `field: (T, T)` where we could make `T: ?Sized` while skipping cases that are known to be\n+        // valid like `field: &'a T` or `field: *mut T` and cases that *might* have further `Sized`\n+        // obligations like `Box<T>` and `Vec<T>`, but we perform no extra analysis for those cases\n+        // and suggest `T: ?Sized` regardless of their obligations. This is fine because the errors\n+        // in that case should make what happened clear enough.\n+        match ty.kind {\n+            hir::TyKind::Ptr(_) | hir::TyKind::Rptr(..) | hir::TyKind::TraitObject(..) => {}\n+            hir::TyKind::Path(hir::QPath::Resolved(None, path))\n+                if path.segments.len() == 1 && path.segments[0].ident.name == self.param =>\n+            {\n+                if !self.nested {\n+                    self.invalid_spans.push(ty.span);\n+                }\n+            }\n+            hir::TyKind::Path(_) => {\n+                let prev = self.nested;\n+                self.nested = true;\n+                hir::intravisit::walk_ty(self, ty);\n+                self.nested = prev;\n+            }\n+            _ => {\n+                hir::intravisit::walk_ty(self, ty);\n+            }\n+        }\n+    }\n+}\n+\n pub fn recursive_type_with_infinite_size_error(\n     tcx: TyCtxt<'tcx>,\n     type_def_id: DefId,"}, {"sha": "006a334021b1419428d1f9813cfd2f85318e382d", "filename": "src/test/ui/dst/dst-sized-trait-param.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fdst%2Fdst-sized-trait-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fdst%2Fdst-sized-trait-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-sized-trait-param.stderr?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -9,6 +9,10 @@ LL | impl Foo<[isize]> for usize { }\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[isize]`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | trait Foo<T: ?Sized> : Sized { fn take(self, x: &T) { } } // Note: T is sized\n+   |            ^^^^^^^^\n \n error[E0277]: the size for values of type `[usize]` cannot be known at compilation time\n   --> $DIR/dst-sized-trait-param.rs:10:6"}, {"sha": "0c7995fde3273f838194afc92f360afe2fa229f0", "filename": "src/test/ui/extern/extern-types-unsized.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fextern%2Fextern-types-unsized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fextern%2Fextern-types-unsized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-types-unsized.stderr?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -26,6 +26,10 @@ LL |     assert_sized::<Foo>();\n    = help: within `Foo`, the trait `std::marker::Sized` is not implemented for `A`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `Foo`\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | fn assert_sized<T: ?Sized>() { }\n+   |                  ^^^^^^^^\n \n error[E0277]: the size for values of type `A` cannot be known at compilation time\n   --> $DIR/extern-types-unsized.rs:28:5\n@@ -39,6 +43,10 @@ LL |     assert_sized::<Bar<A>>();\n    = help: within `Bar<A>`, the trait `std::marker::Sized` is not implemented for `A`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `Bar<A>`\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | fn assert_sized<T: ?Sized>() { }\n+   |                  ^^^^^^^^\n \n error[E0277]: the size for values of type `A` cannot be known at compilation time\n   --> $DIR/extern-types-unsized.rs:31:5\n@@ -53,6 +61,10 @@ LL |     assert_sized::<Bar<Bar<A>>>();\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `Bar<A>`\n    = note: required because it appears within the type `Bar<Bar<A>>`\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | fn assert_sized<T: ?Sized>() { }\n+   |                  ^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "d7a4bf4f21f18dc946084e62b64fa2ce0796d2f8", "filename": "src/test/ui/issues/issue-10412.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -57,6 +57,10 @@ LL | impl<'self> Serializable<str> for &'self str {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | trait Serializable<'self, T: ?Sized> {\n+   |                            ^^^^^^^^\n \n error: aborting due to 9 previous errors\n "}, {"sha": "383cdd4979ad9ad46007915e25745e81e3b2d847", "filename": "src/test/ui/issues/issue-18919.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fissues%2Fissue-18919.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fissues%2Fissue-18919.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18919.stderr?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -9,6 +9,13 @@ LL | enum Option<T> {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `dyn for<'r> std::ops::Fn(&'r isize) -> isize`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `T` if it were used through indirection like `&T` or `Box<T>`\n+  --> $DIR/issue-18919.rs:7:13\n+   |\n+LL | enum Option<T> {\n+   |             ^ this could be changed to `T: ?Sized`...\n+LL |     Some(T),\n+   |          - ...if indirection was used here: `Box<T>`\n \n error: aborting due to previous error\n "}, {"sha": "cffa52361696c93c21c41727c3a2befab1c64466", "filename": "src/test/ui/issues/issue-23281.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fissues%2Fissue-23281.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fissues%2Fissue-23281.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23281.stderr?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -9,6 +9,13 @@ LL | struct Vec<T> {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn std::ops::Fn() + 'static)`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `T` if it were used through indirection like `&T` or `Box<T>`\n+  --> $DIR/issue-23281.rs:8:12\n+   |\n+LL | struct Vec<T> {\n+   |            ^ this could be changed to `T: ?Sized`...\n+LL |     t: T,\n+   |        - ...if indirection was used here: `Box<T>`\n \n error: aborting due to previous error\n "}, {"sha": "ef64d799b65cfcbd374320406dee2b2cd33eef8f", "filename": "src/test/ui/suggestions/adt-param-with-implicit-sized-bound.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.rs?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -0,0 +1,28 @@\n+trait Trait {\n+    fn func1() -> Struct1<Self>; //~ ERROR E0277\n+    fn func2<'a>() -> Struct2<'a, Self>; //~ ERROR E0277\n+    fn func3() -> Struct3<Self>; //~ ERROR E0277\n+    fn func4() -> Struct4<Self>; //~ ERROR E0277\n+}\n+\n+struct Struct1<T>{\n+    _t: std::marker::PhantomData<*const T>,\n+}\n+struct Struct2<'a, T>{\n+    _t: &'a T,\n+}\n+struct Struct3<T>{\n+    _t: T,\n+}\n+\n+struct X<T>(T);\n+\n+struct Struct4<T>{\n+    _t: X<T>,\n+}\n+\n+struct Struct5<T: ?Sized>{\n+    _t: X<T>, //~ ERROR E0277\n+}\n+\n+fn main() {}"}, {"sha": "ee08f51f802703dc509c8f40536cf943db0d4be2", "filename": "src/test/ui/suggestions/adt-param-with-implicit-sized-bound.stderr", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.stderr?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -0,0 +1,107 @@\n+error[E0277]: the size for values of type `T` cannot be known at compilation time\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:25:5\n+   |\n+LL | struct X<T>(T);\n+   |          - required by this bound in `X`\n+...\n+LL | struct Struct5<T: ?Sized>{\n+   |                - this type parameter needs to be `std::marker::Sized`\n+LL |     _t: X<T>,\n+   |     ^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `T`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `T` if it were used through indirection like `&T` or `Box<T>`\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:18:10\n+   |\n+LL | struct X<T>(T);\n+   |          ^  - ...if indirection was used here: `Box<T>`\n+   |          |\n+   |          this could be changed to `T: ?Sized`...\n+\n+error[E0277]: the size for values of type `Self` cannot be known at compilation time\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:2:19\n+   |\n+LL |     fn func1() -> Struct1<Self>;\n+   |                   ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+...\n+LL | struct Struct1<T>{\n+   |                - required by this bound in `Struct1`\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `Self`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider further restricting `Self`\n+   |\n+LL |     fn func1() -> Struct1<Self> where Self: std::marker::Sized;\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | struct Struct1<T: ?Sized>{\n+   |                 ^^^^^^^^\n+\n+error[E0277]: the size for values of type `Self` cannot be known at compilation time\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:3:23\n+   |\n+LL |     fn func2<'a>() -> Struct2<'a, Self>;\n+   |                       ^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+...\n+LL | struct Struct2<'a, T>{\n+   |                    - required by this bound in `Struct2`\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `Self`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider further restricting `Self`\n+   |\n+LL |     fn func2<'a>() -> Struct2<'a, Self> where Self: std::marker::Sized;\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | struct Struct2<'a, T: ?Sized>{\n+   |                     ^^^^^^^^\n+\n+error[E0277]: the size for values of type `Self` cannot be known at compilation time\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:4:19\n+   |\n+LL |     fn func3() -> Struct3<Self>;\n+   |                   ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+...\n+LL | struct Struct3<T>{\n+   |                - required by this bound in `Struct3`\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `Self`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `T` if it were used through indirection like `&T` or `Box<T>`\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:14:16\n+   |\n+LL | struct Struct3<T>{\n+   |                ^ this could be changed to `T: ?Sized`...\n+LL |     _t: T,\n+   |         - ...if indirection was used here: `Box<T>`\n+help: consider further restricting `Self`\n+   |\n+LL |     fn func3() -> Struct3<Self> where Self: std::marker::Sized;\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: the size for values of type `Self` cannot be known at compilation time\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:5:19\n+   |\n+LL |     fn func4() -> Struct4<Self>;\n+   |                   ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+...\n+LL | struct Struct4<T>{\n+   |                - required by this bound in `Struct4`\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `Self`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider further restricting `Self`\n+   |\n+LL |     fn func4() -> Struct4<Self> where Self: std::marker::Sized;\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | struct Struct4<T: ?Sized>{\n+   |                 ^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "1908aee25ea7bf6e094db07ba296ff89b8937534", "filename": "src/test/ui/unsized/unsized-enum.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Funsized%2Funsized-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Funsized%2Funsized-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-enum.stderr?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -11,6 +11,13 @@ LL | fn foo2<T: ?Sized>() { not_sized::<Foo<T>>() }\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `U` if it were used through indirection like `&U` or `Box<U>`\n+  --> $DIR/unsized-enum.rs:4:10\n+   |\n+LL | enum Foo<U> { FooSome(U), FooNone }\n+   |          ^            - ...if indirection was used here: `Box<U>`\n+   |          |\n+   |          this could be changed to `U: ?Sized`...\n \n error: aborting due to previous error\n "}, {"sha": "e0f077d66f99c8920ea3372279d71c7706251dea", "filename": "src/test/ui/unsized/unsized-inherent-impl-self-type.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Funsized%2Funsized-inherent-impl-self-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Funsized%2Funsized-inherent-impl-self-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-inherent-impl-self-type.stderr?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -11,6 +11,13 @@ LL | impl<X: ?Sized> S5<X> {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `Y` if it were used through indirection like `&Y` or `Box<Y>`\n+  --> $DIR/unsized-inherent-impl-self-type.rs:5:11\n+   |\n+LL | struct S5<Y>(Y);\n+   |           ^  - ...if indirection was used here: `Box<Y>`\n+   |           |\n+   |           this could be changed to `Y: ?Sized`...\n \n error: aborting due to previous error\n "}, {"sha": "d92d1d9113e5c56377e8ac4415114357a52562a5", "filename": "src/test/ui/unsized/unsized-struct.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Funsized%2Funsized-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Funsized%2Funsized-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-struct.stderr?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -11,6 +11,13 @@ LL | fn foo2<T: ?Sized>() { not_sized::<Foo<T>>() }\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `T` if it were used through indirection like `&T` or `Box<T>`\n+  --> $DIR/unsized-struct.rs:4:12\n+   |\n+LL | struct Foo<T> { data: T }\n+   |            ^          - ...if indirection was used here: `Box<T>`\n+   |            |\n+   |            this could be changed to `T: ?Sized`...\n \n error[E0277]: the size for values of type `T` cannot be known at compilation time\n   --> $DIR/unsized-struct.rs:13:24"}, {"sha": "73c5439da53b67e83e3c1b66033ef78a04b7ce43", "filename": "src/test/ui/unsized/unsized-trait-impl-self-type.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-self-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-self-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-self-type.stderr?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -11,6 +11,13 @@ LL | impl<X: ?Sized> T3<X> for S5<X> {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `Y` if it were used through indirection like `&Y` or `Box<Y>`\n+  --> $DIR/unsized-trait-impl-self-type.rs:8:11\n+   |\n+LL | struct S5<Y>(Y);\n+   |           ^  - ...if indirection was used here: `Box<Y>`\n+   |           |\n+   |           this could be changed to `Y: ?Sized`...\n \n error: aborting due to previous error\n "}, {"sha": "e423a9bdeab6f9f1c00b86f6a5ca516fdb3c9df9", "filename": "src/test/ui/unsized/unsized-trait-impl-trait-arg.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-trait-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-trait-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-trait-arg.stderr?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -11,6 +11,10 @@ LL | impl<X: ?Sized> T2<X> for S4<X> {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | trait T2<Z: ?Sized> {\n+   |           ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "e0a0389dc46908247f7093f74dd12a77d554e496", "filename": "src/test/ui/unsized3.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Funsized3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Funsized3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized3.stderr?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -48,6 +48,10 @@ LL |     f5(x1);\n    = help: within `S<X>`, the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `S<X>`\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | fn f5<Y: ?Sized>(x: &Y) {}\n+   |        ^^^^^^^^\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized3.rs:40:8\n@@ -91,6 +95,10 @@ LL |     f5(&(32, *x1));\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `S<X>`\n    = note: required because it appears within the type `({integer}, S<X>)`\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | fn f5<Y: ?Sized>(x: &Y) {}\n+   |        ^^^^^^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "e616a5cf0f9c216a7a473b472f883df748f27de8", "filename": "src/test/ui/unsized7.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Funsized7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Funsized7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized7.stderr?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -11,6 +11,10 @@ LL | impl<X: ?Sized + T> T1<X> for S3<X> {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | trait T1<Z: T + ?Sized> {\n+   |               ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "731d31ac34f628d7009c171e5d2c0977fd00a21b", "filename": "src/test/ui/wf/wf-fn-where-clause.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fwf%2Fwf-fn-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4910206b4a5b36ce0d82e08f1e33e72875fd28df/src%2Ftest%2Fui%2Fwf%2Fwf-fn-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-fn-where-clause.stderr?ref=4910206b4a5b36ce0d82e08f1e33e72875fd28df", "patch": "@@ -23,6 +23,13 @@ LL | struct Vec<T> {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn std::marker::Copy + 'static)`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `T` if it were used through indirection like `&T` or `Box<T>`\n+  --> $DIR/wf-fn-where-clause.rs:16:12\n+   |\n+LL | struct Vec<T> {\n+   |            ^ this could be changed to `T: ?Sized`...\n+LL |     t: T,\n+   |        - ...if indirection was used here: `Box<T>`\n \n error[E0038]: the trait `std::marker::Copy` cannot be made into an object\n   --> $DIR/wf-fn-where-clause.rs:12:16"}]}