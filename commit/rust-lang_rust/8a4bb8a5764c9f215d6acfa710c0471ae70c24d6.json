{"sha": "8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNGJiOGE1NzY0YzlmMjE1ZDZhY2ZhNzEwYzA0NzFhZTcwYzI0ZDY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-05-06T19:59:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-06-22T14:25:11Z"}, "message": "Rename ty_param_bounds_and_ty to Polytype", "tree": {"sha": "bff3350025e0c8ad43809bcfc5b76b70f570b13c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bff3350025e0c8ad43809bcfc5b76b70f570b13c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "html_url": "https://github.com/rust-lang/rust/commit/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ead6bed48a0877a9752cfa2022351cec1773533", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ead6bed48a0877a9752cfa2022351cec1773533", "html_url": "https://github.com/rust-lang/rust/commit/7ead6bed48a0877a9752cfa2022351cec1773533"}], "stats": {"total": 331, "additions": 162, "deletions": 169}, "files": [{"sha": "5ab8eeeb36055c7242e3d192f66eb6cd4ccf6038", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "patch": "@@ -193,7 +193,7 @@ pub fn get_struct_fields(cstore: &cstore::CStore,\n \n pub fn get_type(tcx: &ty::ctxt,\n                 def: ast::DefId)\n-             -> ty::ty_param_bounds_and_ty {\n+             -> ty::Polytype {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_type(&*cdata, def.node, tcx)\n@@ -206,7 +206,7 @@ pub fn get_trait_def(tcx: &ty::ctxt, def: ast::DefId) -> ty::TraitDef {\n }\n \n pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n-                      def: ast::DefId) -> ty::ty_param_bounds_and_ty {\n+                      def: ast::DefId) -> ty::Polytype {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(class_id.krate);\n     let all_items = reader::get_doc(ebml::Doc::new(cdata.data()), tag_items);\n@@ -224,7 +224,7 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n                     def)).to_string()\n         });\n     let ty = decoder::item_type(def, the_field, tcx, &*cdata);\n-    ty::ty_param_bounds_and_ty {\n+    ty::Polytype {\n         generics: ty::Generics {types: VecPerParamSpace::empty(),\n                                 regions: VecPerParamSpace::empty()},\n         ty: ty"}, {"sha": "f5ce8cda8c4a6d1b35f00a77c4304701a74e263e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "patch": "@@ -422,7 +422,7 @@ pub fn get_trait_def(cdata: Cmd,\n }\n \n pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n-    -> ty::ty_param_bounds_and_ty {\n+    -> ty::Polytype {\n \n     let item = lookup_item(id, cdata.data());\n \n@@ -432,7 +432,7 @@ pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n     let tp_defs = item_ty_param_defs(item, tcx, cdata, tag_items_data_item_ty_param_bounds);\n     let rp_defs = item_region_param_defs(item, cdata);\n \n-    ty::ty_param_bounds_and_ty {\n+    ty::Polytype {\n         generics: ty::Generics {types: tp_defs,\n                                 regions: rp_defs},\n         ty: t"}, {"sha": "b606ba3b87a53e983d14d317d28b3389d497dcdc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "patch": "@@ -196,11 +196,11 @@ fn encode_item_variances(ebml_w: &mut Encoder,\n \n fn encode_bounds_and_type(ebml_w: &mut Encoder,\n                           ecx: &EncodeContext,\n-                          tpt: &ty::ty_param_bounds_and_ty) {\n-    encode_ty_type_param_defs(ebml_w, ecx, &tpt.generics.types,\n+                          pty: &ty::Polytype) {\n+    encode_ty_type_param_defs(ebml_w, ecx, &pty.generics.types,\n                               tag_items_data_item_ty_param_bounds);\n-    encode_region_param_defs(ebml_w, &tpt.generics.regions);\n-    encode_type(ecx, ebml_w, tpt.ty);\n+    encode_region_param_defs(ebml_w, &pty.generics.regions);\n+    encode_type(ecx, ebml_w, pty.ty);\n }\n \n fn encode_variant_id(ebml_w: &mut Encoder, vid: DefId) {\n@@ -772,8 +772,8 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     encode_stability(ebml_w, stab);\n \n     // The type for methods gets encoded twice, which is unfortunate.\n-    let tpt = lookup_item_type(ecx.tcx, m.def_id);\n-    encode_bounds_and_type(ebml_w, ecx, &tpt);\n+    let pty = lookup_item_type(ecx.tcx, m.def_id);\n+    encode_bounds_and_type(ebml_w, ecx, &pty);\n \n     let elem = ast_map::PathName(m.ident.name);\n     encode_path(ebml_w, impl_path.chain(Some(elem).move_iter()));\n@@ -785,7 +785,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     }\n \n     for &ast_method in ast_method_opt.iter() {\n-        let any_types = !tpt.generics.types.is_empty();\n+        let any_types = !pty.generics.types.is_empty();\n         if any_types || is_default_impl || should_inline(ast_method.attrs.as_slice()) {\n             encode_inlined_item(ecx, ebml_w,\n                                 IIMethodRef(local_def(parent_id), false,\n@@ -1218,8 +1218,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                   fn_style_static_method_family(\n                                       method_ty.fty.fn_style));\n \n-                    let tpt = ty::lookup_item_type(tcx, method_def_id);\n-                    encode_bounds_and_type(ebml_w, ecx, &tpt);\n+                    let pty = ty::lookup_item_type(tcx, method_def_id);\n+                    encode_bounds_and_type(ebml_w, ecx, &pty);\n                 }\n \n                 _ => {\n@@ -1242,8 +1242,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     // this.\n                     if method_ty.explicit_self != SelfStatic {\n                         // FIXME: I feel like there is something funny going on.\n-                        let tpt = ty::lookup_item_type(tcx, method_def_id);\n-                        encode_bounds_and_type(ebml_w, ecx, &tpt);\n+                        let pty = ty::lookup_item_type(tcx, method_def_id);\n+                        encode_bounds_and_type(ebml_w, ecx, &pty);\n                     }\n                     encode_method_sort(ebml_w, 'p');\n                     encode_inlined_item(ecx, ebml_w,"}, {"sha": "31a3057e8a644c37c6896b9e1a830fb3207f5440", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "patch": "@@ -839,9 +839,9 @@ trait ebml_writer_helpers {\n     fn emit_type_param_def(&mut self,\n                            ecx: &e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef);\n-    fn emit_tpbt(&mut self,\n-                 ecx: &e::EncodeContext,\n-                 tpbt: ty::ty_param_bounds_and_ty);\n+    fn emit_polytype(&mut self,\n+                     ecx: &e::EncodeContext,\n+                     pty: ty::Polytype);\n     fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &subst::Substs);\n     fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment);\n }\n@@ -865,26 +865,26 @@ impl<'a> ebml_writer_helpers for Encoder<'a> {\n         });\n     }\n \n-    fn emit_tpbt(&mut self,\n+    fn emit_polytype(&mut self,\n                  ecx: &e::EncodeContext,\n-                 tpbt: ty::ty_param_bounds_and_ty) {\n-        self.emit_struct(\"ty_param_bounds_and_ty\", 2, |this| {\n+                 pty: ty::Polytype) {\n+        self.emit_struct(\"Polytype\", 2, |this| {\n             this.emit_struct_field(\"generics\", 0, |this| {\n                 this.emit_struct(\"Generics\", 2, |this| {\n                     this.emit_struct_field(\"types\", 0, |this| {\n                         Ok(encode_vec_per_param_space(\n-                            this, &tpbt.generics.types,\n+                            this, &pty.generics.types,\n                             |this, def| this.emit_type_param_def(ecx, def)))\n                     });\n                     this.emit_struct_field(\"regions\", 1, |this| {\n                         Ok(encode_vec_per_param_space(\n-                            this, &tpbt.generics.regions,\n+                            this, &pty.generics.regions,\n                             |this, def| def.encode(this).unwrap()))\n                     })\n                 })\n             });\n             this.emit_struct_field(\"ty\", 1, |this| {\n-                Ok(this.emit_ty(ecx, tpbt.ty))\n+                Ok(this.emit_ty(ecx, pty.ty))\n             })\n         });\n     }\n@@ -1030,11 +1030,11 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n-    for &tpbt in tcx.tcache.borrow().find(&lid).iter() {\n+    for &pty in tcx.tcache.borrow().find(&lid).iter() {\n         ebml_w.tag(c::tag_table_tcache, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_tpbt(ecx, tpbt.clone());\n+                ebml_w.emit_polytype(ecx, pty.clone());\n             })\n         })\n     }\n@@ -1142,8 +1142,8 @@ trait ebml_decoder_decoder_helpers {\n     fn read_tys(&mut self, xcx: &ExtendedDecodeContext) -> Vec<ty::t>;\n     fn read_type_param_def(&mut self, xcx: &ExtendedDecodeContext)\n                            -> ty::TypeParameterDef;\n-    fn read_ty_param_bounds_and_ty(&mut self, xcx: &ExtendedDecodeContext)\n-                                -> ty::ty_param_bounds_and_ty;\n+    fn read_polytype(&mut self, xcx: &ExtendedDecodeContext)\n+                     -> ty::Polytype;\n     fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> subst::Substs;\n     fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment;\n     fn convert_def_id(&mut self,\n@@ -1245,10 +1245,10 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_ty_param_bounds_and_ty(&mut self, xcx: &ExtendedDecodeContext)\n-                                   -> ty::ty_param_bounds_and_ty {\n-        self.read_struct(\"ty_param_bounds_and_ty\", 2, |this| {\n-            Ok(ty::ty_param_bounds_and_ty {\n+    fn read_polytype(&mut self, xcx: &ExtendedDecodeContext)\n+                                   -> ty::Polytype {\n+        self.read_struct(\"Polytype\", 2, |this| {\n+            Ok(ty::Polytype {\n                 generics: this.read_struct_field(\"generics\", 0, |this| {\n                     this.read_struct(\"Generics\", 2, |this| {\n                         Ok(ty::Generics {\n@@ -1408,9 +1408,9 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                         dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n                     }\n                     c::tag_table_tcache => {\n-                        let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n+                        let pty = val_dsr.read_polytype(xcx);\n                         let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n-                        dcx.tcx.tcache.borrow_mut().insert(lid, tpbt);\n+                        dcx.tcx.tcache.borrow_mut().insert(lid, pty);\n                     }\n                     c::tag_table_param_defs => {\n                         let bounds = val_dsr.read_type_param_def(xcx);"}, {"sha": "c2fad75d6b89b490ffd488b365fc2f6680827467", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "patch": "@@ -721,7 +721,7 @@ fn check_while_true_expr(cx: &Context, e: &ast::Expr) {\n impl<'a> AstConv for Context<'a>{\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n         ty::lookup_item_type(self.tcx, id)\n     }\n "}, {"sha": "3ef2f7a0480dc7b09ecf18e90ae758f3882c5f34", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "patch": "@@ -1026,21 +1026,16 @@ pub struct ParameterEnvironment {\n \n /// A polytype.\n ///\n-/// - `bounds`: The list of bounds for each type parameter.  The length of the\n-///   list also tells you how many type parameters there are.\n-///\n-/// - `rp`: true if the type is region-parameterized.  Types can have at\n-///   most one region parameter, always called `&self`.\n-///\n-/// - `ty`: the base type.  May have reference to the (unsubstituted) bound\n-///   region `&self` or to (unsubstituted) ty_param types\n+/// - `generics`: the set of type parameters and their bounds\n+/// - `ty`: the base types, which may reference the parameters defined\n+///   in `generics`\n #[deriving(Clone)]\n-pub struct ty_param_bounds_and_ty {\n+pub struct Polytype {\n     pub generics: Generics,\n     pub ty: t\n }\n \n-/// As `ty_param_bounds_and_ty` but for a trait ref.\n+/// As `Polytype` but for a trait ref.\n pub struct TraitDef {\n     pub generics: Generics,\n     pub bounds: BuiltinBounds,\n@@ -1054,7 +1049,7 @@ pub struct ItemSubsts {\n     pub substs: Substs,\n }\n \n-pub type type_cache = RefCell<DefIdMap<ty_param_bounds_and_ty>>;\n+pub type type_cache = RefCell<DefIdMap<Polytype>>;\n \n pub type node_type_table = RefCell<HashMap<uint,t>>;\n \n@@ -3843,7 +3838,7 @@ pub fn enum_variant_with_id(cx: &ctxt,\n // the type cache. Returns the type parameters and type.\n pub fn lookup_item_type(cx: &ctxt,\n                         did: ast::DefId)\n-                     -> ty_param_bounds_and_ty {\n+                     -> Polytype {\n     lookup_locally_or_in_crate_store(\n         \"tcache\", did, &mut *cx.tcache.borrow_mut(),\n         || csearch::get_type(cx, did))\n@@ -3941,7 +3936,7 @@ pub fn lookup_field_type(tcx: &ctxt,\n     } else {\n         let mut tcache = tcx.tcache.borrow_mut();\n         match tcache.find(&id) {\n-           Some(&ty_param_bounds_and_ty {ty, ..}) => ty,\n+           Some(&Polytype {ty, ..}) => ty,\n            None => {\n                let tpt = csearch::get_field_type(tcx, struct_id, id);\n                tcache.insert(id, tpt.clone());"}, {"sha": "4bf32d15e6424fc1a4a0e725259eb5b02ebcb0c4", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "patch": "@@ -53,11 +53,9 @@ use middle::const_eval;\n use middle::def;\n use middle::lang_items::FnMutTraitLangItem;\n use rl = middle::resolve_lifetime;\n-use middle::subst::{Subst, Substs};\n+use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::ty;\n use middle::typeck::TypeAndSubsts;\n-use middle::typeck::rscope;\n-use middle::typeck::rscope::{RegionScope};\n use middle::typeck::lookup_def_tcx;\n use middle::typeck::rscope::RegionScope;\n use middle::typeck::rscope;\n@@ -72,7 +70,7 @@ use syntax::print::pprust::{lifetime_to_str, path_to_str};\n \n pub trait AstConv {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty;\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype;\n     fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef>;\n \n     // what type should we use when a type is omitted?\n@@ -155,7 +153,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     rscope: &RS,\n     decl_generics: &ty::Generics,\n     self_ty: Option<ty::t>,\n-    path: &ast::Path) -> subst::Substs\n+    path: &ast::Path) -> Substs\n {\n     /*!\n      * Given a path `path` that refers to an item `I` with the\n@@ -173,13 +171,13 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     // Note: in the case of traits, the self parameter is also\n     // defined, but we don't currently create a `type_param_def` for\n     // `Self` because it is implicit.\n-    assert!(decl_generics.regions.all(|d| d.space == subst::TypeSpace));\n-    assert!(decl_generics.types.all(|d| d.space != subst::FnSpace));\n+    assert!(decl_generics.regions.all(|d| d.space == TypeSpace));\n+    assert!(decl_generics.types.all(|d| d.space != FnSpace));\n \n     // If the type is parameterized by the this region, then replace this\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n-    let expected_num_region_params = decl_generics.regions.len(subst::TypeSpace);\n+    let expected_num_region_params = decl_generics.regions.len(TypeSpace);\n     let supplied_num_region_params = path.segments.last().unwrap().lifetimes.len();\n     let regions = if expected_num_region_params == supplied_num_region_params {\n         path.segments.last().unwrap().lifetimes.iter().map(\n@@ -205,7 +203,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     };\n \n     // Convert the type parameters supplied by the user.\n-    let ty_param_defs = decl_generics.types.get_vec(subst::TypeSpace);\n+    let ty_param_defs = decl_generics.types.get_vec(TypeSpace);\n     let supplied_ty_param_count = path.segments.iter().flat_map(|s| s.types.iter()).count();\n     let formal_ty_param_count = ty_param_defs.len();\n     let required_ty_param_count = ty_param_defs.iter()\n@@ -247,7 +245,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n                             .map(|a_t| ast_ty_to_ty(this, rscope, &**a_t))\n                             .collect();\n \n-    let mut substs = subst::Substs::new_type(tps, regions);\n+    let mut substs = Substs::new_type(tps, regions);\n \n     match self_ty {\n         None => {\n@@ -259,14 +257,14 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n             // \"declared\" (in other words, this should be a\n             // trait-ref).\n             assert!(decl_generics.types.get_self().is_some());\n-            substs.types.push(subst::SelfSpace, ty);\n+            substs.types.push(SelfSpace, ty);\n         }\n     }\n \n     for param in ty_param_defs.slice_from(supplied_ty_param_count).iter() {\n         let default = param.default.unwrap();\n         let default = default.subst_spanned(tcx, &substs, Some(path.span));\n-        substs.types.push(subst::TypeSpace, default);\n+        substs.types.push(TypeSpace, default);\n     }\n \n     substs\n@@ -293,7 +291,7 @@ pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>(\n      -> TypeAndSubsts\n {\n     let tcx = this.tcx();\n-    let ty::ty_param_bounds_and_ty {\n+    let ty::Polytype {\n         generics: generics,\n         ty: decl_ty\n     } = this.get_item_ty(did);\n@@ -548,11 +546,11 @@ pub fn trait_ref_for_unboxed_function<AC:AstConv,\n     let output_type = ast_ty_to_ty(this,\n                                    rscope,\n                                    &*unboxed_function.decl.output);\n-    let mut substs = subst::Substs::new_type(vec!(input_tuple, output_type),\n+    let mut substs = Substs::new_type(vec!(input_tuple, output_type),\n                                              Vec::new());\n \n     match self_ty {\n-        Some(s) => substs.types.push(subst::SelfSpace, s),\n+        Some(s) => substs.types.push(SelfSpace, s),\n         None => ()\n     }\n "}, {"sha": "c76b0af0145fd79cde295204b65f56d93c9c2487", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "patch": "@@ -133,10 +133,10 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n             match v_def.variant_def_ids() {\n                 Some((enm, var)) => {\n                     // Assign the pattern the type of the *enum*, not the variant.\n-                    let enum_tpt = ty::lookup_item_type(tcx, enm);\n+                    let enum_pty = ty::lookup_item_type(tcx, enm);\n                     instantiate_path(pcx.fcx,\n                                      path,\n-                                     enum_tpt,\n+                                     enum_pty,\n                                      v_def,\n                                      pat.span,\n                                      pat.id);\n@@ -190,16 +190,16 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n             let s_def_id = s_def.def_id();\n \n             // Assign the pattern the type of the struct.\n-            let ctor_tpt = ty::lookup_item_type(tcx, s_def_id);\n-            let struct_tpt = if ty::is_fn_ty(ctor_tpt.ty) {\n-                ty::ty_param_bounds_and_ty {ty: ty::ty_fn_ret(ctor_tpt.ty),\n-                                        ..ctor_tpt}\n+            let ctor_pty = ty::lookup_item_type(tcx, s_def_id);\n+            let struct_pty = if ty::is_fn_ty(ctor_pty.ty) {\n+                ty::Polytype {ty: ty::ty_fn_ret(ctor_pty.ty),\n+                              ..ctor_pty}\n             } else {\n-                ctor_tpt\n+                ctor_pty\n             };\n             instantiate_path(pcx.fcx,\n                              path,\n-                             struct_tpt,\n+                             struct_pty,\n                              s_def,\n                              pat.span,\n                              pat.id);\n@@ -478,9 +478,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n       ast::PatEnum(..) |\n       ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n         let const_did = tcx.def_map.borrow().get_copy(&pat.id).def_id();\n-        let const_tpt = ty::lookup_item_type(tcx, const_did);\n-        demand::suptype(fcx, pat.span, expected, const_tpt.ty);\n-        fcx.write_ty(pat.id, const_tpt.ty);\n+        let const_pty = ty::lookup_item_type(tcx, const_did);\n+        demand::suptype(fcx, pat.span, expected, const_pty.ty);\n+        fcx.write_ty(pat.id, const_pty.ty);\n       }\n       ast::PatIdent(bm, ref name, sub) if pat_is_binding(&tcx.def_map, pat) => {\n         let typ = fcx.local_ty(pat.span, pat.id);"}, {"sha": "1c5cfc45afdb80061d77729245512533794b4ad2", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "patch": "@@ -85,7 +85,7 @@ use middle::pat_util;\n use middle::subst;\n use middle::subst::{Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::ty::{FnSig, VariantInfo};\n-use middle::ty::{ty_param_bounds_and_ty};\n+use middle::ty::{Polytype};\n use middle::ty::{ParamTy, Disr, ExprTyProvider};\n use middle::ty;\n use middle::ty_fold::TypeFolder;\n@@ -645,20 +645,20 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                             it.id);\n       }\n       ast::ItemFn(ref decl, _, _, _, ref body) => {\n-        let fn_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n+        let fn_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n \n         let param_env = ty::construct_parameter_environment(ccx.tcx,\n-                                                            &fn_tpt.generics,\n+                                                            &fn_pty.generics,\n                                                             body.id);\n \n-        check_bare_fn(ccx, &**decl, &**body, it.id, fn_tpt.ty, param_env);\n+        check_bare_fn(ccx, &**decl, &**body, it.id, fn_pty.ty, param_env);\n       }\n       ast::ItemImpl(_, ref opt_trait_ref, _, ref ms) => {\n         debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n \n-        let impl_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n+        let impl_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n         for m in ms.iter() {\n-            check_method_body(ccx, &impl_tpt.generics, &**m);\n+            check_method_body(ccx, &impl_pty.generics, &**m);\n         }\n \n         match *opt_trait_ref {\n@@ -670,7 +670,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                              ast_trait_ref,\n                                              &*impl_trait_ref,\n                                              ms.as_slice());\n-                vtable::resolve_impl(ccx.tcx, it, &impl_tpt.generics, &*impl_trait_ref);\n+                vtable::resolve_impl(ccx.tcx, it, &impl_pty.generics, &*impl_trait_ref);\n             }\n             None => { }\n         }\n@@ -694,8 +694,8 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n         check_struct(ccx, it.id, it.span);\n       }\n       ast::ItemTy(ref t, ref generics) => {\n-        let tpt_ty = ty::node_id_to_type(ccx.tcx, it.id);\n-        check_bounds_are_used(ccx, t.span, &generics.ty_params, tpt_ty);\n+        let pty_ty = ty::node_id_to_type(ccx.tcx, it.id);\n+        check_bounds_are_used(ccx, t.span, &generics.ty_params, pty_ty);\n       }\n       ast::ItemForeignMod(ref m) => {\n         if m.abi == abi::RustIntrinsic {\n@@ -704,8 +704,8 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n             }\n         } else {\n             for item in m.items.iter() {\n-                let tpt = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n-                if !tpt.generics.types.is_empty() {\n+                let pty = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n+                if !pty.generics.types.is_empty() {\n                     ccx.tcx.sess.span_err(item.span, \"foreign items may not have type parameters\");\n                 }\n \n@@ -1049,7 +1049,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n impl<'a> AstConv for FnCtxt<'a> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.ccx.tcx }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n         ty::lookup_item_type(self.tcx(), id)\n     }\n \n@@ -2856,8 +2856,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprPath(ref pth) => {\n         let defn = lookup_def(fcx, pth.span, id);\n-        let tpt = ty_param_bounds_and_ty_for_def(fcx, expr.span, defn);\n-        instantiate_path(fcx, pth, tpt, defn, expr.span, expr.id);\n+        let pty = polytype_for_def(fcx, expr.span, defn);\n+        instantiate_path(fcx, pth, pty, defn, expr.span, expr.id);\n       }\n       ast::ExprInlineAsm(ref ia) => {\n           for &(_, ref input) in ia.inputs.iter() {\n@@ -3752,10 +3752,10 @@ pub fn lookup_def(fcx: &FnCtxt, sp: Span, id: ast::NodeId) -> def::Def {\n }\n \n // Returns the type parameter count and the type for the given definition.\n-pub fn ty_param_bounds_and_ty_for_def(fcx: &FnCtxt,\n-                                      sp: Span,\n-                                      defn: def::Def)\n-                                   -> ty_param_bounds_and_ty {\n+pub fn polytype_for_def(fcx: &FnCtxt,\n+                        sp: Span,\n+                        defn: def::Def)\n+                        -> Polytype {\n     match defn {\n       def::DefArg(nid, _) | def::DefLocal(nid, _) |\n       def::DefBinding(nid, _) => {\n@@ -3768,7 +3768,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: &FnCtxt,\n         return ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n       def::DefUpvar(_, inner, _, _) => {\n-        return ty_param_bounds_and_ty_for_def(fcx, sp, *inner);\n+        return polytype_for_def(fcx, sp, *inner);\n       }\n       def::DefTrait(_) |\n       def::DefTy(_) |\n@@ -3804,7 +3804,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: &FnCtxt,\n // number of type parameters and type.\n pub fn instantiate_path(fcx: &FnCtxt,\n                         path: &ast::Path,\n-                        polytype: ty_param_bounds_and_ty,\n+                        polytype: Polytype,\n                         def: def::Def,\n                         span: Span,\n                         node_id: ast::NodeId) {"}, {"sha": "cbd1479ef0930310acea44ac74c15d2f9ec1ba44", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "patch": "@@ -23,7 +23,7 @@ use middle::ty::get;\n use middle::ty::{ImplContainer, lookup_item_type};\n use middle::ty::{t, ty_bool, ty_char, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil};\n-use middle::ty::{ty_param, ty_param_bounds_and_ty, ty_ptr};\n+use middle::ty::{ty_param, Polytype, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n use middle::ty::type_is_ty_var;\n@@ -378,7 +378,7 @@ impl<'a> CoherenceChecker<'a> {\n             // construct the polytype for the method based on the\n             // method_ty.  it will have all the generics from the\n             // impl, plus its own.\n-            let new_polytype = ty::ty_param_bounds_and_ty {\n+            let new_polytype = ty::Polytype {\n                 generics: new_method_ty.generics.clone(),\n                 ty: ty::mk_bare_fn(tcx, new_method_ty.fty.clone())\n             };\n@@ -487,8 +487,8 @@ impl<'a> CoherenceChecker<'a> {\n     }\n \n     fn polytypes_unify(&self,\n-                       polytype_a: ty_param_bounds_and_ty,\n-                       polytype_b: ty_param_bounds_and_ty)\n+                       polytype_a: Polytype,\n+                       polytype_b: Polytype)\n                        -> bool {\n         let universally_quantified_a =\n             self.universally_quantify_polytype(polytype_a);\n@@ -503,7 +503,7 @@ impl<'a> CoherenceChecker<'a> {\n \n     // Converts a polytype to a monotype by replacing all parameters with\n     // type variables. Returns the monotype and the type variables created.\n-    fn universally_quantify_polytype(&self, polytype: ty_param_bounds_and_ty)\n+    fn universally_quantify_polytype(&self, polytype: Polytype)\n                                      -> UniversalQuantificationResult\n     {\n         let substitutions =\n@@ -526,7 +526,7 @@ impl<'a> CoherenceChecker<'a> {\n     }\n \n     fn get_self_type_for_implementation(&self, impl_did: DefId)\n-                                        -> ty_param_bounds_and_ty {\n+                                        -> Polytype {\n         self.crate_context.tcx.tcache.borrow().get_copy(&impl_did)\n     }\n \n@@ -748,7 +748,7 @@ pub fn make_substs_for_receiver_types(tcx: &ty::ctxt,\n \n fn subst_receiver_types_in_method_ty(tcx: &ty::ctxt,\n                                      impl_id: ast::DefId,\n-                                     impl_poly_type: &ty::ty_param_bounds_and_ty,\n+                                     impl_poly_type: &ty::Polytype,\n                                      trait_ref: &ty::TraitRef,\n                                      new_def_id: ast::DefId,\n                                      method: &ty::Method,"}, {"sha": "bf88ec5c438f28a62e3d52f61327a2b1dbb2b6af", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "patch": "@@ -24,9 +24,9 @@ for each item are in fact polytypes.  In \"layman's terms\", this means\n that they are generic types that may have type parameters (more\n mathematically phrased, they are universally quantified over a set of\n type parameters).  Polytypes are represented by an instance of\n-`ty::ty_param_bounds_and_ty`.  This combines the core type along with\n-a list of the bounds for each parameter.  Type parameters themselves\n-are represented as `ty_param()` instances.\n+`ty::Polytype`.  This combines the core type along with a list of the\n+bounds for each parameter.  Type parameters themselves are represented\n+as `ty_param()` instances.\n \n */\n \n@@ -38,7 +38,7 @@ use middle::resolve_lifetime;\n use middle::subst;\n use middle::subst::{Substs};\n use middle::ty::{ImplContainer, MethodContainer, TraitContainer};\n-use middle::ty::{ty_param_bounds_and_ty};\n+use middle::ty::{Polytype};\n use middle::ty;\n use middle::typeck::astconv::{AstConv, ty_of_arg};\n use middle::typeck::astconv::{ast_ty_to_ty};\n@@ -84,7 +84,7 @@ impl<'a> visit::Visitor<()> for CollectItemTypesVisitor<'a> {\n pub fn collect_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n     fn collect_intrinsic_type(ccx: &CrateCtxt,\n                               lang_item: ast::DefId) {\n-        let ty::ty_param_bounds_and_ty { ty: ty, .. } =\n+        let ty::Polytype { ty: ty, .. } =\n             ccx.get_item_ty(lang_item);\n         ccx.tcx.intrinsic_defs.borrow_mut().insert(lang_item, ty);\n     }\n@@ -113,7 +113,7 @@ impl<'a> ToTy for CrateCtxt<'a> {\n impl<'a> AstConv for CrateCtxt<'a> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n         if id.krate != ast::LOCAL_CRATE {\n             return csearch::get_type(self.tcx, id)\n         }\n@@ -167,25 +167,25 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n             }\n \n             ast::StructVariantKind(struct_def) => {\n-                let tpt = ty_param_bounds_and_ty {\n+                let pty = Polytype {\n                     generics: ty_generics_for_type(ccx, generics),\n                     ty: enum_ty\n                 };\n \n-                convert_struct(ccx, &*struct_def, tpt, variant.node.id);\n+                convert_struct(ccx, &*struct_def, pty, variant.node.id);\n \n                 let input_tys: Vec<_> = struct_def.fields.iter().map(\n                     |f| ty::node_id_to_type(ccx.tcx, f.node.id)).collect();\n                 ty::mk_ctor_fn(tcx, scope, input_tys.as_slice(), enum_ty)\n             }\n         };\n \n-        let tpt = ty_param_bounds_and_ty {\n+        let pty = Polytype {\n             generics: ty_generics_for_type(ccx, generics),\n             ty: result_ty\n         };\n \n-        tcx.tcache.borrow_mut().insert(local_def(variant.node.id), tpt);\n+        tcx.tcache.borrow_mut().insert(local_def(variant.node.id), pty);\n \n         write_ty_to_tcx(tcx, variant.node.id, result_ty);\n     }\n@@ -251,7 +251,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n     fn make_static_method_ty(ccx: &CrateCtxt, m: &ty::Method) {\n         ccx.tcx.tcache.borrow_mut().insert(\n             m.def_id,\n-            ty_param_bounds_and_ty {\n+            Polytype {\n                 generics: m.generics.clone(),\n                 ty: ty::mk_bare_fn(ccx.tcx, m.fty.clone()) });\n     }\n@@ -295,7 +295,7 @@ pub fn convert_field(ccx: &CrateCtxt,\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.borrow_mut().insert(local_def(v.node.id),\n-                                       ty::ty_param_bounds_and_ty {\n+                                       ty::Polytype {\n                                            generics: struct_generics.clone(),\n                                            ty: tt\n                                        });\n@@ -347,7 +347,7 @@ fn convert_methods(ccx: &CrateCtxt,\n                 fty.repr(ccx.tcx));\n         tcx.tcache.borrow_mut().insert(\n             local_def(m.id),\n-            ty_param_bounds_and_ty {\n+            Polytype {\n                 generics: mty.generics.clone(),\n                 ty: fty\n             });\n@@ -422,10 +422,10 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n         ast::ItemForeignMod(_) | ast::ItemMod(_) | ast::ItemMac(_) => {}\n         ast::ItemEnum(ref enum_definition, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"enumeration\");\n-            let tpt = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, tpt.ty);\n+            let pty = ty_of_item(ccx, it);\n+            write_ty_to_tcx(tcx, it.id, pty.ty);\n             get_enum_variant_types(ccx,\n-                                   tpt.ty,\n+                                   pty.ty,\n                                    enum_definition.variants.as_slice(),\n                                    generics);\n         },\n@@ -435,7 +435,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n             tcx.tcache.borrow_mut().insert(local_def(it.id),\n-                                ty_param_bounds_and_ty {\n+                                Polytype {\n                                     generics: ty_generics.clone(),\n                                     ty: selfty});\n \n@@ -484,10 +484,10 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"structure\");\n \n             // Write the class type.\n-            let tpt = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, tpt.ty);\n+            let pty = ty_of_item(ccx, it);\n+            write_ty_to_tcx(tcx, it.id, pty.ty);\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n \n             // Write the super-struct type, if it exists.\n             match struct_def.super_struct {\n@@ -498,38 +498,38 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                 _ => {},\n             }\n \n-            convert_struct(ccx, &*struct_def, tpt, it.id);\n+            convert_struct(ccx, &*struct_def, pty, it.id);\n         },\n         ast::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n-            let tpt = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, tpt.ty);\n+            let pty = ty_of_item(ccx, it);\n+            write_ty_to_tcx(tcx, it.id, pty.ty);\n         },\n         ast::ItemFn(_, _, abi, ref generics, _) => {\n             ensure_generics_abi(ccx, it.span, abi, generics);\n-            let tpt = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, tpt.ty);\n+            let pty = ty_of_item(ccx, it);\n+            write_ty_to_tcx(tcx, it.id, pty.ty);\n         },\n         _ => {\n             // This call populates the type cache with the converted type\n             // of the item in passing. All we have to do here is to write\n             // it into the node type table.\n-            let tpt = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, tpt.ty);\n+            let pty = ty_of_item(ccx, it);\n+            write_ty_to_tcx(tcx, it.id, pty.ty);\n         },\n     }\n }\n \n pub fn convert_struct(ccx: &CrateCtxt,\n                       struct_def: &ast::StructDef,\n-                      tpt: ty::ty_param_bounds_and_ty,\n+                      pty: ty::Polytype,\n                       id: ast::NodeId) {\n     let tcx = ccx.tcx;\n \n     // Write the type of each of the members and check for duplicate fields.\n     let mut seen_fields: HashMap<ast::Name, Span> = HashMap::new();\n     let field_tys = struct_def.fields.iter().map(|f| {\n-        let result = convert_field(ccx, &tpt.generics, f, local_def(id));\n+        let result = convert_field(ccx, &pty.generics, f, local_def(id));\n \n         if result.name != special_idents::unnamed_field.name {\n             let dup = match seen_fields.find(&result.name) {\n@@ -589,7 +589,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n     };\n     tcx.superstructs.borrow_mut().insert(local_def(id), super_struct);\n \n-    let substs = mk_item_substs(ccx, &tpt.generics);\n+    let substs = mk_item_substs(ccx, &pty.generics);\n     let selfty = ty::mk_struct(tcx, local_def(id), substs);\n \n     // If this struct is enum-like or tuple-like, create the type of its\n@@ -601,7 +601,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                 // Enum-like.\n                 write_ty_to_tcx(tcx, ctor_id, selfty);\n \n-                tcx.tcache.borrow_mut().insert(local_def(ctor_id), tpt);\n+                tcx.tcache.borrow_mut().insert(local_def(ctor_id), pty);\n             } else if struct_def.fields.get(0).node.kind.is_unnamed() {\n                 // Tuple-like.\n                 let inputs: Vec<_> = struct_def.fields.iter().map(\n@@ -613,8 +613,8 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id),\n-                                  ty_param_bounds_and_ty {\n-                    generics: tpt.generics,\n+                                  Polytype {\n+                    generics: pty.generics,\n                     ty: ctor_fn_ty\n                 });\n             }\n@@ -633,10 +633,10 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     // convenient way to extract the ABI. - ndm\n     let abi = ccx.tcx.map.get_foreign_abi(i.id);\n \n-    let tpt = ty_of_foreign_item(ccx, i, abi);\n-    write_ty_to_tcx(ccx.tcx, i.id, tpt.ty);\n+    let pty = ty_of_foreign_item(ccx, i, abi);\n+    write_ty_to_tcx(ccx.tcx, i.id, pty.ty);\n \n-    ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), tpt);\n+    ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), pty);\n }\n \n pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n@@ -814,20 +814,20 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n }\n \n pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n-                  -> ty::ty_param_bounds_and_ty {\n+                  -> ty::Polytype {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n     match tcx.tcache.borrow().find(&def_id) {\n-        Some(tpt) => return tpt.clone(),\n+        Some(pty) => return pty.clone(),\n         _ => {}\n     }\n     match it.node {\n         ast::ItemStatic(t, _, _) => {\n             let typ = ccx.to_ty(&ExplicitRscope, &*t);\n-            let tpt = no_params(typ);\n+            let pty = no_params(typ);\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n-            return tpt;\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n+            return pty;\n         }\n         ast::ItemFn(decl, fn_style, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn_or_method(ccx, generics,\n@@ -837,47 +837,47 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                                               fn_style,\n                                               abi,\n                                               &*decl);\n-            let tpt = ty_param_bounds_and_ty {\n+            let pty = Polytype {\n                 generics: ty_generics,\n                 ty: ty::mk_bare_fn(ccx.tcx, tofd)\n             };\n             debug!(\"type of {} (id {}) is {}\",\n                     token::get_ident(it.ident),\n                     it.id,\n-                    ppaux::ty_to_str(tcx, tpt.ty));\n+                    ppaux::ty_to_str(tcx, pty.ty));\n \n-            ccx.tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n-            return tpt;\n+            ccx.tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n+            return pty;\n         }\n         ast::ItemTy(t, ref generics) => {\n             match tcx.tcache.borrow_mut().find(&local_def(it.id)) {\n-                Some(tpt) => return tpt.clone(),\n+                Some(pty) => return pty.clone(),\n                 None => { }\n             }\n \n-            let tpt = {\n+            let pty = {\n                 let ty = ccx.to_ty(&ExplicitRscope, &*t);\n-                ty_param_bounds_and_ty {\n+                Polytype {\n                     generics: ty_generics_for_type(ccx, generics),\n                     ty: ty\n                 }\n             };\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n-            return tpt;\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n+            return pty;\n         }\n         ast::ItemEnum(_, ref generics) => {\n             // Create a new generic polytype.\n             let ty_generics = ty_generics_for_type(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_enum(tcx, local_def(it.id), substs);\n-            let tpt = ty_param_bounds_and_ty {\n+            let pty = Polytype {\n                 generics: ty_generics,\n                 ty: t\n             };\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n-            return tpt;\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n+            return pty;\n         }\n         ast::ItemTrait(..) => {\n             tcx.sess.span_bug(it.span, \"invoked ty_of_item on trait\");\n@@ -886,13 +886,13 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             let ty_generics = ty_generics_for_type(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_struct(tcx, local_def(it.id), substs);\n-            let tpt = ty_param_bounds_and_ty {\n+            let pty = Polytype {\n                 generics: ty_generics,\n                 ty: t\n             };\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n-            return tpt;\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n+            return pty;\n         }\n         ast::ItemImpl(..) | ast::ItemMod(_) |\n         ast::ItemForeignMod(_) | ast::ItemMac(_) => fail!(),\n@@ -901,7 +901,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n \n pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n                           it: &ast::ForeignItem,\n-                          abi: abi::Abi) -> ty::ty_param_bounds_and_ty\n+                          abi: abi::Abi) -> ty::Polytype\n {\n     match it.node {\n         ast::ForeignItemFn(fn_decl, ref generics) => {\n@@ -912,7 +912,7 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n                                   abi)\n         }\n         ast::ForeignItemStatic(t, _) => {\n-            ty::ty_param_bounds_and_ty {\n+            ty::Polytype {\n                 generics: ty::Generics::empty(),\n                 ty: ast_ty_to_ty(ccx, &ExplicitRscope, &*t)\n             }\n@@ -1158,7 +1158,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                              def_id: ast::DefId,\n                              ast_generics: &ast::Generics,\n                              abi: abi::Abi)\n-                          -> ty::ty_param_bounds_and_ty {\n+                          -> ty::Polytype {\n \n     for i in decl.inputs.iter() {\n         match (*i).pat.node {\n@@ -1190,13 +1190,13 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                             output: output_ty,\n                             variadic: decl.variadic}\n         });\n-    let tpt = ty_param_bounds_and_ty {\n+    let pty = Polytype {\n         generics: ty_generics_for_fn_or_method,\n         ty: t_fn\n     };\n \n-    ccx.tcx.tcache.borrow_mut().insert(def_id, tpt.clone());\n-    return tpt;\n+    ccx.tcx.tcache.borrow_mut().insert(def_id, pty.clone());\n+    return pty;\n }\n \n pub fn mk_item_substs(ccx: &CrateCtxt,"}, {"sha": "a5bdea72da2302f1e9906fde9326260b32413c88", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "patch": "@@ -1052,7 +1052,7 @@ impl<'a> Rebuilder<'a> {\n                     };\n                     match a_def {\n                         def::DefTy(did) | def::DefStruct(did) => {\n-                            let ty::ty_param_bounds_and_ty {\n+                            let ty::Polytype {\n                                 generics: generics,\n                                 ty: _\n                             } = ty::lookup_item_type(self.tcx, did);"}, {"sha": "e159d0d00c82caa624073cc8d32a69cd518d63a0", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "patch": "@@ -307,8 +307,8 @@ pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n \n-pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n-    ty::ty_param_bounds_and_ty {\n+pub fn no_params(t: ty::t) -> ty::Polytype {\n+    ty::Polytype {\n         generics: ty::Generics {types: VecPerParamSpace::empty(),\n                                 regions: VecPerParamSpace::empty()},\n         ty: t"}, {"sha": "6aeae544746d8425644ad11eb93042c3a0845cc6", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a4bb8a5764c9f215d6acfa710c0471ae70c24d6/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=8a4bb8a5764c9f215d6acfa710c0471ae70c24d6", "patch": "@@ -748,9 +748,9 @@ impl Repr for ast::DefId {\n     }\n }\n \n-impl Repr for ty::ty_param_bounds_and_ty {\n+impl Repr for ty::Polytype {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"ty_param_bounds_and_ty {{generics: {}, ty: {}}}\",\n+        format!(\"Polytype {{generics: {}, ty: {}}}\",\n                 self.generics.repr(tcx),\n                 self.ty.repr(tcx))\n     }"}]}