{"sha": "67712d79451b042b6fca2167c1a57d91d86f663b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NzEyZDc5NDUxYjA0MmI2ZmNhMjE2N2MxYTU3ZDkxZDg2ZjY2M2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-10T09:00:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-10T09:00:27Z"}, "message": "Auto merge of #49390 - Zoxc:sync-syntax, r=michaelwoerister\n\nMore thread-safety changes\n\nr? @michaelwoerister", "tree": {"sha": "4027dafb2a803d522019bc41052763d61b056f5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4027dafb2a803d522019bc41052763d61b056f5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67712d79451b042b6fca2167c1a57d91d86f663b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67712d79451b042b6fca2167c1a57d91d86f663b", "html_url": "https://github.com/rust-lang/rust/commit/67712d79451b042b6fca2167c1a57d91d86f663b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67712d79451b042b6fca2167c1a57d91d86f663b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1c21ed7e21642b85947ba5d030bbaeffbe377de", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1c21ed7e21642b85947ba5d030bbaeffbe377de", "html_url": "https://github.com/rust-lang/rust/commit/a1c21ed7e21642b85947ba5d030bbaeffbe377de"}, {"sha": "1e3f6388361e1489d27679d6b9e8ba16681e3d26", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e3f6388361e1489d27679d6b9e8ba16681e3d26", "html_url": "https://github.com/rust-lang/rust/commit/1e3f6388361e1489d27679d6b9e8ba16681e3d26"}], "stats": {"total": 190, "additions": 101, "deletions": 89}, "files": [{"sha": "1e348e3a31ce215225c4a269e5fa792e235b4439", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=67712d79451b042b6fca2167c1a57d91d86f663b", "patch": "@@ -33,10 +33,11 @@ use hir::svh::Svh;\n use util::nodemap::{DefIdMap, FxHashMap};\n \n use arena::TypedArena;\n-use std::cell::RefCell;\n use std::io;\n use ty::TyCtxt;\n \n+use rustc_data_structures::sync::Lock;\n+\n pub mod blocks;\n mod collector;\n mod def_collector;\n@@ -264,7 +265,7 @@ pub struct Map<'hir> {\n     definitions: &'hir Definitions,\n \n     /// Bodies inlined from other crates are cached here.\n-    inlined_bodies: RefCell<DefIdMap<&'hir Body>>,\n+    inlined_bodies: Lock<DefIdMap<&'hir Body>>,\n \n     /// The reverse mapping of `node_to_hir_id`.\n     hir_to_node_id: FxHashMap<HirId, NodeId>,\n@@ -927,8 +928,13 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn intern_inlined_body(&self, def_id: DefId, body: Body) -> &'hir Body {\n+        let mut inlined_bodies = self.inlined_bodies.borrow_mut();\n+        if let Some(&b) = inlined_bodies.get(&def_id) {\n+            debug_assert_eq!(&body, b);\n+            return b;\n+        }\n         let body = self.forest.inlined_bodies.alloc(body);\n-        self.inlined_bodies.borrow_mut().insert(def_id, body);\n+        inlined_bodies.insert(def_id, body);\n         body\n     }\n \n@@ -1189,7 +1195,7 @@ pub fn map_crate<'hir>(sess: &::session::Session,\n         map,\n         hir_to_node_id,\n         definitions,\n-        inlined_bodies: RefCell::new(DefIdMap()),\n+        inlined_bodies: Lock::new(DefIdMap()),\n     };\n \n     hir_id_validator::check_crate(&map);"}, {"sha": "0d4fd99995f7ed2d57d4fefe61d16cb20ab4b28f", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=67712d79451b042b6fca2167c1a57d91d86f663b", "patch": "@@ -31,7 +31,7 @@\n pub use self::Level::*;\n pub use self::LintSource::*;\n \n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{self, Lrc};\n \n use errors::{DiagnosticBuilder, DiagnosticId};\n use hir::def_id::{CrateNum, LOCAL_CRATE};\n@@ -287,8 +287,9 @@ pub trait EarlyLintPass: LintPass {\n }\n \n /// A lint pass boxed up as a trait object.\n-pub type EarlyLintPassObject = Box<dyn EarlyLintPass + 'static>;\n-pub type LateLintPassObject = Box<dyn for<'a, 'tcx> LateLintPass<'a, 'tcx> + 'static>;\n+pub type EarlyLintPassObject = Box<dyn EarlyLintPass + sync::Send + sync::Sync + 'static>;\n+pub type LateLintPassObject = Box<dyn for<'a, 'tcx> LateLintPass<'a, 'tcx> + sync::Send\n+                                                                           + sync::Sync + 'static>;\n \n /// Identifies a lint known to the compiler.\n #[derive(Clone, Copy, Debug)]"}, {"sha": "1ed5a22257c537e53446b2013d1c2e842984c55c", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=67712d79451b042b6fca2167c1a57d91d86f663b", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell::{Ref, RefCell};\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::sync::{RwLock, ReadGuard};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use ich::StableHashingContext;\n@@ -19,7 +19,7 @@ use rustc_serialize as serialize;\n \n #[derive(Clone, Debug)]\n pub struct Cache {\n-    predecessors: RefCell<Option<IndexVec<BasicBlock, Vec<BasicBlock>>>>\n+    predecessors: RwLock<Option<IndexVec<BasicBlock, Vec<BasicBlock>>>>\n }\n \n \n@@ -46,7 +46,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Cache {\n impl Cache {\n     pub fn new() -> Self {\n         Cache {\n-            predecessors: RefCell::new(None)\n+            predecessors: RwLock::new(None)\n         }\n     }\n \n@@ -55,12 +55,12 @@ impl Cache {\n         *self.predecessors.borrow_mut() = None;\n     }\n \n-    pub fn predecessors(&self, mir: &Mir) -> Ref<IndexVec<BasicBlock, Vec<BasicBlock>>> {\n+    pub fn predecessors(&self, mir: &Mir) -> ReadGuard<IndexVec<BasicBlock, Vec<BasicBlock>>> {\n         if self.predecessors.borrow().is_none() {\n             *self.predecessors.borrow_mut() = Some(calculate_predecessors(mir));\n         }\n \n-        Ref::map(self.predecessors.borrow(), |p| p.as_ref().unwrap())\n+        ReadGuard::map(self.predecessors.borrow(), |p| p.as_ref().unwrap())\n     }\n }\n "}, {"sha": "33f52ab09c85668b72c9d3a008345fe5394688e6", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=67712d79451b042b6fca2167c1a57d91d86f663b", "patch": "@@ -34,7 +34,7 @@ use util::ppaux;\n use std::slice;\n use hir::{self, InlineAsm};\n use std::borrow::{Cow};\n-use std::cell::Ref;\n+use rustc_data_structures::sync::ReadGuard;\n use std::fmt::{self, Debug, Formatter, Write};\n use std::{iter, mem, u32};\n use std::ops::{Index, IndexMut};\n@@ -187,13 +187,13 @@ impl<'tcx> Mir<'tcx> {\n     }\n \n     #[inline]\n-    pub fn predecessors(&self) -> Ref<IndexVec<BasicBlock, Vec<BasicBlock>>> {\n+    pub fn predecessors(&self) -> ReadGuard<IndexVec<BasicBlock, Vec<BasicBlock>>> {\n         self.cache.predecessors(self)\n     }\n \n     #[inline]\n-    pub fn predecessors_for(&self, bb: BasicBlock) -> Ref<Vec<BasicBlock>> {\n-        Ref::map(self.predecessors(), |p| &p[bb])\n+    pub fn predecessors_for(&self, bb: BasicBlock) -> ReadGuard<Vec<BasicBlock>> {\n+        ReadGuard::map(self.predecessors(), |p| &p[bb])\n     }\n \n     #[inline]"}, {"sha": "e6ad95ec3c77ccb75fc0c54ad674a385aaad4cdd", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=67712d79451b042b6fca2167c1a57d91d86f663b", "patch": "@@ -58,7 +58,7 @@ use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n                                            StableVec};\n use arena::{TypedArena, DroplessArena};\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{Lrc, Lock};\n use std::any::Any;\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell};\n@@ -131,28 +131,28 @@ pub struct CtxtInterners<'tcx> {\n \n     /// Specifically use a speedy hash algorithm for these hash sets,\n     /// they're accessed quite often.\n-    type_: RefCell<FxHashSet<Interned<'tcx, TyS<'tcx>>>>,\n-    type_list: RefCell<FxHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n-    substs: RefCell<FxHashSet<Interned<'tcx, Substs<'tcx>>>>,\n-    canonical_var_infos: RefCell<FxHashSet<Interned<'tcx, Slice<CanonicalVarInfo>>>>,\n-    region: RefCell<FxHashSet<Interned<'tcx, RegionKind>>>,\n-    existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n-    predicates: RefCell<FxHashSet<Interned<'tcx, Slice<Predicate<'tcx>>>>>,\n-    const_: RefCell<FxHashSet<Interned<'tcx, Const<'tcx>>>>,\n+    type_: Lock<FxHashSet<Interned<'tcx, TyS<'tcx>>>>,\n+    type_list: Lock<FxHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n+    substs: Lock<FxHashSet<Interned<'tcx, Substs<'tcx>>>>,\n+    canonical_var_infos: Lock<FxHashSet<Interned<'tcx, Slice<CanonicalVarInfo>>>>,\n+    region: Lock<FxHashSet<Interned<'tcx, RegionKind>>>,\n+    existential_predicates: Lock<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n+    predicates: Lock<FxHashSet<Interned<'tcx, Slice<Predicate<'tcx>>>>>,\n+    const_: Lock<FxHashSet<Interned<'tcx, Const<'tcx>>>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n     fn new(arena: &'tcx DroplessArena) -> CtxtInterners<'tcx> {\n         CtxtInterners {\n-            arena,\n-            type_: RefCell::new(FxHashSet()),\n-            type_list: RefCell::new(FxHashSet()),\n-            substs: RefCell::new(FxHashSet()),\n-            region: RefCell::new(FxHashSet()),\n-            existential_predicates: RefCell::new(FxHashSet()),\n-            canonical_var_infos: RefCell::new(FxHashSet()),\n-            predicates: RefCell::new(FxHashSet()),\n-            const_: RefCell::new(FxHashSet()),\n+            arena: arena,\n+            type_: Lock::new(FxHashSet()),\n+            type_list: Lock::new(FxHashSet()),\n+            substs: Lock::new(FxHashSet()),\n+            canonical_var_infos: Lock::new(FxHashSet()),\n+            region: Lock::new(FxHashSet()),\n+            existential_predicates: Lock::new(FxHashSet()),\n+            predicates: Lock::new(FxHashSet()),\n+            const_: Lock::new(FxHashSet()),\n         }\n     }\n \n@@ -892,11 +892,11 @@ pub struct GlobalCtxt<'tcx> {\n     /// by `proc-macro` crates.\n     pub derive_macros: RefCell<NodeMap<Symbol>>,\n \n-    stability_interner: RefCell<FxHashSet<&'tcx attr::Stability>>,\n+    stability_interner: Lock<FxHashSet<&'tcx attr::Stability>>,\n \n     pub interpret_interner: InterpretInterner<'tcx>,\n \n-    layout_interner: RefCell<FxHashSet<&'tcx LayoutDetails>>,\n+    layout_interner: Lock<FxHashSet<&'tcx LayoutDetails>>,\n \n     /// A vector of every trait accessible in the whole crate\n     /// (i.e. including those from subcrates). This is used only for\n@@ -910,15 +910,15 @@ pub struct GlobalCtxt<'tcx> {\n     /// This is intended to only get used during the trans phase of the compiler\n     /// when satisfying the query for a particular codegen unit. Internally in\n     /// the query it'll send data along this channel to get processed later.\n-    pub tx_to_llvm_workers: mpsc::Sender<Box<dyn Any + Send>>,\n+    pub tx_to_llvm_workers: Lock<mpsc::Sender<Box<dyn Any + Send>>>,\n \n     output_filenames: Arc<OutputFilenames>,\n }\n \n /// Everything needed to efficiently work with interned allocations\n #[derive(Debug, Default)]\n pub struct InterpretInterner<'tcx> {\n-    inner: RefCell<InterpretInternerInner<'tcx>>,\n+    inner: Lock<InterpretInternerInner<'tcx>>,\n }\n \n #[derive(Debug, Default)]\n@@ -1278,13 +1278,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             evaluation_cache: traits::EvaluationCache::new(),\n             crate_name: Symbol::intern(crate_name),\n             data_layout,\n-            layout_interner: RefCell::new(FxHashSet()),\n+            layout_interner: Lock::new(FxHashSet()),\n             layout_depth: Cell::new(0),\n             derive_macros: RefCell::new(NodeMap()),\n-            stability_interner: RefCell::new(FxHashSet()),\n+            stability_interner: Lock::new(FxHashSet()),\n             interpret_interner: Default::default(),\n             all_traits: RefCell::new(None),\n-            tx_to_llvm_workers: tx,\n+            tx_to_llvm_workers: Lock::new(tx),\n             output_filenames: Arc::new(output_filenames.clone()),\n         };\n "}, {"sha": "842c0d6573432fb962057b3432bb4707f75f3048", "filename": "src/librustc/ty/steal.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc%2Fty%2Fsteal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc%2Fty%2Fsteal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsteal.rs?ref=67712d79451b042b6fca2167c1a57d91d86f663b", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell::{Ref, RefCell};\n+use rustc_data_structures::sync::{RwLock, ReadGuard};\n use std::mem;\n \n /// The `Steal` struct is intended to used as the value for a query.\n@@ -32,25 +32,25 @@ use std::mem;\n ///\n /// FIXME(#41710) -- what is the best way to model linear queries?\n pub struct Steal<T> {\n-    value: RefCell<Option<T>>\n+    value: RwLock<Option<T>>\n }\n \n impl<T> Steal<T> {\n     pub fn new(value: T) -> Self {\n         Steal {\n-            value: RefCell::new(Some(value))\n+            value: RwLock::new(Some(value))\n         }\n     }\n \n-    pub fn borrow(&self) -> Ref<T> {\n-        Ref::map(self.value.borrow(), |opt| match *opt {\n+    pub fn borrow(&self) -> ReadGuard<T> {\n+        ReadGuard::map(self.value.borrow(), |opt| match *opt {\n             None => bug!(\"attempted to read from stolen value\"),\n             Some(ref v) => v\n         })\n     }\n \n     pub fn steal(&self) -> T {\n-        let value_ref = &mut *self.value.borrow_mut();\n+        let value_ref = &mut *self.value.try_write().expect(\"stealing value which is locked\");\n         let value = mem::replace(value_ref, None);\n         value.expect(\"attempt to read from stolen value\")\n     }"}, {"sha": "2049a146a0f02c85bad4d846edeaf3d9e581abcc", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=67712d79451b042b6fca2167c1a57d91d86f663b", "patch": "@@ -128,7 +128,7 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n     // Note that `mir_validated` is a \"stealable\" result; the\n     // thief, `optimized_mir()`, forces borrowck, so we know that\n     // is not yet stolen.\n-    tcx.mir_validated(owner_def_id).borrow();\n+    ty::maps::queries::mir_validated::ensure(tcx, owner_def_id);\n \n     // option dance because you can't capture an uninitialized variable\n     // by mut-ref."}, {"sha": "0f534f0adec4b919e3dcd5cfe5a533353a9c9462", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=67712d79451b042b6fca2167c1a57d91d86f663b", "patch": "@@ -388,6 +388,18 @@ impl<T> RwLock<T> {\n         f(&*self.read())\n     }\n \n+    #[cfg(not(parallel_queries))]\n+    #[inline(always)]\n+    pub fn try_write(&self) -> Result<WriteGuard<T>, ()> {\n+        self.0.try_borrow_mut().map_err(|_| ())\n+    }\n+\n+    #[cfg(parallel_queries)]\n+    #[inline(always)]\n+    pub fn try_write(&self) -> Result<WriteGuard<T>, ()> {\n+        self.0.try_write().ok_or(())\n+    }\n+\n     #[cfg(not(parallel_queries))]\n     #[inline(always)]\n     pub fn write(&self) -> WriteGuard<T> {"}, {"sha": "6c7565764119cae8d4150178e6b4a7f2cfd856bc", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=67712d79451b042b6fca2167c1a57d91d86f663b", "patch": "@@ -1035,7 +1035,7 @@ pub fn start_async_translation(tcx: TyCtxt,\n         crate_info,\n \n         time_graph,\n-        coordinator_send: tcx.tx_to_llvm_workers.clone(),\n+        coordinator_send: tcx.tx_to_llvm_workers.lock().clone(),\n         trans_worker_receive,\n         shared_emitter_main,\n         future: coordinator_thread,\n@@ -1428,7 +1428,7 @@ fn start_executing_work(tcx: TyCtxt,\n                         metadata_config: Arc<ModuleConfig>,\n                         allocator_config: Arc<ModuleConfig>)\n                         -> thread::JoinHandle<Result<CompiledModules, ()>> {\n-    let coordinator_send = tcx.tx_to_llvm_workers.clone();\n+    let coordinator_send = tcx.tx_to_llvm_workers.lock().clone();\n     let sess = tcx.sess;\n \n     // Compute the set of symbols we need to retain when doing LTO (if we need to)\n@@ -2340,7 +2340,7 @@ pub(crate) fn submit_translated_module_to_llvm(tcx: TyCtxt,\n                                                mtrans: ModuleTranslation,\n                                                cost: u64) {\n     let llvm_work_item = WorkItem::Optimize(mtrans);\n-    drop(tcx.tx_to_llvm_workers.send(Box::new(Message::TranslationDone {\n+    drop(tcx.tx_to_llvm_workers.lock().send(Box::new(Message::TranslationDone {\n         llvm_work_item,\n         cost,\n     })));"}, {"sha": "c25a7686bead0e8296460215c42d1d199feaa8cc", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=67712d79451b042b6fca2167c1a57d91d86f663b", "patch": "@@ -28,7 +28,7 @@ use std::collections::HashMap;\n use std::iter;\n use std::path::PathBuf;\n use std::rc::Rc;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{self, Lrc};\n use std::default::Default;\n use tokenstream::{self, TokenStream};\n \n@@ -565,26 +565,26 @@ pub enum SyntaxExtension {\n     /// `#[derive(...)]` is a `MultiItemDecorator`.\n     ///\n     /// Prefer ProcMacro or MultiModifier since they are more flexible.\n-    MultiDecorator(Box<MultiItemDecorator>),\n+    MultiDecorator(Box<MultiItemDecorator + sync::Sync + sync::Send>),\n \n     /// A syntax extension that is attached to an item and modifies it\n     /// in-place. Also allows decoration, i.e., creating new items.\n-    MultiModifier(Box<MultiItemModifier>),\n+    MultiModifier(Box<MultiItemModifier + sync::Sync + sync::Send>),\n \n     /// A function-like procedural macro. TokenStream -> TokenStream.\n-    ProcMacro(Box<ProcMacro>),\n+    ProcMacro(Box<ProcMacro + sync::Sync + sync::Send>),\n \n     /// An attribute-like procedural macro. TokenStream, TokenStream -> TokenStream.\n     /// The first TokenSteam is the attribute, the second is the annotated item.\n     /// Allows modification of the input items and adding new items, similar to\n     /// MultiModifier, but uses TokenStreams, rather than AST nodes.\n-    AttrProcMacro(Box<AttrProcMacro>),\n+    AttrProcMacro(Box<AttrProcMacro + sync::Sync + sync::Send>),\n \n     /// A normal, function-like syntax extension.\n     ///\n     /// `bytes!` is a `NormalTT`.\n     NormalTT {\n-        expander: Box<TTMacroExpander>,\n+        expander: Box<TTMacroExpander + sync::Sync + sync::Send>,\n         def_info: Option<(ast::NodeId, Span)>,\n         /// Whether the contents of the macro can\n         /// directly use `#[unstable]` things (true == yes).\n@@ -599,21 +599,23 @@ pub enum SyntaxExtension {\n     /// A function-like syntax extension that has an extra ident before\n     /// the block.\n     ///\n-    IdentTT(Box<IdentMacroExpander>, Option<Span>, bool),\n+    IdentTT(Box<IdentMacroExpander + sync::Sync + sync::Send>, Option<Span>, bool),\n \n     /// An attribute-like procedural macro. TokenStream -> TokenStream.\n     /// The input is the annotated item.\n     /// Allows generating code to implement a Trait for a given struct\n     /// or enum item.\n-    ProcMacroDerive(Box<MultiItemModifier>, Vec<Symbol> /* inert attribute names */),\n+    ProcMacroDerive(Box<MultiItemModifier +\n+                        sync::Sync +\n+                        sync::Send>, Vec<Symbol> /* inert attribute names */),\n \n     /// An attribute-like procedural macro that derives a builtin trait.\n     BuiltinDerive(BuiltinDeriveFn),\n \n     /// A declarative macro, e.g. `macro m() {}`.\n     ///\n     /// The second element is the definition site span.\n-    DeclMacro(Box<TTMacroExpander>, Option<(ast::NodeId, Span)>),\n+    DeclMacro(Box<TTMacroExpander + sync::Sync + sync::Send>, Option<(ast::NodeId, Span)>),\n }\n \n impl SyntaxExtension {"}, {"sha": "b1a22724a9ac39390738b2dda19d6d4f68ae933c", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=67712d79451b042b6fca2167c1a57d91d86f663b", "patch": "@@ -26,6 +26,8 @@\n #![feature(const_atomic_usize_new)]\n #![feature(rustc_attrs)]\n \n+#![recursion_limit=\"256\"]\n+\n // See librustc_cratesio_shim/Cargo.toml for a comment explaining this.\n #[allow(unused_extern_crates)]\n extern crate rustc_cratesio_shim;"}, {"sha": "39b2f77f2305e717d62216d22a8b53c3cfee0059", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=67712d79451b042b6fca2167c1a57d91d86f663b", "patch": "@@ -1781,7 +1781,6 @@ mod tests {\n     use errors;\n     use feature_gate::UnstableFeatures;\n     use parse::token;\n-    use std::cell::RefCell;\n     use std::collections::HashSet;\n     use std::io;\n     use std::path::PathBuf;\n@@ -1797,12 +1796,12 @@ mod tests {\n             span_diagnostic: errors::Handler::with_emitter(true, false, Box::new(emitter)),\n             unstable_features: UnstableFeatures::from_environment(),\n             config: CrateConfig::new(),\n-            included_mod_stack: RefCell::new(Vec::new()),\n+            included_mod_stack: Lock::new(Vec::new()),\n             code_map: cm,\n-            missing_fragment_specifiers: RefCell::new(HashSet::new()),\n-            raw_identifier_spans: RefCell::new(Vec::new()),\n+            missing_fragment_specifiers: Lock::new(HashSet::new()),\n+            raw_identifier_spans: Lock::new(Vec::new()),\n             registered_diagnostics: Lock::new(ErrorMap::new()),\n-            non_modrs_mods: RefCell::new(vec![]),\n+            non_modrs_mods: Lock::new(vec![]),\n         }\n     }\n "}, {"sha": "ff63c9a5c6d539ac1614011b5096a6aff631cc53", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=67712d79451b042b6fca2167c1a57d91d86f663b", "patch": "@@ -23,7 +23,6 @@ use symbol::Symbol;\n use tokenstream::{TokenStream, TokenTree};\n use diagnostics::plugin::ErrorMap;\n \n-use std::cell::RefCell;\n use std::collections::HashSet;\n use std::iter;\n use std::path::{Path, PathBuf};\n@@ -46,17 +45,17 @@ pub struct ParseSess {\n     pub span_diagnostic: Handler,\n     pub unstable_features: UnstableFeatures,\n     pub config: CrateConfig,\n-    pub missing_fragment_specifiers: RefCell<HashSet<Span>>,\n+    pub missing_fragment_specifiers: Lock<HashSet<Span>>,\n     /// Places where raw identifiers were used. This is used for feature gating\n     /// raw identifiers\n-    pub raw_identifier_spans: RefCell<Vec<Span>>,\n+    pub raw_identifier_spans: Lock<Vec<Span>>,\n     /// The registered diagnostics codes\n     pub registered_diagnostics: Lock<ErrorMap>,\n     // Spans where a `mod foo;` statement was included in a non-mod.rs file.\n     // These are used to issue errors if the non_modrs_mods feature is not enabled.\n-    pub non_modrs_mods: RefCell<Vec<(ast::Ident, Span)>>,\n+    pub non_modrs_mods: Lock<Vec<(ast::Ident, Span)>>,\n     /// Used to determine and report recursive mod inclusions\n-    included_mod_stack: RefCell<Vec<PathBuf>>,\n+    included_mod_stack: Lock<Vec<PathBuf>>,\n     code_map: Lrc<CodeMap>,\n }\n \n@@ -75,12 +74,12 @@ impl ParseSess {\n             span_diagnostic: handler,\n             unstable_features: UnstableFeatures::from_environment(),\n             config: HashSet::new(),\n-            missing_fragment_specifiers: RefCell::new(HashSet::new()),\n-            raw_identifier_spans: RefCell::new(Vec::new()),\n+            missing_fragment_specifiers: Lock::new(HashSet::new()),\n+            raw_identifier_spans: Lock::new(Vec::new()),\n             registered_diagnostics: Lock::new(ErrorMap::new()),\n-            included_mod_stack: RefCell::new(vec![]),\n+            included_mod_stack: Lock::new(vec![]),\n             code_map,\n-            non_modrs_mods: RefCell::new(vec![]),\n+            non_modrs_mods: Lock::new(vec![]),\n         }\n     }\n "}, {"sha": "8da79f92768a1c31e3658f7a6b4654301f2ebada", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67712d79451b042b6fca2167c1a57d91d86f663b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=67712d79451b042b6fca2167c1a57d91d86f663b", "patch": "@@ -25,9 +25,8 @@ use syntax_pos::{self, Span, FileName};\n use tokenstream::{TokenStream, TokenTree};\n use tokenstream;\n \n-use std::cell::Cell;\n use std::{cmp, fmt};\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{Lrc, Lock};\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n pub enum BinOpToken {\n@@ -627,15 +626,8 @@ pub fn is_op(tok: &Token) -> bool {\n     }\n }\n \n-pub struct LazyTokenStream(Cell<Option<TokenStream>>);\n-\n-impl Clone for LazyTokenStream {\n-    fn clone(&self) -> Self {\n-        let opt_stream = self.0.take();\n-        self.0.set(opt_stream.clone());\n-        LazyTokenStream(Cell::new(opt_stream))\n-    }\n-}\n+#[derive(Clone)]\n+pub struct LazyTokenStream(Lock<Option<TokenStream>>);\n \n impl cmp::Eq for LazyTokenStream {}\n impl PartialEq for LazyTokenStream {\n@@ -652,15 +644,14 @@ impl fmt::Debug for LazyTokenStream {\n \n impl LazyTokenStream {\n     pub fn new() -> Self {\n-        LazyTokenStream(Cell::new(None))\n+        LazyTokenStream(Lock::new(None))\n     }\n \n     pub fn force<F: FnOnce() -> TokenStream>(&self, f: F) -> TokenStream {\n-        let mut opt_stream = self.0.take();\n+        let mut opt_stream = self.0.lock();\n         if opt_stream.is_none() {\n-            opt_stream = Some(f());\n+            *opt_stream = Some(f());\n         }\n-        self.0.set(opt_stream.clone());\n         opt_stream.clone().unwrap()\n     }\n }"}]}