{"sha": "5a13217ea9c07121e7d3cdcfb0ddd2aa52b90f12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMTMyMTdlYTljMDcxMjFlN2QzY2RjZmIwZGRkMmFhNTJiOTBmMTI=", "commit": {"author": {"name": "ThibsG", "email": "Thibs@debian.com", "date": "2020-10-16T15:58:26Z"}, "committer": {"name": "ThibsG", "email": "Thibs@debian.com", "date": "2020-10-17T09:54:25Z"}, "message": "Assert macro args extractor as a common function in higher", "tree": {"sha": "598dacc9747c12908a031eaa62e060c9927df6eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/598dacc9747c12908a031eaa62e060c9927df6eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a13217ea9c07121e7d3cdcfb0ddd2aa52b90f12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a13217ea9c07121e7d3cdcfb0ddd2aa52b90f12", "html_url": "https://github.com/rust-lang/rust/commit/5a13217ea9c07121e7d3cdcfb0ddd2aa52b90f12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a13217ea9c07121e7d3cdcfb0ddd2aa52b90f12/comments", "author": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71c29b5be8526562c3de8d3b7dc94611647ee120", "url": "https://api.github.com/repos/rust-lang/rust/commits/71c29b5be8526562c3de8d3b7dc94611647ee120", "html_url": "https://github.com/rust-lang/rust/commit/71c29b5be8526562c3de8d3b7dc94611647ee120"}], "stats": {"total": 132, "additions": 69, "deletions": 63}, "files": [{"sha": "3201adbf9a0b60147bd8dd96cdb0025e082f9cbc", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a13217ea9c07121e7d3cdcfb0ddd2aa52b90f12/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a13217ea9c07121e7d3cdcfb0ddd2aa52b90f12/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=5a13217ea9c07121e7d3cdcfb0ddd2aa52b90f12", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{\n-    eq_expr_value, implements_trait, in_macro, is_copy, is_expn_of, multispan_sugg, snippet, span_lint,\n+    eq_expr_value, higher, implements_trait, in_macro, is_copy, is_expn_of, multispan_sugg, snippet, span_lint,\n     span_lint_and_then,\n };\n use if_chain::if_chain;\n@@ -71,13 +71,9 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                     if_chain! {\n                         if is_expn_of(stmt.span, amn).is_some();\n                         if let StmtKind::Semi(ref matchexpr) = stmt.kind;\n-                        if let ExprKind::Block(ref matchblock, _) = matchexpr.kind;\n-                        if let Some(ref matchheader) = matchblock.expr;\n-                        if let ExprKind::Match(ref headerexpr, _, _) = matchheader.kind;\n-                        if let ExprKind::Tup(ref conditions) = headerexpr.kind;\n-                        if conditions.len() == 2;\n-                        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref lhs) = conditions[0].kind;\n-                        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref rhs) = conditions[1].kind;\n+                        if let Some(macro_args) = higher::extract_assert_macro_args(matchexpr);\n+                        if macro_args.len() == 2;\n+                        let (lhs, rhs) = (macro_args[0], macro_args[1]);\n                         if eq_expr_value(cx, lhs, rhs);\n \n                         then {"}, {"sha": "76417aa7ed09d39682788314a61b2213c05ec0b9", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 11, "deletions": 55, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5a13217ea9c07121e7d3cdcfb0ddd2aa52b90f12/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a13217ea9c07121e7d3cdcfb0ddd2aa52b90f12/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=5a13217ea9c07121e7d3cdcfb0ddd2aa52b90f12", "patch": "@@ -1,7 +1,6 @@\n-use crate::utils::{is_direct_expn_of, span_lint};\n-use if_chain::if_chain;\n+use crate::utils::{higher, is_direct_expn_of, span_lint};\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{BorrowKind, Expr, ExprKind, MatchSource, Mutability, StmtKind, UnOp};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, MatchSource, Mutability};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty;\n@@ -39,66 +38,23 @@ impl<'tcx> LateLintPass<'tcx> for DebugAssertWithMutCall {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         for dmn in &DEBUG_MACRO_NAMES {\n             if is_direct_expn_of(e.span, dmn).is_some() {\n-                if let Some(span) = extract_call(cx, e) {\n-                    span_lint(\n-                        cx,\n-                        DEBUG_ASSERT_WITH_MUT_CALL,\n-                        span,\n-                        &format!(\"do not call a function with mutable arguments inside of `{}!`\", dmn),\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-//HACK(hellow554): remove this when #4694 is implemented\n-fn extract_call<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> Option<Span> {\n-    if_chain! {\n-        if let ExprKind::Block(ref block, _) = e.kind;\n-        if block.stmts.len() == 1;\n-        if let StmtKind::Semi(ref matchexpr) = block.stmts[0].kind;\n-        then {\n-            // debug_assert\n-            if_chain! {\n-                if let ExprKind::Match(ref ifclause, _, _) = matchexpr.kind;\n-                if let ExprKind::DropTemps(ref droptmp) = ifclause.kind;\n-                if let ExprKind::Unary(UnOp::UnNot, ref condition) = droptmp.kind;\n-                then {\n-                    let mut visitor = MutArgVisitor::new(cx);\n-                    visitor.visit_expr(condition);\n-                    return visitor.expr_span();\n-                }\n-            }\n-\n-            // debug_assert_{eq,ne}\n-            if_chain! {\n-                if let ExprKind::Block(ref matchblock, _) = matchexpr.kind;\n-                if let Some(ref matchheader) = matchblock.expr;\n-                if let ExprKind::Match(ref headerexpr, _, _) = matchheader.kind;\n-                if let ExprKind::Tup(ref conditions) = headerexpr.kind;\n-                if conditions.len() == 2;\n-                then {\n-                    if let ExprKind::AddrOf(BorrowKind::Ref, _, ref lhs) = conditions[0].kind {\n+                if let Some(macro_args) = higher::extract_assert_macro_args(e) {\n+                    for arg in macro_args {\n                         let mut visitor = MutArgVisitor::new(cx);\n-                        visitor.visit_expr(lhs);\n+                        visitor.visit_expr(arg);\n                         if let Some(span) = visitor.expr_span() {\n-                            return Some(span);\n-                        }\n-                    }\n-                    if let ExprKind::AddrOf(BorrowKind::Ref, _, ref rhs) = conditions[1].kind {\n-                        let mut visitor = MutArgVisitor::new(cx);\n-                        visitor.visit_expr(rhs);\n-                        if let Some(span) = visitor.expr_span() {\n-                            return Some(span);\n+                            span_lint(\n+                                cx,\n+                                DEBUG_ASSERT_WITH_MUT_CALL,\n+                                span,\n+                                &format!(\"do not call a function with mutable arguments inside of `{}!`\", dmn),\n+                            );\n                         }\n                     }\n                 }\n             }\n         }\n     }\n-\n-    None\n }\n \n struct MutArgVisitor<'a, 'tcx> {"}, {"sha": "6d7c5058b4f30eee27114d4b532dec5e2a690af2", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5a13217ea9c07121e7d3cdcfb0ddd2aa52b90f12/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a13217ea9c07121e7d3cdcfb0ddd2aa52b90f12/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=5a13217ea9c07121e7d3cdcfb0ddd2aa52b90f12", "patch": "@@ -7,6 +7,7 @@ use crate::utils::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_hir as hir;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, StmtKind, UnOp};\n use rustc_lint::LateContext;\n \n /// Converts a hir binary operator to the corresponding `ast` type.\n@@ -241,3 +242,56 @@ pub fn vec_macro<'e>(cx: &LateContext<'_>, expr: &'e hir::Expr<'_>) -> Option<Ve\n \n     None\n }\n+\n+/// Extract args from an assert-like macro.\n+/// Currently working with:\n+/// - `assert!`, `assert_eq!` and `assert_ne!`\n+/// - `debug_assert!`, `debug_assert_eq!` and `debug_assert_ne!`\n+/// For example:\n+/// `assert!(expr)` will return Some([expr])\n+/// `debug_assert_eq!(a, b)` will return Some([a, b])\n+pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx Expr<'tcx>>> {\n+    /// Try to match the AST for a pattern that contains a match, for example when two args are\n+    /// compared\n+    fn ast_matchblock(matchblock_expr: &'tcx Expr<'tcx>) -> Option<Vec<&Expr<'_>>> {\n+        if_chain! {\n+            if let ExprKind::Match(ref headerexpr, _, _) = &matchblock_expr.kind;\n+            if let ExprKind::Tup([lhs, rhs]) = &headerexpr.kind;\n+            if let ExprKind::AddrOf(BorrowKind::Ref, _, lhs) = lhs.kind;\n+            if let ExprKind::AddrOf(BorrowKind::Ref, _, rhs) = rhs.kind;\n+            then {\n+                return Some(vec![lhs, rhs]);\n+            }\n+        }\n+        None\n+    }\n+\n+    if let ExprKind::Block(ref block, _) = e.kind {\n+        if block.stmts.len() == 1 {\n+            if let StmtKind::Semi(ref matchexpr) = block.stmts[0].kind {\n+                // macros with unique arg: `{debug_}assert!` (e.g., `debug_assert!(some_condition)`)\n+                if_chain! {\n+                    if let ExprKind::Match(ref ifclause, _, _) = matchexpr.kind;\n+                    if let ExprKind::DropTemps(ref droptmp) = ifclause.kind;\n+                    if let ExprKind::Unary(UnOp::UnNot, condition) = droptmp.kind;\n+                    then {\n+                        return Some(vec![condition]);\n+                    }\n+                }\n+\n+                // debug macros with two args: `debug_assert_{ne, eq}` (e.g., `assert_ne!(a, b)`)\n+                if_chain! {\n+                    if let ExprKind::Block(ref matchblock,_) = matchexpr.kind;\n+                    if let Some(ref matchblock_expr) = matchblock.expr;\n+                    then {\n+                        return ast_matchblock(matchblock_expr);\n+                    }\n+                }\n+            }\n+        } else if let Some(matchblock_expr) = block.expr {\n+            // macros with two args: `assert_{ne, eq}` (e.g., `assert_ne!(a, b)`)\n+            return ast_matchblock(&matchblock_expr);\n+        }\n+    }\n+    None\n+}"}]}