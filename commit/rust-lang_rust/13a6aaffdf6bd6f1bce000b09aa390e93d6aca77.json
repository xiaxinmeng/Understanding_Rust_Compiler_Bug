{"sha": "13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "node_id": "C_kwDOAAsO6NoAKDEzYTZhYWZmZGY2YmQ2ZjFiY2UwMDBiMDlhYTM5MGU5M2Q2YWNhNzc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-26T03:23:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-26T03:23:54Z"}, "message": "Auto merge of #101017 - JohnTitor:rollup-73f2fhb, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #99064 (distinguish the method and associated function diagnostic information)\n - #99920 (Custom allocator support in `rustc_serialize`)\n - #100034 ( Elaborate all box dereferences in `ElaborateBoxDerefs`)\n - #100076 (make slice::{split_at,split_at_unchecked} const functions)\n - #100604 (Remove unstable Result::into_ok_or_err)\n - #100933 (Reduce code size of `assert_matches_failed`)\n - #100978 (Handle `Err` in `ast::LitKind::to_token_lit`.)\n - #101010 (rustdoc: remove unused CSS for `.multi-column`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "76d60e3604e38838c1f2203a916df062c3522e78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76d60e3604e38838c1f2203a916df062c3522e78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "html_url": "https://github.com/rust-lang/rust/commit/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76f3b891a0c48e128c5a43ef57e70d86735e1cf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/76f3b891a0c48e128c5a43ef57e70d86735e1cf2", "html_url": "https://github.com/rust-lang/rust/commit/76f3b891a0c48e128c5a43ef57e70d86735e1cf2"}, {"sha": "b4d5f48e43f2f7d53ac058877e663229f1407e86", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4d5f48e43f2f7d53ac058877e663229f1407e86", "html_url": "https://github.com/rust-lang/rust/commit/b4d5f48e43f2f7d53ac058877e663229f1407e86"}], "stats": {"total": 442, "additions": 187, "deletions": 255}, "files": [{"sha": "69a78d165ef5895ad654b51103bd6efa21f5d016", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -199,7 +199,9 @@ impl LitKind {\n                 let symbol = if value { kw::True } else { kw::False };\n                 (token::Bool, symbol, None)\n             }\n-            LitKind::Err => unreachable!(),\n+            // This only shows up in places like `-Zunpretty=hir` output, so we\n+            // don't bother to produce something useful.\n+            LitKind::Err => (token::Err, Symbol::intern(\"<bad-literal>\"), None),\n         };\n \n         token::Lit::new(kind, symbol, suffix)"}, {"sha": "c59a40df03988aeec2b908ad36e9e4413793533b", "filename": "compiler/rustc_codegen_gcc/patches/0024-core-Disable-portable-simd-test.patch", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -14,7 +14,6 @@ index 06c7be0..359e2e7 100644\n @@ -75,7 +75,6 @@\n  #![feature(never_type)]\n  #![feature(unwrap_infallible)]\n- #![feature(result_into_ok_or_err)]\n -#![feature(portable_simd)]\n  #![feature(ptr_metadata)]\n  #![feature(once_cell)]"}, {"sha": "9da9b4e91f647273a34db162de6173820a597c35", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -1531,6 +1531,7 @@ impl<'tcx> Place<'tcx> {\n }\n \n impl From<Local> for Place<'_> {\n+    #[inline]\n     fn from(local: Local) -> Self {\n         Place { local, projection: List::empty() }\n     }"}, {"sha": "483c1e274aa7809d6b3cffeb5ab5be003072d642", "filename": "compiler/rustc_mir_dataflow/src/impls/liveness.rs", "status": "modified", "additions": 65, "deletions": 40, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -23,12 +23,6 @@ use crate::{Analysis, AnalysisDomain, Backward, CallReturnPlaces, GenKill, GenKi\n /// [liveness]: https://en.wikipedia.org/wiki/Live_variable_analysis\n pub struct MaybeLiveLocals;\n \n-impl MaybeLiveLocals {\n-    fn transfer_function<'a, T>(&self, trans: &'a mut T) -> TransferFunction<'a, T> {\n-        TransferFunction(trans)\n-    }\n-}\n-\n impl<'tcx> AnalysisDomain<'tcx> for MaybeLiveLocals {\n     type Domain = ChunkedBitSet<Local>;\n     type Direction = Backward;\n@@ -54,7 +48,7 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeLiveLocals {\n         statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n-        self.transfer_function(trans).visit_statement(statement, location);\n+        TransferFunction(trans).visit_statement(statement, location);\n     }\n \n     fn terminator_effect(\n@@ -63,7 +57,7 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeLiveLocals {\n         terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n-        self.transfer_function(trans).visit_terminator(terminator, location);\n+        TransferFunction(trans).visit_terminator(terminator, location);\n     }\n \n     fn call_return_effect(\n@@ -85,9 +79,11 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeLiveLocals {\n         _resume_block: mir::BasicBlock,\n         resume_place: mir::Place<'tcx>,\n     ) {\n-        if let Some(local) = resume_place.as_local() {\n-            trans.kill(local);\n-        }\n+        YieldResumeEffect(trans).visit_place(\n+            &resume_place,\n+            PlaceContext::MutatingUse(MutatingUseContext::Yield),\n+            Location::START,\n+        )\n     }\n }\n \n@@ -98,28 +94,51 @@ where\n     T: GenKill<Local>,\n {\n     fn visit_place(&mut self, place: &mir::Place<'tcx>, context: PlaceContext, location: Location) {\n-        let local = place.local;\n-\n-        // We purposefully do not call `super_place` here to avoid calling `visit_local` for this\n-        // place with one of the `Projection` variants of `PlaceContext`.\n-        self.visit_projection(place.as_ref(), context, location);\n+        if let PlaceContext::MutatingUse(MutatingUseContext::Yield) = context {\n+            // The resume place is evaluated and assigned to only after generator resumes, so its\n+            // effect is handled separately in `yield_resume_effect`.\n+            return;\n+        }\n \n         match DefUse::for_place(*place, context) {\n-            Some(DefUse::Def) => self.0.kill(local),\n-            Some(DefUse::Use) => self.0.gen(local),\n+            Some(DefUse::Def) => {\n+                if let PlaceContext::MutatingUse(\n+                    MutatingUseContext::Call | MutatingUseContext::AsmOutput,\n+                ) = context\n+                {\n+                    // For the associated terminators, this is only a `Def` when the terminator returns\n+                    // \"successfully.\" As such, we handle this case separately in `call_return_effect`\n+                    // above. However, if the place looks like `*_5`, this is still unconditionally a use of\n+                    // `_5`.\n+                } else {\n+                    self.0.kill(place.local);\n+                }\n+            }\n+            Some(DefUse::Use) => self.0.gen(place.local),\n             None => {}\n         }\n+\n+        self.visit_projection(place.as_ref(), context, location);\n     }\n \n     fn visit_local(&mut self, local: Local, context: PlaceContext, _: Location) {\n-        // Because we do not call `super_place` above, `visit_local` is only called for locals that\n-        // do not appear as part of  a `Place` in the MIR. This handles cases like the implicit use\n-        // of the return place in a `Return` terminator or the index in an `Index` projection.\n-        match DefUse::for_place(local.into(), context) {\n-            Some(DefUse::Def) => self.0.kill(local),\n-            Some(DefUse::Use) => self.0.gen(local),\n-            None => {}\n-        }\n+        DefUse::apply(self.0, local.into(), context);\n+    }\n+}\n+\n+struct YieldResumeEffect<'a, T>(&'a mut T);\n+\n+impl<'tcx, T> Visitor<'tcx> for YieldResumeEffect<'_, T>\n+where\n+    T: GenKill<Local>,\n+{\n+    fn visit_place(&mut self, place: &mir::Place<'tcx>, context: PlaceContext, location: Location) {\n+        DefUse::apply(self.0, *place, context);\n+        self.visit_projection(place.as_ref(), context, location);\n+    }\n+\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, _: Location) {\n+        DefUse::apply(self.0, local.into(), context);\n     }\n }\n \n@@ -130,11 +149,25 @@ enum DefUse {\n }\n \n impl DefUse {\n+    fn apply<'tcx>(trans: &mut impl GenKill<Local>, place: Place<'tcx>, context: PlaceContext) {\n+        match DefUse::for_place(place, context) {\n+            Some(DefUse::Def) => trans.kill(place.local),\n+            Some(DefUse::Use) => trans.gen(place.local),\n+            None => {}\n+        }\n+    }\n+\n     fn for_place<'tcx>(place: Place<'tcx>, context: PlaceContext) -> Option<DefUse> {\n         match context {\n             PlaceContext::NonUse(_) => None,\n \n-            PlaceContext::MutatingUse(MutatingUseContext::Store | MutatingUseContext::Deinit) => {\n+            PlaceContext::MutatingUse(\n+                MutatingUseContext::Call\n+                | MutatingUseContext::Yield\n+                | MutatingUseContext::AsmOutput\n+                | MutatingUseContext::Store\n+                | MutatingUseContext::Deinit,\n+            ) => {\n                 if place.is_indirect() {\n                     // Treat derefs as a use of the base local. `*p = 4` is not a def of `p` but a\n                     // use.\n@@ -152,16 +185,6 @@ impl DefUse {\n                 place.is_indirect().then_some(DefUse::Use)\n             }\n \n-            // For the associated terminators, this is only a `Def` when the terminator returns\n-            // \"successfully.\" As such, we handle this case separately in `call_return_effect`\n-            // above. However, if the place looks like `*_5`, this is still unconditionally a use of\n-            // `_5`.\n-            PlaceContext::MutatingUse(\n-                MutatingUseContext::Call\n-                | MutatingUseContext::Yield\n-                | MutatingUseContext::AsmOutput,\n-            ) => place.is_indirect().then_some(DefUse::Use),\n-\n             // All other contexts are uses...\n             PlaceContext::MutatingUse(\n                 MutatingUseContext::AddressOf\n@@ -290,8 +313,10 @@ impl<'a, 'tcx> Analysis<'tcx> for MaybeTransitiveLiveLocals<'a> {\n         _resume_block: mir::BasicBlock,\n         resume_place: mir::Place<'tcx>,\n     ) {\n-        if let Some(local) = resume_place.as_local() {\n-            trans.remove(local);\n-        }\n+        YieldResumeEffect(trans).visit_place(\n+            &resume_place,\n+            PlaceContext::MutatingUse(MutatingUseContext::Yield),\n+            Location::START,\n+        )\n     }\n }"}, {"sha": "294af2455d069607b2b8e348d3087cf047a28413", "filename": "compiler/rustc_mir_transform/src/elaborate_box_derefs.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -107,27 +107,8 @@ impl<'tcx> MirPass<'tcx> for ElaborateBoxDerefs {\n             let mut visitor =\n                 ElaborateBoxDerefVisitor { tcx, unique_did, nonnull_did, local_decls, patch };\n \n-            for (block, BasicBlockData { statements, terminator, .. }) in\n-                body.basic_blocks.as_mut_preserves_cfg().iter_enumerated_mut()\n-            {\n-                let mut index = 0;\n-                for statement in statements {\n-                    let location = Location { block, statement_index: index };\n-                    visitor.visit_statement(statement, location);\n-                    index += 1;\n-                }\n-\n-                let location = Location { block, statement_index: index };\n-                match terminator {\n-                    // yielding into a box is handled when lowering generators\n-                    Some(Terminator { kind: TerminatorKind::Yield { value, .. }, .. }) => {\n-                        visitor.visit_operand(value, location);\n-                    }\n-                    Some(terminator) => {\n-                        visitor.visit_terminator(terminator, location);\n-                    }\n-                    None => {}\n-                }\n+            for (block, data) in body.basic_blocks.as_mut_preserves_cfg().iter_enumerated_mut() {\n+                visitor.visit_basic_block_data(block, data);\n             }\n \n             visitor.patch.apply(body);"}, {"sha": "5b0d9900c0fb5cb5a3ef1db6425c00926790aee4", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 7, "deletions": 81, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -1182,8 +1182,6 @@ fn create_cases<'tcx>(\n     transform: &TransformVisitor<'tcx>,\n     operation: Operation,\n ) -> Vec<(usize, BasicBlock)> {\n-    let tcx = transform.tcx;\n-\n     let source_info = SourceInfo::outermost(body.span);\n \n     transform\n@@ -1216,85 +1214,13 @@ fn create_cases<'tcx>(\n                 if operation == Operation::Resume {\n                     // Move the resume argument to the destination place of the `Yield` terminator\n                     let resume_arg = Local::new(2); // 0 = return, 1 = self\n-\n-                    // handle `box yield` properly\n-                    let box_place = if let [projection @ .., ProjectionElem::Deref] =\n-                        &**point.resume_arg.projection\n-                    {\n-                        let box_place =\n-                            Place::from(point.resume_arg.local).project_deeper(projection, tcx);\n-\n-                        let box_ty = box_place.ty(&body.local_decls, tcx).ty;\n-\n-                        if box_ty.is_box() { Some((box_place, box_ty)) } else { None }\n-                    } else {\n-                        None\n-                    };\n-\n-                    if let Some((box_place, box_ty)) = box_place {\n-                        let unique_did = box_ty\n-                            .ty_adt_def()\n-                            .expect(\"expected Box to be an Adt\")\n-                            .non_enum_variant()\n-                            .fields[0]\n-                            .did;\n-\n-                        let Some(nonnull_def) = tcx.type_of(unique_did).ty_adt_def() else {\n-                            span_bug!(tcx.def_span(unique_did), \"expected Box to contain Unique\")\n-                        };\n-\n-                        let nonnull_did = nonnull_def.non_enum_variant().fields[0].did;\n-\n-                        let (unique_ty, nonnull_ty, ptr_ty) =\n-                            crate::elaborate_box_derefs::build_ptr_tys(\n-                                tcx,\n-                                box_ty.boxed_ty(),\n-                                unique_did,\n-                                nonnull_did,\n-                            );\n-\n-                        let ptr_local = body.local_decls.push(LocalDecl::new(ptr_ty, body.span));\n-\n-                        statements.push(Statement {\n-                            source_info,\n-                            kind: StatementKind::StorageLive(ptr_local),\n-                        });\n-\n-                        statements.push(Statement {\n-                            source_info,\n-                            kind: StatementKind::Assign(Box::new((\n-                                Place::from(ptr_local),\n-                                Rvalue::Use(Operand::Copy(box_place.project_deeper(\n-                                    &crate::elaborate_box_derefs::build_projection(\n-                                        unique_ty, nonnull_ty, ptr_ty,\n-                                    ),\n-                                    tcx,\n-                                ))),\n-                            ))),\n-                        });\n-\n-                        statements.push(Statement {\n-                            source_info,\n-                            kind: StatementKind::Assign(Box::new((\n-                                Place::from(ptr_local)\n-                                    .project_deeper(&[ProjectionElem::Deref], tcx),\n-                                Rvalue::Use(Operand::Move(resume_arg.into())),\n-                            ))),\n-                        });\n-\n-                        statements.push(Statement {\n-                            source_info,\n-                            kind: StatementKind::StorageDead(ptr_local),\n-                        });\n-                    } else {\n-                        statements.push(Statement {\n-                            source_info,\n-                            kind: StatementKind::Assign(Box::new((\n-                                point.resume_arg,\n-                                Rvalue::Use(Operand::Move(resume_arg.into())),\n-                            ))),\n-                        });\n-                    }\n+                    statements.push(Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(Box::new((\n+                            point.resume_arg,\n+                            Rvalue::Use(Operand::Move(resume_arg.into())),\n+                        ))),\n+                    });\n                 }\n \n                 // Then jump to the real target"}, {"sha": "91f4cfaf5acaae528923df6084c4871229d230d5", "filename": "compiler/rustc_serialize/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Flib.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -16,6 +16,7 @@ Core encoding and decoding interfaces.\n #![feature(maybe_uninit_slice)]\n #![feature(let_else)]\n #![feature(new_uninit)]\n+#![feature(allocator_api)]\n #![cfg_attr(test, feature(test))]\n #![allow(rustc::internal)]\n #![deny(rustc::untranslatable_diagnostic)]"}, {"sha": "751b209f11a3a899614b80a6e20f7d830f646da1", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -4,6 +4,7 @@\n Core encoding and decoding interfaces.\n */\n \n+use std::alloc::Allocator;\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::marker::PhantomData;\n@@ -229,9 +230,9 @@ impl<D: Decoder, T> Decodable<D> for PhantomData<T> {\n     }\n }\n \n-impl<D: Decoder, T: Decodable<D>> Decodable<D> for Box<[T]> {\n-    fn decode(d: &mut D) -> Box<[T]> {\n-        let v: Vec<T> = Decodable::decode(d);\n+impl<D: Decoder, A: Allocator + Default, T: Decodable<D>> Decodable<D> for Box<[T], A> {\n+    fn decode(d: &mut D) -> Box<[T], A> {\n+        let v: Vec<T, A> = Decodable::decode(d);\n         v.into_boxed_slice()\n     }\n }\n@@ -264,12 +265,13 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for Vec<T> {\n     }\n }\n \n-impl<D: Decoder, T: Decodable<D>> Decodable<D> for Vec<T> {\n-    default fn decode(d: &mut D) -> Vec<T> {\n+impl<D: Decoder, T: Decodable<D>, A: Allocator + Default> Decodable<D> for Vec<T, A> {\n+    default fn decode(d: &mut D) -> Vec<T, A> {\n         let len = d.read_usize();\n+        let allocator = A::default();\n         // SAFETY: we set the capacity in advance, only write elements, and\n         // only set the length at the end once the writing has succeeded.\n-        let mut vec = Vec::with_capacity(len);\n+        let mut vec = Vec::with_capacity_in(len, allocator);\n         unsafe {\n             let ptr: *mut T = vec.as_mut_ptr();\n             for i in 0..len {\n@@ -457,13 +459,15 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Arc<T> {\n     }\n }\n \n-impl<S: Encoder, T: ?Sized + Encodable<S>> Encodable<S> for Box<T> {\n+impl<S: Encoder, T: ?Sized + Encodable<S>, A: Allocator + Default> Encodable<S> for Box<T, A> {\n     fn encode(&self, s: &mut S) {\n-        (**self).encode(s);\n+        (**self).encode(s)\n     }\n }\n-impl<D: Decoder, T: Decodable<D>> Decodable<D> for Box<T> {\n-    fn decode(d: &mut D) -> Box<T> {\n-        Box::new(Decodable::decode(d))\n+\n+impl<D: Decoder, A: Allocator + Default, T: Decodable<D>> Decodable<D> for Box<T, A> {\n+    fn decode(d: &mut D) -> Box<T, A> {\n+        let allocator = A::default();\n+        Box::new_in(Decodable::decode(d), allocator)\n     }\n }"}, {"sha": "93cab7ca533954b216e7df75b6efbedc8fae21e1", "filename": "compiler/rustc_transmute/src/layout/tree.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -1,4 +1,5 @@\n use super::{Byte, Def, Ref};\n+use std::ops::ControlFlow;\n \n #[cfg(test)]\n mod tests;\n@@ -86,17 +87,18 @@ where\n         F: Fn(D) -> bool,\n     {\n         match self {\n-            Self::Seq(elts) => elts\n-                .into_iter()\n-                .map(|elt| elt.prune(f))\n-                .try_fold(Tree::unit(), |elts, elt| {\n+            Self::Seq(elts) => match elts.into_iter().map(|elt| elt.prune(f)).try_fold(\n+                Tree::unit(),\n+                |elts, elt| {\n                     if elt == Tree::uninhabited() {\n-                        Err(Tree::uninhabited())\n+                        ControlFlow::Break(Tree::uninhabited())\n                     } else {\n-                        Ok(elts.then(elt))\n+                        ControlFlow::Continue(elts.then(elt))\n                     }\n-                })\n-                .into_ok_or_err(),\n+                },\n+            ) {\n+                ControlFlow::Break(node) | ControlFlow::Continue(node) => node,\n+            },\n             Self::Alt(alts) => alts\n                 .into_iter()\n                 .map(|alt| alt.prune(f))"}, {"sha": "89b1ce5abe9e80d7a635d584ea7f2cf987964222", "filename": "compiler/rustc_transmute/src/lib.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flib.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -1,11 +1,4 @@\n-#![feature(\n-    alloc_layout_extra,\n-    control_flow_enum,\n-    decl_macro,\n-    iterator_try_reduce,\n-    never_type,\n-    result_into_ok_or_err\n-)]\n+#![feature(alloc_layout_extra, control_flow_enum, decl_macro, iterator_try_reduce, never_type)]\n #![allow(dead_code, unused_variables)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]"}, {"sha": "441a62256de88828cd021a7b73966f376d5ae1ec", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -1066,16 +1066,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // that had unsatisfied trait bounds\n                     if unsatisfied_predicates.is_empty() {\n                         let def_kind = lev_candidate.kind.as_def_kind();\n-                        err.span_suggestion(\n-                            span,\n-                            &format!(\n-                                \"there is {} {} with a similar name\",\n-                                def_kind.article(),\n-                                def_kind.descr(lev_candidate.def_id),\n-                            ),\n-                            lev_candidate.name,\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        // Methods are defined within the context of a struct and their first parameter is always self,\n+                        // which represents the instance of the struct the method is being called on\n+                        // Associated functions don\u2019t take self as a parameter and\n+                        // they are not methods because they don\u2019t have an instance of the struct to work with.\n+                        if def_kind == DefKind::AssocFn && lev_candidate.fn_has_self_parameter {\n+                            err.span_suggestion(\n+                                span,\n+                                &format!(\"there is a method with a similar name\",),\n+                                lev_candidate.name,\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        } else {\n+                            err.span_suggestion(\n+                                span,\n+                                &format!(\n+                                    \"there is {} {} with a similar name\",\n+                                    def_kind.article(),\n+                                    def_kind.descr(lev_candidate.def_id),\n+                                ),\n+                                lev_candidate.name,\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n                     }\n                 }\n "}, {"sha": "afec497ee44d9f3203c062c61711e2e856f134d0", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -149,6 +149,7 @@\n #![feature(maybe_uninit_uninit_array)]\n #![feature(ptr_metadata)]\n #![feature(slice_ptr_get)]\n+#![feature(slice_split_at_unchecked)]\n #![feature(str_internals)]\n #![feature(utf16_extra)]\n #![feature(utf16_extra_const)]"}, {"sha": "d4afe0f5326a362bf8a845e3751f56ff5333a009", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -190,11 +190,11 @@ pub fn assert_matches_failed<T: fmt::Debug + ?Sized>(\n     right: &str,\n     args: Option<fmt::Arguments<'_>>,\n ) -> ! {\n-    // Use the Display implementation to display the pattern.\n+    // The pattern is a string so it can be displayed directly.\n     struct Pattern<'a>(&'a str);\n     impl fmt::Debug for Pattern<'_> {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            fmt::Display::fmt(self.0, f)\n+            f.write_str(self.0)\n         }\n     }\n     assert_failed_inner(AssertKind::Match, &left, &Pattern(right), args);"}, {"sha": "76eaa191f7811db5f9142638be616ffd10ae239c", "filename": "library/core/src/result.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -1776,40 +1776,6 @@ impl<T, E> Result<Result<T, E>, E> {\n     }\n }\n \n-impl<T> Result<T, T> {\n-    /// Returns the [`Ok`] value if `self` is `Ok`, and the [`Err`] value if\n-    /// `self` is `Err`.\n-    ///\n-    /// In other words, this function returns the value (the `T`) of a\n-    /// `Result<T, T>`, regardless of whether or not that result is `Ok` or\n-    /// `Err`.\n-    ///\n-    /// This can be useful in conjunction with APIs such as\n-    /// [`Atomic*::compare_exchange`], or [`slice::binary_search`], but only in\n-    /// cases where you don't care if the result was `Ok` or not.\n-    ///\n-    /// [`Atomic*::compare_exchange`]: crate::sync::atomic::AtomicBool::compare_exchange\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(result_into_ok_or_err)]\n-    /// let ok: Result<u32, u32> = Ok(3);\n-    /// let err: Result<u32, u32> = Err(4);\n-    ///\n-    /// assert_eq!(ok.into_ok_or_err(), 3);\n-    /// assert_eq!(err.into_ok_or_err(), 4);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"result_into_ok_or_err\", reason = \"newly added\", issue = \"82223\")]\n-    pub const fn into_ok_or_err(self) -> T {\n-        match self {\n-            Ok(v) => v,\n-            Err(v) => v,\n-        }\n-    }\n-}\n-\n // This is a separate function to reduce the code size of the methods\n #[cfg(not(feature = \"panic_immediate_abort\"))]\n #[inline(never)]"}, {"sha": "38f05f471cde52a81d3057a32875282513ccce8f", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -1541,13 +1541,14 @@ impl<T> [T] {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_slice_split_at_not_mut\", issue = \"none\")]\n     #[inline]\n     #[track_caller]\n     #[must_use]\n-    pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n+    pub const fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n         assert!(mid <= self.len());\n         // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n-        // fulfills the requirements of `from_raw_parts_mut`.\n+        // fulfills the requirements of `split_at_unchecked`.\n         unsafe { self.split_at_unchecked(mid) }\n     }\n \n@@ -1626,11 +1627,19 @@ impl<T> [T] {\n     /// }\n     /// ```\n     #[unstable(feature = \"slice_split_at_unchecked\", reason = \"new API\", issue = \"76014\")]\n+    #[rustc_const_unstable(feature = \"slice_split_at_unchecked\", issue = \"76014\")]\n     #[inline]\n     #[must_use]\n-    pub unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n+    pub const unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n+        // HACK: the const function `from_raw_parts` is used to make this\n+        // function const; previously the implementation used\n+        // `(self.get_unchecked(..mid), self.get_unchecked(mid..))`\n+\n+        let len = self.len();\n+        let ptr = self.as_ptr();\n+\n         // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n-        unsafe { (self.get_unchecked(..mid), self.get_unchecked(mid..)) }\n+        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), len - mid)) }\n     }\n \n     /// Divides one mutable slice into two at an index, without doing bounds checking."}, {"sha": "c315f3a7975129399459a37c48f8fcc63a1c15c7", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -75,7 +75,6 @@\n #![feature(const_pin)]\n #![feature(never_type)]\n #![feature(unwrap_infallible)]\n-#![feature(result_into_ok_or_err)]\n #![feature(pointer_byte_offsets)]\n #![feature(portable_simd)]\n #![feature(ptr_metadata)]"}, {"sha": "50926da3ce7992f5c610431b2afebd0a00c7b854", "filename": "library/core/tests/result.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/library%2Fcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/library%2Fcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fresult.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -95,15 +95,6 @@ fn test_unwrap_or() {\n     assert_eq!(ok_err.unwrap_or(50), 50);\n }\n \n-#[test]\n-fn test_ok_or_err() {\n-    let ok: Result<isize, isize> = Ok(100);\n-    let err: Result<isize, isize> = Err(200);\n-\n-    assert_eq!(ok.into_ok_or_err(), 100);\n-    assert_eq!(err.into_ok_or_err(), 200);\n-}\n-\n #[test]\n fn test_unwrap_or_else() {\n     fn handler(msg: &'static str) -> isize {"}, {"sha": "f6a7875fddc8ccb32f92d1b8cc917f9e9a1f5cf6", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -750,16 +750,6 @@ pre, .rustdoc.source .example-wrap {\n \tpadding: 0;\n }\n \n-.content .multi-column {\n-\t-moz-column-count: 5;\n-\t-moz-column-gap: 2.5em;\n-\t-webkit-column-count: 5;\n-\t-webkit-column-gap: 2.5em;\n-\tcolumn-count: 5;\n-\tcolumn-gap: 2.5em;\n-}\n-.content .multi-column li { width: 100%; display: inline-block; }\n-\n .content > .methods > .method {\n \tfont-size: 1rem;\n \tposition: relative;"}, {"sha": "e2883050720d662b791326fed5d87e99c6951a68", "filename": "src/test/ui/auto-ref-slice-plus-ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Fauto-ref-slice-plus-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Fauto-ref-slice-plus-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauto-ref-slice-plus-ref.stderr?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -2,7 +2,7 @@ error[E0599]: no method named `test_mut` found for struct `Vec<{integer}>` in th\n   --> $DIR/auto-ref-slice-plus-ref.rs:7:7\n    |\n LL |     a.test_mut();\n-   |       ^^^^^^^^ help: there is an associated function with a similar name: `get_mut`\n+   |       ^^^^^^^^ help: there is a method with a similar name: `get_mut`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `MyIter` defines an item `test_mut`, perhaps you need to implement it"}, {"sha": "be551f6e889fc63964d44af2f699d84027a373ab", "filename": "src/test/ui/block-result/issue-3563.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Fblock-result%2Fissue-3563.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Fblock-result%2Fissue-3563.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-3563.stderr?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -2,7 +2,7 @@ error[E0599]: no method named `b` found for reference `&Self` in the current sco\n   --> $DIR/issue-3563.rs:3:17\n    |\n LL |         || self.b()\n-   |                 ^ help: there is an associated function with a similar name: `a`\n+   |                 ^ help: there is a method with a similar name: `a`\n \n error: aborting due to previous error\n "}, {"sha": "85a8698afc5a701229c9a9eb0637fb260343a9d6", "filename": "src/test/ui/issues/issue-28344.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Fissues%2Fissue-28344.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Fissues%2Fissue-28344.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28344.stderr?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -25,7 +25,7 @@ LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n    |                         ^^^^^\n    |                         |\n    |                         function or associated item not found in `dyn BitXor<_>`\n-   |                         help: there is an associated function with a similar name: `bitxor`\n+   |                         help: there is a method with a similar name: `bitxor`\n \n warning: trait objects without an explicit `dyn` are deprecated\n   --> $DIR/issue-28344.rs:10:13\n@@ -53,7 +53,7 @@ LL |     let g = BitXor::bitor;\n    |                     ^^^^^\n    |                     |\n    |                     function or associated item not found in `dyn BitXor<_>`\n-   |                     help: there is an associated function with a similar name: `bitxor`\n+   |                     help: there is a method with a similar name: `bitxor`\n \n error: aborting due to 4 previous errors; 2 warnings emitted\n "}, {"sha": "c66da3ea6d97642b20e78b765d192603c3e7ed3f", "filename": "src/test/ui/suggestions/dont-suggest-pin-array-dot-set.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-pin-array-dot-set.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-pin-array-dot-set.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-pin-array-dot-set.stderr?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -2,7 +2,7 @@ error[E0599]: no method named `set` found for array `[u8; 1]` in the current sco\n   --> $DIR/dont-suggest-pin-array-dot-set.rs:14:7\n    |\n LL |     a.set(0, 3);\n-   |       ^^^ help: there is an associated function with a similar name: `get`\n+   |       ^^^ help: there is a method with a similar name: `get`\n \n error: aborting due to previous error\n "}, {"sha": "03cb9c77922851dbb795658fc0125f9fed81272a", "filename": "src/test/ui/suggestions/suggest-methods.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.stderr?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -5,25 +5,25 @@ LL | struct Foo;\n    | ---------- method `bat` not found for this struct\n ...\n LL |     f.bat(1.0);\n-   |       ^^^ help: there is an associated function with a similar name: `bar`\n+   |       ^^^ help: there is a method with a similar name: `bar`\n \n error[E0599]: no method named `is_emtpy` found for struct `String` in the current scope\n   --> $DIR/suggest-methods.rs:21:15\n    |\n LL |     let _ = s.is_emtpy();\n-   |               ^^^^^^^^ help: there is an associated function with a similar name: `is_empty`\n+   |               ^^^^^^^^ help: there is a method with a similar name: `is_empty`\n \n error[E0599]: no method named `count_eos` found for type `u32` in the current scope\n   --> $DIR/suggest-methods.rs:25:19\n    |\n LL |     let _ = 63u32.count_eos();\n-   |                   ^^^^^^^^^ help: there is an associated function with a similar name: `count_zeros`\n+   |                   ^^^^^^^^^ help: there is a method with a similar name: `count_zeros`\n \n error[E0599]: no method named `count_o` found for type `u32` in the current scope\n   --> $DIR/suggest-methods.rs:28:19\n    |\n LL |     let _ = 63u32.count_o();\n-   |                   ^^^^^^^ help: there is an associated function with a similar name: `count_ones`\n+   |                   ^^^^^^^ help: there is a method with a similar name: `count_ones`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "af7a410f6d92c205a25cae81e1fd7acdf9f39d21", "filename": "src/test/ui/traits/trait-upcasting/subtrait-method.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fsubtrait-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fsubtrait-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fsubtrait-method.stderr?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -2,7 +2,7 @@ error[E0599]: no method named `c` found for reference `&dyn Bar` in the current\n   --> $DIR/subtrait-method.rs:56:9\n    |\n LL |     bar.c();\n-   |         ^ help: there is an associated function with a similar name: `a`\n+   |         ^ help: there is a method with a similar name: `a`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `Baz` defines an item `c`, perhaps you need to implement it\n@@ -15,7 +15,7 @@ error[E0599]: no method named `b` found for reference `&dyn Foo` in the current\n   --> $DIR/subtrait-method.rs:60:9\n    |\n LL |     foo.b();\n-   |         ^ help: there is an associated function with a similar name: `a`\n+   |         ^ help: there is a method with a similar name: `a`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `Bar` defines an item `b`, perhaps you need to implement it\n@@ -28,7 +28,7 @@ error[E0599]: no method named `c` found for reference `&dyn Foo` in the current\n   --> $DIR/subtrait-method.rs:62:9\n    |\n LL |     foo.c();\n-   |         ^ help: there is an associated function with a similar name: `a`\n+   |         ^ help: there is a method with a similar name: `a`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `Baz` defines an item `c`, perhaps you need to implement it\n@@ -41,7 +41,7 @@ error[E0599]: no method named `b` found for reference `&dyn Foo` in the current\n   --> $DIR/subtrait-method.rs:66:9\n    |\n LL |     foo.b();\n-   |         ^ help: there is an associated function with a similar name: `a`\n+   |         ^ help: there is a method with a similar name: `a`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `Bar` defines an item `b`, perhaps you need to implement it\n@@ -54,7 +54,7 @@ error[E0599]: no method named `c` found for reference `&dyn Foo` in the current\n   --> $DIR/subtrait-method.rs:68:9\n    |\n LL |     foo.c();\n-   |         ^ help: there is an associated function with a similar name: `a`\n+   |         ^ help: there is a method with a similar name: `a`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `Baz` defines an item `c`, perhaps you need to implement it"}, {"sha": "6dcc0da30cc2cd7810154c817ae0fae0da31f121", "filename": "src/test/ui/unpretty/bad-literal.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Funpretty%2Fbad-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Funpretty%2Fbad-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funpretty%2Fbad-literal.rs?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: -Zunpretty=hir\n+// check-fail\n+\n+// In #100948 this caused an ICE with -Zunpretty=hir.\n+fn main() {\n+    1u;\n+    //~^ ERROR invalid suffix `u` for number literal\n+}"}, {"sha": "f3fcb4a4e921d57479b0bc975613261d2e9a27b6", "filename": "src/test/ui/unpretty/bad-literal.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Funpretty%2Fbad-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Funpretty%2Fbad-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funpretty%2Fbad-literal.stderr?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -0,0 +1,10 @@\n+error: invalid suffix `u` for number literal\n+  --> $DIR/bad-literal.rs:6:5\n+   |\n+LL |     1u;\n+   |     ^^ invalid suffix `u`\n+   |\n+   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+error: aborting due to previous error\n+"}, {"sha": "8df9332703316d9d56808630286e1ac0b55dec32", "filename": "src/test/ui/unpretty/bad-literal.stdout", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Funpretty%2Fbad-literal.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/13a6aaffdf6bd6f1bce000b09aa390e93d6aca77/src%2Ftest%2Fui%2Funpretty%2Fbad-literal.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funpretty%2Fbad-literal.stdout?ref=13a6aaffdf6bd6f1bce000b09aa390e93d6aca77", "patch": "@@ -0,0 +1,11 @@\n+#[prelude_import]\n+use ::std::prelude::rust_2015::*;\n+#[macro_use]\n+extern crate std;\n+// compile-flags: -Zunpretty=hir\n+// check-fail\n+\n+// In #100948 this caused an ICE with -Zunpretty=hir.\n+fn main() {\n+        <bad-literal>;\n+    }"}]}