{"sha": "00849191ceeba124e27f38e27306badc264e48d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwODQ5MTkxY2VlYmExMjRlMjdmMzhlMjczMDZiYWRjMjY0ZTQ4ZDc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-22T22:47:16Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-23T13:30:29Z"}, "message": "refactor loan to not return result<>", "tree": {"sha": "4f1892f7bd0a0818293772e04ceaae75811ccd53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f1892f7bd0a0818293772e04ceaae75811ccd53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00849191ceeba124e27f38e27306badc264e48d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00849191ceeba124e27f38e27306badc264e48d7", "html_url": "https://github.com/rust-lang/rust/commit/00849191ceeba124e27f38e27306badc264e48d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00849191ceeba124e27f38e27306badc264e48d7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01a2e99639a2ec0bcdd85143add29a0087b0ea86", "url": "https://api.github.com/repos/rust-lang/rust/commits/01a2e99639a2ec0bcdd85143add29a0087b0ea86", "html_url": "https://github.com/rust-lang/rust/commit/01a2e99639a2ec0bcdd85143add29a0087b0ea86"}], "stats": {"total": 97, "additions": 45, "deletions": 52}, "files": [{"sha": "595ad2d091782576f148955ce0bd7b365beb5587", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 45, "deletions": 52, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/00849191ceeba124e27f38e27306badc264e48d7/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00849191ceeba124e27f38e27306badc264e48d7/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=00849191ceeba124e27f38e27306badc264e48d7", "patch": "@@ -72,10 +72,11 @@ type root_map_key = {id: ast::node_id, derefs: uint};\n type mutbl_map = std::map::hashmap<ast::node_id, ()>;\n \n enum bckerr_code {\n-    err_mutbl(ast::mutability, ast::mutability),\n     err_mut_uniq,\n     err_mut_variant,\n-    err_preserve_gc\n+    err_preserve_gc,\n+    err_mutbl(ast::mutability,\n+              ast::mutability)\n }\n \n type bckerr = {cmt: cmt, code: bckerr_code};\n@@ -136,32 +137,6 @@ enum loan_path {\n // a complete record of a loan that was granted\n type loan = {lp: @loan_path, cmt: cmt, mutbl: ast::mutability};\n \n-fn sup_mutbl(req_m: ast::mutability,\n-             act_m: ast::mutability) -> bool {\n-    alt (req_m, act_m) {\n-      (m_const, _) |\n-      (m_imm, m_imm) |\n-      (m_mutbl, m_mutbl) {\n-        true\n-      }\n-\n-      (_, m_const) |\n-      (m_imm, m_mutbl) |\n-      (m_mutbl, m_imm) {\n-        false\n-      }\n-    }\n-}\n-\n-fn check_sup_mutbl(req_m: ast::mutability,\n-                   cmt: cmt) -> bckres<()> {\n-    if sup_mutbl(req_m, cmt.mutbl) {\n-        ok(())\n-    } else {\n-        err({cmt:cmt, code:err_mutbl(req_m, cmt.mutbl)})\n-    }\n-}\n-\n fn save_and_restore<T:copy,U>(&t: T, f: fn() -> U) -> U {\n     let old_t = t;\n     let u <- f();\n@@ -278,12 +253,12 @@ impl methods for gather_loan_ctxt {\n     // also entail \"rooting\" GC'd pointers, which means ensuring\n     // dynamically that they are not freed.\n     fn guarantee_valid(cmt: cmt,\n-                       mutbl: ast::mutability,\n+                       req_mutbl: ast::mutability,\n                        scope_r: ty::region) {\n \n-        #debug[\"guarantee_valid(cmt=%s, mutbl=%s, scope_r=%s)\",\n+        #debug[\"guarantee_valid(cmt=%s, req_mutbl=%s, scope_r=%s)\",\n                self.bccx.cmt_to_repr(cmt),\n-               self.bccx.mut_to_str(mutbl),\n+               self.bccx.mut_to_str(req_mutbl),\n                region_to_str(self.tcx(), scope_r)];\n         let _i = indenter();\n \n@@ -300,10 +275,8 @@ impl methods for gather_loan_ctxt {\n           some(_) {\n             alt scope_r {\n               ty::re_scope(scope_id) {\n-                alt self.bccx.loan(cmt, mutbl) {\n-                  ok(loans) { self.add_loans(scope_id, loans); }\n-                  err(e) { self.bccx.report(e); }\n-                }\n+                let loans = self.bccx.loan(cmt, req_mutbl);\n+                self.add_loans(scope_id, loans);\n               }\n               _ {\n                 self.bccx.span_err(\n@@ -321,7 +294,7 @@ impl methods for gather_loan_ctxt {\n           // rooted in some immutable path)\n           none {\n             self.bccx.report_if_err(\n-                check_sup_mutbl(mutbl, cmt).chain { |_ok|\n+                self.check_mutbl(req_mutbl, cmt).chain { |_ok|\n                     let opt_scope_id = alt scope_r {\n                       ty::re_scope(scope_id) { some(scope_id) }\n                       _ { none }\n@@ -333,6 +306,32 @@ impl methods for gather_loan_ctxt {\n         }\n     }\n \n+    // Check that the pat `cmt` is compatible with the required\n+    // mutability, presuming that it can be preserved to stay alive\n+    // long enough.\n+    //\n+    // For example, if you have an expression like `&x.f` where `x`\n+    // has type `@mut{f:int}`, this check might fail because `&x.f`\n+    // reqires an immutable pointer, but `f` lives in (aliased)\n+    // mutable memory.\n+    fn check_mutbl(req_mutbl: ast::mutability,\n+                   cmt: cmt) -> bckres<()> {\n+        alt (req_mutbl, cmt.mutbl) {\n+          (m_const, _) |\n+          (m_imm, m_imm) |\n+          (m_mutbl, m_mutbl) {\n+            ok(())\n+          }\n+\n+          (_, m_const) |\n+          (m_imm, m_mutbl) |\n+          (m_mutbl, m_imm) {\n+            err({cmt: cmt,\n+                 code: err_mutbl(req_mutbl, cmt.mutbl)})\n+          }\n+        }\n+    }\n+\n     fn add_loans(scope_id: ast::node_id, loans: @const [loan]) {\n         alt self.req_maps.req_loan_map.find(scope_id) {\n           some(l) {\n@@ -1404,7 +1403,7 @@ impl categorize_methods for borrowck_ctxt {\n     fn bckerr_code_to_str(code: bckerr_code) -> str {\n         alt code {\n           err_mutbl(req, act) {\n-            #fmt[\"mutability mismatch, required %s but found %s\",\n+            #fmt[\"creating %s alias to aliasable, %s memory\",\n                  self.mut_to_str(req), self.mut_to_str(act)]\n           }\n           err_mut_uniq {\n@@ -1647,29 +1646,25 @@ type loan_ctxt = @{\n };\n \n impl loan_methods for borrowck_ctxt {\n-    fn loan(cmt: cmt,\n-            mutbl: ast::mutability) -> bckres<@const [loan]> {\n+    fn loan(cmt: cmt, mutbl: ast::mutability) -> @const [loan] {\n         let lc = @{bccx: self, loans: @mut []};\n-        alt lc.loan(cmt, mutbl) {\n-          ok(()) { ok(lc.loans) }\n-          err(e) { err(e) }\n-        }\n+        lc.loan(cmt, mutbl);\n+        ret lc.loans;\n     }\n }\n \n impl loan_methods for loan_ctxt {\n     fn ok_with_loan_of(cmt: cmt,\n-                       mutbl: ast::mutability) -> bckres<()> {\n+                       mutbl: ast::mutability) {\n         // Note: all cmt's that we deal with will have a non-none lp, because\n         // the entry point into this routine, `borrowck_ctxt::loan()`, rejects\n         // any cmt with a none-lp.\n         *self.loans += [{lp:option::get(cmt.lp),\n                          cmt:cmt,\n                          mutbl:mutbl}];\n-        ok(())\n     }\n \n-    fn loan(cmt: cmt, req_mutbl: ast::mutability) -> bckres<()> {\n+    fn loan(cmt: cmt, req_mutbl: ast::mutability) {\n \n         #debug[\"loan(%s, %s)\",\n                self.bccx.cmt_to_repr(cmt),\n@@ -1711,9 +1706,8 @@ impl loan_methods for loan_ctxt {\n               m_const | m_mutbl { m_const }\n             };\n \n-            self.loan(cmt_base, base_mutbl).chain { |_ok|\n-                self.ok_with_loan_of(cmt, req_mutbl)\n-            }\n+            self.loan(cmt_base, base_mutbl);\n+            self.ok_with_loan_of(cmt, req_mutbl)\n           }\n           cat_comp(cmt1, comp_variant) |\n           cat_deref(cmt1, _, uniq_ptr) {\n@@ -1723,9 +1717,8 @@ impl loan_methods for loan_ctxt {\n             //\n             // Unique pointers: the base must be immutable, because if\n             // it is overwritten, the unique content will be freed.\n-            self.loan(cmt1, m_imm).chain { |_ok|\n-                self.ok_with_loan_of(cmt, req_mutbl)\n-            }\n+            self.loan(cmt1, m_imm);\n+            self.ok_with_loan_of(cmt, req_mutbl)\n           }\n           cat_deref(cmt1, _, unsafe_ptr) |\n           cat_deref(cmt1, _, gc_ptr) |"}]}