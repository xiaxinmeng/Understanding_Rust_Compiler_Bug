{"sha": "7417ab5aed7336cfc961e067cadf9114bb426a3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MTdhYjVhZWQ3MzM2Y2ZjOTYxZTA2N2NhZGY5MTE0YmI0MjZhM2Q=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-03-07T22:46:35Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-03-07T22:46:35Z"}, "message": "Working prototype\n\nImplements a few formatting options using an approach where we modify the source using a rope. Uses very ad-hoc rules for formatting.", "tree": {"sha": "c743c2ff1052bdeb7f6dc022e165a4dc726194fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c743c2ff1052bdeb7f6dc022e165a4dc726194fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7417ab5aed7336cfc961e067cadf9114bb426a3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7417ab5aed7336cfc961e067cadf9114bb426a3d", "html_url": "https://github.com/rust-lang/rust/commit/7417ab5aed7336cfc961e067cadf9114bb426a3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7417ab5aed7336cfc961e067cadf9114bb426a3d/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1e698c838defa9535750312d3fc11ebf3a830e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1e698c838defa9535750312d3fc11ebf3a830e9", "html_url": "https://github.com/rust-lang/rust/commit/f1e698c838defa9535750312d3fc11ebf3a830e9"}], "stats": {"total": 877, "additions": 751, "deletions": 126}, "files": [{"sha": "31edfbbdc0691b03887c932dbc67dd8eaf5e71cd", "filename": "Cargo.toml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7417ab5aed7336cfc961e067cadf9114bb426a3d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7417ab5aed7336cfc961e067cadf9114bb426a3d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=7417ab5aed7336cfc961e067cadf9114bb426a3d", "patch": "@@ -0,0 +1,17 @@\n+[package]\n+\n+name = \"rustfmt\"\n+version = \"0.0.1\"\n+authors = [\"Nicholas Cameron <nrc@ncameron.org>\"]\n+description = \"tool to find and fix Rust formatting issues\"\n+repository = \"https://github.com/nick29581/rustfmt\"\n+readme = \"README.md\"\n+license = \"Apache-2.0/MIT\"\n+\n+#[dependencies.reprint]\n+#reprint = \"0.0.1\"\n+#path = \"/home/ncameron/reprint\"\n+\n+[[bin]]\n+name = \"rustfmt\"\n+path = \"src/mod.rs\""}, {"sha": "bcfbed17f5b3d6717047c0f0caef9eb0719f9c23", "filename": "src/changes.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7417ab5aed7336cfc961e067cadf9114bb426a3d/src%2Fchanges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7417ab5aed7336cfc961e067cadf9114bb426a3d/src%2Fchanges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchanges.rs?ref=7417ab5aed7336cfc961e067cadf9114bb426a3d", "patch": "@@ -8,33 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n // TODO\n-// composable changes\n // print to files (maybe that shouldn't be here, but in mod)\n // tests\n-// docs\n \n use rope::{Rope, RopeSlice};\n use std::collections::HashMap;\n-use syntax::codemap::{CodeMap, Span, Pos, BytePos};\n+use syntax::codemap::{CodeMap, Span, BytePos};\n use std::fmt;\n \n+// This is basically a wrapper around a bunch of Ropes which makes it convenient\n+// to work with libsyntax. It is badly named.\n pub struct ChangeSet<'a> {\n     file_map: HashMap<String, Rope>,\n-    // FIXME, we only keep a codemap around so we can have convenience methods\n-    // taking Spans, it would be more resuable to factor this (and the methods)\n-    // out into an adaptor.\n     codemap: &'a CodeMap,\n     pub count: u64,\n }\n \n-pub struct FileIterator<'c, 'a: 'c> {\n-    change_set: &'c ChangeSet<'a>,\n-    keys: Vec<&'c String>,\n-    cur_key: usize,\n-}\n-\n impl<'a> ChangeSet<'a> {\n+    // Create a new ChangeSet for a given libsyntax CodeMap.\n     pub fn from_codemap(codemap: &'a CodeMap) -> ChangeSet<'a> {\n         let mut result = ChangeSet {\n             file_map: HashMap::new(),\n@@ -43,14 +36,16 @@ impl<'a> ChangeSet<'a> {\n         };\n \n         for f in codemap.files.borrow().iter() {\n-            let contents = Rope::from_string(f.src.clone());\n+            let contents = Rope::from_string((&**f.src.as_ref().unwrap()).clone());\n             result.file_map.insert(f.name.clone(), contents);\n         }\n \n         result\n     }\n \n-    // start and end are unadjusted.\n+    // Change a span of text in our stored text into the new text (`text`).\n+    // The span of text to change is given in the coordinates of the original\n+    // source text, not the current text,\n     pub fn change(&mut self, file_name: &str, start: usize, end: usize, text: String) {\n         println!(\"change: {}:{}-{} \\\"{}\\\"\", file_name, start, end, text);\n \n@@ -59,38 +54,45 @@ impl<'a> ChangeSet<'a> {\n         let file = &mut self.file_map[*file_name];\n \n         if end - start == text.len() {\n-            // TODO\n-            panic!();\n-            file.replace_str(start, &text[]);\n+            // TODO src_replace_str would be much more efficient\n+            //file.src_replace_str(start, &text);\n+            file.src_remove(start, end);\n+            file.src_insert(start, text);\n         } else {\n             // TODO if we do this in one op, could we get better change info?\n             file.src_remove(start, end);\n             file.src_insert(start, text);\n         }\n     }\n \n+    // As for `change()`, but use a Span to indicate the text to change.\n     pub fn change_span(&mut self, span: Span, text: String) {\n         let l_loc = self.codemap.lookup_char_pos(span.lo);\n         let file_offset = l_loc.file.start_pos.0;\n-        self.change(&l_loc.file.name[],\n+        self.change(&l_loc.file.name,\n                     (span.lo.0 - file_offset) as usize,\n                     (span.hi.0 - file_offset) as usize,\n                     text)\n     }\n \n+    // Get a slice of the current text. Coordinates are relative to the source\n+    // text. I.e., this method returns the text which has been changed from the\n+    // indicated span.\n     pub fn slice(&self, file_name: &str, start: usize, end: usize) -> RopeSlice {\n         let file = &self.file_map[*file_name];\n         file.src_slice(start..end)\n     }\n \n+    // As for `slice()`, but use a Span to indicate the text to return.\n     pub fn slice_span(&self, span:Span) -> RopeSlice {\n         let l_loc = self.codemap.lookup_char_pos(span.lo);\n         let file_offset = l_loc.file.start_pos.0;\n-        self.slice(&l_loc.file.name[],\n+        self.slice(&l_loc.file.name,\n                    (span.lo.0 - file_offset) as usize,\n                    (span.hi.0 - file_offset) as usize)\n     }\n \n+    // Return an iterator over the entire changed text.\n     pub fn text<'c>(&'c self) -> FileIterator<'c, 'a> {\n         FileIterator {\n             change_set: self,\n@@ -99,32 +101,43 @@ impl<'a> ChangeSet<'a> {\n         }\n     }\n \n+    // Get the current line-relative position of a position in the source text.\n     pub fn col(&self, loc: BytePos) -> usize {\n         let l_loc = self.codemap.lookup_char_pos(loc);\n         let file_offset = l_loc.file.start_pos.0;\n-        let file = &self.file_map[l_loc.file.name[]];\n+        let file = &self.file_map[l_loc.file.name[..]];\n         file.col_for_src_loc(loc.0 as usize - file_offset as usize)\n     }\n }\n \n+// Iterates over each file in the ChangSet. Yields the filename and the changed\n+// text for that file.\n+pub struct FileIterator<'c, 'a: 'c> {\n+    change_set: &'c ChangeSet<'a>,\n+    keys: Vec<&'c String>,\n+    cur_key: usize,\n+}\n+\n impl<'c, 'a> Iterator for FileIterator<'c, 'a> {\n     type Item = (&'c str, &'c Rope);\n+\n     fn next(&mut self) -> Option<(&'c str, &'c Rope)> {\n         if self.cur_key >= self.keys.len() {\n             return None;\n         }\n \n         let key = self.keys[self.cur_key];\n         self.cur_key += 1;\n-        return Some((&key[], &self.change_set.file_map[*key]))\n+        return Some((&key, &self.change_set.file_map[*key]))\n     }\n }\n \n impl<'a> fmt::Display for ChangeSet<'a> {\n+    // Prints the entire changed text.\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         for (f, r) in self.text() {\n             try!(write!(fmt, \"{}:\\n\", f));\n-            try!(write!(fmt, \"{}\", r));\n+            try!(write!(fmt, \"{}\\n\\n\", r));\n         }\n         Ok(())\n     }    "}, {"sha": "c0bad7a0e31a6b5b256d3312286133447f93df9e", "filename": "src/mod.rs", "status": "added", "additions": 468, "deletions": 0, "changes": 468, "blob_url": "https://github.com/rust-lang/rust/blob/7417ab5aed7336cfc961e067cadf9114bb426a3d/src%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7417ab5aed7336cfc961e067cadf9114bb426a3d/src%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmod.rs?ref=7417ab5aed7336cfc961e067cadf9114bb426a3d", "patch": "@@ -0,0 +1,468 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+#![feature(box_patterns)]\n+#![feature(rustc_private)]\n+#![feature(collections)]\n+#![feature(os)]\n+#![feature(core)]\n+#![feature(unicode)]\n+#![feature(old_path)]\n+#![feature(exit_status)]\n+\n+#[macro_use]\n+extern crate log;\n+\n+extern crate getopts;\n+extern crate rustc;\n+extern crate rustc_driver;\n+extern crate syntax;\n+\n+use rustc::session::Session;\n+use rustc::session::config::{self, Input};\n+use rustc_driver::{driver, CompilerCalls, Compilation};\n+\n+use syntax::ast;\n+use syntax::codemap::{self, CodeMap, Span, Pos};\n+use syntax::diagnostics;\n+use syntax::parse::token;\n+use syntax::print::pprust;\n+use syntax::visit;\n+\n+use std::mem;\n+\n+use changes::ChangeSet;\n+\n+pub mod rope;\n+mod changes;\n+\n+const IDEAL_WIDTH: usize = 80;\n+const MAX_WIDTH: usize = 100;\n+const MIN_STRING: usize = 10;\n+\n+// Formatting which depends on the AST.\n+fn fmt_ast<'a>(krate: &ast::Crate, codemap: &'a CodeMap) -> ChangeSet<'a> {\n+    let mut visitor = FmtVisitor { codemap: codemap,\n+                                   changes: ChangeSet::from_codemap(codemap) };\n+    visit::walk_crate(&mut visitor, krate);\n+\n+    visitor.changes\n+}\n+\n+// Formatting done on a char by char basis.\n+fn fmt_lines(changes: &mut ChangeSet) {\n+    // Iterate over the chars in the change set.\n+    for (f, text) in changes.text() {\n+        let mut trims = vec![];\n+        let mut last_wspace = None;\n+        let mut line_len = 0;\n+        let mut cur_line = 1;\n+        for (c, b) in text.chars() {\n+            if c == '\\n' { // TOOD test for \\r too\n+                // Check for (and record) trailing whitespace.\n+                if let Some(lw) = last_wspace {\n+                    trims.push((lw, b));\n+                    line_len -= b - lw;\n+                }\n+                // Check for any line width errors we couldn't correct.\n+                if line_len > MAX_WIDTH {\n+                    // FIXME store the error rather than reporting immediately.\n+                    println!(\"Rustfmt couldn't fix (sorry). {}:{}: line longer than {} characters\",\n+                             f, cur_line, MAX_WIDTH);\n+                }\n+                line_len = 0;\n+                cur_line += 1;\n+                last_wspace = None;\n+            } else {\n+                line_len += 1;\n+                if c.is_whitespace() {\n+                    if last_wspace.is_none() {\n+                        last_wspace = Some(b);\n+                    }\n+                } else {\n+                    last_wspace = None;\n+                }\n+            }\n+        }\n+\n+        unsafe {\n+            // Invariant: we only mutate a rope after we have searched it, then\n+            // we will not search it again.\n+            let mut_text: &mut rope::Rope = mem::transmute(text);\n+            let mut_count: &mut u64 = mem::transmute(&changes.count);\n+            let mut offset = 0;\n+            // Get rid of any trailing whitespace we recorded earlier.\n+            for &(s, e) in trims.iter() {\n+                // Note that we change the underlying ropes directly, we don't\n+                // go through the changeset because our change positions are\n+                // relative to the newest text, not the original.\n+                debug!(\"Stripping trailing whitespace {}:{}-{} \\\"{}\\\"\",\n+                       f, s, e, text.slice(s-offset..e-offset));\n+                mut_text.remove(s-offset, e-offset);\n+                *mut_count += 1;\n+                offset += e - s;\n+            }\n+        }\n+    }\n+}\n+\n+struct FmtVisitor<'a> {\n+    codemap: &'a CodeMap,\n+    changes: ChangeSet<'a>,\n+}\n+\n+impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n+    fn visit_expr(&mut self, ex: &'v ast::Expr) {\n+        match ex.node {\n+            ast::Expr_::ExprLit(ref l) => match l.node {\n+                ast::Lit_::LitStr(ref is, _) => {\n+                    self.rewrite_string(&is, l.span);\n+                }\n+                _ => {}\n+            },\n+            _ => {}\n+        }\n+\n+        visit::walk_expr(self, ex)\n+    }\n+\n+    fn visit_fn(&mut self,\n+                fk: visit::FnKind<'v>,\n+                fd: &'v ast::FnDecl,\n+                b: &'v ast::Block,\n+                s: Span,\n+                _: ast::NodeId) {\n+        self.fix_formal_args(fd);\n+        visit::walk_fn(self, fk, fd, b, s);\n+    }\n+\n+    fn visit_item(&mut self, item: &'v ast::Item) {\n+        // TODO check each item is on a new line and is correctly indented.\n+        match item.node {\n+            ast::Item_::ItemUse(ref vp) => {\n+                match vp.node {\n+                    ast::ViewPath_::ViewPathList(ref path, ref path_list) => {\n+                        let new_str = self.fix_use_list(path, path_list, vp.span);\n+\n+                        // TODO move these optimisations to ChangeSet\n+                        if new_str != self.codemap.span_to_snippet(item.span).unwrap() {\n+                            self.changes.change_span(item.span, new_str);\n+                        }\n+                    }\n+                    ast::ViewPath_::ViewPathGlob(_) => {\n+                        // FIXME convert to list?\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+        visit::walk_item(self, item);\n+    }\n+}\n+\n+fn make_indent(width: usize) -> String {\n+    let mut indent = String::with_capacity(width);\n+    for _ in 0..width {\n+        indent.push(' ')\n+    }\n+    indent\n+}\n+\n+impl<'a> FmtVisitor<'a> {\n+    // TODO NEEDS TESTS\n+    fn rewrite_string(&mut self, s: &str, span: Span) {\n+        // FIXME I bet this stomps unicode escapes in the source string\n+\n+        // Check if there is anything to fix: we always try to fixup multi-line\n+        // strings, or if the string is too long for the line.\n+        let l_loc = self.codemap.lookup_char_pos(span.lo);\n+        let r_loc = self.codemap.lookup_char_pos(span.hi);\n+        if l_loc.line == r_loc.line && r_loc.col.to_usize() <= MAX_WIDTH {\n+            return;\n+        }\n+\n+        // TODO if lo.col > IDEAL - 10, start a new line (need cur indent for that)\n+\n+        let s = s.escape_default();\n+\n+        // TODO use fixed value.\n+        let l_loc = self.codemap.lookup_char_pos(span.lo);\n+        let l_col = l_loc.col.to_usize();\n+        \n+        let indent = make_indent(l_col + 1);\n+        let indent = &indent;\n+\n+        let max_chars = MAX_WIDTH - (l_col + 1);\n+\n+        let mut cur_start = 0;\n+        let mut result = String::new();\n+        result.push('\"');\n+        loop {\n+            let mut cur_end = cur_start + max_chars;\n+\n+            if cur_end >= s.len() {\n+                result.push_str(&s[cur_start..]);\n+                break;\n+            }\n+\n+            // Make sure we're on a char boundary.\n+            cur_end = next_char(&s, cur_end);\n+\n+            // Push cur_end left until we reach whitespace\n+            while !s.char_at(cur_end-1).is_whitespace() {\n+                cur_end = prev_char(&s, cur_end);\n+\n+                if cur_end - cur_start < MIN_STRING {\n+                    // We can't break at whitespace, fall back to splitting\n+                    // anywhere that doesn't break an escape sequence\n+                    cur_end = next_char(&s, cur_start + max_chars);\n+                    while s.char_at(cur_end) == '\\\\' {\n+                        cur_end = prev_char(&s, cur_end);\n+                    }\n+                }\n+            }\n+            // Make sure there is no whitespace to the right of the break.\n+            while cur_end < s.len() && s.char_at(cur_end).is_whitespace() {\n+                cur_end = next_char(&s, cur_end+1);\n+            }\n+            result.push_str(&s[cur_start..cur_end]);\n+            result.push_str(\"\\\\\\n\");\n+            result.push_str(indent);\n+\n+            cur_start = cur_end;\n+        }\n+        result.push('\"');\n+\n+        // Check that we actually changed something.\n+        if result == self.codemap.span_to_snippet(span).unwrap() {\n+            return;\n+        }\n+\n+        self.changes.change_span(span, result);\n+    }\n+\n+    // Basically just pretty prints a multi-item import.\n+    fn fix_use_list(&mut self,\n+                    path: &ast::Path,\n+                    path_list: &[ast::PathListItem],\n+                    vp_span: Span) -> String {\n+        // FIXME remove unused imports\n+\n+        // FIXME check indentation\n+        let l_loc = self.codemap.lookup_char_pos(vp_span.lo);\n+        let path_str = pprust::path_to_string(&path);\n+        let indent = l_loc.col.0;\n+        // After accounting for the overhead, how much space left for\n+        // the item list? ( 5 = :: + { + } + ; )\n+        let space = IDEAL_WIDTH - (indent + path_str.len() + 5);\n+        // 4 = `use` + one space\n+        // TODO might be pub use\n+        let indent = make_indent(indent-4);\n+\n+        let mut cur_str = String::new();\n+        let mut first = true;\n+        // If `self` is in the list, put it first.\n+        if path_list.iter().any(|vpi|\n+            if let ast::PathListItem_::PathListMod{ .. } = vpi.node {\n+                true\n+            } else {\n+                false\n+            }\n+        ) {\n+            cur_str = \"self\".to_string();\n+            first = false;\n+        }\n+\n+        let mut new_str = String::new();\n+        for vpi in path_list.iter() {\n+            match vpi.node {\n+                ast::PathListItem_::PathListIdent{ name, .. } => {\n+                    let next_item = &token::get_ident(name);\n+                    if cur_str.len() + next_item.len() > space {\n+                        let cur_line = format!(\"{}use {}::{{{}}};\\n\", indent, path_str, cur_str);\n+                        new_str.push_str(&cur_line);\n+\n+                        cur_str = String::new();\n+                        first = true;\n+                    }\n+\n+                    if first {\n+                        first = false;\n+                    } else {\n+                        cur_str.push_str(\", \");\n+                    }\n+\n+                    cur_str.push_str(next_item);\n+                }\n+                ast::PathListItem_::PathListMod{ .. } => {}\n+            }\n+        }\n+\n+        assert!(!first);\n+        let cur_line = format!(\"{}use {}::{{{}}};\", indent, path_str, cur_str);\n+        new_str.push_str(&cur_line);\n+\n+        new_str\n+    }\n+\n+    fn fix_formal_args<'v>(&mut self, fd: &'v ast::FnDecl) {\n+        // For now, just check the arguments line up and make them per-row if the line is too long.\n+        let args = &fd.inputs;\n+        if args.len() <= 1 {\n+            return;\n+        }\n+        // TODO not really using the hi positions\n+        let spans: Vec<_> = args.iter().map(|a| (a.pat.span.lo, a.ty.span.hi)).collect();\n+        let locs: Vec<_> = spans.iter().map(|&(a, b)| (self.codemap.lookup_char_pos(a), self.codemap.lookup_char_pos(b))).collect();\n+        let first_loc = &locs[0].0;\n+        // TODO need to adjust for previous changes here.\n+        let same_row = locs.iter().all(|&(ref l, _)| l.line == first_loc.line);\n+        let same_col = locs.iter().all(|&(ref l, _)| l.col == first_loc.col);\n+\n+        if same_col {\n+            // TODO Check one arg per line and no lines in between (except comments)\n+            return;\n+        }        \n+\n+        if same_row { // TODO check line is < 100 && first_loc.line {\n+            // TODO could also fix whitespace around punctuaton here\n+            // TODO and could check that we're on the same line as the function call, if possible\n+            return;\n+        }\n+\n+        let col = self.changes.col(spans[0].0);\n+        let mut indent = String::with_capacity(col);\n+        indent.push('\\n');\n+        for _ in 0..col { indent.push(' '); }\n+        let last_idx = spans.len() - 1;\n+        for (i, s) in spans.iter().enumerate() {\n+            // Take the span from lo to lo (or the last hi for the last arg), \n+            // trim, push on top of indent, then replace the old lo-lo span with it.\n+            let mut new_text = if i == 0 {\n+                \"\".to_string()\n+            } else {\n+                indent.clone()\n+            };\n+            let hi = if i == last_idx {\n+                s.1\n+            } else {\n+                spans[i+1].0\n+            };\n+            // TODO need a version of slice taking locs, not a span\n+            let snippet = self.changes.slice_span(Span{ lo: s.0, hi: hi, expn_id: codemap::NO_EXPANSION }).to_string();\n+            let snippet = snippet.trim();\n+            new_text.push_str(snippet);\n+            self.changes.change(&first_loc.file.name, (s.0).0 as usize, hi.0 as usize, new_text);\n+        }\n+    }\n+}\n+\n+#[inline]\n+fn prev_char(s: &str, mut i: usize) -> usize {\n+    if i == 0 { return 0; }\n+\n+    i -= 1;\n+    while !s.is_char_boundary(i) {\n+        i -= 1;\n+    }\n+    i\n+}\n+\n+#[inline]\n+fn next_char(s: &str, mut i: usize) -> usize {\n+    if i >= s.len() { return s.len(); }\n+\n+    while !s.is_char_boundary(i) {\n+        i += 1;\n+    }\n+    i\n+}\n+\n+struct RustFmtCalls {\n+    input_path: Option<Path>,\n+}\n+\n+impl<'a> CompilerCalls<'a> for RustFmtCalls {\n+    fn early_callback(&mut self,\n+                      _: &getopts::Matches,\n+                      _: &diagnostics::registry::Registry)\n+                      -> Compilation {\n+        Compilation::Continue\n+    }\n+\n+    fn some_input(&mut self, input: Input, input_path: Option<Path>) -> (Input, Option<Path>) {\n+        match input_path {\n+            Some(ref ip) => self.input_path = Some(ip.clone()),\n+            _ => {\n+                // FIXME should handle string input and write to stdout or something\n+                panic!(\"No input path\");\n+            }\n+        }\n+        (input, input_path)\n+    }\n+\n+    fn no_input(&mut self,\n+                _: &getopts::Matches,\n+                _: &config::Options,\n+                _: &Option<Path>,\n+                _: &Option<Path>,\n+                _: &diagnostics::registry::Registry)\n+                -> Option<(Input, Option<Path>)> {\n+        panic!(\"No input supplied to RustFmt\");\n+    }\n+\n+    fn late_callback(&mut self,\n+                     _: &getopts::Matches,\n+                     _: &Session,\n+                     _: &Input,\n+                     _: &Option<Path>,\n+                     _: &Option<Path>)\n+                     -> Compilation {\n+        Compilation::Continue\n+    }\n+\n+    fn build_controller(&mut self, _: &Session) -> driver::CompileController<'a> {\n+        let mut control = driver::CompileController::basic();\n+        control.after_parse.stop = Compilation::Stop;\n+        control.after_parse.callback = box |state| {\n+            let krate = state.krate.unwrap();\n+            let codemap = state.session.codemap();\n+            let mut changes = fmt_ast(krate, codemap);\n+            fmt_lines(&mut changes);\n+\n+            println!(\"Making {} changes\", changes.count);\n+            println!(\"{}\", changes);\n+            // FIXME(#5) Should be user specified whether to show or replace.\n+        };\n+\n+        control\n+    }\n+}\n+\n+fn main() {\n+    let args = std::os::args();\n+    let mut call_ctxt = RustFmtCalls { input_path: None };\n+    rustc_driver::run_compiler(&args, &mut call_ctxt);\n+    std::env::set_exit_status(0);\n+}\n+\n+// FIXME comments\n+// comments aren't in the AST, which makes processing them difficult, but then\n+// comments are complicated anyway. I think I am happy putting off tackling them\n+// for now. Long term the soluton is for comments to be in the AST, but that means\n+// only the libsyntax AST, not the rustc one, which means waiting for the ASTs\n+// to diverge one day....\n+\n+// Once we do have comments, we just have to implement a simple word wrapping\n+// algorithm to keep the width under IDEAL_WIDTH. We should also convert multiline\n+// /* ... */ comments to // and check doc comments are in the right place and of\n+// the right kind."}, {"sha": "5a96370308ae571c470075fccd2b8dce656a2396", "filename": "src/rope.rs", "status": "modified", "additions": 231, "deletions": 104, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/7417ab5aed7336cfc961e067cadf9114bb426a3d/src%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7417ab5aed7336cfc961e067cadf9114bb426a3d/src%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frope.rs?ref=7417ab5aed7336cfc961e067cadf9114bb426a3d", "patch": "@@ -14,25 +14,31 @@\n // tests\n // pull out into its own crate\n // impl Default, Extend\n-// impl DOubleEndedIter and ExactSizeIter for RopeChars\n+// impl DoubleEndedIter and ExactSizeIter for RopeChars\n // better allocation\n-// balancing\n-// thread safety/parallisation\n+// balancing?\n \n extern crate unicode;\n use std::fmt;\n use std::ops::Range;\n+use std::num::{SignedInt, Int};\n \n-// A Rope, based on an unbalanced binary tree.\n-\n+// A Rope, based on an unbalanced binary tree. The rope is somewhat special in\n+// that it tracks positions in the source text. So when locating a position in\n+// the rope, the user can use either a current position in the text or a\n+// position in the source text, which the Rope will adjust to a current position\n+// whilst searching.\n pub struct Rope {\n     root: Node,\n     len: usize,\n     src_len: usize,\n-    // FIXME: Allocation is very dumb at the moment, we always add another buffer for every inserted string and we never resuse or collect old memory\n+    // FIXME: Allocation is very dumb at the moment, we always add another\n+    // buffer for every inserted string and we never resuse or collect old\n+    // memory\n     storage: Vec<Vec<u8>>\n }\n \n+// A view over a portion of a Rope. Analagous to string slices (`str`);\n pub struct RopeSlice<'rope> {\n     // All nodes which make up the slice, in order.\n     nodes: Vec<&'rope Lnode>,\n@@ -42,15 +48,16 @@ pub struct RopeSlice<'rope> {\n     len: usize,\n }\n \n+// An iterator over the chars in a rope.\n pub struct RopeChars<'rope> {\n     data: RopeSlice<'rope>,\n     cur_node: usize,\n     cur_byte: usize,\n     abs_byte: usize,\n }\n \n-\n impl Rope {\n+    // Create an empty rope.\n     pub fn new() -> Rope {\n         Rope {\n             root: Node::empty_inner(),\n@@ -62,55 +69,49 @@ impl Rope {\n \n     // Uses text as initial storage.\n     pub fn from_string(text: String) -> Rope {\n-        // TODO should split large texts into segments as we insert\n+        // TODO should split very large texts into segments as we insert\n \n         let mut result = Rope::new();\n         result.insert(0, text);\n         result.fix_src();\n         result\n     }\n \n+    // When initialising a rope, indicates that the rope is complete wrt the\n+    // source text.\n     fn fix_src(&mut self) {\n         self.root.fix_src();\n         self.src_len = self.len;\n     }\n \n+    // Length of the rope.\n     pub fn len(&self) -> usize {\n         self.len\n     }\n \n-    pub fn insert(&mut self, start: usize, text: String) {\n-        if text.len() == 0 {\n-            return;\n-        }\n-\n-        debug_assert!(start <= self.len(), \"insertion out of bounds of rope\");\n-\n-        let len = text.len();\n-        let storage = text.into_bytes();\n-        let new_node = box Node::new_leaf(&storage[][0] as *const u8, len, 0);\n-        self.storage.push(storage);\n-\n-        match self.root.insert(new_node, start, start) {\n-            NodeAction::Change(n, adj) => {\n-                assert!(adj as usize == len);\n-                self.root = *n;\n-            }\n-            NodeAction::Adjust(adj) => {\n-                assert!(adj as usize == len);\n-            }\n-            _ => panic!(\"Unexpected action\")\n-        }\n-        self.len += len;\n-    }\n-\n     pub fn insert_copy(&mut self, start: usize, text: &str) {\n-        // If we did clever things with allocation, we could do better here\n+        // FIXME If we did clever things with allocation, we could do better here.\n         self.insert(start, text.to_string());\n     }\n \n+    pub fn insert(&mut self, start: usize, text: String) {\n+        self.insert_inner(start,\n+                          text,\n+                          |this, node| this.root.insert(node, start, start))\n+    }\n+\n     pub fn src_insert(&mut self, start: usize, text: String) {\n-        // TODO refactor with insert\n+        self.insert_inner(start,\n+                          text,\n+                          |this, node| this.root.src_insert(node, start, start))\n+    }\n+\n+    fn insert_inner<F>(&mut self,\n+                       start: usize,\n+                       text: String,\n+                       do_insert: F)\n+        where F: Fn(&mut Rope, Box<Node>) -> NodeAction\n+    {\n         if text.len() == 0 {\n             return;\n         }\n@@ -119,10 +120,10 @@ impl Rope {\n \n         let len = text.len();\n         let storage = text.into_bytes();\n-        let new_node = box Node::new_leaf(&storage[][0] as *const u8, len, 0);\n+        let new_node = box Node::new_leaf(&storage[..][0] as *const u8, len, 0);\n         self.storage.push(storage);\n \n-        match self.root.src_insert(new_node, start, start) {\n+        match do_insert(self, new_node) {\n             NodeAction::Change(n, adj) => {\n                 assert!(adj as usize == len);\n                 self.root = *n;\n@@ -147,35 +148,25 @@ impl Rope {\n     }\n \n     pub fn remove(&mut self, start: usize, end: usize) {\n-        assert!(end >= start);\n-        if start == end {\n-            return;\n-        }\n-\n-        let action = self.root.remove(start, end, start);\n-        match action {\n-            NodeAction::None => {}\n-            NodeAction::Remove => {\n-                self.root = Node::empty_inner();\n-                self.len = 0;\n-            }\n-            NodeAction::Adjust(adj) => self.len = (self.len as isize + adj) as usize,\n-            NodeAction::Change(node, adj) => {\n-                self.root = *node;\n-                self.len = (self.len as isize + adj) as usize;\n-            }\n-        }\n+        self.remove_inner(start, end, |this| this.root.remove(start, end, start))\n     }\n \n     pub fn src_remove(&mut self, start: usize, end: usize) {\n-        // TODO refactor with remove\n+        self.remove_inner(start, end, |this| this.root.src_remove(start, end, start))\n+    }\n+\n+    fn remove_inner<F>(&mut self,\n+                       start: usize,\n+                       end: usize,\n+                       do_remove: F)\n+        where F: Fn(&mut Rope) -> NodeAction\n+    {\n         assert!(end >= start);\n         if start == end {\n             return;\n         }\n \n-        let action = self.root.src_remove(start, end, start);\n-        match action {\n+        match do_remove(self) {\n             NodeAction::None => {}\n             NodeAction::Remove => {\n                 self.root = Node::empty_inner();\n@@ -190,6 +181,7 @@ impl Rope {\n     }\n \n     // TODO src_replace\n+    // TODO src_replace_str\n \n     // This can go horribly wrong if you overwrite a grapheme of different size.\n     // It is the callers responsibility to ensure that the grapheme at point start\n@@ -200,7 +192,7 @@ impl Rope {\n         // I think that is better than duplicating a bunch of code.\n         // It should be possible to view a &char as a &[u8] somehow, and then\n         // we can optimise this (FIXME).\n-        self.replace_str(start, &new_char.to_string()[]);\n+        self.replace_str(start, &new_char.to_string()[..]);\n     }\n \n     pub fn replace_str(&mut self, start: usize, new_str: &str) {\n@@ -332,6 +324,10 @@ impl ::std::str::FromStr for Rope {\n \n impl<'a> fmt::Display for RopeSlice<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        if self.nodes.len() == 0 {\n+            return Ok(());\n+        }\n+\n         let last_idx = self.nodes.len() - 1;\n         for (i, n) in self.nodes.iter().enumerate() {\n             let mut ptr = n.text;\n@@ -346,7 +342,7 @@ impl<'a> fmt::Display for RopeSlice<'a> {\n             unsafe {\n                 try!(write!(fmt,\n                             \"{}\",\n-                            ::std::str::from_utf8(::std::slice::from_raw_buf(&ptr, len)).unwrap()));\n+                            ::std::str::from_utf8(::std::slice::from_raw_parts(ptr, len)).unwrap()));\n             }\n         }\n         Ok(())\n@@ -371,7 +367,7 @@ impl<'a> fmt::Debug for RopeSlice<'a> {\n             unsafe {\n                 try!(write!(fmt,\n                             \"\\\"{}\\\"\",\n-                            ::std::str::from_utf8(::std::slice::from_raw_buf(&ptr, len)).unwrap()));\n+                            ::std::str::from_utf8(::std::slice::from_raw_parts(ptr, len)).unwrap()));\n             }\n         }\n         Ok(())\n@@ -408,7 +404,7 @@ impl fmt::Display for Node {\n                 unsafe {\n                     write!(fmt,\n                            \"{}\",\n-                           ::std::str::from_utf8(::std::slice::from_raw_buf(text, len)).unwrap())\n+                           ::std::str::from_utf8(::std::slice::from_raw_parts(*text, len)).unwrap())\n                 }\n             }\n         }\n@@ -437,7 +433,7 @@ impl fmt::Debug for Node {\n                 unsafe {\n                     write!(fmt,\n                            \"(\\\"{}\\\"; {})\",\n-                           ::std::str::from_utf8(::std::slice::from_raw_buf(text, len)).unwrap(),\n+                           ::std::str::from_utf8(::std::slice::from_raw_parts(*text, len)).unwrap(),\n                            len)\n                 }\n             }\n@@ -519,7 +515,7 @@ impl Node {\n         }\n     }\n \n-    // All these methods are just doing dynamic dispatch, TODO use a macro\n+    // Most of these methods are just doing dynamic dispatch, TODO use a macro\n \n     // precond: start < end\n     fn remove(&mut self, start: usize, end: usize, src_start: usize) -> NodeAction {\n@@ -534,19 +530,9 @@ impl Node {\n             Node::InnerNode(ref mut i) => i.src_remove(start, end, src_start),\n             Node::LeafNode(ref mut l) => {\n                 debug!(\"src_remove: pre-adjust {}-{}; {}\", start, end, l.src_offset);\n-                let mut start = start as isize + l.src_offset;\n-                if start < 0 {\n-                    start = 0;\n-                }\n-                let mut end = end as isize + l.src_offset;\n-                if end < 0 {\n-                    end = 0;\n-                }\n-                // TODO src_start?\n-                let mut src_start = src_start as isize + l.src_offset;\n-                if src_start < 0 {\n-                    src_start = 0;\n-                }\n+                let start = minz(start as isize + l.src_offset);\n+                let end = minz(end as isize + l.src_offset);\n+                let src_start = minz(src_start as isize + l.src_offset);\n                 debug!(\"src_remove: post-adjust {}-{}, {}\", start, end, src_start);\n                 if end > start {\n                     l.remove(start as usize, end as usize, src_start as usize)\n@@ -569,15 +555,8 @@ impl Node {\n             Node::InnerNode(ref mut i) => i.src_insert(node, start, src_start),\n             Node::LeafNode(ref mut l) => {\n                 debug!(\"src_insert: pre-adjust {}, {}; {}\", start, src_start, l.src_offset);\n-                let mut start = start as isize + l.src_offset;\n-                if start < 0 {\n-                    start = 0;\n-                }\n-                // TODO src_start?\n-                let mut src_start = src_start as isize + l.src_offset;\n-                if src_start < 0 {\n-                    src_start = 0;\n-                }\n+                let start = minz(start as isize + l.src_offset);\n+                let src_start = minz(src_start as isize + l.src_offset);\n                 debug!(\"src_insert: post-adjust {}, {}\", start, src_start);\n                 l.insert(node, start as usize, src_start as usize)\n             }\n@@ -596,14 +575,8 @@ impl Node {\n             Node::InnerNode(ref i) => i.find_src_slice(start, end, slice),\n             Node::LeafNode(ref l) => {\n                 debug!(\"find_src_slice: pre-adjust {}-{}; {}\", start, end, l.src_offset);\n-                let mut start = start as isize + l.src_offset;\n-                if start < 0 {\n-                    start = 0;\n-                }\n-                let mut end = end as isize + l.src_offset;\n-                if end < 0 {\n-                    end = 0;\n-                }\n+                let start = minz(start as isize + l.src_offset);\n+                let end = minz(end as isize + l.src_offset);\n                 debug!(\"find_src_slice: post-adjust {}-{}\", start, end);\n                 if end > start {\n                     l.find_slice(start as usize, end as usize, slice);\n@@ -1117,21 +1090,14 @@ impl Lnode {\n             i -= 1;\n         }\n \n-        let loc = if loc < 0 {\n-            0\n-        } else {\n-            loc as usize\n-        };\n+        let loc = minz(loc) as usize;\n         debug!(\"Lnode::col_for_src_loc, return Continue({})\", loc);\n         Search::Continue(loc)\n     }\n \n     fn find_last_char(&self, needle: char) -> Option<usize> {\n         // FIXME due to multi-byte chars, this will give false positives\n-        // I think we must search forwards from the start :-( Perhaps we could\n-        // track unicode vs ascii or something (I don't think there is an efficient\n-        // way to read unicode backwards, I might be wrong).\n-        // std::str::GraphemeIndices can do this!\n+        // FIXME use std::str::GraphemeIndices to do this!\n         let mut loc = self.len as isize - 1;\n         while loc >= 0 {\n             unsafe {\n@@ -1147,8 +1113,169 @@ impl Lnode {\n     }\n }\n \n-//TODO comment etc.\n+// The state of searching through a rope.\n enum Search {\n+    // TODO comment\n     Continue(usize),\n+    // TODO comment\n     Done(usize)\n }\n+\n+fn minz<I: SignedInt>(x: I) -> I {\n+    if x.is_negative() {\n+        return I::zero();\n+    }\n+\n+    x\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    // FIXME is this a Rust bug? Why is minz not imported by the glob import?\n+    use super::minz;\n+\n+    #[test]\n+    fn test_new() {\n+        let r = Rope::new();\n+        assert!(r.len() == 0);\n+        assert!(r.to_string() == \"\");\n+\n+        let r = Rope::from_string(\"Hello world!\".to_string());\n+        assert!(r.len() == 12);\n+        assert!(r.to_string() == \"Hello world!\");\n+    }\n+\n+    #[test]\n+    fn test_minz() {\n+        let x: i32 = 0;\n+        assert!(super::minz(x) == 0);\n+        let x: i32 = 42;\n+        assert!(minz(x) == 42);\n+        let x: i32 = -42;\n+        assert!(minz(x) == 0);\n+        let x: isize = 0;\n+        assert!(minz(x) == 0);\n+        let x: isize = 42;\n+        assert!(minz(x) == 42);\n+        let x: isize = -42;\n+        assert!(minz(x) == 0);\n+    }\n+\n+    #[test]\n+    fn test_from_string() {\n+        let mut r: Rope = \"Hello world!\".parse().unwrap();\n+        assert!(r.to_string() == \"Hello world!\");\n+    }\n+\n+    #[test]\n+    fn test_remove() {\n+        let mut r: Rope = \"Hello world!\".parse().unwrap();\n+        r.remove(0, 10);\n+        assert!(r.to_string() == \"d!\");\n+        assert!(r.src_slice(0..5).to_string() == \"\");\n+        assert!(r.src_slice(10..12).to_string() == \"d!\");       \n+\n+        let mut r: Rope = \"Hello world!\".parse().unwrap();\n+        r.remove(4, 12);\n+        assert!(r.to_string() == \"Hell\");\n+        // TODO\n+        //assert!(r.src_slice(0..4).to_string() == \"Hell\");\n+        //assert!(r.src_slice(10..12).to_string() == \"\");       \n+\n+        let mut r: Rope = \"Hello world!\".parse().unwrap();\n+        r.remove(4, 10);\n+        assert!(r.to_string() == \"Helld!\");\n+        // TODO\n+        //assert!(r.src_slice(1..5).to_string() == \"ell\");\n+        assert!(r.src_slice(9..12).to_string() == \"d!\");\n+    }\n+\n+    #[test]\n+    fn test_insert_copy() {\n+        let mut r: Rope = \"Hello world!\".parse().unwrap();\n+        r.insert_copy(0, \"foo\");\n+        assert!(r.to_string() == \"fooHello world!\");\n+        assert!(r.slice(2..8).to_string() == \"oHello\");\n+\n+        let mut r: Rope = \"Hello world!\".parse().unwrap();\n+        r.insert_copy(12, \"foo\");\n+        assert!(r.to_string() == \"Hello world!foo\");\n+        assert!(r.slice(2..8).to_string() == \"llo wo\");\n+\n+        let mut r: Rope = \"Hello world!\".parse().unwrap();\n+        r.insert_copy(5, \"foo\");\n+        assert!(r.to_string() == \"Hellofoo world!\");\n+        assert!(r.slice(2..8).to_string() == \"llofoo\");\n+    }\n+\n+    #[test]\n+    fn test_push_copy() {\n+        let mut r: Rope = \"Hello world!\".parse().unwrap();\n+        r.push_copy(\"foo\");\n+        assert!(r.to_string() == \"Hello world!foo\");\n+        assert!(r.slice(2..8).to_string() == \"llo wo\");\n+    }\n+\n+    #[test]\n+    fn test_insert_replace() {\n+        let mut r: Rope = \"hello worl\\u{00bb0}!\".parse().unwrap();\n+        r.insert_copy(5, \"bb\");\n+        assert!(r.to_string() == \"hellobb worl\u0bb0!\");\n+        r.replace(0, 'H');\n+        r.replace(15, '~');\n+        r.replace_str(5, \"fo\\u{00cb0}\");\n+        assert!(r.to_string() == \"Hellofo\u0cb0rl\u0bb0~\");\n+        assert!(r.slice(0..10).to_string() == \"Hellofo\u0cb0\");\n+        assert!(r.slice(5..10).to_string() == \"fo\u0cb0\");\n+        assert!(r.slice(10..15).to_string() == \"rl\u0bb0\");\n+\n+        let expected = \"Hellofo\u0cb0rl\u0bb0~\";\n+        let mut byte_pos = 0;\n+        for ((c, b), e) in r.chars().zip(expected.chars()) {\n+            assert!(c == e);\n+            assert!(b == byte_pos);\n+            byte_pos += e.len_utf8();\n+        }\n+    }\n+\n+    #[test]\n+    fn test_src_insert_remove_col_for_src_loc() {\n+        let mut r: Rope = \"hello\\n world!\".parse().unwrap();\n+        r.src_insert(4, \"foo\".to_string());\n+        r.src_insert(5, \"bar\".to_string());\n+        assert!(r.to_string() == \"hellfooobar\\n world!\");\n+\n+        r.src_remove(2, 4);\n+        r.src_remove(10, 12);\n+        assert!(r.to_string() == \"hefooobar\\n wor!\");\n+\n+        let expected = \"hefooobar\\n wor!\";\n+        let mut byte_pos = 0;\n+        for ((c, b), e) in r.chars().zip(expected.chars()) {\n+            assert!(c == e);\n+            assert!(b == byte_pos);\n+            byte_pos += e.len_utf8();\n+        }\n+\n+        let expected = [0, 1, 2, 2, 5, 9, 0, 1, 2, 3, 4, 4, 4];\n+        for i in 0..13 {\n+            assert!(r.col_for_src_loc(i) == expected[i]);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_src_insert() {\n+        let mut r: Rope = \"Hello world!\".parse().unwrap();\n+        r.src_insert(4, \"foo\".to_string());\n+        r.src_insert(0, \"foo\".to_string());\n+        r.src_insert(12, \"foo\".to_string());\n+        assert!(r.to_string() == \"fooHellfooo world!foo\");\n+        r.src_insert(4, \"bar\".to_string());\n+        r.src_insert(5, \"bar\".to_string());\n+        r.src_insert(3, \"bar\".to_string());\n+        r.src_insert(0, \"bar\".to_string());\n+        r.src_insert(12, \"bar\".to_string());\n+        assert!(r.to_string() == \"barfooHelbarlbarfooobar world!barfoo\");\n+    }\n+}"}]}