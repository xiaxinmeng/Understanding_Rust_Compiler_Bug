{"sha": "d32ce37a171663048a4c4a536803434e40f52bd6", "node_id": "C_kwDOAAsO6NoAKGQzMmNlMzdhMTcxNjYzMDQ4YTRjNGE1MzY4MDM0MzRlNDBmNTJiZDY", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-03-03T12:02:12Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-04-05T13:18:21Z"}, "message": "Mark scalar layout unions so that backends that do not support partially initialized scalars can special case them.", "tree": {"sha": "3305f97d4481ab2ca15fa3f1dcec4f6331c0bc30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3305f97d4481ab2ca15fa3f1dcec4f6331c0bc30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d32ce37a171663048a4c4a536803434e40f52bd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d32ce37a171663048a4c4a536803434e40f52bd6", "html_url": "https://github.com/rust-lang/rust/commit/d32ce37a171663048a4c4a536803434e40f52bd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d32ce37a171663048a4c4a536803434e40f52bd6/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ed6786404be276874fbcc7c3540f3237a87e0f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ed6786404be276874fbcc7c3540f3237a87e0f3", "html_url": "https://github.com/rust-lang/rust/commit/2ed6786404be276874fbcc7c3540f3237a87e0f3"}], "stats": {"total": 646, "additions": 357, "deletions": 289}, "files": [{"sha": "ffa629ca16c8b19d7bbc372fcc4055c8d94262a8", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -21,7 +21,7 @@ pub(crate) fn pointer_ty(tcx: TyCtxt<'_>) -> types::Type {\n }\n \n pub(crate) fn scalar_to_clif_type(tcx: TyCtxt<'_>, scalar: Scalar) -> Type {\n-    match scalar.value {\n+    match scalar.primitive() {\n         Primitive::Int(int, _sign) => match int {\n             Integer::I8 => types::I8,\n             Integer::I16 => types::I16,"}, {"sha": "357cb4a6d246fa451a1b42ff3413df5455ef3f81", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -105,7 +105,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n     // Decode the discriminant (specifically if it's niche-encoded).\n     match *tag_encoding {\n         TagEncoding::Direct => {\n-            let signed = match tag_scalar.value {\n+            let signed = match tag_scalar.primitive() {\n                 Int(_, signed) => signed,\n                 _ => false,\n             };"}, {"sha": "8f80b02ae0d4e7d98d588cd255f2ac210bdf209e", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -50,7 +50,7 @@ fn codegen_field<'tcx>(\n }\n \n fn scalar_pair_calculate_b_offset(tcx: TyCtxt<'_>, a_scalar: Scalar, b_scalar: Scalar) -> Offset32 {\n-    let b_offset = a_scalar.value.size(&tcx).align_to(b_scalar.value.align(&tcx).abi);\n+    let b_offset = a_scalar.size(&tcx).align_to(b_scalar.align(&tcx).abi);\n     Offset32::new(b_offset.bytes().try_into().unwrap())\n }\n "}, {"sha": "41f88f119e2a2b017a9e889c99e0748e9a2cc930", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -694,11 +694,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         }\n \n         fn scalar_load_metadata<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, load: RValue<'gcc>, scalar: &abi::Scalar) {\n-            let vr = scalar.valid_range.clone();\n-            match scalar.value {\n+            let vr = scalar.valid_range(bx);\n+            match scalar.primitive() {\n                 abi::Int(..) => {\n                     if !scalar.is_always_valid(bx) {\n-                        bx.range_metadata(load, scalar.valid_range);\n+                        bx.range_metadata(load, vr);\n                     }\n                 }\n                 abi::Pointer if vr.start < vr.end && !vr.contains(0) => {\n@@ -720,7 +720,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 OperandValue::Immediate(self.to_immediate(load, place.layout))\n             }\n             else if let abi::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n-                let b_offset = a.value.size(self).align_to(b.value.align(self).abi);\n+                let b_offset = a.size(self).align_to(b.align(self).abi);\n                 let pair_type = place.layout.gcc_type(self, false);\n \n                 let mut load = |i, scalar: &abi::Scalar, align| {"}, {"sha": "b056b6d473042de78afd61ac952554c2a871dcf6", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -158,14 +158,14 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, ty: Type<'gcc>) -> RValue<'gcc> {\n-        let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n+        let bitsize = if layout.is_bool() { 1 } else { layout.size(self).bits() };\n         match cv {\n             Scalar::Int(ScalarInt::ZST) => {\n-                assert_eq!(0, layout.value.size(self).bytes());\n+                assert_eq!(0, layout.size(self).bytes());\n                 self.const_undef(self.type_ix(0))\n             }\n             Scalar::Int(int) => {\n-                let data = int.assert_bits(layout.value.size(self));\n+                let data = int.assert_bits(layout.size(self));\n \n                 // FIXME(antoyo): there's some issues with using the u128 code that follows, so hard-code\n                 // the paths for floating-point values.\n@@ -209,7 +209,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 let base_addr = self.const_bitcast(base_addr, self.usize_type);\n                 let offset = self.context.new_rvalue_from_long(self.usize_type, offset.bytes() as i64);\n                 let ptr = self.const_bitcast(base_addr + offset, ptr_type);\n-                if layout.value != Pointer {\n+                if layout.primitive() != Pointer {\n                     self.const_bitcast(ptr.dereference(None).to_rvalue(), ty)\n                 }\n                 else {"}, {"sha": "805a265226da3a9563681a5d901deb37186ab6a0", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -328,7 +328,7 @@ pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: ConstAl\n                 interpret::Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n                 &cx.tcx,\n             ),\n-            abi::Scalar { value: Primitive::Pointer, valid_range: WrappingRange { start: 0, end: !0 } },\n+            abi::Scalar::Initialized { value: Primitive::Pointer, valid_range: WrappingRange { start: 0, end: !0 } },\n             cx.type_i8p(),\n         ));\n         next_offset = offset + pointer_size;"}, {"sha": "2c042ba4e3a9e99780bb9c900a0fe91a60b5422b", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -224,7 +224,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n     }\n \n     fn scalar_gcc_type_at<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, scalar: &abi::Scalar, offset: Size) -> Type<'gcc> {\n-        match scalar.value {\n+        match scalar.primitive() {\n             Int(i, true) => cx.type_from_integer(i),\n             Int(i, false) => cx.type_from_unsigned_integer(i),\n             F32 => cx.type_f32(),\n@@ -282,7 +282,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                 Size::ZERO\n             }\n             else {\n-                a.value.size(cx).align_to(b.value.align(cx).abi)\n+                a.size(cx).align_to(b.align(cx).abi)\n             };\n         self.scalar_gcc_type_at(cx, scalar, offset)\n     }"}, {"sha": "b9baa87bac7c7fba8bf663a478b9b6c41868895d", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -510,9 +510,9 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             // If the value is a boolean, the range is 0..2 and that ultimately\n             // become 0..0 when the type becomes i1, which would be rejected\n             // by the LLVM verifier.\n-            if let Int(..) = scalar.value {\n+            if let Int(..) = scalar.primitive() {\n                 if !scalar.is_bool() && !scalar.is_always_valid(bx) {\n-                    bx.range_metadata(callsite, scalar.valid_range);\n+                    bx.range_metadata(callsite, scalar.valid_range(bx));\n                 }\n             }\n         }"}, {"sha": "03c390b4bd427af8c96833c5d9d143da037b0ae2", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 43, "deletions": 37, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -753,7 +753,7 @@ fn dummy_output_type<'ll>(cx: &CodegenCx<'ll, '_>, reg: InlineAsmRegClass) -> &'\n /// Helper function to get the LLVM type for a Scalar. Pointers are returned as\n /// the equivalent integer type.\n fn llvm_asm_scalar_type<'ll>(cx: &CodegenCx<'ll, '_>, scalar: Scalar) -> &'ll Type {\n-    match scalar.value {\n+    match scalar.primitive() {\n         Primitive::Int(Integer::I8, _) => cx.type_i8(),\n         Primitive::Int(Integer::I16, _) => cx.type_i16(),\n         Primitive::Int(Integer::I32, _) => cx.type_i32(),\n@@ -774,7 +774,7 @@ fn llvm_fixup_input<'ll, 'tcx>(\n ) -> &'ll Value {\n     match (reg, layout.abi) {\n         (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n-            if let Primitive::Int(Integer::I8, _) = s.value {\n+            if let Primitive::Int(Integer::I8, _) = s.primitive() {\n                 let vec_ty = bx.cx.type_vector(bx.cx.type_i8(), 8);\n                 bx.insert_element(bx.const_undef(vec_ty), value, bx.const_i32(0))\n             } else {\n@@ -785,7 +785,7 @@ fn llvm_fixup_input<'ll, 'tcx>(\n             let elem_ty = llvm_asm_scalar_type(bx.cx, s);\n             let count = 16 / layout.size.bytes();\n             let vec_ty = bx.cx.type_vector(elem_ty, count);\n-            if let Primitive::Pointer = s.value {\n+            if let Primitive::Pointer = s.primitive() {\n                 value = bx.ptrtoint(value, bx.cx.type_isize());\n             }\n             bx.insert_element(bx.const_undef(vec_ty), value, bx.const_i32(0))\n@@ -800,7 +800,7 @@ fn llvm_fixup_input<'ll, 'tcx>(\n             bx.shuffle_vector(value, bx.const_undef(vec_ty), bx.const_vector(&indices))\n         }\n         (InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd), Abi::Scalar(s))\n-            if s.value == Primitive::F64 =>\n+            if s.primitive() == Primitive::F64 =>\n         {\n             bx.bitcast(value, bx.cx.type_i64())\n         }\n@@ -812,7 +812,7 @@ fn llvm_fixup_input<'ll, 'tcx>(\n             InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg | ArmInlineAsmRegClass::sreg_low16),\n             Abi::Scalar(s),\n         ) => {\n-            if let Primitive::Int(Integer::I32, _) = s.value {\n+            if let Primitive::Int(Integer::I32, _) = s.primitive() {\n                 bx.bitcast(value, bx.cx.type_f32())\n             } else {\n                 value\n@@ -826,19 +826,21 @@ fn llvm_fixup_input<'ll, 'tcx>(\n             ),\n             Abi::Scalar(s),\n         ) => {\n-            if let Primitive::Int(Integer::I64, _) = s.value {\n+            if let Primitive::Int(Integer::I64, _) = s.primitive() {\n                 bx.bitcast(value, bx.cx.type_f64())\n             } else {\n                 value\n             }\n         }\n-        (InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg), Abi::Scalar(s)) => match s.value {\n-            // MIPS only supports register-length arithmetics.\n-            Primitive::Int(Integer::I8 | Integer::I16, _) => bx.zext(value, bx.cx.type_i32()),\n-            Primitive::F32 => bx.bitcast(value, bx.cx.type_i32()),\n-            Primitive::F64 => bx.bitcast(value, bx.cx.type_i64()),\n-            _ => value,\n-        },\n+        (InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg), Abi::Scalar(s)) => {\n+            match s.primitive() {\n+                // MIPS only supports register-length arithmetics.\n+                Primitive::Int(Integer::I8 | Integer::I16, _) => bx.zext(value, bx.cx.type_i32()),\n+                Primitive::F32 => bx.bitcast(value, bx.cx.type_i32()),\n+                Primitive::F64 => bx.bitcast(value, bx.cx.type_i64()),\n+                _ => value,\n+            }\n+        }\n         _ => value,\n     }\n }\n@@ -852,15 +854,15 @@ fn llvm_fixup_output<'ll, 'tcx>(\n ) -> &'ll Value {\n     match (reg, layout.abi) {\n         (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n-            if let Primitive::Int(Integer::I8, _) = s.value {\n+            if let Primitive::Int(Integer::I8, _) = s.primitive() {\n                 bx.extract_element(value, bx.const_i32(0))\n             } else {\n                 value\n             }\n         }\n         (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16), Abi::Scalar(s)) => {\n             value = bx.extract_element(value, bx.const_i32(0));\n-            if let Primitive::Pointer = s.value {\n+            if let Primitive::Pointer = s.primitive() {\n                 value = bx.inttoptr(value, layout.llvm_type(bx.cx));\n             }\n             value\n@@ -875,7 +877,7 @@ fn llvm_fixup_output<'ll, 'tcx>(\n             bx.shuffle_vector(value, bx.const_undef(vec_ty), bx.const_vector(&indices))\n         }\n         (InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd), Abi::Scalar(s))\n-            if s.value == Primitive::F64 =>\n+            if s.primitive() == Primitive::F64 =>\n         {\n             bx.bitcast(value, bx.cx.type_f64())\n         }\n@@ -887,7 +889,7 @@ fn llvm_fixup_output<'ll, 'tcx>(\n             InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg | ArmInlineAsmRegClass::sreg_low16),\n             Abi::Scalar(s),\n         ) => {\n-            if let Primitive::Int(Integer::I32, _) = s.value {\n+            if let Primitive::Int(Integer::I32, _) = s.primitive() {\n                 bx.bitcast(value, bx.cx.type_i32())\n             } else {\n                 value\n@@ -901,20 +903,22 @@ fn llvm_fixup_output<'ll, 'tcx>(\n             ),\n             Abi::Scalar(s),\n         ) => {\n-            if let Primitive::Int(Integer::I64, _) = s.value {\n+            if let Primitive::Int(Integer::I64, _) = s.primitive() {\n                 bx.bitcast(value, bx.cx.type_i64())\n             } else {\n                 value\n             }\n         }\n-        (InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg), Abi::Scalar(s)) => match s.value {\n-            // MIPS only supports register-length arithmetics.\n-            Primitive::Int(Integer::I8, _) => bx.trunc(value, bx.cx.type_i8()),\n-            Primitive::Int(Integer::I16, _) => bx.trunc(value, bx.cx.type_i16()),\n-            Primitive::F32 => bx.bitcast(value, bx.cx.type_f32()),\n-            Primitive::F64 => bx.bitcast(value, bx.cx.type_f64()),\n-            _ => value,\n-        },\n+        (InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg), Abi::Scalar(s)) => {\n+            match s.primitive() {\n+                // MIPS only supports register-length arithmetics.\n+                Primitive::Int(Integer::I8, _) => bx.trunc(value, bx.cx.type_i8()),\n+                Primitive::Int(Integer::I16, _) => bx.trunc(value, bx.cx.type_i16()),\n+                Primitive::F32 => bx.bitcast(value, bx.cx.type_f32()),\n+                Primitive::F64 => bx.bitcast(value, bx.cx.type_f64()),\n+                _ => value,\n+            }\n+        }\n         _ => value,\n     }\n }\n@@ -927,7 +931,7 @@ fn llvm_fixup_output_type<'ll, 'tcx>(\n ) -> &'ll Type {\n     match (reg, layout.abi) {\n         (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n-            if let Primitive::Int(Integer::I8, _) = s.value {\n+            if let Primitive::Int(Integer::I8, _) = s.primitive() {\n                 cx.type_vector(cx.type_i8(), 8)\n             } else {\n                 layout.llvm_type(cx)\n@@ -946,7 +950,7 @@ fn llvm_fixup_output_type<'ll, 'tcx>(\n             cx.type_vector(elem_ty, count * 2)\n         }\n         (InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd), Abi::Scalar(s))\n-            if s.value == Primitive::F64 =>\n+            if s.primitive() == Primitive::F64 =>\n         {\n             cx.type_i64()\n         }\n@@ -958,7 +962,7 @@ fn llvm_fixup_output_type<'ll, 'tcx>(\n             InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg | ArmInlineAsmRegClass::sreg_low16),\n             Abi::Scalar(s),\n         ) => {\n-            if let Primitive::Int(Integer::I32, _) = s.value {\n+            if let Primitive::Int(Integer::I32, _) = s.primitive() {\n                 cx.type_f32()\n             } else {\n                 layout.llvm_type(cx)\n@@ -972,19 +976,21 @@ fn llvm_fixup_output_type<'ll, 'tcx>(\n             ),\n             Abi::Scalar(s),\n         ) => {\n-            if let Primitive::Int(Integer::I64, _) = s.value {\n+            if let Primitive::Int(Integer::I64, _) = s.primitive() {\n                 cx.type_f64()\n             } else {\n                 layout.llvm_type(cx)\n             }\n         }\n-        (InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg), Abi::Scalar(s)) => match s.value {\n-            // MIPS only supports register-length arithmetics.\n-            Primitive::Int(Integer::I8 | Integer::I16, _) => cx.type_i32(),\n-            Primitive::F32 => cx.type_i32(),\n-            Primitive::F64 => cx.type_i64(),\n-            _ => layout.llvm_type(cx),\n-        },\n+        (InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg), Abi::Scalar(s)) => {\n+            match s.primitive() {\n+                // MIPS only supports register-length arithmetics.\n+                Primitive::Int(Integer::I8 | Integer::I16, _) => cx.type_i32(),\n+                Primitive::F32 => cx.type_i32(),\n+                Primitive::F64 => cx.type_i64(),\n+                _ => layout.llvm_type(cx),\n+            }\n+        }\n         _ => layout.llvm_type(cx),\n     }\n }"}, {"sha": "88b87951ecd35b57fd8e791b8261f865078a3d55", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -484,14 +484,14 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 bx.noundef_metadata(load);\n             }\n \n-            match scalar.value {\n+            match scalar.primitive() {\n                 abi::Int(..) => {\n                     if !scalar.is_always_valid(bx) {\n-                        bx.range_metadata(load, scalar.valid_range);\n+                        bx.range_metadata(load, scalar.valid_range(bx));\n                     }\n                 }\n                 abi::Pointer => {\n-                    if !scalar.valid_range.contains(0) {\n+                    if !scalar.valid_range(bx).contains(0) {\n                         bx.nonnull_metadata(load);\n                     }\n \n@@ -525,7 +525,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             });\n             OperandValue::Immediate(self.to_immediate(llval, place.layout))\n         } else if let abi::Abi::ScalarPair(a, b) = place.layout.abi {\n-            let b_offset = a.value.size(self).align_to(b.value.align(self).abi);\n+            let b_offset = a.size(self).align_to(b.align(self).abi);\n             let pair_ty = place.layout.llvm_type(self);\n \n             let mut load = |i, scalar: abi::Scalar, layout, align, offset| {"}, {"sha": "b69d7a000ee9abbbf240d124acf5c70f27367ec2", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -221,16 +221,16 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, llty: &'ll Type) -> &'ll Value {\n-        let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n+        let bitsize = if layout.is_bool() { 1 } else { layout.size(self).bits() };\n         match cv {\n             Scalar::Int(ScalarInt::ZST) => {\n-                assert_eq!(0, layout.value.size(self).bytes());\n+                assert_eq!(0, layout.size(self).bytes());\n                 self.const_undef(self.type_ix(0))\n             }\n             Scalar::Int(int) => {\n-                let data = int.assert_bits(layout.value.size(self));\n+                let data = int.assert_bits(layout.size(self));\n                 let llval = self.const_uint_big(self.type_ix(bitsize), data);\n-                if layout.value == Pointer {\n+                if layout.primitive() == Pointer {\n                     unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n                 } else {\n                     self.const_bitcast(llval, llty)\n@@ -269,7 +269,7 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         1,\n                     )\n                 };\n-                if layout.value != Pointer {\n+                if layout.primitive() != Pointer {\n                     unsafe { llvm::LLVMConstPtrToInt(llval, llty) }\n                 } else {\n                     self.const_bitcast(llval, llty)"}, {"sha": "557e3f47c906849cc47a62b5054aa11f2eb85159", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -109,7 +109,10 @@ pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<\n                 Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n                 &cx.tcx,\n             ),\n-            Scalar { value: Primitive::Pointer, valid_range: WrappingRange { start: 0, end: !0 } },\n+            Scalar::Initialized {\n+                value: Primitive::Pointer,\n+                valid_range: WrappingRange { start: 0, end: !0 },\n+            },\n             cx.type_i8p_ext(address_space),\n         ));\n         next_offset = offset + pointer_size;"}, {"sha": "73e01d0453b257077c8d0605417699f538c01d3d", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -118,7 +118,7 @@ fn tag_base_type<'ll, 'tcx>(\n \n         Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, tag, .. } => {\n             // Niche tags are always normalized to unsized integers of the correct size.\n-            match tag.value {\n+            match tag.primitive() {\n                 Primitive::Int(t, _) => t,\n                 Primitive::F32 => Integer::I32,\n                 Primitive::F64 => Integer::I64,\n@@ -136,7 +136,7 @@ fn tag_base_type<'ll, 'tcx>(\n \n         Variants::Multiple { tag_encoding: TagEncoding::Direct, tag, .. } => {\n             // Direct tags preserve the sign.\n-            tag.value.to_ty(cx.tcx)\n+            tag.primitive().to_ty(cx.tcx)\n         }\n     }\n }\n@@ -425,7 +425,7 @@ fn compute_discriminant_value<'ll, 'tcx>(\n                 let value = (variant_index.as_u32() as u128)\n                     .wrapping_sub(niche_variants.start().as_u32() as u128)\n                     .wrapping_add(niche_start);\n-                let value = tag.value.size(cx).truncate(value);\n+                let value = tag.size(cx).truncate(value);\n                 // NOTE(eddyb) do *NOT* remove this assert, until\n                 // we pass the full 128-bit value to LLVM, otherwise\n                 // truncation will be silent and remain undetected."}, {"sha": "48840c76cac8b05c4d312e60af84d5e85d5af1ba", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -134,7 +134,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n             sym::va_arg => {\n                 match fn_abi.ret.layout.abi {\n                     abi::Abi::Scalar(scalar) => {\n-                        match scalar.value {\n+                        match scalar.primitive() {\n                             Primitive::Int(..) => {\n                                 if self.cx().size_of(ret_ty).bytes() < 4 {\n                                     // `va_arg` should not be called on an integer type"}, {"sha": "862805236311dab7717942c657eafce04f622b97", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -309,7 +309,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n         scalar: Scalar,\n         offset: Size,\n     ) -> &'a Type {\n-        match scalar.value {\n+        match scalar.primitive() {\n             Int(i, _) => cx.type_from_integer(i),\n             F32 => cx.type_f32(),\n             F64 => cx.type_f64(),\n@@ -362,8 +362,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n             return cx.type_i1();\n         }\n \n-        let offset =\n-            if index == 0 { Size::ZERO } else { a.value.size(cx).align_to(b.value.align(cx).abi) };\n+        let offset = if index == 0 { Size::ZERO } else { a.size(cx).align_to(b.align(cx).abi) };\n         self.scalar_llvm_type_at(cx, scalar, offset)\n     }\n "}, {"sha": "369ca950e87be033e8a166a2101d1981290e5457", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -464,13 +464,13 @@ fn push_debuginfo_type_name<'tcx>(\n \n             // calculate the range of values for the dataful variant\n             let dataful_discriminant_range =\n-                dataful_variant_layout.largest_niche().unwrap().scalar.valid_range;\n+                dataful_variant_layout.largest_niche().unwrap().valid_range;\n \n             let min = dataful_discriminant_range.start;\n-            let min = tag.value.size(&tcx).truncate(min);\n+            let min = tag.size(&tcx).truncate(min);\n \n             let max = dataful_discriminant_range.end;\n-            let max = tag.value.size(&tcx).truncate(max);\n+            let max = tag.size(&tcx).truncate(max);\n \n             let dataful_variant_name = variant_name(*dataful_variant);\n             write!(output, \", {}, {}, {}\", min, max, dataful_variant_name).unwrap();"}, {"sha": "b7d760bfbabe1d3325252df2513428803d5792ed", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -1572,7 +1572,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         match (src.layout.abi, dst.layout.abi) {\n             (abi::Abi::Scalar(src_scalar), abi::Abi::Scalar(dst_scalar)) => {\n                 // HACK(eddyb) LLVM doesn't like `bitcast`s between pointers and non-pointers.\n-                if (src_scalar.value == abi::Pointer) == (dst_scalar.value == abi::Pointer) {\n+                if (src_scalar.primitive() == abi::Pointer)\n+                    == (dst_scalar.primitive() == abi::Pointer)\n+                {\n                     assert_eq!(src.layout.size, dst.layout.size);\n \n                     // NOTE(eddyb) the `from_immediate` and `to_immediate_scalar`"}, {"sha": "08be4c0a7b622e2b46130721fdf194922c058eb3", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -207,11 +207,11 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n             // Extract a scalar component from a pair.\n             (OperandValue::Pair(a_llval, b_llval), Abi::ScalarPair(a, b)) => {\n                 if offset.bytes() == 0 {\n-                    assert_eq!(field.size, a.value.size(bx.cx()));\n+                    assert_eq!(field.size, a.size(bx.cx()));\n                     OperandValue::Immediate(a_llval)\n                 } else {\n-                    assert_eq!(offset, a.value.size(bx.cx()).align_to(b.value.align(bx.cx()).abi));\n-                    assert_eq!(field.size, b.value.size(bx.cx()));\n+                    assert_eq!(offset, a.size(bx.cx()).align_to(b.align(bx.cx()).abi));\n+                    assert_eq!(field.size, b.size(bx.cx()));\n                     OperandValue::Immediate(b_llval)\n                 }\n             }\n@@ -316,7 +316,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n                     bug!(\"store_with_flags: invalid ScalarPair layout: {:#?}\", dest.layout);\n                 };\n                 let ty = bx.backend_type(dest.layout);\n-                let b_offset = a_scalar.value.size(bx).align_to(b_scalar.value.align(bx).abi);\n+                let b_offset = a_scalar.size(bx).align_to(b_scalar.align(bx).abi);\n \n                 let llptr = bx.struct_gep(ty, dest.llval, 0);\n                 let val = bx.from_immediate(a);"}, {"sha": "cf69c8fd8fda940784522c89ecff24d71ea516d5", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     self.llval\n                 }\n                 Abi::ScalarPair(a, b)\n-                    if offset == a.value.size(bx.cx()).align_to(b.value.align(bx.cx()).abi) =>\n+                    if offset == a.size(bx.cx()).align_to(b.align(bx.cx()).abi) =>\n                 {\n                     // Offset matches second field.\n                     let ty = bx.backend_type(self.layout);\n@@ -234,7 +234,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         // Decode the discriminant (specifically if it's niche-encoded).\n         match *tag_encoding {\n             TagEncoding::Direct => {\n-                let signed = match tag_scalar.value {\n+                let signed = match tag_scalar.primitive() {\n                     // We use `i1` for bytes that are always `0` or `1`,\n                     // e.g., `#[repr(i8)] enum E { A, B }`, but we can't\n                     // let LLVM interpret the `i1` as signed, because"}, {"sha": "fd29c9e281b920dba741834c28a1703753631785", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -299,23 +299,25 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                         let mut signed = false;\n                         if let Abi::Scalar(scalar) = operand.layout.abi {\n-                            if let Int(_, s) = scalar.value {\n+                            if let Int(_, s) = scalar.primitive() {\n                                 // We use `i1` for bytes that are always `0` or `1`,\n                                 // e.g., `#[repr(i8)] enum E { A, B }`, but we can't\n                                 // let LLVM interpret the `i1` as signed, because\n                                 // then `i1 1` (i.e., E::B) is effectively `i8 -1`.\n                                 signed = !scalar.is_bool() && s;\n \n                                 if !scalar.is_always_valid(bx.cx())\n-                                    && scalar.valid_range.end >= scalar.valid_range.start\n+                                    && scalar.valid_range(bx.cx()).end\n+                                        >= scalar.valid_range(bx.cx()).start\n                                 {\n                                     // We want `table[e as usize \u00b1 k]` to not\n                                     // have bound checks, and this is the most\n                                     // convenient place to put the `assume`s.\n-                                    if scalar.valid_range.start > 0 {\n-                                        let enum_value_lower_bound = bx\n-                                            .cx()\n-                                            .const_uint_big(ll_t_in, scalar.valid_range.start);\n+                                    if scalar.valid_range(bx.cx()).start > 0 {\n+                                        let enum_value_lower_bound = bx.cx().const_uint_big(\n+                                            ll_t_in,\n+                                            scalar.valid_range(bx.cx()).start,\n+                                        );\n                                         let cmp_start = bx.icmp(\n                                             IntPredicate::IntUGE,\n                                             llval,\n@@ -324,8 +326,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                         bx.assume(cmp_start);\n                                     }\n \n-                                    let enum_value_upper_bound =\n-                                        bx.cx().const_uint_big(ll_t_in, scalar.valid_range.end);\n+                                    let enum_value_upper_bound = bx\n+                                        .cx()\n+                                        .const_uint_big(ll_t_in, scalar.valid_range(bx.cx()).end);\n                                     let cmp_end = bx.icmp(\n                                         IntPredicate::IntULE,\n                                         llval,"}, {"sha": "66fa846ee73d040a472bcca73852d4149f8a522f", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -188,7 +188,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let val = self.read_scalar(&args[0])?.check_init()?;\n                 let bits = val.to_bits(layout_of.size)?;\n                 let kind = match layout_of.abi {\n-                    Abi::Scalar(scalar) => scalar.value,\n+                    Abi::Scalar(scalar) => scalar.primitive(),\n                     _ => span_bug!(\n                         self.cur_span(),\n                         \"{} called on invalid type {:?}\","}, {"sha": "73009052e04c5ad790732904d424029074655213", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -265,6 +265,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }));\n         };\n \n+        // It may seem like all types with `Scalar` or `ScalarPair` ABI are fair game at this point.\n+        // However, `MaybeUninit<u64>` is considered a `Scalar` as far as its layout is concerned --\n+        // and yet cannot be represented by an interpreter `Scalar`, since we have to handle the\n+        // case where some of the bytes are initialized and others are not. So, we only permit\n+        // reads from `Scalar`s and `ScalarPair`s that cannot be uninitialized.\n         match mplace.layout.abi {\n             Abi::Scalar(..) => {\n                 let scalar = alloc.read_scalar(alloc_range(Size::ZERO, mplace.layout.size))?;\n@@ -274,7 +279,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // We checked `ptr_align` above, so all fields will have the alignment they need.\n                 // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n                 // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n-                let (a, b) = (a.value, b.value);\n                 let (a_size, b_size) = (a.size(self), b.size(self));\n                 let b_offset = a_size.align_to(b.align(self).abi);\n                 assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n@@ -676,7 +680,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         //   may be a pointer. This is `tag_val.layout`; we just use it for sanity checks.\n \n         // Get layout for tag.\n-        let tag_layout = self.layout_of(tag_scalar_layout.value.to_int_ty(*self.tcx))?;\n+        let tag_layout = self.layout_of(tag_scalar_layout.primitive().to_int_ty(*self.tcx))?;\n \n         // Read tag and sanity-check `tag_layout`.\n         let tag_val = self.read_immediate(&self.operand_field(op, tag_field)?)?;"}, {"sha": "e8b3874ec0779a7a5f502f63f8b97181f4b40e96", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -772,13 +772,11 @@ where\n                 // We checked `ptr_align` above, so all fields will have the alignment they need.\n                 // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n                 // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n-                let (a, b) = match dest.layout.abi {\n-                    Abi::ScalarPair(a, b) => (a.value, b.value),\n-                    _ => span_bug!(\n+                let Abi::ScalarPair(a, b) = dest.layout.abi else { span_bug!(\n                         self.cur_span(),\n                         \"write_immediate_to_mplace: invalid ScalarPair layout: {:#?}\",\n                         dest.layout\n-                    ),\n+                    )\n                 };\n                 let (a_size, b_size) = (a.size(&tcx), b.size(&tcx));\n                 let b_offset = a_size.align_to(b.align(&tcx).abi);\n@@ -1047,7 +1045,7 @@ where\n                 // raw discriminants for enums are isize or bigger during\n                 // their computation, but the in-memory tag is the smallest possible\n                 // representation\n-                let size = tag_layout.value.size(self);\n+                let size = tag_layout.size(self);\n                 let tag_val = size.truncate(discr_val);\n \n                 let tag_dest = self.place_field(dest, tag_field)?;\n@@ -1071,7 +1069,7 @@ where\n                         .expect(\"overflow computing relative variant idx\");\n                     // We need to use machine arithmetic when taking into account `niche_start`:\n                     // tag_val = variant_index_relative + niche_start_val\n-                    let tag_layout = self.layout_of(tag_layout.value.to_int_ty(*self.tcx))?;\n+                    let tag_layout = self.layout_of(tag_layout.primitive().to_int_ty(*self.tcx))?;\n                     let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n                     let variant_index_relative_val =\n                         ImmTy::from_uint(variant_index_relative, tag_layout);"}, {"sha": "3ffa514a7b9ce825d50c5dadce89e510e5ceff16", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -189,12 +189,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // that will take care to make it UB to leave the range, just\n                 // like for transmute).\n                 (abi::Abi::Scalar(caller), abi::Abi::Scalar(callee)) => {\n-                    caller.value == callee.value\n+                    caller.primitive() == callee.primitive()\n                 }\n                 (\n                     abi::Abi::ScalarPair(caller1, caller2),\n                     abi::Abi::ScalarPair(callee1, callee2),\n-                ) => caller1.value == callee1.value && caller2.value == callee2.value,\n+                ) => {\n+                    caller1.primitive() == callee1.primitive()\n+                        && caller2.primitive() == callee2.primitive()\n+                }\n                 // Be conservative\n                 _ => false,\n             }"}, {"sha": "3d5ad153c9b0a9456e01475ca8588fa4b8c6e854", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -629,12 +629,12 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         op: &OpTy<'tcx, M::PointerTag>,\n         scalar_layout: ScalarAbi,\n     ) -> InterpResult<'tcx> {\n-        if scalar_layout.valid_range.is_full_for(op.layout.size) {\n+        if scalar_layout.valid_range(self.ecx).is_full_for(op.layout.size) {\n             // Nothing to check\n             return Ok(());\n         }\n         // At least one value is excluded.\n-        let valid_range = scalar_layout.valid_range;\n+        let valid_range = scalar_layout.valid_range(self.ecx);\n         let WrappingRange { start, end } = valid_range;\n         let max_value = op.layout.size.unsigned_int_max();\n         assert!(end <= max_value);"}, {"sha": "def02f5e85b1e1c9bf82ff234489350c6554400f", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::ty::{self, AdtKind, DefIdTree, Ty, TyCtxt, TypeFoldable};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, Symbol, DUMMY_SP};\n-use rustc_target::abi::Abi;\n+use rustc_target::abi::{Abi, WrappingRange};\n use rustc_target::abi::{Integer, TagEncoding, Variants};\n use rustc_target::spec::abi::Abi as SpecAbi;\n \n@@ -796,14 +796,18 @@ crate fn repr_nullable_ptr<'tcx>(\n         // Return the nullable type this Option-like enum can be safely represented with.\n         let field_ty_abi = &cx.layout_of(field_ty).unwrap().abi;\n         if let Abi::Scalar(field_ty_scalar) = field_ty_abi {\n-            match (field_ty_scalar.valid_range.start, field_ty_scalar.valid_range.end) {\n-                (0, x) if x == field_ty_scalar.value.size(&cx.tcx).unsigned_int_max() - 1 => {\n+            match field_ty_scalar.valid_range(cx) {\n+                WrappingRange { start: 0, end }\n+                    if end == field_ty_scalar.size(&cx.tcx).unsigned_int_max() - 1 =>\n+                {\n                     return Some(get_nullable_type(cx, field_ty).unwrap());\n                 }\n-                (1, _) => {\n+                WrappingRange { start: 1, .. } => {\n                     return Some(get_nullable_type(cx, field_ty).unwrap());\n                 }\n-                (start, end) => unreachable!(\"Unhandled start and end range: ({}, {})\", start, end),\n+                WrappingRange { start, end } => {\n+                    unreachable!(\"Unhandled start and end range: ({}, {})\", start, end)\n+                }\n             };\n         }\n     }\n@@ -1342,7 +1346,7 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n                 return\n             };\n \n-            let tag_size = tag.value.size(&cx.tcx).bytes();\n+            let tag_size = tag.size(&cx.tcx).bytes();\n \n             debug!(\n                 \"enum `{}` is {} bytes large with layout:\\n{:#?}\","}, {"sha": "390f7ab2d18cc9ca324bc48fc840e186ba36e738", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -305,10 +305,10 @@ fn invert_mapping(map: &[u32]) -> Vec<u32> {\n impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n     fn scalar_pair(&self, a: Scalar, b: Scalar) -> LayoutS<'tcx> {\n         let dl = self.data_layout();\n-        let b_align = b.value.align(dl);\n-        let align = a.value.align(dl).max(b_align).max(dl.aggregate_align);\n-        let b_offset = a.value.size(dl).align_to(b_align.abi);\n-        let size = (b_offset + b.value.size(dl)).align_to(align.abi);\n+        let b_align = b.align(dl);\n+        let align = a.align(dl).max(b_align).max(dl.aggregate_align);\n+        let b_offset = a.size(dl).align_to(b_align.abi);\n+        let size = (b_offset + b.size(dl)).align_to(align.abi);\n \n         // HACK(nox): We iter on `b` and then `a` because `max_by_key`\n         // returns the last maximum.\n@@ -567,7 +567,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let scalar_unit = |value: Primitive| {\n             let size = value.size(dl);\n             assert!(size.bits() <= 128);\n-            Scalar { value, valid_range: WrappingRange { start: 0, end: size.unsigned_int_max() } }\n+            Scalar::Initialized {\n+                value,\n+                valid_range: WrappingRange { start: 0, end: size.unsigned_int_max() },\n+            }\n         };\n         let scalar =\n             |value: Primitive| tcx.intern_layout(LayoutS::scalar(self, scalar_unit(value)));\n@@ -581,11 +584,14 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             // Basic scalars.\n             ty::Bool => tcx.intern_layout(LayoutS::scalar(\n                 self,\n-                Scalar { value: Int(I8, false), valid_range: WrappingRange { start: 0, end: 1 } },\n+                Scalar::Initialized {\n+                    value: Int(I8, false),\n+                    valid_range: WrappingRange { start: 0, end: 1 },\n+                },\n             )),\n             ty::Char => tcx.intern_layout(LayoutS::scalar(\n                 self,\n-                Scalar {\n+                Scalar::Initialized {\n                     value: Int(I32, false),\n                     valid_range: WrappingRange { start: 0, end: 0x10FFFF },\n                 },\n@@ -598,7 +604,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }),\n             ty::FnPtr(_) => {\n                 let mut ptr = scalar_unit(Pointer);\n-                ptr.valid_range = ptr.valid_range.with_start(1);\n+                ptr.valid_range_mut().start = 1;\n                 tcx.intern_layout(LayoutS::scalar(self, ptr))\n             }\n \n@@ -616,7 +622,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             ty::Ref(_, pointee, _) | ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let mut data_ptr = scalar_unit(Pointer);\n                 if !ty.is_unsafe_ptr() {\n-                    data_ptr.valid_range = data_ptr.valid_range.with_start(1);\n+                    data_ptr.valid_range_mut().start = 1;\n                 }\n \n                 let pointee = tcx.normalize_erasing_regions(param_env, pointee);\n@@ -632,7 +638,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     ty::Slice(_) | ty::Str => scalar_unit(Int(dl.ptr_sized_integer(), false)),\n                     ty::Dynamic(..) => {\n                         let mut vtable = scalar_unit(Pointer);\n-                        vtable.valid_range = vtable.valid_range.with_start(1);\n+                        vtable.valid_range_mut().start = 1;\n                         vtable\n                     }\n                     _ => return Err(LayoutError::Unknown(unsized_part)),\n@@ -889,14 +895,14 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                         // If all non-ZST fields have the same ABI, forward this ABI\n                         if optimize && !field.is_zst() {\n-                            // Normalize scalar_unit to the maximal valid range\n+                            // Discard valid range information and allow undef\n                             let field_abi = match field.abi {\n-                                Abi::Scalar(x) => Abi::Scalar(scalar_unit(x.value)),\n+                                Abi::Scalar(x) => Abi::Scalar(x.to_union()),\n                                 Abi::ScalarPair(x, y) => {\n-                                    Abi::ScalarPair(scalar_unit(x.value), scalar_unit(y.value))\n+                                    Abi::ScalarPair(x.to_union(), y.to_union())\n                                 }\n                                 Abi::Vector { element: x, count } => {\n-                                    Abi::Vector { element: scalar_unit(x.value), count }\n+                                    Abi::Vector { element: x.to_union(), count }\n                                 }\n                                 Abi::Uninhabited | Abi::Aggregate { .. } => {\n                                     Abi::Aggregate { sized: true }\n@@ -1000,14 +1006,16 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             if let Bound::Included(start) = start {\n                                 // FIXME(eddyb) this might be incorrect - it doesn't\n                                 // account for wrap-around (end < start) ranges.\n-                                assert!(scalar.valid_range.start <= start);\n-                                scalar.valid_range.start = start;\n+                                let valid_range = scalar.valid_range_mut();\n+                                assert!(valid_range.start <= start);\n+                                valid_range.start = start;\n                             }\n                             if let Bound::Included(end) = end {\n                                 // FIXME(eddyb) this might be incorrect - it doesn't\n                                 // account for wrap-around (end < start) ranges.\n-                                assert!(scalar.valid_range.end >= end);\n-                                scalar.valid_range.end = end;\n+                                let valid_range = scalar.valid_range_mut();\n+                                assert!(valid_range.end >= end);\n+                                valid_range.end = end;\n                             }\n \n                             // Update `largest_niche` if we have introduced a larger niche.\n@@ -1133,9 +1141,15 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                         // guaranteed to be initialised, not the\n                                         // other primitive.\n                                         if offset.bytes() == 0 {\n-                                            Abi::ScalarPair(niche_scalar, scalar_unit(second.value))\n+                                            Abi::ScalarPair(\n+                                                niche_scalar,\n+                                                scalar_unit(second.primitive()),\n+                                            )\n                                         } else {\n-                                            Abi::ScalarPair(scalar_unit(first.value), niche_scalar)\n+                                            Abi::ScalarPair(\n+                                                scalar_unit(first.primitive()),\n+                                                niche_scalar,\n+                                            )\n                                         }\n                                     }\n                                     _ => Abi::Aggregate { sized: true },\n@@ -1314,7 +1328,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 }\n \n                 let tag_mask = ity.size().unsigned_int_max();\n-                let tag = Scalar {\n+                let tag = Scalar::Initialized {\n                     value: Int(ity, signed),\n                     valid_range: WrappingRange {\n                         start: (min as u128 & tag_mask),\n@@ -1325,7 +1339,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 // Without latter check aligned enums with custom discriminant values\n                 // Would result in ICE see the issue #92464 for more info\n-                if tag.value.size(dl) == size || variants.iter().all(|layout| layout.is_empty()) {\n+                if tag.size(dl) == size || variants.iter().all(|layout| layout.is_empty()) {\n                     abi = Abi::Scalar(tag);\n                 } else {\n                     // Try to use a ScalarPair for all tagged enums.\n@@ -1345,7 +1359,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             }\n                         };\n                         let prim = match field.abi {\n-                            Abi::Scalar(scalar) => scalar.value,\n+                            Abi::Scalar(scalar) => scalar.primitive(),\n                             _ => {\n                                 common_prim = None;\n                                 break;\n@@ -1599,7 +1613,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let max_discr = (info.variant_fields.len() - 1) as u128;\n         let discr_int = Integer::fit_unsigned(max_discr);\n         let discr_int_ty = discr_int.to_ty(tcx, false);\n-        let tag = Scalar {\n+        let tag = Scalar::Initialized {\n             value: Primitive::Int(discr_int, false),\n             valid_range: WrappingRange { start: 0, end: max_discr },\n         };\n@@ -1898,7 +1912,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     adt_kind.into(),\n                     adt_packed,\n                     match tag_encoding {\n-                        TagEncoding::Direct => Some(tag.value.size(self)),\n+                        TagEncoding::Direct => Some(tag.size(self)),\n                         _ => None,\n                     },\n                     variant_infos,\n@@ -2304,7 +2318,7 @@ where\n             let tag_layout = |tag: Scalar| -> TyAndLayout<'tcx> {\n                 TyAndLayout {\n                     layout: tcx.intern_layout(LayoutS::scalar(cx, tag)),\n-                    ty: tag.value.to_ty(tcx),\n+                    ty: tag.primitive().to_ty(tcx),\n                 }\n             };\n \n@@ -3079,11 +3093,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }\n \n             // Only pointer types handled below.\n-            if scalar.value != Pointer {\n-                return;\n-            }\n+            let Scalar::Initialized { value: Pointer, valid_range} = scalar else { return };\n \n-            if !scalar.valid_range.contains(0) {\n+            if !valid_range.contains(0) {\n                 attrs.set(ArgAttribute::NonNull);\n             }\n "}, {"sha": "cd54167aa7f82de2676554e2f38af0ae1f7c6d77", "filename": "compiler/rustc_target/src/abi/call/mips64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -6,7 +6,7 @@ use crate::abi::{self, HasDataLayout, Size, TyAbiInterface};\n fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n     // Always sign extend u32 values on 64-bit mips\n     if let abi::Abi::Scalar(scalar) = arg.layout.abi {\n-        if let abi::Int(i, signed) = scalar.value {\n+        if let abi::Int(i, signed) = scalar.primitive() {\n             if !signed && i.size().bits() == 32 {\n                 if let PassMode::Direct(ref mut attrs) = arg.mode {\n                     attrs.ext(ArgExtension::Sext);\n@@ -25,7 +25,7 @@ where\n     C: HasDataLayout,\n {\n     match ret.layout.field(cx, i).abi {\n-        abi::Abi::Scalar(scalar) => match scalar.value {\n+        abi::Abi::Scalar(scalar) => match scalar.primitive() {\n             abi::F32 => Some(Reg::f32()),\n             abi::F64 => Some(Reg::f64()),\n             _ => None,\n@@ -110,7 +110,7 @@ where\n \n                 // We only care about aligned doubles\n                 if let abi::Abi::Scalar(scalar) = field.abi {\n-                    if let abi::F64 = scalar.value {\n+                    if let abi::F64 = scalar.primitive() {\n                         if offset.is_aligned(dl.f64_align.abi) {\n                             // Insert enough integers to cover [last_offset, offset)\n                             assert!(last_offset.is_aligned(dl.f64_align.abi));"}, {"sha": "ce564d1455bfc05d3ee3016f2f5e4255cd2454d9", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -348,7 +348,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n \n             // The primitive for this algorithm.\n             Abi::Scalar(scalar) => {\n-                let kind = match scalar.value {\n+                let kind = match scalar.primitive() {\n                     abi::Int(..) | abi::Pointer => RegKind::Integer,\n                     abi::F32 | abi::F64 => RegKind::Float,\n                 };\n@@ -482,7 +482,7 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n             Abi::Scalar(scalar) => PassMode::Direct(scalar_attrs(&layout, scalar, Size::ZERO)),\n             Abi::ScalarPair(a, b) => PassMode::Pair(\n                 scalar_attrs(&layout, a, Size::ZERO),\n-                scalar_attrs(&layout, b, a.value.size(cx).align_to(b.value.align(cx).abi)),\n+                scalar_attrs(&layout, b, a.size(cx).align_to(b.align(cx).abi)),\n             ),\n             Abi::Vector { .. } => PassMode::Direct(ArgAttributes::new()),\n             Abi::Aggregate { .. } => PassMode::Direct(ArgAttributes::new()),\n@@ -534,7 +534,7 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n     pub fn extend_integer_width_to(&mut self, bits: u64) {\n         // Only integers have signedness\n         if let Abi::Scalar(scalar) = self.layout.abi {\n-            if let abi::Int(i, signed) = scalar.value {\n+            if let abi::Int(i, signed) = scalar.primitive() {\n                 if i.size().bits() < bits {\n                     if let PassMode::Direct(ref mut attrs) = self.mode {\n                         if signed {"}, {"sha": "752b44f6434cf86daa144acd9abbf0e6a24e26fb", "filename": "compiler/rustc_target/src/abi/call/riscv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -44,7 +44,7 @@ where\n     Ty: TyAbiInterface<'a, C> + Copy,\n {\n     match arg_layout.abi {\n-        Abi::Scalar(scalar) => match scalar.value {\n+        Abi::Scalar(scalar) => match scalar.primitive() {\n             abi::Int(..) | abi::Pointer => {\n                 if arg_layout.size.bits() > xlen {\n                     return Err(CannotUseFpConv);\n@@ -298,7 +298,7 @@ fn classify_arg<'a, Ty, C>(\n \n fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n     if let Abi::Scalar(scalar) = arg.layout.abi {\n-        if let abi::Int(i, _) = scalar.value {\n+        if let abi::Int(i, _) = scalar.primitive() {\n             // 32-bit integers are always sign-extended\n             if i.size().bits() == 32 && xlen > 32 {\n                 if let PassMode::Direct(ref mut attrs) = arg.mode {"}, {"sha": "5a92ebdd9e8431908b85654c920dc3fad25e150a", "filename": "compiler/rustc_target/src/abi/call/sparc64.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -20,7 +20,7 @@ where\n {\n     let dl = cx.data_layout();\n \n-    if scalar.value != abi::F32 && scalar.value != abi::F64 {\n+    if !scalar.primitive().is_float() {\n         return data;\n     }\n \n@@ -56,7 +56,7 @@ where\n         return data;\n     }\n \n-    if scalar.value == abi::F32 {\n+    if scalar.primitive() == abi::F32 {\n         data.arg_attribute = ArgAttribute::InReg;\n         data.prefix[data.prefix_index] = Some(Reg::f32());\n         data.last_offset = offset + Reg::f32().size;\n@@ -79,17 +79,15 @@ where\n     C: HasDataLayout,\n {\n     data = arg_scalar(cx, &scalar1, offset, data);\n-    if scalar1.value == abi::F32 {\n-        offset += Reg::f32().size;\n-    } else if scalar2.value == abi::F64 {\n-        offset += Reg::f64().size;\n-    } else if let abi::Int(i, _signed) = scalar1.value {\n-        offset += i.size();\n-    } else if scalar1.value == abi::Pointer {\n-        offset = offset + Reg::i64().size;\n+    match (scalar1.primitive(), scalar2.primitive()) {\n+        (abi::F32, _) => offset += Reg::f32().size,\n+        (_, abi::F64) => offset += Reg::f64().size,\n+        (abi::Int(i, _signed), _) => offset += i.size(),\n+        (abi::Pointer, _) => offset += Reg::i64().size,\n+        _ => {}\n     }\n \n-    if (offset.raw % 4) != 0 && (scalar2.value == abi::F32 || scalar2.value == abi::F64) {\n+    if (offset.raw % 4) != 0 && scalar2.primitive().is_float() {\n         offset.raw += 4 - (offset.raw % 4);\n     }\n     data = arg_scalar(cx, &scalar2, offset, data);"}, {"sha": "a52e01a495a57e0d76c1a33aad089fb901ddc6d7", "filename": "compiler/rustc_target/src/abi/call/x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -49,7 +49,7 @@ where\n         let mut c = match layout.abi {\n             Abi::Uninhabited => return Ok(()),\n \n-            Abi::Scalar(scalar) => match scalar.value {\n+            Abi::Scalar(scalar) => match scalar.primitive() {\n                 abi::Int(..) | abi::Pointer => Class::Int,\n                 abi::F32 | abi::F64 => Class::Sse,\n             },"}, {"sha": "c46726b767bf2290c5c70eff04e8c64e478d9227", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 80, "deletions": 20, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -752,6 +752,10 @@ pub struct WrappingRange {\n }\n \n impl WrappingRange {\n+    pub fn full(size: Size) -> Self {\n+        Self { start: 0, end: size.unsigned_int_max() }\n+    }\n+\n     /// Returns `true` if `v` is contained in the range.\n     #[inline(always)]\n     pub fn contains(&self, v: u128) -> bool {\n@@ -799,28 +803,82 @@ impl fmt::Debug for WrappingRange {\n /// Information about one scalar component of a Rust type.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n #[derive(HashStable_Generic)]\n-pub struct Scalar {\n-    pub value: Primitive,\n-\n-    // FIXME(eddyb) always use the shortest range, e.g., by finding\n-    // the largest space between two consecutive valid values and\n-    // taking everything else as the (shortest) valid range.\n-    pub valid_range: WrappingRange,\n+pub enum Scalar {\n+    Initialized {\n+        value: Primitive,\n+\n+        // FIXME(eddyb) always use the shortest range, e.g., by finding\n+        // the largest space between two consecutive valid values and\n+        // taking everything else as the (shortest) valid range.\n+        valid_range: WrappingRange,\n+    },\n+    Union {\n+        /// Even for unions, we need to use the correct registers for the kind of\n+        /// values inside the union, so we keep the `Primitive` type around. We\n+        /// also use it to compute the size of the scalar.\n+        /// However, unions never have niches and even allow undef,\n+        /// so there is no `valid_range`.\n+        value: Primitive,\n+    },\n }\n \n impl Scalar {\n     #[inline]\n     pub fn is_bool(&self) -> bool {\n         matches!(\n             self,\n-            Scalar { value: Int(I8, false), valid_range: WrappingRange { start: 0, end: 1 } }\n+            Scalar::Initialized {\n+                value: Int(I8, false),\n+                valid_range: WrappingRange { start: 0, end: 1 }\n+            }\n         )\n     }\n \n+    /// Get the primitive representation of this type, ignoring the valid range and whether the\n+    /// value is allowed to be undefined (due to being a union).\n+    pub fn primitive(&self) -> Primitive {\n+        match *self {\n+            Scalar::Initialized { value, .. } | Scalar::Union { value } => value,\n+        }\n+    }\n+\n+    pub fn align(self, cx: &impl HasDataLayout) -> AbiAndPrefAlign {\n+        self.primitive().align(cx)\n+    }\n+\n+    pub fn size(self, cx: &impl HasDataLayout) -> Size {\n+        self.primitive().size(cx)\n+    }\n+\n+    #[inline]\n+    pub fn to_union(&self) -> Self {\n+        Self::Union { value: self.primitive() }\n+    }\n+\n+    #[inline]\n+    pub fn valid_range(&self, cx: &impl HasDataLayout) -> WrappingRange {\n+        match *self {\n+            Scalar::Initialized { valid_range, .. } => valid_range,\n+            Scalar::Union { value } => WrappingRange::full(value.size(cx)),\n+        }\n+    }\n+\n+    #[inline]\n+    /// Allows the caller to mutate the valid range. This operation will panic if attempted on a union.\n+    pub fn valid_range_mut(&mut self) -> &mut WrappingRange {\n+        match self {\n+            Scalar::Initialized { valid_range, .. } => valid_range,\n+            Scalar::Union { .. } => panic!(\"cannot change the valid range of a union\"),\n+        }\n+    }\n+\n     /// Returns `true` if all possible numbers are valid, i.e `valid_range` covers the whole layout\n     #[inline]\n     pub fn is_always_valid<C: HasDataLayout>(&self, cx: &C) -> bool {\n-        self.valid_range.is_full_for(self.value.size(cx))\n+        match *self {\n+            Scalar::Initialized { valid_range, .. } => valid_range.is_full_for(self.size(cx)),\n+            Scalar::Union { .. } => true,\n+        }\n     }\n }\n \n@@ -988,7 +1046,7 @@ impl Abi {\n     #[inline]\n     pub fn is_signed(&self) -> bool {\n         match self {\n-            Abi::Scalar(scal) => match scal.value {\n+            Abi::Scalar(scal) => match scal.primitive() {\n                 Primitive::Int(_, signed) => signed,\n                 _ => false,\n             },\n@@ -1060,17 +1118,19 @@ pub enum TagEncoding {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct Niche {\n     pub offset: Size,\n-    pub scalar: Scalar,\n+    pub value: Primitive,\n+    pub valid_range: WrappingRange,\n }\n \n impl Niche {\n     pub fn from_scalar<C: HasDataLayout>(cx: &C, offset: Size, scalar: Scalar) -> Option<Self> {\n-        let niche = Niche { offset, scalar };\n+        let Scalar::Initialized { value, valid_range } = scalar else { return None };\n+        let niche = Niche { offset, value, valid_range };\n         if niche.available(cx) > 0 { Some(niche) } else { None }\n     }\n \n     pub fn available<C: HasDataLayout>(&self, cx: &C) -> u128 {\n-        let Scalar { value, valid_range: v } = self.scalar;\n+        let Self { value, valid_range: v, .. } = *self;\n         let size = value.size(cx);\n         assert!(size.bits() <= 128);\n         let max_value = size.unsigned_int_max();\n@@ -1083,7 +1143,7 @@ impl Niche {\n     pub fn reserve<C: HasDataLayout>(&self, cx: &C, count: u128) -> Option<(u128, Scalar)> {\n         assert!(count > 0);\n \n-        let Scalar { value, valid_range: v } = self.scalar;\n+        let Self { value, valid_range: v, .. } = *self;\n         let size = value.size(cx);\n         assert!(size.bits() <= 128);\n         let max_value = size.unsigned_int_max();\n@@ -1107,12 +1167,12 @@ impl Niche {\n         // If niche zero is already reserved, the selection of bounds are of little interest.\n         let move_start = |v: WrappingRange| {\n             let start = v.start.wrapping_sub(count) & max_value;\n-            Some((start, Scalar { value, valid_range: v.with_start(start) }))\n+            Some((start, Scalar::Initialized { value, valid_range: v.with_start(start) }))\n         };\n         let move_end = |v: WrappingRange| {\n             let start = v.end.wrapping_add(1) & max_value;\n             let end = v.end.wrapping_add(count) & max_value;\n-            Some((start, Scalar { value, valid_range: v.with_end(end) }))\n+            Some((start, Scalar::Initialized { value, valid_range: v.with_end(end) }))\n         };\n         let distance_end_zero = max_value - v.end;\n         if v.start > v.end {\n@@ -1172,8 +1232,8 @@ pub struct LayoutS<'a> {\n impl<'a> LayoutS<'a> {\n     pub fn scalar<C: HasDataLayout>(cx: &C, scalar: Scalar) -> Self {\n         let largest_niche = Niche::from_scalar(cx, Size::ZERO, scalar);\n-        let size = scalar.value.size(cx);\n-        let align = scalar.value.align(cx);\n+        let size = scalar.size(cx);\n+        let align = scalar.align(cx);\n         LayoutS {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldsShape::Primitive,\n@@ -1325,7 +1385,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n         C: HasDataLayout,\n     {\n         match self.abi {\n-            Abi::Scalar(scalar) => scalar.value.is_float(),\n+            Abi::Scalar(scalar) => scalar.primitive().is_float(),\n             Abi::Aggregate { .. } => {\n                 if self.fields.count() == 1 && self.fields.offset(0).bytes() == 0 {\n                     self.field(cx, 0).is_single_fp_element(cx)\n@@ -1371,7 +1431,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n         let scalar_allows_raw_init = move |s: Scalar| -> bool {\n             if zero {\n                 // The range must contain 0.\n-                s.valid_range.contains(0)\n+                s.valid_range(cx).contains(0)\n             } else {\n                 // The range must include all values.\n                 s.is_always_valid(cx)"}, {"sha": "99d7475da33966daae1326fe155ae97ce18323b8", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -1769,7 +1769,7 @@ fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n \n                     let tag_size = if let TagEncoding::Niche { .. } = tag_encoding {\n                         0\n-                    } else if let Primitive::Int(i, _) = tag.value {\n+                    } else if let Primitive::Int(i, _) = tag.primitive() {\n                         i.size().bytes()\n                     } else {\n                         span_bug!(tcx.def_span(ty_def_id), \"tag is neither niche nor int\")"}, {"sha": "25f7febfef9dfee610bc1f37f82054f31a81b551", "filename": "src/test/ui/layout/debug.stderr", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -10,7 +10,7 @@ error: layout_of(E) = Layout {\n                ],\n            },\n            variants: Multiple {\n-               tag: Scalar {\n+               tag: Initialized {\n                    value: Int(\n                        I32,\n                        false,\n@@ -86,13 +86,11 @@ error: layout_of(E) = Layout {\n                    offset: Size {\n                        raw: 0,\n                    },\n-                   scalar: Scalar {\n-                       value: Int(\n-                           I32,\n-                           false,\n-                       ),\n-                       valid_range: 0..=0,\n-                   },\n+                   value: Int(\n+                       I32,\n+                       false,\n+                   ),\n+                   valid_range: 0..=0,\n                },\n            ),\n            align: AbiAndPrefAlign {\n@@ -133,14 +131,14 @@ error: layout_of(S) = Layout {\n                index: 0,\n            },\n            abi: ScalarPair(\n-               Scalar {\n+               Initialized {\n                    value: Int(\n                        I32,\n                        true,\n                    ),\n                    valid_range: 0..=4294967295,\n                },\n-               Scalar {\n+               Initialized {\n                    value: Int(\n                        I32,\n                        true,\n@@ -202,7 +200,7 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                ],\n            },\n            variants: Multiple {\n-               tag: Scalar {\n+               tag: Initialized {\n                    value: Int(\n                        I32,\n                        false,\n@@ -271,14 +269,14 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                ],\n            },\n            abi: ScalarPair(\n-               Scalar {\n+               Initialized {\n                    value: Int(\n                        I32,\n                        false,\n                    ),\n                    valid_range: 0..=1,\n                },\n-               Scalar {\n+               Initialized {\n                    value: Int(\n                        I32,\n                        true,\n@@ -291,13 +289,11 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                    offset: Size {\n                        raw: 0,\n                    },\n-                   scalar: Scalar {\n-                       value: Int(\n-                           I32,\n-                           false,\n-                       ),\n-                       valid_range: 0..=1,\n-                   },\n+                   value: Int(\n+                       I32,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n                },\n            ),\n            align: AbiAndPrefAlign {\n@@ -321,7 +317,7 @@ error: layout_of(i32) = Layout {\n                index: 0,\n            },\n            abi: Scalar(\n-               Scalar {\n+               Initialized {\n                    value: Int(\n                        I32,\n                        true,"}, {"sha": "4db8162b16bb249e0b3201912f432206671ce875", "filename": "src/test/ui/layout/hexagon-enum.stderr", "status": "modified", "additions": 35, "deletions": 45, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/src%2Ftest%2Fui%2Flayout%2Fhexagon-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/src%2Ftest%2Fui%2Flayout%2Fhexagon-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhexagon-enum.stderr?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -10,7 +10,7 @@ error: layout_of(A) = Layout {\n                ],\n            },\n            variants: Multiple {\n-               tag: Scalar {\n+               tag: Initialized {\n                    value: Int(\n                        I8,\n                        false,\n@@ -47,7 +47,7 @@ error: layout_of(A) = Layout {\n                ],\n            },\n            abi: Scalar(\n-               Scalar {\n+               Initialized {\n                    value: Int(\n                        I8,\n                        false,\n@@ -60,13 +60,11 @@ error: layout_of(A) = Layout {\n                    offset: Size {\n                        raw: 0,\n                    },\n-                   scalar: Scalar {\n-                       value: Int(\n-                           I8,\n-                           false,\n-                       ),\n-                       valid_range: 0..=0,\n-                   },\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=0,\n                },\n            ),\n            align: AbiAndPrefAlign {\n@@ -98,7 +96,7 @@ error: layout_of(B) = Layout {\n                ],\n            },\n            variants: Multiple {\n-               tag: Scalar {\n+               tag: Initialized {\n                    value: Int(\n                        I8,\n                        false,\n@@ -135,7 +133,7 @@ error: layout_of(B) = Layout {\n                ],\n            },\n            abi: Scalar(\n-               Scalar {\n+               Initialized {\n                    value: Int(\n                        I8,\n                        false,\n@@ -148,13 +146,11 @@ error: layout_of(B) = Layout {\n                    offset: Size {\n                        raw: 0,\n                    },\n-                   scalar: Scalar {\n-                       value: Int(\n-                           I8,\n-                           false,\n-                       ),\n-                       valid_range: 255..=255,\n-                   },\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 255..=255,\n                },\n            ),\n            align: AbiAndPrefAlign {\n@@ -186,7 +182,7 @@ error: layout_of(C) = Layout {\n                ],\n            },\n            variants: Multiple {\n-               tag: Scalar {\n+               tag: Initialized {\n                    value: Int(\n                        I16,\n                        false,\n@@ -223,7 +219,7 @@ error: layout_of(C) = Layout {\n                ],\n            },\n            abi: Scalar(\n-               Scalar {\n+               Initialized {\n                    value: Int(\n                        I16,\n                        false,\n@@ -236,13 +232,11 @@ error: layout_of(C) = Layout {\n                    offset: Size {\n                        raw: 0,\n                    },\n-                   scalar: Scalar {\n-                       value: Int(\n-                           I16,\n-                           false,\n-                       ),\n-                       valid_range: 256..=256,\n-                   },\n+                   value: Int(\n+                       I16,\n+                       false,\n+                   ),\n+                   valid_range: 256..=256,\n                },\n            ),\n            align: AbiAndPrefAlign {\n@@ -274,7 +268,7 @@ error: layout_of(P) = Layout {\n                ],\n            },\n            variants: Multiple {\n-               tag: Scalar {\n+               tag: Initialized {\n                    value: Int(\n                        I32,\n                        false,\n@@ -311,7 +305,7 @@ error: layout_of(P) = Layout {\n                ],\n            },\n            abi: Scalar(\n-               Scalar {\n+               Initialized {\n                    value: Int(\n                        I32,\n                        false,\n@@ -324,13 +318,11 @@ error: layout_of(P) = Layout {\n                    offset: Size {\n                        raw: 0,\n                    },\n-                   scalar: Scalar {\n-                       value: Int(\n-                           I32,\n-                           false,\n-                       ),\n-                       valid_range: 268435456..=268435456,\n-                   },\n+                   value: Int(\n+                       I32,\n+                       false,\n+                   ),\n+                   valid_range: 268435456..=268435456,\n                },\n            ),\n            align: AbiAndPrefAlign {\n@@ -362,7 +354,7 @@ error: layout_of(T) = Layout {\n                ],\n            },\n            variants: Multiple {\n-               tag: Scalar {\n+               tag: Initialized {\n                    value: Int(\n                        I32,\n                        true,\n@@ -399,7 +391,7 @@ error: layout_of(T) = Layout {\n                ],\n            },\n            abi: Scalar(\n-               Scalar {\n+               Initialized {\n                    value: Int(\n                        I32,\n                        true,\n@@ -412,13 +404,11 @@ error: layout_of(T) = Layout {\n                    offset: Size {\n                        raw: 0,\n                    },\n-                   scalar: Scalar {\n-                       value: Int(\n-                           I32,\n-                           true,\n-                       ),\n-                       valid_range: 2164260864..=2164260864,\n-                   },\n+                   value: Int(\n+                       I32,\n+                       true,\n+                   ),\n+                   valid_range: 2164260864..=2164260864,\n                },\n            ),\n            align: AbiAndPrefAlign {"}, {"sha": "9d1f234f31ad5b68ed43ec5b381822f92967d007", "filename": "src/test/ui/layout/thumb-enum.stderr", "status": "modified", "additions": 35, "deletions": 45, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/src%2Ftest%2Fui%2Flayout%2Fthumb-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d32ce37a171663048a4c4a536803434e40f52bd6/src%2Ftest%2Fui%2Flayout%2Fthumb-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fthumb-enum.stderr?ref=d32ce37a171663048a4c4a536803434e40f52bd6", "patch": "@@ -10,7 +10,7 @@ error: layout_of(A) = Layout {\n                ],\n            },\n            variants: Multiple {\n-               tag: Scalar {\n+               tag: Initialized {\n                    value: Int(\n                        I8,\n                        false,\n@@ -47,7 +47,7 @@ error: layout_of(A) = Layout {\n                ],\n            },\n            abi: Scalar(\n-               Scalar {\n+               Initialized {\n                    value: Int(\n                        I8,\n                        false,\n@@ -60,13 +60,11 @@ error: layout_of(A) = Layout {\n                    offset: Size {\n                        raw: 0,\n                    },\n-                   scalar: Scalar {\n-                       value: Int(\n-                           I8,\n-                           false,\n-                       ),\n-                       valid_range: 0..=0,\n-                   },\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=0,\n                },\n            ),\n            align: AbiAndPrefAlign {\n@@ -98,7 +96,7 @@ error: layout_of(B) = Layout {\n                ],\n            },\n            variants: Multiple {\n-               tag: Scalar {\n+               tag: Initialized {\n                    value: Int(\n                        I8,\n                        false,\n@@ -135,7 +133,7 @@ error: layout_of(B) = Layout {\n                ],\n            },\n            abi: Scalar(\n-               Scalar {\n+               Initialized {\n                    value: Int(\n                        I8,\n                        false,\n@@ -148,13 +146,11 @@ error: layout_of(B) = Layout {\n                    offset: Size {\n                        raw: 0,\n                    },\n-                   scalar: Scalar {\n-                       value: Int(\n-                           I8,\n-                           false,\n-                       ),\n-                       valid_range: 255..=255,\n-                   },\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 255..=255,\n                },\n            ),\n            align: AbiAndPrefAlign {\n@@ -186,7 +182,7 @@ error: layout_of(C) = Layout {\n                ],\n            },\n            variants: Multiple {\n-               tag: Scalar {\n+               tag: Initialized {\n                    value: Int(\n                        I16,\n                        false,\n@@ -223,7 +219,7 @@ error: layout_of(C) = Layout {\n                ],\n            },\n            abi: Scalar(\n-               Scalar {\n+               Initialized {\n                    value: Int(\n                        I16,\n                        false,\n@@ -236,13 +232,11 @@ error: layout_of(C) = Layout {\n                    offset: Size {\n                        raw: 0,\n                    },\n-                   scalar: Scalar {\n-                       value: Int(\n-                           I16,\n-                           false,\n-                       ),\n-                       valid_range: 256..=256,\n-                   },\n+                   value: Int(\n+                       I16,\n+                       false,\n+                   ),\n+                   valid_range: 256..=256,\n                },\n            ),\n            align: AbiAndPrefAlign {\n@@ -274,7 +268,7 @@ error: layout_of(P) = Layout {\n                ],\n            },\n            variants: Multiple {\n-               tag: Scalar {\n+               tag: Initialized {\n                    value: Int(\n                        I32,\n                        false,\n@@ -311,7 +305,7 @@ error: layout_of(P) = Layout {\n                ],\n            },\n            abi: Scalar(\n-               Scalar {\n+               Initialized {\n                    value: Int(\n                        I32,\n                        false,\n@@ -324,13 +318,11 @@ error: layout_of(P) = Layout {\n                    offset: Size {\n                        raw: 0,\n                    },\n-                   scalar: Scalar {\n-                       value: Int(\n-                           I32,\n-                           false,\n-                       ),\n-                       valid_range: 268435456..=268435456,\n-                   },\n+                   value: Int(\n+                       I32,\n+                       false,\n+                   ),\n+                   valid_range: 268435456..=268435456,\n                },\n            ),\n            align: AbiAndPrefAlign {\n@@ -362,7 +354,7 @@ error: layout_of(T) = Layout {\n                ],\n            },\n            variants: Multiple {\n-               tag: Scalar {\n+               tag: Initialized {\n                    value: Int(\n                        I32,\n                        true,\n@@ -399,7 +391,7 @@ error: layout_of(T) = Layout {\n                ],\n            },\n            abi: Scalar(\n-               Scalar {\n+               Initialized {\n                    value: Int(\n                        I32,\n                        true,\n@@ -412,13 +404,11 @@ error: layout_of(T) = Layout {\n                    offset: Size {\n                        raw: 0,\n                    },\n-                   scalar: Scalar {\n-                       value: Int(\n-                           I32,\n-                           true,\n-                       ),\n-                       valid_range: 2164260864..=2164260864,\n-                   },\n+                   value: Int(\n+                       I32,\n+                       true,\n+                   ),\n+                   valid_range: 2164260864..=2164260864,\n                },\n            ),\n            align: AbiAndPrefAlign {"}]}