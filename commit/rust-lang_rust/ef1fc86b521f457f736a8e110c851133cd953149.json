{"sha": "ef1fc86b521f457f736a8e110c851133cd953149", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMWZjODZiNTIxZjQ1N2Y3MzZhOGUxMTBjODUxMTMzY2Q5NTMxNDk=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-05-25T15:26:57Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-06-13T20:05:21Z"}, "message": "Call str::eq and <[T]>::eq for match comparisons\n\nWe used to call the less efficient `<&str>::eq` and `<&[T]>::eq`.", "tree": {"sha": "ae2cadbdda96b33e813c66c98e1989c1c767c873", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae2cadbdda96b33e813c66c98e1989c1c767c873"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef1fc86b521f457f736a8e110c851133cd953149", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef1fc86b521f457f736a8e110c851133cd953149", "html_url": "https://github.com/rust-lang/rust/commit/ef1fc86b521f457f736a8e110c851133cd953149", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef1fc86b521f457f736a8e110c851133cd953149/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "html_url": "https://github.com/rust-lang/rust/commit/da22793a35b725e2fe2f7e2ac1d808404c39c4aa"}], "stats": {"total": 70, "additions": 23, "deletions": 47}, "files": [{"sha": "47f0aa82a417a9fc8a7cd87f693db33a4679b0d3", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 21, "deletions": 45, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ef1fc86b521f457f736a8e110c851133cd953149/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1fc86b521f457f736a8e110c851133cd953149/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=ef1fc86b521f457f736a8e110c851133cd953149", "patch": "@@ -15,7 +15,9 @@ use rustc::ty::{self, Ty, adjustment::{PointerCast}};\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::layout::VariantIdx;\n use rustc::mir::*;\n-use rustc::hir::{RangeEnd, Mutability};\n+use rustc::hir::RangeEnd;\n+use syntax_pos::symbol::sym;\n+\n use std::cmp::Ordering;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -252,10 +254,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             TestKind::Eq { value, ty } => {\n-                // Use `PartialEq::eq` instead of `BinOp::Eq`\n-                // (the binop can only handle primitives)\n                 if let [success, fail] = *target_blocks {\n                     if !ty.is_scalar() {\n+                        // Use `PartialEq::eq` instead of `BinOp::Eq`\n+                        // (the binop can only handle primitives)\n                         self.non_scalar_compare(\n                             block,\n                             success,\n@@ -368,7 +370,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         );\n     }\n \n-    /// Compare using `std::compare::PartialEq::eq`\n+    /// Compare two `&T` values using `<T as std::compare::PartialEq>::eq`\n     fn non_scalar_compare(\n         &mut self,\n         block: BasicBlock,\n@@ -381,8 +383,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     ) {\n         use rustc::middle::lang_items::EqTraitLangItem;\n \n-        let mut expect = self.literal_operand(source_info.span, ty, value);\n-        let val = Operand::Copy(place.clone());\n+        let mut expect = self.literal_operand(source_info.span, value.ty, value);\n+        let mut val = Operand::Copy(place.clone());\n \n         // If we're using `b\"...\"` as a pattern, we need to insert an\n         // unsizing coercion, as the byte string has the type `&[u8; N]`.\n@@ -399,7 +401,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n         let opt_ref_ty = unsize(ty);\n         let opt_ref_test_ty = unsize(value.ty);\n-        let mut place = place.clone();\n         match (opt_ref_ty, opt_ref_test_ty) {\n             // nothing to do, neither is an array\n             (None, None) => {},\n@@ -409,56 +410,33 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // make both a slice\n                 ty = tcx.mk_imm_ref(region, tcx.mk_slice(elem_ty));\n                 if opt_ref_ty.is_some() {\n-                    place = self.temp(ty, source_info.span);\n+                    let temp = self.temp(ty, source_info.span);\n                     self.cfg.push_assign(\n-                        block, source_info, &place, Rvalue::Cast(\n+                        block, source_info, &temp, Rvalue::Cast(\n                             CastKind::Pointer(PointerCast::Unsize), val, ty\n                         )\n                     );\n+                    val = Operand::Move(temp);\n                 }\n                 if opt_ref_test_ty.is_some() {\n-                    let array = self.literal_operand(\n-                        source_info.span,\n-                        value.ty,\n-                        value,\n-                    );\n-\n                     let slice = self.temp(ty, source_info.span);\n                     self.cfg.push_assign(\n                         block, source_info, &slice, Rvalue::Cast(\n-                            CastKind::Pointer(PointerCast::Unsize), array, ty\n+                            CastKind::Pointer(PointerCast::Unsize), expect, ty\n                         )\n                     );\n                     expect = Operand::Move(slice);\n                 }\n             },\n         }\n-        let eq_def_id = self.hir.tcx().require_lang_item(EqTraitLangItem);\n-        let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, &[ty.into()]);\n \n-        let re_erased = self.hir.tcx().lifetimes.re_erased;\n-        // take the argument by reference\n-        let tam = ty::TypeAndMut {\n-            ty,\n-            mutbl: Mutability::MutImmutable,\n+        let deref_ty = match ty.sty {\n+            ty::Ref(_, deref_ty, _) => deref_ty,\n+            _ => bug!(\"non_scalar_compare called on non-reference type: {}\", ty),\n         };\n-        let ref_ty = self.hir.tcx().mk_ref(re_erased, tam);\n-\n-        // let lhs_ref_place = &lhs;\n-        let ref_rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, place);\n-        let lhs_ref_place = self.temp(ref_ty, source_info.span);\n-        self.cfg.push_assign(block, source_info, &lhs_ref_place, ref_rvalue);\n-        let val = Operand::Move(lhs_ref_place);\n \n-        // let rhs_place = rhs;\n-        let rhs_place = self.temp(ty, source_info.span);\n-        self.cfg.push_assign(block, source_info, &rhs_place, Rvalue::Use(expect));\n-\n-        // let rhs_ref_place = &rhs_place;\n-        let ref_rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, rhs_place);\n-        let rhs_ref_place = self.temp(ref_ty, source_info.span);\n-        self.cfg.push_assign(block, source_info, &rhs_ref_place, ref_rvalue);\n-        let expect = Operand::Move(rhs_ref_place);\n+        let eq_def_id = self.hir.tcx().require_lang_item(EqTraitLangItem);\n+        let (mty, method) = self.hir.trait_method(eq_def_id, sym::eq, deref_ty, &[deref_ty.into()]);\n \n         let bool_ty = self.hir.bool_ty();\n         let eq_result = self.temp(bool_ty, source_info.span);\n@@ -469,12 +447,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 span: source_info.span,\n                 ty: mty,\n \n-                // FIXME(#54571): This constant comes from user\n-                // input (a constant in a pattern).  Are\n-                // there forms where users can add type\n-                // annotations here?  For example, an\n-                // associated constant? Need to\n-                // experiment.\n+                // FIXME(#54571): This constant comes from user input (a\n+                // constant in a pattern).  Are there forms where users can add\n+                // type annotations here?  For example, an associated constant?\n+                // Need to experiment.\n                 user_ty: None,\n \n                 literal: method,"}, {"sha": "92df82984412fa54eaa7a1bb0725833fc7c97a36", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef1fc86b521f457f736a8e110c851133cd953149/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1fc86b521f457f736a8e110c851133cd953149/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=ef1fc86b521f457f736a8e110c851133cd953149", "patch": "@@ -168,11 +168,10 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n     pub fn trait_method(&mut self,\n                         trait_def_id: DefId,\n-                        method_name: &str,\n+                        method_name: Symbol,\n                         self_ty: Ty<'tcx>,\n                         params: &[Kind<'tcx>])\n                         -> (Ty<'tcx>, &'tcx ty::Const<'tcx>) {\n-        let method_name = Symbol::intern(method_name);\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n             if item.kind == ty::AssocKind::Method && item.ident.name == method_name {"}, {"sha": "0d0233cc2e986adacde2dacadf7e2e0b446cf5fe", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef1fc86b521f457f736a8e110c851133cd953149/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1fc86b521f457f736a8e110c851133cd953149/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=ef1fc86b521f457f736a8e110c851133cd953149", "patch": "@@ -247,6 +247,7 @@ symbols! {\n         eh_personality,\n         eh_unwind_resume,\n         enable,\n+        eq,\n         err,\n         Err,\n         Equal,"}]}