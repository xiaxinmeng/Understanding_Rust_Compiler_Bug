{"sha": "2ea61204f6bae64955f57dda7d3768bc9ba2dd55", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYTYxMjA0ZjZiYWU2NDk1NWY1N2RkYTdkMzc2OGJjOWJhMmRkNTU=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-15T22:24:16Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-18T20:56:14Z"}, "message": "Get rid of resolve::MethodInfo. Closes #4946.", "tree": {"sha": "e69c241070431de8815c086c70c92b071c1be08a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e69c241070431de8815c086c70c92b071c1be08a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ea61204f6bae64955f57dda7d3768bc9ba2dd55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ea61204f6bae64955f57dda7d3768bc9ba2dd55", "html_url": "https://github.com/rust-lang/rust/commit/2ea61204f6bae64955f57dda7d3768bc9ba2dd55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0a69b1a43f5785a533566b892411bc041f887f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0a69b1a43f5785a533566b892411bc041f887f6", "html_url": "https://github.com/rust-lang/rust/commit/f0a69b1a43f5785a533566b892411bc041f887f6"}], "stats": {"total": 128, "additions": 44, "deletions": 84}, "files": [{"sha": "993649492a4630ff3896d6de132ef95902d1ce4d", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=2ea61204f6bae64955f57dda7d3768bc9ba2dd55", "patch": "@@ -15,7 +15,7 @@ use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata;\n-use middle::{ty, resolve};\n+use middle::ty;\n \n use std::vec;\n use reader = extra::ebml::reader;\n@@ -97,10 +97,10 @@ pub fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n }\n \n /// Returns information about the given implementation.\n-pub fn get_impl(cstore: @mut cstore::CStore, impl_def_id: ast::def_id)\n-                -> resolve::Impl {\n-    let cdata = cstore::get_crate_data(cstore, impl_def_id.crate);\n-    decoder::get_impl(cstore.intr, cdata, impl_def_id.node)\n+pub fn get_impl(tcx: ty::ctxt, impl_def_id: ast::def_id)\n+                -> ty::Impl {\n+    let cdata = cstore::get_crate_data(tcx.cstore, impl_def_id.crate);\n+    decoder::get_impl(tcx.cstore.intr, cdata, impl_def_id.node, tcx)\n }\n \n pub fn get_method(tcx: ty::ctxt, def: ast::def_id) -> ty::Method {"}, {"sha": "7d515fe62b5276e08396cd8bd613c56d9bab4bf2", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2ea61204f6bae64955f57dda7d3768bc9ba2dd55", "patch": "@@ -20,7 +20,7 @@ use metadata::decoder;\n use metadata::tydecode::{parse_ty_data, parse_def_id,\n                          parse_type_param_def_data,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n-use middle::{ty, resolve};\n+use middle::ty;\n \n use std::hash::HashUtil;\n use std::int;\n@@ -795,34 +795,29 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n }\n \n fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n-                     base_tps: uint) -> ~[@resolve::MethodInfo] {\n+                     tcx: ty::ctxt) -> ~[@ty::Method] {\n     let mut rslt = ~[];\n     for reader::tagged_docs(item, tag_item_impl_method) |doc| {\n         let m_did = reader::with_doc_data(doc, parse_def_id);\n-        let mth_item = lookup_item(m_did.node, cdata.data);\n-        let explicit_self = get_explicit_self(mth_item);\n-        rslt.push(@resolve::MethodInfo {\n-                    did: translate_def_id(cdata, m_did),\n-                    n_tps: item_ty_param_count(mth_item) - base_tps,\n-                    ident: item_name(intr, mth_item),\n-                    explicit_self: explicit_self});\n+        rslt.push(@get_method(intr, cdata, m_did.node, tcx));\n     }\n+\n     rslt\n }\n \n /// Returns information about the given implementation.\n-pub fn get_impl(intr: @ident_interner, cdata: cmd, impl_id: ast::node_id)\n-                -> resolve::Impl {\n+pub fn get_impl(intr: @ident_interner, cdata: cmd, impl_id: ast::node_id,\n+               tcx: ty::ctxt)\n+                -> ty::Impl {\n     let data = cdata.data;\n     let impl_item = lookup_item(impl_id, data);\n-    let base_tps = item_ty_param_count(impl_item);\n-    resolve::Impl {\n+    ty::Impl {\n         did: ast::def_id {\n             crate: cdata.cnum,\n             node: impl_id,\n         },\n         ident: item_name(intr, impl_item),\n-        methods: item_impl_methods(intr, cdata, impl_item, base_tps),\n+        methods: item_impl_methods(intr, cdata, impl_item, tcx),\n     }\n }\n "}, {"sha": "722f8ff9580230394c2c24860d9fd42422788904", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2ea61204f6bae64955f57dda7d3768bc9ba2dd55", "patch": "@@ -402,7 +402,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                 for base_impl.methods.iter().advance |&m| {\n                     if m.explicit_self == ast::sty_static {\n                         encode_reexported_static_method(ecx, ebml_w, exp,\n-                                                        m.did, m.ident);\n+                                                        m.def_id, m.ident);\n                     }\n                 }\n             }"}, {"sha": "6d457b46d4f3d762471ad84eb4dea423b0a4b502", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=2ea61204f6bae64955f57dda7d3768bc9ba2dd55", "patch": "@@ -55,24 +55,6 @@ pub struct binding_info {\n // Map from the name in a pattern to its binding mode.\n pub type BindingMap = HashMap<ident,binding_info>;\n \n-// Implementation resolution\n-//\n-// FIXME #4946: This kind of duplicates information kept in\n-// ty::method. Maybe it should go away.\n-\n-pub struct MethodInfo {\n-    did: def_id,\n-    n_tps: uint,\n-    ident: ident,\n-    explicit_self: explicit_self_\n-}\n-\n-pub struct Impl {\n-    did: def_id,\n-    ident: ident,\n-    methods: ~[@MethodInfo]\n-}\n-\n // Trait method resolution\n pub type TraitMap = HashMap<node_id,@mut ~[def_id]>;\n "}, {"sha": "03dbe0869fbc855e3659af035be44dc5923eeb13", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=2ea61204f6bae64955f57dda7d3768bc9ba2dd55", "patch": "@@ -344,8 +344,8 @@ pub fn method_with_name(ccx: &mut CrateContext,\n     let meth = imp.methods.iter().find_(|m| m.ident == name)\n         .expect(\"could not find method while translating\");\n \n-    ccx.impl_method_cache.insert((impl_id, name), meth.did);\n-    meth.did\n+    ccx.impl_method_cache.insert((impl_id, name), meth.def_id);\n+    meth.def_id\n }\n \n pub fn trans_monomorphized_callee(bcx: block,"}, {"sha": "6f3c3d9037ead2573ce894641f28f758eae0b595", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2ea61204f6bae64955f57dda7d3768bc9ba2dd55", "patch": "@@ -16,7 +16,6 @@ use middle::const_eval;\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n use middle::lang_items::OpaqueStructLangItem;\n use middle::freevars;\n-use middle::resolve::{Impl, MethodInfo};\n use middle::resolve;\n use middle::ty;\n use middle::subst::Subst;\n@@ -96,6 +95,12 @@ impl Method {\n     }\n }\n \n+pub struct Impl {\n+    did: def_id,\n+    ident: ident,\n+    methods: ~[@Method]\n+}\n+\n #[deriving(Clone, Eq, IterBytes)]\n pub struct mt {\n     ty: t,"}, {"sha": "4a32e8bf952c1d70b0530e7bbfc154f176ba24ae", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=2ea61204f6bae64955f57dda7d3768bc9ba2dd55", "patch": "@@ -527,7 +527,7 @@ impl<'self> LookupContext<'self> {\n \n     pub fn push_candidates_from_impl(&self,\n                                      candidates: &mut ~[Candidate],\n-                                     impl_info: &resolve::Impl) {\n+                                     impl_info: &ty::Impl) {\n         if !self.impl_dups.insert(impl_info.did) {\n             return; // already visited\n         }\n@@ -543,7 +543,7 @@ impl<'self> LookupContext<'self> {\n             }\n         };\n \n-        let method = ty::method(self.tcx(), impl_info.methods[idx].did);\n+        let method = ty::method(self.tcx(), impl_info.methods[idx].def_id);\n \n         // determine the `self` of the impl with fresh\n         // variables for each parameter:"}, {"sha": "2bdb2f2932affd2fbca4b721f14de1d4ca5635cf", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 19, "deletions": 41, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea61204f6bae64955f57dda7d3768bc9ba2dd55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=2ea61204f6bae64955f57dda7d3768bc9ba2dd55", "patch": "@@ -17,9 +17,8 @@\n \n use metadata::csearch::{each_path, get_impl_trait};\n use metadata::csearch;\n-use metadata::cstore::{CStore, iter_crate_data};\n+use metadata::cstore::iter_crate_data;\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n-use middle::resolve::{Impl, MethodInfo};\n use middle::ty::{ProvidedMethodSource, get};\n use middle::ty::{lookup_item_type, subst};\n use middle::ty::{substs, t, ty_bool, ty_bot, ty_box, ty_enum, ty_err};\n@@ -31,14 +30,15 @@ use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec};\n use middle::ty::{type_is_ty_var};\n use middle::subst::Subst;\n use middle::ty;\n+use middle::ty::{Impl, Method};\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n use middle::typeck::infer;\n use syntax::ast::{crate, def_id, def_struct, def_ty};\n use syntax::ast::{item, item_enum, item_impl, item_mod, item_struct};\n-use syntax::ast::{local_crate, method, trait_ref, ty_path};\n+use syntax::ast::{local_crate, trait_ref, ty_path};\n use syntax::ast;\n use syntax::ast_map::node_item;\n use syntax::ast_map;\n@@ -149,16 +149,6 @@ pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n     }\n }\n \n-\n-pub fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n-    @MethodInfo {\n-        did: local_def(ast_method.id),\n-        n_tps: ast_method.generics.ty_params.len(),\n-        ident: ast_method.ident,\n-        explicit_self: ast_method.explicit_self.node\n-    }\n-}\n-\n pub fn CoherenceChecker(crate_context: @mut CrateCtxt) -> CoherenceChecker {\n     CoherenceChecker {\n         crate_context: crate_context,\n@@ -291,7 +281,7 @@ impl CoherenceChecker {\n     pub fn instantiate_default_methods(&self,\n                                        impl_id: ast::def_id,\n                                        trait_ref: &ty::TraitRef,\n-                                       all_methods: &mut ~[@MethodInfo]) {\n+                                       all_methods: &mut ~[@Method]) {\n         let tcx = self.crate_context.tcx;\n         debug!(\"instantiate_default_methods(impl_id=%?, trait_ref=%s)\",\n                impl_id, trait_ref.repr(tcx));\n@@ -316,6 +306,7 @@ impl CoherenceChecker {\n                     *trait_method);\n \n             debug!(\"new_method_ty=%s\", new_method_ty.repr(tcx));\n+            all_methods.push(new_method_ty);\n \n             // construct the polytype for the method based on the method_ty\n             let new_generics = ty::Generics {\n@@ -344,14 +335,6 @@ impl CoherenceChecker {\n \n             self.crate_context.tcx.provided_method_sources.insert(new_did,\n                                                                   source);\n-\n-            let method_info = @MethodInfo {\n-                did: new_did,\n-                n_tps: trait_method.generics.type_param_defs.len(),\n-                ident: trait_method.ident,\n-                explicit_self: trait_method.explicit_self\n-            };\n-            all_methods.push(method_info);\n         }\n     }\n \n@@ -563,7 +546,7 @@ impl CoherenceChecker {\n     // here for historical reasons\n     pub fn check_trait_methods_are_implemented(\n         &self,\n-        all_methods: &mut ~[@MethodInfo],\n+        all_methods: &mut ~[@Method],\n         trait_did: def_id,\n         trait_ref_span: span) {\n \n@@ -628,11 +611,12 @@ impl CoherenceChecker {\n \n     // Converts an implementation in the AST to an Impl structure.\n     pub fn create_impl_from_item(&self, item: @item) -> @Impl {\n+        let tcx = self.crate_context.tcx;\n         match item.node {\n             item_impl(_, ref trait_refs, _, ref ast_methods) => {\n                 let mut methods = ~[];\n                 for ast_methods.iter().advance |ast_method| {\n-                    methods.push(method_to_MethodInfo(*ast_method));\n+                    methods.push(ty::method(tcx, local_def(ast_method.id)));\n                 }\n \n                 for trait_refs.iter().advance |trait_ref| {\n@@ -682,12 +666,12 @@ impl CoherenceChecker {\n \n     pub fn add_external_impl(&self,\n                              impls_seen: &mut HashSet<def_id>,\n-                             crate_store: @mut CStore,\n                              impl_def_id: def_id) {\n-        let implementation = csearch::get_impl(crate_store, impl_def_id);\n+        let tcx = self.crate_context.tcx;\n+        let implementation = csearch::get_impl(tcx, impl_def_id);\n \n         debug!(\"coherence: adding impl from external crate: %s\",\n-               ty::item_path_str(self.crate_context.tcx, implementation.did));\n+               ty::item_path_str(tcx, implementation.did));\n \n         // Make sure we don't visit the same implementation multiple times.\n         if !impls_seen.insert(implementation.did) {\n@@ -696,9 +680,8 @@ impl CoherenceChecker {\n         }\n         // Good. Continue.\n \n-        let self_type = lookup_item_type(self.crate_context.tcx,\n-                                         implementation.did);\n-        let associated_traits = get_impl_trait(self.crate_context.tcx,\n+        let self_type = lookup_item_type(tcx, implementation.did);\n+        let associated_traits = get_impl_trait(tcx,\n                                                implementation.did);\n \n         // Do a sanity check to make sure that inherent methods have base\n@@ -708,12 +691,10 @@ impl CoherenceChecker {\n                                        dummy_sp(),\n                                        self_type.ty) {\n                 None => {\n-                    let session = self.crate_context.tcx.sess;\n-                    session.bug(fmt!(\"no base type for external impl with no \\\n+                    tcx.sess.bug(fmt!(\"no base type for external impl with no \\\n                                       trait: %s (type %s)!\",\n-                                     session.str_of(implementation.ident),\n-                                     ty_to_str(self.crate_context.tcx,\n-                                               self_type.ty)));\n+                                     tcx.sess.str_of(implementation.ident),\n+                                     ty_to_str(tcx, self_type.ty)));\n                 }\n                 Some(_) => {} // Nothing to do.\n             }\n@@ -756,8 +737,7 @@ impl CoherenceChecker {\n             }\n         }\n \n-        self.crate_context.tcx.impls.insert(implementation.did,\n-                                            implementation);\n+        tcx.impls.insert(implementation.did, implementation);\n     }\n \n     // Adds implementations and traits from external crates to the coherence\n@@ -770,9 +750,7 @@ impl CoherenceChecker {\n             for each_path(crate_store, crate_number) |_, def_like, _| {\n                 match def_like {\n                     dl_impl(def_id) => {\n-                        self.add_external_impl(&mut impls_seen,\n-                                               crate_store,\n-                                               def_id)\n+                        self.add_external_impl(&mut impls_seen, def_id)\n                     }\n                     dl_def(_) | dl_field => loop,   // Skip this.\n                 }\n@@ -802,7 +780,7 @@ impl CoherenceChecker {\n                 // We'll error out later. For now, just don't ICE.\n                 loop;\n             }\n-            let method_def_id = impl_info.methods[0].did;\n+            let method_def_id = impl_info.methods[0].def_id;\n \n             let self_type = self.get_self_type_for_implementation(*impl_info);\n             match ty::get(self_type.ty).sty {"}]}