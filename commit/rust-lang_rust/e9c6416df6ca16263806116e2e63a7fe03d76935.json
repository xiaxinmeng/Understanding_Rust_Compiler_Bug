{"sha": "e9c6416df6ca16263806116e2e63a7fe03d76935", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5YzY0MTZkZjZjYTE2MjYzODA2MTE2ZTJlNjNhN2ZlMDNkNzY5MzU=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-05-16T22:05:48Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-23T05:29:17Z"}, "message": "std: splitting out tcp server API WIP", "tree": {"sha": "753dae79d741b2549c720ffff71214b530c62565", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/753dae79d741b2549c720ffff71214b530c62565"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9c6416df6ca16263806116e2e63a7fe03d76935", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9c6416df6ca16263806116e2e63a7fe03d76935", "html_url": "https://github.com/rust-lang/rust/commit/e9c6416df6ca16263806116e2e63a7fe03d76935", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9c6416df6ca16263806116e2e63a7fe03d76935/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d02b3dffa490e646416f58a2f0a7756c0f7ed8ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/d02b3dffa490e646416f58a2f0a7756c0f7ed8ec", "html_url": "https://github.com/rust-lang/rust/commit/d02b3dffa490e646416f58a2f0a7756c0f7ed8ec"}], "stats": {"total": 376, "additions": 295, "deletions": 81}, "files": [{"sha": "69ecd7e4a0cb2ccca4d47059d30a5ba42f7657a2", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 293, "deletions": 79, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/e9c6416df6ca16263806116e2e63a7fe03d76935/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c6416df6ca16263806116e2e63a7fe03d76935/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=e9c6416df6ca16263806116e2e63a7fe03d76935", "patch": "@@ -8,27 +8,35 @@ import result::*;\n import str::*;\n \n // data\n-export tcp_socket, tcp_err_data;\n+export tcp_socket, tcp_conn_port, tcp_err_data;\n // operations on a tcp_socket\n export write, read_start, read_stop;\n // tcp server stuff\n-export listen, accept;\n+export new_listener, listen_for_conn, accept;\n // tcp client stuff\n export connect;\n // misc util\n export is_responding;\n \n+#[nolink]\n+native mod rustrt {\n+    fn rust_uv_current_kernel_malloc(size: libc::size_t) -> *libc::c_void;\n+    fn rust_uv_current_kernel_free(mem: *libc::c_void);\n+}\n+\n #[doc=\"\n Encapsulates an open TCP/IP connection through libuv\n \n `tcp_socket` non-sendable and handles automatically closing the underlying libuv data structures when it goes out of scope.\n \"]\n-resource tcp_socket(socket_data: @tcp_socket_data) unsafe {\n+resource tcp_socket(socket_data_wrap: @{data:*mut tcp_socket_data})\n+    unsafe {\n     let closed_po = comm::port::<()>();\n     let closed_ch = comm::chan(closed_po);\n     let close_data = {\n         closed_ch: closed_ch\n     };\n+    let socket_data = (*socket_data_wrap).data;\n     let close_data_ptr = ptr::addr_of(close_data);\n     let stream_handle_ptr = ptr::addr_of((*socket_data).stream_handle);\n     uv::hl::interact((*socket_data).hl_loop) {|loop_ptr|\n@@ -39,9 +47,24 @@ resource tcp_socket(socket_data: @tcp_socket_data) unsafe {\n         uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n     };\n     comm::recv(closed_po);\n+    log(debug, #fmt(\"about to free socket_data at %?\", socket_data));\n+    rustrt::rust_uv_current_kernel_free(socket_data as *libc::c_void);\n     log(debug, \"exiting dtor for tcp_socket\");\n }\n \n+resource tcp_conn_port(conn_data: @tcp_conn_port_data) unsafe {\n+    let conn_data_ptr = ptr::addr_of(*conn_data);\n+    let server_stream_ptr = ptr::addr_of((*conn_data_ptr).server_stream);\n+    let stream_closed_po = (*conn_data).stream_closed_po;\n+    let hl_loop = (*conn_data_ptr).hl_loop;\n+    uv::hl::interact(hl_loop) {|loop_ptr|\n+        log(debug, #fmt(\"dtor for tcp_conn_port loop: %?\",\n+                       loop_ptr));\n+        uv::ll::close(server_stream_ptr, tcp_nl_close_cb);\n+    }\n+    comm::recv(stream_closed_po);\n+}\n+\n #[doc=\"\n Contains raw, string-based, error information returned from libuv\n \"]\n@@ -75,7 +98,8 @@ fn connect(input_ip: ip::ip_addr, port: uint)\n     let conn_data_ptr = ptr::addr_of(conn_data);\n     let hl_loop = uv::global_loop::get();\n     let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n-    let socket_data = @{\n+    let socket_data_ptr = new_socket_data();\n+    *socket_data_ptr = {\n         reader_po: reader_po,\n         reader_ch: comm::chan(reader_po),\n         stream_handle : uv::ll::tcp_t(),\n@@ -86,8 +110,6 @@ fn connect(input_ip: ip::ip_addr, port: uint)\n     log(debug, #fmt(\"tcp_connect result_ch %?\", conn_data.result_ch));\n     // get an unsafe representation of our stream_handle_ptr that\n     // we can send into the interact cb to be handled in libuv..\n-    let socket_data_ptr: *tcp_socket_data =\n-        ptr::addr_of(*socket_data);\n     log(debug, #fmt(\"stream_handl_ptr outside interact %?\",\n         ptr::addr_of((*socket_data_ptr).stream_handle)));\n     uv::hl::interact(hl_loop) {|loop_ptr|\n@@ -117,7 +139,8 @@ fn connect(input_ip: ip::ip_addr, port: uint)\n                     // reusable data that we'll have for the\n                     // duration..\n                     uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n-                                               socket_data_ptr);\n+                                               socket_data_ptr as\n+                                                  *libc::c_void);\n                     // just so the connect_cb can send the\n                     // outcome..\n                     uv::ll::set_data_for_req(connect_req_ptr,\n@@ -151,7 +174,7 @@ fn connect(input_ip: ip::ip_addr, port: uint)\n     alt comm::recv(result_po) {\n       conn_success {\n         log(debug, \"tcp::connect - received success on result_po\");\n-        result::ok(tcp_socket(socket_data))\n+        result::ok(tcp_socket(@{data:socket_data_ptr}))\n       }\n       conn_failure(err_data) {\n         comm::recv(closed_signal_po);\n@@ -177,7 +200,7 @@ A `result` object with a `()` value, in the event of success, or a\n \"]\n fn write(sock: tcp_socket, raw_write_data: [[u8]])\n     -> result::result<(), tcp_err_data> unsafe {\n-    let socket_data_ptr = ptr::addr_of(**sock);\n+    let socket_data_ptr = ((**sock).data);\n     let write_req_ptr = ptr::addr_of((*socket_data_ptr).write_req);\n     let stream_handle_ptr =\n         ptr::addr_of((*socket_data_ptr).stream_handle);\n@@ -231,11 +254,12 @@ on) from until `read_stop` is called, or a `tcp_err_data` record\n fn read_start(sock: tcp_socket)\n     -> result::result<comm::port<\n         result::result<[u8], tcp_err_data>>, tcp_err_data> unsafe {\n-    let stream_handle_ptr = ptr::addr_of((**sock).stream_handle);\n+    let socket_data = (**sock).data;\n+    let stream_handle_ptr = ptr::addr_of((*socket_data).stream_handle);\n     let start_po = comm::port::<option<uv::ll::uv_err_data>>();\n     let start_ch = comm::chan(start_po);\n     log(debug, \"in tcp::read_start before interact loop\");\n-    uv::hl::interact((**sock).hl_loop) {|loop_ptr|\n+    uv::hl::interact((*socket_data).hl_loop) {|loop_ptr|\n         log(debug, #fmt(\"in tcp::read_start interact cb %?\", loop_ptr));\n         alt uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n                                on_alloc_cb,\n@@ -256,7 +280,7 @@ fn read_start(sock: tcp_socket)\n         result::err(err_data.to_tcp_err())\n       }\n       none {\n-        result::ok((**sock).reader_po)\n+        result::ok((*socket_data).reader_po)\n       }\n     }\n }\n@@ -266,10 +290,11 @@ Stop reading from an open TCP connection.\n \"]\n fn read_stop(sock: tcp_socket) ->\n     result::result<(), tcp_err_data> unsafe {\n-    let stream_handle_ptr = ptr::addr_of((**sock).stream_handle);\n+    let socket_data = (**sock).data;\n+    let stream_handle_ptr = ptr::addr_of((*socket_data).stream_handle);\n     let stop_po = comm::port::<option<tcp_err_data>>();\n     let stop_ch = comm::chan(stop_po);\n-    uv::hl::interact((**sock).hl_loop) {|loop_ptr|\n+    uv::hl::interact((*socket_data).hl_loop) {|loop_ptr|\n         log(debug, \"in interact cb for tcp::read_stop\");\n         alt uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n           0i32 {\n@@ -303,39 +328,32 @@ Bind to a given IP/port and listen for new connections\n * `port` - a uint representing the port to listen on\n * `backlog` - a uint representing the number of incoming connections\n to cache in memory\n-* `new_connect_cb` - a callback to be evaluated, on the libuv thread,\n-whenever a client attempts to conect on the provided ip/port. The\n-callback's arguments are:\n-    * `new_conn` - an opaque type that can be passed to\n-    `net::tcp::accept` in order to be converted to a `tcp_socket`.\n-    * `kill_ch` - channel of type `comm::chan<option<tcp_err_data>>`. This\n-    channel can be used to send a message to cause `listen` to begin\n-    closing the underlying libuv data structures.\n \n # Returns\n \n-A `result` instance containing empty data of type `()` on a successful\n-or normal shutdown, and a `tcp_err_data` record in the event of listen\n-exiting because of an error\n+A `result` instance containing either a `tcp_conn_port` which can used\n+to listen for, and accept, new connections, or a `tcp_err_data` if\n+failure to create the tcp listener occurs\n \"]\n-fn listen(host_ip: ip::ip_addr, port: uint, backlog: uint,\n-          new_connect_cb: fn~(tcp_new_connection,\n-                              comm::chan<option<tcp_err_data>>))\n-    -> result::result<(), tcp_err_data> unsafe {\n+fn new_listener(host_ip: ip::ip_addr, port: uint, backlog: uint)\n+    -> result::result<tcp_conn_port, tcp_err_data> unsafe {\n     let stream_closed_po = comm::port::<()>();\n-    let kill_po = comm::port::<option<tcp_err_data>>();\n-    let server_stream = uv::ll::tcp_t();\n-    let server_stream_ptr = ptr::addr_of(server_stream);\n+    let stream_closed_ch = comm::chan(stream_closed_po);\n     let hl_loop = uv::global_loop::get();\n-    let server_data = {\n-        server_stream_ptr: server_stream_ptr,\n-        stream_closed_ch: comm::chan(stream_closed_po),\n-        kill_ch: comm::chan(kill_po),\n-        new_connect_cb: new_connect_cb,\n+    let new_conn_po = comm::port::<result::result<*uv::ll::uv_tcp_t,\n+                                                  tcp_err_data>>();\n+    let new_conn_ch = comm::chan(new_conn_po);\n+    let server_data: @tcp_conn_port_data = @{\n+        server_stream: uv::ll::tcp_t(),\n+        stream_closed_po: stream_closed_po,\n+        stream_closed_ch: stream_closed_ch,\n         hl_loop: hl_loop,\n-        mut active: true\n+        new_conn_po: new_conn_po,\n+        new_conn_ch: new_conn_ch\n     };\n-    let server_data_ptr = ptr::addr_of(server_data);\n+    let server_data_ptr = ptr::addr_of(*server_data);\n+    let server_stream_ptr = ptr::addr_of((*server_data_ptr)\n+                                         .server_stream);\n \n     let setup_po = comm::port::<option<tcp_err_data>>();\n     let setup_ch = comm::chan(setup_po);\n@@ -349,7 +367,7 @@ fn listen(host_ip: ip::ip_addr, port: uint, backlog: uint,\n               0i32 {\n                 alt uv::ll::listen(server_stream_ptr,\n                                    backlog as libc::c_int,\n-                                   tcp_listen_on_connection_cb) {\n+                                   tcp_nl_on_connection_cb) {\n                   0i32 {\n                     uv::ll::set_data_for_uv_handle(\n                         server_stream_ptr,\n@@ -377,31 +395,13 @@ fn listen(host_ip: ip::ip_addr, port: uint, backlog: uint,\n           }\n         }\n     };\n-    let mut kill_result: option<tcp_err_data> = none;\n     alt comm::recv(setup_po) {\n       some(err_data) {\n         // we failed to bind/list w/ libuv\n         result::err(err_data.to_tcp_err())\n       }\n       none {\n-        kill_result = comm::recv(kill_po);\n-        uv::hl::interact(hl_loop) {|loop_ptr|\n-            log(debug, #fmt(\"tcp::listen post-kill recv hl interact %?\",\n-                            loop_ptr));\n-            (*server_data_ptr).active = false;\n-            uv::ll::close(server_stream_ptr, tcp_listen_close_cb);\n-        };\n-        comm::recv(stream_closed_po);\n-        alt kill_result {\n-          // some failure post bind/listen\n-          some(err_data) {\n-            result::err(err_data)\n-          }\n-          // clean exit\n-          none {\n-            result::ok(())\n-          }\n-        }\n+        result::ok(tcp_conn_port(server_data))\n       }\n     }\n }\n@@ -474,18 +474,18 @@ fn accept(new_conn: tcp_new_connection)\n     alt new_conn{\n       new_tcp_conn(server_handle_ptr) {\n         let server_data_ptr = uv::ll::get_data_for_uv_handle(\n-            server_handle_ptr) as *tcp_server_data;\n+            server_handle_ptr) as *tcp_listen_fc_data;\n         let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n         let hl_loop = (*server_data_ptr).hl_loop;\n-        let client_socket_data = @{\n+        let client_socket_data_ptr = new_socket_data();\n+        *client_socket_data_ptr = {\n             reader_po: reader_po,\n             reader_ch: comm::chan(reader_po),\n             stream_handle : uv::ll::tcp_t(),\n             connect_req : uv::ll::connect_t(),\n             write_req : uv::ll::write_t(),\n             hl_loop: hl_loop\n         };\n-        let client_socket_data_ptr = ptr::addr_of(*client_socket_data);\n         let client_stream_handle_ptr = ptr::addr_of(\n             (*client_socket_data_ptr).stream_handle);\n \n@@ -510,7 +510,8 @@ fn accept(new_conn: tcp_new_connection)\n               0i32 {\n                 log(debug, \"successfully accepted client connection\");\n                 uv::ll::set_data_for_uv_handle(client_stream_handle_ptr,\n-                                               client_socket_data_ptr);\n+                                               client_socket_data_ptr\n+                                                   as *libc::c_void);\n                 comm::send(result_ch, none);\n               }\n               _ {\n@@ -532,7 +533,7 @@ fn accept(new_conn: tcp_new_connection)\n             result::err(err_data)\n           }\n           none {\n-            result::ok(tcp_socket(client_socket_data))\n+            result::ok(tcp_socket(@{data: client_socket_data_ptr }))\n           }\n         }\n       }\n@@ -585,13 +586,142 @@ fn is_responding(remote_ip: ip::ip_addr, remote_port: uint,\n     }\n }\n \n-// INTERNAL API\n+#[doc=\"\n+Bind to a given IP/port and listen for new connections\n+\n+# Arguments\n+\n+* `host_ip` - a `net::ip::ip_addr` representing a unique IP\n+(versions 4 or 6)\n+* `port` - a uint representing the port to listen on\n+* `backlog` - a uint representing the number of incoming connections\n+to cache in memory\n+* `on_establish_cb` - a callback that is evaluated if/when the listener\n+is successfully established. it takes no parameters\n+* `new_connect_cb` - a callback to be evaluated, on the libuv thread,\n+whenever a client attempts to conect on the provided ip/port. the\n+callback's arguments are:\n+    * `new_conn` - an opaque type that can be passed to\n+    `net::tcp::accept` in order to be converted to a `tcp_socket`.\n+    * `kill_ch` - channel of type `comm::chan<option<tcp_err_data>>`. this\n+    channel can be used to send a message to cause `listen` to begin\n+    closing the underlying libuv data structures.\n+\n+# returns\n+\n+a `result` instance containing empty data of type `()` on a successful\n+or normal shutdown, and a `tcp_err_data` record in the event of listen\n+exiting because of an error\n+\"]\n+fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n+          on_establish_cb: fn~(comm::chan<option<tcp_err_data>>),\n+          new_connect_cb: fn~(tcp_new_connection,\n+                              comm::chan<option<tcp_err_data>>))\n+    -> result::result<(), tcp_err_data> unsafe {\n+    let stream_closed_po = comm::port::<()>();\n+    let kill_po = comm::port::<option<tcp_err_data>>();\n+    let kill_ch = comm::chan(kill_po);\n+    let server_stream = uv::ll::tcp_t();\n+    let server_stream_ptr = ptr::addr_of(server_stream);\n+    let hl_loop = uv::global_loop::get();\n+    let server_data = {\n+        server_stream_ptr: server_stream_ptr,\n+        stream_closed_ch: comm::chan(stream_closed_po),\n+        kill_ch: kill_ch,\n+        new_connect_cb: new_connect_cb,\n+        hl_loop: hl_loop,\n+        mut active: true\n+    };\n+    let server_data_ptr = ptr::addr_of(server_data);\n+\n+    let setup_po = comm::port::<option<tcp_err_data>>();\n+    let setup_ch = comm::chan(setup_po);\n+    uv::hl::interact(hl_loop) {|loop_ptr|\n+        let tcp_addr = ipv4_ip_addr_to_sockaddr_in(host_ip,\n+                                                   port);\n+        alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n+          0i32 {\n+            alt uv::ll::tcp_bind(server_stream_ptr,\n+                                 ptr::addr_of(tcp_addr)) {\n+              0i32 {\n+                alt uv::ll::listen(server_stream_ptr,\n+                                   backlog as libc::c_int,\n+                                   tcp_lfc_on_connection_cb) {\n+                  0i32 {\n+                    uv::ll::set_data_for_uv_handle(\n+                        server_stream_ptr,\n+                        server_data_ptr);\n+                    comm::send(setup_ch, none);\n+                  }\n+                  _ {\n+                    log(debug, \"failure to uv_listen()\");\n+                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                    comm::send(setup_ch, some(err_data));\n+                  }\n+                }\n+              }\n+              _ {\n+                log(debug, \"failure to uv_tcp_bind\");\n+                let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                comm::send(setup_ch, some(err_data));\n+              }\n+            }\n+          }\n+          _ {\n+            log(debug, \"failure to uv_tcp_init\");\n+            let err_data = uv::ll::get_last_err_data(loop_ptr);\n+            comm::send(setup_ch, some(err_data));\n+          }\n+        }\n+    };\n+    let mut kill_result: option<tcp_err_data> = none;\n+    alt comm::recv(setup_po) {\n+      some(err_data) {\n+        // we failed to bind/list w/ libuv\n+        result::err(err_data.to_tcp_err())\n+      }\n+      none {\n+        on_establish_cb(kill_ch);\n+        kill_result = comm::recv(kill_po);\n+        uv::hl::interact(hl_loop) {|loop_ptr|\n+            log(debug, #fmt(\"tcp::listen post-kill recv hl interact %?\",\n+                            loop_ptr));\n+            (*server_data_ptr).active = false;\n+            uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n+        };\n+        comm::recv(stream_closed_po);\n+        alt kill_result {\n+          // some failure post bind/listen\n+          some(err_data) {\n+            result::err(err_data)\n+          }\n+          // clean exit\n+          none {\n+            result::ok(())\n+          }\n+        }\n+      }\n+    }\n+}\n+\n+// internal api\n \n enum tcp_new_connection {\n     new_tcp_conn(*uv::ll::uv_tcp_t)\n }\n \n-type tcp_server_data = {\n+type tcp_conn_port_data = {\n+    server_stream: uv::ll::uv_tcp_t,\n+    stream_closed_po: comm::port<()>,\n+    stream_closed_ch: comm::chan<()>,\n+    hl_loop: uv::hl::high_level_loop,\n+    new_conn_po: comm::port<result::result<*uv::ll::uv_tcp_t,\n+                                           tcp_err_data>>,\n+    new_conn_ch: comm::chan<result::result<*uv::ll::uv_tcp_t,\n+                                           tcp_err_data>>\n+};\n+\n+type tcp_listen_fc_data = {\n     server_stream_ptr: *uv::ll::uv_tcp_t,\n     stream_closed_ch: comm::chan<()>,\n     kill_ch: comm::chan<option<tcp_err_data>>,\n@@ -601,16 +731,16 @@ type tcp_server_data = {\n     mut active: bool\n };\n \n-crust fn tcp_listen_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n+crust fn tcp_lfc_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n     let server_data_ptr = uv::ll::get_data_for_uv_handle(\n-        handle) as *tcp_server_data;\n+        handle) as *tcp_listen_fc_data;\n     comm::send((*server_data_ptr).stream_closed_ch, ());\n }\n \n-crust fn tcp_listen_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n+crust fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n                                      status: libc::c_int) unsafe {\n     let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n-        as *tcp_server_data;\n+        as *tcp_listen_fc_data;\n     let kill_ch = (*server_data_ptr).kill_ch;\n     alt (*server_data_ptr).active {\n       true {\n@@ -633,6 +763,80 @@ crust fn tcp_listen_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n     }\n }\n \n+crust fn tcp_nl_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n+    let conn_data_ptr = uv::ll::get_data_for_uv_handle(\n+        handle) as *tcp_conn_port_data;\n+    comm::send((*conn_data_ptr).stream_closed_ch, ());\n+}\n+\n+fn new_socket_data() -> *mut tcp_socket_data unsafe {\n+    rustrt::rust_uv_current_kernel_malloc(\n+        sys::size_of::<tcp_socket_data>()) as\n+    *mut tcp_socket_data\n+}\n+\n+crust fn tcp_nl_on_connection_cb(server_handle_ptr: *uv::ll::uv_tcp_t,\n+                                     status: libc::c_int) unsafe {\n+    let server_data_ptr = uv::ll::get_data_for_uv_handle(server_handle_ptr)\n+        as *tcp_conn_port_data;\n+    let new_conn_ch = (*server_data_ptr).new_conn_ch;\n+    let loop_ptr = uv::ll::get_loop_for_uv_handle(server_handle_ptr);\n+    alt status {\n+      0i32 {\n+        let hl_loop = (*server_data_ptr).hl_loop;\n+        let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n+        let client_socket_data_ptr = new_socket_data();\n+        *client_socket_data_ptr = {\n+            reader_po: reader_po,\n+            reader_ch: comm::chan(reader_po),\n+            stream_handle : uv::ll::tcp_t(),\n+            connect_req : uv::ll::connect_t(),\n+            write_req : uv::ll::write_t(),\n+            hl_loop: hl_loop\n+        }; \n+        let client_stream_handle_ptr = ptr::addr_of(\n+            (*client_socket_data_ptr).stream_handle);\n+        alt uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n+          0i32 {\n+            log(debug, \"uv_tcp_init successful for client stream\");\n+            alt uv::ll::accept(\n+                server_handle_ptr as *libc::c_void,\n+                client_stream_handle_ptr as *libc::c_void) {\n+              0i32 {\n+                log(debug, \"successfully accepted client connection\");\n+                uv::ll::set_data_for_uv_handle(client_stream_handle_ptr,\n+                                               client_socket_data_ptr as\n+                                               *libc::c_void);\n+                comm::send(new_conn_ch,\n+                           result::ok(client_stream_handle_ptr));\n+              }\n+              _ {\n+                log(debug, \"failed to accept client conn\");\n+                comm::send(\n+                    new_conn_ch,\n+                    result::err(uv::ll::get_last_err_data(loop_ptr)\n+                        .to_tcp_err()));\n+              }\n+            }\n+          }\n+          _ {\n+            log(debug, \"failed to init client stream\");\n+            comm::send(\n+                new_conn_ch,\n+                result::err(uv::ll::get_last_err_data(loop_ptr)\n+                    .to_tcp_err()));\n+          }\n+        }\n+      }\n+      _ {\n+        comm::send(\n+            new_conn_ch,\n+            result::err(uv::ll::get_last_err_data(loop_ptr)\n+                .to_tcp_err()));\n+      }\n+    }\n+}\n+\n enum tcp_connect_result {\n     tcp_connected(tcp_socket),\n     tcp_connect_error(tcp_err_data)\n@@ -849,23 +1053,25 @@ mod test {\n \n         let server_result_po = comm::port::<str>();\n         let server_result_ch = comm::chan(server_result_po);\n+\n+        let cont_po = comm::port::<()>();\n+        let cont_ch = comm::chan(cont_po);\n         // server\n         task::spawn_sched(task::manual_threads(1u)) {||\n             let actual_req = comm::listen {|server_ch|\n                 run_tcp_test_server(\n                     server_ip,\n                     server_port,\n                     expected_resp,\n-                    server_ch)\n+                    server_ch,\n+                    cont_ch)\n             };\n             server_result_ch.send(actual_req);\n         };\n+        comm::recv(cont_po);\n         // client\n         log(debug, \"server started, firing up client..\");\n         let actual_resp = comm::listen {|client_ch|\n-            log(debug, \"before client sleep\");\n-            timer::sleep(2u);\n-            log(debug, \"after client sleep\");\n             run_tcp_test_client(\n                 server_ip,\n                 server_port,\n@@ -882,13 +1088,21 @@ mod test {\n     }\n \n     fn run_tcp_test_server(server_ip: str, server_port: uint, resp: str,\n-                          server_ch: comm::chan<str>) -> str {\n+                          server_ch: comm::chan<str>,\n+                          cont_ch: comm::chan<()>) -> str {\n \n         task::spawn_sched(task::manual_threads(1u)) {||\n             let server_ip_addr = ip::v4::parse_addr(server_ip);\n-            let listen_result = listen(server_ip_addr, server_port, 128u)\n-                // this callback is ran on the loop.\n-                // .. should it go?\n+            let listen_result =\n+                listen_for_conn(server_ip_addr, server_port, 128u,\n+                // on_establish_cb -- called when listener is set up\n+                {|kill_ch|\n+                    log(debug, #fmt(\"establish_cb %?\",\n+                        kill_ch));\n+                    comm::send(cont_ch, ());\n+                },\n+                // risky to run this on the loop, but some users\n+                // will want the POWER\n                 {|new_conn, kill_ch|\n                 log(debug, \"SERVER: new connection!\");\n                 comm::listen {|cont_ch|\n@@ -935,7 +1149,7 @@ mod test {\n                     cont_ch.recv()\n                 };\n                 log(debug, \"SERVER: recv'd on cont_ch..leaving listen cb\");\n-            };\n+            });\n             // err check on listen_result\n             if result::is_failure(listen_result) {\n                 let err_data = result::get_err(listen_result);"}, {"sha": "95d503b791419d564a8fac1a301421ad89ca1c83", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9c6416df6ca16263806116e2e63a7fe03d76935/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e9c6416df6ca16263806116e2e63a7fe03d76935/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=e9c6416df6ca16263806116e2e63a7fe03d76935", "patch": "@@ -456,7 +456,7 @@ rust_uv_current_kernel_malloc(size_t size) {\n \treturn current_kernel_malloc(size, \"rust_uv_current_kernel_malloc\");\n }\n \n-extern \"C\" void*\n+extern \"C\" void\n rust_uv_current_kernel_free(void* mem) {\n-\treturn current_kernel_free(mem);\n+\tcurrent_kernel_free(mem);\n }"}]}