{"sha": "6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2", "node_id": "C_kwDOAAsO6NoAKDY0MzZjMzQ4ZGJhYTBlYjhmMjg1M2RmYjY0Y2JmOGIzMGY1MTE5ZjI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-25T23:31:28Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-25T23:31:37Z"}, "message": "Remove SelectionContext::infcx() in favor of field access", "tree": {"sha": "afdb34f050376322506e2ecfd2ad5f698e3f9c2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afdb34f050376322506e2ecfd2ad5f698e3f9c2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2", "html_url": "https://github.com/rust-lang/rust/commit/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8681d4cffcd23bbe619984ab62772a91827a40dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8681d4cffcd23bbe619984ab62772a91827a40dc", "html_url": "https://github.com/rust-lang/rust/commit/8681d4cffcd23bbe619984ab62772a91827a40dc"}], "stats": {"total": 167, "additions": 75, "deletions": 92}, "files": [{"sha": "3bc248bb0b274f9ff4a50cb5d38d314df95ced79", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2", "patch": "@@ -599,17 +599,17 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n         computed_preds: &mut FxIndexSet<ty::Predicate<'tcx>>,\n         fresh_preds: &mut FxHashSet<ty::Predicate<'tcx>>,\n         predicates: &mut VecDeque<ty::PolyTraitPredicate<'tcx>>,\n-        select: &mut SelectionContext<'_, 'tcx>,\n+        selcx: &mut SelectionContext<'_, 'tcx>,\n         only_projections: bool,\n     ) -> bool {\n         let dummy_cause = ObligationCause::dummy();\n \n         for obligation in nested {\n             let is_new_pred =\n-                fresh_preds.insert(self.clean_pred(select.infcx(), obligation.predicate));\n+                fresh_preds.insert(self.clean_pred(selcx.infcx, obligation.predicate));\n \n             // Resolve any inference variables that we can, to help selection succeed\n-            let predicate = select.infcx().resolve_vars_if_possible(obligation.predicate);\n+            let predicate = selcx.infcx.resolve_vars_if_possible(obligation.predicate);\n \n             // We only add a predicate as a user-displayable bound if\n             // it involves a generic parameter, and doesn't contain\n@@ -717,10 +717,8 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                     // and turn them into an explicit negative impl for our type.\n                     debug!(\"Projecting and unifying projection predicate {:?}\", predicate);\n \n-                    match project::poly_project_and_unify_type(\n-                        select,\n-                        &obligation.with(self.tcx, p),\n-                    ) {\n+                    match project::poly_project_and_unify_type(selcx, &obligation.with(self.tcx, p))\n+                    {\n                         ProjectAndUnifyResult::MismatchedProjectionTypes(e) => {\n                             debug!(\n                                 \"evaluate_nested_obligations: Unable to unify predicate \\\n@@ -745,7 +743,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                                     computed_preds,\n                                     fresh_preds,\n                                     predicates,\n-                                    select,\n+                                    selcx,\n                                     only_projections,\n                                 ) {\n                                     return false;\n@@ -768,7 +766,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 }\n                 ty::PredicateKind::Clause(ty::Clause::RegionOutlives(binder)) => {\n                     let binder = bound_predicate.rebind(binder);\n-                    select.infcx().region_outlives_predicate(&dummy_cause, binder)\n+                    selcx.infcx.region_outlives_predicate(&dummy_cause, binder)\n                 }\n                 ty::PredicateKind::Clause(ty::Clause::TypeOutlives(binder)) => {\n                     let binder = bound_predicate.rebind(binder);\n@@ -777,14 +775,14 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                         binder.map_bound_ref(|pred| pred.0).no_bound_vars(),\n                     ) {\n                         (None, Some(t_a)) => {\n-                            select.infcx().register_region_obligation_with_cause(\n+                            selcx.infcx.register_region_obligation_with_cause(\n                                 t_a,\n-                                select.infcx().tcx.lifetimes.re_static,\n+                                selcx.infcx.tcx.lifetimes.re_static,\n                                 &dummy_cause,\n                             );\n                         }\n                         (Some(ty::OutlivesPredicate(t_a, r_b)), _) => {\n-                            select.infcx().register_region_obligation_with_cause(\n+                            selcx.infcx.register_region_obligation_with_cause(\n                                 t_a,\n                                 r_b,\n                                 &dummy_cause,\n@@ -796,13 +794,13 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 ty::PredicateKind::ConstEquate(c1, c2) => {\n                     let evaluate = |c: ty::Const<'tcx>| {\n                         if let ty::ConstKind::Unevaluated(unevaluated) = c.kind() {\n-                            match select.infcx().const_eval_resolve(\n+                            match selcx.infcx.const_eval_resolve(\n                                 obligation.param_env,\n                                 unevaluated,\n                                 Some(obligation.cause.span),\n                             ) {\n                                 Ok(Some(valtree)) => {\n-                                    Ok(ty::Const::from_value(select.tcx(), valtree, c.ty()))\n+                                    Ok(ty::Const::from_value(selcx.tcx(), valtree, c.ty()))\n                                 }\n                                 Ok(None) => {\n                                     let tcx = self.tcx;\n@@ -823,10 +821,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n \n                     match (evaluate(c1), evaluate(c2)) {\n                         (Ok(c1), Ok(c2)) => {\n-                            match select\n-                                .infcx()\n-                                .at(&obligation.cause, obligation.param_env)\n-                                .eq(c1, c2)\n+                            match selcx.infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n                             {\n                                 Ok(_) => (),\n                                 Err(_) => return false,"}, {"sha": "99724fb28db1104ab90a8c7c04a6f54865d9377c", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2", "patch": "@@ -119,7 +119,7 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n     impl_def_id: DefId,\n ) -> ty::ImplHeader<'tcx> {\n     let tcx = selcx.tcx();\n-    let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+    let impl_substs = selcx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n \n     let header = ty::ImplHeader {\n         impl_def_id,\n@@ -149,7 +149,7 @@ fn overlap<'cx, 'tcx>(\n         impl1_def_id, impl2_def_id, overlap_mode\n     );\n \n-    selcx.infcx().probe_maybe_skip_leak_check(skip_leak_check.is_yes(), |snapshot| {\n+    selcx.infcx.probe_maybe_skip_leak_check(skip_leak_check.is_yes(), |snapshot| {\n         overlap_within_probe(selcx, impl1_def_id, impl2_def_id, overlap_mode, snapshot)\n     })\n }\n@@ -161,7 +161,7 @@ fn overlap_within_probe<'cx, 'tcx>(\n     overlap_mode: OverlapMode,\n     snapshot: &CombinedSnapshot<'tcx>,\n ) -> Option<OverlapResult<'tcx>> {\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n \n     if overlap_mode.use_negative_impl() {\n         if negative_impl(infcx.tcx, impl1_def_id, impl2_def_id)\n@@ -200,9 +200,9 @@ fn overlap_within_probe<'cx, 'tcx>(\n     debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n \n     let involves_placeholder =\n-        matches!(selcx.infcx().region_constraints_added_in_snapshot(snapshot), Some(true));\n+        matches!(selcx.infcx.region_constraints_added_in_snapshot(snapshot), Some(true));\n \n-    let impl_header = selcx.infcx().resolve_vars_if_possible(impl1_header);\n+    let impl_header = selcx.infcx.resolve_vars_if_possible(impl1_header);\n     Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n }\n \n@@ -214,7 +214,7 @@ fn equate_impl_headers<'cx, 'tcx>(\n     // Do `a` and `b` unify? If not, no overlap.\n     debug!(\"equate_impl_headers(impl1_header={:?}, impl2_header={:?}\", impl1_header, impl2_header);\n     selcx\n-        .infcx()\n+        .infcx\n         .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n         .eq_impl_headers(impl1_header, impl2_header)\n         .map(|infer_ok| infer_ok.obligations)\n@@ -255,7 +255,7 @@ fn implicit_negative<'cx, 'tcx>(\n         \"implicit_negative(impl1_header={:?}, impl2_header={:?}, obligations={:?})\",\n         impl1_header, impl2_header, obligations\n     );\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     let opt_failing_obligation = impl1_header\n         .predicates\n         .iter()"}, {"sha": "19c384671b3b91b72b0d3fc65ef606da0b0e1fda", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2", "patch": "@@ -199,7 +199,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n             // code is so hot. 1 and 0 dominate; 2+ is fairly rare.\n             1 => {\n                 let infer_var = pending_obligation.stalled_on[0];\n-                self.selcx.infcx().ty_or_const_infer_var_changed(infer_var)\n+                self.selcx.infcx.ty_or_const_infer_var_changed(infer_var)\n             }\n             0 => {\n                 // In this case we haven't changed, but wish to make a change.\n@@ -210,7 +210,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 // form was a perf win. See #64545 for details.\n                 (|| {\n                     for &infer_var in &pending_obligation.stalled_on {\n-                        if self.selcx.infcx().ty_or_const_infer_var_changed(infer_var) {\n+                        if self.selcx.infcx.ty_or_const_infer_var_changed(infer_var) {\n                             return true;\n                         }\n                     }\n@@ -240,13 +240,12 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n         debug!(?obligation, \"pre-resolve\");\n \n         if obligation.predicate.has_non_region_infer() {\n-            obligation.predicate =\n-                self.selcx.infcx().resolve_vars_if_possible(obligation.predicate);\n+            obligation.predicate = self.selcx.infcx.resolve_vars_if_possible(obligation.predicate);\n         }\n \n         let obligation = &pending_obligation.obligation;\n \n-        let infcx = self.selcx.infcx();\n+        let infcx = self.selcx.infcx;\n \n         if obligation.predicate.has_projections() {\n             let mut obligations = Vec::new();\n@@ -353,7 +352,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 }\n \n                 ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {\n-                    match self.selcx.infcx().closure_kind(closure_substs) {\n+                    match self.selcx.infcx.closure_kind(closure_substs) {\n                         Some(closure_kind) => {\n                             if closure_kind.extends(kind) {\n                                 ProcessResult::Changed(vec![])\n@@ -367,7 +366,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n \n                 ty::PredicateKind::WellFormed(arg) => {\n                     match wf::obligations(\n-                        self.selcx.infcx(),\n+                        self.selcx.infcx,\n                         obligation.param_env,\n                         obligation.cause.body_id,\n                         obligation.recursion_depth + 1,\n@@ -384,7 +383,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 }\n \n                 ty::PredicateKind::Subtype(subtype) => {\n-                    match self.selcx.infcx().subtype_predicate(\n+                    match self.selcx.infcx.subtype_predicate(\n                         &obligation.cause,\n                         obligation.param_env,\n                         Binder::dummy(subtype),\n@@ -408,7 +407,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 }\n \n                 ty::PredicateKind::Coerce(coerce) => {\n-                    match self.selcx.infcx().coerce_predicate(\n+                    match self.selcx.infcx.coerce_predicate(\n                         &obligation.cause,\n                         obligation.param_env,\n                         Binder::dummy(coerce),\n@@ -432,7 +431,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n \n                 ty::PredicateKind::ConstEvaluatable(uv) => {\n                     match const_evaluatable::is_const_evaluatable(\n-                        self.selcx.infcx(),\n+                        self.selcx.infcx,\n                         uv,\n                         obligation.param_env,\n                         obligation.cause.span,\n@@ -476,7 +475,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n \n                     let mut evaluate = |c: Const<'tcx>| {\n                         if let ty::ConstKind::Unevaluated(unevaluated) = c.kind() {\n-                            match self.selcx.infcx().try_const_eval_resolve(\n+                            match self.selcx.infcx.try_const_eval_resolve(\n                                 obligation.param_env,\n                                 unevaluated,\n                                 c.ty(),\n@@ -504,7 +503,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                         (Ok(c1), Ok(c2)) => {\n                             match self\n                                 .selcx\n-                                .infcx()\n+                                .infcx\n                                 .at(&obligation.cause, obligation.param_env)\n                                 .eq(c1, c2)\n                             {\n@@ -572,7 +571,7 @@ impl<'a, 'tcx> FulfillProcessor<'a, 'tcx> {\n         trait_obligation: TraitObligation<'tcx>,\n         stalled_on: &mut Vec<TyOrConstInferVar<'tcx>>,\n     ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {\n-        let infcx = self.selcx.infcx();\n+        let infcx = self.selcx.infcx;\n         if obligation.predicate.is_global() {\n             // no type variables present, can use evaluation for better caching.\n             // FIXME: consider caching errors too.\n@@ -630,7 +629,7 @@ impl<'a, 'tcx> FulfillProcessor<'a, 'tcx> {\n         if obligation.predicate.is_global() {\n             // no type variables present, can use evaluation for better caching.\n             // FIXME: consider caching errors too.\n-            if self.selcx.infcx().predicate_must_hold_considering_regions(obligation) {\n+            if self.selcx.infcx.predicate_must_hold_considering_regions(obligation) {\n                 if let Some(key) = ProjectionCacheKey::from_poly_projection_predicate(\n                     &mut self.selcx,\n                     project_obligation.predicate,\n@@ -639,7 +638,7 @@ impl<'a, 'tcx> FulfillProcessor<'a, 'tcx> {\n                     // evaluated all sub-obligations. We can therefore mark the 'root'\n                     // obligation as complete, and skip evaluating sub-obligations.\n                     self.selcx\n-                        .infcx()\n+                        .infcx\n                         .inner\n                         .borrow_mut()\n                         .projection_cache()\n@@ -678,7 +677,7 @@ fn substs_infer_vars<'a, 'tcx>(\n     substs: ty::Binder<'tcx, SubstsRef<'tcx>>,\n ) -> impl Iterator<Item = TyOrConstInferVar<'tcx>> {\n     selcx\n-        .infcx()\n+        .infcx\n         .resolve_vars_if_possible(substs)\n         .skip_binder() // ok because this check doesn't care about regions\n         .iter()"}, {"sha": "f358687402f47d884e1e2ddff2ea161b80237c66", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2", "patch": "@@ -194,7 +194,7 @@ pub(super) fn poly_project_and_unify_type<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &PolyProjectionObligation<'tcx>,\n ) -> ProjectAndUnifyResult<'tcx> {\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     let r = infcx.commit_if_ok(|_snapshot| {\n         let old_universe = infcx.universe();\n         let placeholder_predicate =\n@@ -250,7 +250,7 @@ fn project_and_unify_type<'cx, 'tcx>(\n ) -> ProjectAndUnifyResult<'tcx> {\n     let mut obligations = vec![];\n \n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     let normalized = match opt_normalize_projection_type(\n         selcx,\n         obligation.param_env,\n@@ -269,7 +269,7 @@ fn project_and_unify_type<'cx, 'tcx>(\n     // This allows users to omit re-mentioning all bounds on an associated type and just use an\n     // `impl Trait` for the assoc type to add more bounds.\n     let InferOk { value: actual, obligations: new } =\n-        selcx.infcx().replace_opaque_types_with_inference_vars(\n+        selcx.infcx.replace_opaque_types_with_inference_vars(\n             actual,\n             obligation.cause.body_id,\n             obligation.cause.span,\n@@ -445,7 +445,7 @@ impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n     }\n \n     fn fold<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n-        let value = self.selcx.infcx().resolve_vars_if_possible(value);\n+        let value = self.selcx.infcx.resolve_vars_if_possible(value);\n         debug!(?value);\n \n         assert!(\n@@ -524,7 +524,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                                 self.param_env,\n                                 ty,\n                             );\n-                            self.selcx.infcx().err_ctxt().report_overflow_error(&obligation, true);\n+                            self.selcx.infcx.err_ctxt().report_overflow_error(&obligation, true);\n                         }\n \n                         let substs = substs.fold_with(self);\n@@ -590,7 +590,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 // want to figure out how to register obligations with escaping vars\n                 // or handle this some other way.\n \n-                let infcx = self.selcx.infcx();\n+                let infcx = self.selcx.infcx;\n                 let (data, mapped_regions, mapped_types, mapped_consts) =\n                     BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n                 let data = data.fold_with(self);\n@@ -640,7 +640,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n             let constant = constant.super_fold_with(self);\n             debug!(?constant, ?self.param_env);\n             with_replaced_escaping_bound_vars(\n-                self.selcx.infcx(),\n+                self.selcx.infcx,\n                 &mut self.universes,\n                 constant,\n                 |constant| constant.eval(tcx, self.param_env),\n@@ -992,10 +992,7 @@ pub fn normalize_projection_type<'a, 'b, 'tcx>(\n         // and a deferred predicate to resolve this when more type\n         // information is available.\n \n-        selcx\n-            .infcx()\n-            .infer_projection(param_env, projection_ty, cause, depth + 1, obligations)\n-            .into()\n+        selcx.infcx.infer_projection(param_env, projection_ty, cause, depth + 1, obligations).into()\n     })\n }\n \n@@ -1018,7 +1015,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     depth: usize,\n     obligations: &mut Vec<PredicateObligation<'tcx>>,\n ) -> Result<Option<Term<'tcx>>, InProgress> {\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     // Don't use the projection cache in intercrate mode -\n     // the `infcx` may be re-used between intercrate in non-intercrate\n     // mode, which could lead to using incorrect cache results.\n@@ -1110,7 +1107,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // an impl, where-clause etc) and hence we must\n             // re-normalize it\n \n-            let projected_term = selcx.infcx().resolve_vars_if_possible(projected_term);\n+            let projected_term = selcx.infcx.resolve_vars_if_possible(projected_term);\n \n             let mut result = if projected_term.has_projections() {\n                 let mut normalizer = AssocTypeNormalizer::new(\n@@ -1206,9 +1203,9 @@ fn normalize_to_error<'a, 'tcx>(\n         param_env,\n         predicate: trait_ref.without_const().to_predicate(selcx.tcx()),\n     };\n-    let tcx = selcx.infcx().tcx;\n+    let tcx = selcx.infcx.tcx;\n     let def_id = projection_ty.item_def_id;\n-    let new_value = selcx.infcx().next_ty_var(TypeVariableOrigin {\n+    let new_value = selcx.infcx.next_ty_var(TypeVariableOrigin {\n         kind: TypeVariableOriginKind::NormalizeProjectionType,\n         span: tcx.def_span(def_id),\n     });\n@@ -1330,7 +1327,7 @@ fn assemble_candidate_for_impl_trait_in_trait<'cx, 'tcx>(\n         let trait_predicate =\n             ty::Binder::dummy(ty::TraitRef { def_id: trait_def_id, substs: trait_substs });\n \n-        let _ = selcx.infcx().commit_if_ok(|_| {\n+        let _ = selcx.infcx.commit_if_ok(|_| {\n             match selcx.select(&obligation.with(tcx, trait_predicate)) {\n                 Ok(Some(super::ImplSource::UserDefined(data))) => {\n                     candidate_set.push_candidate(ProjectionCandidate::ImplTraitInTrait(\n@@ -1435,7 +1432,7 @@ fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n     let tcx = selcx.tcx();\n \n     let self_ty = obligation.predicate.self_ty();\n-    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n+    let object_ty = selcx.infcx.shallow_resolve(self_ty);\n     let data = match object_ty.kind() {\n         ty::Dynamic(data, ..) => data,\n         ty::Infer(ty::TyVar(_)) => {\n@@ -1473,7 +1470,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     env_predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n     potentially_unnormalized_candidates: bool,\n ) {\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     for predicate in env_predicates {\n         let bound_predicate = predicate.kind();\n         if let ty::PredicateKind::Clause(ty::Clause::Projection(data)) =\n@@ -1529,7 +1526,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n     // start out by selecting the predicate `T as TraitRef<...>`:\n     let poly_trait_ref = ty::Binder::dummy(obligation.predicate.trait_ref(selcx.tcx()));\n     let trait_obligation = obligation.with(selcx.tcx(), poly_trait_ref);\n-    let _ = selcx.infcx().commit_if_ok(|_| {\n+    let _ = selcx.infcx.commit_if_ok(|_| {\n         let impl_source = match selcx.select(&trait_obligation) {\n             Ok(Some(impl_source)) => impl_source,\n             Ok(None) => {\n@@ -1587,7 +1584,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     if obligation.param_env.reveal() == Reveal::All {\n                         // NOTE(eddyb) inference variables can resolve to parameters, so\n                         // assume `poly_trait_ref` isn't monomorphic, if it contains any.\n-                        let poly_trait_ref = selcx.infcx().resolve_vars_if_possible(poly_trait_ref);\n+                        let poly_trait_ref = selcx.infcx.resolve_vars_if_possible(poly_trait_ref);\n                         !poly_trait_ref.still_further_specializable()\n                     } else {\n                         debug!(\n@@ -1603,7 +1600,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // While a builtin impl may be known to exist, the associated type may not yet\n                 // be known. Any type with multiple potential associated types is therefore\n                 // not eligible.\n-                let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n+                let self_ty = selcx.infcx.shallow_resolve(obligation.predicate.self_ty());\n \n                 let lang_items = selcx.tcx().lang_items();\n                 if lang_items.discriminant_kind_trait() == Some(poly_trait_ref.def_id()) {\n@@ -1690,7 +1687,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                         // type parameters, opaques, and unnormalized projections have pointer\n                         // metadata if they're known (e.g. by the param_env) to be sized\n                         ty::Param(_) | ty::Projection(..) | ty::Opaque(..)\n-                            if selcx.infcx().predicate_must_hold_modulo_regions(\n+                            if selcx.infcx.predicate_must_hold_modulo_regions(\n                                 &obligation.with(\n                                     selcx.tcx(),\n                                     ty::Binder::dummy(\n@@ -1818,8 +1815,7 @@ fn confirm_candidate<'cx, 'tcx>(\n     // when possible for this to work. See `auto-trait-projection-recursion.rs`\n     // for a case where this matters.\n     if progress.term.has_infer_regions() {\n-        progress.term =\n-            progress.term.fold_with(&mut OpportunisticRegionResolver::new(selcx.infcx()));\n+        progress.term = progress.term.fold_with(&mut OpportunisticRegionResolver::new(selcx.infcx));\n     }\n     progress\n }\n@@ -2000,7 +1996,7 @@ fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_pointer_impl_source: ImplSourceFnPointerData<'tcx, PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let fn_type = selcx.infcx().shallow_resolve(fn_pointer_impl_source.fn_ty);\n+    let fn_type = selcx.infcx.shallow_resolve(fn_pointer_impl_source.fn_ty);\n     let sig = fn_type.fn_sig(selcx.tcx());\n     let Normalized { value: sig, obligations } = normalize_with_depth(\n         selcx,\n@@ -2073,7 +2069,7 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n     poly_cache_entry: ty::PolyProjectionPredicate<'tcx>,\n     potentially_unnormalized_candidate: bool,\n ) -> Progress<'tcx> {\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     let cause = &obligation.cause;\n     let param_env = obligation.param_env;\n \n@@ -2168,7 +2164,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     // * `substs` ends up as `[u32, S]`\n     let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n     let substs =\n-        translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.defining_node);\n+        translate_substs(selcx.infcx, param_env, impl_def_id, substs, assoc_ty.defining_node);\n     let ty = tcx.bound_type_of(assoc_ty.item.def_id);\n     let is_const = matches!(tcx.def_kind(assoc_ty.item.def_id), DefKind::AssocConst);\n     let term: ty::EarlyBinder<ty::Term<'tcx>> = if is_const {\n@@ -2264,7 +2260,7 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n     let impl_fn_substs =\n         obligation.predicate.substs.rebase_onto(tcx, tcx.parent(trait_fn_def_id), data.substs);\n     let impl_fn_substs = translate_substs(\n-        selcx.infcx(),\n+        selcx.infcx,\n         obligation.param_env,\n         data.impl_def_id,\n         impl_fn_substs,\n@@ -2424,7 +2420,7 @@ impl<'cx, 'tcx> ProjectionCacheKeyExt<'cx, 'tcx> for ProjectionCacheKey<'tcx> {\n         selcx: &mut SelectionContext<'cx, 'tcx>,\n         predicate: ty::PolyProjectionPredicate<'tcx>,\n     ) -> Option<Self> {\n-        let infcx = selcx.infcx();\n+        let infcx = selcx.infcx;\n         // We don't do cross-snapshot caching of obligations with escaping regions,\n         // so there's no cache key to use\n         predicate.no_bound_vars().map(|predicate| {"}, {"sha": "fa076765ad991342c6a1dff112961b4c887f7c5e", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2", "patch": "@@ -238,7 +238,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             param_env: obligation.param_env,\n             cause: obligation.cause.clone(),\n             recursion_depth: obligation.recursion_depth,\n-            predicate: self.infcx().resolve_vars_if_possible(obligation.predicate),\n+            predicate: self.infcx.resolve_vars_if_possible(obligation.predicate),\n         };\n \n         if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n@@ -689,9 +689,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             debug!(?poly_trait_ref, \"assemble_candidates_from_object_ty\");\n \n-            let poly_trait_predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n+            let poly_trait_predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);\n             let placeholder_trait_predicate =\n-                self.infcx().replace_bound_vars_with_placeholders(poly_trait_predicate);\n+                self.infcx.replace_bound_vars_with_placeholders(poly_trait_predicate);\n \n             // Count only those upcast versions that match the trait-ref\n             // we are looking for. Specifically, do not only check for the\n@@ -940,7 +940,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return;\n         }\n \n-        let self_ty = self.infcx().shallow_resolve(obligation.self_ty());\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         match self_ty.skip_binder().kind() {\n             ty::Opaque(..)\n             | ty::Dynamic(..)\n@@ -1007,7 +1007,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) {\n-        let self_ty = self.infcx().shallow_resolve(obligation.self_ty().skip_binder());\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n         match self_ty.kind() {\n             ty::Tuple(_) => {\n                 candidates.vec.push(BuiltinCandidate { has_nested: false });"}, {"sha": "86fd69c159e57955471aba12ab56011de3693887", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2", "patch": "@@ -147,7 +147,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let trait_predicate = self.infcx.shallow_resolve(obligation.predicate);\n         let placeholder_trait_predicate =\n-            self.infcx().replace_bound_vars_with_placeholders(trait_predicate).trait_ref;\n+            self.infcx.replace_bound_vars_with_placeholders(trait_predicate).trait_ref;\n         let placeholder_self_ty = placeholder_trait_predicate.self_ty();\n         let placeholder_trait_predicate = ty::Binder::dummy(placeholder_trait_predicate);\n         let (def_id, substs) = match *placeholder_self_ty.kind() {\n@@ -639,7 +639,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?obligation, \"confirm_trait_alias_candidate\");\n \n         let alias_def_id = obligation.predicate.def_id();\n-        let predicate = self.infcx().replace_bound_vars_with_placeholders(obligation.predicate);\n+        let predicate = self.infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n         let trait_ref = predicate.trait_ref;\n         let trait_def_id = trait_ref.def_id;\n         let substs = trait_ref.substs;"}, {"sha": "7088016e6e6a5d36f0cf69edb0414c2d2590b1b6", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2", "patch": "@@ -101,7 +101,7 @@ impl IntercrateAmbiguityCause {\n }\n \n pub struct SelectionContext<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'tcx>,\n+    pub infcx: &'cx InferCtxt<'tcx>,\n \n     /// Freshener used specifically for entries on the obligation\n     /// stack. This ensures that all entries on the stack at one time\n@@ -237,10 +237,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.intercrate_ambiguity_causes.take().unwrap_or_default()\n     }\n \n-    pub fn infcx(&self) -> &'cx InferCtxt<'tcx> {\n-        self.infcx\n-    }\n-\n     pub fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -693,10 +689,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     match (evaluate(c1), evaluate(c2)) {\n                         (Ok(c1), Ok(c2)) => {\n-                            match self\n-                                .infcx()\n-                                .at(&obligation.cause, obligation.param_env)\n-                                .eq(c1, c2)\n+                            match self.infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n                             {\n                                 Ok(_) => Ok(EvaluatedToOk),\n                                 Err(_) => Ok(EvaluatedToErr),\n@@ -1212,7 +1205,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         let obligation = &stack.obligation;\n-        let predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n+        let predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);\n \n         // Okay to skip binder because of the nature of the\n         // trait-ref-is-knowable check, which does not care about\n@@ -1349,9 +1342,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> smallvec::SmallVec<[(usize, ty::BoundConstness); 2]> {\n-        let poly_trait_predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n+        let poly_trait_predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);\n         let placeholder_trait_predicate =\n-            self.infcx().replace_bound_vars_with_placeholders(poly_trait_predicate);\n+            self.infcx.replace_bound_vars_with_placeholders(poly_trait_predicate);\n         debug!(?placeholder_trait_predicate);\n \n         let tcx = self.infcx.tcx;\n@@ -2131,7 +2124,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<Normalized<'tcx, SubstsRef<'tcx>>, ()> {\n         let placeholder_obligation =\n-            self.infcx().replace_bound_vars_with_placeholders(obligation.predicate);\n+            self.infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n         let placeholder_obligation_trait_ref = placeholder_obligation.trait_ref;\n \n         let impl_substs = self.infcx.fresh_substs_for_item(obligation.cause.span, impl_def_id);"}, {"sha": "a06db4c274831fdf76f01069852c93adadc6e08d", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=6436c348dbaa0eb8f2853dfb64cbf8b30f5119f2", "patch": "@@ -203,13 +203,13 @@ pub fn impl_subject_and_oblig<'a, 'tcx>(\n     let subject = selcx.tcx().bound_impl_subject(impl_def_id);\n     let subject = subject.subst(selcx.tcx(), impl_substs);\n     let InferOk { value: subject, obligations: normalization_obligations1 } = selcx\n-        .infcx()\n+        .infcx\n         .partially_normalize_associated_types_in(ObligationCause::dummy(), param_env, subject);\n \n     let predicates = selcx.tcx().predicates_of(impl_def_id);\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n     let InferOk { value: predicates, obligations: normalization_obligations2 } = selcx\n-        .infcx()\n+        .infcx\n         .partially_normalize_associated_types_in(ObligationCause::dummy(), param_env, predicates);\n     let impl_obligations =\n         super::predicates_for_generics(|_, _| ObligationCause::dummy(), param_env, predicates);"}]}