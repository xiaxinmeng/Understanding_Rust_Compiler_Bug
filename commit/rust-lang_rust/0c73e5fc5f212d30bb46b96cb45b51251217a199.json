{"sha": "0c73e5fc5f212d30bb46b96cb45b51251217a199", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNzNlNWZjNWYyMTJkMzBiYjQ2Yjk2Y2I0NWI1MTI1MTIxN2ExOTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-08T15:36:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-08T15:36:13Z"}, "message": "auto merge of #12809 : eddyb/rust/ty-arena, r=cmr\n\nThis was inspired by seeing a LLVM flatline of **~600MB** when running rustc with jemalloc (each type's `t_box_` is allocated on the heap, creating a lot of fragmentation, which jemalloc can deal with, unlike glibc).", "tree": {"sha": "809db807a9892dc33a0e8bc99bdf6f5475eaa143", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/809db807a9892dc33a0e8bc99bdf6f5475eaa143"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c73e5fc5f212d30bb46b96cb45b51251217a199", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c73e5fc5f212d30bb46b96cb45b51251217a199", "html_url": "https://github.com/rust-lang/rust/commit/0c73e5fc5f212d30bb46b96cb45b51251217a199", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c73e5fc5f212d30bb46b96cb45b51251217a199/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f34760e4173dda94162502153fe4c5a2a96fc9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f34760e4173dda94162502153fe4c5a2a96fc9d", "html_url": "https://github.com/rust-lang/rust/commit/6f34760e4173dda94162502153fe4c5a2a96fc9d"}, {"sha": "8bfbcddf5382ab156b442b08f3236800d0b6ccd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bfbcddf5382ab156b442b08f3236800d0b6ccd8", "html_url": "https://github.com/rust-lang/rust/commit/8bfbcddf5382ab156b442b08f3236800d0b6ccd8"}], "stats": {"total": 4677, "additions": 2299, "deletions": 2378}, "files": [{"sha": "4c71c2df44d3e167ab159ba25cd1f2f3b4d71215", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -32,6 +32,7 @@ use serialize::{json, Encodable};\n \n use std::io;\n use std::io::fs;\n+use arena::TypedArena;\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::{AttrMetaMethods};\n@@ -86,8 +87,9 @@ pub fn compile_input(sess: Session,\n \n         if stop_after_phase_2(&sess) { return; }\n \n+        let type_arena = TypedArena::new();\n         let analysis = phase_3_run_analysis_passes(sess, &expanded_crate,\n-                                                   ast_map, id);\n+                                                   ast_map, &type_arena, id);\n         phase_save_analysis(&analysis.ty_cx.sess, &expanded_crate, &analysis, outdir);\n         if stop_after_phase_3(&analysis.ty_cx.sess) { return; }\n         let (tcx, trans) = phase_4_translate_to_llvm(expanded_crate, analysis);\n@@ -299,11 +301,11 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     Some((krate, map))\n }\n \n-pub struct CrateAnalysis {\n+pub struct CrateAnalysis<'tcx> {\n     pub exp_map2: middle::resolve::ExportMap2,\n     pub exported_items: middle::privacy::ExportedItems,\n     pub public_items: middle::privacy::PublicItems,\n-    pub ty_cx: ty::ctxt,\n+    pub ty_cx: ty::ctxt<'tcx>,\n     pub reachable: NodeSet,\n     pub name: String,\n }\n@@ -312,10 +314,11 @@ pub struct CrateAnalysis {\n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n-pub fn phase_3_run_analysis_passes(sess: Session,\n-                                   krate: &ast::Crate,\n-                                   ast_map: syntax::ast_map::Map,\n-                                   name: String) -> CrateAnalysis {\n+pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n+                                         krate: &ast::Crate,\n+                                         ast_map: syntax::ast_map::Map,\n+                                         type_arena: &'tcx TypedArena<ty::t_box_>,\n+                                         name: String) -> CrateAnalysis<'tcx> {\n     let time_passes = sess.time_passes();\n \n     time(time_passes, \"external crate/lib resolution\", (), |_|\n@@ -362,6 +365,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n                                stability::Index::build(krate));\n \n     let ty_cx = ty::mk_ctxt(sess,\n+                            type_arena,\n                             def_map,\n                             named_region_map,\n                             ast_map,"}, {"sha": "a3227e4dbf1d49064880dda50c839663f9f2087b", "filename": "src/librustc/driver/pretty.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fpretty.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -33,7 +33,7 @@ use graphviz as dot;\n use std::io::{mod, MemReader};\n use std::from_str::FromStr;\n use std::option;\n-\n+use arena::TypedArena;\n \n #[deriving(PartialEq, Show)]\n pub enum PpSourceMode {\n@@ -114,7 +114,9 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n-                let analysis = driver::phase_3_run_analysis_passes(sess, krate, ast_map, id);\n+                let type_arena = TypedArena::new();\n+                let analysis = driver::phase_3_run_analysis_passes(sess, krate, ast_map,\n+                                                                   &type_arena, id);\n                 let annotation = TypedAnnotation { analysis: analysis };\n                 f(&annotation, payload)\n             }\n@@ -260,25 +262,25 @@ impl pprust::PpAnn for HygieneAnnotation {\n }\n \n \n-struct TypedAnnotation {\n-    analysis: CrateAnalysis,\n+struct TypedAnnotation<'tcx> {\n+    analysis: CrateAnalysis<'tcx>,\n }\n \n-impl PrinterSupport for TypedAnnotation {\n+impl<'tcx> PrinterSupport for TypedAnnotation<'tcx> {\n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n }\n \n-impl SessionCarrier for TypedAnnotation {\n+impl<'tcx> SessionCarrier for TypedAnnotation<'tcx> {\n     fn sess<'a>(&'a self) -> &'a Session { &self.analysis.ty_cx.sess }\n }\n \n-impl AstMapCarrier for TypedAnnotation {\n+impl<'tcx> AstMapCarrier for TypedAnnotation<'tcx> {\n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n         Some(&self.analysis.ty_cx.map)\n     }\n }\n \n-impl pprust::PpAnn for TypedAnnotation {\n+impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n     fn pre(&self,\n            s: &mut pprust::State,\n            node: pprust::AnnNode) -> io::IoResult<()> {\n@@ -531,8 +533,9 @@ pub fn pretty_print_input(sess: Session,\n             match code {\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n+                    let type_arena = TypedArena::new();\n                     let analysis = driver::phase_3_run_analysis_passes(sess, &krate,\n-                                                                       ast_map, id);\n+                                                                       ast_map, &type_arena, id);\n                     print_flowgraph(variants, analysis, code, out)\n                 }\n                 None => {"}, {"sha": "c3c4cf51f577540ed5dd0763a427c424377c1140", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -340,11 +340,11 @@ impl LintPass for TypeLimits {\n declare_lint!(CTYPES, Warn,\n               \"proper use of libc types in foreign modules\")\n \n-struct CTypesVisitor<'a> {\n-    cx: &'a Context<'a>\n+struct CTypesVisitor<'a, 'tcx: 'a> {\n+    cx: &'a Context<'a, 'tcx>\n }\n \n-impl<'a> CTypesVisitor<'a> {\n+impl<'a, 'tcx> CTypesVisitor<'a, 'tcx> {\n     fn check_def(&mut self, sp: Span, ty_id: ast::NodeId, path_id: ast::NodeId) {\n         match self.cx.tcx.def_map.borrow().get_copy(&path_id) {\n             def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n@@ -375,7 +375,7 @@ impl<'a> CTypesVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for CTypesVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for CTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n         match ty.node {\n             ast::TyPath(_, _, id) => self.check_def(ty.span, ty.id, id),\n@@ -505,11 +505,11 @@ impl LintPass for HeapMemory {\n declare_lint!(RAW_POINTER_DERIVING, Warn,\n               \"uses of #[deriving] with raw pointers are rarely correct\")\n \n-struct RawPtrDerivingVisitor<'a> {\n-    cx: &'a Context<'a>\n+struct RawPtrDerivingVisitor<'a, 'tcx: 'a> {\n+    cx: &'a Context<'a, 'tcx>\n }\n \n-impl<'a> Visitor<()> for RawPtrDerivingVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for RawPtrDerivingVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n         static MSG: &'static str = \"use of `#[deriving]` with a raw pointer\";\n         match ty.node {"}, {"sha": "26ed5cbfb2cc1b89491c5bfb2fb3502183e11a4f", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -231,9 +231,9 @@ impl LintStore {\n }\n \n /// Context for lint checking.\n-pub struct Context<'a> {\n+pub struct Context<'a, 'tcx: 'a> {\n     /// Type context we're checking in.\n-    pub tcx: &'a ty::ctxt,\n+    pub tcx: &'a ty::ctxt<'tcx>,\n \n     /// The crate being checked.\n     pub krate: &'a ast::Crate,\n@@ -345,10 +345,10 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n     }\n }\n \n-impl<'a> Context<'a> {\n-    fn new(tcx: &'a ty::ctxt,\n+impl<'a, 'tcx> Context<'a, 'tcx> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>,\n            krate: &'a ast::Crate,\n-           exported_items: &'a ExportedItems) -> Context<'a> {\n+           exported_items: &'a ExportedItems) -> Context<'a, 'tcx> {\n         // We want to own the lint store, so move it out of the session.\n         let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(),\n                                       LintStore::new());\n@@ -476,8 +476,8 @@ impl<'a> Context<'a> {\n     }\n }\n \n-impl<'a> AstConv for Context<'a>{\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n+impl<'a, 'tcx> AstConv<'tcx> for Context<'a, 'tcx>{\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n         ty::lookup_item_type(self.tcx, id)\n@@ -492,7 +492,7 @@ impl<'a> AstConv for Context<'a>{\n     }\n }\n \n-impl<'a> Visitor<()> for Context<'a> {\n+impl<'a, 'tcx> Visitor<()> for Context<'a, 'tcx> {\n     fn visit_item(&mut self, it: &ast::Item, _: ()) {\n         self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n             run_lints!(cx, check_item, it);\n@@ -663,7 +663,7 @@ impl<'a> Visitor<()> for Context<'a> {\n }\n \n // Output any lints that were previously added to the session.\n-impl<'a> IdVisitingOperation for Context<'a> {\n+impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n     fn visit_id(&self, id: ast::NodeId) {\n         match self.tcx.sess.lints.borrow_mut().pop(&id) {\n             None => {}"}, {"sha": "a105a56a09b15d9ef0afe3a34bb3a8bcf253b314", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -71,9 +71,9 @@ pub type EncodeInlinedItem<'a> = |ecx: &EncodeContext,\n                                   rbml_w: &mut Encoder,\n                                   ii: InlinedItemRef|: 'a;\n \n-pub struct EncodeParams<'a> {\n+pub struct EncodeParams<'a, 'tcx: 'a> {\n     pub diag: &'a SpanHandler,\n-    pub tcx: &'a ty::ctxt,\n+    pub tcx: &'a ty::ctxt<'tcx>,\n     pub reexports2: &'a middle::resolve::ExportMap2,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n     pub non_inlineable_statics: &'a RefCell<NodeSet>,\n@@ -83,9 +83,9 @@ pub struct EncodeParams<'a> {\n     pub reachable: &'a NodeSet,\n }\n \n-pub struct EncodeContext<'a> {\n+pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub diag: &'a SpanHandler,\n-    pub tcx: &'a ty::ctxt,\n+    pub tcx: &'a ty::ctxt<'tcx>,\n     pub reexports2: &'a middle::resolve::ExportMap2,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n     pub non_inlineable_statics: &'a RefCell<NodeSet>,\n@@ -1793,12 +1793,12 @@ fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &Crate) {\n \n \n \n-struct ImplVisitor<'a,'b:'a,'c:'a> {\n-    ecx: &'a EncodeContext<'b>,\n+struct ImplVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n+    ecx: &'a EncodeContext<'b, 'tcx>,\n     rbml_w: &'a mut Encoder<'c>,\n }\n \n-impl<'a,'b,'c> Visitor<()> for ImplVisitor<'a,'b,'c> {\n+impl<'a, 'b, 'c, 'tcx> Visitor<()> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n         match item.node {\n             ItemImpl(_, Some(ref trait_ref), _, _) => {"}, {"sha": "53203663bb16e080e48165af52a69b12c7bf6406", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -59,11 +59,11 @@ pub enum DefIdSource {\n pub type conv_did<'a> =\n     |source: DefIdSource, ast::DefId|: 'a -> ast::DefId;\n \n-pub struct PState<'a> {\n+pub struct PState<'a, 'tcx: 'a> {\n     data: &'a [u8],\n     krate: ast::CrateNum,\n     pos: uint,\n-    tcx: &'a ty::ctxt\n+    tcx: &'a ty::ctxt<'tcx>\n }\n \n fn peek(st: &PState) -> char {\n@@ -105,8 +105,9 @@ fn parse_ident_(st: &mut PState, is_last: |char| -> bool) -> ast::Ident {\n     })\n }\n \n-pub fn parse_state_from_data<'a>(data: &'a [u8], crate_num: ast::CrateNum,\n-                             pos: uint, tcx: &'a ty::ctxt) -> PState<'a> {\n+pub fn parse_state_from_data<'a, 'tcx>(data: &'a [u8], crate_num: ast::CrateNum,\n+                                       pos: uint, tcx: &'a ty::ctxt<'tcx>)\n+                                       -> PState<'a, 'tcx> {\n     PState {\n         data: data,\n         krate: crate_num,"}, {"sha": "cbf558b6b483e615630ae6fd2640e1de7249f580", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -31,12 +31,12 @@ use rbml::io::SeekableMemWriter;\n \n macro_rules! mywrite( ($($arg:tt)*) => ({ write!($($arg)*); }) )\n \n-pub struct ctxt<'a> {\n+pub struct ctxt<'a, 'tcx: 'a> {\n     pub diag: &'a SpanHandler,\n     // Def -> str Callback:\n     pub ds: fn(DefId) -> String,\n     // The type context.\n-    pub tcx: &'a ty::ctxt,\n+    pub tcx: &'a ty::ctxt<'tcx>,\n     pub abbrevs: &'a abbrev_map\n }\n "}, {"sha": "0e64be3d0b70bbfa347a6f3364a4ed99baa2378d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -54,13 +54,13 @@ use serialize::{EncoderHelpers};\n #[cfg(test)] use syntax::print::pprust;\n #[cfg(test)] use std::gc::Gc;\n \n-struct DecodeContext<'a> {\n+struct DecodeContext<'a, 'tcx: 'a> {\n     cdata: &'a cstore::crate_metadata,\n-    tcx: &'a ty::ctxt,\n+    tcx: &'a ty::ctxt<'tcx>,\n }\n \n-struct ExtendedDecodeContext<'a> {\n-    dcx: &'a DecodeContext<'a>,\n+struct ExtendedDecodeContext<'a, 'tcx: 'a> {\n+    dcx: &'a DecodeContext<'a, 'tcx>,\n     from_id_range: ast_util::IdRange,\n     to_id_range: ast_util::IdRange\n }\n@@ -176,7 +176,7 @@ fn reserve_id_range(sess: &Session,\n     ast_util::IdRange { min: to_id_min, max: to_id_max }\n }\n \n-impl<'a> ExtendedDecodeContext<'a> {\n+impl<'a, 'tcx> ExtendedDecodeContext<'a, 'tcx> {\n     pub fn tr_id(&self, id: ast::NodeId) -> ast::NodeId {\n         /*!\n          * Translates an internal id, meaning a node id that is known\n@@ -382,11 +382,11 @@ fn decode_ast(par_doc: rbml::Doc) -> ast::InlinedItem {\n     Decodable::decode(&mut d).unwrap()\n }\n \n-struct AstRenumberer<'a> {\n-    xcx: &'a ExtendedDecodeContext<'a>,\n+struct AstRenumberer<'a, 'tcx: 'a> {\n+    xcx: &'a ExtendedDecodeContext<'a, 'tcx>,\n }\n \n-impl<'a> ast_map::FoldOps for AstRenumberer<'a> {\n+impl<'a, 'tcx> ast_map::FoldOps for AstRenumberer<'a, 'tcx> {\n     fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n         if id == ast::DUMMY_NODE_ID {\n             // Used by ast_map to map the NodeInlinedParent.\n@@ -914,12 +914,12 @@ fn encode_vec_per_param_space<T>(rbml_w: &mut Encoder,\n // ______________________________________________________________________\n // Encoding and decoding the side tables\n \n-trait get_ty_str_ctxt {\n-    fn ty_str_ctxt<'a>(&'a self) -> tyencode::ctxt<'a>;\n+trait get_ty_str_ctxt<'tcx> {\n+    fn ty_str_ctxt<'a>(&'a self) -> tyencode::ctxt<'a, 'tcx>;\n }\n \n-impl<'a> get_ty_str_ctxt for e::EncodeContext<'a> {\n-    fn ty_str_ctxt<'a>(&'a self) -> tyencode::ctxt<'a> {\n+impl<'a, 'tcx> get_ty_str_ctxt<'tcx> for e::EncodeContext<'a, 'tcx> {\n+    fn ty_str_ctxt<'a>(&'a self) -> tyencode::ctxt<'a, 'tcx> {\n         tyencode::ctxt {\n             diag: self.tcx.sess.diagnostic(),\n             ds: e::def_to_string,"}, {"sha": "df637e7a052dd36473d5de825d3a1c752e3adddc", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -79,14 +79,14 @@ fn owned_ptr_base_path_rc(loan_path: &Rc<LoanPath>) -> Rc<LoanPath> {\n     }\n }\n \n-struct CheckLoanCtxt<'a> {\n-    bccx: &'a BorrowckCtxt<'a>,\n-    dfcx_loans: &'a LoanDataFlow<'a>,\n-    move_data: move_data::FlowedMoveData<'a>,\n+struct CheckLoanCtxt<'a, 'tcx: 'a> {\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n+    dfcx_loans: &'a LoanDataFlow<'a, 'tcx>,\n+    move_data: move_data::FlowedMoveData<'a, 'tcx>,\n     all_loans: &'a [Loan],\n }\n \n-impl<'a> euv::Delegate for CheckLoanCtxt<'a> {\n+impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                consume_span: Span,\n@@ -179,12 +179,12 @@ impl<'a> euv::Delegate for CheckLoanCtxt<'a> {\n     fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) { }\n }\n \n-pub fn check_loans(bccx: &BorrowckCtxt,\n-                   dfcx_loans: &LoanDataFlow,\n-                   move_data: move_data::FlowedMoveData,\n-                   all_loans: &[Loan],\n-                   decl: &ast::FnDecl,\n-                   body: &ast::Block) {\n+pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                     dfcx_loans: &LoanDataFlow<'b, 'tcx>,\n+                                     move_data: move_data::FlowedMoveData<'c, 'tcx>,\n+                                     all_loans: &[Loan],\n+                                     decl: &ast::FnDecl,\n+                                     body: &ast::Block) {\n     debug!(\"check_loans(body id={:?})\", body.id);\n \n     let mut clcx = CheckLoanCtxt {\n@@ -212,8 +212,8 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n     borrow_kind1 == ty::ImmBorrow && borrow_kind2 == ty::ImmBorrow\n }\n \n-impl<'a> CheckLoanCtxt<'a> {\n-    pub fn tcx(&self) -> &'a ty::ctxt { self.bccx.tcx }\n+impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n+    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.bccx.tcx }\n \n     pub fn each_issued_loan(&self, scope_id: ast::NodeId, op: |&Loan| -> bool)\n                             -> bool {"}, {"sha": "e13717e5abd31be1ae23e9a1b91918a6bdcb814e", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -45,8 +45,8 @@ pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n ///////////////////////////////////////////////////////////////////////////\n // Private\n \n-struct GuaranteeLifetimeContext<'a> {\n-    bccx: &'a BorrowckCtxt<'a>,\n+struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n \n     // the node id of the function body for the enclosing item\n     item_scope_id: ast::NodeId,\n@@ -57,7 +57,7 @@ struct GuaranteeLifetimeContext<'a> {\n     cmt_original: mc::cmt\n }\n \n-impl<'a> GuaranteeLifetimeContext<'a> {\n+impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n \n     fn check(&self, cmt: &mc::cmt, discr_scope: Option<ast::NodeId>) -> R {\n         //! Main routine. Walks down `cmt` until we find the \"guarantor\"."}, {"sha": "11189390df565921317ae28cb11b24c1bc6b00bb", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -57,15 +57,15 @@ pub fn gather_loans_in_fn(bccx: &BorrowckCtxt,\n     (all_loans, move_data)\n }\n \n-struct GatherLoanCtxt<'a> {\n-    bccx: &'a BorrowckCtxt<'a>,\n+struct GatherLoanCtxt<'a, 'tcx: 'a> {\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     move_data: move_data::MoveData,\n     move_error_collector: move_error::MoveErrorCollector,\n     all_loans: Vec<Loan>,\n     item_ub: ast::NodeId,\n }\n \n-impl<'a> euv::Delegate for GatherLoanCtxt<'a> {\n+impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                _consume_span: Span,\n@@ -204,8 +204,8 @@ fn check_aliasability(bccx: &BorrowckCtxt,\n     }\n }\n \n-impl<'a> GatherLoanCtxt<'a> {\n-    pub fn tcx(&self) -> &'a ty::ctxt { self.bccx.tcx }\n+impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n+    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.bccx.tcx }\n \n     fn guarantee_valid(&mut self,\n                        borrow_id: ast::NodeId,\n@@ -467,11 +467,11 @@ impl<'a> GatherLoanCtxt<'a> {\n ///\n /// This visitor walks static initializer's expressions and makes\n /// sure the loans being taken are sound.\n-struct StaticInitializerCtxt<'a> {\n-    bccx: &'a BorrowckCtxt<'a>\n+struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>\n }\n \n-impl<'a> visit::Visitor<()> for StaticInitializerCtxt<'a> {\n+impl<'a, 'tcx> visit::Visitor<()> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         match ex.node {\n             ast::ExprAddrOf(mutbl, ref base) => {"}, {"sha": "90e17e4d79cbbce8eec47ea28e653f76e9a5c466", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -44,14 +44,14 @@ pub fn compute_restrictions(bccx: &BorrowckCtxt,\n ///////////////////////////////////////////////////////////////////////////\n // Private\n \n-struct RestrictionsContext<'a> {\n-    bccx: &'a BorrowckCtxt<'a>,\n+struct RestrictionsContext<'a, 'tcx: 'a> {\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     span: Span,\n     loan_region: ty::Region,\n     cause: euv::LoanCause,\n }\n \n-impl<'a> RestrictionsContext<'a> {\n+impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n     fn restrict(&self,\n                 cmt: mc::cmt) -> RestrictionResult {\n         debug!(\"restrict(cmt={})\", cmt.repr(self.bccx.tcx));"}, {"sha": "e75378de5a5c791b5bf495ffc8bd79b5f5a4c474", "filename": "src/librustc/middle/borrowck/graphviz.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -43,14 +43,14 @@ impl Variant {\n     }\n }\n \n-pub struct DataflowLabeller<'a> {\n+pub struct DataflowLabeller<'a, 'tcx: 'a> {\n     pub inner: cfg_dot::LabelledCFG<'a>,\n     pub variants: Vec<Variant>,\n-    pub borrowck_ctxt: &'a BorrowckCtxt<'a>,\n-    pub analysis_data: &'a borrowck::AnalysisData<'a>,\n+    pub borrowck_ctxt: &'a BorrowckCtxt<'a, 'tcx>,\n+    pub analysis_data: &'a borrowck::AnalysisData<'a, 'tcx>,\n }\n \n-impl<'a> DataflowLabeller<'a> {\n+impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n     fn dataflow_for(&self, e: EntryOrExit, n: &Node<'a>) -> String {\n         let id = n.val1().data.id;\n         debug!(\"dataflow_for({}, id={}) {}\", e, id, self.variants);\n@@ -77,7 +77,7 @@ impl<'a> DataflowLabeller<'a> {\n     fn build_set<O:DataFlowOperator>(&self,\n                                      e: EntryOrExit,\n                                      cfgidx: CFGIndex,\n-                                     dfcx: &DataFlowContext<'a, O>,\n+                                     dfcx: &DataFlowContext<'a, 'tcx, O>,\n                                      to_lp: |uint| -> Rc<LoanPath>) -> String {\n         let mut saw_some = false;\n         let mut set = \"{\".to_string();\n@@ -126,7 +126,7 @@ impl<'a> DataflowLabeller<'a> {\n     }\n }\n \n-impl<'a> dot::Labeller<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a> {\n+impl<'a, 'tcx> dot::Labeller<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a, 'tcx> {\n     fn graph_id(&'a self) -> dot::Id<'a> { self.inner.graph_id() }\n     fn node_id(&'a self, n: &Node<'a>) -> dot::Id<'a> { self.inner.node_id(n) }\n     fn node_label(&'a self, n: &Node<'a>) -> dot::LabelText<'a> {\n@@ -140,7 +140,7 @@ impl<'a> dot::Labeller<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a> {\n     fn edge_label(&'a self, e: &Edge<'a>) -> dot::LabelText<'a> { self.inner.edge_label(e) }\n }\n \n-impl<'a> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a> {\n+impl<'a, 'tcx> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a, 'tcx> {\n     fn nodes(&self) -> dot::Nodes<'a, Node<'a>> { self.inner.nodes() }\n     fn edges(&self) -> dot::Edges<'a, Edge<'a>> { self.inner.edges() }\n     fn source(&self, edge: &Edge<'a>) -> Node<'a> { self.inner.source(edge) }"}, {"sha": "f4d3678271c0ded7c8d6c26a980f60b9ce947688", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -58,9 +58,9 @@ pub mod move_data;\n #[deriving(Clone)]\n pub struct LoanDataFlowOperator;\n \n-pub type LoanDataFlow<'a> = DataFlowContext<'a, LoanDataFlowOperator>;\n+pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator>;\n \n-impl<'a> Visitor<()> for BorrowckCtxt<'a> {\n+impl<'a, 'tcx> Visitor<()> for BorrowckCtxt<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl,\n                 b: &Block, s: Span, n: NodeId, _: ()) {\n         borrowck_fn(self, fk, fd, b, s, n);\n@@ -120,10 +120,10 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n }\n \n /// Collection of conclusions determined via borrow checker analyses.\n-pub struct AnalysisData<'a> {\n+pub struct AnalysisData<'a, 'tcx: 'a> {\n     pub all_loans: Vec<Loan>,\n-    pub loans: DataFlowContext<'a, LoanDataFlowOperator>,\n-    pub move_data: move_data::FlowedMoveData<'a>,\n+    pub loans: DataFlowContext<'a, 'tcx, LoanDataFlowOperator>,\n+    pub move_data: move_data::FlowedMoveData<'a, 'tcx>,\n }\n \n fn borrowck_fn(this: &mut BorrowckCtxt,\n@@ -145,13 +145,13 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     visit::walk_fn(this, fk, decl, body, sp, ());\n }\n \n-fn build_borrowck_dataflow_data<'a>(this: &mut BorrowckCtxt<'a>,\n-                                    fk: &FnKind,\n-                                    decl: &ast::FnDecl,\n-                                    cfg: &cfg::CFG,\n-                                    body: &ast::Block,\n-                                    sp: Span,\n-                                    id: ast::NodeId) -> AnalysisData<'a> {\n+fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n+                                          fk: &FnKind,\n+                                          decl: &ast::FnDecl,\n+                                          cfg: &cfg::CFG,\n+                                          body: &ast::Block,\n+                                          sp: Span,\n+                                          id: ast::NodeId) -> AnalysisData<'a, 'tcx> {\n     // Check the body of fn items.\n     let id_range = ast_util::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n     let (all_loans, move_data) =\n@@ -200,9 +200,9 @@ impl<'a> FnPartsWithCFG<'a> {\n \n /// Accessor for introspective clients inspecting `AnalysisData` and\n /// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n-pub fn build_borrowck_dataflow_data_for_fn<'a>(\n-    tcx: &'a ty::ctxt,\n-    input: FnPartsWithCFG<'a>) -> (BorrowckCtxt<'a>, AnalysisData<'a>) {\n+pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n+    tcx: &'a ty::ctxt<'tcx>,\n+    input: FnPartsWithCFG<'a>) -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>) {\n \n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n@@ -230,8 +230,8 @@ pub fn build_borrowck_dataflow_data_for_fn<'a>(\n // ----------------------------------------------------------------------\n // Type definitions\n \n-pub struct BorrowckCtxt<'a> {\n-    tcx: &'a ty::ctxt,\n+pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n \n     // Statistics:\n     stats: Gc<BorrowStats>,\n@@ -390,7 +390,7 @@ pub enum MovedValueUseKind {\n ///////////////////////////////////////////////////////////////////////////\n // Misc\n \n-impl<'a> BorrowckCtxt<'a> {\n+impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region)\n                            -> bool {\n         self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n@@ -401,7 +401,7 @@ impl<'a> BorrowckCtxt<'a> {\n         self.tcx.region_maps.is_subscope_of(r_sub, r_sup)\n     }\n \n-    pub fn mc(&self) -> mc::MemCategorizationContext<'a,ty::ctxt> {\n+    pub fn mc(&self) -> mc::MemCategorizationContext<'a, ty::ctxt<'tcx>> {\n         mc::MemCategorizationContext::new(self.tcx)\n     }\n "}, {"sha": "fdd16c886866d3e0e9dbc6235723f6ec99a80656", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -56,15 +56,15 @@ pub struct MoveData {\n     pub assignee_ids: RefCell<HashSet<ast::NodeId>>,\n }\n \n-pub struct FlowedMoveData<'a> {\n+pub struct FlowedMoveData<'a, 'tcx: 'a> {\n     pub move_data: MoveData,\n \n-    pub dfcx_moves: MoveDataFlow<'a>,\n+    pub dfcx_moves: MoveDataFlow<'a, 'tcx>,\n \n     // We could (and maybe should, for efficiency) combine both move\n     // and assign data flow into one, but this way it's easier to\n     // distinguish the bits that correspond to moves and assignments.\n-    pub dfcx_assign: AssignDataFlow<'a>\n+    pub dfcx_assign: AssignDataFlow<'a, 'tcx>\n }\n \n /// Index into `MoveData.paths`, used like a pointer\n@@ -154,12 +154,12 @@ pub struct Assignment {\n #[deriving(Clone)]\n pub struct MoveDataFlowOperator;\n \n-pub type MoveDataFlow<'a> = DataFlowContext<'a, MoveDataFlowOperator>;\n+pub type MoveDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, MoveDataFlowOperator>;\n \n #[deriving(Clone)]\n pub struct AssignDataFlowOperator;\n \n-pub type AssignDataFlow<'a> = DataFlowContext<'a, AssignDataFlowOperator>;\n+pub type AssignDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, AssignDataFlowOperator>;\n \n fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n     match *loan_path {\n@@ -531,14 +531,14 @@ impl MoveData {\n     }\n }\n \n-impl<'a> FlowedMoveData<'a> {\n+impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     pub fn new(move_data: MoveData,\n-               tcx: &'a ty::ctxt,\n+               tcx: &'a ty::ctxt<'tcx>,\n                cfg: &cfg::CFG,\n                id_range: ast_util::IdRange,\n                decl: &ast::FnDecl,\n                body: &ast::Block)\n-               -> FlowedMoveData<'a> {\n+               -> FlowedMoveData<'a, 'tcx> {\n         let mut dfcx_moves =\n             DataFlowContext::new(tcx,\n                                  \"flowed_move_data_moves\","}, {"sha": "ec414b858187aae059be33986fa1f50f468abe1f", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -19,8 +19,8 @@ use util::nodemap::NodeMap;\n \n use std::gc::Gc;\n \n-struct CFGBuilder<'a> {\n-    tcx: &'a ty::ctxt,\n+struct CFGBuilder<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     exit_map: NodeMap<CFGIndex>,\n     graph: CFGGraph,\n     fn_exit: CFGIndex,\n@@ -65,7 +65,7 @@ fn add_initial_dummy_node(g: &mut CFGGraph) -> CFGIndex {\n     g.add_node(CFGNodeData { id: ast::DUMMY_NODE_ID })\n }\n \n-impl<'a> CFGBuilder<'a> {\n+impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n         for stmt in blk.stmts.iter() {"}, {"sha": "3c8db8d048076cae439776cbb65957c76a6692da", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -21,11 +21,11 @@ use syntax::{ast_util, ast_map};\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-pub struct CheckCrateVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+pub struct CheckCrateVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n }\n \n-impl<'a> Visitor<bool> for CheckCrateVisitor<'a> {\n+impl<'a, 'tcx> Visitor<bool> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &Item, env: bool) {\n         check_item(self, i, env);\n     }"}, {"sha": "6676ea9851db0113bbfb9ab11be9ac32266c0625", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -86,8 +86,8 @@ impl FromIterator<Vec<Gc<Pat>>> for Matrix {\n     }\n }\n \n-pub struct MatchCheckCtxt<'a> {\n-    pub tcx: &'a ty::ctxt\n+pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n+    pub tcx: &'a ty::ctxt<'tcx>\n }\n \n #[deriving(Clone, PartialEq)]\n@@ -119,7 +119,7 @@ enum WitnessPreference {\n     LeaveOutWitness\n }\n \n-impl<'a> Visitor<()> for MatchCheckCtxt<'a> {\n+impl<'a, 'tcx> Visitor<()> for MatchCheckCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         check_expr(self, ex);\n     }\n@@ -304,21 +304,21 @@ fn const_val_to_expr(value: &const_val) -> Gc<Expr> {\n     }\n }\n \n-pub struct StaticInliner<'a> {\n-    pub tcx: &'a ty::ctxt,\n+pub struct StaticInliner<'a, 'tcx: 'a> {\n+    pub tcx: &'a ty::ctxt<'tcx>,\n     pub failed: bool\n }\n \n-impl<'a> StaticInliner<'a> {\n-    pub fn new<'a>(tcx: &'a ty::ctxt) -> StaticInliner<'a> {\n+impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n+    pub fn new<'a>(tcx: &'a ty::ctxt<'tcx>) -> StaticInliner<'a, 'tcx> {\n         StaticInliner {\n             tcx: tcx,\n             failed: false\n         }\n     }\n }\n \n-impl<'a> Folder for StaticInliner<'a> {\n+impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: Gc<Pat>) -> Gc<Pat> {\n         match pat.node {\n             PatIdent(..) | PatEnum(..) => {\n@@ -963,19 +963,19 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n \n /// Ensures that a pattern guard doesn't borrow by mutable reference or\n /// assign.\n-fn check_for_mutation_in_guard<'a>(cx: &'a MatchCheckCtxt<'a>, guard: &Expr) {\n+fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>, guard: &Expr) {\n     let mut checker = MutationChecker {\n         cx: cx,\n     };\n     let mut visitor = ExprUseVisitor::new(&mut checker, checker.cx.tcx);\n     visitor.walk_expr(guard);\n }\n \n-struct MutationChecker<'a> {\n-    cx: &'a MatchCheckCtxt<'a>,\n+struct MutationChecker<'a, 'tcx: 'a> {\n+    cx: &'a MatchCheckCtxt<'a, 'tcx>,\n }\n \n-impl<'a> Delegate for MutationChecker<'a> {\n+impl<'a, 'tcx> Delegate for MutationChecker<'a, 'tcx> {\n     fn consume(&mut self, _: NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n     fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}\n     fn borrow(&mut self,\n@@ -1020,11 +1020,11 @@ fn check_legality_of_bindings_in_at_patterns(cx: &MatchCheckCtxt, pat: &Pat) {\n     visitor.visit_pat(pat, true);\n }\n \n-struct AtBindingPatternVisitor<'a,'b:'a> {\n-    cx: &'a MatchCheckCtxt<'b>,\n+struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n+    cx: &'a MatchCheckCtxt<'b, 'tcx>,\n }\n \n-impl<'a,'b> Visitor<bool> for AtBindingPatternVisitor<'a,'b> {\n+impl<'a, 'b, 'tcx> Visitor<bool> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n     fn visit_pat(&mut self, pat: &Pat, bindings_allowed: bool) {\n         if !bindings_allowed && pat_is_binding(&self.cx.tcx.def_map, pat) {\n             self.cx.tcx.sess.span_err(pat.span,"}, {"sha": "f851ddbeeac238f3e88b6d389c84296e9b1bbbcd", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -26,11 +26,11 @@ pub fn check_crate(tcx: &ty::ctxt,\n     visit::walk_crate(&mut rvcx, krate, ());\n }\n \n-struct RvalueContext<'a> {\n-    tcx: &'a ty::ctxt\n+struct RvalueContext<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>\n }\n \n-impl<'a> visit::Visitor<()> for RvalueContext<'a> {\n+impl<'a, 'tcx> visit::Visitor<()> for RvalueContext<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 _: &visit::FnKind,\n                 fd: &ast::FnDecl,\n@@ -43,7 +43,7 @@ impl<'a> visit::Visitor<()> for RvalueContext<'a> {\n     }\n }\n \n-impl<'a> euv::Delegate for RvalueContext<'a> {\n+impl<'a, 'tcx> euv::Delegate for RvalueContext<'a, 'tcx> {\n     fn consume(&mut self,\n                _: ast::NodeId,\n                span: Span,"}, {"sha": "7b00bb4589c71e8983c2aaaea38d992b8d655d44", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -52,15 +52,15 @@ fn safe_type_for_static_mut(cx: &ty::ctxt, e: &ast::Expr) -> Option<String> {\n     Some(format!(\"mutable static items are not allowed to have {}\", suffix))\n }\n \n-struct CheckStaticVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct CheckStaticVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n }\n \n pub fn check_crate(tcx: &ty::ctxt, krate: &ast::Crate) {\n     visit::walk_crate(&mut CheckStaticVisitor { tcx: tcx }, krate, false)\n }\n \n-impl<'a> CheckStaticVisitor<'a> {\n+impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n     fn report_error(&self, span: Span, result: Option<String>) -> bool {\n         match result {\n             None => { false }\n@@ -72,7 +72,7 @@ impl<'a> CheckStaticVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n+impl<'a, 'tcx> Visitor<bool> for CheckStaticVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, i: &ast::Item, _is_const: bool) {\n         debug!(\"visit_item(item={})\", pprust::item_to_string(i));"}, {"sha": "e853b5961ec4fa4b2ef60246efa8764d33d07ed1", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -176,12 +176,12 @@ pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n     }\n }\n \n-struct ConstEvalVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct ConstEvalVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     ccache: constness_cache,\n }\n \n-impl<'a> ConstEvalVisitor<'a> {\n+impl<'a, 'tcx> ConstEvalVisitor<'a, 'tcx> {\n     fn classify(&mut self, e: &Expr) -> constness {\n         let did = ast_util::local_def(e.id);\n         match self.ccache.find(&did) {\n@@ -266,7 +266,7 @@ impl<'a> ConstEvalVisitor<'a> {\n \n }\n \n-impl<'a> Visitor<()> for ConstEvalVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for ConstEvalVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &Ty, _: ()) {\n         match t.node {\n             TyFixedLengthVec(_, expr) => {\n@@ -365,8 +365,7 @@ pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n     }\n }\n \n-pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n-                            -> Result<const_val, String> {\n+pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, String> {\n     fn fromb(b: bool) -> Result<const_val, String> { Ok(const_int(b as i64)) }\n     match e.node {\n       ExprUnary(UnNeg, ref inner) => {\n@@ -494,12 +493,11 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n         // This tends to get called w/o the type actually having been\n         // populated in the ctxt, which was causing things to blow up\n         // (#5900). Fall back to doing a limited lookup to get past it.\n-        let ety = ty::expr_ty_opt(tcx.ty_ctxt(), e)\n-                .or_else(|| astconv::ast_ty_to_prim_ty(tcx.ty_ctxt(), &**target_ty))\n+        let ety = ty::expr_ty_opt(tcx, e)\n+                .or_else(|| astconv::ast_ty_to_prim_ty(tcx, &**target_ty))\n                 .unwrap_or_else(|| {\n-                    tcx.ty_ctxt().sess.span_fatal(target_ty.span,\n-                                                  \"target type not found for \\\n-                                                   const cast\")\n+                    tcx.sess.span_fatal(target_ty.span,\n+                                        \"target type not found for const cast\")\n                 });\n \n         let base = eval_const_expr_partial(tcx, &**base);\n@@ -540,8 +538,8 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n         }\n       }\n       ExprPath(_) => {\n-          match lookup_const(tcx.ty_ctxt(), e) {\n-              Some(actual_e) => eval_const_expr_partial(tcx.ty_ctxt(), &*actual_e),\n+          match lookup_const(tcx, e) {\n+              Some(actual_e) => eval_const_expr_partial(tcx, &*actual_e),\n               None => Err(\"non-constant path in constant expr\".to_string())\n           }\n       }"}, {"sha": "c32f8db2380e428456e96553142398e8622a9962", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -32,8 +32,8 @@ use util::nodemap::NodeMap;\n pub enum EntryOrExit { Entry, Exit }\n \n #[deriving(Clone)]\n-pub struct DataFlowContext<'a, O> {\n-    tcx: &'a ty::ctxt,\n+pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n+    tcx: &'a ty::ctxt<'tcx>,\n \n     /// a name for the analysis using this dataflow instance\n     analysis_name: &'static str,\n@@ -80,8 +80,8 @@ pub trait DataFlowOperator : BitwiseOperator {\n     fn initial_value(&self) -> bool;\n }\n \n-struct PropagationContext<'a, 'b:'a, O:'a> {\n-    dfcx: &'a mut DataFlowContext<'b, O>,\n+struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O: 'a> {\n+    dfcx: &'a mut DataFlowContext<'b, 'tcx, O>,\n     changed: bool\n }\n \n@@ -92,14 +92,14 @@ fn to_cfgidx_or_die(id: ast::NodeId, index: &NodeMap<CFGIndex>) -> CFGIndex {\n     })\n }\n \n-impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n+impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     fn has_bitset_for_nodeid(&self, n: ast::NodeId) -> bool {\n         assert!(n != ast::DUMMY_NODE_ID);\n         self.nodeid_to_index.contains_key(&n)\n     }\n }\n \n-impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n+impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O> {\n     fn pre(&self,\n            ps: &mut pprust::State,\n            node: pprust::AnnNode) -> io::IoResult<()> {\n@@ -182,14 +182,14 @@ fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n     }\n }\n \n-impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n-    pub fn new(tcx: &'a ty::ctxt,\n+impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n+    pub fn new(tcx: &'a ty::ctxt<'tcx>,\n                analysis_name: &'static str,\n                decl: Option<&ast::FnDecl>,\n                cfg: &cfg::CFG,\n                oper: O,\n                id_range: IdRange,\n-               bits_per_id: uint) -> DataFlowContext<'a, O> {\n+               bits_per_id: uint) -> DataFlowContext<'a, 'tcx, O> {\n         let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n         let num_nodes = cfg.graph.all_nodes().len();\n \n@@ -427,8 +427,8 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n     }\n }\n \n-impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n-//                          ^^^^^^^^^^^^^ only needed for pretty printing\n+impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n+//                                ^^^^^^^^^^^^^ only needed for pretty printing\n     pub fn propagate(&mut self, cfg: &cfg::CFG, blk: &ast::Block) {\n         //! Performs the data flow analysis.\n \n@@ -469,7 +469,7 @@ impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n     }\n }\n \n-impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n+impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n     fn walk_cfg(&mut self,\n                 cfg: &cfg::CFG,\n                 in_out: &mut [uint]) {"}, {"sha": "b7cddd0c23f964876451b05e06c22b815d9070af", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -47,9 +47,9 @@ fn should_explore(tcx: &ty::ctxt, def_id: ast::DefId) -> bool {\n     }\n }\n \n-struct MarkSymbolVisitor<'a> {\n+struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<ast::NodeId>,\n-    tcx: &'a ty::ctxt,\n+    tcx: &'a ty::ctxt<'tcx>,\n     live_symbols: Box<HashSet<ast::NodeId>>,\n }\n \n@@ -58,9 +58,9 @@ struct MarkSymbolVisitorContext {\n     struct_has_extern_repr: bool\n }\n \n-impl<'a> MarkSymbolVisitor<'a> {\n-    fn new(tcx: &'a ty::ctxt,\n-           worklist: Vec<ast::NodeId>) -> MarkSymbolVisitor<'a> {\n+impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>,\n+           worklist: Vec<ast::NodeId>) -> MarkSymbolVisitor<'a, 'tcx> {\n         MarkSymbolVisitor {\n             worklist: worklist,\n             tcx: tcx,\n@@ -232,7 +232,7 @@ impl<'a> MarkSymbolVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<MarkSymbolVisitorContext> for MarkSymbolVisitor<'a> {\n+impl<'a, 'tcx> Visitor<MarkSymbolVisitorContext> for MarkSymbolVisitor<'a, 'tcx> {\n \n     fn visit_struct_def(&mut self, def: &ast::StructDef, _: ast::Ident, _: &ast::Generics,\n                         _: ast::NodeId, ctxt: MarkSymbolVisitorContext) {\n@@ -418,12 +418,12 @@ fn get_struct_ctor_id(item: &ast::Item) -> Option<ast::NodeId> {\n     }\n }\n \n-struct DeadVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct DeadVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     live_symbols: Box<HashSet<ast::NodeId>>,\n }\n \n-impl<'a> DeadVisitor<'a> {\n+impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     fn should_warn_about_field(&mut self, node: &ast::StructField_) -> bool {\n         let is_named = node.ident().is_some();\n         let field_type = ty::node_id_to_type(self.tcx, node.id);\n@@ -490,7 +490,7 @@ impl<'a> DeadVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for DeadVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for DeadVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         let ctor_id = get_struct_ctor_id(item);\n         if !self.symbol_is_live(item.id, ctor_id) && should_warn(item) {"}, {"sha": "ec1430edcddb9c1e02a23edcaff134eedfb34660", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -37,14 +37,14 @@ fn type_is_unsafe_function(ty: ty::t) -> bool {\n     }\n }\n \n-struct EffectCheckVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct EffectCheckVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n \n     /// Whether we're in an unsafe context.\n     unsafe_context: UnsafeContext,\n }\n \n-impl<'a> EffectCheckVisitor<'a> {\n+impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n     fn require_unsafe(&mut self, span: Span, description: &str) {\n         match self.unsafe_context {\n             SafeContext => {\n@@ -86,7 +86,7 @@ impl<'a> EffectCheckVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_fn(&mut self, fn_kind: &visit::FnKind, fn_decl: &ast::FnDecl,\n                 block: &ast::Block, span: Span, _: ast::NodeId, _:()) {\n "}, {"sha": "207620b182907b9229985313f9a998bdf3ea29f4", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -214,7 +214,7 @@ macro_rules! return_if_err(\n     )\n )\n \n-impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n+impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n     pub fn new(delegate: &'d mut Delegate,\n                typer: &'t TYPER)\n                -> ExprUseVisitor<'d,'t,TYPER> {\n@@ -246,7 +246,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         }\n     }\n \n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+    fn tcx(&self) -> &'t ty::ctxt<'tcx> {\n         self.typer.tcx()\n     }\n "}, {"sha": "df5a6b6d2a113003dcbf2e39329bebeb67ec51f6", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -180,7 +180,7 @@ pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[freevar_entry]|\n     }\n }\n \n-pub fn get_capture_mode<T:Typer>(tcx: &T, closure_expr_id: ast::NodeId)\n-                        -> CaptureMode {\n+pub fn get_capture_mode<'tcx, T:Typer<'tcx>>(tcx: &T, closure_expr_id: ast::NodeId)\n+                                             -> CaptureMode {\n     tcx.capture_mode(closure_expr_id)\n }"}, {"sha": "25a8555565c93ae8e6e62a75ee0461431fd2ef97", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -67,11 +67,11 @@ fn type_size_is_affected_by_type_parameters(tcx: &ty::ctxt, typ: ty::t)\n     result\n }\n \n-struct IntrinsicCheckingVisitor<'a> {\n-    tcx: &'a ctxt,\n+struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ctxt<'tcx>,\n }\n \n-impl<'a> IntrinsicCheckingVisitor<'a> {\n+impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n         let intrinsic = match ty::get(ty::lookup_item_type(self.tcx, def_id).ty).sty {\n             ty::ty_bare_fn(ref bfty) => bfty.abi == RustIntrinsic,\n@@ -116,7 +116,7 @@ impl<'a> IntrinsicCheckingVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for IntrinsicCheckingVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr, (): ()) {\n         match expr.node {\n             ast::ExprPath(..) => {"}, {"sha": "e556c5a59c224696dcb3540358084453a8c0e4d0", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -50,13 +50,13 @@ use syntax::visit;\n // primitives in the stdlib are explicitly annotated to only take sendable\n // types.\n \n-pub struct Context<'a> {\n-    tcx: &'a ty::ctxt,\n+pub struct Context<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     struct_and_enum_bounds_checked: HashSet<ty::t>,\n     parameter_environments: Vec<ParameterEnvironment>,\n }\n \n-impl<'a> Visitor<()> for Context<'a> {\n+impl<'a, 'tcx> Visitor<()> for Context<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         check_expr(self, ex);\n     }\n@@ -94,11 +94,11 @@ pub fn check_crate(tcx: &ty::ctxt,\n     tcx.sess.abort_if_errors();\n }\n \n-struct EmptySubstsFolder<'a> {\n-    tcx: &'a ty::ctxt\n+struct EmptySubstsFolder<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>\n }\n-impl<'a> ty_fold::TypeFolder for EmptySubstsFolder<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for EmptySubstsFolder<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.tcx\n     }\n     fn fold_substs(&mut self, _: &subst::Substs) -> subst::Substs {"}, {"sha": "26aa51b909944cff987fa77254b257d98d59f700", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -179,7 +179,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, cx: &ty::ctxt) -> String {\n     }\n }\n \n-impl<'a> Visitor<()> for IrMaps<'a> {\n+impl<'a, 'tcx> Visitor<()> for IrMaps<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, _: ()) {\n         visit_fn(self, fk, fd, b, s, n);\n     }\n@@ -252,8 +252,8 @@ enum VarKind {\n     ImplicitRet\n }\n \n-struct IrMaps<'a> {\n-    tcx: &'a ty::ctxt,\n+struct IrMaps<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n \n     num_live_nodes: uint,\n     num_vars: uint,\n@@ -264,8 +264,8 @@ struct IrMaps<'a> {\n     lnks: Vec<LiveNodeKind>,\n }\n \n-impl<'a> IrMaps<'a> {\n-    fn new(tcx: &'a ty::ctxt) -> IrMaps<'a> {\n+impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>) -> IrMaps<'a, 'tcx> {\n         IrMaps {\n             tcx: tcx,\n             num_live_nodes: 0,\n@@ -343,7 +343,7 @@ impl<'a> IrMaps<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for Liveness<'a> {\n+impl<'a, 'tcx> Visitor<()> for Liveness<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, _: ()) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n@@ -555,8 +555,8 @@ static ACC_READ: uint = 1u;\n static ACC_WRITE: uint = 2u;\n static ACC_USE: uint = 4u;\n \n-struct Liveness<'a> {\n-    ir: &'a mut IrMaps<'a>,\n+struct Liveness<'a, 'tcx: 'a> {\n+    ir: &'a mut IrMaps<'a, 'tcx>,\n     s: Specials,\n     successors: Vec<LiveNode>,\n     users: Vec<Users>,\n@@ -570,8 +570,8 @@ struct Liveness<'a> {\n     cont_ln: NodeMap<LiveNode>\n }\n \n-impl<'a> Liveness<'a> {\n-    fn new(ir: &'a mut IrMaps<'a>, specials: Specials) -> Liveness<'a> {\n+impl<'a, 'tcx> Liveness<'a, 'tcx> {\n+    fn new(ir: &'a mut IrMaps<'a, 'tcx>, specials: Specials) -> Liveness<'a, 'tcx> {\n         let num_live_nodes = ir.num_live_nodes;\n         let num_vars = ir.num_vars;\n         Liveness {\n@@ -607,7 +607,7 @@ impl<'a> Liveness<'a> {\n \n     fn pat_bindings(&mut self,\n                     pat: &Pat,\n-                    f: |&mut Liveness<'a>, LiveNode, Variable, Span, NodeId|) {\n+                    f: |&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId|) {\n         pat_util::pat_bindings(&self.ir.tcx.def_map, pat, |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n@@ -617,7 +617,7 @@ impl<'a> Liveness<'a> {\n \n     fn arm_pats_bindings(&mut self,\n                          pats: &[Gc<Pat>],\n-                         f: |&mut Liveness<'a>, LiveNode, Variable, Span, NodeId|) {\n+                         f: |&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId|) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n         // the \"authoritative\" set of ids\n@@ -683,7 +683,7 @@ impl<'a> Liveness<'a> {\n     fn indices2(&mut self,\n                 ln: LiveNode,\n                 succ_ln: LiveNode,\n-                op: |&mut Liveness<'a>, uint, uint|) {\n+                op: |&mut Liveness<'a, 'tcx>, uint, uint|) {\n         let node_base_idx = self.idx(ln, Variable(0u));\n         let succ_base_idx = self.idx(succ_ln, Variable(0u));\n         for var_idx in range(0u, self.ir.num_vars) {\n@@ -1376,7 +1376,7 @@ impl<'a> Liveness<'a> {\n                           loop_node_id: NodeId,\n                           break_ln: LiveNode,\n                           cont_ln: LiveNode,\n-                          f: |&mut Liveness<'a>| -> R)\n+                          f: |&mut Liveness<'a, 'tcx>| -> R)\n                           -> R {\n         debug!(\"with_loop_nodes: {} {}\", loop_node_id, break_ln.get());\n         self.loop_scope.push(loop_node_id);\n@@ -1465,7 +1465,7 @@ fn check_fn(_v: &Liveness,\n     // do not check contents of nested fns\n }\n \n-impl<'a> Liveness<'a> {\n+impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_ret(&self,\n                  id: NodeId,\n                  sp: Span,"}, {"sha": "abed04c8f33acf7cf90f98d4dc151af9521822b2", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -264,8 +264,8 @@ pub type McResult<T> = Result<T, ()>;\n  * know that no errors have occurred, so we simply consult the tcx and we\n  * can be sure that only `Ok` results will occur.\n  */\n-pub trait Typer {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n+pub trait Typer<'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n     fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t>;\n     fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t>;\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>>;\n@@ -375,12 +375,12 @@ macro_rules! if_ok(\n     )\n )\n \n-impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n+impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn new(typer: &'t TYPER) -> MemCategorizationContext<'t,TYPER> {\n         MemCategorizationContext { typer: typer }\n     }\n \n-    fn tcx(&self) -> &'t ty::ctxt {\n+    fn tcx(&self) -> &'t ty::ctxt<'tcx> {\n         self.typer.tcx()\n     }\n "}, {"sha": "6017444267a4f2b7583962b05c162e0b60ebfab6", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -133,8 +133,8 @@ impl Visitor<()> for ParentVisitor {\n /// The embargo visitor, used to determine the exports of the ast\n ////////////////////////////////////////////////////////////////////////////////\n \n-struct EmbargoVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct EmbargoVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     exp_map2: &'a resolve::ExportMap2,\n \n     // This flag is an indicator of whether the previous item in the\n@@ -163,7 +163,7 @@ struct EmbargoVisitor<'a> {\n     prev_public: bool,\n }\n \n-impl<'a> EmbargoVisitor<'a> {\n+impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     // There are checks inside of privacy which depend on knowing whether a\n     // trait should be exported or not. The two current consumers of this are:\n     //\n@@ -180,7 +180,7 @@ impl<'a> EmbargoVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for EmbargoVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         let orig_all_pub = self.prev_public;\n         self.prev_public = orig_all_pub && item.vis == ast::Public;\n@@ -355,8 +355,8 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n /// The privacy visitor, where privacy checks take place (violations reported)\n ////////////////////////////////////////////////////////////////////////////////\n \n-struct PrivacyVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct PrivacyVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     curitem: ast::NodeId,\n     in_foreign: bool,\n     parents: NodeMap<ast::NodeId>,\n@@ -376,7 +376,7 @@ enum FieldName {\n     NamedField(ast::Ident),\n }\n \n-impl<'a> PrivacyVisitor<'a> {\n+impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     // used when debugging\n     fn nodestr(&self, id: ast::NodeId) -> String {\n         self.tcx.map.node_to_string(id).to_string()\n@@ -802,7 +802,7 @@ impl<'a> PrivacyVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for PrivacyVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         let orig_curitem = replace(&mut self.curitem, item.id);\n         visit::walk_item(self, item, ());\n@@ -1023,12 +1023,12 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n /// The privacy sanity check visitor, ensures unnecessary visibility isn't here\n ////////////////////////////////////////////////////////////////////////////////\n \n-struct SanePrivacyVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct SanePrivacyVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     in_fn: bool,\n }\n \n-impl<'a> Visitor<()> for SanePrivacyVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for SanePrivacyVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         if self.in_fn {\n             self.check_all_inherited(item);\n@@ -1076,7 +1076,7 @@ impl<'a> Visitor<()> for SanePrivacyVisitor<'a> {\n     }\n }\n \n-impl<'a> SanePrivacyVisitor<'a> {\n+impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n     /// Validates all of the visibility qualifiers placed on the item given. This\n     /// ensures that there are no extraneous qualifiers that don't actually do\n     /// anything. In theory these qualifiers wouldn't parse, but that may happen\n@@ -1215,14 +1215,14 @@ impl<'a> SanePrivacyVisitor<'a> {\n     }\n }\n \n-struct VisiblePrivateTypesVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct VisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     exported_items: &'a ExportedItems,\n     public_items: &'a PublicItems,\n }\n \n-struct CheckTypeForPrivatenessVisitor<'a, 'b:'a> {\n-    inner: &'a VisiblePrivateTypesVisitor<'b>,\n+struct CheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n+    inner: &'a VisiblePrivateTypesVisitor<'b, 'tcx>,\n     /// whether the type refers to private types.\n     contains_private: bool,\n     /// whether we've recurred at all (i.e. if we're pointing at the\n@@ -1232,7 +1232,7 @@ struct CheckTypeForPrivatenessVisitor<'a, 'b:'a> {\n     outer_type_is_public_path: bool,\n }\n \n-impl<'a> VisiblePrivateTypesVisitor<'a> {\n+impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n         let did = match self.tcx.def_map.borrow().find_copy(&path_id) {\n             // `int` etc. (None doesn't seem to occur.)\n@@ -1256,7 +1256,7 @@ impl<'a> VisiblePrivateTypesVisitor<'a> {\n     }\n }\n \n-impl<'a, 'b> Visitor<()> for CheckTypeForPrivatenessVisitor<'a, 'b> {\n+impl<'a, 'b, 'tcx> Visitor<()> for CheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n         match ty.node {\n             ast::TyPath(_, _, path_id) => {\n@@ -1279,7 +1279,7 @@ impl<'a, 'b> Visitor<()> for CheckTypeForPrivatenessVisitor<'a, 'b> {\n     fn visit_expr(&mut self, _: &ast::Expr, _: ()) {}\n }\n \n-impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         match item.node {\n             // contents of a private mod can be reexported, so we need"}, {"sha": "7ba5144985ef206a3e40ab9a156a0b2263632d00", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -89,9 +89,9 @@ fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n }\n \n // Information needed while computing reachability.\n-struct ReachableContext<'a> {\n+struct ReachableContext<'a, 'tcx: 'a> {\n     // The type context.\n-    tcx: &'a ty::ctxt,\n+    tcx: &'a ty::ctxt<'tcx>,\n     // The set of items which must be exported in the linkage sense.\n     reachable_symbols: NodeSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n@@ -101,7 +101,7 @@ struct ReachableContext<'a> {\n     any_library: bool,\n }\n \n-impl<'a> Visitor<()> for ReachableContext<'a> {\n+impl<'a, 'tcx> Visitor<()> for ReachableContext<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n \n@@ -164,9 +164,9 @@ impl<'a> Visitor<()> for ReachableContext<'a> {\n     }\n }\n \n-impl<'a> ReachableContext<'a> {\n+impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Creates a new reachability computation context.\n-    fn new(tcx: &'a ty::ctxt) -> ReachableContext<'a> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>) -> ReachableContext<'a, 'tcx> {\n         let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n             *ty != config::CrateTypeExecutable\n         });"}, {"sha": "7c7960e0918f46fb1213cc39b77ddb792258e4d4", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -74,9 +74,9 @@ fn generated_code(span: Span) -> bool {\n     span.expn_info.is_some() || span  == DUMMY_SP\n }\n \n-struct DxrVisitor<'l> {\n+struct DxrVisitor<'l, 'tcx: 'l> {\n     sess: &'l Session,\n-    analysis: &'l CrateAnalysis,\n+    analysis: &'l CrateAnalysis<'tcx>,\n \n     collected_paths: Vec<(NodeId, ast::Path, bool, recorder::Row)>,\n     collecting: bool,\n@@ -85,7 +85,7 @@ struct DxrVisitor<'l> {\n     fmt: FmtStrs<'l>,\n }\n \n-impl <'l> DxrVisitor<'l> {\n+impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n         // the current crate\n         self.fmt.crate_str(krate.span, name);\n@@ -1023,7 +1023,7 @@ impl <'l> DxrVisitor<'l> {\n     }\n }\n \n-impl<'l> Visitor<DxrVisitorEnv> for DxrVisitor<'l> {\n+impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n     fn visit_item(&mut self, item:&ast::Item, e: DxrVisitorEnv) {\n         if generated_code(item.span) {\n             return"}, {"sha": "c1c23dff98406b5bee865610afdaaa155ba850ee", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -548,8 +548,8 @@ impl<T:TypeFoldable> Subst for T {\n ///////////////////////////////////////////////////////////////////////////\n // The actual substitution engine itself is a type folder.\n \n-struct SubstFolder<'a> {\n-    tcx: &'a ty::ctxt,\n+struct SubstFolder<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     substs: &'a Substs,\n \n     // The location for which the substitution is performed, if available.\n@@ -562,8 +562,8 @@ struct SubstFolder<'a> {\n     ty_stack_depth: uint,\n }\n \n-impl<'a> TypeFolder for SubstFolder<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n+impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         // Note: This routine only handles regions that are bound on"}, {"sha": "dd0668b8fa0e77aefdd8aa8f4fda189913c41356", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 144, "deletions": 153, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -225,14 +225,14 @@ use syntax::ast::Ident;\n use syntax::codemap::Span;\n use syntax::fold::Folder;\n \n-struct ConstantExpr<'a>(&'a ty::ctxt, Gc<ast::Expr>);\n+struct ConstantExpr<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>, Gc<ast::Expr>);\n \n-impl<'a> Eq for ConstantExpr<'a> {\n+impl<'a, 'tcx> Eq for ConstantExpr<'a, 'tcx> {\n     fn assert_receiver_is_total_eq(&self) {}\n }\n \n-impl<'a> PartialEq for ConstantExpr<'a> {\n-    fn eq(&self, other: &ConstantExpr<'a>) -> bool {\n+impl<'a, 'tcx> PartialEq for ConstantExpr<'a, 'tcx> {\n+    fn eq(&self, other: &ConstantExpr<'a, 'tcx>) -> bool {\n         let &ConstantExpr(tcx, expr) = self;\n         let &ConstantExpr(_, other_expr) = other;\n         match const_eval::compare_lit_exprs(tcx, &*expr, &*other_expr) {\n@@ -244,16 +244,16 @@ impl<'a> PartialEq for ConstantExpr<'a> {\n \n // An option identifying a branch (either a literal, an enum variant or a range)\n #[deriving(Eq, PartialEq)]\n-enum Opt<'a> {\n-    ConstantValue(ConstantExpr<'a>),\n-    ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>),\n+enum Opt<'blk, 'tcx: 'blk> {\n+    ConstantValue(ConstantExpr<'blk, 'tcx>),\n+    ConstantRange(ConstantExpr<'blk, 'tcx>, ConstantExpr<'blk, 'tcx>),\n     Variant(ty::Disr, Rc<adt::Repr>, ast::DefId),\n     SliceLengthEqual(uint),\n     SliceLengthGreaterOrEqual(/* prefix length */ uint, /* suffix length */ uint),\n }\n \n-impl<'a> Opt<'a> {\n-    fn trans(&self, mut bcx: &'a Block<'a>) -> OptResult<'a> {\n+impl<'blk, 'tcx> Opt<'blk, 'tcx> {\n+    fn trans(&self, mut bcx: Block<'blk, 'tcx>) -> OptResult<'blk, 'tcx> {\n         let _icx = push_ctxt(\"match::trans_opt\");\n         let ccx = bcx.ccx();\n         match *self {\n@@ -293,10 +293,10 @@ pub enum BranchKind {\n     CompareSliceLength\n }\n \n-pub enum OptResult<'a> {\n-    SingleResult(Result<'a>),\n-    RangeResult(Result<'a>, Result<'a>),\n-    LowerBound(Result<'a>)\n+pub enum OptResult<'blk, 'tcx: 'blk> {\n+    SingleResult(Result<'blk, 'tcx>),\n+    RangeResult(Result<'blk, 'tcx>, Result<'blk, 'tcx>),\n+    LowerBound(Result<'blk, 'tcx>)\n }\n \n #[deriving(Clone)]\n@@ -325,8 +325,8 @@ pub struct BindingInfo {\n \n type BindingsMap = HashMap<Ident, BindingInfo>;\n \n-struct ArmData<'a, 'b> {\n-    bodycx: &'b Block<'b>,\n+struct ArmData<'a, 'blk, 'tcx: 'blk> {\n+    bodycx: Block<'blk, 'tcx>,\n     arm: &'a ast::Arm,\n     bindings_map: BindingsMap\n }\n@@ -337,13 +337,13 @@ struct ArmData<'a, 'b> {\n  * As we proceed `bound_ptrs` are filled with pointers to values to be bound,\n  * these pointers are stored in llmatch variables just before executing `data` arm.\n  */\n-struct Match<'a, 'b:'a> {\n+struct Match<'a, 'blk: 'a, 'tcx: 'blk> {\n     pats: Vec<Gc<ast::Pat>>,\n-    data: &'a ArmData<'a, 'b>,\n+    data: &'a ArmData<'a, 'blk, 'tcx>,\n     bound_ptrs: Vec<(Ident, ValueRef)>\n }\n \n-impl<'a, 'b> Repr for Match<'a, 'b> {\n+impl<'a, 'blk, 'tcx> Repr for Match<'a, 'blk, 'tcx> {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         if tcx.sess.verbose() {\n             // for many programs, this just take too long to serialize\n@@ -364,12 +364,11 @@ fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     return false;\n }\n \n-fn expand_nested_bindings<'a, 'b>(\n-                          bcx: &'b Block<'b>,\n-                          m: &'a [Match<'a, 'b>],\n-                          col: uint,\n-                          val: ValueRef)\n-                          -> Vec<Match<'a, 'b>> {\n+fn expand_nested_bindings<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          m: &'a [Match<'a, 'blk, 'tcx>],\n+                                          col: uint,\n+                                          val: ValueRef)\n+                                          -> Vec<Match<'a, 'blk, 'tcx>> {\n     debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -402,14 +401,13 @@ fn expand_nested_bindings<'a, 'b>(\n \n type EnterPatterns<'a> = |&[Gc<ast::Pat>]|: 'a -> Option<Vec<Gc<ast::Pat>>>;\n \n-fn enter_match<'a, 'b>(\n-               bcx: &'b Block<'b>,\n-               dm: &DefMap,\n-               m: &'a [Match<'a, 'b>],\n-               col: uint,\n-               val: ValueRef,\n-               e: EnterPatterns)\n-               -> Vec<Match<'a, 'b>> {\n+fn enter_match<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               dm: &DefMap,\n+                               m: &'a [Match<'a, 'blk, 'tcx>],\n+                               col: uint,\n+                               val: ValueRef,\n+                               e: EnterPatterns)\n+                               -> Vec<Match<'a, 'blk, 'tcx>> {\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -450,13 +448,12 @@ fn enter_match<'a, 'b>(\n     }).collect()\n }\n \n-fn enter_default<'a, 'b>(\n-                 bcx: &'b Block<'b>,\n-                 dm: &DefMap,\n-                 m: &'a [Match<'a, 'b>],\n-                 col: uint,\n-                 val: ValueRef)\n-                 -> Vec<Match<'a, 'b>> {\n+fn enter_default<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 dm: &DefMap,\n+                                 m: &'a [Match<'a, 'blk, 'tcx>],\n+                                 col: uint,\n+                                 val: ValueRef)\n+                                 -> Vec<Match<'a, 'blk, 'tcx>> {\n     debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -502,16 +499,16 @@ fn enter_default<'a, 'b>(\n /// takes the complete row of patterns rather than just the first one.\n /// Also, most of the enter_() family functions have been unified with\n /// the check_match specialization step.\n-fn enter_opt<'a, 'b>(\n-             bcx: &'b Block<'b>,\n+fn enter_opt<'a, 'blk, 'tcx>(\n+             bcx: Block<'blk, 'tcx>,\n              _: ast::NodeId,\n              dm: &DefMap,\n-             m: &'a [Match<'a, 'b>],\n+             m: &'a [Match<'a, 'blk, 'tcx>],\n              opt: &Opt,\n              col: uint,\n              variant_size: uint,\n              val: ValueRef)\n-             -> Vec<Match<'a, 'b>> {\n+             -> Vec<Match<'a, 'blk, 'tcx>> {\n     debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -545,10 +542,12 @@ fn enter_opt<'a, 'b>(\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-fn get_branches<'a>(bcx: &'a Block, m: &[Match], col: uint) -> Vec<Opt<'a>> {\n+fn get_branches<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                            m: &[Match], col: uint)\n+                            -> Vec<Opt<'blk, 'tcx>> {\n     let ccx = bcx.ccx();\n \n-    fn add_to_set<'a>(set: &mut Vec<Opt<'a>>, opt: Opt<'a>) {\n+    fn add_to_set<'blk, 'tcx>(set: &mut Vec<Opt<'blk, 'tcx>>, opt: Opt<'blk, 'tcx>) {\n         if !set.contains(&opt) {\n             set.push(opt);\n         }\n@@ -593,17 +592,16 @@ fn get_branches<'a>(bcx: &'a Block, m: &[Match], col: uint) -> Vec<Opt<'a>> {\n     found\n }\n \n-struct ExtractedBlock<'a> {\n-    vals: Vec<ValueRef> ,\n-    bcx: &'a Block<'a>,\n+struct ExtractedBlock<'blk, 'tcx: 'blk> {\n+    vals: Vec<ValueRef>,\n+    bcx: Block<'blk, 'tcx>,\n }\n \n-fn extract_variant_args<'a>(\n-                        bcx: &'a Block<'a>,\n-                        repr: &adt::Repr,\n-                        disr_val: ty::Disr,\n-                        val: ValueRef)\n-                        -> ExtractedBlock<'a> {\n+fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    repr: &adt::Repr,\n+                                    disr_val: ty::Disr,\n+                                    val: ValueRef)\n+                                    -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_variant_args\");\n     let args = Vec::from_fn(adt::num_args(repr, disr_val), |i| {\n         adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n@@ -621,12 +619,11 @@ fn match_datum(val: ValueRef, left_ty: ty::t) -> Datum<Lvalue> {\n     Datum::new(val, left_ty, Lvalue)\n }\n \n-fn bind_subslice_pat<'a>(\n-                    bcx: &'a Block<'a>,\n-                    pat_id: ast::NodeId,\n-                    val: ValueRef,\n-                    offset_left: uint,\n-                    offset_right: uint) -> ValueRef {\n+fn bind_subslice_pat(bcx: Block,\n+                     pat_id: ast::NodeId,\n+                     val: ValueRef,\n+                     offset_left: uint,\n+                     offset_right: uint) -> ValueRef {\n     let _icx = push_ctxt(\"match::bind_subslice_pat\");\n     let vec_ty = node_id_type(bcx, pat_id);\n     let vt = tvec::vec_types(bcx, ty::sequence_element_type(bcx.tcx(), ty::type_content(vec_ty)));\n@@ -647,13 +644,12 @@ fn bind_subslice_pat<'a>(\n     scratch.val\n }\n \n-fn extract_vec_elems<'a>(\n-                     bcx: &'a Block<'a>,\n-                     left_ty: ty::t,\n-                     before: uint,\n-                     after: uint,\n-                     val: ValueRef)\n-                     -> ExtractedBlock<'a> {\n+fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 left_ty: ty::t,\n+                                 before: uint,\n+                                 after: uint,\n+                                 val: ValueRef)\n+                                 -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_vec_elems\");\n     let vec_datum = match_datum(val, left_ty);\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n@@ -714,13 +710,13 @@ fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: uint) -> bool {\n }\n \n /// What to do when the pattern match fails.\n-enum FailureHandler<'a> {\n+enum FailureHandler {\n     Infallible,\n     JumpToBasicBlock(BasicBlockRef),\n     Unreachable\n }\n \n-impl<'a> FailureHandler<'a> {\n+impl FailureHandler {\n     fn is_fallible(&self) -> bool {\n         match *self {\n             Infallible => false,\n@@ -732,7 +728,7 @@ impl<'a> FailureHandler<'a> {\n         !self.is_fallible()\n     }\n \n-    fn handle_fail(&self, bcx: &Block) {\n+    fn handle_fail(&self, bcx: Block) {\n         match *self {\n             Infallible =>\n                 fail!(\"attempted to fail in an infallible failure handler!\"),\n@@ -774,17 +770,16 @@ fn pick_col(m: &[Match]) -> uint {\n }\n \n // Compiles a comparison between two things.\n-fn compare_values<'a>(\n-                  cx: &'a Block<'a>,\n-                  lhs: ValueRef,\n-                  rhs: ValueRef,\n-                  rhs_t: ty::t)\n-                  -> Result<'a> {\n-    fn compare_str<'a>(cx: &'a Block<'a>,\n-                       lhs: ValueRef,\n-                       rhs: ValueRef,\n-                       rhs_t: ty::t)\n-                       -> Result<'a> {\n+fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                              lhs: ValueRef,\n+                              rhs: ValueRef,\n+                              rhs_t: ty::t)\n+                              -> Result<'blk, 'tcx> {\n+    fn compare_str<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                               lhs: ValueRef,\n+                               rhs: ValueRef,\n+                               rhs_t: ty::t)\n+                               -> Result<'blk, 'tcx> {\n         let did = langcall(cx,\n                            None,\n                            format!(\"comparison of `{}`\",\n@@ -819,9 +814,10 @@ fn compare_values<'a>(\n     }\n }\n \n-fn insert_lllocals<'a>(mut bcx: &'a Block<'a>, bindings_map: &BindingsMap,\n-                       cs: Option<cleanup::ScopeId>)\n-                       -> &'a Block<'a> {\n+fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                               bindings_map: &BindingsMap,\n+                               cs: Option<cleanup::ScopeId>)\n+                               -> Block<'blk, 'tcx> {\n     /*!\n      * For each binding in `data.bindings_map`, adds an appropriate entry into\n      * the `fcx.lllocals` map\n@@ -874,15 +870,14 @@ fn insert_lllocals<'a>(mut bcx: &'a Block<'a>, bindings_map: &BindingsMap,\n     bcx\n }\n \n-fn compile_guard<'a, 'b>(\n-                 bcx: &'b Block<'b>,\n-                 guard_expr: &ast::Expr,\n-                 data: &ArmData,\n-                 m: &'a [Match<'a, 'b>],\n-                 vals: &[ValueRef],\n-                 chk: &FailureHandler,\n-                 has_genuine_default: bool)\n-                 -> &'b Block<'b> {\n+fn compile_guard<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 guard_expr: &ast::Expr,\n+                                 data: &ArmData,\n+                                 m: &'a [Match<'a, 'blk, 'tcx>],\n+                                 vals: &[ValueRef],\n+                                 chk: &FailureHandler,\n+                                 has_genuine_default: bool)\n+                                 -> Block<'blk, 'tcx> {\n     debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n            bcx.to_str(),\n            bcx.expr_to_string(guard_expr),\n@@ -923,12 +918,11 @@ fn compile_guard<'a, 'b>(\n     })\n }\n \n-fn compile_submatch<'a, 'b>(\n-                    bcx: &'b Block<'b>,\n-                    m: &'a [Match<'a, 'b>],\n-                    vals: &[ValueRef],\n-                    chk: &FailureHandler,\n-                    has_genuine_default: bool) {\n+fn compile_submatch<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    m: &'a [Match<'a, 'blk, 'tcx>],\n+                                    vals: &[ValueRef],\n+                                    chk: &FailureHandler,\n+                                    has_genuine_default: bool) {\n     debug!(\"compile_submatch(bcx={}, m={}, vals={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -984,14 +978,13 @@ fn compile_submatch<'a, 'b>(\n     }\n }\n \n-fn compile_submatch_continue<'a, 'b>(\n-                             mut bcx: &'b Block<'b>,\n-                             m: &'a [Match<'a, 'b>],\n-                             vals: &[ValueRef],\n-                             chk: &FailureHandler,\n-                             col: uint,\n-                             val: ValueRef,\n-                             has_genuine_default: bool) {\n+fn compile_submatch_continue<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                             m: &'a [Match<'a, 'blk, 'tcx>],\n+                                             vals: &[ValueRef],\n+                                             chk: &FailureHandler,\n+                                             col: uint,\n+                                             val: ValueRef,\n+                                             has_genuine_default: bool) {\n     let fcx = bcx.fcx;\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n@@ -1218,19 +1211,18 @@ fn compile_submatch_continue<'a, 'b>(\n     }\n }\n \n-pub fn trans_match<'a>(\n-                   bcx: &'a Block<'a>,\n-                   match_expr: &ast::Expr,\n-                   discr_expr: &ast::Expr,\n-                   arms: &[ast::Arm],\n-                   dest: Dest)\n-                   -> &'a Block<'a> {\n+pub fn trans_match<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               match_expr: &ast::Expr,\n+                               discr_expr: &ast::Expr,\n+                               arms: &[ast::Arm],\n+                               dest: Dest)\n+                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::trans_match\");\n     trans_match_inner(bcx, match_expr.id, discr_expr, arms, dest)\n }\n \n /// Checks whether the binding in `discr` is assigned to anywhere in the expression `body`\n-fn is_discr_reassigned(bcx: &Block, discr: &ast::Expr, body: &ast::Expr) -> bool {\n+fn is_discr_reassigned(bcx: Block, discr: &ast::Expr, body: &ast::Expr) -> bool {\n     match discr.node {\n         ast::ExprPath(..) => match bcx.def(discr.id) {\n             def::DefArg(vid, _) | def::DefBinding(vid, _) |\n@@ -1272,7 +1264,7 @@ impl euv::Delegate for ReassignmentChecker {\n     }\n }\n \n-fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>,\n+fn create_bindings_map(bcx: Block, pat: Gc<ast::Pat>,\n                       discr: &ast::Expr, body: &ast::Expr) -> BindingsMap {\n     // Create the bindings map, which is a mapping from each binding name\n     // to an alloca() that will be the value for that local variable.\n@@ -1327,11 +1319,11 @@ fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>,\n     return bindings_map;\n }\n \n-fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n-                         match_id: ast::NodeId,\n-                         discr_expr: &ast::Expr,\n-                         arms: &[ast::Arm],\n-                         dest: Dest) -> &'a Block<'a> {\n+fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n+                                 match_id: ast::NodeId,\n+                                 discr_expr: &ast::Expr,\n+                                 arms: &[ast::Arm],\n+                                 dest: Dest) -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::trans_match_inner\");\n     let fcx = scope_cx.fcx;\n     let mut bcx = scope_cx;\n@@ -1402,9 +1394,9 @@ enum IrrefutablePatternBindingMode {\n     BindArgument\n }\n \n-pub fn store_local<'a>(bcx: &'a Block<'a>,\n-                       local: &ast::Local)\n-                       -> &'a Block<'a> {\n+pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               local: &ast::Local)\n+                               -> Block<'blk, 'tcx> {\n     /*!\n      * Generates code for a local variable declaration like\n      * `let <pat>;` or `let <pat> = <opt_init_expr>`.\n@@ -1457,9 +1449,9 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n         }\n     };\n \n-    fn create_dummy_locals<'a>(mut bcx: &'a Block<'a>,\n-                               pat: Gc<ast::Pat>)\n-                               -> &'a Block<'a> {\n+    fn create_dummy_locals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                       pat: Gc<ast::Pat>)\n+                                       -> Block<'blk, 'tcx> {\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n@@ -1473,11 +1465,11 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n-                     pat: Gc<ast::Pat>,\n-                     arg: Datum<Rvalue>,\n-                     arg_scope: cleanup::ScopeId)\n-                     -> &'a Block<'a> {\n+pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                             pat: Gc<ast::Pat>,\n+                             arg: Datum<Rvalue>,\n+                             arg_scope: cleanup::ScopeId)\n+                             -> Block<'blk, 'tcx> {\n     /*!\n      * Generates code for argument patterns like `fn foo(<pat>: T)`.\n      * Creates entries in the `llargs` map for each of the bindings\n@@ -1527,12 +1519,11 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n \n /// Generates code for the pattern binding in a `for` loop like\n /// `for <pat> in <expr> { ... }`.\n-pub fn store_for_loop_binding<'a>(\n-                              bcx: &'a Block<'a>,\n-                              pat: Gc<ast::Pat>,\n-                              llvalue: ValueRef,\n-                              body_scope: cleanup::ScopeId)\n-                              -> &'a Block<'a> {\n+pub fn store_for_loop_binding<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          pat: Gc<ast::Pat>,\n+                                          llvalue: ValueRef,\n+                                          body_scope: cleanup::ScopeId)\n+                                          -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::store_for_loop_binding\");\n \n     if simple_identifier(&*pat).is_some() {\n@@ -1550,14 +1541,15 @@ pub fn store_for_loop_binding<'a>(\n     bind_irrefutable_pat(bcx, pat, llvalue, BindLocal, body_scope)\n }\n \n-fn mk_binding_alloca<'a,A>(bcx: &'a Block<'a>,\n-                           p_id: ast::NodeId,\n-                           ident: &ast::Ident,\n-                           binding_mode: IrrefutablePatternBindingMode,\n-                           cleanup_scope: cleanup::ScopeId,\n-                           arg: A,\n-                           populate: |A, &'a Block<'a>, ValueRef, ty::t| -> &'a Block<'a>)\n-                         -> &'a Block<'a> {\n+fn mk_binding_alloca<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n+                                    p_id: ast::NodeId,\n+                                    ident: &ast::Ident,\n+                                    binding_mode: IrrefutablePatternBindingMode,\n+                                    cleanup_scope: cleanup::ScopeId,\n+                                    arg: A,\n+                                    populate: |A, Block<'blk, 'tcx>, ValueRef, ty::t|\n+                                              -> Block<'blk, 'tcx>)\n+                                    -> Block<'blk, 'tcx> {\n     let var_ty = node_id_type(bcx, p_id);\n \n     // Allocate memory on stack for the binding.\n@@ -1580,13 +1572,12 @@ fn mk_binding_alloca<'a,A>(bcx: &'a Block<'a>,\n     bcx\n }\n \n-fn bind_irrefutable_pat<'a>(\n-                        bcx: &'a Block<'a>,\n-                        pat: Gc<ast::Pat>,\n-                        val: ValueRef,\n-                        binding_mode: IrrefutablePatternBindingMode,\n-                        cleanup_scope: cleanup::ScopeId)\n-                        -> &'a Block<'a> {\n+fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    pat: Gc<ast::Pat>,\n+                                    val: ValueRef,\n+                                    binding_mode: IrrefutablePatternBindingMode,\n+                                    cleanup_scope: cleanup::ScopeId)\n+                                    -> Block<'blk, 'tcx> {\n     /*!\n      * A simple version of the pattern matching code that only handles\n      * irrefutable patterns. This is used in let/argument patterns,"}, {"sha": "e62e3563a0a2ca3c0f85c1eec3f6b325d1e4a3fc", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -143,7 +143,7 @@ pub struct Struct {\n  * these, for places in trans where the `ty::t` isn't directly\n  * available.\n  */\n-pub fn represent_node(bcx: &Block, node: ast::NodeId) -> Rc<Repr> {\n+pub fn represent_node(bcx: Block, node: ast::NodeId) -> Rc<Repr> {\n     represent_type(bcx.ccx(), node_id_type(bcx, node))\n }\n \n@@ -574,7 +574,7 @@ fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool, dst: bool) -> V\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_switch(bcx: &Block, r: &Repr, scrutinee: ValueRef)\n+pub fn trans_switch(bcx: Block, r: &Repr, scrutinee: ValueRef)\n     -> (_match::BranchKind, Option<ValueRef>) {\n     match *r {\n         CEnum(..) | General(..) |\n@@ -590,7 +590,7 @@ pub fn trans_switch(bcx: &Block, r: &Repr, scrutinee: ValueRef)\n \n \n /// Obtain the actual discriminant of a value.\n-pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Option<Type>)\n+pub fn trans_get_discr(bcx: Block, r: &Repr, scrutinee: ValueRef, cast_to: Option<Type>)\n     -> ValueRef {\n     let signed;\n     let val;\n@@ -625,7 +625,7 @@ pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n     }\n }\n \n-fn struct_wrapped_nullable_bitdiscr(bcx: &Block, nndiscr: Disr, ptrfield: PointerField,\n+fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, ptrfield: PointerField,\n                                     scrutinee: ValueRef) -> ValueRef {\n     let llptrptr = match ptrfield {\n         ThinPointer(field) => GEPi(bcx, scrutinee, [0, field]),\n@@ -637,7 +637,7 @@ fn struct_wrapped_nullable_bitdiscr(bcx: &Block, nndiscr: Disr, ptrfield: Pointe\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: &Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n+fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     -> ValueRef {\n     let llty = ll_inttype(bcx.ccx(), ity);\n     assert_eq!(val_ty(ptr), llty.ptr_to());\n@@ -666,8 +666,8 @@ fn load_discr(bcx: &Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n-                  -> _match::OptResult<'a> {\n+pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr, discr: Disr)\n+                              -> _match::OptResult<'blk, 'tcx> {\n     match *r {\n         CEnum(ity, _, _) => {\n             _match::SingleResult(Result::new(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n@@ -692,7 +692,7 @@ pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n  * Set the discriminant for a new value of the given case of the given\n  * representation.\n  */\n-pub fn trans_set_discr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n+pub fn trans_set_discr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr) {\n     match *r {\n         CEnum(ity, min, max) => {\n             assert_discr_in_range(ity, min, max, discr);\n@@ -770,7 +770,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n+pub fn trans_field_ptr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr,\n                        ix: uint) -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n@@ -809,7 +809,7 @@ pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n     }\n }\n \n-pub fn struct_field_ptr(bcx: &Block, st: &Struct, val: ValueRef,\n+pub fn struct_field_ptr(bcx: Block, st: &Struct, val: ValueRef,\n                         ix: uint, needs_cast: bool) -> ValueRef {\n     let val = if needs_cast {\n         let ccx = bcx.ccx();\n@@ -823,10 +823,10 @@ pub fn struct_field_ptr(bcx: &Block, st: &Struct, val: ValueRef,\n     GEPi(bcx, val, [0, ix])\n }\n \n-pub fn fold_variants<'r, 'b>(\n-    bcx: &'b Block<'b>, r: &Repr, value: ValueRef,\n-    f: |&'b Block<'b>, &Struct, ValueRef|: 'r -> &'b Block<'b>\n-) -> &'b Block<'b> {\n+pub fn fold_variants<'blk, 'tcx>(\n+        bcx: Block<'blk, 'tcx>, r: &Repr, value: ValueRef,\n+        f: |Block<'blk, 'tcx>, &Struct, ValueRef| -> Block<'blk, 'tcx>)\n+        -> Block<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n     match *r {\n         Univariant(ref st, _) => {\n@@ -864,8 +864,8 @@ pub fn fold_variants<'r, 'b>(\n }\n \n /// Access the struct drop flag, if present.\n-pub fn trans_drop_flag_ptr<'b>(mut bcx: &'b Block<'b>, r: &Repr,\n-                               val: ValueRef) -> datum::DatumBlock<'b, datum::Expr> {\n+pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr, val: ValueRef)\n+                                       -> datum::DatumBlock<'blk, 'tcx, datum::Expr> {\n     let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), ty::mk_bool());\n     match *r {\n         Univariant(ref st, true) => {"}, {"sha": "7fb692c270ee3dd1b51ef20ea012a79d13448ce5", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -27,8 +27,8 @@ use std::string::String;\n use syntax::ast;\n \n // Take an inline assembly expression and splat it out via LLVM\n-pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n-                        -> &'a Block<'a> {\n+pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n+                                    -> Block<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n     let mut constraints = Vec::new();"}, {"sha": "dc2aa16eb728494a612c869615a18043e3fc099b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 145, "deletions": 156, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -137,15 +137,16 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     _InsnCtxt { _cannot_construct_outside_of_this_module: () }\n }\n \n-pub struct StatRecorder<'a> {\n-    ccx: &'a CrateContext<'a>,\n+pub struct StatRecorder<'a, 'tcx: 'a> {\n+    ccx: &'a CrateContext<'a, 'tcx>,\n     name: Option<String>,\n     start: u64,\n     istart: uint,\n }\n \n-impl<'a> StatRecorder<'a> {\n-    pub fn new(ccx: &'a CrateContext, name: String) -> StatRecorder<'a> {\n+impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n+    pub fn new(ccx: &'a CrateContext<'a, 'tcx>, name: String)\n+               -> StatRecorder<'a, 'tcx> {\n         let start = if ccx.sess().trans_stats() {\n             time::precise_time_ns()\n         } else {\n@@ -162,7 +163,7 @@ impl<'a> StatRecorder<'a> {\n }\n \n #[unsafe_destructor]\n-impl<'a> Drop for StatRecorder<'a> {\n+impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     fn drop(&mut self) {\n         if self.ccx.sess().trans_stats() {\n             let end = time::precise_time_ns();\n@@ -343,15 +344,15 @@ pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n // Returns a pointer to the body for the box. The box may be an opaque\n // box. The result will be casted to the type of body_t, if it is statically\n // known.\n-pub fn at_box_body(bcx: &Block, body_t: ty::t, boxptr: ValueRef) -> ValueRef {\n+pub fn at_box_body(bcx: Block, body_t: ty::t, boxptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"at_box_body\");\n     let ccx = bcx.ccx();\n     let ty = Type::at_box(ccx, type_of(ccx, body_t));\n     let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());\n     GEPi(bcx, boxptr, [0u, abi::box_field_body])\n }\n \n-fn require_alloc_fn(bcx: &Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n+fn require_alloc_fn(bcx: Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n     match bcx.tcx().lang_items.require(it) {\n         Ok(id) => id,\n         Err(s) => {\n@@ -365,12 +366,12 @@ fn require_alloc_fn(bcx: &Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n // The following malloc_raw_dyn* functions allocate a box to contain\n // a given type, but with a potentially dynamic size.\n \n-pub fn malloc_raw_dyn<'a>(bcx: &'a Block<'a>,\n-                          llty_ptr: Type,\n-                          info_ty: ty::t,\n-                          size: ValueRef,\n-                          align: ValueRef)\n-                          -> Result<'a> {\n+pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  llty_ptr: Type,\n+                                  info_ty: ty::t,\n+                                  size: ValueRef,\n+                                  align: ValueRef)\n+                                  -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"malloc_raw_exchange\");\n \n     // Allocate space:\n@@ -382,9 +383,9 @@ pub fn malloc_raw_dyn<'a>(bcx: &'a Block<'a>,\n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n-pub fn malloc_raw_dyn_proc<'a>(\n-                      bcx: &'a Block<'a>,\n-                      t: ty::t, alloc_fn: LangItem) -> Result<'a> {\n+pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       t: ty::t, alloc_fn: LangItem)\n+                                       -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"malloc_raw_dyn_proc\");\n     let ccx = bcx.ccx();\n \n@@ -413,12 +414,11 @@ pub fn malloc_raw_dyn_proc<'a>(\n }\n \n \n-pub fn malloc_raw_dyn_managed<'a>(\n-                      bcx: &'a Block<'a>,\n-                      t: ty::t,\n-                      alloc_fn: LangItem,\n-                      size: ValueRef)\n-                      -> Result<'a> {\n+pub fn malloc_raw_dyn_managed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          t: ty::t,\n+                                          alloc_fn: LangItem,\n+                                          size: ValueRef)\n+                                          -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"malloc_raw_dyn_managed\");\n     let ccx = bcx.ccx();\n \n@@ -584,13 +584,12 @@ pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n // Used only for creating scalar comparison glue.\n pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n \n-pub fn compare_scalar_types<'a>(\n-                            cx: &'a Block<'a>,\n-                            lhs: ValueRef,\n-                            rhs: ValueRef,\n-                            t: ty::t,\n-                            op: ast::BinOp)\n-                            -> Result<'a> {\n+pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                        lhs: ValueRef,\n+                                        rhs: ValueRef,\n+                                        t: ty::t,\n+                                        op: ast::BinOp)\n+                                        -> Result<'blk, 'tcx> {\n     let f = |a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op));\n \n     match ty::get(t).sty {\n@@ -606,15 +605,14 @@ pub fn compare_scalar_types<'a>(\n \n \n // A helper function to do the actual comparison of scalar values.\n-pub fn compare_scalar_values<'a>(\n-                             cx: &'a Block<'a>,\n-                             lhs: ValueRef,\n-                             rhs: ValueRef,\n-                             nt: scalar_type,\n-                             op: ast::BinOp)\n-                             -> ValueRef {\n+pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                         lhs: ValueRef,\n+                                         rhs: ValueRef,\n+                                         nt: scalar_type,\n+                                         op: ast::BinOp)\n+                                         -> ValueRef {\n     let _icx = push_ctxt(\"compare_scalar_values\");\n-    fn die(cx: &Block) -> ! {\n+    fn die(cx: Block) -> ! {\n         cx.sess().bug(\"compare_scalar_values: must be a comparison operator\");\n     }\n     match nt {\n@@ -668,7 +666,7 @@ pub fn compare_scalar_values<'a>(\n }\n \n pub fn compare_simd_types(\n-                    cx: &Block,\n+                    cx: Block,\n                     lhs: ValueRef,\n                     rhs: ValueRef,\n                     t: ty::t,\n@@ -705,28 +703,24 @@ pub fn compare_simd_types(\n     }\n }\n \n-pub type val_and_ty_fn<'r,'b> =\n-    |&'b Block<'b>, ValueRef, ty::t|: 'r -> &'b Block<'b>;\n+pub type val_and_ty_fn<'a, 'blk, 'tcx> =\n+    |Block<'blk, 'tcx>, ValueRef, ty::t|: 'a -> Block<'blk, 'tcx>;\n \n // Iterates through the elements of a structural type.\n-pub fn iter_structural_ty<'r,\n-                          'b>(\n-                          cx: &'b Block<'b>,\n-                          av: ValueRef,\n-                          t: ty::t,\n-                          f: val_and_ty_fn<'r,'b>)\n-                          -> &'b Block<'b> {\n+pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                          av: ValueRef,\n+                                          t: ty::t,\n+                                          f: val_and_ty_fn<'a, 'blk, 'tcx>)\n+                                          -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"iter_structural_ty\");\n \n-    fn iter_variant<'r,\n-                    'b>(\n-                    cx: &'b Block<'b>,\n-                    repr: &adt::Repr,\n-                    av: ValueRef,\n-                    variant: &ty::VariantInfo,\n-                    substs: &subst::Substs,\n-                    f: val_and_ty_fn<'r,'b>)\n-                    -> &'b Block<'b> {\n+    fn iter_variant<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                    repr: &adt::Repr,\n+                                    av: ValueRef,\n+                                    variant: &ty::VariantInfo,\n+                                    substs: &subst::Substs,\n+                                    f: val_and_ty_fn<'a, 'blk, 'tcx>)\n+                                    -> Block<'blk, 'tcx> {\n         let _icx = push_ctxt(\"iter_variant\");\n         let tcx = cx.tcx();\n         let mut cx = cx;\n@@ -846,8 +840,7 @@ pub fn iter_structural_ty<'r,\n     return cx;\n }\n \n-pub fn cast_shift_expr_rhs<'a>(\n-                           cx: &'a Block<'a>,\n+pub fn cast_shift_expr_rhs(cx: Block,\n                            op: ast::BinOp,\n                            lhs: ValueRef,\n                            rhs: ValueRef)\n@@ -894,14 +887,14 @@ pub fn cast_shift_rhs(op: ast::BinOp,\n     }\n }\n \n-pub fn fail_if_zero_or_overflows<'a>(\n-                    cx: &'a Block<'a>,\n-                    span: Span,\n-                    divrem: ast::BinOp,\n-                    lhs: ValueRef,\n-                    rhs: ValueRef,\n-                    rhs_t: ty::t)\n-                    -> &'a Block<'a> {\n+pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n+                                cx: Block<'blk, 'tcx>,\n+                                span: Span,\n+                                divrem: ast::BinOp,\n+                                lhs: ValueRef,\n+                                rhs: ValueRef,\n+                                rhs_t: ty::t)\n+                                -> Block<'blk, 'tcx> {\n     let (zero_text, overflow_text) = if divrem == ast::BiDiv {\n         (\"attempted to divide by zero\",\n          \"attempted to divide with overflow\")\n@@ -998,16 +991,15 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n     }\n }\n \n-pub fn invoke<'a>(\n-              bcx: &'a Block<'a>,\n-              llfn: ValueRef,\n-              llargs: Vec<ValueRef> ,\n-              fn_ty: ty::t,\n-              call_info: Option<NodeInfo>,\n-              // FIXME(15064) is_lang_item is a horrible hack, please remove it\n-              // at the soonest opportunity.\n-              is_lang_item: bool)\n-              -> (ValueRef, &'a Block<'a>) {\n+pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                          llfn: ValueRef,\n+                          llargs: Vec<ValueRef> ,\n+                          fn_ty: ty::t,\n+                          call_info: Option<NodeInfo>,\n+                          // FIXME(15064) is_lang_item is a horrible hack, please remove it\n+                          // at the soonest opportunity.\n+                          is_lang_item: bool)\n+                          -> (ValueRef, Block<'blk, 'tcx>) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable.get() {\n         return (C_null(Type::i8(bcx.ccx())), bcx);\n@@ -1066,7 +1058,7 @@ pub fn invoke<'a>(\n     }\n }\n \n-pub fn need_invoke(bcx: &Block) -> bool {\n+pub fn need_invoke(bcx: Block) -> bool {\n     if bcx.sess().no_landing_pads() {\n         return false;\n     }\n@@ -1079,13 +1071,13 @@ pub fn need_invoke(bcx: &Block) -> bool {\n     bcx.fcx.needs_invoke()\n }\n \n-pub fn load_if_immediate(cx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn load_if_immediate(cx: Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n     if type_is_immediate(cx.ccx(), t) { return load_ty(cx, v, t); }\n     return v;\n }\n \n-pub fn load_ty(cx: &Block, ptr: ValueRef, t: ty::t) -> ValueRef {\n+pub fn load_ty(cx: Block, ptr: ValueRef, t: ty::t) -> ValueRef {\n     /*!\n      * Helper for loading values from memory. Does the necessary conversion if\n      * the in-memory type differs from the type used for SSA values. Also\n@@ -1105,7 +1097,7 @@ pub fn load_ty(cx: &Block, ptr: ValueRef, t: ty::t) -> ValueRef {\n     }\n }\n \n-pub fn store_ty(cx: &Block, v: ValueRef, dst: ValueRef, t: ty::t) {\n+pub fn store_ty(cx: Block, v: ValueRef, dst: ValueRef, t: ty::t) {\n     /*!\n      * Helper for storing values in memory. Does the necessary conversion if\n      * the in-memory type differs from the type used for SSA values.\n@@ -1117,33 +1109,31 @@ pub fn store_ty(cx: &Block, v: ValueRef, dst: ValueRef, t: ty::t) {\n     };\n }\n \n-pub fn ignore_lhs(_bcx: &Block, local: &ast::Local) -> bool {\n+pub fn ignore_lhs(_bcx: Block, local: &ast::Local) -> bool {\n     match local.pat.node {\n         ast::PatWild(ast::PatWildSingle) => true, _ => false\n     }\n }\n \n-pub fn init_local<'a>(bcx: &'a Block<'a>, local: &ast::Local)\n-                  -> &'a Block<'a> {\n+pub fn init_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, local: &ast::Local)\n+                              -> Block<'blk, 'tcx> {\n     debug!(\"init_local(bcx={}, local.id={:?})\", bcx.to_str(), local.id);\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"init_local\");\n     _match::store_local(bcx, local)\n }\n \n-pub fn raw_block<'a>(\n-                 fcx: &'a FunctionContext<'a>,\n-                 is_lpad: bool,\n-                 llbb: BasicBlockRef)\n-                 -> &'a Block<'a> {\n-    common::Block::new(llbb, is_lpad, None, fcx)\n+pub fn raw_block<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n+                             is_lpad: bool,\n+                             llbb: BasicBlockRef)\n+                             -> Block<'blk, 'tcx> {\n+    common::BlockS::new(llbb, is_lpad, None, fcx)\n }\n \n-pub fn with_cond<'a>(\n-                 bcx: &'a Block<'a>,\n-                 val: ValueRef,\n-                 f: |&'a Block<'a>| -> &'a Block<'a>)\n-                 -> &'a Block<'a> {\n+pub fn with_cond<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             val: ValueRef,\n+                             f: |Block<'blk, 'tcx>| -> Block<'blk, 'tcx>)\n+                             -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"with_cond\");\n     let fcx = bcx.fcx;\n     let next_cx = fcx.new_temp_block(\"next\");\n@@ -1156,7 +1146,7 @@ pub fn with_cond<'a>(\n     next_cx\n }\n \n-pub fn call_lifetime_start(cx: &Block, ptr: ValueRef) {\n+pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n     if cx.sess().opts.optimize == config::No {\n         return;\n     }\n@@ -1170,7 +1160,7 @@ pub fn call_lifetime_start(cx: &Block, ptr: ValueRef) {\n     Call(cx, lifetime_start, [llsize, ptr], None);\n }\n \n-pub fn call_lifetime_end(cx: &Block, ptr: ValueRef) {\n+pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n     if cx.sess().opts.optimize == config::No {\n         return;\n     }\n@@ -1184,7 +1174,7 @@ pub fn call_lifetime_end(cx: &Block, ptr: ValueRef) {\n     Call(cx, lifetime_end, [llsize, ptr], None);\n }\n \n-pub fn call_memcpy(cx: &Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n+pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n     let key = match ccx.sess().targ_cfg.arch {\n@@ -1200,7 +1190,7 @@ pub fn call_memcpy(cx: &Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef,\n     Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n-pub fn memcpy_ty(bcx: &Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n+pub fn memcpy_ty(bcx: Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n@@ -1213,7 +1203,7 @@ pub fn memcpy_ty(bcx: &Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     }\n }\n \n-pub fn zero_mem(cx: &Block, llptr: ValueRef, t: ty::t) {\n+pub fn zero_mem(cx: Block, llptr: ValueRef, t: ty::t) {\n     if cx.unreachable.get() { return; }\n     let _icx = push_ctxt(\"zero_mem\");\n     let bcx = cx;\n@@ -1245,7 +1235,7 @@ fn memzero(b: &Builder, llptr: ValueRef, ty: ty::t) {\n     b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile], None);\n }\n \n-pub fn alloc_ty(bcx: &Block, t: ty::t, name: &str) -> ValueRef {\n+pub fn alloc_ty(bcx: Block, t: ty::t, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n@@ -1254,13 +1244,13 @@ pub fn alloc_ty(bcx: &Block, t: ty::t, name: &str) -> ValueRef {\n     return val;\n }\n \n-pub fn alloca(cx: &Block, ty: Type, name: &str) -> ValueRef {\n+pub fn alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n     let p = alloca_no_lifetime(cx, ty, name);\n     call_lifetime_start(cx, p);\n     p\n }\n \n-pub fn alloca_no_lifetime(cx: &Block, ty: Type, name: &str) -> ValueRef {\n+pub fn alloca_no_lifetime(cx: Block, ty: Type, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloca\");\n     if cx.unreachable.get() {\n         unsafe {\n@@ -1271,7 +1261,7 @@ pub fn alloca_no_lifetime(cx: &Block, ty: Type, name: &str) -> ValueRef {\n     Alloca(cx, ty, name)\n }\n \n-pub fn alloca_zeroed(cx: &Block, ty: ty::t, name: &str) -> ValueRef {\n+pub fn alloca_zeroed(cx: Block, ty: ty::t, name: &str) -> ValueRef {\n     let llty = type_of::type_of(cx.ccx(), ty);\n     if cx.unreachable.get() {\n         unsafe {\n@@ -1285,7 +1275,7 @@ pub fn alloca_zeroed(cx: &Block, ty: ty::t, name: &str) -> ValueRef {\n     p\n }\n \n-pub fn arrayalloca(cx: &Block, ty: Type, v: ValueRef) -> ValueRef {\n+pub fn arrayalloca(cx: Block, ty: Type, v: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"arrayalloca\");\n     if cx.unreachable.get() {\n         unsafe {\n@@ -1440,15 +1430,15 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n //\n // Be warned! You must call `init_function` before doing anything with the\n // returned function context.\n-pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n-                       llfndecl: ValueRef,\n-                       id: ast::NodeId,\n-                       has_env: bool,\n-                       output_type: ty::t,\n-                       param_substs: &'a param_substs,\n-                       sp: Option<Span>,\n-                       block_arena: &'a TypedArena<Block<'a>>)\n-                       -> FunctionContext<'a> {\n+pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n+                             llfndecl: ValueRef,\n+                             id: ast::NodeId,\n+                             has_env: bool,\n+                             output_type: ty::t,\n+                             param_substs: &'a param_substs,\n+                             sp: Option<Span>,\n+                             block_arena: &'a TypedArena<common::BlockS<'a, 'tcx>>)\n+                             -> FunctionContext<'a, 'tcx> {\n     param_substs.validate();\n \n     debug!(\"new_fn_ctxt(path={}, id={}, param_substs={})\",\n@@ -1494,9 +1484,9 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n \n /// Performs setup on a newly created function, creating the entry scope block\n /// and allocating space for the return pointer.\n-pub fn init_function<'a>(fcx: &'a FunctionContext<'a>,\n-                         skip_retptr: bool,\n-                         output_type: ty::t) -> &'a Block<'a> {\n+pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n+                               skip_retptr: bool,\n+                               output_type: ty::t) -> Block<'a, 'tcx> {\n     let entry_bcx = fcx.new_temp_block(\"entry-block\");\n \n     // Use a dummy instruction as the insertion point for all allocas.\n@@ -1564,9 +1554,8 @@ pub fn create_datums_for_fn_args(fcx: &FunctionContext,\n /// datums.\n ///\n /// FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n-fn create_datums_for_fn_args_under_call_abi<\n-        'a>(\n-        mut bcx: &'a Block<'a>,\n+fn create_datums_for_fn_args_under_call_abi(\n+        mut bcx: Block,\n         arg_scope: cleanup::CustomScopeIndex,\n         arg_tys: &[ty::t])\n         -> Vec<RvalueDatum> {\n@@ -1632,12 +1621,12 @@ fn create_datums_for_fn_args_under_call_abi<\n     result\n }\n \n-fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n-                            arg_scope: cleanup::CustomScopeIndex,\n-                            bcx: &'a Block<'a>,\n-                            args: &[ast::Arg],\n-                            arg_datums: Vec<RvalueDatum> )\n-                            -> &'a Block<'a> {\n+fn copy_args_to_allocas<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n+                                    arg_scope: cleanup::CustomScopeIndex,\n+                                    bcx: Block<'blk, 'tcx>,\n+                                    args: &[ast::Arg],\n+                                    arg_datums: Vec<RvalueDatum> )\n+                                    -> Block<'blk, 'tcx> {\n     debug!(\"copy_args_to_allocas\");\n \n     let _icx = push_ctxt(\"copy_args_to_allocas\");\n@@ -1664,13 +1653,13 @@ fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n     bcx\n }\n \n-fn copy_unboxed_closure_args_to_allocas<'a>(\n-                                        mut bcx: &'a Block<'a>,\n+fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n+                                        mut bcx: Block<'blk, 'tcx>,\n                                         arg_scope: cleanup::CustomScopeIndex,\n                                         args: &[ast::Arg],\n                                         arg_datums: Vec<RvalueDatum>,\n                                         monomorphized_arg_types: &[ty::t])\n-                                        -> &'a Block<'a> {\n+                                        -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"copy_unboxed_closure_args_to_allocas\");\n     let arg_scope_id = cleanup::CustomScope(arg_scope);\n \n@@ -1720,9 +1709,9 @@ fn copy_unboxed_closure_args_to_allocas<'a>(\n \n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n-pub fn finish_fn<'a>(fcx: &'a FunctionContext<'a>,\n-                     last_bcx: &'a Block<'a>,\n-                     retty: ty::t) {\n+pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n+                             last_bcx: Block<'blk, 'tcx>,\n+                             retty: ty::t) {\n     let _icx = push_ctxt(\"finish_fn\");\n \n     // This shouldn't need to recompute the return type,\n@@ -1744,7 +1733,7 @@ pub fn finish_fn<'a>(fcx: &'a FunctionContext<'a>,\n }\n \n // Builds the return block for a function.\n-pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block, retty: ty::t) {\n+pub fn build_return_block(fcx: &FunctionContext, ret_cx: Block, retty: ty::t) {\n     if fcx.llretslotptr.get().is_none() ||\n        (!fcx.needs_ret_allocas && fcx.caller_expects_out_pointer) {\n         return RetVoid(ret_cx);\n@@ -1813,8 +1802,8 @@ pub fn trans_closure(ccx: &CrateContext,\n                      abi: Abi,\n                      has_env: bool,\n                      is_unboxed_closure: IsUnboxedClosureFlag,\n-                     maybe_load_env: <'a>|&'a Block<'a>, ScopeId|\n-                                         -> &'a Block<'a>) {\n+                     maybe_load_env: <'blk, 'tcx> |Block<'blk, 'tcx>, ScopeId|\n+                                                  -> Block<'blk, 'tcx>) {\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n     let _icx = push_ctxt(\"trans_closure\");\n@@ -1980,11 +1969,11 @@ pub fn trans_enum_variant(ccx: &CrateContext,\n         llfndecl);\n }\n \n-pub fn trans_named_tuple_constructor<'a>(mut bcx: &'a Block<'a>,\n-                                         ctor_ty: ty::t,\n-                                         disr: ty::Disr,\n-                                         args: callee::CallArgs,\n-                                         dest: expr::Dest) -> Result<'a> {\n+pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                                 ctor_ty: ty::t,\n+                                                 disr: ty::Disr,\n+                                                 args: callee::CallArgs,\n+                                                 dest: expr::Dest) -> Result<'blk, 'tcx> {\n \n     let ccx = bcx.fcx.ccx;\n     let tcx = ccx.tcx();\n@@ -2142,11 +2131,11 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n     }\n }\n \n-pub struct TransItemVisitor<'a> {\n-    pub ccx: &'a CrateContext<'a>,\n+pub struct TransItemVisitor<'a, 'tcx: 'a> {\n+    pub ccx: &'a CrateContext<'a, 'tcx>,\n }\n \n-impl<'a> Visitor<()> for TransItemVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for TransItemVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item, _:()) {\n         trans_item(self.ccx, i);\n     }\n@@ -2911,20 +2900,20 @@ pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r SharedCrateContext,\n-                                      ie: encoder::EncodeInlinedItem<'r>)\n-    -> encoder::EncodeParams<'r> {\n-        encoder::EncodeParams {\n-            diag: cx.sess().diagnostic(),\n-            tcx: cx.tcx(),\n-            reexports2: cx.exp_map2(),\n-            item_symbols: cx.item_symbols(),\n-            non_inlineable_statics: cx.non_inlineable_statics(),\n-            link_meta: cx.link_meta(),\n-            cstore: &cx.sess().cstore,\n-            encode_inlined_item: ie,\n-            reachable: cx.reachable(),\n-        }\n+pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'tcx>,\n+                                            ie: encoder::EncodeInlinedItem<'a>)\n+                                            -> encoder::EncodeParams<'a, 'tcx> {\n+    encoder::EncodeParams {\n+        diag: cx.sess().diagnostic(),\n+        tcx: cx.tcx(),\n+        reexports2: cx.exp_map2(),\n+        item_symbols: cx.item_symbols(),\n+        non_inlineable_statics: cx.non_inlineable_statics(),\n+        link_meta: cx.link_meta(),\n+        cstore: &cx.sess().cstore,\n+        encode_inlined_item: ie,\n+        reachable: cx.reachable(),\n+    }\n }\n \n pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {"}, {"sha": "e30f9af02c6a6ce334577aff000ab4b09d9b1e88", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 108, "deletions": 108, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -23,18 +23,18 @@ use middle::trans::type_::Type;\n \n use libc::{c_uint, c_ulonglong, c_char};\n \n-pub fn terminate(cx: &Block, _: &str) {\n+pub fn terminate(cx: Block, _: &str) {\n     debug!(\"terminate({})\", cx.to_str());\n     cx.terminated.set(true);\n }\n \n-pub fn check_not_terminated(cx: &Block) {\n+pub fn check_not_terminated(cx: Block) {\n     if cx.terminated.get() {\n         fail!(\"already terminated!\");\n     }\n }\n \n-pub fn B<'a>(cx: &'a Block) -> Builder<'a> {\n+pub fn B<'blk, 'tcx>(cx: Block<'blk, 'tcx>) -> Builder<'blk, 'tcx> {\n     let b = cx.fcx.ccx.builder();\n     b.position_at_end(cx.llbb);\n     b\n@@ -48,35 +48,35 @@ pub fn B<'a>(cx: &'a Block) -> Builder<'a> {\n // for (fail/break/return statements, call to diverging functions, etc), and\n // further instructions to the block should simply be ignored.\n \n-pub fn RetVoid(cx: &Block) {\n+pub fn RetVoid(cx: Block) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"RetVoid\");\n     B(cx).ret_void();\n }\n \n-pub fn Ret(cx: &Block, v: ValueRef) {\n+pub fn Ret(cx: Block, v: ValueRef) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"Ret\");\n     B(cx).ret(v);\n }\n \n-pub fn AggregateRet(cx: &Block, ret_vals: &[ValueRef]) {\n+pub fn AggregateRet(cx: Block, ret_vals: &[ValueRef]) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"AggregateRet\");\n     B(cx).aggregate_ret(ret_vals);\n }\n \n-pub fn Br(cx: &Block, dest: BasicBlockRef) {\n+pub fn Br(cx: Block, dest: BasicBlockRef) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"Br\");\n     B(cx).br(dest);\n }\n \n-pub fn CondBr(cx: &Block,\n+pub fn CondBr(cx: Block,\n               if_: ValueRef,\n               then: BasicBlockRef,\n               else_: BasicBlockRef) {\n@@ -86,7 +86,7 @@ pub fn CondBr(cx: &Block,\n     B(cx).cond_br(if_, then, else_);\n }\n \n-pub fn Switch(cx: &Block, v: ValueRef, else_: BasicBlockRef, num_cases: uint)\n+pub fn Switch(cx: Block, v: ValueRef, else_: BasicBlockRef, num_cases: uint)\n     -> ValueRef {\n     if cx.unreachable.get() { return _Undef(v); }\n     check_not_terminated(cx);\n@@ -101,14 +101,14 @@ pub fn AddCase(s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n     }\n }\n \n-pub fn IndirectBr(cx: &Block, addr: ValueRef, num_dests: uint) {\n+pub fn IndirectBr(cx: Block, addr: ValueRef, num_dests: uint) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"IndirectBr\");\n     B(cx).indirect_br(addr, num_dests);\n }\n \n-pub fn Invoke(cx: &Block,\n+pub fn Invoke(cx: Block,\n               fn_: ValueRef,\n               args: &[ValueRef],\n               then: BasicBlockRef,\n@@ -126,7 +126,7 @@ pub fn Invoke(cx: &Block,\n     B(cx).invoke(fn_, args, then, catch, attributes)\n }\n \n-pub fn Unreachable(cx: &Block) {\n+pub fn Unreachable(cx: Block) {\n     if cx.unreachable.get() {\n         return\n     }\n@@ -143,163 +143,163 @@ pub fn _Undef(val: ValueRef) -> ValueRef {\n }\n \n /* Arithmetic */\n-pub fn Add(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn Add(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).add(lhs, rhs)\n }\n \n-pub fn NSWAdd(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn NSWAdd(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).nswadd(lhs, rhs)\n }\n \n-pub fn NUWAdd(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn NUWAdd(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).nuwadd(lhs, rhs)\n }\n \n-pub fn FAdd(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn FAdd(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).fadd(lhs, rhs)\n }\n \n-pub fn Sub(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn Sub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).sub(lhs, rhs)\n }\n \n-pub fn NSWSub(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn NSWSub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).nswsub(lhs, rhs)\n }\n \n-pub fn NUWSub(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn NUWSub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).nuwsub(lhs, rhs)\n }\n \n-pub fn FSub(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn FSub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).fsub(lhs, rhs)\n }\n \n-pub fn Mul(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn Mul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).mul(lhs, rhs)\n }\n \n-pub fn NSWMul(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn NSWMul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).nswmul(lhs, rhs)\n }\n \n-pub fn NUWMul(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn NUWMul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).nuwmul(lhs, rhs)\n }\n \n-pub fn FMul(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn FMul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).fmul(lhs, rhs)\n }\n \n-pub fn UDiv(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn UDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).udiv(lhs, rhs)\n }\n \n-pub fn SDiv(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn SDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).sdiv(lhs, rhs)\n }\n \n-pub fn ExactSDiv(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn ExactSDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).exactsdiv(lhs, rhs)\n }\n \n-pub fn FDiv(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn FDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).fdiv(lhs, rhs)\n }\n \n-pub fn URem(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn URem(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).urem(lhs, rhs)\n }\n \n-pub fn SRem(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn SRem(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).srem(lhs, rhs)\n }\n \n-pub fn FRem(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn FRem(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).frem(lhs, rhs)\n }\n \n-pub fn Shl(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn Shl(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).shl(lhs, rhs)\n }\n \n-pub fn LShr(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn LShr(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).lshr(lhs, rhs)\n }\n \n-pub fn AShr(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn AShr(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).ashr(lhs, rhs)\n }\n \n-pub fn And(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn And(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).and(lhs, rhs)\n }\n \n-pub fn Or(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn Or(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).or(lhs, rhs)\n }\n \n-pub fn Xor(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn Xor(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).xor(lhs, rhs)\n }\n \n-pub fn BinOp(cx: &Block, op: Opcode, lhs: ValueRef, rhs: ValueRef)\n+pub fn BinOp(cx: Block, op: Opcode, lhs: ValueRef, rhs: ValueRef)\n           -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).binop(op, lhs, rhs)\n }\n \n-pub fn Neg(cx: &Block, v: ValueRef) -> ValueRef {\n+pub fn Neg(cx: Block, v: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(v); }\n     B(cx).neg(v)\n }\n \n-pub fn NSWNeg(cx: &Block, v: ValueRef) -> ValueRef {\n+pub fn NSWNeg(cx: Block, v: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(v); }\n     B(cx).nswneg(v)\n }\n \n-pub fn NUWNeg(cx: &Block, v: ValueRef) -> ValueRef {\n+pub fn NUWNeg(cx: Block, v: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(v); }\n     B(cx).nuwneg(v)\n }\n-pub fn FNeg(cx: &Block, v: ValueRef) -> ValueRef {\n+pub fn FNeg(cx: Block, v: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(v); }\n     B(cx).fneg(v)\n }\n \n-pub fn Not(cx: &Block, v: ValueRef) -> ValueRef {\n+pub fn Not(cx: Block, v: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(v); }\n     B(cx).not(v)\n }\n \n /* Memory */\n-pub fn Malloc(cx: &Block, ty: Type) -> ValueRef {\n+pub fn Malloc(cx: Block, ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n@@ -308,7 +308,7 @@ pub fn Malloc(cx: &Block, ty: Type) -> ValueRef {\n     }\n }\n \n-pub fn ArrayMalloc(cx: &Block, ty: Type, val: ValueRef) -> ValueRef {\n+pub fn ArrayMalloc(cx: Block, ty: Type, val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n@@ -317,7 +317,7 @@ pub fn ArrayMalloc(cx: &Block, ty: Type, val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn Alloca(cx: &Block, ty: Type, name: &str) -> ValueRef {\n+pub fn Alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.ptr_to().to_ref()); }\n         AllocaFcx(cx.fcx, ty, name)\n@@ -330,7 +330,7 @@ pub fn AllocaFcx(fcx: &FunctionContext, ty: Type, name: &str) -> ValueRef {\n     b.alloca(ty, name)\n }\n \n-pub fn ArrayAlloca(cx: &Block, ty: Type, val: ValueRef) -> ValueRef {\n+pub fn ArrayAlloca(cx: Block, ty: Type, val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n@@ -339,12 +339,12 @@ pub fn ArrayAlloca(cx: &Block, ty: Type, val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn Free(cx: &Block, pointer_val: ValueRef) {\n+pub fn Free(cx: Block, pointer_val: ValueRef) {\n     if cx.unreachable.get() { return; }\n     B(cx).free(pointer_val)\n }\n \n-pub fn Load(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n+pub fn Load(cx: Block, pointer_val: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable.get() {\n@@ -360,7 +360,7 @@ pub fn Load(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn VolatileLoad(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n+pub fn VolatileLoad(cx: Block, pointer_val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -369,7 +369,7 @@ pub fn VolatileLoad(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn AtomicLoad(cx: &Block, pointer_val: ValueRef, order: AtomicOrdering) -> ValueRef {\n+pub fn AtomicLoad(cx: Block, pointer_val: ValueRef, order: AtomicOrdering) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable.get() {\n@@ -380,7 +380,7 @@ pub fn AtomicLoad(cx: &Block, pointer_val: ValueRef, order: AtomicOrdering) -> V\n }\n \n \n-pub fn LoadRangeAssert(cx: &Block, pointer_val: ValueRef, lo: c_ulonglong,\n+pub fn LoadRangeAssert(cx: Block, pointer_val: ValueRef, lo: c_ulonglong,\n                        hi: c_ulonglong, signed: llvm::Bool) -> ValueRef {\n     if cx.unreachable.get() {\n         let ccx = cx.fcx.ccx;\n@@ -398,22 +398,22 @@ pub fn LoadRangeAssert(cx: &Block, pointer_val: ValueRef, lo: c_ulonglong,\n     }\n }\n \n-pub fn Store(cx: &Block, val: ValueRef, ptr: ValueRef) {\n+pub fn Store(cx: Block, val: ValueRef, ptr: ValueRef) {\n     if cx.unreachable.get() { return; }\n     B(cx).store(val, ptr)\n }\n \n-pub fn VolatileStore(cx: &Block, val: ValueRef, ptr: ValueRef) {\n+pub fn VolatileStore(cx: Block, val: ValueRef, ptr: ValueRef) {\n     if cx.unreachable.get() { return; }\n     B(cx).volatile_store(val, ptr)\n }\n \n-pub fn AtomicStore(cx: &Block, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n+pub fn AtomicStore(cx: Block, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n     if cx.unreachable.get() { return; }\n     B(cx).atomic_store(val, ptr, order)\n }\n \n-pub fn GEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n+pub fn GEP(cx: Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n@@ -425,7 +425,7 @@ pub fn GEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_i32()\n #[inline]\n-pub fn GEPi(cx: &Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n+pub fn GEPi(cx: Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n@@ -434,7 +434,7 @@ pub fn GEPi(cx: &Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     }\n }\n \n-pub fn InBoundsGEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n+pub fn InBoundsGEP(cx: Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n@@ -443,7 +443,7 @@ pub fn InBoundsGEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> Value\n     }\n }\n \n-pub fn StructGEP(cx: &Block, pointer: ValueRef, idx: uint) -> ValueRef {\n+pub fn StructGEP(cx: Block, pointer: ValueRef, idx: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n@@ -452,7 +452,7 @@ pub fn StructGEP(cx: &Block, pointer: ValueRef, idx: uint) -> ValueRef {\n     }\n }\n \n-pub fn GlobalString(cx: &Block, _str: *const c_char) -> ValueRef {\n+pub fn GlobalString(cx: Block, _str: *const c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n@@ -461,7 +461,7 @@ pub fn GlobalString(cx: &Block, _str: *const c_char) -> ValueRef {\n     }\n }\n \n-pub fn GlobalStringPtr(cx: &Block, _str: *const c_char) -> ValueRef {\n+pub fn GlobalStringPtr(cx: Block, _str: *const c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n@@ -471,112 +471,112 @@ pub fn GlobalStringPtr(cx: &Block, _str: *const c_char) -> ValueRef {\n }\n \n /* Casts */\n-pub fn Trunc(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn Trunc(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).trunc(val, dest_ty)\n     }\n }\n \n-pub fn ZExt(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn ZExt(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).zext(val, dest_ty)\n     }\n }\n \n-pub fn SExt(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn SExt(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).sext(val, dest_ty)\n     }\n }\n \n-pub fn FPToUI(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn FPToUI(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).fptoui(val, dest_ty)\n     }\n }\n \n-pub fn FPToSI(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn FPToSI(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).fptosi(val, dest_ty)\n     }\n }\n \n-pub fn UIToFP(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn UIToFP(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).uitofp(val, dest_ty)\n     }\n }\n \n-pub fn SIToFP(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn SIToFP(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).sitofp(val, dest_ty)\n     }\n }\n \n-pub fn FPTrunc(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn FPTrunc(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).fptrunc(val, dest_ty)\n     }\n }\n \n-pub fn FPExt(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn FPExt(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).fpext(val, dest_ty)\n     }\n }\n \n-pub fn PtrToInt(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn PtrToInt(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).ptrtoint(val, dest_ty)\n     }\n }\n \n-pub fn IntToPtr(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn IntToPtr(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).inttoptr(val, dest_ty)\n     }\n }\n \n-pub fn BitCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn BitCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).bitcast(val, dest_ty)\n     }\n }\n \n-pub fn ZExtOrBitCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn ZExtOrBitCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).zext_or_bitcast(val, dest_ty)\n     }\n }\n \n-pub fn SExtOrBitCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn SExtOrBitCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).sext_or_bitcast(val, dest_ty)\n     }\n }\n \n-pub fn TruncOrBitCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn TruncOrBitCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).trunc_or_bitcast(val, dest_ty)\n     }\n }\n \n-pub fn Cast(cx: &Block, op: Opcode, val: ValueRef, dest_ty: Type,\n+pub fn Cast(cx: Block, op: Opcode, val: ValueRef, dest_ty: Type,\n             _: *const u8)\n      -> ValueRef {\n     unsafe {\n@@ -585,21 +585,21 @@ pub fn Cast(cx: &Block, op: Opcode, val: ValueRef, dest_ty: Type,\n     }\n }\n \n-pub fn PointerCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn PointerCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).pointercast(val, dest_ty)\n     }\n }\n \n-pub fn IntCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn IntCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).intcast(val, dest_ty)\n     }\n }\n \n-pub fn FPCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn FPCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).fpcast(val, dest_ty)\n@@ -608,7 +608,7 @@ pub fn FPCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n \n \n /* Comparisons */\n-pub fn ICmp(cx: &Block, op: IntPredicate, lhs: ValueRef, rhs: ValueRef)\n+pub fn ICmp(cx: Block, op: IntPredicate, lhs: ValueRef, rhs: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n@@ -618,7 +618,7 @@ pub fn ICmp(cx: &Block, op: IntPredicate, lhs: ValueRef, rhs: ValueRef)\n     }\n }\n \n-pub fn FCmp(cx: &Block, op: RealPredicate, lhs: ValueRef, rhs: ValueRef)\n+pub fn FCmp(cx: Block, op: RealPredicate, lhs: ValueRef, rhs: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n@@ -629,14 +629,14 @@ pub fn FCmp(cx: &Block, op: RealPredicate, lhs: ValueRef, rhs: ValueRef)\n }\n \n /* Miscellaneous instructions */\n-pub fn EmptyPhi(cx: &Block, ty: Type) -> ValueRef {\n+pub fn EmptyPhi(cx: Block, ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.to_ref()); }\n         B(cx).empty_phi(ty)\n     }\n }\n \n-pub fn Phi(cx: &Block, ty: Type, vals: &[ValueRef],\n+pub fn Phi(cx: Block, ty: Type, vals: &[ValueRef],\n            bbs: &[BasicBlockRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.to_ref()); }\n@@ -651,7 +651,7 @@ pub fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     }\n }\n \n-pub fn _UndefReturn(cx: &Block, fn_: ValueRef) -> ValueRef {\n+pub fn _UndefReturn(cx: Block, fn_: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(fn_);\n@@ -665,51 +665,51 @@ pub fn _UndefReturn(cx: &Block, fn_: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn add_span_comment(cx: &Block, sp: Span, text: &str) {\n+pub fn add_span_comment(cx: Block, sp: Span, text: &str) {\n     B(cx).add_span_comment(sp, text)\n }\n \n-pub fn add_comment(cx: &Block, text: &str) {\n+pub fn add_comment(cx: Block, text: &str) {\n     B(cx).add_comment(text)\n }\n \n-pub fn InlineAsmCall(cx: &Block, asm: *const c_char, cons: *const c_char,\n+pub fn InlineAsmCall(cx: Block, asm: *const c_char, cons: *const c_char,\n                      inputs: &[ValueRef], output: Type,\n                      volatile: bool, alignstack: bool,\n                      dia: AsmDialect) -> ValueRef {\n     B(cx).inline_asm_call(asm, cons, inputs, output, volatile, alignstack, dia)\n }\n \n-pub fn Call(cx: &Block, fn_: ValueRef, args: &[ValueRef],\n+pub fn Call(cx: Block, fn_: ValueRef, args: &[ValueRef],\n             attributes: Option<AttrBuilder>) -> ValueRef {\n     if cx.unreachable.get() { return _UndefReturn(cx, fn_); }\n     B(cx).call(fn_, args, attributes)\n }\n \n-pub fn CallWithConv(cx: &Block, fn_: ValueRef, args: &[ValueRef], conv: CallConv,\n+pub fn CallWithConv(cx: Block, fn_: ValueRef, args: &[ValueRef], conv: CallConv,\n                     attributes: Option<AttrBuilder>) -> ValueRef {\n     if cx.unreachable.get() { return _UndefReturn(cx, fn_); }\n     B(cx).call_with_conv(fn_, args, conv, attributes)\n }\n \n-pub fn AtomicFence(cx: &Block, order: AtomicOrdering) {\n+pub fn AtomicFence(cx: Block, order: AtomicOrdering) {\n     if cx.unreachable.get() { return; }\n     B(cx).atomic_fence(order)\n }\n \n-pub fn Select(cx: &Block, if_: ValueRef, then: ValueRef, else_: ValueRef) -> ValueRef {\n+pub fn Select(cx: Block, if_: ValueRef, then: ValueRef, else_: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(then); }\n     B(cx).select(if_, then, else_)\n }\n \n-pub fn VAArg(cx: &Block, list: ValueRef, ty: Type) -> ValueRef {\n+pub fn VAArg(cx: Block, list: ValueRef, ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.to_ref()); }\n         B(cx).va_arg(list, ty)\n     }\n }\n \n-pub fn ExtractElement(cx: &Block, vec_val: ValueRef, index: ValueRef) -> ValueRef {\n+pub fn ExtractElement(cx: Block, vec_val: ValueRef, index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -718,7 +718,7 @@ pub fn ExtractElement(cx: &Block, vec_val: ValueRef, index: ValueRef) -> ValueRe\n     }\n }\n \n-pub fn InsertElement(cx: &Block, vec_val: ValueRef, elt_val: ValueRef,\n+pub fn InsertElement(cx: Block, vec_val: ValueRef, elt_val: ValueRef,\n                      index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n@@ -728,7 +728,7 @@ pub fn InsertElement(cx: &Block, vec_val: ValueRef, elt_val: ValueRef,\n     }\n }\n \n-pub fn ShuffleVector(cx: &Block, v1: ValueRef, v2: ValueRef,\n+pub fn ShuffleVector(cx: Block, v1: ValueRef, v2: ValueRef,\n                      mask: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n@@ -738,7 +738,7 @@ pub fn ShuffleVector(cx: &Block, v1: ValueRef, v2: ValueRef,\n     }\n }\n \n-pub fn VectorSplat(cx: &Block, num_elts: uint, elt_val: ValueRef) -> ValueRef {\n+pub fn VectorSplat(cx: Block, num_elts: uint, elt_val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -747,7 +747,7 @@ pub fn VectorSplat(cx: &Block, num_elts: uint, elt_val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn ExtractValue(cx: &Block, agg_val: ValueRef, index: uint) -> ValueRef {\n+pub fn ExtractValue(cx: Block, agg_val: ValueRef, index: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -756,7 +756,7 @@ pub fn ExtractValue(cx: &Block, agg_val: ValueRef, index: uint) -> ValueRef {\n     }\n }\n \n-pub fn InsertValue(cx: &Block, agg_val: ValueRef, elt_val: ValueRef, index: uint) -> ValueRef {\n+pub fn InsertValue(cx: Block, agg_val: ValueRef, elt_val: ValueRef, index: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -765,7 +765,7 @@ pub fn InsertValue(cx: &Block, agg_val: ValueRef, elt_val: ValueRef, index: uint\n     }\n }\n \n-pub fn IsNull(cx: &Block, val: ValueRef) -> ValueRef {\n+pub fn IsNull(cx: Block, val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n@@ -774,7 +774,7 @@ pub fn IsNull(cx: &Block, val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn IsNotNull(cx: &Block, val: ValueRef) -> ValueRef {\n+pub fn IsNotNull(cx: Block, val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n@@ -783,44 +783,44 @@ pub fn IsNotNull(cx: &Block, val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn PtrDiff(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn PtrDiff(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ccx.int_type().to_ref()); }\n         B(cx).ptrdiff(lhs, rhs)\n     }\n }\n \n-pub fn Trap(cx: &Block) {\n+pub fn Trap(cx: Block) {\n     if cx.unreachable.get() { return; }\n     B(cx).trap();\n }\n \n-pub fn LandingPad(cx: &Block, ty: Type, pers_fn: ValueRef,\n+pub fn LandingPad(cx: Block, ty: Type, pers_fn: ValueRef,\n                   num_clauses: uint) -> ValueRef {\n     check_not_terminated(cx);\n     assert!(!cx.unreachable.get());\n     B(cx).landing_pad(ty, pers_fn, num_clauses)\n }\n \n-pub fn SetCleanup(cx: &Block, landing_pad: ValueRef) {\n+pub fn SetCleanup(cx: Block, landing_pad: ValueRef) {\n     B(cx).set_cleanup(landing_pad)\n }\n \n-pub fn Resume(cx: &Block, exn: ValueRef) -> ValueRef {\n+pub fn Resume(cx: Block, exn: ValueRef) -> ValueRef {\n     check_not_terminated(cx);\n     terminate(cx, \"Resume\");\n     B(cx).resume(exn)\n }\n \n // Atomic Operations\n-pub fn AtomicCmpXchg(cx: &Block, dst: ValueRef,\n+pub fn AtomicCmpXchg(cx: Block, dst: ValueRef,\n                      cmp: ValueRef, src: ValueRef,\n                      order: AtomicOrdering,\n                      failure_order: AtomicOrdering) -> ValueRef {\n     B(cx).atomic_cmpxchg(dst, cmp, src, order, failure_order)\n }\n-pub fn AtomicRMW(cx: &Block, op: AtomicBinOp,\n+pub fn AtomicRMW(cx: Block, op: AtomicBinOp,\n                  dst: ValueRef, src: ValueRef,\n                  order: AtomicOrdering) -> ValueRef {\n     B(cx).atomic_rmw(op, dst, src, order)"}, {"sha": "ca7adb97f3d5453a4b0229e6fc866f619c008f48", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -23,9 +23,9 @@ use libc::{c_uint, c_ulonglong, c_char};\n use std::string::String;\n use syntax::codemap::Span;\n \n-pub struct Builder<'a> {\n+pub struct Builder<'a, 'tcx: 'a> {\n     pub llbuilder: BuilderRef,\n-    pub ccx: &'a CrateContext<'a>,\n+    pub ccx: &'a CrateContext<'a, 'tcx>,\n }\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n@@ -35,8 +35,8 @@ pub fn noname() -> *const c_char {\n     &cnull as *const c_char\n }\n \n-impl<'a> Builder<'a> {\n-    pub fn new(ccx: &'a CrateContext) -> Builder<'a> {\n+impl<'a, 'tcx> Builder<'a, 'tcx> {\n+    pub fn new(ccx: &'a CrateContext<'a, 'tcx>) -> Builder<'a, 'tcx> {\n         Builder {\n             llbuilder: ccx.raw_builder(),\n             ccx: ccx,"}, {"sha": "5d66ec0a4b936df092a2e9f100fa5e9d664e7c1e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 66, "deletions": 69, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -80,12 +80,13 @@ pub enum CalleeData {\n     TraitItem(MethodData)\n }\n \n-pub struct Callee<'a> {\n-    pub bcx: &'a Block<'a>,\n+pub struct Callee<'blk, 'tcx: 'blk> {\n+    pub bcx: Block<'blk, 'tcx>,\n     pub data: CalleeData,\n }\n \n-fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n+fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n+                     -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_callee\");\n     debug!(\"callee::trans(expr={})\", expr.repr(bcx.tcx()));\n \n@@ -100,7 +101,8 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n     // any other expressions are closures:\n     return datum_callee(bcx, expr);\n \n-    fn datum_callee<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n+    fn datum_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n+                                -> Callee<'blk, 'tcx> {\n         let DatumBlock {bcx: mut bcx, datum} = expr::trans(bcx, expr);\n         match ty::get(datum.ty).sty {\n             ty::ty_bare_fn(..) => {\n@@ -128,15 +130,16 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n         }\n     }\n \n-    fn fn_callee<'a>(bcx: &'a Block<'a>, llfn: ValueRef) -> Callee<'a> {\n+    fn fn_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, llfn: ValueRef)\n+                             -> Callee<'blk, 'tcx> {\n         return Callee {\n             bcx: bcx,\n             data: Fn(llfn),\n         };\n     }\n \n-    fn trans_def<'a>(bcx: &'a Block<'a>, def: def::Def, ref_expr: &ast::Expr)\n-                 -> Callee<'a> {\n+    fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, def: def::Def, ref_expr: &ast::Expr)\n+                             -> Callee<'blk, 'tcx> {\n         debug!(\"trans_def(def={}, ref_expr={})\", def.repr(bcx.tcx()), ref_expr.repr(bcx.tcx()));\n         let expr_ty = node_id_type(bcx, ref_expr.id);\n         match def {\n@@ -214,7 +217,7 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n     }\n }\n \n-pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, node: ExprOrMethodCall) -> ValueRef {\n+pub fn trans_fn_ref(bcx: Block, def_id: ast::DefId, node: ExprOrMethodCall) -> ValueRef {\n     /*!\n      * Translates a reference (with id `ref_id`) to the fn/method\n      * with id `def_id` into a function pointer.  This may require\n@@ -237,12 +240,12 @@ pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, node: ExprOrMethodCall) ->\n     trans_fn_ref_with_vtables(bcx, def_id, node, substs, vtables)\n }\n \n-fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n-                                           def_id: ast::DefId,\n-                                           ref_id: ast::NodeId,\n-                                           substs: subst::Substs,\n-                                           vtables: typeck::vtable_res)\n-                                           -> Callee<'a> {\n+fn trans_fn_ref_with_vtables_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                                   def_id: ast::DefId,\n+                                                   ref_id: ast::NodeId,\n+                                                   substs: subst::Substs,\n+                                                   vtables: typeck::vtable_res)\n+                                                   -> Callee<'blk, 'tcx> {\n     Callee {\n         bcx: bcx,\n         data: Fn(trans_fn_ref_with_vtables(bcx,\n@@ -253,7 +256,7 @@ fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-fn resolve_default_method_vtables(bcx: &Block,\n+fn resolve_default_method_vtables(bcx: Block,\n                                   impl_id: ast::DefId,\n                                   substs: &subst::Substs,\n                                   impl_vtables: typeck::vtable_res)\n@@ -281,7 +284,7 @@ fn resolve_default_method_vtables(bcx: &Block,\n \n /// Translates the adapter that deconstructs a `Box<Trait>` object into\n /// `Trait` so that a by-value self method can be called.\n-pub fn trans_unboxing_shim(bcx: &Block,\n+pub fn trans_unboxing_shim(bcx: Block,\n                            llshimmedfn: ValueRef,\n                            fty: &ty::BareFnTy,\n                            method_id: ast::DefId,\n@@ -406,7 +409,7 @@ pub fn trans_unboxing_shim(bcx: &Block,\n }\n \n pub fn trans_fn_ref_with_vtables(\n-    bcx: &Block,                 //\n+    bcx: Block,                  //\n     def_id: ast::DefId,          // def id of fn\n     node: ExprOrMethodCall,      // node id of use of fn; may be zero if N/A\n     substs: subst::Substs,       // values for fn's ty params\n@@ -625,13 +628,12 @@ pub fn trans_fn_ref_with_vtables(\n // ______________________________________________________________________\n // Translating calls\n \n-pub fn trans_call<'a>(\n-                  in_cx: &'a Block<'a>,\n-                  call_ex: &ast::Expr,\n-                  f: &ast::Expr,\n-                  args: CallArgs,\n-                  dest: expr::Dest)\n-                  -> &'a Block<'a> {\n+pub fn trans_call<'blk, 'tcx>(in_cx: Block<'blk, 'tcx>,\n+                              call_ex: &ast::Expr,\n+                              f: &ast::Expr,\n+                              args: CallArgs,\n+                              dest: expr::Dest)\n+                              -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_call\");\n     trans_call_inner(in_cx,\n                      Some(common::expr_info(call_ex)),\n@@ -641,13 +643,12 @@ pub fn trans_call<'a>(\n                      Some(dest)).bcx\n }\n \n-pub fn trans_method_call<'a>(\n-                         bcx: &'a Block<'a>,\n-                         call_ex: &ast::Expr,\n-                         rcvr: &ast::Expr,\n-                         args: CallArgs,\n-                         dest: expr::Dest)\n-                         -> &'a Block<'a> {\n+pub fn trans_method_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     call_ex: &ast::Expr,\n+                                     rcvr: &ast::Expr,\n+                                     args: CallArgs,\n+                                     dest: expr::Dest)\n+                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex={})\", call_ex.repr(bcx.tcx()));\n     let method_call = MethodCall::expr(call_ex.id);\n@@ -663,12 +664,11 @@ pub fn trans_method_call<'a>(\n         Some(dest)).bcx\n }\n \n-pub fn trans_lang_call<'a>(\n-                       bcx: &'a Block<'a>,\n-                       did: ast::DefId,\n-                       args: &[ValueRef],\n-                       dest: Option<expr::Dest>)\n-                       -> Result<'a> {\n+pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   did: ast::DefId,\n+                                   args: &[ValueRef],\n+                                   dest: Option<expr::Dest>)\n+                                   -> Result<'blk, 'tcx> {\n     let fty = if did.krate == ast::LOCAL_CRATE {\n         ty::node_id_to_type(bcx.tcx(), did.node)\n     } else {\n@@ -688,16 +688,15 @@ pub fn trans_lang_call<'a>(\n                              dest)\n }\n \n-pub fn trans_call_inner<'a>(\n-                        bcx: &'a Block<'a>,\n-                        call_info: Option<NodeInfo>,\n-                        callee_ty: ty::t,\n-                        get_callee: |bcx: &'a Block<'a>,\n-                                     arg_cleanup_scope: cleanup::ScopeId|\n-                                     -> Callee<'a>,\n-                        args: CallArgs,\n-                        dest: Option<expr::Dest>)\n-                        -> Result<'a> {\n+pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    call_info: Option<NodeInfo>,\n+                                    callee_ty: ty::t,\n+                                    get_callee: |bcx: Block<'blk, 'tcx>,\n+                                                arg_cleanup_scope: cleanup::ScopeId|\n+                                                -> Callee<'blk, 'tcx>,\n+                                    args: CallArgs,\n+                                    dest: Option<expr::Dest>)\n+                                    -> Result<'blk, 'tcx> {\n     /*!\n      * This behemoth of a function translates function calls.\n      * Unfortunately, in order to generate more efficient LLVM\n@@ -920,14 +919,14 @@ pub enum CallArgs<'a> {\n     ArgOverloadedCall(&'a [Gc<ast::Expr>]),\n }\n \n-fn trans_args_under_call_abi<'a>(\n-                             mut bcx: &'a Block<'a>,\n+fn trans_args_under_call_abi<'blk, 'tcx>(\n+                             mut bcx: Block<'blk, 'tcx>,\n                              arg_exprs: &[Gc<ast::Expr>],\n                              fn_ty: ty::t,\n                              llargs: &mut Vec<ValueRef>,\n                              arg_cleanup_scope: cleanup::ScopeId,\n                              ignore_self: bool)\n-                             -> &'a Block<'a> {\n+                             -> Block<'blk, 'tcx> {\n     // Translate the `self` argument first.\n     let arg_tys = ty::ty_fn_args(fn_ty);\n     if !ignore_self {\n@@ -981,14 +980,14 @@ fn trans_args_under_call_abi<'a>(\n     bcx\n }\n \n-fn trans_overloaded_call_args<'a>(\n-                              mut bcx: &'a Block<'a>,\n+fn trans_overloaded_call_args<'blk, 'tcx>(\n+                              mut bcx: Block<'blk, 'tcx>,\n                               arg_exprs: &[Gc<ast::Expr>],\n                               fn_ty: ty::t,\n                               llargs: &mut Vec<ValueRef>,\n                               arg_cleanup_scope: cleanup::ScopeId,\n                               ignore_self: bool)\n-                              -> &'a Block<'a> {\n+                              -> Block<'blk, 'tcx> {\n     // Translate the `self` argument first.\n     let arg_tys = ty::ty_fn_args(fn_ty);\n     if !ignore_self {\n@@ -1028,15 +1027,14 @@ fn trans_overloaded_call_args<'a>(\n     bcx\n }\n \n-pub fn trans_args<'a>(\n-                  cx: &'a Block<'a>,\n-                  args: CallArgs,\n-                  fn_ty: ty::t,\n-                  llargs: &mut Vec<ValueRef> ,\n-                  arg_cleanup_scope: cleanup::ScopeId,\n-                  ignore_self: bool,\n-                  abi: synabi::Abi)\n-                  -> &'a Block<'a> {\n+pub fn trans_args<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                              args: CallArgs,\n+                              fn_ty: ty::t,\n+                              llargs: &mut Vec<ValueRef> ,\n+                              arg_cleanup_scope: cleanup::ScopeId,\n+                              ignore_self: bool,\n+                              abi: synabi::Abi)\n+                              -> Block<'blk, 'tcx> {\n     debug!(\"trans_args(abi={})\", abi);\n \n     let _icx = push_ctxt(\"trans_args\");\n@@ -1124,13 +1122,12 @@ pub enum AutorefArg {\n     DoAutorefArg(ast::NodeId)\n }\n \n-pub fn trans_arg_datum<'a>(\n-                      bcx: &'a Block<'a>,\n-                      formal_arg_ty: ty::t,\n-                      arg_datum: Datum<Expr>,\n-                      arg_cleanup_scope: cleanup::ScopeId,\n-                      autoref_arg: AutorefArg)\n-                      -> Result<'a> {\n+pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   formal_arg_ty: ty::t,\n+                                   arg_datum: Datum<Expr>,\n+                                   arg_cleanup_scope: cleanup::ScopeId,\n+                                   autoref_arg: AutorefArg)\n+                                   -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_arg_datum\");\n     let mut bcx = bcx;\n     let ccx = bcx.ccx();"}, {"sha": "4d54308031e92cc0dc46697a36be721108cf8207", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -25,13 +25,13 @@ use middle::ty;\n use syntax::ast;\n use util::ppaux::Repr;\n \n-pub struct CleanupScope<'a> {\n+pub struct CleanupScope<'blk, 'tcx: 'blk> {\n     // The id of this cleanup scope. If the id is None,\n     // this is a *temporary scope* that is pushed during trans to\n     // cleanup miscellaneous garbage that trans may generate whose\n     // lifetime is a subset of some expression.  See module doc for\n     // more details.\n-    kind: CleanupScopeKind<'a>,\n+    kind: CleanupScopeKind<'blk, 'tcx>,\n \n     // Cleanups to run upon scope exit.\n     cleanups: Vec<CleanupObj>,\n@@ -48,10 +48,10 @@ pub static EXIT_BREAK: uint = 0;\n pub static EXIT_LOOP: uint = 1;\n pub static EXIT_MAX: uint = 2;\n \n-pub enum CleanupScopeKind<'a> {\n+pub enum CleanupScopeKind<'blk, 'tcx: 'blk> {\n     CustomScopeKind,\n     AstScopeKind(ast::NodeId),\n-    LoopScopeKind(ast::NodeId, [&'a Block<'a>, ..EXIT_MAX])\n+    LoopScopeKind(ast::NodeId, [Block<'blk, 'tcx>, ..EXIT_MAX])\n }\n \n #[deriving(PartialEq)]\n@@ -69,7 +69,7 @@ pub struct CachedEarlyExit {\n pub trait Cleanup {\n     fn must_unwind(&self) -> bool;\n     fn clean_on_unwind(&self) -> bool;\n-    fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a>;\n+    fn trans<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>) -> Block<'blk, 'tcx>;\n }\n \n pub type CleanupObj = Box<Cleanup+'static>;\n@@ -79,7 +79,7 @@ pub enum ScopeId {\n     CustomScope(CustomScopeIndex)\n }\n \n-impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n+impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn push_ast_cleanup_scope(&self, id: ast::NodeId) {\n         /*!\n          * Invoked when we start to trans the code contained\n@@ -109,7 +109,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n     fn push_loop_cleanup_scope(&self,\n                                id: ast::NodeId,\n-                               exits: [&'a Block<'a>, ..EXIT_MAX]) {\n+                               exits: [Block<'blk, 'tcx>, ..EXIT_MAX]) {\n         debug!(\"push_loop_cleanup_scope({})\",\n                self.ccx.tcx().map.node_to_string(id));\n         assert_eq!(Some(id), self.top_ast_scope());\n@@ -125,9 +125,9 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n     }\n \n     fn pop_and_trans_ast_cleanup_scope(&self,\n-                                       bcx: &'a Block<'a>,\n+                                       bcx: Block<'blk, 'tcx>,\n                                        cleanup_scope: ast::NodeId)\n-                                       -> &'a Block<'a> {\n+                                       -> Block<'blk, 'tcx> {\n         /*!\n          * Removes the cleanup scope for id `cleanup_scope`, which\n          * must be at the top of the cleanup stack, and generates the\n@@ -175,9 +175,9 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n     }\n \n     fn pop_and_trans_custom_cleanup_scope(&self,\n-                                        bcx: &'a Block<'a>,\n+                                        bcx: Block<'blk, 'tcx>,\n                                         custom_scope: CustomScopeIndex)\n-                                        -> &'a Block<'a> {\n+                                        -> Block<'blk, 'tcx> {\n         /*!\n          * Removes the top cleanup scope from the stack, which must be\n          * a temporary scope, and generates the code to do its\n@@ -207,7 +207,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         self.ccx.sess().bug(\"no loop scope found\");\n     }\n \n-    fn normal_exit_block(&'a self,\n+    fn normal_exit_block(&'blk self,\n                          cleanup_scope: ast::NodeId,\n                          exit: uint) -> BasicBlockRef {\n         /*!\n@@ -219,7 +219,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         self.trans_cleanups_to_exit_scope(LoopExit(cleanup_scope, exit))\n     }\n \n-    fn return_exit_block(&'a self) -> BasicBlockRef {\n+    fn return_exit_block(&'blk self) -> BasicBlockRef {\n         /*!\n          * Returns a block to branch to which will perform all pending\n          * cleanups and then return from this function\n@@ -426,7 +426,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         self.scopes.borrow().iter().rev().any(|s| s.needs_invoke())\n     }\n \n-    fn get_landing_pad(&'a self) -> BasicBlockRef {\n+    fn get_landing_pad(&'blk self) -> BasicBlockRef {\n         /*!\n          * Returns a basic block to branch to in the event of a failure.\n          * This block will run the failure cleanups and eventually\n@@ -464,7 +464,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n     }\n }\n \n-impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n+impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn top_ast_scope(&self) -> Option<ast::NodeId> {\n         /*!\n          * Returns the id of the current top-most AST scope, if any.\n@@ -496,8 +496,8 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n     }\n \n     fn trans_scope_cleanups(&self, // cannot borrow self, will recurse\n-                            bcx: &'a Block<'a>,\n-                            scope: &CleanupScope) -> &'a Block<'a> {\n+                            bcx: Block<'blk, 'tcx>,\n+                            scope: &CleanupScope) -> Block<'blk, 'tcx> {\n         /*! Generates the cleanups for `scope` into `bcx` */\n \n         let mut bcx = bcx;\n@@ -513,23 +513,23 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n         self.scopes.borrow().len()\n     }\n \n-    fn push_scope(&self, scope: CleanupScope<'a>) {\n+    fn push_scope(&self, scope: CleanupScope<'blk, 'tcx>) {\n         self.scopes.borrow_mut().push(scope)\n     }\n \n-    fn pop_scope(&self) -> CleanupScope<'a> {\n+    fn pop_scope(&self) -> CleanupScope<'blk, 'tcx> {\n         debug!(\"popping cleanup scope {}, {} scopes remaining\",\n                self.top_scope(|s| s.block_name(\"\")),\n                self.scopes_len() - 1);\n \n         self.scopes.borrow_mut().pop().unwrap()\n     }\n \n-    fn top_scope<R>(&self, f: |&CleanupScope<'a>| -> R) -> R {\n+    fn top_scope<R>(&self, f: |&CleanupScope<'blk, 'tcx>| -> R) -> R {\n         f(self.scopes.borrow().last().unwrap())\n     }\n \n-    fn trans_cleanups_to_exit_scope(&'a self,\n+    fn trans_cleanups_to_exit_scope(&'blk self,\n                                     label: EarlyExitLabel)\n                                     -> BasicBlockRef {\n         /*!\n@@ -691,7 +691,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n         prev_llbb\n     }\n \n-    fn get_or_create_landing_pad(&'a self) -> BasicBlockRef {\n+    fn get_or_create_landing_pad(&'blk self) -> BasicBlockRef {\n         /*!\n          * Creates a landing pad for the top scope, if one does not\n          * exist.  The landing pad will perform all cleanups necessary\n@@ -784,8 +784,8 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n     }\n }\n \n-impl<'a> CleanupScope<'a> {\n-    fn new(kind: CleanupScopeKind<'a>) -> CleanupScope<'a> {\n+impl<'blk, 'tcx> CleanupScope<'blk, 'tcx> {\n+    fn new(kind: CleanupScopeKind<'blk, 'tcx>) -> CleanupScope<'blk, 'tcx> {\n         CleanupScope {\n             kind: kind,\n             cleanups: vec!(),\n@@ -836,7 +836,7 @@ impl<'a> CleanupScope<'a> {\n     }\n }\n \n-impl<'a> CleanupScopeKind<'a> {\n+impl<'blk, 'tcx> CleanupScopeKind<'blk, 'tcx> {\n     fn is_temp(&self) -> bool {\n         match *self {\n             CustomScopeKind => true,\n@@ -902,7 +902,7 @@ impl Cleanup for DropValue {\n         self.must_unwind\n     }\n \n-    fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n+    fn trans<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>) -> Block<'blk, 'tcx> {\n         let bcx = if self.is_immediate {\n             glue::drop_ty_immediate(bcx, self.val, self.ty)\n         } else {\n@@ -935,7 +935,7 @@ impl Cleanup for FreeValue {\n         true\n     }\n \n-    fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n+    fn trans<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>) -> Block<'blk, 'tcx> {\n         match self.heap {\n             HeapManaged => {\n                 glue::trans_free(bcx, self.ptr)\n@@ -963,7 +963,7 @@ impl Cleanup for FreeSlice {\n         true\n     }\n \n-    fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n+    fn trans<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>) -> Block<'blk, 'tcx> {\n         match self.heap {\n             HeapManaged => {\n                 glue::trans_free(bcx, self.ptr)\n@@ -988,7 +988,7 @@ impl Cleanup for LifetimeEnd {\n         true\n     }\n \n-    fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n+    fn trans<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>) -> Block<'blk, 'tcx> {\n         base::call_lifetime_end(bcx, self.ptr);\n         bcx\n     }\n@@ -1026,29 +1026,29 @@ fn cleanup_is_suitable_for(c: &Cleanup,\n ///////////////////////////////////////////////////////////////////////////\n // These traits just exist to put the methods into this file.\n \n-pub trait CleanupMethods<'a> {\n+pub trait CleanupMethods<'blk, 'tcx> {\n     fn push_ast_cleanup_scope(&self, id: ast::NodeId);\n     fn push_loop_cleanup_scope(&self,\n                                    id: ast::NodeId,\n-                                   exits: [&'a Block<'a>, ..EXIT_MAX]);\n+                                   exits: [Block<'blk, 'tcx>, ..EXIT_MAX]);\n     fn push_custom_cleanup_scope(&self) -> CustomScopeIndex;\n     fn pop_and_trans_ast_cleanup_scope(&self,\n-                                              bcx: &'a Block<'a>,\n+                                              bcx: Block<'blk, 'tcx>,\n                                               cleanup_scope: ast::NodeId)\n-                                              -> &'a Block<'a>;\n+                                              -> Block<'blk, 'tcx>;\n     fn pop_loop_cleanup_scope(&self,\n                               cleanup_scope: ast::NodeId);\n     fn pop_custom_cleanup_scope(&self,\n                                 custom_scope: CustomScopeIndex);\n     fn pop_and_trans_custom_cleanup_scope(&self,\n-                                          bcx: &'a Block<'a>,\n+                                          bcx: Block<'blk, 'tcx>,\n                                           custom_scope: CustomScopeIndex)\n-                                          -> &'a Block<'a>;\n+                                          -> Block<'blk, 'tcx>;\n     fn top_loop_scope(&self) -> ast::NodeId;\n-    fn normal_exit_block(&'a self,\n+    fn normal_exit_block(&'blk self,\n                          cleanup_scope: ast::NodeId,\n                          exit: uint) -> BasicBlockRef;\n-    fn return_exit_block(&'a self) -> BasicBlockRef;\n+    fn return_exit_block(&'blk self) -> BasicBlockRef;\n     fn schedule_lifetime_end(&self,\n                          cleanup_scope: ScopeId,\n                          val: ValueRef);\n@@ -1085,23 +1085,23 @@ pub trait CleanupMethods<'a> {\n                                     custom_scope: CustomScopeIndex,\n                                     cleanup: CleanupObj);\n     fn needs_invoke(&self) -> bool;\n-    fn get_landing_pad(&'a self) -> BasicBlockRef;\n+    fn get_landing_pad(&'blk self) -> BasicBlockRef;\n }\n \n-trait CleanupHelperMethods<'a> {\n+trait CleanupHelperMethods<'blk, 'tcx> {\n     fn top_ast_scope(&self) -> Option<ast::NodeId>;\n     fn top_nonempty_cleanup_scope(&self) -> Option<uint>;\n     fn is_valid_to_pop_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool;\n     fn is_valid_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool;\n     fn trans_scope_cleanups(&self,\n-                            bcx: &'a Block<'a>,\n-                            scope: &CleanupScope<'a>) -> &'a Block<'a>;\n-    fn trans_cleanups_to_exit_scope(&'a self,\n+                            bcx: Block<'blk, 'tcx>,\n+                            scope: &CleanupScope<'blk, 'tcx>) -> Block<'blk, 'tcx>;\n+    fn trans_cleanups_to_exit_scope(&'blk self,\n                                     label: EarlyExitLabel)\n                                     -> BasicBlockRef;\n-    fn get_or_create_landing_pad(&'a self) -> BasicBlockRef;\n+    fn get_or_create_landing_pad(&'blk self) -> BasicBlockRef;\n     fn scopes_len(&self) -> uint;\n-    fn push_scope(&self, scope: CleanupScope<'a>);\n-    fn pop_scope(&self) -> CleanupScope<'a>;\n-    fn top_scope<R>(&self, f: |&CleanupScope<'a>| -> R) -> R;\n+    fn push_scope(&self, scope: CleanupScope<'blk, 'tcx>);\n+    fn pop_scope(&self) -> CleanupScope<'blk, 'tcx>;\n+    fn top_scope<R>(&self, f: |&CleanupScope<'blk, 'tcx>| -> R) -> R;\n }"}, {"sha": "7bbdf332fe11f20b843062c003d394bb14b8b9d7", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -135,10 +135,10 @@ fn tuplify_box_ty(tcx: &ty::ctxt, t: ty::t) -> ty::t {\n     ty::mk_tup(tcx, vec!(ty::mk_uint(), ty::mk_nil_ptr(tcx), ptr, ptr, t))\n }\n \n-fn allocate_cbox<'a>(bcx: &'a Block<'a>,\n-                     store: ty::TraitStore,\n-                     cdata_ty: ty::t)\n-                     -> Result<'a> {\n+fn allocate_cbox<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             store: ty::TraitStore,\n+                             cdata_ty: ty::t)\n+                             -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::allocate_cbox\");\n     let tcx = bcx.tcx();\n \n@@ -155,21 +155,20 @@ fn allocate_cbox<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-pub struct ClosureResult<'a> {\n+pub struct ClosureResult<'blk, 'tcx: 'blk> {\n     llbox: ValueRef,    // llvalue of ptr to closure\n     cdata_ty: ty::t,    // type of the closure data\n-    bcx: &'a Block<'a>  // final bcx\n+    bcx: Block<'blk, 'tcx>  // final bcx\n }\n \n // Given a block context and a list of tydescs and values to bind\n // construct a closure out of them. If copying is true, it is a\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n-pub fn store_environment<'a>(\n-                         bcx: &'a Block<'a>,\n-                         bound_values: Vec<EnvValue> ,\n-                         store: ty::TraitStore)\n-                         -> ClosureResult<'a> {\n+pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     bound_values: Vec<EnvValue> ,\n+                                     store: ty::TraitStore)\n+                                     -> ClosureResult<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx();\n@@ -224,12 +223,11 @@ pub fn store_environment<'a>(\n \n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n-fn build_closure<'a>(bcx0: &'a Block<'a>,\n-                     freevar_mode: freevars::CaptureMode,\n-                     freevars: &Vec<freevars::freevar_entry>,\n-                     store: ty::TraitStore)\n-                     -> ClosureResult<'a>\n-{\n+fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n+                             freevar_mode: freevars::CaptureMode,\n+                             freevars: &Vec<freevars::freevar_entry>,\n+                             store: ty::TraitStore)\n+                             -> ClosureResult<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::build_closure\");\n \n     // If we need to, package up the iterator body to call\n@@ -248,11 +246,11 @@ fn build_closure<'a>(bcx0: &'a Block<'a>,\n // Given an enclosing block context, a new function context, a closure type,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n-fn load_environment<'a>(bcx: &'a Block<'a>,\n-                        cdata_ty: ty::t,\n-                        freevars: &Vec<freevars::freevar_entry>,\n-                        store: ty::TraitStore)\n-                        -> &'a Block<'a> {\n+fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                cdata_ty: ty::t,\n+                                freevars: &Vec<freevars::freevar_entry>,\n+                                store: ty::TraitStore)\n+                                -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n \n     // Don't bother to create the block if there's nothing to load\n@@ -301,12 +299,12 @@ fn load_environment<'a>(bcx: &'a Block<'a>,\n     bcx\n }\n \n-fn load_unboxed_closure_environment<'a>(\n-                                    bcx: &'a Block<'a>,\n+fn load_unboxed_closure_environment<'blk, 'tcx>(\n+                                    bcx: Block<'blk, 'tcx>,\n                                     arg_scope_id: ScopeId,\n                                     freevars: &Vec<freevars::freevar_entry>,\n                                     closure_id: ast::DefId)\n-                                    -> &'a Block<'a> {\n+                                    -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n \n     if freevars.len() == 0 {\n@@ -343,20 +341,19 @@ fn load_unboxed_closure_environment<'a>(\n     bcx\n }\n \n-fn fill_fn_pair(bcx: &Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef) {\n+fn fill_fn_pair(bcx: Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef) {\n     Store(bcx, llfn, GEPi(bcx, pair, [0u, abi::fn_field_code]));\n     let llenvptr = PointerCast(bcx, llenvptr, Type::i8p(bcx.ccx()));\n     Store(bcx, llenvptr, GEPi(bcx, pair, [0u, abi::fn_field_box]));\n }\n \n-pub fn trans_expr_fn<'a>(\n-                     bcx: &'a Block<'a>,\n-                     store: ty::TraitStore,\n-                     decl: &ast::FnDecl,\n-                     body: &ast::Block,\n-                     id: ast::NodeId,\n-                     dest: expr::Dest)\n-                     -> &'a Block<'a> {\n+pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 store: ty::TraitStore,\n+                                 decl: &ast::FnDecl,\n+                                 body: &ast::Block,\n+                                 id: ast::NodeId,\n+                                 dest: expr::Dest)\n+                                 -> Block<'blk, 'tcx> {\n     /*!\n      *\n      * Translates the body of a closure expression.\n@@ -458,13 +455,13 @@ pub fn get_or_create_declaration_if_unboxed_closure(ccx: &CrateContext,\n     Some(llfn)\n }\n \n-pub fn trans_unboxed_closure<'a>(\n-                             mut bcx: &'a Block<'a>,\n+pub fn trans_unboxed_closure<'blk, 'tcx>(\n+                             mut bcx: Block<'blk, 'tcx>,\n                              decl: &ast::FnDecl,\n                              body: &ast::Block,\n                              id: ast::NodeId,\n                              dest: expr::Dest)\n-                             -> &'a Block<'a> {\n+                             -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::trans_unboxed_closure\");\n \n     debug!(\"trans_unboxed_closure()\");\n@@ -620,11 +617,11 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n     llfn\n }\n \n-pub fn make_closure_from_bare_fn<'a>(bcx: &'a Block<'a>,\n-                                     closure_ty: ty::t,\n-                                     def: def::Def,\n-                                     fn_ptr: ValueRef)\n-                                     -> DatumBlock<'a, Expr>  {\n+pub fn make_closure_from_bare_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                             closure_ty: ty::t,\n+                                             def: def::Def,\n+                                             fn_ptr: ValueRef)\n+                                             -> DatumBlock<'blk, 'tcx, Expr>  {\n     let scratch = rvalue_scratch_datum(bcx, closure_ty, \"__adjust\");\n     let wrapper = get_wrapper_for_bare_fn(bcx.ccx(), closure_ty, def, fn_ptr, true);\n     fill_fn_pair(bcx, scratch.val, wrapper, C_null(Type::i8p(bcx.ccx())));"}, {"sha": "4ac9ae64d5a08e7eb17c09fda5dcefab536eff14", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -233,7 +233,7 @@ pub type LvalueDatum = datum::Datum<datum::Lvalue>;\n \n // Function context.  Every LLVM function we create will have one of\n // these.\n-pub struct FunctionContext<'a> {\n+pub struct FunctionContext<'a, 'tcx: 'a> {\n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n     // address of the first instruction in the sequence of\n     // instructions for this function that will go in the .text\n@@ -294,19 +294,19 @@ pub struct FunctionContext<'a> {\n     pub span: Option<Span>,\n \n     // The arena that blocks are allocated from.\n-    pub block_arena: &'a TypedArena<Block<'a>>,\n+    pub block_arena: &'a TypedArena<BlockS<'a, 'tcx>>,\n \n     // This function's enclosing crate context.\n-    pub ccx: &'a CrateContext<'a>,\n+    pub ccx: &'a CrateContext<'a, 'tcx>,\n \n     // Used and maintained by the debuginfo module.\n     pub debug_context: debuginfo::FunctionDebugContext,\n \n     // Cleanup scopes.\n-    pub scopes: RefCell<Vec<cleanup::CleanupScope<'a>> >,\n+    pub scopes: RefCell<Vec<cleanup::CleanupScope<'a, 'tcx>>>,\n }\n \n-impl<'a> FunctionContext<'a> {\n+impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     pub fn arg_pos(&self, arg: uint) -> uint {\n         let arg = self.env_arg_pos() + arg;\n         if self.llenv.is_some() {\n@@ -350,7 +350,7 @@ impl<'a> FunctionContext<'a> {\n         self.llreturn.get().unwrap()\n     }\n \n-    pub fn get_ret_slot(&self, bcx: &Block, ty: ty::t, name: &str) -> ValueRef {\n+    pub fn get_ret_slot(&self, bcx: Block, ty: ty::t, name: &str) -> ValueRef {\n         if self.needs_ret_allocas {\n             base::alloca_no_lifetime(bcx, type_of::type_of(bcx.ccx(), ty), name)\n         } else {\n@@ -362,34 +362,34 @@ impl<'a> FunctionContext<'a> {\n                      is_lpad: bool,\n                      name: &str,\n                      opt_node_id: Option<ast::NodeId>)\n-                     -> &'a Block<'a> {\n+                     -> Block<'a, 'tcx> {\n         unsafe {\n             let llbb = name.with_c_str(|buf| {\n                     llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n                                                         self.llfn,\n                                                         buf)\n                 });\n-            Block::new(llbb, is_lpad, opt_node_id, self)\n+            BlockS::new(llbb, is_lpad, opt_node_id, self)\n         }\n     }\n \n     pub fn new_id_block(&'a self,\n                         name: &str,\n                         node_id: ast::NodeId)\n-                        -> &'a Block<'a> {\n+                        -> Block<'a, 'tcx> {\n         self.new_block(false, name, Some(node_id))\n     }\n \n     pub fn new_temp_block(&'a self,\n                           name: &str)\n-                          -> &'a Block<'a> {\n+                          -> Block<'a, 'tcx> {\n         self.new_block(false, name, None)\n     }\n \n     pub fn join_blocks(&'a self,\n                        id: ast::NodeId,\n-                       in_cxs: &[&'a Block<'a>])\n-                       -> &'a Block<'a> {\n+                       in_cxs: &[Block<'a, 'tcx>])\n+                       -> Block<'a, 'tcx> {\n         let out = self.new_id_block(\"join\", id);\n         let mut reachable = false;\n         for bcx in in_cxs.iter() {\n@@ -410,7 +410,7 @@ impl<'a> FunctionContext<'a> {\n // code.  Each basic block we generate is attached to a function, typically\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n-pub struct Block<'a> {\n+pub struct BlockS<'blk, 'tcx: 'blk> {\n     // The BasicBlockRef returned from a call to\n     // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n     // block to the function pointed to by llfn.  We insert\n@@ -429,17 +429,18 @@ pub struct Block<'a> {\n \n     // The function context for the function to which this block is\n     // attached.\n-    pub fcx: &'a FunctionContext<'a>,\n+    pub fcx: &'blk FunctionContext<'blk, 'tcx>,\n }\n \n-impl<'a> Block<'a> {\n-    pub fn new<'a>(\n-               llbb: BasicBlockRef,\n+pub type Block<'blk, 'tcx> = &'blk BlockS<'blk, 'tcx>;\n+\n+impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n+    pub fn new(llbb: BasicBlockRef,\n                is_lpad: bool,\n                opt_node_id: Option<ast::NodeId>,\n-               fcx: &'a FunctionContext<'a>)\n-               -> &'a Block<'a> {\n-        fcx.block_arena.alloc(Block {\n+               fcx: &'blk FunctionContext<'blk, 'tcx>)\n+               -> Block<'blk, 'tcx> {\n+        fcx.block_arena.alloc(BlockS {\n             llbb: llbb,\n             terminated: Cell::new(false),\n             unreachable: Cell::new(false),\n@@ -449,11 +450,13 @@ impl<'a> Block<'a> {\n         })\n     }\n \n-    pub fn ccx(&self) -> &'a CrateContext<'a> { self.fcx.ccx }\n-    pub fn tcx(&self) -> &'a ty::ctxt {\n+    pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n+        self.fcx.ccx\n+    }\n+    pub fn tcx(&self) -> &'blk ty::ctxt<'tcx> {\n         self.fcx.ccx.tcx()\n     }\n-    pub fn sess(&self) -> &'a Session { self.fcx.ccx.sess() }\n+    pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n \n     pub fn ident(&self, ident: Ident) -> String {\n         token::get_ident(ident).get().to_string()\n@@ -490,13 +493,12 @@ impl<'a> Block<'a> {\n     }\n \n     pub fn to_str(&self) -> String {\n-        let blk: *const Block = self;\n-        format!(\"[block {}]\", blk)\n+        format!(\"[block {:p}]\", self)\n     }\n }\n \n-impl<'a> mc::Typer for Block<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.tcx()\n     }\n \n@@ -535,13 +537,13 @@ impl<'a> mc::Typer for Block<'a> {\n     }\n }\n \n-pub struct Result<'a> {\n-    pub bcx: &'a Block<'a>,\n+pub struct Result<'blk, 'tcx: 'blk> {\n+    pub bcx: Block<'blk, 'tcx>,\n     pub val: ValueRef\n }\n \n-impl<'a> Result<'a> {\n-    pub fn new(bcx: &'a Block<'a>, val: ValueRef) -> Result<'a> {\n+impl<'b, 'tcx> Result<'b, 'tcx> {\n+    pub fn new(bcx: Block<'b, 'tcx>, val: ValueRef) -> Result<'b, 'tcx> {\n         Result {\n             bcx: bcx,\n             val: val,\n@@ -746,21 +748,21 @@ pub fn is_null(val: ValueRef) -> bool {\n     }\n }\n \n-pub fn monomorphize_type(bcx: &Block, t: ty::t) -> ty::t {\n+pub fn monomorphize_type(bcx: &BlockS, t: ty::t) -> ty::t {\n     t.subst(bcx.tcx(), &bcx.fcx.param_substs.substs)\n }\n \n-pub fn node_id_type(bcx: &Block, id: ast::NodeId) -> ty::t {\n+pub fn node_id_type(bcx: &BlockS, id: ast::NodeId) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n     monomorphize_type(bcx, t)\n }\n \n-pub fn expr_ty(bcx: &Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty(bcx: Block, ex: &ast::Expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n \n-pub fn expr_ty_adjusted(bcx: &Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty_adjusted(bcx: Block, ex: &ast::Expr) -> ty::t {\n     monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n }\n \n@@ -774,7 +776,7 @@ pub enum ExprOrMethodCall {\n     MethodCall(typeck::MethodCall)\n }\n \n-pub fn node_id_substs(bcx: &Block,\n+pub fn node_id_substs(bcx: Block,\n                       node: ExprOrMethodCall)\n                       -> subst::Substs {\n     let tcx = bcx.tcx();\n@@ -799,7 +801,7 @@ pub fn node_id_substs(bcx: &Block,\n     substs.substp(tcx, bcx.fcx.param_substs)\n }\n \n-pub fn node_vtables(bcx: &Block, id: typeck::MethodCall)\n+pub fn node_vtables(bcx: Block, id: typeck::MethodCall)\n                  -> typeck::vtable_res {\n     bcx.tcx().vtable_map.borrow().find(&id).map(|vts| {\n         resolve_vtables_in_fn_ctxt(bcx.fcx, vts)\n@@ -877,7 +879,7 @@ pub fn find_vtable(tcx: &ty::ctxt,\n     param_bounds.get(n_bound).clone()\n }\n \n-pub fn langcall(bcx: &Block,\n+pub fn langcall(bcx: Block,\n                 span: Option<Span>,\n                 msg: &str,\n                 li: LangItem)"}, {"sha": "3b4b50c7e85acecb95df1e3b595a8f696204ba39", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -55,7 +55,7 @@ pub struct Stats {\n /// per crate.  The data here is shared between all compilation units of the\n /// crate, so it must not contain references to any LLVM data structures\n /// (aside from metadata-related ones).\n-pub struct SharedCrateContext {\n+pub struct SharedCrateContext<'tcx> {\n     local_ccxs: Vec<LocalCrateContext>,\n \n     metadata_llmod: ModuleRef,\n@@ -70,7 +70,7 @@ pub struct SharedCrateContext {\n     /// that is generated\n     non_inlineable_statics: RefCell<NodeSet>,\n     symbol_hasher: RefCell<Sha256>,\n-    tcx: ty::ctxt,\n+    tcx: ty::ctxt<'tcx>,\n     stats: Stats,\n \n     available_monomorphizations: RefCell<HashSet<String>>,\n@@ -152,21 +152,21 @@ pub struct LocalCrateContext {\n     n_llvm_insns: Cell<uint>,\n }\n \n-pub struct CrateContext<'a> {\n-    shared: &'a SharedCrateContext,\n+pub struct CrateContext<'a, 'tcx: 'a> {\n+    shared: &'a SharedCrateContext<'tcx>,\n     local: &'a LocalCrateContext,\n     /// The index of `local` in `shared.local_ccxs`.  This is used in\n     /// `maybe_iter(true)` to identify the original `LocalCrateContext`.\n     index: uint,\n }\n \n-pub struct CrateContextIterator<'a> {\n-    shared: &'a SharedCrateContext,\n+pub struct CrateContextIterator<'a, 'tcx: 'a> {\n+    shared: &'a SharedCrateContext<'tcx>,\n     index: uint,\n }\n \n-impl<'a> Iterator<CrateContext<'a>> for CrateContextIterator<'a> {\n-    fn next(&mut self) -> Option<CrateContext<'a>> {\n+impl<'a, 'tcx> Iterator<CrateContext<'a, 'tcx>> for CrateContextIterator<'a,'tcx> {\n+    fn next(&mut self) -> Option<CrateContext<'a, 'tcx>> {\n         if self.index >= self.shared.local_ccxs.len() {\n             return None;\n         }\n@@ -183,15 +183,15 @@ impl<'a> Iterator<CrateContext<'a>> for CrateContextIterator<'a> {\n }\n \n /// The iterator produced by `CrateContext::maybe_iter`.\n-pub struct CrateContextMaybeIterator<'a> {\n-    shared: &'a SharedCrateContext,\n+pub struct CrateContextMaybeIterator<'a, 'tcx: 'a> {\n+    shared: &'a SharedCrateContext<'tcx>,\n     index: uint,\n     single: bool,\n     origin: uint,\n }\n \n-impl<'a> Iterator<(CrateContext<'a>, bool)> for CrateContextMaybeIterator<'a> {\n-    fn next(&mut self) -> Option<(CrateContext<'a>, bool)> {\n+impl<'a, 'tcx> Iterator<(CrateContext<'a, 'tcx>, bool)> for CrateContextMaybeIterator<'a, 'tcx> {\n+    fn next(&mut self) -> Option<(CrateContext<'a, 'tcx>, bool)> {\n         if self.index >= self.shared.local_ccxs.len() {\n             return None;\n         }\n@@ -234,15 +234,15 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n     (llcx, llmod)\n }\n \n-impl SharedCrateContext {\n+impl<'tcx> SharedCrateContext<'tcx> {\n     pub fn new(crate_name: &str,\n                local_count: uint,\n-               tcx: ty::ctxt,\n+               tcx: ty::ctxt<'tcx>,\n                emap2: resolve::ExportMap2,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n                reachable: NodeSet)\n-               -> SharedCrateContext {\n+               -> SharedCrateContext<'tcx> {\n         let (metadata_llcx, metadata_llmod) = unsafe {\n             create_context_and_module(&tcx.sess, \"metadata\")\n         };\n@@ -293,22 +293,22 @@ impl SharedCrateContext {\n         shared_ccx\n     }\n \n-    pub fn iter<'a>(&'a self) -> CrateContextIterator<'a> {\n+    pub fn iter<'a>(&'a self) -> CrateContextIterator<'a, 'tcx> {\n         CrateContextIterator {\n             shared: self,\n             index: 0,\n         }\n     }\n \n-    pub fn get_ccx<'a>(&'a self, index: uint) -> CrateContext<'a> {\n+    pub fn get_ccx<'a>(&'a self, index: uint) -> CrateContext<'a, 'tcx> {\n         CrateContext {\n             shared: self,\n             local: &self.local_ccxs[index],\n             index: index,\n         }\n     }\n \n-    fn get_smallest_ccx<'a>(&'a self) -> CrateContext<'a> {\n+    fn get_smallest_ccx<'a>(&'a self) -> CrateContext<'a, 'tcx> {\n         let (local_ccx, index) =\n             self.local_ccxs\n                 .iter()\n@@ -355,11 +355,11 @@ impl SharedCrateContext {\n         &self.symbol_hasher\n     }\n \n-    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         &self.tcx\n     }\n \n-    pub fn take_tcx(self) -> ty::ctxt {\n+    pub fn take_tcx(self) -> ty::ctxt<'tcx> {\n         self.tcx\n     }\n \n@@ -459,7 +459,8 @@ impl LocalCrateContext {\n     /// This is used in the `LocalCrateContext` constructor to allow calling\n     /// functions that expect a complete `CrateContext`, even before the local\n     /// portion is fully initialized and attached to the `SharedCrateContext`.\n-    fn dummy_ccx<'a>(&'a self, shared: &'a SharedCrateContext) -> CrateContext<'a> {\n+    fn dummy_ccx<'a, 'tcx>(&'a self, shared: &'a SharedCrateContext<'tcx>)\n+                           -> CrateContext<'a, 'tcx> {\n         CrateContext {\n             shared: shared,\n             local: self,\n@@ -468,8 +469,8 @@ impl LocalCrateContext {\n     }\n }\n \n-impl<'b> CrateContext<'b> {\n-    pub fn shared(&self) -> &'b SharedCrateContext {\n+impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n+    pub fn shared(&self) -> &'b SharedCrateContext<'tcx> {\n         self.shared\n     }\n \n@@ -480,7 +481,7 @@ impl<'b> CrateContext<'b> {\n \n     /// Get a (possibly) different `CrateContext` from the same\n     /// `SharedCrateContext`.\n-    pub fn rotate(&self) -> CrateContext<'b> {\n+    pub fn rotate(&self) -> CrateContext<'b, 'tcx> {\n         self.shared.get_smallest_ccx()\n     }\n \n@@ -490,7 +491,7 @@ impl<'b> CrateContext<'b> {\n     /// otherwise.  This method is useful for avoiding code duplication in\n     /// cases where it may or may not be necessary to translate code into every\n     /// context.\n-    pub fn maybe_iter(&self, iter_all: bool) -> CrateContextMaybeIterator<'b> {\n+    pub fn maybe_iter(&self, iter_all: bool) -> CrateContextMaybeIterator<'b, 'tcx> {\n         CrateContextMaybeIterator {\n             shared: self.shared,\n             index: if iter_all { 0 } else { self.index },\n@@ -500,15 +501,15 @@ impl<'b> CrateContext<'b> {\n     }\n \n \n-    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         &self.shared.tcx\n     }\n \n     pub fn sess<'a>(&'a self) -> &'a Session {\n         &self.shared.tcx.sess\n     }\n \n-    pub fn builder<'a>(&'a self) -> Builder<'a> {\n+    pub fn builder<'a>(&'a self) -> Builder<'a, 'tcx> {\n         Builder::new(self)\n     }\n "}, {"sha": "dd9e41a61bf8748fa0adc29b3f8d6a00976e84cf", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 56, "deletions": 58, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -41,9 +41,9 @@ use syntax::visit::Visitor;\n \n use std::gc::Gc;\n \n-pub fn trans_stmt<'a>(cx: &'a Block<'a>,\n-                      s: &ast::Stmt)\n-                      -> &'a Block<'a> {\n+pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                              s: &ast::Stmt)\n+                              -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_stmt\");\n     let fcx = cx.fcx;\n     debug!(\"trans_stmt({})\", s.repr(cx.tcx()));\n@@ -83,7 +83,8 @@ pub fn trans_stmt<'a>(cx: &'a Block<'a>,\n     return bcx;\n }\n \n-pub fn trans_stmt_semi<'a>(cx: &'a Block<'a>, e: &ast::Expr) -> &'a Block<'a> {\n+pub fn trans_stmt_semi<'blk, 'tcx>(cx: Block<'blk, 'tcx>, e: &ast::Expr)\n+                                   -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_stmt_semi\");\n     let ty = expr_ty(cx, e);\n     if ty::type_needs_drop(cx.tcx(), ty) {\n@@ -93,10 +94,10 @@ pub fn trans_stmt_semi<'a>(cx: &'a Block<'a>, e: &ast::Expr) -> &'a Block<'a> {\n     }\n }\n \n-pub fn trans_block<'a>(bcx: &'a Block<'a>,\n-                       b: &ast::Block,\n-                       mut dest: expr::Dest)\n-                       -> &'a Block<'a> {\n+pub fn trans_block<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               b: &ast::Block,\n+                               mut dest: expr::Dest)\n+                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_block\");\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n@@ -128,13 +129,13 @@ pub fn trans_block<'a>(bcx: &'a Block<'a>,\n     return bcx;\n }\n \n-pub fn trans_if<'a>(bcx: &'a Block<'a>,\n-                    if_id: ast::NodeId,\n-                    cond: &ast::Expr,\n-                    thn: ast::P<ast::Block>,\n-                    els: Option<Gc<ast::Expr>>,\n-                    dest: expr::Dest)\n-                    -> &'a Block<'a> {\n+pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                            if_id: ast::NodeId,\n+                            cond: &ast::Expr,\n+                            thn: ast::P<ast::Block>,\n+                            els: Option<Gc<ast::Expr>>,\n+                            dest: expr::Dest)\n+                            -> Block<'blk, 'tcx> {\n     debug!(\"trans_if(bcx={}, if_id={}, cond={}, thn={:?}, dest={})\",\n            bcx.to_str(), if_id, bcx.expr_to_string(cond), thn.id,\n            dest.to_string(bcx.ccx()));\n@@ -204,11 +205,11 @@ pub fn trans_if<'a>(bcx: &'a Block<'a>,\n     next_bcx\n }\n \n-pub fn trans_while<'a>(bcx: &'a Block<'a>,\n-                       loop_id: ast::NodeId,\n-                       cond: &ast::Expr,\n-                       body: &ast::Block)\n-                       -> &'a Block<'a> {\n+pub fn trans_while<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               loop_id: ast::NodeId,\n+                               cond: &ast::Expr,\n+                               body: &ast::Block)\n+                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_while\");\n     let fcx = bcx.fcx;\n \n@@ -248,13 +249,12 @@ pub fn trans_while<'a>(bcx: &'a Block<'a>,\n }\n \n /// Translates a `for` loop.\n-pub fn trans_for<'a>(\n-                 mut bcx: &'a Block<'a>,\n-                 loop_info: NodeInfo,\n-                 pat: Gc<ast::Pat>,\n-                 head: &ast::Expr,\n-                 body: &ast::Block)\n-                 -> &'a Block<'a> {\n+pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                             loop_info: NodeInfo,\n+                             pat: Gc<ast::Pat>,\n+                             head: &ast::Expr,\n+                             body: &ast::Block)\n+                             -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_for\");\n \n     //            bcx\n@@ -369,10 +369,10 @@ pub fn trans_for<'a>(\n     next_bcx_in\n }\n \n-pub fn trans_loop<'a>(bcx:&'a Block<'a>,\n-                      loop_id: ast::NodeId,\n-                      body: &ast::Block)\n-                      -> &'a Block<'a> {\n+pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              loop_id: ast::NodeId,\n+                              body: &ast::Block)\n+                              -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_loop\");\n     let fcx = bcx.fcx;\n \n@@ -405,11 +405,11 @@ pub fn trans_loop<'a>(bcx:&'a Block<'a>,\n     return next_bcx_in;\n }\n \n-pub fn trans_break_cont<'a>(bcx: &'a Block<'a>,\n-                            expr_id: ast::NodeId,\n-                            opt_label: Option<Ident>,\n-                            exit: uint)\n-                            -> &'a Block<'a> {\n+pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    expr_id: ast::NodeId,\n+                                    opt_label: Option<Ident>,\n+                                    exit: uint)\n+                                    -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_break_cont\");\n     let fcx = bcx.fcx;\n \n@@ -438,23 +438,23 @@ pub fn trans_break_cont<'a>(bcx: &'a Block<'a>,\n     return bcx;\n }\n \n-pub fn trans_break<'a>(bcx: &'a Block<'a>,\n-                       expr_id: ast::NodeId,\n-                       label_opt: Option<Ident>)\n-                       -> &'a Block<'a> {\n+pub fn trans_break<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               expr_id: ast::NodeId,\n+                               label_opt: Option<Ident>)\n+                               -> Block<'blk, 'tcx> {\n     return trans_break_cont(bcx, expr_id, label_opt, cleanup::EXIT_BREAK);\n }\n \n-pub fn trans_cont<'a>(bcx: &'a Block<'a>,\n-                      expr_id: ast::NodeId,\n-                      label_opt: Option<Ident>)\n-                      -> &'a Block<'a> {\n+pub fn trans_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              expr_id: ast::NodeId,\n+                              label_opt: Option<Ident>)\n+                              -> Block<'blk, 'tcx> {\n     return trans_break_cont(bcx, expr_id, label_opt, cleanup::EXIT_LOOP);\n }\n \n-pub fn trans_ret<'a>(bcx: &'a Block<'a>,\n-                     e: Option<Gc<ast::Expr>>)\n-                     -> &'a Block<'a> {\n+pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             e: Option<Gc<ast::Expr>>)\n+                             -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_ret\");\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n@@ -483,11 +483,10 @@ pub fn trans_ret<'a>(bcx: &'a Block<'a>,\n     return bcx;\n }\n \n-pub fn trans_fail<'a>(\n-                  bcx: &'a Block<'a>,\n-                  sp: Span,\n-                  fail_str: InternedString)\n-                  -> &'a Block<'a> {\n+pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              sp: Span,\n+                              fail_str: InternedString)\n+                              -> Block<'blk, 'tcx> {\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"trans_fail_value\");\n \n@@ -508,12 +507,11 @@ pub fn trans_fail<'a>(\n     return bcx;\n }\n \n-pub fn trans_fail_bounds_check<'a>(\n-                               bcx: &'a Block<'a>,\n-                               sp: Span,\n-                               index: ValueRef,\n-                               len: ValueRef)\n-                               -> &'a Block<'a> {\n+pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                           sp: Span,\n+                                           index: ValueRef,\n+                                           len: ValueRef)\n+                                           -> Block<'blk, 'tcx> {\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"trans_fail_bounds_check\");\n "}, {"sha": "84d9f2cb740a36fd7017ba6f6019d98b33f4fab6", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 95, "deletions": 96, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -47,8 +47,8 @@ pub struct Datum<K> {\n     pub kind: K,\n }\n \n-pub struct DatumBlock<'a, K> {\n-    pub bcx: &'a Block<'a>,\n+pub struct DatumBlock<'blk, 'tcx: 'blk, K> {\n+    pub bcx: Block<'blk, 'tcx>,\n     pub datum: Datum<K>,\n }\n \n@@ -94,23 +94,23 @@ pub fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum<Rvalue> {\n     return Datum::new(val, ty, Rvalue::new(ByValue));\n }\n \n-pub fn immediate_rvalue_bcx<'a>(bcx: &'a Block<'a>,\n-                                val: ValueRef,\n-                                ty: ty::t)\n-                                -> DatumBlock<'a, Rvalue> {\n+pub fn immediate_rvalue_bcx<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                        val: ValueRef,\n+                                        ty: ty::t)\n+                                        -> DatumBlock<'blk, 'tcx, Rvalue> {\n     return DatumBlock::new(bcx, immediate_rvalue(val, ty))\n }\n \n \n-pub fn lvalue_scratch_datum<'a, A>(bcx: &'a Block<'a>,\n-                                   ty: ty::t,\n-                                   name: &str,\n-                                   zero: bool,\n-                                   scope: cleanup::ScopeId,\n-                                   arg: A,\n-                                   populate: |A, &'a Block<'a>, ValueRef|\n-                                             -> &'a Block<'a>)\n-                                   -> DatumBlock<'a, Lvalue> {\n+pub fn lvalue_scratch_datum<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n+                                           ty: ty::t,\n+                                           name: &str,\n+                                           zero: bool,\n+                                           scope: cleanup::ScopeId,\n+                                           arg: A,\n+                                           populate: |A, Block<'blk, 'tcx>, ValueRef|\n+                                                      -> Block<'blk, 'tcx>)\n+                                          -> DatumBlock<'blk, 'tcx, Lvalue> {\n     /*!\n      * Allocates temporary space on the stack using alloca() and\n      * returns a by-ref Datum pointing to it. The memory will be\n@@ -135,7 +135,7 @@ pub fn lvalue_scratch_datum<'a, A>(bcx: &'a Block<'a>,\n     DatumBlock::new(bcx, Datum::new(scratch, ty, Lvalue))\n }\n \n-pub fn rvalue_scratch_datum(bcx: &Block,\n+pub fn rvalue_scratch_datum(bcx: Block,\n                             ty: ty::t,\n                             name: &str)\n                             -> Datum<Rvalue> {\n@@ -188,11 +188,11 @@ pub trait KindOps {\n      * Take appropriate action after the value in `datum` has been\n      * stored to a new location.\n      */\n-    fn post_store<'a>(&self,\n-                      bcx: &'a Block<'a>,\n-                      val: ValueRef,\n-                      ty: ty::t)\n-                      -> &'a Block<'a>;\n+    fn post_store<'blk, 'tcx>(&self,\n+                              bcx: Block<'blk, 'tcx>,\n+                              val: ValueRef,\n+                              ty: ty::t)\n+                              -> Block<'blk, 'tcx>;\n \n     /**\n      * True if this mode is a reference mode, meaning that the datum's\n@@ -208,11 +208,11 @@ pub trait KindOps {\n }\n \n impl KindOps for Rvalue {\n-    fn post_store<'a>(&self,\n-                      bcx: &'a Block<'a>,\n-                      _val: ValueRef,\n-                      _ty: ty::t)\n-                      -> &'a Block<'a> {\n+    fn post_store<'blk, 'tcx>(&self,\n+                              bcx: Block<'blk, 'tcx>,\n+                              _val: ValueRef,\n+                              _ty: ty::t)\n+                              -> Block<'blk, 'tcx> {\n         // No cleanup is scheduled for an rvalue, so we don't have\n         // to do anything after a move to cancel or duplicate it.\n         bcx\n@@ -228,11 +228,11 @@ impl KindOps for Rvalue {\n }\n \n impl KindOps for Lvalue {\n-    fn post_store<'a>(&self,\n-                      bcx: &'a Block<'a>,\n-                      val: ValueRef,\n-                      ty: ty::t)\n-                      -> &'a Block<'a> {\n+    fn post_store<'blk, 'tcx>(&self,\n+                              bcx: Block<'blk, 'tcx>,\n+                              val: ValueRef,\n+                              ty: ty::t)\n+                              -> Block<'blk, 'tcx> {\n         /*!\n          * If an lvalue is moved, we must zero out the memory in which\n          * it resides so as to cancel cleanup. If an @T lvalue is\n@@ -263,11 +263,11 @@ impl KindOps for Lvalue {\n }\n \n impl KindOps for Expr {\n-    fn post_store<'a>(&self,\n-                      bcx: &'a Block<'a>,\n-                      val: ValueRef,\n-                      ty: ty::t)\n-                      -> &'a Block<'a> {\n+    fn post_store<'blk, 'tcx>(&self,\n+                              bcx: Block<'blk, 'tcx>,\n+                              val: ValueRef,\n+                              ty: ty::t)\n+                              -> Block<'blk, 'tcx> {\n         match *self {\n             LvalueExpr => Lvalue.post_store(bcx, val, ty),\n             RvalueExpr(ref r) => r.post_store(bcx, val, ty),\n@@ -302,11 +302,11 @@ impl Datum<Rvalue> {\n         self.val\n     }\n \n-    pub fn to_lvalue_datum_in_scope<'a>(self,\n-                                        bcx: &'a Block<'a>,\n-                                        name: &str,\n-                                        scope: cleanup::ScopeId)\n-                                        -> DatumBlock<'a, Lvalue> {\n+    pub fn to_lvalue_datum_in_scope<'blk, 'tcx>(self,\n+                                                bcx: Block<'blk, 'tcx>,\n+                                                name: &str,\n+                                                scope: cleanup::ScopeId)\n+                                                -> DatumBlock<'blk, 'tcx, Lvalue> {\n         /*!\n          * Returns an lvalue datum (that is, a by ref datum with\n          * cleanup scheduled). If `self` is not already an lvalue,\n@@ -328,7 +328,8 @@ impl Datum<Rvalue> {\n         }\n     }\n \n-    pub fn to_ref_datum<'a>(self, bcx: &'a Block<'a>) -> DatumBlock<'a, Rvalue> {\n+    pub fn to_ref_datum<'blk, 'tcx>(self, bcx: Block<'blk, 'tcx>)\n+                                    -> DatumBlock<'blk, 'tcx, Rvalue> {\n         let mut bcx = bcx;\n         match self.kind.mode {\n             ByRef => DatumBlock::new(bcx, self),\n@@ -340,9 +341,9 @@ impl Datum<Rvalue> {\n         }\n     }\n \n-    pub fn to_appropriate_datum<'a>(self,\n-                                    bcx: &'a Block<'a>)\n-                                    -> DatumBlock<'a, Rvalue> {\n+    pub fn to_appropriate_datum<'blk, 'tcx>(self,\n+                                            bcx: Block<'blk, 'tcx>)\n+                                            -> DatumBlock<'blk, 'tcx, Rvalue> {\n         match self.appropriate_rvalue_mode(bcx.ccx()) {\n             ByRef => {\n                 self.to_ref_datum(bcx)\n@@ -381,7 +382,7 @@ impl Datum<Expr> {\n     }\n \n     #[allow(dead_code)] // potentially useful\n-    pub fn assert_lvalue(self, bcx: &Block) -> Datum<Lvalue> {\n+    pub fn assert_lvalue(self, bcx: Block) -> Datum<Lvalue> {\n         /*!\n          * Asserts that this datum *is* an lvalue and returns it.\n          */\n@@ -391,7 +392,7 @@ impl Datum<Expr> {\n             |_| bcx.sess().bug(\"assert_lvalue given rvalue\"))\n     }\n \n-    pub fn assert_rvalue(self, bcx: &Block) -> Datum<Rvalue> {\n+    pub fn assert_rvalue(self, bcx: Block) -> Datum<Rvalue> {\n         /*!\n          * Asserts that this datum *is* an lvalue and returns it.\n          */\n@@ -401,11 +402,11 @@ impl Datum<Expr> {\n             |r| r)\n     }\n \n-    pub fn store_to_dest<'a>(self,\n-                             bcx: &'a Block<'a>,\n-                             dest: expr::Dest,\n-                             expr_id: ast::NodeId)\n-                             -> &'a Block<'a> {\n+    pub fn store_to_dest<'blk, 'tcx>(self,\n+                                     bcx: Block<'blk, 'tcx>,\n+                                     dest: expr::Dest,\n+                                     expr_id: ast::NodeId)\n+                                     -> Block<'blk, 'tcx> {\n         match dest {\n             expr::Ignore => {\n                 self.add_clean_if_rvalue(bcx, expr_id);\n@@ -417,9 +418,9 @@ impl Datum<Expr> {\n         }\n     }\n \n-    pub fn add_clean_if_rvalue<'a>(self,\n-                                   bcx: &'a Block<'a>,\n-                                   expr_id: ast::NodeId) {\n+    pub fn add_clean_if_rvalue<'blk, 'tcx>(self,\n+                                           bcx: Block<'blk, 'tcx>,\n+                                           expr_id: ast::NodeId) {\n         /*!\n          * Arranges cleanup for `self` if it is an rvalue. Use when\n          * you are done working with a value that may need drop.\n@@ -433,11 +434,11 @@ impl Datum<Expr> {\n             })\n     }\n \n-    pub fn clean<'a>(self,\n-                     bcx: &'a Block<'a>,\n-                     name: &'static str,\n-                     expr_id: ast::NodeId)\n-                     -> &'a Block<'a> {\n+    pub fn clean<'blk, 'tcx>(self,\n+                             bcx: Block<'blk, 'tcx>,\n+                             name: &'static str,\n+                             expr_id: ast::NodeId)\n+                             -> Block<'blk, 'tcx> {\n         /*!\n          * Ensures that `self` will get cleaned up, if it is not an lvalue\n          * already.\n@@ -446,11 +447,11 @@ impl Datum<Expr> {\n         self.to_lvalue_datum(bcx, name, expr_id).bcx\n     }\n \n-    pub fn to_lvalue_datum<'a>(self,\n-                               bcx: &'a Block<'a>,\n-                               name: &str,\n-                               expr_id: ast::NodeId)\n-                               -> DatumBlock<'a, Lvalue> {\n+    pub fn to_lvalue_datum<'blk, 'tcx>(self,\n+                                       bcx: Block<'blk, 'tcx>,\n+                                       name: &str,\n+                                       expr_id: ast::NodeId)\n+                                       -> DatumBlock<'blk, 'tcx, Lvalue> {\n         debug!(\"to_lvalue_datum self: {}\", self.to_string(bcx.ccx()));\n \n         assert!(ty::lltype_is_sized(bcx.tcx(), self.ty),\n@@ -463,10 +464,10 @@ impl Datum<Expr> {\n             })\n     }\n \n-    pub fn to_rvalue_datum<'a>(self,\n-                               bcx: &'a Block<'a>,\n-                               name: &'static str)\n-                               -> DatumBlock<'a, Rvalue> {\n+    pub fn to_rvalue_datum<'blk, 'tcx>(self,\n+                                       bcx: Block<'blk, 'tcx>,\n+                                       name: &'static str)\n+                                       -> DatumBlock<'blk, 'tcx, Rvalue> {\n         /*!\n          * Ensures that we have an rvalue datum (that is, a datum with\n          * no cleanup scheduled).\n@@ -514,11 +515,9 @@ impl Datum<Lvalue> {\n     // datum may also be unsized _without the size information_. It is the\n     // callers responsibility to package the result in some way to make a valid\n     // datum in that case (e.g., by making a fat pointer or opened pair).\n-    pub fn get_element<'a>(&self,\n-                           bcx: &'a Block<'a>,\n-                           ty: ty::t,\n-                           gep: |ValueRef| -> ValueRef)\n-                           -> Datum<Lvalue> {\n+    pub fn get_element(&self, bcx: Block, ty: ty::t,\n+                       gep: |ValueRef| -> ValueRef)\n+                       -> Datum<Lvalue> {\n         let val = match ty::get(self.ty).sty {\n             _ if ty::type_is_sized(bcx.tcx(), self.ty) => gep(self.val),\n             ty::ty_open(_) => {\n@@ -536,7 +535,7 @@ impl Datum<Lvalue> {\n         }\n     }\n \n-    pub fn get_vec_base_and_len<'a>(&self, bcx: &'a Block<'a>) -> (ValueRef, ValueRef) {\n+    pub fn get_vec_base_and_len(&self, bcx: Block) -> (ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair.\n \n         tvec::get_base_and_len(bcx, self.val, self.ty)\n@@ -556,10 +555,10 @@ impl<K:KindOps> Datum<K> {\n         Datum { val: val, ty: ty, kind: kind.to_expr_kind() }\n     }\n \n-    pub fn store_to<'a>(self,\n-                        bcx: &'a Block<'a>,\n-                        dst: ValueRef)\n-                        -> &'a Block<'a> {\n+    pub fn store_to<'blk, 'tcx>(self,\n+                                bcx: Block<'blk, 'tcx>,\n+                                dst: ValueRef)\n+                                -> Block<'blk, 'tcx> {\n         /*!\n          * Moves or copies this value into a new home, as appropriate\n          * depending on the type of the datum. This method consumes\n@@ -573,10 +572,10 @@ impl<K:KindOps> Datum<K> {\n         self.kind.post_store(bcx, self.val, self.ty)\n     }\n \n-    fn shallow_copy<'a>(&self,\n-                        bcx: &'a Block<'a>,\n-                        dst: ValueRef)\n-                        -> &'a Block<'a> {\n+    fn shallow_copy<'blk, 'tcx>(&self,\n+                                bcx: Block<'blk, 'tcx>,\n+                                dst: ValueRef)\n+                                -> Block<'blk, 'tcx> {\n         /*!\n          * Helper function that performs a shallow copy of this value\n          * into `dst`, which should be a pointer to a memory location\n@@ -606,10 +605,10 @@ impl<K:KindOps> Datum<K> {\n         return bcx;\n     }\n \n-    pub fn shallow_copy_and_take<'a>(&self,\n-                                     bcx: &'a Block<'a>,\n-                                     dst: ValueRef)\n-                                     -> &'a Block<'a> {\n+    pub fn shallow_copy_and_take<'blk, 'tcx>(&self,\n+                                             bcx: Block<'blk, 'tcx>,\n+                                             dst: ValueRef)\n+                                             -> Block<'blk, 'tcx> {\n         /*!\n          * Copies the value into a new location and runs any necessary\n          * take glue on the new location. This function always\n@@ -638,7 +637,7 @@ impl<K:KindOps> Datum<K> {\n         appropriate_rvalue_mode(ccx, self.ty)\n     }\n \n-    pub fn to_llscalarish<'a>(self, bcx: &'a Block<'a>) -> ValueRef {\n+    pub fn to_llscalarish(self, bcx: Block) -> ValueRef {\n         /*!\n          * Converts `self` into a by-value `ValueRef`. Consumes this\n          * datum (i.e., absolves you of responsibility to cleanup the\n@@ -657,33 +656,33 @@ impl<K:KindOps> Datum<K> {\n         }\n     }\n \n-    pub fn to_llbool<'a>(self, bcx: &'a Block<'a>) -> ValueRef {\n+    pub fn to_llbool(self, bcx: Block) -> ValueRef {\n         assert!(ty::type_is_bool(self.ty) || ty::type_is_bot(self.ty))\n         self.to_llscalarish(bcx)\n     }\n }\n \n-impl <'a, K> DatumBlock<'a, K> {\n-    pub fn new(bcx: &'a Block<'a>, datum: Datum<K>) -> DatumBlock<'a, K> {\n+impl<'blk, 'tcx, K> DatumBlock<'blk, 'tcx, K> {\n+    pub fn new(bcx: Block<'blk, 'tcx>, datum: Datum<K>) -> DatumBlock<'blk, 'tcx, K> {\n         DatumBlock { bcx: bcx, datum: datum }\n     }\n }\n \n-impl<'a, K:KindOps> DatumBlock<'a, K> {\n-    pub fn to_expr_datumblock(self) -> DatumBlock<'a, Expr> {\n+impl<'blk, 'tcx, K:KindOps> DatumBlock<'blk, 'tcx, K> {\n+    pub fn to_expr_datumblock(self) -> DatumBlock<'blk, 'tcx, Expr> {\n         DatumBlock::new(self.bcx, self.datum.to_expr_datum())\n     }\n }\n \n-impl<'a> DatumBlock<'a, Expr> {\n+impl<'blk, 'tcx> DatumBlock<'blk, 'tcx, Expr> {\n     pub fn store_to_dest(self,\n                          dest: expr::Dest,\n-                         expr_id: ast::NodeId) -> &'a Block<'a> {\n+                         expr_id: ast::NodeId) -> Block<'blk, 'tcx> {\n         let DatumBlock { bcx, datum } = self;\n         datum.store_to_dest(bcx, dest, expr_id)\n     }\n \n-    pub fn to_llbool(self) -> Result<'a> {\n+    pub fn to_llbool(self) -> Result<'blk, 'tcx> {\n         let DatumBlock { datum, bcx } = self;\n         Result::new(bcx, datum.to_llbool(bcx))\n     }"}, {"sha": "b640f9ef5af11dfb5cb6640666de6bd6824e1fc7", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -832,7 +832,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n /// Creates debug information for the given local variable.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n+pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n@@ -867,7 +867,7 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n /// Creates debug information for a variable captured in a closure.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_captured_var_metadata(bcx: &Block,\n+pub fn create_captured_var_metadata(bcx: Block,\n                                     node_id: ast::NodeId,\n                                     env_data_type: ty::t,\n                                     env_pointer: ValueRef,\n@@ -954,7 +954,7 @@ pub fn create_captured_var_metadata(bcx: &Block,\n /// match-statement arm.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_match_binding_metadata(bcx: &Block,\n+pub fn create_match_binding_metadata(bcx: Block,\n                                      variable_ident: ast::Ident,\n                                      binding: BindingInfo) {\n     if fn_should_be_ignored(bcx.fcx) {\n@@ -994,7 +994,7 @@ pub fn create_match_binding_metadata(bcx: &Block,\n /// Creates debug information for the given function argument.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n+pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n@@ -1518,7 +1518,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n     }\n }\n \n-fn declare_local(bcx: &Block,\n+fn declare_local(bcx: Block,\n                  variable_ident: ast::Ident,\n                  variable_type: ty::t,\n                  scope_metadata: DIScope,"}, {"sha": "0421aef45ef9c4617d866f1e1f99c1889ebd62c7", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 208, "deletions": 213, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -100,10 +100,10 @@ impl Dest {\n     }\n }\n \n-pub fn trans_into<'a>(bcx: &'a Block<'a>,\n-                      expr: &ast::Expr,\n-                      dest: Dest)\n-                      -> &'a Block<'a> {\n+pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              expr: &ast::Expr,\n+                              dest: Dest)\n+                              -> Block<'blk, 'tcx> {\n     /*!\n      * This function is equivalent to `trans(bcx, expr).store_to_dest(dest)`\n      * but it may generate better optimized LLVM code.\n@@ -139,9 +139,9 @@ pub fn trans_into<'a>(bcx: &'a Block<'a>,\n     bcx.fcx.pop_and_trans_ast_cleanup_scope(bcx, expr.id)\n }\n \n-pub fn trans<'a>(bcx: &'a Block<'a>,\n-                 expr: &ast::Expr)\n-                 -> DatumBlock<'a, Expr> {\n+pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                         expr: &ast::Expr)\n+                         -> DatumBlock<'blk, 'tcx, Expr> {\n     /*!\n      * Translates an expression, returning a datum (and new block)\n      * encapsulating the result. When possible, it is preferred to\n@@ -161,18 +161,18 @@ pub fn trans<'a>(bcx: &'a Block<'a>,\n     return DatumBlock::new(bcx, datum);\n }\n \n-pub fn get_len(bcx: &Block, fat_ptr: ValueRef) -> ValueRef {\n+pub fn get_len(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n     GEPi(bcx, fat_ptr, [0u, abi::slice_elt_len])\n }\n \n-pub fn get_dataptr(bcx: &Block, fat_ptr: ValueRef) -> ValueRef {\n+pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n     GEPi(bcx, fat_ptr, [0u, abi::slice_elt_base])\n }\n \n-fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n-                         expr: &ast::Expr,\n-                         datum: Datum<Expr>)\n-                         -> DatumBlock<'a, Expr> {\n+fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 expr: &ast::Expr,\n+                                 datum: Datum<Expr>)\n+                                 -> DatumBlock<'blk, 'tcx, Expr> {\n     /*!\n      * Helper for trans that apply adjustments from `expr` to `datum`,\n      * which should be the unadjusted translation of `expr`.\n@@ -245,11 +245,11 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n     debug!(\"after adjustments, datum={}\", datum.to_string(bcx.ccx()));\n     return DatumBlock::new(bcx, datum);\n \n-    fn apply_autoref<'a>(autoref: &ty::AutoRef,\n-                         bcx: &'a Block<'a>,\n-                         expr: &ast::Expr,\n-                         datum: Datum<Expr>)\n-                         -> DatumBlock<'a, Expr> {\n+    fn apply_autoref<'blk, 'tcx>(autoref: &ty::AutoRef,\n+                                 bcx: Block<'blk, 'tcx>,\n+                                 expr: &ast::Expr,\n+                                 datum: Datum<Expr>)\n+                                 -> DatumBlock<'blk, 'tcx, Expr> {\n         let mut bcx = bcx;\n         let mut datum = datum;\n \n@@ -281,10 +281,10 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         DatumBlock::new(bcx, datum)\n     }\n \n-    fn ref_ptr<'a>(bcx: &'a Block<'a>,\n-                   expr: &ast::Expr,\n-                   datum: Datum<Expr>)\n-                   -> DatumBlock<'a, Expr> {\n+    fn ref_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                           expr: &ast::Expr,\n+                           datum: Datum<Expr>)\n+                           -> DatumBlock<'blk, 'tcx, Expr> {\n         if !ty::type_is_sized(bcx.tcx(), datum.ty) {\n             debug!(\"Taking address of unsized type {}\",\n                    bcx.ty_to_string(datum.ty));\n@@ -303,11 +303,11 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n     // into a type to be destructed. If we want to end up with a Box pointer,\n     // then mk_ty should make a Box pointer (T -> Box<T>), if we want a\n     // borrowed reference then it should be T -> &T.\n-    fn unsized_info<'a>(bcx: &'a Block<'a>,\n-                        kind: &ty::UnsizeKind,\n-                        id: ast::NodeId,\n-                        unsized_ty: ty::t,\n-                        mk_ty: |ty::t| -> ty::t) -> ValueRef {\n+    fn unsized_info<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                kind: &ty::UnsizeKind,\n+                                id: ast::NodeId,\n+                                unsized_ty: ty::t,\n+                                mk_ty: |ty::t| -> ty::t) -> ValueRef {\n         match kind {\n             &ty::UnsizeLength(len) => C_uint(bcx.ccx(), len),\n             &ty::UnsizeStruct(box ref k, tp_index) => match ty::get(unsized_ty).sty {\n@@ -327,11 +327,11 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         }\n     }\n \n-    fn unsize_expr<'a>(bcx: &'a Block<'a>,\n-                       expr: &ast::Expr,\n-                       datum: Datum<Expr>,\n-                       k: &ty::UnsizeKind)\n-                       -> DatumBlock<'a, Expr> {\n+    fn unsize_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               expr: &ast::Expr,\n+                               datum: Datum<Expr>,\n+                               k: &ty::UnsizeKind)\n+                               -> DatumBlock<'blk, 'tcx, Expr> {\n         let tcx = bcx.tcx();\n         let datum_ty = datum.ty;\n         let unsized_ty = ty::unsize_ty(tcx, datum_ty, k, expr.span);\n@@ -361,24 +361,24 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         into_fat_ptr(bcx, expr, datum, dest_ty, base, info)\n     }\n \n-    fn ref_fat_ptr<'a>(bcx: &'a Block<'a>,\n-                       expr: &ast::Expr,\n-                       datum: Datum<Expr>)\n-                       -> DatumBlock<'a, Expr> {\n+    fn ref_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               expr: &ast::Expr,\n+                               datum: Datum<Expr>)\n+                               -> DatumBlock<'blk, 'tcx, Expr> {\n         let tcx = bcx.tcx();\n         let dest_ty = ty::close_type(tcx, datum.ty);\n         let base = |bcx, val| Load(bcx, get_dataptr(bcx, val));\n         let len = |bcx, val| Load(bcx, get_len(bcx, val));\n         into_fat_ptr(bcx, expr, datum, dest_ty, base, len)\n     }\n \n-    fn into_fat_ptr<'a>(bcx: &'a Block<'a>,\n-                        expr: &ast::Expr,\n-                        datum: Datum<Expr>,\n-                        dest_ty: ty::t,\n-                        base: |&'a Block<'a>, ValueRef| -> ValueRef,\n-                        info: |&'a Block<'a>, ValueRef| -> ValueRef)\n-                        -> DatumBlock<'a, Expr> {\n+    fn into_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                expr: &ast::Expr,\n+                                datum: Datum<Expr>,\n+                                dest_ty: ty::t,\n+                                base: |Block<'blk, 'tcx>, ValueRef| -> ValueRef,\n+                                info: |Block<'blk, 'tcx>, ValueRef| -> ValueRef)\n+                                -> DatumBlock<'blk, 'tcx, Expr> {\n         let mut bcx = bcx;\n \n         // Arrange cleanup\n@@ -394,11 +394,11 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         DatumBlock::new(bcx, scratch.to_expr_datum())\n     }\n \n-    fn unsize_unique_vec<'a>(bcx: &'a Block<'a>,\n-                             expr: &ast::Expr,\n-                             datum: Datum<Expr>,\n-                             len: uint)\n-                             -> DatumBlock<'a, Expr> {\n+    fn unsize_unique_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     expr: &ast::Expr,\n+                                     datum: Datum<Expr>,\n+                                     len: uint)\n+                                     -> DatumBlock<'blk, 'tcx, Expr> {\n         let mut bcx = bcx;\n         let tcx = bcx.tcx();\n \n@@ -440,11 +440,11 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         DatumBlock::new(bcx, scratch.to_expr_datum())\n     }\n \n-    fn unsize_unique_expr<'a>(bcx: &'a Block<'a>,\n-                              expr: &ast::Expr,\n-                              datum: Datum<Expr>,\n-                              k: &ty::UnsizeKind)\n-                              -> DatumBlock<'a, Expr> {\n+    fn unsize_unique_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      expr: &ast::Expr,\n+                                      datum: Datum<Expr>,\n+                                      k: &ty::UnsizeKind)\n+                                      -> DatumBlock<'blk, 'tcx, Expr> {\n         let mut bcx = bcx;\n         let tcx = bcx.tcx();\n \n@@ -475,10 +475,10 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         DatumBlock::new(bcx, scratch.to_expr_datum())\n     }\n \n-    fn add_env<'a>(bcx: &'a Block<'a>,\n-                   expr: &ast::Expr,\n-                   datum: Datum<Expr>)\n-                   -> DatumBlock<'a, Expr> {\n+    fn add_env<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                           expr: &ast::Expr,\n+                           datum: Datum<Expr>)\n+                           -> DatumBlock<'blk, 'tcx, Expr> {\n         // This is not the most efficient thing possible; since closures\n         // are two words it'd be better if this were compiled in\n         // 'dest' mode, but I can't find a nice way to structure the\n@@ -492,10 +492,10 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-pub fn trans_to_lvalue<'a>(bcx: &'a Block<'a>,\n-                           expr: &ast::Expr,\n-                           name: &str)\n-                           -> DatumBlock<'a, Lvalue> {\n+pub fn trans_to_lvalue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   expr: &ast::Expr,\n+                                   name: &str)\n+                                   -> DatumBlock<'blk, 'tcx, Lvalue> {\n     /*!\n      * Translates an expression in \"lvalue\" mode -- meaning that it\n      * returns a reference to the memory that the expr represents.\n@@ -512,9 +512,9 @@ pub fn trans_to_lvalue<'a>(bcx: &'a Block<'a>,\n     return datum.to_lvalue_datum(bcx, name, expr.id);\n }\n \n-fn trans_unadjusted<'a>(bcx: &'a Block<'a>,\n-                        expr: &ast::Expr)\n-                        -> DatumBlock<'a, Expr> {\n+fn trans_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                expr: &ast::Expr)\n+                                -> DatumBlock<'blk, 'tcx, Expr> {\n     /*!\n      * A version of `trans` that ignores adjustments. You almost\n      * certainly do not want to call this directly.\n@@ -568,16 +568,17 @@ fn trans_unadjusted<'a>(bcx: &'a Block<'a>,\n         }\n     };\n \n-    fn nil<'a>(bcx: &'a Block<'a>, ty: ty::t) -> DatumBlock<'a, Expr> {\n+    fn nil<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ty: ty::t)\n+                       -> DatumBlock<'blk, 'tcx, Expr> {\n         let llval = C_undef(type_of::type_of(bcx.ccx(), ty));\n         let datum = immediate_rvalue(llval, ty);\n         DatumBlock::new(bcx, datum.to_expr_datum())\n     }\n }\n \n-fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n-                              expr: &ast::Expr)\n-                              -> DatumBlock<'a, Expr> {\n+fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      expr: &ast::Expr)\n+                                      -> DatumBlock<'blk, 'tcx, Expr> {\n     let mut bcx = bcx;\n     let fcx = bcx.fcx;\n     let _icx = push_ctxt(\"trans_datum_unadjusted\");\n@@ -665,10 +666,10 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-fn trans_rec_field<'a>(bcx: &'a Block<'a>,\n-                       base: &ast::Expr,\n-                       field: ast::Ident)\n-                       -> DatumBlock<'a, Expr> {\n+fn trans_rec_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               base: &ast::Expr,\n+                               field: ast::Ident)\n+                               -> DatumBlock<'blk, 'tcx, Expr> {\n     //! Translates `base.field`.\n \n     let mut bcx = bcx;\n@@ -698,12 +699,12 @@ fn trans_rec_field<'a>(bcx: &'a Block<'a>,\n     })\n }\n \n-fn trans_index<'a>(bcx: &'a Block<'a>,\n-                   index_expr: &ast::Expr,\n-                   base: &ast::Expr,\n-                   idx: &ast::Expr,\n-                   method_call: MethodCall)\n-                   -> DatumBlock<'a, Expr> {\n+fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                           index_expr: &ast::Expr,\n+                           base: &ast::Expr,\n+                           idx: &ast::Expr,\n+                           method_call: MethodCall)\n+                           -> DatumBlock<'blk, 'tcx, Expr> {\n     //! Translates `base[idx]`.\n \n     let _icx = push_ctxt(\"trans_index\");\n@@ -803,11 +804,10 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n     DatumBlock::new(bcx, elt_datum)\n }\n \n-fn trans_def<'a>(bcx: &'a Block<'a>,\n-                 ref_expr: &ast::Expr,\n-                 def: def::Def)\n-                 -> DatumBlock<'a, Expr>\n-{\n+fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                         ref_expr: &ast::Expr,\n+                         def: def::Def)\n+                         -> DatumBlock<'blk, 'tcx, Expr> {\n     //! Translates a reference to a path.\n \n     let _icx = push_ctxt(\"trans_def_lvalue\");\n@@ -830,8 +830,8 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n             //     an external global, and return a pointer to that.\n             let const_ty = expr_ty(bcx, ref_expr);\n \n-            fn get_val<'a>(bcx: &'a Block<'a>, did: ast::DefId, const_ty: ty::t)\n-                       -> ValueRef {\n+            fn get_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, did: ast::DefId, const_ty: ty::t)\n+                                   -> ValueRef {\n                 // For external constants, we don't inline.\n                 if did.krate == ast::LOCAL_CRATE {\n                     // Case 1 or 2.  (The inlining in case 2 produces a new\n@@ -880,9 +880,9 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>,\n-                                    expr: &ast::Expr)\n-                                    -> &'a Block<'a> {\n+fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                            expr: &ast::Expr)\n+                                            -> Block<'blk, 'tcx> {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rvalue_stmt\");\n \n@@ -961,10 +961,10 @@ fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n-                                   expr: &ast::Expr,\n-                                   dest: Dest)\n-                                   -> &'a Block<'a> {\n+fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                           expr: &ast::Expr,\n+                                           dest: Dest)\n+                                           -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx();\n@@ -1091,12 +1091,11 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-fn trans_def_dps_unadjusted<'a>(\n-                            bcx: &'a Block<'a>,\n-                            ref_expr: &ast::Expr,\n-                            def: def::Def,\n-                            dest: Dest)\n-                            -> &'a Block<'a> {\n+fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                        ref_expr: &ast::Expr,\n+                                        def: def::Def,\n+                                        dest: Dest)\n+                                        -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n \n     let lldest = match dest {\n@@ -1140,9 +1139,10 @@ fn trans_def_dps_unadjusted<'a>(\n     }\n }\n \n-fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n-                               ref_expr: &ast::Expr,\n-                               def: def::Def) -> DatumBlock<'a, Expr> {\n+fn trans_def_fn_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       ref_expr: &ast::Expr,\n+                                       def: def::Def)\n+                                       -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n     let llfn = match def {\n@@ -1167,9 +1167,9 @@ fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n     DatumBlock::new(bcx, Datum::new(llfn, fn_ty, RvalueExpr(Rvalue::new(ByValue))))\n }\n \n-pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n-                           def: def::Def)\n-                           -> Datum<Lvalue> {\n+pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   def: def::Def)\n+                                   -> Datum<Lvalue> {\n     /*!\n      * Translates a reference to a local variable or argument.\n      * This always results in an lvalue datum.\n@@ -1203,10 +1203,10 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n         }\n     };\n \n-    fn take_local<'a>(bcx: &'a Block<'a>,\n-                      table: &NodeMap<Datum<Lvalue>>,\n-                      nid: ast::NodeId)\n-                      -> Datum<Lvalue> {\n+    fn take_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              table: &NodeMap<Datum<Lvalue>>,\n+                              nid: ast::NodeId)\n+                              -> Datum<Lvalue> {\n         let datum = match table.find(&nid) {\n             Some(&v) => v,\n             None => {\n@@ -1275,12 +1275,12 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n     }\n }\n \n-fn trans_struct<'a>(bcx: &'a Block<'a>,\n-                    fields: &[ast::Field],\n-                    base: Option<Gc<ast::Expr>>,\n-                    expr_span: codemap::Span,\n-                    id: ast::NodeId,\n-                    dest: Dest) -> &'a Block<'a> {\n+fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                            fields: &[ast::Field],\n+                            base: Option<Gc<ast::Expr>>,\n+                            expr_span: codemap::Span,\n+                            id: ast::NodeId,\n+                            dest: Dest) -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_rec\");\n \n     let ty = node_id_type(bcx, id);\n@@ -1350,12 +1350,12 @@ pub struct StructBaseInfo {\n  * - `optbase` contains information on the base struct (if any) from\n  * which remaining fields are copied; see comments on `StructBaseInfo`.\n  */\n-pub fn trans_adt<'a>(mut bcx: &'a Block<'a>,\n-                     ty: ty::t,\n-                     discr: ty::Disr,\n-                     fields: &[(uint, Gc<ast::Expr>)],\n-                     optbase: Option<StructBaseInfo>,\n-                     dest: Dest) -> &'a Block<'a> {\n+pub fn trans_adt<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                             ty: ty::t,\n+                             discr: ty::Disr,\n+                             fields: &[(uint, Gc<ast::Expr>)],\n+                             optbase: Option<StructBaseInfo>,\n+                             dest: Dest) -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_adt\");\n     let fcx = bcx.fcx;\n     let repr = adt::represent_type(bcx.ccx(), ty);\n@@ -1419,22 +1419,22 @@ pub fn trans_adt<'a>(mut bcx: &'a Block<'a>,\n }\n \n \n-fn trans_immediate_lit<'a>(bcx: &'a Block<'a>,\n-                           expr: &ast::Expr,\n-                           lit: ast::Lit)\n-                           -> DatumBlock<'a, Expr> {\n+fn trans_immediate_lit<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   expr: &ast::Expr,\n+                                   lit: ast::Lit)\n+                                   -> DatumBlock<'blk, 'tcx, Expr> {\n     // must not be a string constant, that is a RvalueDpsExpr\n     let _icx = push_ctxt(\"trans_immediate_lit\");\n     let ty = expr_ty(bcx, expr);\n     let v = consts::const_lit(bcx.ccx(), expr, lit);\n     immediate_rvalue_bcx(bcx, v, ty).to_expr_datumblock()\n }\n \n-fn trans_unary<'a>(bcx: &'a Block<'a>,\n-                   expr: &ast::Expr,\n-                   op: ast::UnOp,\n-                   sub_expr: &ast::Expr)\n-                   -> DatumBlock<'a, Expr> {\n+fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                           expr: &ast::Expr,\n+                           op: ast::UnOp,\n+                           sub_expr: &ast::Expr)\n+                           -> DatumBlock<'blk, 'tcx, Expr> {\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_unary_datum\");\n@@ -1481,11 +1481,11 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-fn trans_uniq_expr<'a>(bcx: &'a Block<'a>,\n-                       box_ty: ty::t,\n-                       contents: &ast::Expr,\n-                       contents_ty: ty::t)\n-                        -> DatumBlock<'a, Expr> {\n+fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               box_ty: ty::t,\n+                               contents: &ast::Expr,\n+                               contents_ty: ty::t)\n+                               -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_uniq_expr\");\n     let fcx = bcx.fcx;\n     assert!(ty::type_is_sized(bcx.tcx(), contents_ty));\n@@ -1510,11 +1510,11 @@ fn trans_uniq_expr<'a>(bcx: &'a Block<'a>,\n     immediate_rvalue_bcx(bcx, val, box_ty).to_expr_datumblock()\n }\n \n-fn trans_managed_expr<'a>(bcx: &'a Block<'a>,\n-                          box_ty: ty::t,\n-                          contents: &ast::Expr,\n-                          contents_ty: ty::t)\n-                          -> DatumBlock<'a, Expr> {\n+fn trans_managed_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  box_ty: ty::t,\n+                                  contents: &ast::Expr,\n+                                  contents_ty: ty::t)\n+                                  -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_managed_expr\");\n     let fcx = bcx.fcx;\n     let ty = type_of::type_of(bcx.ccx(), contents_ty);\n@@ -1530,10 +1530,10 @@ fn trans_managed_expr<'a>(bcx: &'a Block<'a>,\n     immediate_rvalue_bcx(bcx, bx, box_ty).to_expr_datumblock()\n }\n \n-fn trans_addr_of<'a>(bcx: &'a Block<'a>,\n-                     expr: &ast::Expr,\n-                     subexpr: &ast::Expr)\n-                     -> DatumBlock<'a, Expr> {\n+fn trans_addr_of<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             expr: &ast::Expr,\n+                             subexpr: &ast::Expr)\n+                             -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n     let sub_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, subexpr, \"addr_of\"));\n@@ -1563,16 +1563,15 @@ fn trans_addr_of<'a>(bcx: &'a Block<'a>,\n \n // Important to get types for both lhs and rhs, because one might be _|_\n // and the other not.\n-fn trans_eager_binop<'a>(\n-                     bcx: &'a Block<'a>,\n-                     binop_expr: &ast::Expr,\n-                     binop_ty: ty::t,\n-                     op: ast::BinOp,\n-                     lhs_t: ty::t,\n-                     lhs: ValueRef,\n-                     rhs_t: ty::t,\n-                     rhs: ValueRef)\n-                     -> DatumBlock<'a, Expr> {\n+fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 binop_expr: &ast::Expr,\n+                                 binop_ty: ty::t,\n+                                 op: ast::BinOp,\n+                                 lhs_t: ty::t,\n+                                 lhs: ValueRef,\n+                                 rhs_t: ty::t,\n+                                 rhs: ValueRef)\n+                                 -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_eager_binop\");\n \n     let tcx = bcx.tcx();\n@@ -1663,13 +1662,12 @@ enum lazy_binop_ty {\n     lazy_or,\n }\n \n-fn trans_lazy_binop<'a>(\n-                    bcx: &'a Block<'a>,\n-                    binop_expr: &ast::Expr,\n-                    op: lazy_binop_ty,\n-                    a: &ast::Expr,\n-                    b: &ast::Expr)\n-                    -> DatumBlock<'a, Expr> {\n+fn trans_lazy_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                binop_expr: &ast::Expr,\n+                                op: lazy_binop_ty,\n+                                a: &ast::Expr,\n+                                b: &ast::Expr)\n+                                -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_lazy_binop\");\n     let binop_ty = expr_ty(bcx, binop_expr);\n     let fcx = bcx.fcx;\n@@ -1703,12 +1701,12 @@ fn trans_lazy_binop<'a>(\n     return immediate_rvalue_bcx(join, phi, binop_ty).to_expr_datumblock();\n }\n \n-fn trans_binary<'a>(bcx: &'a Block<'a>,\n-                    expr: &ast::Expr,\n-                    op: ast::BinOp,\n-                    lhs: &ast::Expr,\n-                    rhs: &ast::Expr)\n-                    -> DatumBlock<'a, Expr> {\n+fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                            expr: &ast::Expr,\n+                            op: ast::BinOp,\n+                            lhs: &ast::Expr,\n+                            rhs: &ast::Expr)\n+                            -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_binary\");\n     let ccx = bcx.ccx();\n \n@@ -1745,14 +1743,13 @@ fn trans_binary<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-fn trans_overloaded_op<'a, 'b>(\n-                       bcx: &'a Block<'a>,\n-                       expr: &ast::Expr,\n-                       method_call: MethodCall,\n-                       lhs: Datum<Expr>,\n-                       rhs: Option<(Datum<Expr>, ast::NodeId)>,\n-                       dest: Option<Dest>)\n-                       -> Result<'a> {\n+fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   expr: &ast::Expr,\n+                                   method_call: MethodCall,\n+                                   lhs: Datum<Expr>,\n+                                   rhs: Option<(Datum<Expr>, ast::NodeId)>,\n+                                   dest: Option<Dest>)\n+                                   -> Result<'blk, 'tcx> {\n     let method_ty = bcx.tcx().method_map.borrow().get(&method_call).ty;\n     callee::trans_call_inner(bcx,\n                              Some(expr_info(expr)),\n@@ -1767,13 +1764,12 @@ fn trans_overloaded_op<'a, 'b>(\n                              dest)\n }\n \n-fn trans_overloaded_call<'a>(\n-                         mut bcx: &'a Block<'a>,\n-                         expr: &ast::Expr,\n-                         callee: Gc<ast::Expr>,\n-                         args: &[Gc<ast::Expr>],\n-                         dest: Option<Dest>)\n-                         -> &'a Block<'a> {\n+fn trans_overloaded_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                     expr: &ast::Expr,\n+                                     callee: Gc<ast::Expr>,\n+                                     args: &[Gc<ast::Expr>],\n+                                     dest: Option<Dest>)\n+                                     -> Block<'blk, 'tcx> {\n     let method_call = MethodCall::expr(expr.id);\n     let method_type = bcx.tcx()\n                          .method_map\n@@ -1800,7 +1796,7 @@ fn trans_overloaded_call<'a>(\n     bcx\n }\n \n-fn int_cast(bcx: &Block,\n+fn int_cast(bcx: Block,\n             lldsttype: Type,\n             llsrctype: Type,\n             llsrc: ValueRef,\n@@ -1822,7 +1818,7 @@ fn int_cast(bcx: &Block,\n     }\n }\n \n-fn float_cast(bcx: &Block,\n+fn float_cast(bcx: Block,\n               lldsttype: Type,\n               llsrctype: Type,\n               llsrc: ValueRef)\n@@ -1879,10 +1875,10 @@ fn cast_is_noop(t_in: ty::t, t_out: ty::t) -> bool {\n     }\n }\n \n-fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n-                      expr: &ast::Expr,\n-                      id: ast::NodeId)\n-                      -> DatumBlock<'a, Expr> {\n+fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              expr: &ast::Expr,\n+                              id: ast::NodeId)\n+                              -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_cast\");\n     let mut bcx = bcx;\n     let ccx = bcx.ccx();\n@@ -1971,13 +1967,12 @@ fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }\n \n-fn trans_assign_op<'a>(\n-                   bcx: &'a Block<'a>,\n-                   expr: &ast::Expr,\n-                   op: ast::BinOp,\n-                   dst: &ast::Expr,\n-                   src: Gc<ast::Expr>)\n-                   -> &'a Block<'a> {\n+fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               expr: &ast::Expr,\n+                               op: ast::BinOp,\n+                               dst: &ast::Expr,\n+                               src: Gc<ast::Expr>)\n+                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;\n \n@@ -2004,10 +1999,10 @@ fn trans_assign_op<'a>(\n     return result_datum.store_to(bcx, dst_datum.val);\n }\n \n-fn auto_ref<'a>(bcx: &'a Block<'a>,\n-                datum: Datum<Expr>,\n-                expr: &ast::Expr)\n-                -> DatumBlock<'a, Expr> {\n+fn auto_ref<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                        datum: Datum<Expr>,\n+                        expr: &ast::Expr)\n+                        -> DatumBlock<'blk, 'tcx, Expr> {\n     let mut bcx = bcx;\n \n     // Ensure cleanup of `datum` if not already scheduled and obtain\n@@ -2028,11 +2023,11 @@ fn auto_ref<'a>(bcx: &'a Block<'a>,\n     DatumBlock::new(bcx, Datum::new(llref, ptr_ty, RvalueExpr(Rvalue::new(ByValue))))\n }\n \n-fn deref_multiple<'a>(bcx: &'a Block<'a>,\n-                      expr: &ast::Expr,\n-                      datum: Datum<Expr>,\n-                      times: uint)\n-                      -> DatumBlock<'a, Expr> {\n+fn deref_multiple<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              expr: &ast::Expr,\n+                              datum: Datum<Expr>,\n+                              times: uint)\n+                              -> DatumBlock<'blk, 'tcx, Expr> {\n     let mut bcx = bcx;\n     let mut datum = datum;\n     for i in range(0, times) {\n@@ -2042,11 +2037,11 @@ fn deref_multiple<'a>(bcx: &'a Block<'a>,\n     DatumBlock { bcx: bcx, datum: datum }\n }\n \n-fn deref_once<'a>(bcx: &'a Block<'a>,\n-                  expr: &ast::Expr,\n-                  datum: Datum<Expr>,\n-                  method_call: MethodCall)\n-                  -> DatumBlock<'a, Expr> {\n+fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                          expr: &ast::Expr,\n+                          datum: Datum<Expr>,\n+                          method_call: MethodCall)\n+                          -> DatumBlock<'blk, 'tcx, Expr> {\n     let ccx = bcx.ccx();\n \n     debug!(\"deref_once(expr={}, datum={}, method_call={})\",\n@@ -2146,11 +2141,11 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n \n     return r;\n \n-    fn deref_owned_pointer<'a>(bcx: &'a Block<'a>,\n-                               expr: &ast::Expr,\n-                               datum: Datum<Expr>,\n-                               content_ty: ty::t)\n-                               -> DatumBlock<'a, Expr> {\n+    fn deref_owned_pointer<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       expr: &ast::Expr,\n+                                       datum: Datum<Expr>,\n+                                       content_ty: ty::t)\n+                                       -> DatumBlock<'blk, 'tcx, Expr> {\n         /*!\n          * We microoptimize derefs of owned pointers a bit here.\n          * Basically, the idea is to make the deref of an rvalue"}, {"sha": "2cb8c86094496ad253a818d6e1711fb86b27c317", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -247,14 +247,13 @@ pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi, fty: ty::t,\n     llfn\n }\n \n-pub fn trans_native_call<'a>(\n-                         bcx: &'a Block<'a>,\n-                         callee_ty: ty::t,\n-                         llfn: ValueRef,\n-                         llretptr: ValueRef,\n-                         llargs_rust: &[ValueRef],\n-                         passed_arg_tys: Vec<ty::t> )\n-                         -> &'a Block<'a> {\n+pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     callee_ty: ty::t,\n+                                     llfn: ValueRef,\n+                                     llretptr: ValueRef,\n+                                     llargs_rust: &[ValueRef],\n+                                     passed_arg_tys: Vec<ty::t> )\n+                                     -> Block<'blk, 'tcx> {\n     /*!\n      * Prepares a call to a native function. This requires adapting\n      * from the Rust argument passing rules to the native rules."}, {"sha": "259f85098afee14ff9feec007d8f8b569c5c3b51", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -45,16 +45,18 @@ use libc::c_uint;\n use syntax::ast;\n use syntax::parse::token;\n \n-pub fn trans_free<'a>(cx: &'a Block<'a>, v: ValueRef) -> &'a Block<'a> {\n+pub fn trans_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef)\n+                              -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_free\");\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", FreeFnLangItem),\n         [PointerCast(cx, v, Type::i8p(cx.ccx()))],\n         Some(expr::Ignore)).bcx\n }\n \n-pub fn trans_exchange_free_dyn<'a>(cx: &'a Block<'a>, v: ValueRef, size: ValueRef,\n-                               align: ValueRef) -> &'a Block<'a> {\n+pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n+                                           size: ValueRef, align: ValueRef)\n+                                           -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     let ccx = cx.ccx();\n     callee::trans_lang_call(cx,\n@@ -63,14 +65,14 @@ pub fn trans_exchange_free_dyn<'a>(cx: &'a Block<'a>, v: ValueRef, size: ValueRe\n         Some(expr::Ignore)).bcx\n }\n \n-pub fn trans_exchange_free<'a>(cx: &'a Block<'a>, v: ValueRef, size: u64,\n-                               align: u64) -> &'a Block<'a> {\n+pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n+                                       size: u64, align: u64) -> Block<'blk, 'tcx> {\n     trans_exchange_free_dyn(cx, v, C_uint(cx.ccx(), size as uint),\n                             C_uint(cx.ccx(), align as uint))\n }\n \n-pub fn trans_exchange_free_ty<'a>(bcx: &'a Block<'a>, ptr: ValueRef,\n-                                  content_ty: ty::t) -> &'a Block<'a> {\n+pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef,\n+                                          content_ty: ty::t) -> Block<'blk, 'tcx> {\n     assert!(ty::type_is_sized(bcx.ccx().tcx(), content_ty));\n     let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n     let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n@@ -84,8 +86,8 @@ pub fn trans_exchange_free_ty<'a>(bcx: &'a Block<'a>, ptr: ValueRef,\n     }\n }\n \n-pub fn take_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n-               -> &'a Block<'a> {\n+pub fn take_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v: ValueRef, t: ty::t)\n+                           -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"take_ty\");\n     match ty::get(t).sty {\n@@ -123,8 +125,8 @@ pub fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n     }\n }\n \n-pub fn drop_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n-               -> &'a Block<'a> {\n+pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v: ValueRef, t: ty::t)\n+                           -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"drop_ty(t={})\", t.repr(bcx.tcx()));\n     let _icx = push_ctxt(\"drop_ty\");\n@@ -142,8 +144,8 @@ pub fn drop_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     bcx\n }\n \n-pub fn drop_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n-                         -> &'a Block<'a> {\n+pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v: ValueRef, t: ty::t)\n+                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n     Store(bcx, v, vp);\n@@ -232,7 +234,7 @@ pub fn lazily_emit_visit_glue(ccx: &CrateContext, ti: &tydesc_info) -> ValueRef\n }\n \n // See [Note-arg-mode]\n-pub fn call_visit_glue(bcx: &Block, v: ValueRef, tydesc: ValueRef) {\n+pub fn call_visit_glue(bcx: Block, v: ValueRef, tydesc: ValueRef) {\n     let _icx = push_ctxt(\"call_visit_glue\");\n \n     // Select the glue function to call from the tydesc\n@@ -242,8 +244,8 @@ pub fn call_visit_glue(bcx: &Block, v: ValueRef, tydesc: ValueRef) {\n     Call(bcx, llfn, [llrawptr], None);\n }\n \n-fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n-                   -> &'a Block<'a> {\n+fn make_visit_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v: ValueRef, t: ty::t)\n+                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n     let (visitor_trait, object_ty) = match ty::visitor_object_ty(bcx.tcx(),\n@@ -259,13 +261,13 @@ fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     bcx\n }\n \n-fn trans_struct_drop_flag<'a>(mut bcx: &'a Block<'a>,\n-                              t: ty::t,\n-                              v0: ValueRef,\n-                              dtor_did: ast::DefId,\n-                              class_did: ast::DefId,\n-                              substs: &subst::Substs)\n-                              -> &'a Block<'a> {\n+fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                      t: ty::t,\n+                                      v0: ValueRef,\n+                                      dtor_did: ast::DefId,\n+                                      class_did: ast::DefId,\n+                                      substs: &subst::Substs)\n+                                      -> Block<'blk, 'tcx> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let struct_data = if ty::type_is_sized(bcx.tcx(), t) {\n         v0\n@@ -279,13 +281,13 @@ fn trans_struct_drop_flag<'a>(mut bcx: &'a Block<'a>,\n     })\n }\n \n-fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n-                         t: ty::t,\n-                         v0: ValueRef,\n-                         dtor_did: ast::DefId,\n-                         class_did: ast::DefId,\n-                         substs: &subst::Substs)\n-                         -> &'a Block<'a> {\n+fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 t: ty::t,\n+                                 v0: ValueRef,\n+                                 dtor_did: ast::DefId,\n+                                 class_did: ast::DefId,\n+                                 substs: &subst::Substs)\n+                                 -> Block<'blk, 'tcx> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n \n     // Find and call the actual destructor\n@@ -371,7 +373,7 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n     })\n }\n \n-fn size_and_align_of_dst<'a>(bcx: &'a Block<'a>, t :ty::t, info: ValueRef) -> (ValueRef, ValueRef) {\n+fn size_and_align_of_dst(bcx: Block, t :ty::t, info: ValueRef) -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {}\",\n            bcx.ty_to_string(t), bcx.val_to_string(info));\n     if ty::type_is_sized(bcx.tcx(), t) {\n@@ -426,7 +428,8 @@ fn size_and_align_of_dst<'a>(bcx: &'a Block<'a>, t :ty::t, info: ValueRef) -> (V\n     }\n }\n \n-fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'a> {\n+fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: ty::t)\n+                              -> Block<'blk, 'tcx> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n     match ty::get(t).sty {\n@@ -549,9 +552,9 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n     }\n }\n \n-fn decr_refcnt_maybe_free<'a>(bcx: &'a Block<'a>,\n-                              box_ptr_ptr: ValueRef,\n-                              t: ty::t) -> &'a Block<'a> {\n+fn decr_refcnt_maybe_free<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      box_ptr_ptr: ValueRef,\n+                                      t: ty::t) -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"decr_refcnt_maybe_free\");\n     let fcx = bcx.fcx;\n     let ccx = bcx.ccx();\n@@ -578,8 +581,8 @@ fn decr_refcnt_maybe_free<'a>(bcx: &'a Block<'a>,\n     next_bcx\n }\n \n-fn incr_refcnt_of_boxed<'a>(bcx: &'a Block<'a>,\n-                            box_ptr_ptr: ValueRef) -> &'a Block<'a> {\n+fn incr_refcnt_of_boxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    box_ptr_ptr: ValueRef) -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = bcx.ccx();\n     let box_ptr = Load(bcx, box_ptr_ptr);\n@@ -645,8 +648,8 @@ fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n fn make_generic_glue(ccx: &CrateContext,\n                      t: ty::t,\n                      llfn: ValueRef,\n-                     helper: <'a> |&'a Block<'a>, ValueRef, ty::t|\n-                                  -> &'a Block<'a>,\n+                     helper: <'blk, 'tcx> |Block<'blk, 'tcx>, ValueRef, ty::t|\n+                                           -> Block<'blk, 'tcx>,\n                      name: &str)\n                      -> ValueRef {\n     let _icx = push_ctxt(\"make_generic_glue\");"}, {"sha": "36184b2eed37e3156a10f7ce5f677ad2e4340bbf", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -134,10 +134,11 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n     ccx.sess().abort_if_errors();\n }\n \n-pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n-                                callee_ty: ty::t, cleanup_scope: cleanup::CustomScopeIndex,\n-                                args: callee::CallArgs, dest: expr::Dest,\n-                                substs: subst::Substs, call_info: NodeInfo) -> Result<'a> {\n+pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::NodeId,\n+                                        callee_ty: ty::t, cleanup_scope: cleanup::CustomScopeIndex,\n+                                        args: callee::CallArgs, dest: expr::Dest,\n+                                        substs: subst::Substs, call_info: NodeInfo)\n+                                        -> Result<'blk, 'tcx> {\n \n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n@@ -548,7 +549,7 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n     Result::new(bcx, llresult)\n }\n \n-fn copy_intrinsic(bcx: &Block, allow_overlap: bool, volatile: bool,\n+fn copy_intrinsic(bcx: Block, allow_overlap: bool, volatile: bool,\n                   tp_ty: ty::t, dst: ValueRef, src: ValueRef, count: ValueRef) -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n@@ -577,7 +578,7 @@ fn copy_intrinsic(bcx: &Block, allow_overlap: bool, volatile: bool,\n                      C_bool(ccx, volatile)], None)\n }\n \n-fn memset_intrinsic(bcx: &Block, volatile: bool, tp_ty: ty::t,\n+fn memset_intrinsic(bcx: Block, volatile: bool, tp_ty: ty::t,\n                     dst: ValueRef, val: ValueRef, count: ValueRef) -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n@@ -596,13 +597,13 @@ fn memset_intrinsic(bcx: &Block, volatile: bool, tp_ty: ty::t,\n                      C_bool(ccx, volatile)], None)\n }\n \n-fn count_zeros_intrinsic(bcx: &Block, name: &'static str, val: ValueRef) -> ValueRef {\n+fn count_zeros_intrinsic(bcx: Block, name: &'static str, val: ValueRef) -> ValueRef {\n     let y = C_bool(bcx.ccx(), false);\n     let llfn = bcx.ccx().get_intrinsic(&name);\n     Call(bcx, llfn, [val, y], None)\n }\n \n-fn with_overflow_intrinsic(bcx: &Block, name: &'static str, t: ty::t,\n+fn with_overflow_intrinsic(bcx: Block, name: &'static str, t: ty::t,\n                            a: ValueRef, b: ValueRef) -> ValueRef {\n     let llfn = bcx.ccx().get_intrinsic(&name);\n "}, {"sha": "fb1a764f0fce51eefb7051e7eeeac44cf3791017", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -102,12 +102,11 @@ pub fn trans_impl(ccx: &CrateContext,\n     }\n }\n \n-pub fn trans_method_callee<'a>(\n-                           bcx: &'a Block<'a>,\n-                           method_call: MethodCall,\n-                           self_expr: Option<&ast::Expr>,\n-                           arg_cleanup_scope: cleanup::ScopeId)\n-                           -> Callee<'a> {\n+pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       method_call: MethodCall,\n+                                       self_expr: Option<&ast::Expr>,\n+                                       arg_cleanup_scope: cleanup::ScopeId)\n+                                       -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_method_callee\");\n \n     let (origin, method_ty) = match bcx.tcx().method_map\n@@ -166,7 +165,7 @@ pub fn trans_method_callee<'a>(\n     }\n }\n \n-pub fn trans_static_method_callee(bcx: &Block,\n+pub fn trans_static_method_callee(bcx: Block,\n                                   method_id: ast::DefId,\n                                   trait_id: ast::DefId,\n                                   expr_id: ast::NodeId)\n@@ -262,13 +261,12 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n     meth_did.def_id()\n }\n \n-fn trans_monomorphized_callee<'a>(\n-                              bcx: &'a Block<'a>,\n-                              method_call: MethodCall,\n-                              trait_id: ast::DefId,\n-                              n_method: uint,\n-                              vtbl: typeck::vtable_origin)\n-                              -> Callee<'a> {\n+fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          method_call: MethodCall,\n+                                          trait_id: ast::DefId,\n+                                          n_method: uint,\n+                                          vtbl: typeck::vtable_origin)\n+                                          -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n     match vtbl {\n       typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n@@ -324,7 +322,7 @@ fn trans_monomorphized_callee<'a>(\n     }\n }\n \n-fn combine_impl_and_methods_tps(bcx: &Block,\n+fn combine_impl_and_methods_tps(bcx: Block,\n                                 node: ExprOrMethodCall,\n                                 rcvr_substs: subst::Substs,\n                                 rcvr_origins: typeck::vtable_res)\n@@ -378,12 +376,12 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n     (ty_substs, vtables)\n }\n \n-fn trans_trait_callee<'a>(bcx: &'a Block<'a>,\n-                          method_ty: ty::t,\n-                          n_method: uint,\n-                          self_expr: &ast::Expr,\n-                          arg_cleanup_scope: cleanup::ScopeId)\n-                          -> Callee<'a> {\n+fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  method_ty: ty::t,\n+                                  n_method: uint,\n+                                  self_expr: &ast::Expr,\n+                                  arg_cleanup_scope: cleanup::ScopeId)\n+                                  -> Callee<'blk, 'tcx> {\n     /*!\n      * Create a method callee where the method is coming from a trait\n      * object (e.g., Box<Trait> type).  In this case, we must pull the fn\n@@ -422,11 +420,11 @@ fn trans_trait_callee<'a>(bcx: &'a Block<'a>,\n     trans_trait_callee_from_llval(bcx, method_ty, n_method, llval)\n }\n \n-pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n-                                         callee_ty: ty::t,\n-                                         n_method: uint,\n-                                         llpair: ValueRef)\n-                                         -> Callee<'a> {\n+pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                                 callee_ty: ty::t,\n+                                                 n_method: uint,\n+                                                 llpair: ValueRef)\n+                                                 -> Callee<'blk, 'tcx> {\n     /*!\n      * Same as `trans_trait_callee()` above, except that it is given\n      * a by-ref pointer to the object pair.\n@@ -476,7 +474,7 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n /// Creates the self type and (fake) callee substitutions for an unboxed\n /// closure with the given def ID. The static region and type parameters are\n /// lies, but we're in trans so it doesn't matter.\n-fn get_callee_substitutions_for_unboxed_closure(bcx: &Block,\n+fn get_callee_substitutions_for_unboxed_closure(bcx: Block,\n                                                 def_id: ast::DefId)\n                                                 -> subst::Substs {\n     let self_ty = ty::mk_unboxed_closure(bcx.tcx(), def_id, ty::ReStatic);\n@@ -495,7 +493,7 @@ fn get_callee_substitutions_for_unboxed_closure(bcx: &Block,\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n-fn get_vtable(bcx: &Block,\n+fn get_vtable(bcx: Block,\n               self_ty: ty::t,\n               origins: typeck::vtable_param_res)\n               -> ValueRef\n@@ -630,7 +628,7 @@ pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n     }\n }\n \n-fn emit_vtable_methods(bcx: &Block,\n+fn emit_vtable_methods(bcx: Block,\n                        impl_id: ast::DefId,\n                        substs: subst::Substs,\n                        vtables: typeck::vtable_res)\n@@ -686,9 +684,9 @@ fn emit_vtable_methods(bcx: &Block,\n     }).collect()\n }\n \n-pub fn vtable_ptr<'a>(bcx: &'a Block<'a>,\n-                      id: ast::NodeId,\n-                      self_ty: ty::t) -> ValueRef {\n+pub fn vtable_ptr(bcx: Block,\n+                  id: ast::NodeId,\n+                  self_ty: ty::t) -> ValueRef {\n     let ccx = bcx.ccx();\n     let origins = {\n         let vtable_map = ccx.tcx().vtable_map.borrow();\n@@ -706,11 +704,11 @@ pub fn vtable_ptr<'a>(bcx: &'a Block<'a>,\n     get_vtable(bcx, self_ty, origins)\n }\n \n-pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n-                            datum: Datum<Expr>,\n-                            id: ast::NodeId,\n-                            dest: expr::Dest)\n-                            -> &'a Block<'a> {\n+pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    datum: Datum<Expr>,\n+                                    id: ast::NodeId,\n+                                    dest: expr::Dest)\n+                                    -> Block<'blk, 'tcx> {\n     /*!\n      * Generates the code to convert from a pointer (`Box<T>`, `&T`, etc)\n      * into an object (`Box<Trait>`, `&Trait`, etc). This means creating a"}, {"sha": "214726edd778d0c14a40c1bee9050d22f78f5101", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -33,15 +33,15 @@ use syntax::ast_map;\n use syntax::parse::token::{InternedString, special_idents};\n use syntax::parse::token;\n \n-pub struct Reflector<'a, 'b> {\n+pub struct Reflector<'a, 'blk, 'tcx: 'blk> {\n     visitor_val: ValueRef,\n     visitor_items: &'a [ty::ImplOrTraitItem],\n-    final_bcx: &'b Block<'b>,\n+    final_bcx: Block<'blk, 'tcx>,\n     tydesc_ty: Type,\n-    bcx: &'b Block<'b>\n+    bcx: Block<'blk, 'tcx>\n }\n \n-impl<'a, 'b> Reflector<'a, 'b> {\n+impl<'a, 'blk, 'tcx> Reflector<'a, 'blk, 'tcx> {\n     pub fn c_uint(&mut self, u: uint) -> ValueRef {\n         C_uint(self.bcx.ccx(), u)\n     }\n@@ -419,12 +419,11 @@ impl<'a, 'b> Reflector<'a, 'b> {\n }\n \n // Emit a sequence of calls to visit_ty::visit_foo\n-pub fn emit_calls_to_trait_visit_ty<'a>(\n-                                    bcx: &'a Block<'a>,\n-                                    t: ty::t,\n-                                    visitor_val: ValueRef,\n-                                    visitor_trait_id: DefId)\n-                                    -> &'a Block<'a> {\n+pub fn emit_calls_to_trait_visit_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                                t: ty::t,\n+                                                visitor_val: ValueRef,\n+                                                visitor_trait_id: DefId)\n+                                                -> Block<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n     let final = fcx.new_temp_block(\"final\");\n     let tydesc_ty = ty::get_tydesc_ty(bcx.tcx()).unwrap();"}, {"sha": "00b9977c7523ce46a47c750bfd5234a4bf47e4c6", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 52, "deletions": 60, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -35,29 +35,28 @@ use util::ppaux::ty_to_string;\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n-fn get_len(bcx: &Block, vptr: ValueRef) -> ValueRef {\n+fn get_len(bcx: Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_lenl\");\n     Load(bcx, expr::get_len(bcx, vptr))\n }\n \n-fn get_dataptr(bcx: &Block, vptr: ValueRef) -> ValueRef {\n+fn get_dataptr(bcx: Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_dataptr\");\n     Load(bcx, expr::get_dataptr(bcx, vptr))\n }\n \n-pub fn pointer_add_byte(bcx: &Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n+pub fn pointer_add_byte(bcx: Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::pointer_add_byte\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, Type::i8p(bcx.ccx()));\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n-pub fn make_drop_glue_unboxed<'a>(\n-                              bcx: &'a Block<'a>,\n-                              vptr: ValueRef,\n-                              unit_ty: ty::t,\n-                              should_deallocate: bool)\n-                              -> &'a Block<'a> {\n+pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          vptr: ValueRef,\n+                                          unit_ty: ty::t,\n+                                          should_deallocate: bool)\n+                                          -> Block<'blk, 'tcx> {\n     let not_null = IsNotNull(bcx, vptr);\n     with_cond(bcx, not_null, |bcx| {\n         let ccx = bcx.ccx();\n@@ -105,11 +104,10 @@ impl VecTypes {\n     }\n }\n \n-pub fn trans_fixed_vstore<'a>(\n-                          bcx: &'a Block<'a>,\n-                          expr: &ast::Expr,\n-                          dest: expr::Dest)\n-                          -> &'a Block<'a> {\n+pub fn trans_fixed_vstore<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      expr: &ast::Expr,\n+                                      dest: expr::Dest)\n+                                      -> Block<'blk, 'tcx> {\n     //!\n     //\n     // [...] allocates a fixed-size array and moves it around \"by value\".\n@@ -133,10 +131,10 @@ pub fn trans_fixed_vstore<'a>(\n     };\n }\n \n-pub fn trans_slice_vec<'a>(bcx: &'a Block<'a>,\n-                           slice_expr: &ast::Expr,\n-                           content_expr: &ast::Expr)\n-                           -> DatumBlock<'a, Expr> {\n+pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   slice_expr: &ast::Expr,\n+                                   content_expr: &ast::Expr)\n+                                   -> DatumBlock<'blk, 'tcx, Expr> {\n     /*!\n      * &[...] allocates memory on the stack and writes the values into it,\n      * returning the vector (the caller must make the reference).  \"...\" is\n@@ -207,12 +205,11 @@ pub fn trans_slice_vec<'a>(bcx: &'a Block<'a>,\n     immediate_rvalue_bcx(bcx, llfixed, vec_ty).to_expr_datumblock()\n }\n \n-pub fn trans_lit_str<'a>(\n-                     bcx: &'a Block<'a>,\n-                     lit_expr: &ast::Expr,\n-                     str_lit: InternedString,\n-                     dest: Dest)\n-                     -> &'a Block<'a> {\n+pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 lit_expr: &ast::Expr,\n+                                 str_lit: InternedString,\n+                                 dest: Dest)\n+                                 -> Block<'blk, 'tcx> {\n     /*!\n      * Literal strings translate to slices into static memory.  This is\n      * different from trans_slice_vstore() above because it doesn't need to copy\n@@ -239,10 +236,10 @@ pub fn trans_lit_str<'a>(\n     }\n }\n \n-pub fn trans_uniq_vec<'a>(bcx: &'a Block<'a>,\n-                          uniq_expr: &ast::Expr,\n-                          content_expr: &ast::Expr)\n-                          -> DatumBlock<'a, Expr> {\n+pub fn trans_uniq_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  uniq_expr: &ast::Expr,\n+                                  content_expr: &ast::Expr)\n+                                  -> DatumBlock<'blk, 'tcx, Expr> {\n     /*!\n      * Box<[...]> and \"...\".to_string() allocate boxes in the exchange heap and write\n      * the array elements into them.\n@@ -327,13 +324,12 @@ pub fn trans_uniq_vec<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-pub fn write_content<'a>(\n-                     bcx: &'a Block<'a>,\n-                     vt: &VecTypes,\n-                     vstore_expr: &ast::Expr,\n-                     content_expr: &ast::Expr,\n-                     dest: Dest)\n-                     -> &'a Block<'a> {\n+pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 vt: &VecTypes,\n+                                 vstore_expr: &ast::Expr,\n+                                 content_expr: &ast::Expr,\n+                                 dest: Dest)\n+                                 -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"tvec::write_content\");\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n@@ -429,12 +425,12 @@ pub fn write_content<'a>(\n     }\n }\n \n-pub fn vec_types_from_expr(bcx: &Block, vec_expr: &ast::Expr) -> VecTypes {\n+pub fn vec_types_from_expr(bcx: Block, vec_expr: &ast::Expr) -> VecTypes {\n     let vec_ty = node_id_type(bcx, vec_expr.id);\n     vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty))\n }\n \n-pub fn vec_types(bcx: &Block, unit_ty: ty::t) -> VecTypes {\n+pub fn vec_types(bcx: Block, unit_ty: ty::t) -> VecTypes {\n     let ccx = bcx.ccx();\n     let llunit_ty = type_of::type_of(ccx, unit_ty);\n     let llunit_size = nonzero_llsize_of(ccx, llunit_ty);\n@@ -448,7 +444,7 @@ pub fn vec_types(bcx: &Block, unit_ty: ty::t) -> VecTypes {\n     }\n }\n \n-pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n+pub fn elements_required(bcx: Block, content_expr: &ast::Expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n@@ -470,7 +466,7 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n     }\n }\n \n-pub fn get_fixed_base_and_len(bcx: &Block,\n+pub fn get_fixed_base_and_len(bcx: Block,\n                               llval: ValueRef,\n                               vec_length: uint)\n                               -> (ValueRef, ValueRef) {\n@@ -486,15 +482,15 @@ pub fn get_fixed_base_and_len(bcx: &Block,\n     (base, len)\n }\n \n-fn get_slice_base_and_len(bcx: &Block,\n+fn get_slice_base_and_len(bcx: Block,\n                           llval: ValueRef)\n                           -> (ValueRef, ValueRef) {\n     let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n     let len = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n     (base, len)\n }\n \n-pub fn get_base_and_len(bcx: &Block,\n+pub fn get_base_and_len(bcx: Block,\n                         llval: ValueRef,\n                         vec_ty: ty::t)\n                         -> (ValueRef, ValueRef) {\n@@ -528,17 +524,15 @@ pub fn get_base_and_len(bcx: &Block,\n     }\n }\n \n-pub type iter_vec_block<'r,'b> =\n-    |&'b Block<'b>, ValueRef, ty::t|: 'r -> &'b Block<'b>;\n-\n-pub fn iter_vec_loop<'r,\n-                     'b>(\n-                     bcx: &'b Block<'b>,\n-                     data_ptr: ValueRef,\n-                     vt: &VecTypes,\n-                     count: ValueRef,\n-                     f: iter_vec_block<'r,'b>)\n-                     -> &'b Block<'b> {\n+pub type iter_vec_block<'a, 'blk, 'tcx> =\n+    |Block<'blk, 'tcx>, ValueRef, ty::t|: 'a -> Block<'blk, 'tcx>;\n+\n+pub fn iter_vec_loop<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     data_ptr: ValueRef,\n+                                     vt: &VecTypes,\n+                                     count: ValueRef,\n+                                     f: iter_vec_block<'a, 'blk, 'tcx>)\n+                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"tvec::iter_vec_loop\");\n     let fcx = bcx.fcx;\n \n@@ -589,14 +583,12 @@ pub fn iter_vec_loop<'r,\n     next_bcx\n }\n \n-pub fn iter_vec_raw<'r,\n-                    'b>(\n-                    bcx: &'b Block<'b>,\n-                    data_ptr: ValueRef,\n-                    unit_ty: ty::t,\n-                    len: ValueRef,\n-                    f: iter_vec_block<'r,'b>)\n-                    -> &'b Block<'b> {\n+pub fn iter_vec_raw<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    data_ptr: ValueRef,\n+                                    unit_ty: ty::t,\n+                                    len: ValueRef,\n+                                    f: iter_vec_block<'a, 'blk, 'tcx>)\n+                                    -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"tvec::iter_vec_raw\");\n     let fcx = bcx.fcx;\n "}, {"sha": "dfa4ae6b285c87786236cdef19f0156077611093", "filename": "src/librustc/middle/trans/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -55,7 +55,7 @@ impl Value {\n     /// This only performs a search for a trivially dominating store. The store\n     /// must be the only user of this value, and there must not be any conditional\n     /// branches between the store and the given block.\n-    pub fn get_dominating_store(self, bcx: &Block) -> Option<Value> {\n+    pub fn get_dominating_store(self, bcx: Block) -> Option<Value> {\n         match self.get_single_user().and_then(|user| user.as_store_inst()) {\n             Some(store) => {\n                 store.get_parent().and_then(|store_bb| {"}, {"sha": "feed76233d68aaf1b2e384e85d1a2d62119c37c1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 60, "deletions": 70, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -50,6 +50,7 @@ use std::mem;\n use std::ops;\n use std::rc::Rc;\n use std::collections::{HashMap, HashSet};\n+use arena::TypedArena;\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, FnStyle, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n@@ -418,10 +419,13 @@ pub struct TransmuteRestriction {\n /// The data structure to keep track of all the information that typechecker\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n-pub struct ctxt {\n+pub struct ctxt<'tcx> {\n+    /// The arena that types are allocated from.\n+    type_arena: &'tcx TypedArena<t_box_>,\n+\n     /// Specifically use a speedy hash algorithm for this hash map, it's used\n     /// quite often.\n-    pub interner: RefCell<FnvHashMap<intern_key, Box<t_box_>>>,\n+    interner: RefCell<FnvHashMap<intern_key, &'tcx t_box_>>,\n     pub next_id: Cell<uint>,\n     pub sess: Session,\n     pub def_map: resolve::DefMap,\n@@ -1373,21 +1377,22 @@ impl UnboxedClosureKind {\n     }\n }\n \n-pub fn mk_ctxt(s: Session,\n-               dm: resolve::DefMap,\n-               named_region_map: resolve_lifetime::NamedRegionMap,\n-               map: ast_map::Map,\n-               freevars: freevars::freevar_map,\n-               capture_modes: freevars::CaptureModeMap,\n-               region_maps: middle::region::RegionMaps,\n-               lang_items: middle::lang_items::LanguageItems,\n-               stability: stability::Index)\n-               -> ctxt {\n+pub fn mk_ctxt<'tcx>(s: Session,\n+                     type_arena: &'tcx TypedArena<t_box_>,\n+                     dm: resolve::DefMap,\n+                     named_region_map: resolve_lifetime::NamedRegionMap,\n+                     map: ast_map::Map,\n+                     freevars: freevars::freevar_map,\n+                     capture_modes: freevars::CaptureModeMap,\n+                     region_maps: middle::region::RegionMaps,\n+                     lang_items: middle::lang_items::LanguageItems,\n+                     stability: stability::Index) -> ctxt<'tcx> {\n     ctxt {\n+        type_arena: type_arena,\n+        interner: RefCell::new(FnvHashMap::new()),\n         named_region_map: named_region_map,\n         item_variance_map: RefCell::new(DefIdMap::new()),\n         variance_computed: Cell::new(false),\n-        interner: RefCell::new(FnvHashMap::new()),\n         next_id: Cell::new(primitives::LAST_PRIMITIVE_ID),\n         sess: s,\n         def_map: dm,\n@@ -1554,11 +1559,11 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       }\n     }\n \n-    let t = box t_box_ {\n+    let t = cx.type_arena.alloc(t_box_ {\n         sty: st,\n         id: cx.next_id.get(),\n         flags: flags,\n-    };\n+    });\n \n     let sty_ptr = &t.sty as *const sty;\n \n@@ -3463,10 +3468,10 @@ impl AutoRef {\n     }\n }\n \n-pub fn method_call_type_param_defs<T>(typer: &T,\n-                                      origin: typeck::MethodOrigin)\n-                                      -> VecPerParamSpace<TypeParameterDef>\n-                                      where T: mc::Typer {\n+pub fn method_call_type_param_defs<'tcx, T>(typer: &T,\n+                                            origin: typeck::MethodOrigin)\n+                                            -> VecPerParamSpace<TypeParameterDef>\n+                                            where T: mc::Typer<'tcx> {\n     match origin {\n         typeck::MethodStatic(did) => {\n             ty::lookup_item_type(typer.tcx(), did).generics.types.clone()\n@@ -4655,10 +4660,10 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n     let u = TypeNormalizer(cx).fold_ty(t);\n     return u;\n \n-    struct TypeNormalizer<'a>(&'a ctxt);\n+    struct TypeNormalizer<'a, 'tcx: 'a>(&'a ctxt<'tcx>);\n \n-    impl<'a> TypeFolder for TypeNormalizer<'a> {\n-        fn tcx<'a>(&'a self) -> &'a ctxt { let TypeNormalizer(c) = *self; c }\n+    impl<'a, 'tcx> TypeFolder<'tcx> for TypeNormalizer<'a, 'tcx> {\n+        fn tcx<'a>(&'a self) -> &'a ctxt<'tcx> { let TypeNormalizer(c) = *self; c }\n \n         fn fold_ty(&mut self, t: ty::t) -> ty::t {\n             match self.tcx().normalized_cache.borrow().find_copy(&t) {\n@@ -4697,70 +4702,55 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n     }\n }\n \n-pub trait ExprTyProvider {\n-    fn expr_ty(&self, ex: &ast::Expr) -> t;\n-    fn ty_ctxt<'a>(&'a self) -> &'a ctxt;\n-}\n-\n-impl ExprTyProvider for ctxt {\n-    fn expr_ty(&self, ex: &ast::Expr) -> t {\n-        expr_ty(self, ex)\n-    }\n-\n-    fn ty_ctxt<'a>(&'a self) -> &'a ctxt {\n-        self\n-    }\n-}\n-\n // Returns the repeat count for a repeating vector expression.\n-pub fn eval_repeat_count<T: ExprTyProvider>(tcx: &T, count_expr: &ast::Expr) -> uint {\n+pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n     match const_eval::eval_const_expr_partial(tcx, count_expr) {\n       Ok(ref const_val) => match *const_val {\n         const_eval::const_int(count) => if count < 0 {\n-            tcx.ty_ctxt().sess.span_err(count_expr.span,\n-                                        \"expected positive integer for \\\n-                                         repeat count, found negative integer\");\n-            return 0;\n+            tcx.sess.span_err(count_expr.span,\n+                              \"expected positive integer for \\\n+                               repeat count, found negative integer\");\n+            0\n         } else {\n-            return count as uint\n+            count as uint\n         },\n-        const_eval::const_uint(count) => return count as uint,\n+        const_eval::const_uint(count) => count as uint,\n         const_eval::const_float(count) => {\n-            tcx.ty_ctxt().sess.span_err(count_expr.span,\n-                                        \"expected positive integer for \\\n-                                         repeat count, found float\");\n-            return count as uint;\n+            tcx.sess.span_err(count_expr.span,\n+                              \"expected positive integer for \\\n+                               repeat count, found float\");\n+            count as uint\n         }\n         const_eval::const_str(_) => {\n-            tcx.ty_ctxt().sess.span_err(count_expr.span,\n-                                        \"expected positive integer for \\\n-                                         repeat count, found string\");\n-            return 0;\n+            tcx.sess.span_err(count_expr.span,\n+                              \"expected positive integer for \\\n+                               repeat count, found string\");\n+            0\n         }\n         const_eval::const_bool(_) => {\n-            tcx.ty_ctxt().sess.span_err(count_expr.span,\n-                                        \"expected positive integer for \\\n-                                         repeat count, found boolean\");\n-            return 0;\n+            tcx.sess.span_err(count_expr.span,\n+                              \"expected positive integer for \\\n+                               repeat count, found boolean\");\n+            0\n         }\n         const_eval::const_binary(_) => {\n-            tcx.ty_ctxt().sess.span_err(count_expr.span,\n-                                        \"expected positive integer for \\\n-                                         repeat count, found binary array\");\n-            return 0;\n+            tcx.sess.span_err(count_expr.span,\n+                              \"expected positive integer for \\\n+                               repeat count, found binary array\");\n+            0\n         }\n         const_eval::const_nil => {\n-            tcx.ty_ctxt().sess.span_err(count_expr.span,\n-                                        \"expected positive integer for \\\n-                                         repeat count, found ()\");\n-            return 0;\n+            tcx.sess.span_err(count_expr.span,\n+                              \"expected positive integer for \\\n+                               repeat count, found ()\");\n+            0\n         }\n       },\n       Err(..) => {\n-        tcx.ty_ctxt().sess.span_err(count_expr.span,\n-                                    \"expected constant integer for repeat count, \\\n-                                     found variable\");\n-        return 0;\n+        tcx.sess.span_err(count_expr.span,\n+                          \"expected constant integer for repeat count, \\\n+                           found variable\");\n+        0\n       }\n     }\n }\n@@ -5397,8 +5387,8 @@ impl BorrowKind {\n     }\n }\n \n-impl mc::Typer for ty::ctxt {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self\n     }\n "}, {"sha": "bc53568694df632c4fbf1bee8f5711363df34346", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 75, "deletions": 77, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -25,16 +25,16 @@ use util::ppaux::Repr;\n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n pub trait TypeFoldable {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> Self;\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n }\n \n /// The TypeFolder trait defines the actual *folding*. There is a\n /// method defined for every foldable type. Each of these has a\n /// default implementation that does an \"identity\" fold. Within each\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n /// sub-item.\n-pub trait TypeFolder {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n+pub trait TypeFolder<'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n \n     fn fold_ty(&mut self, t: ty::t) -> ty::t {\n         super_fold_ty(self, t)\n@@ -111,111 +111,111 @@ pub trait TypeFolder {\n // needed.\n \n impl<T:TypeFoldable> TypeFoldable for Option<T> {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> Option<T> {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Option<T> {\n         self.as_ref().map(|t| t.fold_with(folder))\n     }\n }\n \n impl<T:TypeFoldable> TypeFoldable for Rc<T> {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> Rc<T> {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n         Rc::new((**self).fold_with(folder))\n     }\n }\n \n impl<T:TypeFoldable> TypeFoldable for Vec<T> {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> Vec<T> {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Vec<T> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n }\n \n impl<T:TypeFoldable> TypeFoldable for OwnedSlice<T> {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> OwnedSlice<T> {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> OwnedSlice<T> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n }\n \n impl<T:TypeFoldable> TypeFoldable for VecPerParamSpace<T> {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> VecPerParamSpace<T> {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> VecPerParamSpace<T> {\n         self.map(|t| t.fold_with(folder))\n     }\n }\n \n impl TypeFoldable for ty::TraitStore {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::TraitStore {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitStore {\n         folder.fold_trait_store(*self)\n     }\n }\n \n impl TypeFoldable for ty::t {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::t {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::t {\n         folder.fold_ty(*self)\n     }\n }\n \n impl TypeFoldable for ty::BareFnTy {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::BareFnTy {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::BareFnTy {\n         folder.fold_bare_fn_ty(self)\n     }\n }\n \n impl TypeFoldable for ty::ClosureTy {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::ClosureTy {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureTy {\n         folder.fold_closure_ty(self)\n     }\n }\n \n impl TypeFoldable for ty::mt {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::mt {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::mt {\n         folder.fold_mt(self)\n     }\n }\n \n impl TypeFoldable for ty::FnSig {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::FnSig {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig {\n         folder.fold_sig(self)\n     }\n }\n \n impl TypeFoldable for ty::sty {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::sty {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::sty {\n         folder.fold_sty(self)\n     }\n }\n \n impl TypeFoldable for ty::TraitRef {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::TraitRef {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef {\n         folder.fold_trait_ref(self)\n     }\n }\n \n impl TypeFoldable for ty::Region {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::Region {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Region {\n         folder.fold_region(*self)\n     }\n }\n \n impl TypeFoldable for subst::Substs {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> subst::Substs {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> subst::Substs {\n         folder.fold_substs(self)\n     }\n }\n \n impl TypeFoldable for ty::ItemSubsts {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::ItemSubsts {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ItemSubsts {\n         ty::ItemSubsts {\n             substs: self.substs.fold_with(folder),\n         }\n     }\n }\n \n impl TypeFoldable for ty::AutoRef {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::AutoRef {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::AutoRef {\n         folder.fold_autoref(self)\n     }\n }\n \n impl TypeFoldable for typeck::vtable_origin {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> typeck::vtable_origin {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> typeck::vtable_origin {\n         match *self {\n             typeck::vtable_static(def_id, ref substs, ref origins) => {\n                 let r_substs = substs.fold_with(folder);\n@@ -236,19 +236,19 @@ impl TypeFoldable for typeck::vtable_origin {\n }\n \n impl TypeFoldable for ty::BuiltinBounds {\n-    fn fold_with<F:TypeFolder>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n         *self\n     }\n }\n \n impl TypeFoldable for ty::ExistentialBounds {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::ExistentialBounds {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ExistentialBounds {\n         folder.fold_existential_bounds(*self)\n     }\n }\n \n impl TypeFoldable for ty::ParamBounds {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::ParamBounds {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ParamBounds {\n         ty::ParamBounds {\n             opt_region_bound: self.opt_region_bound.fold_with(folder),\n             builtin_bounds: self.builtin_bounds.fold_with(folder),\n@@ -258,7 +258,7 @@ impl TypeFoldable for ty::ParamBounds {\n }\n \n impl TypeFoldable for ty::TypeParameterDef {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::TypeParameterDef {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeParameterDef {\n         ty::TypeParameterDef {\n             ident: self.ident,\n             def_id: self.def_id,\n@@ -271,7 +271,7 @@ impl TypeFoldable for ty::TypeParameterDef {\n }\n \n impl TypeFoldable for ty::RegionParameterDef {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::RegionParameterDef {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::RegionParameterDef {\n         ty::RegionParameterDef {\n             name: self.name,\n             def_id: self.def_id,\n@@ -283,7 +283,7 @@ impl TypeFoldable for ty::RegionParameterDef {\n }\n \n impl TypeFoldable for ty::Generics {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::Generics {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Generics {\n         ty::Generics {\n             types: self.types.fold_with(folder),\n             regions: self.regions.fold_with(folder),\n@@ -292,7 +292,7 @@ impl TypeFoldable for ty::Generics {\n }\n \n impl TypeFoldable for ty::UnsizeKind {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::UnsizeKind {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::UnsizeKind {\n         match *self {\n             ty::UnsizeLength(len) => ty::UnsizeLength(len),\n             ty::UnsizeStruct(box ref k, n) => ty::UnsizeStruct(box k.fold_with(folder), n),\n@@ -307,17 +307,16 @@ impl TypeFoldable for ty::UnsizeKind {\n // \"super\" routines: these are the default implementations for TypeFolder.\n //\n // They should invoke `foo.fold_with()` to do recursive folding.\n-\n-pub fn super_fold_ty<T:TypeFolder>(this: &mut T,\n-                                   t: ty::t)\n-                                   -> ty::t {\n+pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                t: ty::t)\n+                                                -> ty::t {\n     let sty = ty::get(t).sty.fold_with(this);\n     ty::mk_t(this.tcx(), sty)\n }\n \n-pub fn super_fold_substs<T:TypeFolder>(this: &mut T,\n-                                       substs: &subst::Substs)\n-                                       -> subst::Substs {\n+pub fn super_fold_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                    substs: &subst::Substs)\n+                                                    -> subst::Substs {\n     let regions = match substs.regions {\n         subst::ErasedRegions => {\n             subst::ErasedRegions\n@@ -331,27 +330,27 @@ pub fn super_fold_substs<T:TypeFolder>(this: &mut T,\n                     types: substs.types.fold_with(this) }\n }\n \n-pub fn super_fold_sig<T:TypeFolder>(this: &mut T,\n-                                    sig: &ty::FnSig)\n-                                    -> ty::FnSig {\n+pub fn super_fold_sig<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                 sig: &ty::FnSig)\n+                                                 -> ty::FnSig {\n     ty::FnSig { binder_id: sig.binder_id,\n                 inputs: sig.inputs.fold_with(this),\n                 output: sig.output.fold_with(this),\n                 variadic: sig.variadic }\n }\n \n-pub fn super_fold_bare_fn_ty<T:TypeFolder>(this: &mut T,\n-                                           fty: &ty::BareFnTy)\n-                                           -> ty::BareFnTy\n+pub fn super_fold_bare_fn_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                        fty: &ty::BareFnTy)\n+                                                        -> ty::BareFnTy\n {\n     ty::BareFnTy { sig: fty.sig.fold_with(this),\n                    abi: fty.abi,\n                    fn_style: fty.fn_style }\n }\n \n-pub fn super_fold_closure_ty<T:TypeFolder>(this: &mut T,\n-                                           fty: &ty::ClosureTy)\n-                                           -> ty::ClosureTy\n+pub fn super_fold_closure_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                        fty: &ty::ClosureTy)\n+                                                        -> ty::ClosureTy\n {\n     ty::ClosureTy {\n         store: fty.store.fold_with(this),\n@@ -362,24 +361,23 @@ pub fn super_fold_closure_ty<T:TypeFolder>(this: &mut T,\n         abi: fty.abi,\n     }\n }\n-\n-pub fn super_fold_trait_ref<T:TypeFolder>(this: &mut T,\n-                                          t: &ty::TraitRef)\n-                                          -> ty::TraitRef {\n+pub fn super_fold_trait_ref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                       t: &ty::TraitRef)\n+                                                       -> ty::TraitRef {\n     ty::TraitRef {\n         def_id: t.def_id,\n         substs: t.substs.fold_with(this),\n     }\n }\n \n-pub fn super_fold_mt<T:TypeFolder>(this: &mut T,\n-                                   mt: &ty::mt) -> ty::mt {\n+pub fn super_fold_mt<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                mt: &ty::mt) -> ty::mt {\n     ty::mt {ty: mt.ty.fold_with(this),\n             mutbl: mt.mutbl}\n }\n \n-pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n-                                    sty: &ty::sty) -> ty::sty {\n+pub fn super_fold_sty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                 sty: &ty::sty) -> ty::sty {\n     match *sty {\n         ty::ty_box(typ) => {\n             ty::ty_box(typ.fold_with(this))\n@@ -437,9 +435,9 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n     }\n }\n \n-pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n-                                            trait_store: ty::TraitStore)\n-                                            -> ty::TraitStore {\n+pub fn super_fold_trait_store<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                         trait_store: ty::TraitStore)\n+                                                         -> ty::TraitStore {\n     match trait_store {\n         ty::UniqTraitStore => ty::UniqTraitStore,\n         ty::RegionTraitStore(r, m) => {\n@@ -448,18 +446,18 @@ pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n     }\n }\n \n-pub fn super_fold_existential_bounds<T:TypeFolder>(this: &mut T,\n-                                                   bounds: ty::ExistentialBounds)\n-                                                   -> ty::ExistentialBounds {\n+pub fn super_fold_existential_bounds<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                                bounds: ty::ExistentialBounds)\n+                                                                -> ty::ExistentialBounds {\n     ty::ExistentialBounds {\n         region_bound: bounds.region_bound.fold_with(this),\n         builtin_bounds: bounds.builtin_bounds,\n     }\n }\n \n-pub fn super_fold_autoref<T:TypeFolder>(this: &mut T,\n-                                        autoref: &ty::AutoRef)\n-                                        -> ty::AutoRef\n+pub fn super_fold_autoref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                     autoref: &ty::AutoRef)\n+                                                     -> ty::AutoRef\n {\n     match *autoref {\n         ty::AutoPtr(r, m, None) => ty::AutoPtr(this.fold_region(r), m, None),\n@@ -475,9 +473,9 @@ pub fn super_fold_autoref<T:TypeFolder>(this: &mut T,\n     }\n }\n \n-pub fn super_fold_item_substs<T:TypeFolder>(this: &mut T,\n-                                            substs: ty::ItemSubsts)\n-                                            -> ty::ItemSubsts\n+pub fn super_fold_item_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                         substs: ty::ItemSubsts)\n+                                                         -> ty::ItemSubsts\n {\n     ty::ItemSubsts {\n         substs: substs.substs.fold_with(this),\n@@ -487,13 +485,13 @@ pub fn super_fold_item_substs<T:TypeFolder>(this: &mut T,\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n-pub struct BottomUpFolder<'a> {\n-    pub tcx: &'a ty::ctxt,\n+pub struct BottomUpFolder<'a, 'tcx: 'a> {\n+    pub tcx: &'a ty::ctxt<'tcx>,\n     pub fldop: |ty::t|: 'a -> ty::t,\n }\n \n-impl<'a> TypeFolder for BottomUpFolder<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n+impl<'a, 'tcx> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n         let t1 = super_fold_ty(self, ty);\n@@ -516,18 +514,18 @@ impl<'a> TypeFolder for BottomUpFolder<'a> {\n /// (The distinction between \"free\" and \"bound\" is represented by\n /// keeping track of each `FnSig` in the lexical context of the\n /// current position of the fold.)\n-pub struct RegionFolder<'a> {\n-    tcx: &'a ty::ctxt,\n+pub struct RegionFolder<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     fld_t: |ty::t|: 'a -> ty::t,\n     fld_r: |ty::Region|: 'a -> ty::Region,\n     within_binder_ids: Vec<ast::NodeId>,\n }\n \n-impl<'a> RegionFolder<'a> {\n-    pub fn general(tcx: &'a ty::ctxt,\n+impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n+    pub fn general(tcx: &'a ty::ctxt<'tcx>,\n                    fld_r: |ty::Region|: 'a -> ty::Region,\n                    fld_t: |ty::t|: 'a -> ty::t)\n-                   -> RegionFolder<'a> {\n+                   -> RegionFolder<'a, 'tcx> {\n         RegionFolder {\n             tcx: tcx,\n             fld_t: fld_t,\n@@ -536,8 +534,8 @@ impl<'a> RegionFolder<'a> {\n         }\n     }\n \n-    pub fn regions(tcx: &'a ty::ctxt, fld_r: |ty::Region|: 'a -> ty::Region)\n-                   -> RegionFolder<'a> {\n+    pub fn regions(tcx: &'a ty::ctxt<'tcx>, fld_r: |ty::Region|: 'a -> ty::Region)\n+                   -> RegionFolder<'a, 'tcx> {\n         fn noop(t: ty::t) -> ty::t { t }\n \n         RegionFolder {\n@@ -559,8 +557,8 @@ fn opt_binder_id_of_function(t: ty::t) -> Option<ast::NodeId> {\n     }\n }\n \n-impl<'a> TypeFolder for RegionFolder<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n+impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n         debug!(\"RegionFolder.fold_ty({})\", ty.repr(self.tcx()));"}, {"sha": "f5fa6168a415cb83a8989683cf797031d6dac14a", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -71,8 +71,8 @@ use syntax::abi;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n \n-pub trait AstConv {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n+pub trait AstConv<'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n     fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype;\n     fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef>;\n \n@@ -118,7 +118,7 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n     r\n }\n \n-pub fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n+pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     default_span: Span,\n@@ -152,7 +152,7 @@ pub fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n     r\n }\n \n-fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n+fn ast_path_substs<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     decl_generics: &ty::Generics,\n@@ -271,7 +271,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     substs\n }\n \n-pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope>(\n+pub fn ast_path_to_trait_ref<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         this: &AC,\n         rscope: &RS,\n         trait_def_id: ast::DefId,\n@@ -284,7 +284,7 @@ pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope>(\n     })\n }\n \n-pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>(\n+pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     did: ast::DefId,\n@@ -307,7 +307,7 @@ pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>(\n /// and/or region variables are substituted.\n ///\n /// This is used when checking the constructor in struct literals.\n-pub fn ast_path_to_ty_relaxed<AC:AstConv,\n+pub fn ast_path_to_ty_relaxed<'tcx, AC: AstConv<'tcx>,\n                               RS:RegionScope>(\n                               this: &AC,\n                               rscope: &RS,\n@@ -412,12 +412,11 @@ pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n \n /// Converts the given AST type to a built-in type. A \"built-in type\" is, at\n /// present, either a core numeric type, a string, or `Box`.\n-pub fn ast_ty_to_builtin_ty<AC:AstConv,\n-                            RS:RegionScope>(\n-                            this: &AC,\n-                            rscope: &RS,\n-                            ast_ty: &ast::Ty)\n-                            -> Option<ty::t> {\n+pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n+        this: &AC,\n+        rscope: &RS,\n+        ast_ty: &ast::Ty)\n+        -> Option<ty::t> {\n     match ast_ty_to_prim_ty(this.tcx(), ast_ty) {\n         Some(typ) => return Some(typ),\n         None => {}\n@@ -531,7 +530,7 @@ impl PointerTy {\n     }\n }\n \n-pub fn trait_ref_for_unboxed_function<AC:AstConv,\n+pub fn trait_ref_for_unboxed_function<'tcx, AC: AstConv<'tcx>,\n                                       RS:RegionScope>(\n                                       this: &AC,\n                                       rscope: &RS,\n@@ -576,14 +575,13 @@ pub fn trait_ref_for_unboxed_function<AC:AstConv,\n // Handle `~`, `Box`, and `&` being able to mean strs and vecs.\n // If a_seq_ty is a str or a vec, make it a str/vec.\n // Also handle first-class trait types.\n-fn mk_pointer<AC:AstConv,\n-              RS:RegionScope>(\n-              this: &AC,\n-              rscope: &RS,\n-              a_seq_ty: &ast::MutTy,\n-              ptr_ty: PointerTy,\n-              constr: |ty::t| -> ty::t)\n-              -> ty::t {\n+fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n+        this: &AC,\n+        rscope: &RS,\n+        a_seq_ty: &ast::MutTy,\n+        ptr_ty: PointerTy,\n+        constr: |ty::t| -> ty::t)\n+        -> ty::t {\n     let tcx = this.tcx();\n     debug!(\"mk_pointer(ptr_ty={})\", ptr_ty);\n \n@@ -695,8 +693,8 @@ fn mk_pointer<AC:AstConv,\n \n // Parses the programmer's textual representation of a type into our\n // internal notion of a type.\n-pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n-    this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t {\n+pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n+        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t {\n \n     let tcx = this.tcx();\n \n@@ -914,8 +912,10 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n     return typ;\n }\n \n-pub fn ty_of_arg<AC: AstConv, RS: RegionScope>(this: &AC, rscope: &RS, a: &ast::Arg,\n-                                               expected_ty: Option<ty::t>) -> ty::t {\n+pub fn ty_of_arg<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(this: &AC, rscope: &RS,\n+                                                           a: &ast::Arg,\n+                                                           expected_ty: Option<ty::t>)\n+                                                           -> ty::t {\n     match a.ty.node {\n         ast::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n         ast::TyInfer => this.ty_infer(a.ty.span),\n@@ -928,7 +928,7 @@ struct SelfInfo<'a> {\n     explicit_self: ast::ExplicitSelf,\n }\n \n-pub fn ty_of_method<AC:AstConv>(\n+pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n                     this: &AC,\n                     id: ast::NodeId,\n                     fn_style: ast::FnStyle,\n@@ -951,15 +951,15 @@ pub fn ty_of_method<AC:AstConv>(\n     (bare_fn_ty, optional_explicit_self_category.unwrap())\n }\n \n-pub fn ty_of_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n-                                 fn_style: ast::FnStyle, abi: abi::Abi,\n-                                 decl: &ast::FnDecl) -> ty::BareFnTy {\n+pub fn ty_of_bare_fn<'tcx, AC: AstConv<'tcx>>(this: &AC, id: ast::NodeId,\n+                                              fn_style: ast::FnStyle, abi: abi::Abi,\n+                                              decl: &ast::FnDecl) -> ty::BareFnTy {\n     let (bare_fn_ty, _) =\n         ty_of_method_or_bare_fn(this, id, fn_style, abi, None, decl);\n     bare_fn_ty\n }\n \n-fn ty_of_method_or_bare_fn<AC:AstConv>(\n+fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n                            this: &AC,\n                            id: ast::NodeId,\n                            fn_style: ast::FnStyle,\n@@ -1070,7 +1070,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(\n     }, explicit_self_category_result)\n }\n \n-fn determine_explicit_self_category<AC:AstConv,\n+fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n                                     RS:RegionScope>(\n                                     this: &AC,\n                                     rscope: &RS,\n@@ -1145,7 +1145,7 @@ fn determine_explicit_self_category<AC:AstConv,\n     }\n }\n \n-pub fn ty_of_closure<AC:AstConv>(\n+pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n     this: &AC,\n     id: ast::NodeId,\n     fn_style: ast::FnStyle,\n@@ -1196,7 +1196,7 @@ pub fn ty_of_closure<AC:AstConv>(\n     }\n }\n \n-pub fn conv_existential_bounds<AC:AstConv, RS:RegionScope>(\n+pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n@@ -1330,7 +1330,7 @@ pub fn compute_opt_region_bound(tcx: &ty::ctxt,\n     return Some(r);\n }\n \n-fn compute_region_bound<AC:AstConv, RS:RegionScope>(\n+fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,"}, {"sha": "247178770d21a9a4041a3ea228335a934a10c9c5", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -107,8 +107,8 @@ pub fn check_match(fcx: &FnCtxt,\n     fcx.write_ty(expr.id, result_ty);\n }\n \n-pub struct pat_ctxt<'a> {\n-    pub fcx: &'a FnCtxt<'a>,\n+pub struct pat_ctxt<'a, 'tcx: 'a> {\n+    pub fcx: &'a FnCtxt<'a, 'tcx>,\n     pub map: PatIdMap,\n }\n "}, {"sha": "88d9a58ab141a91d603a7846e3ad14d39c21a451", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -123,8 +123,8 @@ pub enum StaticMethodsFlag {\n     IgnoreStaticMethods,\n }\n \n-pub fn lookup<'a>(\n-        fcx: &'a FnCtxt<'a>,\n+pub fn lookup<'a, 'tcx>(\n+        fcx: &'a FnCtxt<'a, 'tcx>,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n         expr: &ast::Expr,                   // The expression `a.b(...)`.\n@@ -170,8 +170,8 @@ pub fn lookup<'a>(\n     lcx.search(self_ty)\n }\n \n-pub fn lookup_in_trait<'a>(\n-        fcx: &'a FnCtxt<'a>,\n+pub fn lookup_in_trait<'a, 'tcx>(\n+        fcx: &'a FnCtxt<'a, 'tcx>,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n         span: Span,                         // The expression `a.b(...)`'s span.\n@@ -303,8 +303,8 @@ fn construct_transformed_self_ty_for_object(\n     }\n }\n \n-struct LookupContext<'a> {\n-    fcx: &'a FnCtxt<'a>,\n+struct LookupContext<'a, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n \n     // The receiver to the method call. Only `None` in the case of\n@@ -350,7 +350,7 @@ pub enum RcvrMatchCondition {\n     RcvrMatchesIfSubtype(ty::t),\n }\n \n-impl<'a> LookupContext<'a> {\n+impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     fn search(&self, self_ty: ty::t) -> Option<MethodCallee> {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         let self_expr_id = self.self_expr.map(|e| e.id);\n@@ -1615,11 +1615,11 @@ impl<'a> LookupContext<'a> {\n             idx + 1u, ty::item_path_str(self.tcx(), did));\n     }\n \n-    fn infcx(&'a self) -> &'a infer::InferCtxt<'a> {\n+    fn infcx(&'a self) -> &'a infer::InferCtxt<'a, 'tcx> {\n         &self.fcx.inh.infcx\n     }\n \n-    fn tcx(&self) -> &'a ty::ctxt {\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n         self.fcx.tcx()\n     }\n "}, {"sha": "01b5fd6e429eeaec1e675f1c7b5f3774b70c06d2", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 48, "deletions": 58, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -89,7 +89,7 @@ use middle::subst;\n use middle::subst::{Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{Polytype};\n-use middle::ty::{Disr, ExprTyProvider, ParamTy, ParameterEnvironment};\n+use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n@@ -159,8 +159,8 @@ pub mod method;\n /// Here, the function `foo()` and the closure passed to\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n-pub struct Inherited<'a> {\n-    infcx: infer::InferCtxt<'a>,\n+pub struct Inherited<'a, 'tcx: 'a> {\n+    infcx: infer::InferCtxt<'a, 'tcx>,\n     locals: RefCell<NodeMap<ty::t>>,\n     param_env: ty::ParameterEnvironment,\n \n@@ -267,7 +267,7 @@ enum IsBinopAssignment{\n }\n \n #[deriving(Clone)]\n-pub struct FnCtxt<'a> {\n+pub struct FnCtxt<'a, 'tcx: 'a> {\n     body_id: ast::NodeId,\n \n     // This flag is set to true if, during the writeback phase, we encounter\n@@ -284,13 +284,13 @@ pub struct FnCtxt<'a> {\n \n     ps: RefCell<FnStyleState>,\n \n-    inh: &'a Inherited<'a>,\n+    inh: &'a Inherited<'a, 'tcx>,\n \n-    ccx: &'a CrateCtxt<'a>,\n+    ccx: &'a CrateCtxt<'a, 'tcx>,\n }\n \n-impl<'a> mem_categorization::Typer for FnCtxt<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n     fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t> {\n@@ -322,10 +322,10 @@ impl<'a> mem_categorization::Typer for FnCtxt<'a> {\n     }\n }\n \n-impl<'a> Inherited<'a> {\n-    fn new(tcx: &'a ty::ctxt,\n+impl<'a, 'tcx> Inherited<'a, 'tcx> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>,\n            param_env: ty::ParameterEnvironment)\n-           -> Inherited<'a> {\n+           -> Inherited<'a, 'tcx> {\n         Inherited {\n             infcx: infer::new_infer_ctxt(tcx),\n             locals: RefCell::new(NodeMap::new()),\n@@ -344,12 +344,11 @@ impl<'a> Inherited<'a> {\n }\n \n // Used by check_const and check_enum_variants\n-pub fn blank_fn_ctxt<'a>(\n-                     ccx: &'a CrateCtxt<'a>,\n-                     inh: &'a Inherited<'a>,\n-                     rty: ty::t,\n-                     body_id: ast::NodeId)\n-                     -> FnCtxt<'a> {\n+pub fn blank_fn_ctxt<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n+                               inh: &'a Inherited<'a, 'tcx>,\n+                               rty: ty::t,\n+                               body_id: ast::NodeId)\n+                               -> FnCtxt<'a, 'tcx> {\n     FnCtxt {\n         body_id: body_id,\n         writeback_errors: Cell::new(false),\n@@ -361,7 +360,8 @@ pub fn blank_fn_ctxt<'a>(\n     }\n }\n \n-fn static_inherited_fields<'a>(ccx: &'a CrateCtxt<'a>) -> Inherited<'a> {\n+fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n+                                    -> Inherited<'a, 'tcx> {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n     let param_env = ty::ParameterEnvironment {\n@@ -372,37 +372,29 @@ fn static_inherited_fields<'a>(ccx: &'a CrateCtxt<'a>) -> Inherited<'a> {\n     Inherited::new(ccx.tcx, param_env)\n }\n \n-impl<'a> ExprTyProvider for FnCtxt<'a> {\n-    fn expr_ty(&self, ex: &ast::Expr) -> ty::t {\n-        self.expr_ty(ex)\n-    }\n-\n-    fn ty_ctxt<'a>(&'a self) -> &'a ty::ctxt {\n-        self.ccx.tcx\n-    }\n-}\n-\n-struct CheckTypeWellFormedVisitor<'a> { ccx: &'a CrateCtxt<'a> }\n+struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n+struct CheckTypeWellFormedVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n \n-impl<'a> Visitor<()> for CheckTypeWellFormedVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         check_type_well_formed(self.ccx, i);\n         visit::walk_item(self, i, ());\n     }\n }\n \n-struct CheckItemTypesVisitor<'a> { ccx: &'a CrateCtxt<'a> }\n \n-impl<'a> Visitor<()> for CheckItemTypesVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         check_item(self.ccx, i);\n         visit::walk_item(self, i, ());\n     }\n }\n \n-struct CheckItemSizedTypesVisitor<'a> { ccx: &'a CrateCtxt<'a> }\n+struct CheckItemSizedTypesVisitor<'a, 'tcx: 'a> {\n+    ccx: &'a CrateCtxt<'a, 'tcx>\n+}\n \n-impl<'a> Visitor<()> for CheckItemSizedTypesVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for CheckItemSizedTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         check_item_sized(self.ccx, i);\n         visit::walk_item(self, i, ());\n@@ -451,11 +443,11 @@ fn check_bare_fn(ccx: &CrateCtxt,\n     }\n }\n \n-struct GatherLocalsVisitor<'a> {\n-    fcx: &'a FnCtxt<'a>\n+struct GatherLocalsVisitor<'a, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'tcx>\n }\n \n-impl<'a> GatherLocalsVisitor<'a> {\n+impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n     fn assign(&mut self, nid: ast::NodeId, ty_opt: Option<ty::t>) {\n             match ty_opt {\n                 None => {\n@@ -472,7 +464,7 @@ impl<'a> GatherLocalsVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for GatherLocalsVisitor<'a, 'tcx> {\n     // Add explicitly-declared locals.\n     fn visit_local(&mut self, local: &ast::Local, _: ()) {\n         let o_ty = match local.ty.node {\n@@ -530,17 +522,15 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n \n }\n \n-fn check_fn<'a>(\n-    ccx: &'a CrateCtxt<'a>,\n-    fn_style: ast::FnStyle,\n-    fn_style_id: ast::NodeId,\n-    fn_sig: &ty::FnSig,\n-    decl: &ast::FnDecl,\n-    fn_id: ast::NodeId,\n-    body: &ast::Block,\n-    inherited: &'a Inherited<'a>)\n-    -> FnCtxt<'a>\n-{\n+fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n+                      fn_style: ast::FnStyle,\n+                      fn_style_id: ast::NodeId,\n+                      fn_sig: &ty::FnSig,\n+                      decl: &ast::FnDecl,\n+                      fn_id: ast::NodeId,\n+                      body: &ast::Block,\n+                      inherited: &'a Inherited<'a, 'tcx>)\n+                      -> FnCtxt<'a, 'tcx> {\n     /*!\n      * Helper used by check_bare_fn and check_expr_fn.  Does the\n      * grungy work of checking a function body and returns the\n@@ -1563,8 +1553,8 @@ fn check_cast(fcx: &FnCtxt,\n     fcx.write_ty(id, t_1);\n }\n \n-impl<'a> AstConv for FnCtxt<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.ccx.tcx }\n+impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.ccx.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n         ty::lookup_item_type(self.tcx(), id)\n@@ -1579,18 +1569,18 @@ impl<'a> AstConv for FnCtxt<'a> {\n     }\n }\n \n-impl<'a> FnCtxt<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.ccx.tcx }\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.ccx.tcx }\n \n-    pub fn infcx<'b>(&'b self) -> &'b infer::InferCtxt<'a> {\n+    pub fn infcx<'b>(&'b self) -> &'b infer::InferCtxt<'a, 'tcx> {\n         &self.inh.infcx\n     }\n \n     pub fn err_count_since_creation(&self) -> uint {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n \n-    pub fn vtable_context<'a>(&'a self) -> VtableContext<'a> {\n+    pub fn vtable_context<'a>(&'a self) -> VtableContext<'a, 'tcx> {\n         VtableContext {\n             infcx: self.infcx(),\n             param_env: &self.inh.param_env,\n@@ -1599,7 +1589,7 @@ impl<'a> FnCtxt<'a> {\n     }\n }\n \n-impl<'a> RegionScope for infer::InferCtxt<'a> {\n+impl<'a, 'tcx> RegionScope for infer::InferCtxt<'a, 'tcx> {\n     fn default_region_bound(&self, span: Span) -> Option<ty::Region> {\n         Some(self.next_region_var(infer::MiscVariable(span)))\n     }\n@@ -1612,7 +1602,7 @@ impl<'a> RegionScope for infer::InferCtxt<'a> {\n     }\n }\n \n-impl<'a> FnCtxt<'a> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn tag(&self) -> String {\n         format!(\"{}\", self as *const FnCtxt)\n     }\n@@ -3919,7 +3909,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprRepeat(ref element, ref count_expr) => {\n         check_expr_has_type(fcx, &**count_expr, ty::mk_uint());\n-        let count = ty::eval_repeat_count(fcx, &**count_expr);\n+        let count = ty::eval_repeat_count(fcx.tcx(), &**count_expr);\n \n         let uty = match expected {\n             ExpectHasType(uty) => {"}, {"sha": "eb630d0fc7bbe083ba7e88e393f1e6395a4f28b1", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -196,8 +196,8 @@ macro_rules! ignore_err(\n     )\n )\n \n-pub struct Rcx<'a> {\n-    fcx: &'a FnCtxt<'a>,\n+pub struct Rcx<'a, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n \n     region_param_pairs: Vec<(ty::Region, ty::ParamTy)>,\n \n@@ -250,15 +250,15 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n     }\n }\n \n-impl<'a> Rcx<'a> {\n-    pub fn new(fcx: &'a FnCtxt<'a>,\n-               initial_repeating_scope: ast::NodeId) -> Rcx<'a> {\n+impl<'a, 'tcx> Rcx<'a, 'tcx> {\n+    pub fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n+               initial_repeating_scope: ast::NodeId) -> Rcx<'a, 'tcx> {\n         Rcx { fcx: fcx,\n               repeating_scope: initial_repeating_scope,\n               region_param_pairs: Vec::new() }\n     }\n \n-    pub fn tcx(&self) -> &'a ty::ctxt {\n+    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n         self.fcx.ccx.tcx\n     }\n \n@@ -438,8 +438,8 @@ impl<'a> Rcx<'a> {\n     }\n }\n \n-impl<'fcx> mc::Typer for Rcx<'fcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.fcx.ccx.tcx\n     }\n \n@@ -479,7 +479,7 @@ impl<'fcx> mc::Typer for Rcx<'fcx> {\n     }\n }\n \n-impl<'a> Visitor<()> for Rcx<'a> {\n+impl<'a, 'tcx> Visitor<()> for Rcx<'a, 'tcx> {\n     // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n     // However, right now we run into an issue whereby some free\n     // regions are not properly related if they appear within the"}, {"sha": "60e502786ab3dbeb684efd32ac3fe64dcc73114a", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -51,8 +51,8 @@ pub enum WfConstraint {\n     RegionSubParamConstraint(Option<ty::t>, ty::Region, ty::ParamTy),\n }\n \n-struct Wf<'a> {\n-    tcx: &'a ty::ctxt,\n+struct Wf<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     stack: Vec<(ty::Region, Option<ty::t>)>,\n     out: Vec<WfConstraint>,\n }\n@@ -78,7 +78,7 @@ pub fn region_wf_constraints(\n     wf.out\n }\n \n-impl<'a> Wf<'a> {\n+impl<'a, 'tcx> Wf<'a, 'tcx> {\n     fn accumulate_from_ty(&mut self, ty: ty::t) {\n         debug!(\"Wf::accumulate_from_ty(ty={})\",\n                ty.repr(self.tcx));"}, {"sha": "16136fcf3e840c5046d7f96e500373142cfcfcbf", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -68,14 +68,14 @@ use syntax::visit::Visitor;\n \n /// A vtable context includes an inference context, a parameter environment,\n /// and a list of unboxed closure types.\n-pub struct VtableContext<'a> {\n-    pub infcx: &'a infer::InferCtxt<'a>,\n+pub struct VtableContext<'a, 'tcx: 'a> {\n+    pub infcx: &'a infer::InferCtxt<'a, 'tcx>,\n     pub param_env: &'a ty::ParameterEnvironment,\n     pub unboxed_closures: &'a RefCell<DefIdMap<ty::UnboxedClosure>>,\n }\n \n-impl<'a> VtableContext<'a> {\n-    pub fn tcx(&self) -> &'a ty::ctxt { self.infcx.tcx }\n+impl<'a, 'tcx> VtableContext<'a, 'tcx> {\n+    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.infcx.tcx }\n }\n \n fn lookup_vtables(vcx: &VtableContext,\n@@ -1025,7 +1025,7 @@ pub fn trans_resolve_method(tcx: &ty::ctxt, id: ast::NodeId,\n                    false)\n }\n \n-impl<'a, 'b> visit::Visitor<()> for &'a FnCtxt<'b> {\n+impl<'a, 'b, 'tcx> visit::Visitor<()> for &'a FnCtxt<'b, 'tcx> {\n     fn visit_expr(&mut self, ex: &ast::Expr, _: ()) {\n         early_resolve_expr(ex, *self, false);\n         visit::walk_expr(self, ex, ());"}, {"sha": "d65172cc0c167a57e922aef74994ed9c7f720a80", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -84,16 +84,16 @@ pub fn resolve_impl_res(infcx: &infer::InferCtxt,\n // there, it applies a few ad-hoc checks that were not convenient to\n // do elsewhere.\n \n-struct WritebackCx<'cx> {\n-    fcx: &'cx FnCtxt<'cx>,\n+struct WritebackCx<'cx, 'tcx: 'cx> {\n+    fcx: &'cx FnCtxt<'cx, 'tcx>,\n }\n \n-impl<'cx> WritebackCx<'cx> {\n-    fn new(fcx: &'cx FnCtxt) -> WritebackCx<'cx> {\n+impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n+    fn new(fcx: &'cx FnCtxt<'cx, 'tcx>) -> WritebackCx<'cx, 'tcx> {\n         WritebackCx { fcx: fcx }\n     }\n \n-    fn tcx(&self) -> &'cx ty::ctxt {\n+    fn tcx(&self) -> &'cx ty::ctxt<'tcx> {\n         self.fcx.tcx()\n     }\n }\n@@ -106,7 +106,7 @@ impl<'cx> WritebackCx<'cx> {\n // below. In general, a function is made into a `visitor` if it must\n // traffic in node-ids or update tables in the type context etc.\n \n-impl<'cx> Visitor<()> for WritebackCx<'cx> {\n+impl<'cx, 'tcx> Visitor<()> for WritebackCx<'cx, 'tcx> {\n     fn visit_item(&mut self, _: &ast::Item, _: ()) {\n         // Ignore items\n     }\n@@ -192,7 +192,7 @@ impl<'cx> Visitor<()> for WritebackCx<'cx> {\n     }\n }\n \n-impl<'cx> WritebackCx<'cx> {\n+impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_upvar_borrow_map(&self) {\n         if self.fcx.writeback_errors.get() {\n             return;\n@@ -400,28 +400,28 @@ impl<T:TypeFoldable> ResolveIn for T {\n // The Resolver. This is the type folding engine that detects\n // unresolved types and so forth.\n \n-struct Resolver<'cx> {\n-    tcx: &'cx ty::ctxt,\n-    infcx: &'cx infer::InferCtxt<'cx>,\n+struct Resolver<'cx, 'tcx: 'cx> {\n+    tcx: &'cx ty::ctxt<'tcx>,\n+    infcx: &'cx infer::InferCtxt<'cx, 'tcx>,\n     writeback_errors: &'cx Cell<bool>,\n     reason: ResolveReason,\n }\n \n-impl<'cx> Resolver<'cx> {\n-    fn new(fcx: &'cx FnCtxt<'cx>,\n+impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n+    fn new(fcx: &'cx FnCtxt<'cx, 'tcx>,\n            reason: ResolveReason)\n-           -> Resolver<'cx>\n+           -> Resolver<'cx, 'tcx>\n     {\n         Resolver { infcx: fcx.infcx(),\n                    tcx: fcx.tcx(),\n                    writeback_errors: &fcx.writeback_errors,\n                    reason: reason }\n     }\n \n-    fn from_infcx(infcx: &'cx infer::InferCtxt<'cx>,\n+    fn from_infcx(infcx: &'cx infer::InferCtxt<'cx, 'tcx>,\n                   writeback_errors: &'cx Cell<bool>,\n                   reason: ResolveReason)\n-                  -> Resolver<'cx>\n+                  -> Resolver<'cx, 'tcx>\n     {\n         Resolver { infcx: infcx,\n                    tcx: infcx.tcx,\n@@ -475,8 +475,8 @@ impl<'cx> Resolver<'cx> {\n     }\n }\n \n-impl<'cx> TypeFolder for Resolver<'cx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.tcx\n     }\n "}, {"sha": "2c6dc94f182b4bd56b4e01062b617fe2410680ca", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -182,16 +182,16 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n     }\n }\n \n-struct CoherenceChecker<'a> {\n-    crate_context: &'a CrateCtxt<'a>,\n-    inference_context: InferCtxt<'a>,\n+struct CoherenceChecker<'a, 'tcx: 'a> {\n+    crate_context: &'a CrateCtxt<'a, 'tcx>,\n+    inference_context: InferCtxt<'a, 'tcx>,\n }\n \n-struct CoherenceCheckVisitor<'a> {\n-    cc: &'a CoherenceChecker<'a>\n+struct CoherenceCheckVisitor<'a, 'tcx: 'a> {\n+    cc: &'a CoherenceChecker<'a, 'tcx>\n }\n \n-impl<'a> visit::Visitor<()> for CoherenceCheckVisitor<'a> {\n+impl<'a, 'tcx> visit::Visitor<()> for CoherenceCheckVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n \n         //debug!(\"(checking coherence) item '{}'\", token::get_ident(item.ident));\n@@ -214,9 +214,11 @@ impl<'a> visit::Visitor<()> for CoherenceCheckVisitor<'a> {\n     }\n }\n \n-struct PrivilegedScopeVisitor<'a> { cc: &'a CoherenceChecker<'a> }\n+struct PrivilegedScopeVisitor<'a, 'tcx: 'a> {\n+    cc: &'a CoherenceChecker<'a, 'tcx>\n+}\n \n-impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n+impl<'a, 'tcx> visit::Visitor<()> for PrivilegedScopeVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n \n         match item.node {\n@@ -263,7 +265,7 @@ impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n     }\n }\n \n-impl<'a> CoherenceChecker<'a> {\n+impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     fn check(&self, krate: &Crate) {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also"}, {"sha": "742d22cc3793ff396dfdde686f2e67f1f69db63e", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -95,11 +95,11 @@ pub fn collect_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n // of type parameters and supertraits. This is information we need to\n // know later when parsing field defs.\n \n-struct CollectTraitDefVisitor<'a> {\n-    ccx: &'a CrateCtxt<'a>\n+struct CollectTraitDefVisitor<'a, 'tcx: 'a> {\n+    ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n-impl<'a> visit::Visitor<()> for CollectTraitDefVisitor<'a> {\n+impl<'a, 'tcx> visit::Visitor<()> for CollectTraitDefVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         match i.node {\n             ast::ItemTrait(..) => {\n@@ -116,11 +116,11 @@ impl<'a> visit::Visitor<()> for CollectTraitDefVisitor<'a> {\n ///////////////////////////////////////////////////////////////////////////\n // Second phase: collection proper.\n \n-struct CollectItemTypesVisitor<'a> {\n-    ccx: &'a CrateCtxt<'a>\n+struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n+    ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n-impl<'a> visit::Visitor<()> for CollectItemTypesVisitor<'a> {\n+impl<'a, 'tcx> visit::Visitor<()> for CollectItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         convert(self.ccx, i);\n         visit::walk_item(self, i, ());\n@@ -138,14 +138,14 @@ pub trait ToTy {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t;\n }\n \n-impl<'a> ToTy for CrateCtxt<'a> {\n+impl<'a, 'tcx> ToTy for CrateCtxt<'a, 'tcx> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n-impl<'a> AstConv for CrateCtxt<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n+impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n         if id.krate != ast::LOCAL_CRATE {"}, {"sha": "44141f25418e404d4383a9132c5e8ef7be82f152", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -82,10 +82,10 @@ use syntax::ast;\n // Note: Coerce is not actually a combiner, in that it does not\n // conform to the same interface, though it performs a similar\n // function.\n-pub struct Coerce<'f>(pub CombineFields<'f>);\n+pub struct Coerce<'f, 'tcx: 'f>(pub CombineFields<'f, 'tcx>);\n \n-impl<'f> Coerce<'f> {\n-    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> {\n+impl<'f, 'tcx> Coerce<'f, 'tcx> {\n+    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f, 'tcx> {\n         let Coerce(ref v) = *self; v\n     }\n "}, {"sha": "66caf10cb408ca59794fcefdf16f144f7a2434cc", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -57,16 +57,16 @@ use syntax::ast::{Onceness, FnStyle};\n use syntax::ast;\n use syntax::abi;\n \n-pub trait Combine {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a>;\n+pub trait Combine<'tcx> {\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx>;\n     fn tag(&self) -> String;\n     fn a_is_expected(&self) -> bool;\n     fn trace(&self) -> TypeTrace;\n \n-    fn equate<'a>(&'a self) -> Equate<'a>;\n-    fn sub<'a>(&'a self) -> Sub<'a>;\n-    fn lub<'a>(&'a self) -> Lub<'a>;\n-    fn glb<'a>(&'a self) -> Glb<'a>;\n+    fn equate<'a>(&'a self) -> Equate<'a, 'tcx>;\n+    fn sub<'a>(&'a self) -> Sub<'a, 'tcx>;\n+    fn lub<'a>(&'a self) -> Lub<'a, 'tcx>;\n+    fn glb<'a>(&'a self) -> Glb<'a, 'tcx>;\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt>;\n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n@@ -138,13 +138,12 @@ pub trait Combine {\n \n         return Ok(substs);\n \n-        fn relate_region_params<C:Combine>(this: &C,\n-                                           item_def_id: ast::DefId,\n-                                           variances: &[ty::Variance],\n-                                           a_rs: &[ty::Region],\n-                                           b_rs: &[ty::Region])\n-                                           -> cres<Vec<ty::Region>>\n-        {\n+        fn relate_region_params<'tcx, C: Combine<'tcx>>(this: &C,\n+                                                        item_def_id: ast::DefId,\n+                                                        variances: &[ty::Variance],\n+                                                        a_rs: &[ty::Region],\n+                                                        b_rs: &[ty::Region])\n+                                                        -> cres<Vec<ty::Region>> {\n             let tcx = this.infcx().tcx;\n             let num_region_params = variances.len();\n \n@@ -305,13 +304,13 @@ pub trait Combine {\n }\n \n #[deriving(Clone)]\n-pub struct CombineFields<'a> {\n-    pub infcx: &'a InferCtxt<'a>,\n+pub struct CombineFields<'a, 'tcx: 'a> {\n+    pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub a_is_expected: bool,\n     pub trace: TypeTrace,\n }\n \n-pub fn expected_found<C:Combine,T>(\n+pub fn expected_found<'tcx, C: Combine<'tcx>, T>(\n         this: &C, a: T, b: T) -> ty::expected_found<T> {\n     if this.a_is_expected() {\n         ty::expected_found {expected: a, found: b}\n@@ -320,9 +319,15 @@ pub fn expected_found<C:Combine,T>(\n     }\n }\n \n-pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+pub fn super_fn_sigs<'tcx, C: Combine<'tcx>>(this: &C,\n+                                             a: &ty::FnSig,\n+                                             b: &ty::FnSig)\n+                                             -> cres<ty::FnSig> {\n \n-    fn argvecs<C:Combine>(this: &C, a_args: &[ty::t], b_args: &[ty::t]) -> cres<Vec<ty::t> > {\n+    fn argvecs<'tcx, C: Combine<'tcx>>(this: &C,\n+                                       a_args: &[ty::t],\n+                                       b_args: &[ty::t])\n+                                       -> cres<Vec<ty::t>> {\n         if a_args.len() == b_args.len() {\n             result::collect(a_args.iter().zip(b_args.iter())\n                             .map(|(a, b)| this.args(*a, *b)))\n@@ -345,18 +350,18 @@ pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<\n               variadic: a.variadic})\n }\n \n-pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n+pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n     // This is a horrible hack - historically, [T] was not treated as a type,\n     // so, for example, &T and &[U] should not unify. In fact the only thing\n     // &[U] should unify with is &[T]. We preserve that behaviour with this\n     // check.\n-    fn check_ptr_to_unsized<C:Combine>(this: &C,\n-                                       a: ty::t,\n-                                       b: ty::t,\n-                                       a_inner: ty::t,\n-                                       b_inner: ty::t,\n-                                       result: ty::t) -> cres<ty::t> {\n+    fn check_ptr_to_unsized<'tcx, C: Combine<'tcx>>(this: &C,\n+                                                    a: ty::t,\n+                                                    b: ty::t,\n+                                                    a_inner: ty::t,\n+                                                    b_inner: ty::t,\n+                                                    result: ty::t) -> cres<ty::t> {\n         match (&ty::get(a_inner).sty, &ty::get(b_inner).sty) {\n             (&ty::ty_vec(_, None), &ty::ty_vec(_, None)) |\n             (&ty::ty_str, &ty::ty_str) |\n@@ -547,7 +552,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       _ => Err(ty::terr_sorts(expected_found(this, a, b)))\n     };\n \n-    fn unify_integral_variable<C:Combine>(\n+    fn unify_integral_variable<'tcx, C: Combine<'tcx>>(\n         this: &C,\n         vid_is_expected: bool,\n         vid: ty::IntVid,\n@@ -560,7 +565,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n         }\n     }\n \n-    fn unify_float_variable<C:Combine>(\n+    fn unify_float_variable<'tcx, C: Combine<'tcx>>(\n         this: &C,\n         vid_is_expected: bool,\n         vid: ty::FloatVid,\n@@ -571,19 +576,19 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n     }\n }\n \n-impl<'f> CombineFields<'f> {\n-    pub fn switch_expected(&self) -> CombineFields<'f> {\n+impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n+    pub fn switch_expected(&self) -> CombineFields<'f, 'tcx> {\n         CombineFields {\n             a_is_expected: !self.a_is_expected,\n             ..(*self).clone()\n         }\n     }\n \n-    fn equate(&self) -> Equate<'f> {\n+    fn equate(&self) -> Equate<'f, 'tcx> {\n         Equate((*self).clone())\n     }\n \n-    fn sub(&self) -> Sub<'f> {\n+    fn sub(&self) -> Sub<'f, 'tcx> {\n         Sub((*self).clone())\n     }\n "}, {"sha": "fd4a5927362188d066f61e5626e03f0225409695", "filename": "src/librustc/middle/typeck/infer/equate.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -23,25 +23,25 @@ use util::ppaux::{Repr};\n \n use syntax::ast::{Onceness, FnStyle};\n \n-pub struct Equate<'f> {\n-    fields: CombineFields<'f>\n+pub struct Equate<'f, 'tcx: 'f> {\n+    fields: CombineFields<'f, 'tcx>\n }\n \n #[allow(non_snake_case)]\n-pub fn Equate<'f>(cf: CombineFields<'f>) -> Equate<'f> {\n+pub fn Equate<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Equate<'f, 'tcx> {\n     Equate { fields: cf }\n }\n \n-impl<'f> Combine for Equate<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n+impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"eq\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n-    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n+    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         self.tys(a, b)"}, {"sha": "e602e6a7b3c56b099c547a8cccc684b1f4d160d4", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -166,7 +166,7 @@ trait ErrorReportingHelpers {\n                                 span: codemap::Span);\n }\n \n-impl<'a> ErrorReporting for InferCtxt<'a> {\n+impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n     fn report_region_errors(&self,\n                             errors: &Vec<RegionResolutionError>) {\n         let p_errors = self.process_errors(errors);\n@@ -900,8 +900,8 @@ struct RebuildPathInfo<'a> {\n     region_names: &'a HashSet<ast::Name>\n }\n \n-struct Rebuilder<'a> {\n-    tcx: &'a ty::ctxt,\n+struct Rebuilder<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     fn_decl: ast::P<ast::FnDecl>,\n     expl_self_opt: Option<ast::ExplicitSelf_>,\n     generics: &'a ast::Generics,\n@@ -916,14 +916,14 @@ enum FreshOrKept {\n     Kept\n }\n \n-impl<'a> Rebuilder<'a> {\n-    fn new(tcx: &'a ty::ctxt,\n+impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>,\n            fn_decl: ast::P<ast::FnDecl>,\n            expl_self_opt: Option<ast::ExplicitSelf_>,\n            generics: &'a ast::Generics,\n            same_regions: &'a [SameRegions],\n            life_giver: &'a LifeGiver)\n-           -> Rebuilder<'a> {\n+           -> Rebuilder<'a, 'tcx> {\n         Rebuilder {\n             tcx: tcx,\n             fn_decl: fn_decl,\n@@ -1403,7 +1403,7 @@ impl<'a> Rebuilder<'a> {\n     }\n }\n \n-impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n+impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n     fn give_expl_lifetime_param(&self,\n                                 decl: &ast::FnDecl,\n                                 fn_style: ast::FnStyle,"}, {"sha": "08d4f9f3a86e5f041e9d00a8c8908a79e2982f0b", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -30,25 +30,25 @@ use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Glb<'f> {\n-    fields: CombineFields<'f>\n+pub struct Glb<'f, 'tcx: 'f> {\n+    fields: CombineFields<'f, 'tcx>\n }\n \n #[allow(non_snake_case)]\n-pub fn Glb<'f>(cf: CombineFields<'f>) -> Glb<'f> {\n+pub fn Glb<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Glb<'f, 'tcx> {\n     Glb { fields: cf }\n }\n \n-impl<'f> Combine for Glb<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n+impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"glb\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n-    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n+    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.fields.infcx.tcx;"}, {"sha": "6095e5b0504237823358ee068dd11bcf2d5dde46", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -51,7 +51,7 @@ pub trait LatticeDir {\n     fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()>;\n }\n \n-impl<'a> LatticeDir for Lub<'a> {\n+impl<'a, 'tcx> LatticeDir for Lub<'a, 'tcx> {\n     fn ty_bot(&self, t: ty::t) -> cres<ty::t> {\n         Ok(t)\n     }\n@@ -64,7 +64,7 @@ impl<'a> LatticeDir for Lub<'a> {\n     }\n }\n \n-impl<'a> LatticeDir for Glb<'a> {\n+impl<'a, 'tcx> LatticeDir for Glb<'a, 'tcx> {\n     fn ty_bot(&self, _: ty::t) -> cres<ty::t> {\n         Ok(ty::mk_bot())\n     }\n@@ -77,10 +77,10 @@ impl<'a> LatticeDir for Glb<'a> {\n     }\n }\n \n-pub fn super_lattice_tys<L:LatticeDir+Combine>(this: &L,\n-                                               a: ty::t,\n-                                               b: ty::t)\n-                                               -> cres<ty::t>\n+pub fn super_lattice_tys<'tcx, L:LatticeDir+Combine<'tcx>>(this: &L,\n+                                                           a: ty::t,\n+                                                           b: ty::t)\n+                                                           -> cres<ty::t>\n {\n     debug!(\"{}.lattice_tys({}, {})\",\n            this.tag(),\n@@ -115,9 +115,9 @@ pub fn super_lattice_tys<L:LatticeDir+Combine>(this: &L,\n // Random utility functions used by LUB/GLB when computing LUB/GLB of\n // fn types\n \n-pub fn var_ids<T:Combine>(this: &T,\n-                          map: &HashMap<ty::BoundRegion, ty::Region>)\n-                          -> Vec<RegionVid> {\n+pub fn var_ids<'tcx, T: Combine<'tcx>>(this: &T,\n+                                       map: &HashMap<ty::BoundRegion, ty::Region>)\n+                                       -> Vec<RegionVid> {\n     map.iter().map(|(_, r)| match *r {\n             ty::ReInfer(ty::ReVar(r)) => { r }\n             r => {"}, {"sha": "276a22648374173f4eefcf8d885789f619072a09", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -29,25 +29,25 @@ use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n /// \"Least upper bound\" (common supertype)\n-pub struct Lub<'f> {\n-    fields: CombineFields<'f>\n+pub struct Lub<'f, 'tcx: 'f> {\n+    fields: CombineFields<'f, 'tcx>\n }\n \n #[allow(non_snake_case)]\n-pub fn Lub<'f>(cf: CombineFields<'f>) -> Lub<'f> {\n+pub fn Lub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Lub<'f, 'tcx> {\n     Lub { fields: cf }\n }\n \n-impl<'f> Combine for Lub<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n+impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"lub\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n-    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n+    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.fields.infcx.tcx;"}, {"sha": "44ee7ba2de6e4beefdfe74e1b4169fe596ab7d05", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -75,8 +75,8 @@ pub type ures = cres<()>; // \"unify result\"\n pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n pub type CoerceResult = cres<Option<ty::AutoAdjustment>>;\n \n-pub struct InferCtxt<'a> {\n-    pub tcx: &'a ty::ctxt,\n+pub struct InferCtxt<'a, 'tcx: 'a> {\n+    pub tcx: &'a ty::ctxt<'tcx>,\n \n     // We instantiate UnificationTable with bounds<ty::t> because the\n     // types that might instantiate a general type variable have an\n@@ -93,7 +93,7 @@ pub struct InferCtxt<'a> {\n \n     // For region variables.\n     region_vars:\n-        RegionVarBindings<'a>,\n+        RegionVarBindings<'a, 'tcx>,\n }\n \n /// Why did we require that the two types be related?\n@@ -291,7 +291,8 @@ pub fn fixup_err_to_string(f: fixup_err) -> String {\n     }\n }\n \n-pub fn new_infer_ctxt<'a>(tcx: &'a ty::ctxt) -> InferCtxt<'a> {\n+pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>)\n+                                -> InferCtxt<'a, 'tcx> {\n     InferCtxt {\n         tcx: tcx,\n         type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n@@ -518,23 +519,23 @@ pub struct CombinedSnapshot {\n     region_vars_snapshot: RegionSnapshot,\n }\n \n-impl<'a> InferCtxt<'a> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn combine_fields<'a>(&'a self, a_is_expected: bool, trace: TypeTrace)\n-                              -> CombineFields<'a> {\n+                              -> CombineFields<'a, 'tcx> {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        trace: trace}\n     }\n \n-    pub fn equate<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Equate<'a> {\n+    pub fn equate<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Equate<'a, 'tcx> {\n         Equate(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn sub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Sub<'a> {\n+    pub fn sub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Sub<'a, 'tcx> {\n         Sub(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn lub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Lub<'a> {\n+    pub fn lub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Lub<'a, 'tcx> {\n         Lub(self.combine_fields(a_is_expected, trace))\n     }\n \n@@ -635,7 +636,7 @@ impl<'a> InferCtxt<'a> {\n     }\n }\n \n-impl<'a> InferCtxt<'a> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn next_ty_var_id(&self) -> TyVid {\n         self.type_variables\n             .borrow_mut()"}, {"sha": "7e61c254a656b3417d6815734ea5e193cbb58dab", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -151,8 +151,8 @@ impl SameRegions {\n \n pub type CombineMap = HashMap<TwoRegions, RegionVid>;\n \n-pub struct RegionVarBindings<'a> {\n-    tcx: &'a ty::ctxt,\n+pub struct RegionVarBindings<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     var_origins: RefCell<Vec<RegionVariableOrigin>>,\n \n     // Constraints of the form `A <= B` introduced by the region\n@@ -217,8 +217,8 @@ pub struct RegionMark {\n     length: uint\n }\n \n-impl<'a> RegionVarBindings<'a> {\n-    pub fn new(tcx: &'a ty::ctxt) -> RegionVarBindings<'a> {\n+impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n+    pub fn new(tcx: &'a ty::ctxt<'tcx>) -> RegionVarBindings<'a, 'tcx> {\n         RegionVarBindings {\n             tcx: tcx,\n             var_origins: RefCell::new(Vec::new()),\n@@ -711,9 +711,7 @@ impl<'a> RegionVarBindings<'a> {\n         *self.values.borrow_mut() = Some(v);\n         errors\n     }\n-}\n \n-impl<'a> RegionVarBindings<'a> {\n     fn is_subregion_of(&self, sub: Region, sup: Region) -> bool {\n         self.tcx.region_maps.is_subregion_of(sub, sup)\n     }\n@@ -959,7 +957,7 @@ struct RegionAndOrigin {\n \n type RegionGraph = graph::Graph<(), Constraint>;\n \n-impl<'a> RegionVarBindings<'a> {\n+impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn infer_variable_values(&self,\n                              errors: &mut Vec<RegionResolutionError>)\n                              -> Vec<VarValue>"}, {"sha": "dcdae7ed29c8d33a306af5c94a6bb4f3cda26ebf", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -74,18 +74,18 @@ pub static try_resolve_tvar_shallow: uint = 0;\n pub static resolve_and_force_all_but_regions: uint =\n     (resolve_all | force_all) & not_regions;\n \n-pub struct ResolveState<'a> {\n-    infcx: &'a InferCtxt<'a>,\n+pub struct ResolveState<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n     modes: uint,\n     err: Option<fixup_err>,\n     v_seen: Vec<TyVid> ,\n     type_depth: uint,\n }\n \n-pub fn resolver<'a>(infcx: &'a InferCtxt,\n-                    modes: uint,\n-                    _: Option<Span>)\n-                    -> ResolveState<'a> {\n+pub fn resolver<'a, 'tcx>(infcx: &'a InferCtxt<'a, 'tcx>,\n+                          modes: uint,\n+                          _: Option<Span>)\n+                          -> ResolveState<'a, 'tcx> {\n     ResolveState {\n         infcx: infcx,\n         modes: modes,\n@@ -95,8 +95,8 @@ pub fn resolver<'a>(infcx: &'a InferCtxt,\n     }\n }\n \n-impl<'a> ty_fold::TypeFolder for ResolveState<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for ResolveState<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -109,7 +109,7 @@ impl<'a> ty_fold::TypeFolder for ResolveState<'a> {\n     }\n }\n \n-impl<'a> ResolveState<'a> {\n+impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n     pub fn should(&mut self, mode: uint) -> bool {\n         (self.modes & mode) == mode\n     }"}, {"sha": "7403d50a2109ca287ef63ea24f739f3db23321de", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -28,25 +28,25 @@ use syntax::ast::{Onceness, FnStyle, MutImmutable, MutMutable};\n \n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Sub<'f> {\n-    fields: CombineFields<'f>\n+pub struct Sub<'f, 'tcx: 'f> {\n+    fields: CombineFields<'f, 'tcx>\n }\n \n #[allow(non_snake_case)]\n-pub fn Sub<'f>(cf: CombineFields<'f>) -> Sub<'f> {\n+pub fn Sub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Sub<'f, 'tcx> {\n     Sub { fields: cf }\n }\n \n-impl<'f> Combine for Sub<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n+impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"sub\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n-    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n+    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         Sub(self.fields.switch_expected()).tys(b, a)"}, {"sha": "198857fca5055123c908ed32e2fe76dcba43819c", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -39,10 +39,11 @@ use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note};\n use syntax::ast;\n use util::ppaux::{ty_to_string, UserString};\n \n-struct Env<'a> {\n+use arena::TypedArena;\n+\n+struct Env<'a, 'tcx: 'a> {\n     krate: ast::Crate,\n-    tcx: &'a ty::ctxt,\n-    infcx: &'a infer::InferCtxt<'a>,\n+    infcx: &'a infer::InferCtxt<'a, 'tcx>,\n }\n \n struct RH<'a> {\n@@ -129,7 +130,9 @@ fn test_env(_test_name: &str,\n     let named_region_map = resolve_lifetime::krate(&sess, &krate);\n     let region_map = region::resolve_crate(&sess, &krate);\n     let stability_index = stability::Index::build(&krate);\n+    let type_arena = TypedArena::new();\n     let tcx = ty::mk_ctxt(sess,\n+                          &type_arena,\n                           def_map,\n                           named_region_map,\n                           ast_map,\n@@ -139,19 +142,20 @@ fn test_env(_test_name: &str,\n                           lang_items,\n                           stability_index);\n     let infcx = infer::new_infer_ctxt(&tcx);\n-    let env = Env {krate: krate,\n-                   tcx: &tcx,\n-                   infcx: &infcx};\n+    let env = Env {\n+        krate: krate,\n+        infcx: &infcx\n+    };\n     body(env);\n     infcx.resolve_regions_and_report_errors();\n     assert_eq!(tcx.sess.err_count(), expected_err_count);\n }\n \n-impl<'a> Env<'a> {\n+impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn create_region_hierarchy(&self, rh: &RH) {\n         for child_rh in rh.sub.iter() {\n             self.create_region_hierarchy(child_rh);\n-            self.tcx.region_maps.record_encl_scope(child_rh.id, rh.id);\n+            self.infcx.tcx.region_maps.record_encl_scope(child_rh.id, rh.id);\n         }\n     }\n \n@@ -181,7 +185,7 @@ impl<'a> Env<'a> {\n                       -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n             for item in m.items.iter() {\n-                if item.ident.user_string(this.tcx) == names[idx] {\n+                if item.ident.user_string(this.infcx.tcx) == names[idx] {\n                     return search(this, &**item, idx+1, names);\n                 }\n             }\n@@ -220,7 +224,7 @@ impl<'a> Env<'a> {\n         match infer::mk_subty(self.infcx, true, infer::Misc(DUMMY_SP), a, b) {\n             Ok(_) => true,\n             Err(ref e) => fail!(\"Encountered error: {}\",\n-                                ty::type_err_to_str(self.tcx, e))\n+                                ty::type_err_to_str(self.infcx.tcx, e))\n         }\n     }\n \n@@ -253,7 +257,7 @@ impl<'a> Env<'a> {\n     }\n \n     pub fn ty_to_string(&self, a: ty::t) -> String {\n-        ty_to_string(self.tcx, a)\n+        ty_to_string(self.infcx.tcx, a)\n     }\n \n     pub fn t_fn(&self,\n@@ -262,31 +266,31 @@ impl<'a> Env<'a> {\n                 output_ty: ty::t)\n                 -> ty::t\n     {\n-        ty::mk_ctor_fn(self.tcx, binder_id, input_tys, output_ty)\n+        ty::mk_ctor_fn(self.infcx.tcx, binder_id, input_tys, output_ty)\n     }\n \n     pub fn t_int(&self) -> ty::t {\n         ty::mk_int()\n     }\n \n     pub fn t_rptr_late_bound(&self, binder_id: ast::NodeId, id: uint) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx, ty::ReLateBound(binder_id, ty::BrAnon(id)),\n+        ty::mk_imm_rptr(self.infcx.tcx, ty::ReLateBound(binder_id, ty::BrAnon(id)),\n                         self.t_int())\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx, ty::ReScope(id), self.t_int())\n+        ty::mk_imm_rptr(self.infcx.tcx, ty::ReScope(id), self.t_int())\n     }\n \n     pub fn t_rptr_free(&self, nid: ast::NodeId, id: uint) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx,\n+        ty::mk_imm_rptr(self.infcx.tcx,\n                         ty::ReFree(ty::FreeRegion {scope_id: nid,\n                                                     bound_region: ty::BrAnon(id)}),\n                         self.t_int())\n     }\n \n     pub fn t_rptr_static(&self) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx, ty::ReStatic, self.t_int())\n+        ty::mk_imm_rptr(self.infcx.tcx, ty::ReStatic, self.t_int())\n     }\n \n     pub fn dummy_type_trace(&self) -> infer::TypeTrace {\n@@ -299,12 +303,12 @@ impl<'a> Env<'a> {\n         }\n     }\n \n-    pub fn lub(&self) -> Lub<'a> {\n+    pub fn lub(&self) -> Lub<'a, 'tcx> {\n         let trace = self.dummy_type_trace();\n         Lub(self.infcx.combine_fields(true, trace))\n     }\n \n-    pub fn glb(&self) -> Glb<'a> {\n+    pub fn glb(&self) -> Glb<'a, 'tcx> {\n         let trace = self.dummy_type_trace();\n         Glb(self.infcx.combine_fields(true, trace))\n     }\n@@ -317,7 +321,7 @@ impl<'a> Env<'a> {\n         match self.lub().tys(t1, t2) {\n             Ok(t) => t,\n             Err(ref e) => fail!(\"unexpected error computing LUB: {:?}\",\n-                                ty::type_err_to_str(self.tcx, e))\n+                                ty::type_err_to_str(self.infcx.tcx, e))\n         }\n     }\n \n@@ -329,7 +333,7 @@ impl<'a> Env<'a> {\n             }\n             Err(ref e) => {\n                 fail!(\"unexpected error in LUB: {}\",\n-                      ty::type_err_to_str(self.tcx, e))\n+                      ty::type_err_to_str(self.infcx.tcx, e))\n             }\n         }\n     }"}, {"sha": "22d78340e9637fc90a94769044179b0744ff2f30", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -288,8 +288,8 @@ pub trait InferCtxtMethodsForSimplyUnifiableTypes<V:SimplyUnifiable,\n                     -> ures;\n }\n \n-impl<'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n-    InferCtxtMethodsForSimplyUnifiableTypes<V,K> for InferCtxt<'tcx>\n+impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n+    InferCtxtMethodsForSimplyUnifiableTypes<V,K> for InferCtxt<'a, 'tcx>\n {\n     fn simple_vars(&self,\n                    a_is_expected: bool,"}, {"sha": "7104cb9584444e0bb3117dd8a6ad8953ce7d0f3d", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -281,10 +281,10 @@ pub type vtable_map = RefCell<FnvHashMap<MethodCall, vtable_res>>;\n \n pub type impl_vtable_map = RefCell<DefIdMap<vtable_res>>;\n \n-pub struct CrateCtxt<'a> {\n+pub struct CrateCtxt<'a, 'tcx: 'a> {\n     // A mapping from method call sites to traits that have that method.\n     trait_map: resolve::TraitMap,\n-    tcx: &'a ty::ctxt\n+    tcx: &'a ty::ctxt<'tcx>\n }\n \n // Functions that write types into the node type table"}, {"sha": "7e8c53159fb8d0a39e6f6468db91f71b800d9763", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -254,8 +254,8 @@ impl<'a> fmt::Show for VarianceTerm<'a> {\n  * The first pass over the crate simply builds up the set of inferreds.\n  */\n \n-struct TermsContext<'a> {\n-    tcx: &'a ty::ctxt,\n+struct TermsContext<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     arena: &'a Arena,\n \n     empty_variances: Rc<ty::ItemVariances>,\n@@ -283,10 +283,10 @@ struct InferredInfo<'a> {\n     term: VarianceTermPtr<'a>,\n }\n \n-fn determine_parameters_to_be_inferred<'a>(tcx: &'a ty::ctxt,\n-                                           arena: &'a mut Arena,\n-                                           krate: &ast::Crate)\n-                                           -> TermsContext<'a> {\n+fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n+                                                 arena: &'a mut Arena,\n+                                                 krate: &ast::Crate)\n+                                                 -> TermsContext<'a, 'tcx> {\n     let mut terms_cx = TermsContext {\n         tcx: tcx,\n         arena: arena,\n@@ -306,7 +306,7 @@ fn determine_parameters_to_be_inferred<'a>(tcx: &'a ty::ctxt,\n     terms_cx\n }\n \n-impl<'a> TermsContext<'a> {\n+impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n     fn add_inferred(&mut self,\n                     item_id: ast::NodeId,\n                     kind: ParamKind,\n@@ -337,7 +337,7 @@ impl<'a> TermsContext<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for TermsContext<'a> {\n+impl<'a, 'tcx> Visitor<()> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         debug!(\"add_inferreds for item {}\", item.repr(self.tcx));\n \n@@ -402,8 +402,8 @@ impl<'a> Visitor<()> for TermsContext<'a> {\n  * We walk the set of items and, for each member, generate new constraints.\n  */\n \n-struct ConstraintContext<'a> {\n-    terms_cx: TermsContext<'a>,\n+struct ConstraintContext<'a, 'tcx: 'a> {\n+    terms_cx: TermsContext<'a, 'tcx>,\n \n     // These are the def-id of the std::kinds::marker::InvariantType,\n     // std::kinds::marker::InvariantLifetime, and so on. The arrays\n@@ -431,9 +431,9 @@ struct Constraint<'a> {\n     variance: &'a VarianceTerm<'a>,\n }\n \n-fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n-                                  krate: &ast::Crate)\n-                                  -> ConstraintContext<'a> {\n+fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n+                                        krate: &ast::Crate)\n+                                        -> ConstraintContext<'a, 'tcx> {\n     let mut invariant_lang_items = [None, ..2];\n     let mut covariant_lang_items = [None, ..2];\n     let mut contravariant_lang_items = [None, ..2];\n@@ -477,7 +477,7 @@ fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n     constraint_cx\n }\n \n-impl<'a> Visitor<()> for ConstraintContext<'a> {\n+impl<'a, 'tcx> Visitor<()> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         let did = ast_util::local_def(item.id);\n         let tcx = self.terms_cx.tcx;\n@@ -546,8 +546,8 @@ fn is_lifetime(map: &ast_map::Map, param_id: ast::NodeId) -> bool {\n     }\n }\n \n-impl<'a> ConstraintContext<'a> {\n-    fn tcx(&self) -> &'a ty::ctxt {\n+impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n         self.terms_cx.tcx\n     }\n \n@@ -942,8 +942,8 @@ impl<'a> ConstraintContext<'a> {\n  * inferred is then written into the `variance_map` in the tcx.\n  */\n \n-struct SolveContext<'a> {\n-    terms_cx: TermsContext<'a>,\n+struct SolveContext<'a, 'tcx: 'a> {\n+    terms_cx: TermsContext<'a, 'tcx>,\n     constraints: Vec<Constraint<'a>> ,\n \n     // Maps from an InferredIndex to the inferred value for that variable.\n@@ -961,7 +961,7 @@ fn solve_constraints(constraints_cx: ConstraintContext) {\n     solutions_cx.write();\n }\n \n-impl<'a> SolveContext<'a> {\n+impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n     fn solve(&mut self) {\n         // Propagate constraints until a fixed point is reached.  Note\n         // that the maximum number of iterations is 2C where C is the"}, {"sha": "e0afb80ad37f5ee203f30366849e54d619c19791", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 52, "deletions": 57, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -21,7 +21,7 @@ use rustc::middle::ty;\n use rustc::middle::subst;\n use rustc::middle::stability;\n \n-use core;\n+use core::DocContext;\n use doctree;\n use clean;\n \n@@ -39,24 +39,23 @@ use super::Clean;\n ///\n /// The returned value is `None` if the `id` could not be inlined, and `Some`\n /// of a vector of items if it was successfully expanded.\n-pub fn try_inline(id: ast::NodeId, into: Option<ast::Ident>)\n+pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Ident>)\n                   -> Option<Vec<clean::Item>> {\n-    let cx = ::ctxtkey.get().unwrap();\n-    let tcx = match cx.maybe_typed {\n-        core::Typed(ref tycx) => tycx,\n-        core::NotTyped(_) => return None,\n+    let tcx = match cx.tcx_opt() {\n+        Some(tcx) => tcx,\n+        None => return None,\n     };\n     let def = match tcx.def_map.borrow().find(&id) {\n         Some(def) => *def,\n         None => return None,\n     };\n     let did = def.def_id();\n     if ast_util::is_local(did) { return None }\n-    try_inline_def(&**cx, tcx, def).map(|vec| {\n+    try_inline_def(cx, tcx, def).map(|vec| {\n         vec.move_iter().map(|mut item| {\n             match into {\n                 Some(into) if item.name.is_some() => {\n-                    item.name = Some(into.clean());\n+                    item.name = Some(into.clean(cx));\n                 }\n                 _ => {}\n             }\n@@ -65,15 +64,14 @@ pub fn try_inline(id: ast::NodeId, into: Option<ast::Ident>)\n     })\n }\n \n-fn try_inline_def(cx: &core::DocContext,\n-                  tcx: &ty::ctxt,\n+fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n                   def: def::Def) -> Option<Vec<clean::Item>> {\n     let mut ret = Vec::new();\n     let did = def.def_id();\n     let inner = match def {\n         def::DefTrait(did) => {\n             record_extern_fqn(cx, did, clean::TypeTrait);\n-            clean::TraitItem(build_external_trait(tcx, did))\n+            clean::TraitItem(build_external_trait(cx, tcx, did))\n         }\n         def::DefFn(did, style) => {\n             // If this function is a tuple struct constructor, we just skip it\n@@ -82,17 +80,17 @@ fn try_inline_def(cx: &core::DocContext,\n                 return None\n             }\n             record_extern_fqn(cx, did, clean::TypeFunction);\n-            clean::FunctionItem(build_external_function(tcx, did, style))\n+            clean::FunctionItem(build_external_function(cx, tcx, did, style))\n         }\n         def::DefStruct(did) => {\n             record_extern_fqn(cx, did, clean::TypeStruct);\n             ret.extend(build_impls(cx, tcx, did).move_iter());\n-            clean::StructItem(build_struct(tcx, did))\n+            clean::StructItem(build_struct(cx, tcx, did))\n         }\n         def::DefTy(did) => {\n             record_extern_fqn(cx, did, clean::TypeEnum);\n             ret.extend(build_impls(cx, tcx, did).move_iter());\n-            build_type(tcx, did)\n+            build_type(cx, tcx, did)\n         }\n         // Assume that the enum type is reexported next to the variant, and\n         // variants don't show up in documentation specially.\n@@ -103,7 +101,7 @@ fn try_inline_def(cx: &core::DocContext,\n         }\n         def::DefStatic(did, mtbl) => {\n             record_extern_fqn(cx, did, clean::TypeStatic);\n-            clean::StaticItem(build_static(tcx, did, mtbl))\n+            clean::StaticItem(build_static(cx, tcx, did, mtbl))\n         }\n         _ => return None,\n     };\n@@ -112,20 +110,21 @@ fn try_inline_def(cx: &core::DocContext,\n     ret.push(clean::Item {\n         source: clean::Span::empty(),\n         name: Some(fqn.last().unwrap().to_string()),\n-        attrs: load_attrs(tcx, did),\n+        attrs: load_attrs(cx, tcx, did),\n         inner: inner,\n         visibility: Some(ast::Public),\n-        stability: stability::lookup(tcx, did).clean(),\n+        stability: stability::lookup(tcx, did).clean(cx),\n         def_id: did,\n     });\n     Some(ret)\n }\n \n-pub fn load_attrs(tcx: &ty::ctxt, did: ast::DefId) -> Vec<clean::Attribute> {\n+pub fn load_attrs(cx: &DocContext, tcx: &ty::ctxt,\n+                  did: ast::DefId) -> Vec<clean::Attribute> {\n     let mut attrs = Vec::new();\n     csearch::get_item_attrs(&tcx.sess.cstore, did, |v| {\n         attrs.extend(v.move_iter().map(|a| {\n-            a.clean()\n+            a.clean(cx)\n         }));\n     });\n     attrs\n@@ -135,22 +134,21 @@ pub fn load_attrs(tcx: &ty::ctxt, did: ast::DefId) -> Vec<clean::Attribute> {\n ///\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n-pub fn record_extern_fqn(cx: &core::DocContext,\n-                         did: ast::DefId,\n-                         kind: clean::TypeKind) {\n-    match cx.maybe_typed {\n-        core::Typed(ref tcx) => {\n+pub fn record_extern_fqn(cx: &DocContext, did: ast::DefId, kind: clean::TypeKind) {\n+    match cx.tcx_opt() {\n+        Some(tcx) => {\n             let fqn = csearch::get_item_path(tcx, did);\n             let fqn = fqn.move_iter().map(|i| i.to_string()).collect();\n             cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n         }\n-        core::NotTyped(..) => {}\n+        None => {}\n     }\n }\n \n-pub fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> clean::Trait {\n+pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n+                            did: ast::DefId) -> clean::Trait {\n     let def = ty::lookup_trait_def(tcx, did);\n-    let trait_items = ty::trait_items(tcx, did).clean();\n+    let trait_items = ty::trait_items(tcx, did).clean(cx);\n     let provided = ty::provided_trait_methods(tcx, did);\n     let mut items = trait_items.move_iter().map(|trait_item| {\n         if provided.iter().any(|a| a.def_id == trait_item.def_id) {\n@@ -160,29 +158,29 @@ pub fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> clean::Trait {\n         }\n     });\n     let trait_def = ty::lookup_trait_def(tcx, did);\n-    let bounds = trait_def.bounds.clean();\n+    let bounds = trait_def.bounds.clean(cx);\n     clean::Trait {\n-        generics: (&def.generics, subst::TypeSpace).clean(),\n+        generics: (&def.generics, subst::TypeSpace).clean(cx),\n         items: items.collect(),\n         bounds: bounds,\n     }\n }\n \n-fn build_external_function(tcx: &ty::ctxt,\n+fn build_external_function(cx: &DocContext, tcx: &ty::ctxt,\n                            did: ast::DefId,\n                            style: ast::FnStyle) -> clean::Function {\n     let t = ty::lookup_item_type(tcx, did);\n     clean::Function {\n         decl: match ty::get(t.ty).sty {\n-            ty::ty_bare_fn(ref f) => (did, &f.sig).clean(),\n+            ty::ty_bare_fn(ref f) => (did, &f.sig).clean(cx),\n             _ => fail!(\"bad function\"),\n         },\n-        generics: (&t.generics, subst::FnSpace).clean(),\n+        generics: (&t.generics, subst::FnSpace).clean(cx),\n         fn_style: style,\n     }\n }\n \n-fn build_struct(tcx: &ty::ctxt, did: ast::DefId) -> clean::Struct {\n+fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Struct {\n     use syntax::parse::token::special_idents::unnamed_field;\n \n     let t = ty::lookup_item_type(tcx, did);\n@@ -195,33 +193,32 @@ fn build_struct(tcx: &ty::ctxt, did: ast::DefId) -> clean::Struct {\n             [ref f, ..] if f.name == unnamed_field.name => doctree::Tuple,\n             _ => doctree::Plain,\n         },\n-        generics: (&t.generics, subst::TypeSpace).clean(),\n-        fields: fields.clean(),\n+        generics: (&t.generics, subst::TypeSpace).clean(cx),\n+        fields: fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n \n-fn build_type(tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n+fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n     let t = ty::lookup_item_type(tcx, did);\n     match ty::get(t.ty).sty {\n         ty::ty_enum(edid, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n             return clean::EnumItem(clean::Enum {\n-                generics: (&t.generics, subst::TypeSpace).clean(),\n+                generics: (&t.generics, subst::TypeSpace).clean(cx),\n                 variants_stripped: false,\n-                variants: ty::enum_variants(tcx, edid).clean(),\n+                variants: ty::enum_variants(tcx, edid).clean(cx),\n             })\n         }\n         _ => {}\n     }\n \n     clean::TypedefItem(clean::Typedef {\n-        type_: t.ty.clean(),\n-        generics: (&t.generics, subst::TypeSpace).clean(),\n+        type_: t.ty.clean(cx),\n+        generics: (&t.generics, subst::TypeSpace).clean(cx),\n     })\n }\n \n-fn build_impls(cx: &core::DocContext,\n-               tcx: &ty::ctxt,\n+fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n                did: ast::DefId) -> Vec<clean::Item> {\n     ty::populate_implementations_for_type_if_necessary(tcx, did);\n     let mut impls = Vec::new();\n@@ -248,8 +245,7 @@ fn build_impls(cx: &core::DocContext,\n             populate_impls(cx, tcx, def, &mut impls)\n         });\n \n-        fn populate_impls(cx: &core::DocContext,\n-                          tcx: &ty::ctxt,\n+        fn populate_impls(cx: &DocContext, tcx: &ty::ctxt,\n                           def: decoder::DefLike,\n                           impls: &mut Vec<Option<clean::Item>>) {\n             match def {\n@@ -269,8 +265,7 @@ fn build_impls(cx: &core::DocContext,\n     impls.move_iter().filter_map(|a| a).collect()\n }\n \n-fn build_impl(cx: &core::DocContext,\n-              tcx: &ty::ctxt,\n+fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n               did: ast::DefId) -> Option<clean::Item> {\n     if !cx.inlined.borrow_mut().as_mut().unwrap().insert(did) {\n         return None\n@@ -280,15 +275,15 @@ fn build_impl(cx: &core::DocContext,\n     // If this is an impl for a #[doc(hidden)] trait, be sure to not inline it.\n     match associated_trait {\n         Some(ref t) => {\n-            let trait_attrs = load_attrs(tcx, t.def_id);\n+            let trait_attrs = load_attrs(cx, tcx, t.def_id);\n             if trait_attrs.iter().any(|a| is_doc_hidden(a)) {\n                 return None\n             }\n         }\n         None => {}\n     }\n \n-    let attrs = load_attrs(tcx, did);\n+    let attrs = load_attrs(cx, tcx, did);\n     let ty = ty::lookup_item_type(tcx, did);\n     let trait_items = csearch::get_impl_items(&tcx.sess.cstore, did)\n             .iter()\n@@ -300,7 +295,7 @@ fn build_impl(cx: &core::DocContext,\n                 if method.vis != ast::Public && associated_trait.is_none() {\n                     return None\n                 }\n-                let mut item = method.clean();\n+                let mut item = method.clean(cx);\n                 item.inner = match item.inner.clone() {\n                     clean::TyMethodItem(clean::TyMethod {\n                         fn_style, decl, self_, generics\n@@ -321,21 +316,21 @@ fn build_impl(cx: &core::DocContext,\n     return Some(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n             derived: clean::detect_derived(attrs.as_slice()),\n-            trait_: associated_trait.clean().map(|bound| {\n+            trait_: associated_trait.clean(cx).map(|bound| {\n                 match bound {\n                     clean::TraitBound(ty) => ty,\n                     clean::RegionBound => unreachable!(),\n                 }\n             }),\n-            for_: ty.ty.clean(),\n-            generics: (&ty.generics, subst::TypeSpace).clean(),\n+            for_: ty.ty.clean(cx),\n+            generics: (&ty.generics, subst::TypeSpace).clean(cx),\n             items: trait_items,\n         }),\n         source: clean::Span::empty(),\n         name: None,\n         attrs: attrs,\n         visibility: Some(ast::Inherited),\n-        stability: stability::lookup(tcx, did).clean(),\n+        stability: stability::lookup(tcx, did).clean(cx),\n         def_id: did,\n     });\n \n@@ -354,7 +349,7 @@ fn build_impl(cx: &core::DocContext,\n     }\n }\n \n-fn build_module(cx: &core::DocContext, tcx: &ty::ctxt,\n+fn build_module(cx: &DocContext, tcx: &ty::ctxt,\n                 did: ast::DefId) -> clean::Module {\n     let mut items = Vec::new();\n     fill_in(cx, tcx, did, &mut items);\n@@ -365,7 +360,7 @@ fn build_module(cx: &core::DocContext, tcx: &ty::ctxt,\n \n     // FIXME: this doesn't handle reexports inside the module itself.\n     //        Should they be handled?\n-    fn fill_in(cx: &core::DocContext, tcx: &ty::ctxt, did: ast::DefId,\n+    fn fill_in(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId,\n                items: &mut Vec<clean::Item>) {\n         csearch::each_child_of_item(&tcx.sess.cstore, did, |def, _, vis| {\n             match def {\n@@ -387,11 +382,11 @@ fn build_module(cx: &core::DocContext, tcx: &ty::ctxt,\n     }\n }\n \n-fn build_static(tcx: &ty::ctxt,\n+fn build_static(cx: &DocContext, tcx: &ty::ctxt,\n                 did: ast::DefId,\n                 mutable: bool) -> clean::Static {\n     clean::Static {\n-        type_: ty::lookup_item_type(tcx, did).ty.clean(),\n+        type_: ty::lookup_item_type(tcx, did).ty.clean(cx),\n         mutability: if mutable {clean::Mutable} else {clean::Immutable},\n         expr: \"\\n\\n\\n\".to_string(), // trigger the \"[definition]\" links\n     }"}, {"sha": "c1a91f26dbf802c9e725cc8e533aebd33fa5f8e1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 355, "deletions": 380, "changes": 735, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -36,7 +36,7 @@ use std::rc::Rc;\n use std::u32;\n use std::gc::{Gc, GC};\n \n-use core;\n+use core::DocContext;\n use doctree;\n use visit_ast;\n \n@@ -46,57 +46,51 @@ pub static SCHEMA_VERSION: &'static str = \"0.8.3\";\n \n mod inline;\n \n-// load the current DocContext from TLD\n-fn get_cx() -> Gc<core::DocContext> {\n-    *super::ctxtkey.get().unwrap()\n-}\n-\n-// extract the stability index for a node from TLD, if possible\n-fn get_stability(def_id: ast::DefId) -> Option<Stability> {\n-    get_cx().tcx_opt().and_then(|tcx| stability::lookup(tcx, def_id))\n-            .map(|stab| stab.clean())\n+// extract the stability index for a node from tcx, if possible\n+fn get_stability(cx: &DocContext, def_id: ast::DefId) -> Option<Stability> {\n+    cx.tcx_opt().and_then(|tcx| stability::lookup(tcx, def_id)).clean(cx)\n }\n \n pub trait Clean<T> {\n-    fn clean(&self) -> T;\n+    fn clean(&self, cx: &DocContext) -> T;\n }\n \n impl<T: Clean<U>, U> Clean<Vec<U>> for Vec<T> {\n-    fn clean(&self) -> Vec<U> {\n-        self.iter().map(|x| x.clean()).collect()\n+    fn clean(&self, cx: &DocContext) -> Vec<U> {\n+        self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n impl<T: Clean<U>, U> Clean<VecPerParamSpace<U>> for VecPerParamSpace<T> {\n-    fn clean(&self) -> VecPerParamSpace<U> {\n-        self.map(|x| x.clean())\n+    fn clean(&self, cx: &DocContext) -> VecPerParamSpace<U> {\n+        self.map(|x| x.clean(cx))\n     }\n }\n \n impl<T: 'static + Clean<U>, U> Clean<U> for Gc<T> {\n-    fn clean(&self) -> U {\n-        (**self).clean()\n+    fn clean(&self, cx: &DocContext) -> U {\n+        (**self).clean(cx)\n     }\n }\n \n impl<T: Clean<U>, U> Clean<U> for Rc<T> {\n-    fn clean(&self) -> U {\n-        (**self).clean()\n+    fn clean(&self, cx: &DocContext) -> U {\n+        (**self).clean(cx)\n     }\n }\n \n impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n-    fn clean(&self) -> Option<U> {\n+    fn clean(&self, cx: &DocContext) -> Option<U> {\n         match self {\n             &None => None,\n-            &Some(ref v) => Some(v.clean())\n+            &Some(ref v) => Some(v.clean(cx))\n         }\n     }\n }\n \n impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::owned_slice::OwnedSlice<T> {\n-    fn clean(&self) -> Vec<U> {\n-        self.iter().map(|x| x.clean()).collect()\n+    fn clean(&self, cx: &DocContext) -> Vec<U> {\n+        self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n@@ -108,13 +102,11 @@ pub struct Crate {\n     pub primitives: Vec<Primitive>,\n }\n \n-impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n-    fn clean(&self) -> Crate {\n-        let cx = get_cx();\n-\n+impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n+    fn clean(&self, cx: &DocContext) -> Crate {\n         let mut externs = Vec::new();\n         cx.sess().cstore.iter_crate_data(|n, meta| {\n-            externs.push((n, meta.clean()));\n+            externs.push((n, meta.clean(cx)));\n         });\n         externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n@@ -124,7 +116,7 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n \n         // Clean the crate, translating the entire libsyntax AST to one that is\n         // understood by rustdoc.\n-        let mut module = self.module.clean();\n+        let mut module = self.module.clean(cx);\n \n         // Collect all inner modules which are tagged as implementations of\n         // primitives.\n@@ -199,23 +191,23 @@ pub struct ExternalCrate {\n }\n \n impl Clean<ExternalCrate> for cstore::crate_metadata {\n-    fn clean(&self) -> ExternalCrate {\n+    fn clean(&self, cx: &DocContext) -> ExternalCrate {\n         let mut primitives = Vec::new();\n-        get_cx().tcx_opt().map(|tcx| {\n+        cx.tcx_opt().map(|tcx| {\n             csearch::each_top_level_item_of_crate(&tcx.sess.cstore,\n                                                   self.cnum,\n                                                   |def, _, _| {\n                 let did = match def {\n                     decoder::DlDef(def::DefMod(did)) => did,\n                     _ => return\n                 };\n-                let attrs = inline::load_attrs(tcx, did);\n+                let attrs = inline::load_attrs(cx, tcx, did);\n                 Primitive::find(attrs.as_slice()).map(|prim| primitives.push(prim));\n             })\n         });\n         ExternalCrate {\n             name: self.name.to_string(),\n-            attrs: decoder::get_crate_attributes(self.data()).clean(),\n+            attrs: decoder::get_crate_attributes(self.data()).clean(cx),\n             primitives: primitives,\n         }\n     }\n@@ -334,38 +326,37 @@ pub struct Module {\n }\n \n impl Clean<Item> for doctree::Module {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         let name = if self.name.is_some() {\n-            self.name.unwrap().clean()\n+            self.name.unwrap().clean(cx)\n         } else {\n             \"\".to_string()\n         };\n         let mut foreigns = Vec::new();\n-        for subforeigns in self.foreigns.clean().move_iter() {\n+        for subforeigns in self.foreigns.clean(cx).move_iter() {\n             for foreign in subforeigns.move_iter() {\n                 foreigns.push(foreign)\n             }\n         }\n         let items: Vec<Vec<Item> > = vec!(\n-            self.structs.clean(),\n-            self.enums.clean(),\n-            self.fns.clean(),\n+            self.structs.clean(cx),\n+            self.enums.clean(cx),\n+            self.fns.clean(cx),\n             foreigns,\n-            self.mods.clean(),\n-            self.typedefs.clean(),\n-            self.statics.clean(),\n-            self.traits.clean(),\n-            self.impls.clean(),\n-            self.view_items.clean().move_iter()\n+            self.mods.clean(cx),\n+            self.typedefs.clean(cx),\n+            self.statics.clean(cx),\n+            self.traits.clean(cx),\n+            self.impls.clean(cx),\n+            self.view_items.clean(cx).move_iter()\n                            .flat_map(|s| s.move_iter()).collect(),\n-            self.macros.clean(),\n+            self.macros.clean(cx),\n         );\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n         let whence = {\n-            let ctxt = super::ctxtkey.get().unwrap();\n-            let cm = ctxt.sess().codemap();\n+            let cm = cx.sess().codemap();\n             let outer = cm.lookup_char_pos(self.where_outer.lo);\n             let inner = cm.lookup_char_pos(self.where_inner.lo);\n             if outer.file.start_pos == inner.file.start_pos {\n@@ -379,10 +370,10 @@ impl Clean<Item> for doctree::Module {\n \n         Item {\n             name: Some(name),\n-            attrs: self.attrs.clean(),\n-            source: whence.clean(),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            attrs: self.attrs.clean(cx),\n+            source: whence.clean(cx),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             def_id: ast_util::local_def(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n@@ -402,11 +393,11 @@ pub enum Attribute {\n }\n \n impl Clean<Attribute> for ast::MetaItem {\n-    fn clean(&self) -> Attribute {\n+    fn clean(&self, cx: &DocContext) -> Attribute {\n         match self.node {\n             ast::MetaWord(ref s) => Word(s.get().to_string()),\n             ast::MetaList(ref s, ref l) => {\n-                List(s.get().to_string(), l.clean())\n+                List(s.get().to_string(), l.clean(cx))\n             }\n             ast::MetaNameValue(ref s, ref v) => {\n                 NameValue(s.get().to_string(), lit_to_string(v))\n@@ -416,8 +407,8 @@ impl Clean<Attribute> for ast::MetaItem {\n }\n \n impl Clean<Attribute> for ast::Attribute {\n-    fn clean(&self) -> Attribute {\n-        self.desugar_doc().node.value.clean()\n+    fn clean(&self, cx: &DocContext) -> Attribute {\n+        self.desugar_doc().node.value.clean(cx)\n     }\n }\n \n@@ -456,25 +447,25 @@ pub struct TyParam {\n }\n \n impl Clean<TyParam> for ast::TyParam {\n-    fn clean(&self) -> TyParam {\n+    fn clean(&self, cx: &DocContext) -> TyParam {\n         TyParam {\n-            name: self.ident.clean(),\n+            name: self.ident.clean(cx),\n             did: ast::DefId { krate: ast::LOCAL_CRATE, node: self.id },\n-            bounds: self.bounds.clean(),\n-            default: self.default.clean()\n+            bounds: self.bounds.clean(cx),\n+            default: self.default.clean(cx)\n         }\n     }\n }\n \n impl Clean<TyParam> for ty::TypeParameterDef {\n-    fn clean(&self) -> TyParam {\n-        get_cx().external_typarams.borrow_mut().as_mut().unwrap()\n-                .insert(self.def_id, self.ident.clean());\n+    fn clean(&self, cx: &DocContext) -> TyParam {\n+        cx.external_typarams.borrow_mut().as_mut().unwrap()\n+          .insert(self.def_id, self.ident.clean(cx));\n         TyParam {\n-            name: self.ident.clean(),\n+            name: self.ident.clean(cx),\n             did: self.def_id,\n-            bounds: self.bounds.clean(),\n-            default: self.default.clean()\n+            bounds: self.bounds.clean(cx),\n+            default: self.default.clean(cx)\n         }\n     }\n }\n@@ -486,35 +477,35 @@ pub enum TyParamBound {\n }\n \n impl Clean<TyParamBound> for ast::TyParamBound {\n-    fn clean(&self) -> TyParamBound {\n+    fn clean(&self, cx: &DocContext) -> TyParamBound {\n         match *self {\n             ast::RegionTyParamBound(_) => RegionBound,\n             ast::UnboxedFnTyParamBound(_) => {\n                 // FIXME(pcwalton): Wrong.\n                 RegionBound\n             }\n-            ast::TraitTyParamBound(ref t) => TraitBound(t.clean()),\n+            ast::TraitTyParamBound(ref t) => TraitBound(t.clean(cx)),\n         }\n     }\n }\n \n impl Clean<Vec<TyParamBound>> for ty::ExistentialBounds {\n-    fn clean(&self) -> Vec<TyParamBound> {\n+    fn clean(&self, cx: &DocContext) -> Vec<TyParamBound> {\n         let mut vec = vec!(RegionBound);\n         for bb in self.builtin_bounds.iter() {\n-            vec.push(bb.clean());\n+            vec.push(bb.clean(cx));\n         }\n         vec\n     }\n }\n \n-fn external_path(name: &str, substs: &subst::Substs) -> Path {\n+fn external_path(cx: &DocContext, name: &str, substs: &subst::Substs) -> Path {\n     let lifetimes = substs.regions().get_slice(subst::TypeSpace)\n                     .iter()\n-                    .filter_map(|v| v.clean())\n+                    .filter_map(|v| v.clean(cx))\n                     .collect();\n     let types = Vec::from_slice(substs.types.get_slice(subst::TypeSpace));\n-    let types = types.clean();\n+    let types = types.clean(cx);\n     Path {\n         global: false,\n         segments: vec![PathSegment {\n@@ -526,26 +517,25 @@ fn external_path(name: &str, substs: &subst::Substs) -> Path {\n }\n \n impl Clean<TyParamBound> for ty::BuiltinBound {\n-    fn clean(&self) -> TyParamBound {\n-        let cx = get_cx();\n-        let tcx = match cx.maybe_typed {\n-            core::Typed(ref tcx) => tcx,\n-            core::NotTyped(_) => return RegionBound,\n+    fn clean(&self, cx: &DocContext) -> TyParamBound {\n+        let tcx = match cx.tcx_opt() {\n+            Some(tcx) => tcx,\n+            None => return RegionBound,\n         };\n         let empty = subst::Substs::empty();\n         let (did, path) = match *self {\n             ty::BoundSend =>\n                 (tcx.lang_items.send_trait().unwrap(),\n-                 external_path(\"Send\", &empty)),\n+                 external_path(cx, \"Send\", &empty)),\n             ty::BoundSized =>\n                 (tcx.lang_items.sized_trait().unwrap(),\n-                 external_path(\"Sized\", &empty)),\n+                 external_path(cx, \"Sized\", &empty)),\n             ty::BoundCopy =>\n                 (tcx.lang_items.copy_trait().unwrap(),\n-                 external_path(\"Copy\", &empty)),\n+                 external_path(cx, \"Copy\", &empty)),\n             ty::BoundSync =>\n                 (tcx.lang_items.sync_trait().unwrap(),\n-                 external_path(\"Sync\", &empty)),\n+                 external_path(cx, \"Sync\", &empty)),\n         };\n         let fqn = csearch::get_item_path(tcx, did);\n         let fqn = fqn.move_iter().map(|i| i.to_string()).collect();\n@@ -560,16 +550,15 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n }\n \n impl Clean<TyParamBound> for ty::TraitRef {\n-    fn clean(&self) -> TyParamBound {\n-        let cx = get_cx();\n-        let tcx = match cx.maybe_typed {\n-            core::Typed(ref tcx) => tcx,\n-            core::NotTyped(_) => return RegionBound,\n+    fn clean(&self, cx: &DocContext) -> TyParamBound {\n+        let tcx = match cx.tcx_opt() {\n+            Some(tcx) => tcx,\n+            None => return RegionBound,\n         };\n         let fqn = csearch::get_item_path(tcx, self.def_id);\n         let fqn = fqn.move_iter().map(|i| i.to_string())\n                      .collect::<Vec<String>>();\n-        let path = external_path(fqn.last().unwrap().as_slice(),\n+        let path = external_path(cx, fqn.last().unwrap().as_slice(),\n                                  &self.substs);\n         cx.external_paths.borrow_mut().as_mut().unwrap().insert(self.def_id,\n                                                             (fqn, TypeTrait));\n@@ -582,25 +571,25 @@ impl Clean<TyParamBound> for ty::TraitRef {\n }\n \n impl Clean<Vec<TyParamBound>> for ty::ParamBounds {\n-    fn clean(&self) -> Vec<TyParamBound> {\n+    fn clean(&self, cx: &DocContext) -> Vec<TyParamBound> {\n         let mut v = Vec::new();\n         for b in self.builtin_bounds.iter() {\n             if b != ty::BoundSized {\n-                v.push(b.clean());\n+                v.push(b.clean(cx));\n             }\n         }\n         for t in self.trait_bounds.iter() {\n-            v.push(t.clean());\n+            v.push(t.clean(cx));\n         }\n         return v;\n     }\n }\n \n impl Clean<Option<Vec<TyParamBound>>> for subst::Substs {\n-    fn clean(&self) -> Option<Vec<TyParamBound>> {\n+    fn clean(&self, cx: &DocContext) -> Option<Vec<TyParamBound>> {\n         let mut v = Vec::new();\n         v.extend(self.regions().iter().map(|_| RegionBound));\n-        v.extend(self.types.iter().map(|t| TraitBound(t.clean())));\n+        v.extend(self.types.iter().map(|t| TraitBound(t.clean(cx))));\n         if v.len() > 0 {Some(v)} else {None}\n     }\n }\n@@ -617,30 +606,30 @@ impl Lifetime {\n }\n \n impl Clean<Lifetime> for ast::Lifetime {\n-    fn clean(&self) -> Lifetime {\n+    fn clean(&self, _: &DocContext) -> Lifetime {\n         Lifetime(token::get_name(self.name).get().to_string())\n     }\n }\n \n impl Clean<Lifetime> for ast::LifetimeDef {\n-    fn clean(&self) -> Lifetime {\n+    fn clean(&self, _: &DocContext) -> Lifetime {\n         Lifetime(token::get_name(self.lifetime.name).get().to_string())\n     }\n }\n \n impl Clean<Lifetime> for ty::RegionParameterDef {\n-    fn clean(&self) -> Lifetime {\n+    fn clean(&self, _: &DocContext) -> Lifetime {\n         Lifetime(token::get_name(self.name).get().to_string())\n     }\n }\n \n impl Clean<Option<Lifetime>> for ty::Region {\n-    fn clean(&self) -> Option<Lifetime> {\n+    fn clean(&self, cx: &DocContext) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime(\"'static\".to_string())),\n             ty::ReLateBound(_, ty::BrNamed(_, name)) =>\n                 Some(Lifetime(token::get_name(name).get().to_string())),\n-            ty::ReEarlyBound(_, _, _, name) => Some(Lifetime(name.clean())),\n+            ty::ReEarlyBound(_, _, _, name) => Some(Lifetime(name.clean(cx))),\n \n             ty::ReLateBound(..) |\n             ty::ReFree(..) |\n@@ -659,20 +648,20 @@ pub struct Generics {\n }\n \n impl Clean<Generics> for ast::Generics {\n-    fn clean(&self) -> Generics {\n+    fn clean(&self, cx: &DocContext) -> Generics {\n         Generics {\n-            lifetimes: self.lifetimes.clean(),\n-            type_params: self.ty_params.clean(),\n+            lifetimes: self.lifetimes.clean(cx),\n+            type_params: self.ty_params.clean(cx),\n         }\n     }\n }\n \n impl<'a> Clean<Generics> for (&'a ty::Generics, subst::ParamSpace) {\n-    fn clean(&self) -> Generics {\n+    fn clean(&self, cx: &DocContext) -> Generics {\n         let (me, space) = *self;\n         Generics {\n-            type_params: Vec::from_slice(me.types.get_slice(space)).clean(),\n-            lifetimes: Vec::from_slice(me.regions.get_slice(space)).clean(),\n+            type_params: Vec::from_slice(me.types.get_slice(space)).clean(cx),\n+            lifetimes: Vec::from_slice(me.regions.get_slice(space)).clean(cx),\n         }\n     }\n }\n@@ -686,30 +675,30 @@ pub struct Method {\n }\n \n impl Clean<Item> for ast::Method {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         let all_inputs = &self.pe_fn_decl().inputs;\n         let inputs = match self.pe_explicit_self().node {\n             ast::SelfStatic => all_inputs.as_slice(),\n             _ => all_inputs.slice_from(1)\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n-                values: inputs.iter().map(|x| x.clean()).collect(),\n+                values: inputs.iter().map(|x| x.clean(cx)).collect(),\n             },\n-            output: (self.pe_fn_decl().output.clean()),\n-            cf: self.pe_fn_decl().cf.clean(),\n+            output: (self.pe_fn_decl().output.clean(cx)),\n+            cf: self.pe_fn_decl().cf.clean(cx),\n             attrs: Vec::new()\n         };\n         Item {\n-            name: Some(self.pe_ident().clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.span.clean(),\n+            name: Some(self.pe_ident().clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.span.clean(cx),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.pe_vis().clean(),\n-            stability: get_stability(ast_util::local_def(self.id)),\n+            visibility: self.pe_vis().clean(cx),\n+            stability: get_stability(cx, ast_util::local_def(self.id)),\n             inner: MethodItem(Method {\n-                generics: self.pe_generics().clean(),\n-                self_: self.pe_explicit_self().node.clean(),\n+                generics: self.pe_generics().clean(cx),\n+                self_: self.pe_explicit_self().node.clean(cx),\n                 fn_style: self.pe_fn_style().clone(),\n                 decl: decl,\n             }),\n@@ -726,31 +715,31 @@ pub struct TyMethod {\n }\n \n impl Clean<Item> for ast::TypeMethod {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         let inputs = match self.explicit_self.node {\n             ast::SelfStatic => self.decl.inputs.as_slice(),\n             _ => self.decl.inputs.slice_from(1)\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n-                values: inputs.iter().map(|x| x.clean()).collect(),\n+                values: inputs.iter().map(|x| x.clean(cx)).collect(),\n             },\n-            output: (self.decl.output.clean()),\n-            cf: self.decl.cf.clean(),\n+            output: (self.decl.output.clean(cx)),\n+            cf: self.decl.cf.clean(cx),\n             attrs: Vec::new()\n         };\n         Item {\n-            name: Some(self.ident.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.span.clean(),\n+            name: Some(self.ident.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.span.clean(cx),\n             def_id: ast_util::local_def(self.id),\n             visibility: None,\n-            stability: get_stability(ast_util::local_def(self.id)),\n+            stability: get_stability(cx, ast_util::local_def(self.id)),\n             inner: TyMethodItem(TyMethod {\n                 fn_style: self.fn_style.clone(),\n                 decl: decl,\n-                self_: self.explicit_self.node.clean(),\n-                generics: self.generics.clean(),\n+                self_: self.explicit_self.node.clean(cx),\n+                generics: self.generics.clean(cx),\n             }),\n         }\n     }\n@@ -765,14 +754,14 @@ pub enum SelfTy {\n }\n \n impl Clean<SelfTy> for ast::ExplicitSelf_ {\n-    fn clean(&self) -> SelfTy {\n+    fn clean(&self, cx: &DocContext) -> SelfTy {\n         match *self {\n             ast::SelfStatic => SelfStatic,\n             ast::SelfValue(_) => SelfValue,\n             ast::SelfRegion(lt, mt, _) => {\n-                SelfBorrowed(lt.clean(), mt.clean())\n+                SelfBorrowed(lt.clean(cx), mt.clean(cx))\n             }\n-            ast::SelfExplicit(typ, _) => SelfExplicit(typ.clean()),\n+            ast::SelfExplicit(typ, _) => SelfExplicit(typ.clean(cx)),\n         }\n     }\n }\n@@ -785,17 +774,17 @@ pub struct Function {\n }\n \n impl Clean<Item> for doctree::Function {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             def_id: ast_util::local_def(self.id),\n             inner: FunctionItem(Function {\n-                decl: self.decl.clean(),\n-                generics: self.generics.clean(),\n+                decl: self.decl.clean(cx),\n+                generics: self.generics.clean(cx),\n                 fn_style: self.fn_style,\n             }),\n         }\n@@ -812,13 +801,13 @@ pub struct ClosureDecl {\n }\n \n impl Clean<ClosureDecl> for ast::ClosureTy {\n-    fn clean(&self) -> ClosureDecl {\n+    fn clean(&self, cx: &DocContext) -> ClosureDecl {\n         ClosureDecl {\n-            lifetimes: self.lifetimes.clean(),\n-            decl: self.decl.clean(),\n+            lifetimes: self.lifetimes.clean(cx),\n+            decl: self.decl.clean(cx),\n             onceness: self.onceness,\n             fn_style: self.fn_style,\n-            bounds: self.bounds.clean()\n+            bounds: self.bounds.clean(cx)\n         }\n     }\n }\n@@ -837,21 +826,20 @@ pub struct Arguments {\n }\n \n impl Clean<FnDecl> for ast::FnDecl {\n-    fn clean(&self) -> FnDecl {\n+    fn clean(&self, cx: &DocContext) -> FnDecl {\n         FnDecl {\n             inputs: Arguments {\n-                values: self.inputs.iter().map(|x| x.clean()).collect(),\n+                values: self.inputs.clean(cx),\n             },\n-            output: (self.output.clean()),\n-            cf: self.cf.clean(),\n+            output: self.output.clean(cx),\n+            cf: self.cf.clean(cx),\n             attrs: Vec::new()\n         }\n     }\n }\n \n impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n-    fn clean(&self) -> FnDecl {\n-        let cx = get_cx();\n+    fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n         let mut names = if did.node != 0 {\n             csearch::get_method_arg_names(&cx.tcx().sess.cstore, did).move_iter()\n@@ -862,13 +850,13 @@ impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n             let _ = names.next();\n         }\n         FnDecl {\n-            output: sig.output.clean(),\n+            output: sig.output.clean(cx),\n             cf: Return,\n             attrs: Vec::new(),\n             inputs: Arguments {\n                 values: sig.inputs.iter().map(|t| {\n                     Argument {\n-                        type_: t.clean(),\n+                        type_: t.clean(cx),\n                         id: 0,\n                         name: names.next().unwrap_or(\"\".to_string()),\n                     }\n@@ -886,10 +874,10 @@ pub struct Argument {\n }\n \n impl Clean<Argument> for ast::Arg {\n-    fn clean(&self) -> Argument {\n+    fn clean(&self, cx: &DocContext) -> Argument {\n         Argument {\n             name: name_from_pat(&*self.pat),\n-            type_: (self.ty.clean()),\n+            type_: (self.ty.clean(cx)),\n             id: self.id\n         }\n     }\n@@ -902,7 +890,7 @@ pub enum RetStyle {\n }\n \n impl Clean<RetStyle> for ast::RetStyle {\n-    fn clean(&self) -> RetStyle {\n+    fn clean(&self, _: &DocContext) -> RetStyle {\n         match *self {\n             ast::Return => Return,\n             ast::NoReturn => NoReturn\n@@ -918,26 +906,26 @@ pub struct Trait {\n }\n \n impl Clean<Item> for doctree::Trait {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             inner: TraitItem(Trait {\n-                items: self.items.clean(),\n-                generics: self.generics.clean(),\n-                bounds: self.bounds.clean(),\n+                items: self.items.clean(cx),\n+                generics: self.generics.clean(cx),\n+                bounds: self.bounds.clean(cx),\n             }),\n         }\n     }\n }\n \n impl Clean<Type> for ast::TraitRef {\n-    fn clean(&self) -> Type {\n-        resolve_type(self.path.clean(), None, self.ref_id)\n+    fn clean(&self, cx: &DocContext) -> Type {\n+        resolve_type(cx, self.path.clean(cx), None, self.ref_id)\n     }\n }\n \n@@ -969,10 +957,10 @@ impl TraitItem {\n }\n \n impl Clean<TraitItem> for ast::TraitItem {\n-    fn clean(&self) -> TraitItem {\n+    fn clean(&self, cx: &DocContext) -> TraitItem {\n         match self {\n-            &ast::RequiredMethod(ref t) => RequiredMethod(t.clean()),\n-            &ast::ProvidedMethod(ref t) => ProvidedMethod(t.clean()),\n+            &ast::RequiredMethod(ref t) => RequiredMethod(t.clean(cx)),\n+            &ast::ProvidedMethod(ref t) => ProvidedMethod(t.clean(cx)),\n         }\n     }\n }\n@@ -983,18 +971,17 @@ pub enum ImplItem {\n }\n \n impl Clean<ImplItem> for ast::ImplItem {\n-    fn clean(&self) -> ImplItem {\n+    fn clean(&self, cx: &DocContext) -> ImplItem {\n         match self {\n-            &ast::MethodImplItem(ref t) => MethodImplItem(t.clean()),\n+            &ast::MethodImplItem(ref t) => MethodImplItem(t.clean(cx)),\n         }\n     }\n }\n \n impl Clean<Item> for ty::Method {\n-    fn clean(&self) -> Item {\n-        let cx = get_cx();\n+    fn clean(&self, cx: &DocContext) -> Item {\n         let (self_, sig) = match self.explicit_self {\n-            ty::StaticExplicitSelfCategory => (ast::SelfStatic.clean(),\n+            ty::StaticExplicitSelfCategory => (ast::SelfStatic.clean(cx),\n                                                self.fty.sig.clone()),\n             s => {\n                 let sig = ty::FnSig {\n@@ -1006,13 +993,13 @@ impl Clean<Item> for ty::Method {\n                     ty::ByReferenceExplicitSelfCategory(..) => {\n                         match ty::get(self.fty.sig.inputs[0]).sty {\n                             ty::ty_rptr(r, mt) => {\n-                                SelfBorrowed(r.clean(), mt.mutbl.clean())\n+                                SelfBorrowed(r.clean(cx), mt.mutbl.clean(cx))\n                             }\n                             _ => unreachable!(),\n                         }\n                     }\n                     ty::ByBoxExplicitSelfCategory => {\n-                        SelfExplicit(self.fty.sig.inputs[0].clean())\n+                        SelfExplicit(self.fty.sig.inputs[0].clean(cx))\n                     }\n                     ty::StaticExplicitSelfCategory => unreachable!(),\n                 };\n@@ -1021,26 +1008,26 @@ impl Clean<Item> for ty::Method {\n         };\n \n         Item {\n-            name: Some(self.ident.clean()),\n+            name: Some(self.ident.clean(cx)),\n             visibility: Some(ast::Inherited),\n-            stability: get_stability(self.def_id),\n+            stability: get_stability(cx, self.def_id),\n             def_id: self.def_id,\n-            attrs: inline::load_attrs(cx.tcx(), self.def_id),\n+            attrs: inline::load_attrs(cx, cx.tcx(), self.def_id),\n             source: Span::empty(),\n             inner: TyMethodItem(TyMethod {\n                 fn_style: self.fty.fn_style,\n-                generics: (&self.generics, subst::FnSpace).clean(),\n+                generics: (&self.generics, subst::FnSpace).clean(cx),\n                 self_: self_,\n-                decl: (self.def_id, &sig).clean(),\n+                decl: (self.def_id, &sig).clean(cx),\n             })\n         }\n     }\n }\n \n impl Clean<Item> for ty::ImplOrTraitItem {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         match *self {\n-            ty::MethodTraitItem(ref mti) => mti.clean(),\n+            ty::MethodTraitItem(ref mti) => mti.clean(cx),\n         }\n     }\n }\n@@ -1194,37 +1181,35 @@ impl Primitive {\n }\n \n impl Clean<Type> for ast::Ty {\n-    fn clean(&self) -> Type {\n+    fn clean(&self, cx: &DocContext) -> Type {\n         use syntax::ast::*;\n         match self.node {\n             TyNil => Primitive(Unit),\n-            TyPtr(ref m) => RawPointer(m.mutbl.clean(), box m.ty.clean()),\n+            TyPtr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n             TyRptr(ref l, ref m) =>\n-                BorrowedRef {lifetime: l.clean(), mutability: m.mutbl.clean(),\n-                             type_: box m.ty.clean()},\n-            TyBox(ty) => Managed(box ty.clean()),\n-            TyUniq(ty) => Unique(box ty.clean()),\n-            TyVec(ty) => Vector(box ty.clean()),\n-            TyFixedLengthVec(ty, ref e) => FixedVector(box ty.clean(),\n-                                                       e.span.to_src()),\n-            TyTup(ref tys) => Tuple(tys.iter().map(|x| x.clean()).collect()),\n+                BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n+                             type_: box m.ty.clean(cx)},\n+            TyBox(ty) => Managed(box ty.clean(cx)),\n+            TyUniq(ty) => Unique(box ty.clean(cx)),\n+            TyVec(ty) => Vector(box ty.clean(cx)),\n+            TyFixedLengthVec(ty, ref e) => FixedVector(box ty.clean(cx),\n+                                                       e.span.to_src(cx)),\n+            TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(ref p, ref tpbs, id) => {\n-                resolve_type(p.clean(),\n-                             tpbs.clean().map(|x| x),\n-                             id)\n+                resolve_type(cx, p.clean(cx), tpbs.clean(cx), id)\n             }\n-            TyClosure(ref c) => Closure(box c.clean()),\n-            TyProc(ref c) => Proc(box c.clean()),\n-            TyBareFn(ref barefn) => BareFunction(box barefn.clean()),\n-            TyParen(ref ty) => ty.clean(),\n+            TyClosure(ref c) => Closure(box c.clean(cx)),\n+            TyProc(ref c) => Proc(box c.clean(cx)),\n+            TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n+            TyParen(ref ty) => ty.clean(cx),\n             TyBot => Bottom,\n             ref x => fail!(\"Unimplemented type {:?}\", x),\n         }\n     }\n }\n \n impl Clean<Type> for ty::t {\n-    fn clean(&self) -> Type {\n+    fn clean(&self, cx: &DocContext) -> Type {\n         match ty::get(*self).sty {\n             ty::ty_bot => Bottom,\n             ty::ty_nil => Primitive(Unit),\n@@ -1244,41 +1229,41 @@ impl Clean<Type> for ty::t {\n             ty::ty_float(ast::TyF64) => Primitive(F64),\n             ty::ty_str => Primitive(Str),\n             ty::ty_box(t) => {\n-                let gc_did = get_cx().tcx_opt().and_then(|tcx| {\n+                let gc_did = cx.tcx_opt().and_then(|tcx| {\n                     tcx.lang_items.gc()\n                 });\n-                lang_struct(gc_did, t, \"Gc\", Managed)\n+                lang_struct(cx, gc_did, t, \"Gc\", Managed)\n             }\n             ty::ty_uniq(t) => {\n-                let box_did = get_cx().tcx_opt().and_then(|tcx| {\n+                let box_did = cx.tcx_opt().and_then(|tcx| {\n                     tcx.lang_items.owned_box()\n                 });\n-                lang_struct(box_did, t, \"Box\", Unique)\n+                lang_struct(cx, box_did, t, \"Box\", Unique)\n             }\n-            ty::ty_vec(ty, None) => Vector(box ty.clean()),\n-            ty::ty_vec(ty, Some(i)) => FixedVector(box ty.clean(),\n+            ty::ty_vec(ty, None) => Vector(box ty.clean(cx)),\n+            ty::ty_vec(ty, Some(i)) => FixedVector(box ty.clean(cx),\n                                                    format!(\"{}\", i)),\n-            ty::ty_ptr(mt) => RawPointer(mt.mutbl.clean(), box mt.ty.clean()),\n+            ty::ty_ptr(mt) => RawPointer(mt.mutbl.clean(cx), box mt.ty.clean(cx)),\n             ty::ty_rptr(r, mt) => BorrowedRef {\n-                lifetime: r.clean(),\n-                mutability: mt.mutbl.clean(),\n-                type_: box mt.ty.clean(),\n+                lifetime: r.clean(cx),\n+                mutability: mt.mutbl.clean(cx),\n+                type_: box mt.ty.clean(cx),\n             },\n             ty::ty_bare_fn(ref fty) => BareFunction(box BareFunctionDecl {\n                 fn_style: fty.fn_style,\n                 generics: Generics {\n                     lifetimes: Vec::new(), type_params: Vec::new()\n                 },\n-                decl: (ast_util::local_def(0), &fty.sig).clean(),\n+                decl: (ast_util::local_def(0), &fty.sig).clean(cx),\n                 abi: fty.abi.to_string(),\n             }),\n             ty::ty_closure(ref fty) => {\n                 let decl = box ClosureDecl {\n                     lifetimes: Vec::new(), // FIXME: this looks wrong...\n-                    decl: (ast_util::local_def(0), &fty.sig).clean(),\n+                    decl: (ast_util::local_def(0), &fty.sig).clean(cx),\n                     onceness: fty.onceness,\n                     fn_style: fty.fn_style,\n-                    bounds: fty.bounds.clean(),\n+                    bounds: fty.bounds.clean(cx),\n                 };\n                 match fty.store {\n                     ty::UniqTraitStore => Proc(decl),\n@@ -1288,7 +1273,7 @@ impl Clean<Type> for ty::t {\n             ty::ty_struct(did, ref substs) |\n             ty::ty_enum(did, ref substs) |\n             ty::ty_trait(box ty::TyTrait { def_id: did, ref substs, .. }) => {\n-                let fqn = csearch::get_item_path(get_cx().tcx(), did);\n+                let fqn = csearch::get_item_path(cx.tcx(), did);\n                 let fqn: Vec<String> = fqn.move_iter().map(|i| {\n                     i.to_string()\n                 }).collect();\n@@ -1297,17 +1282,16 @@ impl Clean<Type> for ty::t {\n                     ty::ty_trait(..) => TypeTrait,\n                     _ => TypeEnum,\n                 };\n-                let path = external_path(fqn.last().unwrap().to_string().as_slice(),\n+                let path = external_path(cx, fqn.last().unwrap().to_string().as_slice(),\n                                          substs);\n-                get_cx().external_paths.borrow_mut().as_mut().unwrap()\n-                                       .insert(did, (fqn, kind));\n+                cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n                 ResolvedPath {\n                     path: path,\n                     typarams: None,\n                     did: did,\n                 }\n             }\n-            ty::ty_tup(ref t) => Tuple(t.iter().map(|t| t.clean()).collect()),\n+            ty::ty_tup(ref t) => Tuple(t.clean(cx)),\n \n             ty::ty_param(ref p) => {\n                 if p.space == subst::SelfSpace {\n@@ -1333,59 +1317,54 @@ pub enum StructField {\n }\n \n impl Clean<Item> for ast::StructField {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         let (name, vis) = match self.node.kind {\n             ast::NamedField(id, vis) => (Some(id), vis),\n             ast::UnnamedField(vis) => (None, vis)\n         };\n         Item {\n-            name: name.clean(),\n-            attrs: self.node.attrs.clean(),\n-            source: self.span.clean(),\n+            name: name.clean(cx),\n+            attrs: self.node.attrs.clean(cx),\n+            source: self.span.clean(cx),\n             visibility: Some(vis),\n-            stability: get_stability(ast_util::local_def(self.node.id)),\n+            stability: get_stability(cx, ast_util::local_def(self.node.id)),\n             def_id: ast_util::local_def(self.node.id),\n-            inner: StructFieldItem(TypedStructField(self.node.ty.clean())),\n+            inner: StructFieldItem(TypedStructField(self.node.ty.clean(cx))),\n         }\n     }\n }\n \n impl Clean<Item> for ty::field_ty {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         use syntax::parse::token::special_idents::unnamed_field;\n         use rustc::metadata::csearch;\n \n-        let cx = get_cx();\n-        let attrs;\n-\n         let attr_map = csearch::get_struct_field_attrs(&cx.tcx().sess.cstore, self.id);\n \n-        let name = if self.name == unnamed_field.name {\n-            attrs = None;\n-            None\n+        let (name, attrs) = if self.name == unnamed_field.name {\n+            (None, None)\n         } else {\n-            attrs = Some(attr_map.find(&self.id.node).unwrap());\n-            Some(self.name)\n+            (Some(self.name), Some(attr_map.find(&self.id.node).unwrap()))\n         };\n \n         let ty = ty::lookup_item_type(cx.tcx(), self.id);\n \n         Item {\n-            name: name.clean(),\n-            attrs: attrs.unwrap_or(&Vec::new()).clean(),\n+            name: name.clean(cx),\n+            attrs: attrs.unwrap_or(&Vec::new()).clean(cx),\n             source: Span::empty(),\n             visibility: Some(self.vis),\n-            stability: get_stability(self.id),\n+            stability: get_stability(cx, self.id),\n             def_id: self.id,\n-            inner: StructFieldItem(TypedStructField(ty.ty.clean())),\n+            inner: StructFieldItem(TypedStructField(ty.ty.clean(cx))),\n         }\n     }\n }\n \n pub type Visibility = ast::Visibility;\n \n impl Clean<Option<Visibility>> for ast::Visibility {\n-    fn clean(&self) -> Option<Visibility> {\n+    fn clean(&self, _: &DocContext) -> Option<Visibility> {\n         Some(*self)\n     }\n }\n@@ -1399,18 +1378,18 @@ pub struct Struct {\n }\n \n impl Clean<Item> for doctree::Struct {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             inner: StructItem(Struct {\n                 struct_type: self.struct_type,\n-                generics: self.generics.clean(),\n-                fields: self.fields.clean(),\n+                generics: self.generics.clean(cx),\n+                fields: self.fields.clean(cx),\n                 fields_stripped: false,\n             }),\n         }\n@@ -1428,10 +1407,10 @@ pub struct VariantStruct {\n }\n \n impl Clean<VariantStruct> for syntax::ast::StructDef {\n-    fn clean(&self) -> VariantStruct {\n+    fn clean(&self, cx: &DocContext) -> VariantStruct {\n         VariantStruct {\n             struct_type: doctree::struct_type_from_def(self),\n-            fields: self.fields.clean(),\n+            fields: self.fields.clean(cx),\n             fields_stripped: false,\n         }\n     }\n@@ -1445,17 +1424,17 @@ pub struct Enum {\n }\n \n impl Clean<Item> for doctree::Enum {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             inner: EnumItem(Enum {\n-                variants: self.variants.clean(),\n-                generics: self.generics.clean(),\n+                variants: self.variants.clean(cx),\n+                generics: self.generics.clean(cx),\n                 variants_stripped: false,\n             }),\n         }\n@@ -1468,29 +1447,28 @@ pub struct Variant {\n }\n \n impl Clean<Item> for doctree::Variant {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             def_id: ast_util::local_def(self.id),\n             inner: VariantItem(Variant {\n-                kind: self.kind.clean(),\n+                kind: self.kind.clean(cx),\n             }),\n         }\n     }\n }\n \n impl Clean<Item> for ty::VariantInfo {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         // use syntax::parse::token::special_idents::unnamed_field;\n-        let cx = get_cx();\n         let kind = match self.arg_names.as_ref().map(|s| s.as_slice()) {\n             None | Some([]) if self.args.len() == 0 => CLikeVariant,\n             None | Some([]) => {\n-                TupleVariant(self.args.iter().map(|t| t.clean()).collect())\n+                TupleVariant(self.args.clean(cx))\n             }\n             Some(s) => {\n                 StructVariant(VariantStruct {\n@@ -1499,7 +1477,7 @@ impl Clean<Item> for ty::VariantInfo {\n                     fields: s.iter().zip(self.args.iter()).map(|(name, ty)| {\n                         Item {\n                             source: Span::empty(),\n-                            name: Some(name.clean()),\n+                            name: Some(name.clean(cx)),\n                             attrs: Vec::new(),\n                             visibility: Some(ast::Public),\n                             // FIXME: this is not accurate, we need an id for\n@@ -1510,23 +1488,23 @@ impl Clean<Item> for ty::VariantInfo {\n                             //        more infrastructure work before we can get\n                             //        at the needed information here.\n                             def_id: self.id,\n-                            stability: get_stability(self.id),\n+                            stability: get_stability(cx, self.id),\n                             inner: StructFieldItem(\n-                                TypedStructField(ty.clean())\n+                                TypedStructField(ty.clean(cx))\n                             )\n                         }\n                     }).collect()\n                 })\n             }\n         };\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: inline::load_attrs(cx.tcx(), self.id),\n+            name: Some(self.name.clean(cx)),\n+            attrs: inline::load_attrs(cx, cx.tcx(), self.id),\n             source: Span::empty(),\n             visibility: Some(ast::Public),\n             def_id: self.id,\n             inner: VariantItem(Variant { kind: kind }),\n-            stability: get_stability(self.id),\n+            stability: get_stability(cx, self.id),\n         }\n     }\n }\n@@ -1539,16 +1517,16 @@ pub enum VariantKind {\n }\n \n impl Clean<VariantKind> for ast::VariantKind {\n-    fn clean(&self) -> VariantKind {\n+    fn clean(&self, cx: &DocContext) -> VariantKind {\n         match self {\n             &ast::TupleVariantKind(ref args) => {\n                 if args.len() == 0 {\n                     CLikeVariant\n                 } else {\n-                    TupleVariant(args.iter().map(|x| x.ty.clean()).collect())\n+                    TupleVariant(args.iter().map(|x| x.ty.clean(cx)).collect())\n                 }\n             },\n-            &ast::StructVariantKind(ref sd) => StructVariant(sd.clean()),\n+            &ast::StructVariantKind(ref sd) => StructVariant(sd.clean(cx)),\n         }\n     }\n }\n@@ -1573,9 +1551,8 @@ impl Span {\n }\n \n impl Clean<Span> for syntax::codemap::Span {\n-    fn clean(&self) -> Span {\n-        let ctxt = super::ctxtkey.get().unwrap();\n-        let cm = ctxt.sess().codemap();\n+    fn clean(&self, cx: &DocContext) -> Span {\n+        let cm = cx.sess().codemap();\n         let filename = cm.span_to_filename(*self);\n         let lo = cm.lookup_char_pos(self.lo);\n         let hi = cm.lookup_char_pos(self.hi);\n@@ -1596,10 +1573,10 @@ pub struct Path {\n }\n \n impl Clean<Path> for ast::Path {\n-    fn clean(&self) -> Path {\n+    fn clean(&self, cx: &DocContext) -> Path {\n         Path {\n             global: self.global,\n-            segments: self.segments.clean(),\n+            segments: self.segments.clean(cx),\n         }\n     }\n }\n@@ -1612,11 +1589,11 @@ pub struct PathSegment {\n }\n \n impl Clean<PathSegment> for ast::PathSegment {\n-    fn clean(&self) -> PathSegment {\n+    fn clean(&self, cx: &DocContext) -> PathSegment {\n         PathSegment {\n-            name: self.identifier.clean(),\n-            lifetimes: self.lifetimes.clean(),\n-            types: self.types.clean(),\n+            name: self.identifier.clean(cx),\n+            lifetimes: self.lifetimes.clean(cx),\n+            types: self.types.clean(cx),\n         }\n     }\n }\n@@ -1636,13 +1613,13 @@ fn path_to_string(p: &ast::Path) -> String {\n }\n \n impl Clean<String> for ast::Ident {\n-    fn clean(&self) -> String {\n+    fn clean(&self, _: &DocContext) -> String {\n         token::get_ident(*self).get().to_string()\n     }\n }\n \n impl Clean<String> for ast::Name {\n-    fn clean(&self) -> String {\n+    fn clean(&self, _: &DocContext) -> String {\n         token::get_name(*self).get().to_string()\n     }\n }\n@@ -1654,17 +1631,17 @@ pub struct Typedef {\n }\n \n impl Clean<Item> for doctree::Typedef {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n             def_id: ast_util::local_def(self.id.clone()),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             inner: TypedefItem(Typedef {\n-                type_: self.ty.clean(),\n-                generics: self.gen.clean(),\n+                type_: self.ty.clean(cx),\n+                generics: self.gen.clean(cx),\n             }),\n         }\n     }\n@@ -1679,14 +1656,14 @@ pub struct BareFunctionDecl {\n }\n \n impl Clean<BareFunctionDecl> for ast::BareFnTy {\n-    fn clean(&self) -> BareFunctionDecl {\n+    fn clean(&self, cx: &DocContext) -> BareFunctionDecl {\n         BareFunctionDecl {\n             fn_style: self.fn_style,\n             generics: Generics {\n-                lifetimes: self.lifetimes.clean(),\n+                lifetimes: self.lifetimes.clean(cx),\n                 type_params: Vec::new(),\n             },\n-            decl: self.decl.clean(),\n+            decl: self.decl.clean(cx),\n             abi: self.abi.to_string(),\n         }\n     }\n@@ -1703,19 +1680,19 @@ pub struct Static {\n }\n \n impl Clean<Item> for doctree::Static {\n-    fn clean(&self) -> Item {\n-        debug!(\"claning static {}: {:?}\", self.name.clean(), self);\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        debug!(\"claning static {}: {:?}\", self.name.clean(cx), self);\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             inner: StaticItem(Static {\n-                type_: self.type_.clean(),\n-                mutability: self.mutability.clean(),\n-                expr: self.expr.span.to_src(),\n+                type_: self.type_.clean(cx),\n+                mutability: self.mutability.clean(cx),\n+                expr: self.expr.span.to_src(cx),\n             }),\n         }\n     }\n@@ -1728,7 +1705,7 @@ pub enum Mutability {\n }\n \n impl Clean<Mutability> for ast::Mutability {\n-    fn clean(&self) -> Mutability {\n+    fn clean(&self, _: &DocContext) -> Mutability {\n         match self {\n             &ast::MutMutable => Mutable,\n             &ast::MutImmutable => Immutable,\n@@ -1750,19 +1727,19 @@ fn detect_derived<M: AttrMetaMethods>(attrs: &[M]) -> bool {\n }\n \n impl Clean<Item> for doctree::Impl {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n             name: None,\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             inner: ImplItem(Impl {\n-                generics: self.generics.clean(),\n-                trait_: self.trait_.clean(),\n-                for_: self.for_.clean(),\n-                items: self.items.clean().move_iter().map(|ti| {\n+                generics: self.generics.clean(cx),\n+                trait_: self.trait_.clean(cx),\n+                for_: self.for_.clean(cx),\n+                items: self.items.clean(cx).move_iter().map(|ti| {\n                         match ti {\n                             MethodImplItem(i) => i,\n                         }\n@@ -1779,7 +1756,7 @@ pub struct ViewItem {\n }\n \n impl Clean<Vec<Item>> for ast::ViewItem {\n-    fn clean(&self) -> Vec<Item> {\n+    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         // We consider inlining the documentation of `pub use` statements, but we\n         // forcefully don't inline if this is not public or if the\n         // #[doc(no_inline)] attribute is present.\n@@ -1792,12 +1769,12 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n         let convert = |node: &ast::ViewItem_| {\n             Item {\n                 name: None,\n-                attrs: self.attrs.clean(),\n-                source: self.span.clean(),\n+                attrs: self.attrs.clean(cx),\n+                source: self.span.clean(cx),\n                 def_id: ast_util::local_def(0),\n-                visibility: self.vis.clean(),\n+                visibility: self.vis.clean(cx),\n                 stability: None,\n-                inner: ViewItemItem(ViewItem { inner: node.clean() }),\n+                inner: ViewItemItem(ViewItem { inner: node.clean(cx) }),\n             }\n         };\n         let mut ret = Vec::new();\n@@ -1810,7 +1787,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                         // to keep any non-inlineable reexports so they can be\n                         // listed in the documentation.\n                         let remaining = list.iter().filter(|path| {\n-                            match inline::try_inline(path.node.id(), None) {\n+                            match inline::try_inline(cx, path.node.id(), None) {\n                                 Some(items) => {\n                                     ret.extend(items.move_iter()); false\n                                 }\n@@ -1826,7 +1803,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                         }\n                     }\n                     ast::ViewPathSimple(ident, _, id) => {\n-                        match inline::try_inline(id, Some(ident)) {\n+                        match inline::try_inline(cx, id, Some(ident)) {\n                             Some(items) => ret.extend(items.move_iter()),\n                             None => ret.push(convert(&self.node)),\n                         }\n@@ -1846,17 +1823,17 @@ pub enum ViewItemInner {\n }\n \n impl Clean<ViewItemInner> for ast::ViewItem_ {\n-    fn clean(&self) -> ViewItemInner {\n+    fn clean(&self, cx: &DocContext) -> ViewItemInner {\n         match self {\n             &ast::ViewItemExternCrate(ref i, ref p, ref id) => {\n                 let string = match *p {\n                     None => None,\n                     Some((ref x, _)) => Some(x.get().to_string()),\n                 };\n-                ExternCrate(i.clean(), string, *id)\n+                ExternCrate(i.clean(cx), string, *id)\n             }\n             &ast::ViewItemUse(ref vp) => {\n-                Import(vp.clean())\n+                Import(vp.clean(cx))\n             }\n         }\n     }\n@@ -1879,15 +1856,15 @@ pub struct ImportSource {\n }\n \n impl Clean<ViewPath> for ast::ViewPath {\n-    fn clean(&self) -> ViewPath {\n+    fn clean(&self, cx: &DocContext) -> ViewPath {\n         match self.node {\n             ast::ViewPathSimple(ref i, ref p, id) =>\n-                SimpleImport(i.clean(), resolve_use_source(p.clean(), id)),\n+                SimpleImport(i.clean(cx), resolve_use_source(cx, p.clean(cx), id)),\n             ast::ViewPathGlob(ref p, id) =>\n-                GlobImport(resolve_use_source(p.clean(), id)),\n+                GlobImport(resolve_use_source(cx, p.clean(cx), id)),\n             ast::ViewPathList(ref p, ref pl, id) => {\n-                ImportList(resolve_use_source(p.clean(), id),\n-                           pl.clean())\n+                ImportList(resolve_use_source(cx, p.clean(cx), id),\n+                           pl.clean(cx))\n             }\n         }\n     }\n@@ -1900,51 +1877,51 @@ pub struct ViewListIdent {\n }\n \n impl Clean<ViewListIdent> for ast::PathListItem {\n-    fn clean(&self) -> ViewListIdent {\n+    fn clean(&self, cx: &DocContext) -> ViewListIdent {\n         match self.node {\n             ast::PathListIdent { id, name } => ViewListIdent {\n-                name: name.clean(),\n-                source: resolve_def(id)\n+                name: name.clean(cx),\n+                source: resolve_def(cx, id)\n             },\n             ast::PathListMod { id } => ViewListIdent {\n                 name: \"mod\".to_string(),\n-                source: resolve_def(id)\n+                source: resolve_def(cx, id)\n             }\n         }\n     }\n }\n \n impl Clean<Vec<Item>> for ast::ForeignMod {\n-    fn clean(&self) -> Vec<Item> {\n-        self.items.clean()\n+    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n+        self.items.clean(cx)\n     }\n }\n \n impl Clean<Item> for ast::ForeignItem {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n             ast::ForeignItemFn(ref decl, ref generics) => {\n                 ForeignFunctionItem(Function {\n-                    decl: decl.clean(),\n-                    generics: generics.clean(),\n+                    decl: decl.clean(cx),\n+                    generics: generics.clean(cx),\n                     fn_style: ast::UnsafeFn,\n                 })\n             }\n             ast::ForeignItemStatic(ref ty, mutbl) => {\n                 ForeignStaticItem(Static {\n-                    type_: ty.clean(),\n+                    type_: ty.clean(cx),\n                     mutability: if mutbl {Mutable} else {Immutable},\n                     expr: \"\".to_string(),\n                 })\n             }\n         };\n         Item {\n-            name: Some(self.ident.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.span.clean(),\n+            name: Some(self.ident.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.span.clean(cx),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.vis.clean(),\n-            stability: get_stability(ast_util::local_def(self.id)),\n+            visibility: self.vis.clean(cx),\n+            stability: get_stability(cx, ast_util::local_def(self.id)),\n             inner: inner,\n         }\n     }\n@@ -1953,15 +1930,13 @@ impl Clean<Item> for ast::ForeignItem {\n // Utilities\n \n trait ToSource {\n-    fn to_src(&self) -> String;\n+    fn to_src(&self, cx: &DocContext) -> String;\n }\n \n impl ToSource for syntax::codemap::Span {\n-    fn to_src(&self) -> String {\n-        debug!(\"converting span {:?} to snippet\", self.clean());\n-        let ctxt = super::ctxtkey.get().unwrap();\n-        let cm = ctxt.sess().codemap().clone();\n-        let sn = match cm.span_to_snippet(*self) {\n+    fn to_src(&self, cx: &DocContext) -> String {\n+        debug!(\"converting span {:?} to snippet\", self.clean(cx));\n+        let sn = match cx.sess().codemap().span_to_snippet(*self) {\n             Some(x) => x.to_string(),\n             None    => \"\".to_string()\n         };\n@@ -2030,16 +2005,16 @@ fn name_from_pat(p: &ast::Pat) -> String {\n }\n \n /// Given a Type, resolve it using the def_map\n-fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n+fn resolve_type(cx: &DocContext, path: Path,\n+                tpbs: Option<Vec<TyParamBound>>,\n                 id: ast::NodeId) -> Type {\n-    let cx = get_cx();\n-    let tycx = match cx.maybe_typed {\n-        core::Typed(ref tycx) => tycx,\n+    let tcx = match cx.tcx_opt() {\n+        Some(tcx) => tcx,\n         // If we're extracting tests, this return value doesn't matter.\n-        core::NotTyped(_) => return Primitive(Bool),\n+        None => return Primitive(Bool),\n     };\n     debug!(\"searching for {:?} in defmap\", id);\n-    let def = match tycx.def_map.borrow().find(&id) {\n+    let def = match tcx.def_map.borrow().find(&id) {\n         Some(&k) => k,\n         None => fail!(\"unresolved id not in defmap\")\n     };\n@@ -2071,7 +2046,7 @@ fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n     ResolvedPath { path: path, typarams: tpbs, did: did }\n }\n \n-fn register_def(cx: &core::DocContext, def: def::Def) -> ast::DefId {\n+fn register_def(cx: &DocContext, def: def::Def) -> ast::DefId {\n     let (did, kind) = match def {\n         def::DefFn(i, _) => (i, TypeFunction),\n         def::DefTy(i) => (i, TypeEnum),\n@@ -2083,31 +2058,31 @@ fn register_def(cx: &core::DocContext, def: def::Def) -> ast::DefId {\n         _ => return def.def_id()\n     };\n     if ast_util::is_local(did) { return did }\n-    let tcx = match cx.maybe_typed {\n-        core::Typed(ref t) => t,\n-        core::NotTyped(_) => return did\n+    let tcx = match cx.tcx_opt() {\n+        Some(tcx) => tcx,\n+        None => return did\n     };\n     inline::record_extern_fqn(cx, did, kind);\n     match kind {\n         TypeTrait => {\n-            let t = inline::build_external_trait(tcx, did);\n+            let t = inline::build_external_trait(cx, tcx, did);\n             cx.external_traits.borrow_mut().as_mut().unwrap().insert(did, t);\n         }\n         _ => {}\n     }\n     return did;\n }\n \n-fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n+fn resolve_use_source(cx: &DocContext, path: Path, id: ast::NodeId) -> ImportSource {\n     ImportSource {\n         path: path,\n-        did: resolve_def(id),\n+        did: resolve_def(cx, id),\n     }\n }\n \n-fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n-    get_cx().tcx_opt().and_then(|tcx| {\n-        tcx.def_map.borrow().find(&id).map(|&def| register_def(&*get_cx(), def))\n+fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<ast::DefId> {\n+    cx.tcx_opt().and_then(|tcx| {\n+        tcx.def_map.borrow().find(&id).map(|&def| register_def(cx, def))\n     })\n }\n \n@@ -2117,16 +2092,16 @@ pub struct Macro {\n }\n \n impl Clean<Item> for doctree::Macro {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(format!(\"{}!\", self.name.clean())),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n-            visibility: ast::Public.clean(),\n-            stability: self.stab.clean(),\n+            name: Some(format!(\"{}!\", self.name.clean(cx))),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            visibility: ast::Public.clean(cx),\n+            stability: self.stab.clean(cx),\n             def_id: ast_util::local_def(self.id),\n             inner: MacroItem(Macro {\n-                source: self.whence.to_src(),\n+                source: self.whence.to_src(cx),\n             }),\n         }\n     }\n@@ -2139,7 +2114,7 @@ pub struct Stability {\n }\n \n impl Clean<Stability> for attr::Stability {\n-    fn clean(&self) -> Stability {\n+    fn clean(&self, _: &DocContext) -> Stability {\n         Stability {\n             level: self.level,\n             text: self.text.as_ref().map_or(\"\".to_string(),\n@@ -2148,18 +2123,18 @@ impl Clean<Stability> for attr::Stability {\n     }\n }\n \n-fn lang_struct(did: Option<ast::DefId>, t: ty::t, name: &str,\n+fn lang_struct(cx: &DocContext, did: Option<ast::DefId>,\n+               t: ty::t, name: &str,\n                fallback: fn(Box<Type>) -> Type) -> Type {\n     let did = match did {\n         Some(did) => did,\n-        None => return fallback(box t.clean()),\n+        None => return fallback(box t.clean(cx)),\n     };\n-    let fqn = csearch::get_item_path(get_cx().tcx(), did);\n+    let fqn = csearch::get_item_path(cx.tcx(), did);\n     let fqn: Vec<String> = fqn.move_iter().map(|i| {\n         i.to_string()\n     }).collect();\n-    get_cx().external_paths.borrow_mut().as_mut().unwrap()\n-                           .insert(did, (fqn, TypeStruct));\n+    cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, TypeStruct));\n     ResolvedPath {\n         typarams: None,\n         did: did,\n@@ -2168,7 +2143,7 @@ fn lang_struct(did: Option<ast::DefId>, t: ty::t, name: &str,\n             segments: vec![PathSegment {\n                 name: name.to_string(),\n                 lifetimes: vec![],\n-                types: vec![t.clean()],\n+                types: vec![t.clean(cx)],\n             }],\n         },\n     }"}, {"sha": "a8cd9f18d60a52b152a1a3bdaba9cea57be42b74", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -22,23 +22,24 @@ use std::cell::RefCell;\n use std::gc::GC;\n use std::os;\n use std::collections::{HashMap, HashSet};\n+use arena::TypedArena;\n \n use visit_ast::RustdocVisitor;\n use clean;\n use clean::Clean;\n \n /// Are we generating documentation (`Typed`) or tests (`NotTyped`)?\n-pub enum MaybeTyped {\n-    Typed(middle::ty::ctxt),\n+pub enum MaybeTyped<'tcx> {\n+    Typed(middle::ty::ctxt<'tcx>),\n     NotTyped(driver::session::Session)\n }\n \n pub type ExternalPaths = RefCell<Option<HashMap<ast::DefId,\n                                                 (Vec<String>, clean::TypeKind)>>>;\n \n-pub struct DocContext {\n+pub struct DocContext<'tcx> {\n     pub krate: ast::Crate,\n-    pub maybe_typed: MaybeTyped,\n+    pub maybe_typed: MaybeTyped<'tcx>,\n     pub src: Path,\n     pub external_paths: ExternalPaths,\n     pub external_traits: RefCell<Option<HashMap<ast::DefId, clean::Trait>>>,\n@@ -47,22 +48,22 @@ pub struct DocContext {\n     pub populated_crate_impls: RefCell<HashSet<ast::CrateNum>>,\n }\n \n-impl DocContext {\n+impl<'tcx> DocContext<'tcx> {\n     pub fn sess<'a>(&'a self) -> &'a driver::session::Session {\n         match self.maybe_typed {\n             Typed(ref tcx) => &tcx.sess,\n             NotTyped(ref sess) => sess\n         }\n     }\n \n-    pub fn tcx_opt<'a>(&'a self) -> Option<&'a ty::ctxt> {\n+    pub fn tcx_opt<'a>(&'a self) -> Option<&'a ty::ctxt<'tcx>> {\n         match self.maybe_typed {\n             Typed(ref tcx) => Some(tcx),\n             NotTyped(_) => None\n         }\n     }\n \n-    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         let tcx_opt = self.tcx_opt();\n         tcx_opt.expect(\"tcx not present\")\n     }\n@@ -80,9 +81,10 @@ pub struct CrateAnalysis {\n pub type Externs = HashMap<String, Vec<String>>;\n \n /// Parses, resolves, and typechecks the given crate\n-fn get_ast_and_resolve(cpath: &Path, libs: Vec<Path>, cfgs: Vec<String>,\n-                       externs: Externs, triple: Option<String>)\n-                       -> (DocContext, CrateAnalysis) {\n+fn get_ast_and_resolve<'tcx>(cpath: &Path, libs: Vec<Path>, cfgs: Vec<String>,\n+                             externs: Externs, triple: Option<String>,\n+                             type_arena: &'tcx TypedArena<ty::t_box_>)\n+                             -> (DocContext<'tcx>, CrateAnalysis) {\n     use syntax::codemap::dummy_spanned;\n     use rustc::driver::driver::{FileInput,\n                                 phase_1_parse_input,\n@@ -131,7 +133,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: Vec<Path>, cfgs: Vec<String>,\n \n     let driver::driver::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n-    } = phase_3_run_analysis_passes(sess, &krate, ast_map, name);\n+    } = phase_3_run_analysis_passes(sess, &krate, ast_map, type_arena, name);\n \n     debug!(\"crate: {:?}\", krate);\n     (DocContext {\n@@ -156,14 +158,14 @@ fn get_ast_and_resolve(cpath: &Path, libs: Vec<Path>, cfgs: Vec<String>,\n pub fn run_core(libs: Vec<Path>, cfgs: Vec<String>, externs: Externs,\n                 path: &Path, triple: Option<String>)\n                 -> (clean::Crate, CrateAnalysis) {\n-    let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs, externs, triple);\n-    let ctxt = box(GC) ctxt;\n-    super::ctxtkey.replace(Some(ctxt));\n+    let type_arena = TypedArena::new();\n+    let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs, externs,\n+                                               triple, &type_arena);\n \n     let krate = {\n-        let mut v = RustdocVisitor::new(&*ctxt, Some(&analysis));\n+        let mut v = RustdocVisitor::new(&ctxt, Some(&analysis));\n         v.visit(&ctxt.krate);\n-        v.clean()\n+        v.clean(&ctxt)\n     };\n \n     let external_paths = ctxt.external_paths.borrow_mut().take();"}, {"sha": "758af6758c2c47db92c8cbe8f071a171d396986b", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -17,6 +17,7 @@\n \n #![feature(globs, struct_variant, managed_boxes, macro_rules, phase)]\n \n+extern crate arena;\n extern crate debug;\n extern crate getopts;\n extern crate libc;\n@@ -29,7 +30,6 @@ extern crate time;\n \n use std::io;\n use std::io::{File, MemWriter};\n-use std::gc::Gc;\n use std::collections::HashMap;\n use serialize::{json, Decodable, Encodable};\n use externalfiles::ExternalHtml;\n@@ -83,7 +83,6 @@ static DEFAULT_PASSES: &'static [&'static str] = &[\n     \"unindent-comments\",\n ];\n \n-local_data_key!(pub ctxtkey: Gc<core::DocContext>)\n local_data_key!(pub analysiskey: core::CrateAnalysis)\n \n type Output = (clean::Crate, Vec<plugins::PluginJson> );"}, {"sha": "0eb0a9afd751cad7c1791d844ac8061e1f05ae82", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -74,7 +74,7 @@ pub fn run(input: &str,\n                                                           \"rustdoc-test\", None)\n         .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n-    let ctx = box(GC) core::DocContext {\n+    let ctx = core::DocContext {\n         krate: krate,\n         maybe_typed: core::NotTyped(sess),\n         src: input_path,\n@@ -84,11 +84,10 @@ pub fn run(input: &str,\n         inlined: RefCell::new(None),\n         populated_crate_impls: RefCell::new(HashSet::new()),\n     };\n-    super::ctxtkey.replace(Some(ctx));\n \n-    let mut v = RustdocVisitor::new(&*ctx, None);\n+    let mut v = RustdocVisitor::new(&ctx, None);\n     v.visit(&ctx.krate);\n-    let mut krate = v.clean();\n+    let mut krate = v.clean(&ctx);\n     match crate_name {\n         Some(name) => krate.name = name,\n         None => {}"}, {"sha": "79576cac20af3b759b532b7bdb75eecd47028266", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c73e5fc5f212d30bb46b96cb45b51251217a199/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=0c73e5fc5f212d30bb46b96cb45b51251217a199", "patch": "@@ -34,16 +34,16 @@ use doctree::*;\n // also, is there some reason that this doesn't use the 'visit'\n // framework from syntax?\n \n-pub struct RustdocVisitor<'a> {\n+pub struct RustdocVisitor<'a, 'tcx: 'a> {\n     pub module: Module,\n     pub attrs: Vec<ast::Attribute>,\n-    pub cx: &'a core::DocContext,\n+    pub cx: &'a core::DocContext<'tcx>,\n     pub analysis: Option<&'a core::CrateAnalysis>,\n }\n \n-impl<'a> RustdocVisitor<'a> {\n-    pub fn new<'b>(cx: &'b core::DocContext,\n-                   analysis: Option<&'b core::CrateAnalysis>) -> RustdocVisitor<'b> {\n+impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n+    pub fn new(cx: &'a core::DocContext<'tcx>,\n+               analysis: Option<&'a core::CrateAnalysis>) -> RustdocVisitor<'a, 'tcx> {\n         RustdocVisitor {\n             module: Module::new(None),\n             attrs: Vec::new(),\n@@ -53,11 +53,7 @@ impl<'a> RustdocVisitor<'a> {\n     }\n \n     fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n-        let tcx = match self.cx.maybe_typed {\n-            core::Typed(ref tcx) => tcx,\n-            core::NotTyped(_) => return None\n-        };\n-        stability::lookup(tcx, ast_util::local_def(id))\n+        self.cx.tcx_opt().and_then(|tcx| stability::lookup(tcx, ast_util::local_def(id)))\n     }\n \n     pub fn visit(&mut self, krate: &ast::Crate) {\n@@ -225,9 +221,9 @@ impl<'a> RustdocVisitor<'a> {\n \n     fn resolve_id(&mut self, id: ast::NodeId, renamed: Option<ast::Ident>,\n                   glob: bool, om: &mut Module, please_inline: bool) -> bool {\n-        let tcx = match self.cx.maybe_typed {\n-            core::Typed(ref tcx) => tcx,\n-            core::NotTyped(_) => return false\n+        let tcx = match self.cx.tcx_opt() {\n+            Some(tcx) => tcx,\n+            None => return false\n         };\n         let def = (*tcx.def_map.borrow())[id].def_id();\n         if !ast_util::is_local(def) { return false }"}]}