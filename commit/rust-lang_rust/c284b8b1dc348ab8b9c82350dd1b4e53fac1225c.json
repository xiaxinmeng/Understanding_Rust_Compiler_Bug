{"sha": "c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyODRiOGIxZGMzNDhhYjhiOWM4MjM1MGRkMWI0ZTUzZmFjMTIyNWM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-24T22:28:43Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-24T22:51:16Z"}, "message": "Start using core::path2::Path in a lot of places.", "tree": {"sha": "99de39b149969275f6f9ddebd7a9f555d91c5bff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99de39b149969275f6f9ddebd7a9f555d91c5bff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "html_url": "https://github.com/rust-lang/rust/commit/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8f1bee4574b8427a052e2fad93a90839288584b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8f1bee4574b8427a052e2fad93a90839288584b", "html_url": "https://github.com/rust-lang/rust/commit/a8f1bee4574b8427a052e2fad93a90839288584b"}], "stats": {"total": 2246, "additions": 1135, "deletions": 1111}, "files": [{"sha": "abd50520f5024d1d55f8b0d6cb51623b0be93284", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 242, "deletions": 235, "changes": 477, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -43,12 +43,12 @@ type source = @{\n \n type cargo = {\n     pgp: bool,\n-    root: ~str,\n-    installdir: ~str,\n-    bindir: ~str,\n-    libdir: ~str,\n-    workdir: ~str,\n-    sourcedir: ~str,\n+    root: Path,\n+    installdir: Path,\n+    bindir: Path,\n+    libdir: Path,\n+    workdir: Path,\n+    sourcedir: Path,\n     sources: map::hashmap<~str, source>,\n     mut current_install: ~str,\n     dep_cache: map::hashmap<~str, bool>,\n@@ -185,7 +185,7 @@ fn has_archive_extension(p: ~str) -> bool {\n }\n \n fn is_archive_path(u: ~str) -> bool {\n-    has_archive_extension(u) && os::path_exists(u)\n+    has_archive_extension(u) && os::path_exists(&Path(u))\n }\n \n fn is_archive_url(u: ~str) -> bool {\n@@ -209,7 +209,7 @@ fn assume_source_method(url: ~str) -> ~str {\n     if is_git_url(url) {\n         return ~\"git\";\n     }\n-    if str::starts_with(url, ~\"file://\") || os::path_exists(url) {\n+    if str::starts_with(url, ~\"file://\") || os::path_exists(&Path(url)) {\n         return ~\"file\";\n     }\n \n@@ -238,7 +238,7 @@ fn load_link(mis: ~[@ast::meta_item]) -> (option<~str>,\n     (name, vers, uuid)\n }\n \n-fn load_crate(filename: ~str) -> option<crate> {\n+fn load_crate(filename: &Path) -> option<crate> {\n     let sess = parse::new_parse_sess(none);\n     let c = parse::parse_crate_from_crate_file(filename, ~[], sess);\n \n@@ -368,10 +368,10 @@ fn rest(s: ~str, start: uint) -> ~str {\n     }\n }\n \n-fn need_dir(s: ~str) {\n+fn need_dir(s: &Path) {\n     if os::path_is_dir(s) { return; }\n     if !os::make_dir(s, 493_i32 /* oct: 755 */) {\n-        fail fmt!(\"can't make_dir %s\", s);\n+        fail fmt!(\"can't make_dir %s\", s.to_str());\n     }\n }\n \n@@ -411,7 +411,7 @@ fn parse_source(name: ~str, j: json::json) -> source {\n                 _ => none\n             };\n             if method == ~\"file\" {\n-                url = os::make_absolute(url);\n+                url = os::make_absolute(&Path(url)).to_str();\n             }\n             return @{\n                 name: name,\n@@ -425,7 +425,7 @@ fn parse_source(name: ~str, j: json::json) -> source {\n     };\n }\n \n-fn try_parse_sources(filename: ~str, sources: map::hashmap<~str, source>) {\n+fn try_parse_sources(filename: &Path, sources: map::hashmap<~str, source>) {\n     if !os::path_exists(filename)  { return; }\n     let c = io::read_whole_file_str(filename);\n     match json::from_str(result::get(c)) {\n@@ -436,7 +436,7 @@ fn try_parse_sources(filename: ~str, sources: map::hashmap<~str, source>) {\n             }\n         }\n         ok(_) => fail ~\"malformed sources.json\",\n-        err(e) => fail fmt!(\"%s:%s\", filename, e.to_str())\n+        err(e) => fail fmt!(\"%s:%s\", filename.to_str(), e.to_str())\n     }\n }\n \n@@ -543,10 +543,10 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n }\n \n fn load_source_info(c: cargo, src: source) {\n-    let dir = path::connect(c.sourcedir, src.name);\n-    let srcfile = path::connect(dir, ~\"source.json\");\n-    if !os::path_exists(srcfile) { return; }\n-    let srcstr = io::read_whole_file_str(srcfile);\n+    let dir = c.sourcedir.push(src.name);\n+    let srcfile = dir.push(\"source.json\");\n+    if !os::path_exists(&srcfile) { return; }\n+    let srcstr = io::read_whole_file_str(&srcfile);\n     match json::from_str(result::get(srcstr)) {\n         ok(json::dict(s)) => {\n             let o = parse_source(src.name, json::dict(s));\n@@ -565,10 +565,10 @@ fn load_source_info(c: cargo, src: source) {\n }\n fn load_source_packages(c: cargo, src: source) {\n     log(debug, ~\"loading source: \" + src.name);\n-    let dir = path::connect(c.sourcedir, src.name);\n-    let pkgfile = path::connect(dir, ~\"packages.json\");\n-    if !os::path_exists(pkgfile) { return; }\n-    let pkgstr = io::read_whole_file_str(pkgfile);\n+    let dir = c.sourcedir.push(src.name);\n+    let pkgfile = dir.push(\"packages.json\");\n+    if !os::path_exists(&pkgfile) { return; }\n+    let pkgstr = io::read_whole_file_str(&pkgfile);\n     match json::from_str(result::get(pkgstr)) {\n         ok(json::list(js)) => {\n           for (*js).each |j| {\n@@ -639,31 +639,31 @@ fn configure(opts: options) -> cargo {\n     let p = result::get(get_cargo_dir());\n \n     let sources = map::str_hash();\n-    try_parse_sources(path::connect(home, ~\"sources.json\"), sources);\n-    try_parse_sources(path::connect(home, ~\"local-sources.json\"), sources);\n+    try_parse_sources(&home.push(\"sources.json\"), sources);\n+    try_parse_sources(&home.push(\"local-sources.json\"), sources);\n \n     let dep_cache = map::str_hash();\n \n     let mut c = {\n         pgp: pgp::supported(),\n         root: home,\n         installdir: p,\n-        bindir: path::connect(p, ~\"bin\"),\n-        libdir: path::connect(p, ~\"lib\"),\n-        workdir: path::connect(p, ~\"work\"),\n-        sourcedir: path::connect(home, ~\"sources\"),\n+        bindir: p.push(\"bin\"),\n+        libdir: p.push(\"lib\"),\n+        workdir: p.push(\"work\"),\n+        sourcedir: home.push(\"sources\"),\n         sources: sources,\n         mut current_install: ~\"\",\n         dep_cache: dep_cache,\n         opts: opts\n     };\n \n-    need_dir(c.root);\n-    need_dir(c.installdir);\n-    need_dir(c.sourcedir);\n-    need_dir(c.workdir);\n-    need_dir(c.libdir);\n-    need_dir(c.bindir);\n+    need_dir(&c.root);\n+    need_dir(&c.installdir);\n+    need_dir(&c.sourcedir);\n+    need_dir(&c.workdir);\n+    need_dir(&c.libdir);\n+    need_dir(&c.bindir);\n \n     for sources.each_key |k| {\n         let mut s = sources.get(k);\n@@ -672,7 +672,7 @@ fn configure(opts: options) -> cargo {\n     }\n \n     if c.pgp {\n-        pgp::init(c.root);\n+        pgp::init(&c.root);\n     } else {\n         warn(~\"command `gpg` was not found\");\n         warn(~\"you have to install gpg from source \" +\n@@ -694,60 +694,67 @@ fn for_each_package(c: cargo, b: fn(source, package)) {\n }\n \n // Runs all programs in directory <buildpath>\n-fn run_programs(buildpath: ~str) {\n+fn run_programs(buildpath: &Path) {\n     let newv = os::list_dir_path(buildpath);\n     for newv.each |ct| {\n-        run::run_program(ct, ~[]);\n+        run::run_program(ct.to_str(), ~[]);\n     }\n }\n \n // Runs rustc in <path + subdir> with the given flags\n-// and returns <path + subdir>\n-fn run_in_buildpath(what: ~str, path: ~str, subdir: ~str, cf: ~str,\n-                    extra_flags: ~[~str]) -> option<~str> {\n-    let buildpath = path::connect(path, subdir);\n-    need_dir(buildpath);\n-    debug!(\"%s: %s -> %s\", what, cf, buildpath);\n+// and returns <patho + subdir>\n+fn run_in_buildpath(what: &str, path: &Path, subdir: &Path, cf: &Path,\n+                    extra_flags: ~[~str]) -> option<Path> {\n+    let buildpath = path.push_rel(subdir);\n+    need_dir(&buildpath);\n+    debug!(\"%s: %s -> %s\", what, cf.to_str(), buildpath.to_str());\n     let p = run::program_output(rustc_sysroot(),\n-                                ~[~\"--out-dir\", buildpath, cf] + extra_flags);\n+                                ~[~\"--out-dir\",\n+                                  buildpath.to_str(),\n+                                  cf.to_str()] + extra_flags);\n     if p.status != 0 {\n         error(fmt!(\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out));\n         return none;\n     }\n     some(buildpath)\n }\n \n-fn test_one_crate(_c: cargo, path: ~str, cf: ~str) {\n-  let buildpath = match run_in_buildpath(~\"testing\", path, ~\"/test\", cf,\n-                                       ~[ ~\"--test\"]) {\n+fn test_one_crate(_c: cargo, path: &Path, cf: &Path) {\n+    let buildpath = match run_in_buildpath(~\"testing\", path,\n+                                           &Path(\"test\"),\n+                                           cf,\n+                                           ~[ ~\"--test\"]) {\n       none => return,\n-      some(bp) => bp\n+    some(bp) => bp\n   };\n-  run_programs(buildpath);\n+  run_programs(&buildpath);\n }\n \n-fn install_one_crate(c: cargo, path: ~str, cf: ~str) {\n+fn install_one_crate(c: cargo, path: &Path, cf: &Path) {\n     let buildpath = match run_in_buildpath(~\"installing\", path,\n-                                         ~\"/build\", cf, ~[]) {\n+                                           &Path(\"build\"),\n+                                           cf, ~[]) {\n       none => return,\n       some(bp) => bp\n     };\n-    let newv = os::list_dir_path(buildpath);\n+    let newv = os::list_dir_path(&buildpath);\n     let exec_suffix = os::exe_suffix();\n     for newv.each |ct| {\n-        if (exec_suffix != ~\"\" && str::ends_with(ct, exec_suffix)) ||\n-            (exec_suffix == ~\"\" && !str::starts_with(path::basename(ct),\n-                                                    ~\"lib\")) {\n-            debug!(\"  bin: %s\", ct);\n-            install_to_dir(ct, c.bindir);\n+        if (exec_suffix != ~\"\" && str::ends_with(ct.to_str(),\n+                                                 exec_suffix)) ||\n+            (exec_suffix == ~\"\" &&\n+             !str::starts_with(option::get(ct.filename()),\n+                               ~\"lib\")) {\n+            debug!(\"  bin: %s\", ct.to_str());\n+            install_to_dir(ct, &c.bindir);\n             if c.opts.mode == system_mode {\n                 // FIXME (#2662): Put this file in PATH / symlink it so it can\n                 // be used as a generic executable\n                 // `cargo install -G rustray` and `rustray file.obj`\n             }\n         } else {\n-            debug!(\"  lib: %s\", ct);\n-            install_to_dir(ct, c.libdir);\n+            debug!(\"  lib: %s\", ct.to_str());\n+            install_to_dir(ct, &c.libdir);\n         }\n     }\n }\n@@ -756,23 +763,22 @@ fn install_one_crate(c: cargo, path: ~str, cf: ~str) {\n fn rustc_sysroot() -> ~str {\n     match os::self_exe_path() {\n         some(path) => {\n-            let path = ~[path, ~\"..\", ~\"bin\", ~\"rustc\"];\n-            let rustc = path::normalize(path::connect_many(path));\n-            debug!(\"  rustc: %s\", rustc);\n-            rustc\n+            let rustc = path.push_many([~\"..\", ~\"bin\", ~\"rustc\"]);\n+            debug!(\"  rustc: %s\", rustc.to_str());\n+            rustc.to_str()\n         }\n         none => ~\"rustc\"\n     }\n }\n \n-fn install_source(c: cargo, path: ~str) {\n-    debug!(\"source: %s\", path);\n+fn install_source(c: cargo, path: &Path) {\n+    debug!(\"source: %s\", path.to_str());\n     os::change_dir(path);\n \n     let mut cratefiles = ~[];\n-    for os::walk_dir(~\".\") |p| {\n-        if str::ends_with(p, ~\".rc\") {\n-            vec::push(cratefiles, p);\n+    for os::walk_dir(&Path(\".\")) |p| {\n+        if p.filetype() == some(~\"rc\") {\n+            vec::push(cratefiles, *p);\n         }\n     }\n \n@@ -781,36 +787,31 @@ fn install_source(c: cargo, path: ~str) {\n     }\n \n     for cratefiles.each |cf| {\n-        match load_crate(cf) {\n+        match load_crate(&cf) {\n             none => again,\n             some(crate) => {\n               for crate.deps.each |query| {\n                     // FIXME (#1356): handle cyclic dependencies\n                     // (n.b. #1356 says \"Cyclic dependency is an error\n                     // condition\")\n \n-                    let wd_base = c.workdir + path::path_sep();\n-                    let wd = match tempfile::mkdtemp(wd_base, ~\"\") {\n-                        some(wd) => wd,\n-                        none => fail fmt!(\"needed temp dir: %s\", wd_base)\n-                    };\n-\n-                    install_query(c, wd, query);\n+                    let wd = get_temp_workdir(c);\n+                    install_query(c, &wd, query);\n                 }\n \n                 os::change_dir(path);\n \n                 if c.opts.test {\n-                    test_one_crate(c, path, cf);\n+                    test_one_crate(c, path, &cf);\n                 }\n-                install_one_crate(c, path, cf);\n+                install_one_crate(c, path, &cf);\n             }\n         }\n     }\n }\n \n-fn install_git(c: cargo, wd: ~str, url: ~str, reference: option<~str>) {\n-    run::program_output(~\"git\", ~[~\"clone\", url, wd]);\n+fn install_git(c: cargo, wd: &Path, url: ~str, reference: option<~str>) {\n+    run::program_output(~\"git\", ~[~\"clone\", url, wd.to_str()]);\n     if option::is_some(reference) {\n         let r = option::get(reference);\n         os::change_dir(wd);\n@@ -820,25 +821,27 @@ fn install_git(c: cargo, wd: ~str, url: ~str, reference: option<~str>) {\n     install_source(c, wd);\n }\n \n-fn install_curl(c: cargo, wd: ~str, url: ~str) {\n-    let tarpath = path::connect(wd, ~\"pkg.tar\");\n+fn install_curl(c: cargo, wd: &Path, url: ~str) {\n+    let tarpath = wd.push(\"pkg.tar\");\n     let p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n-                                         tarpath, url]);\n+                                         tarpath.to_str(), url]);\n     if p.status != 0 {\n         fail fmt!(\"fetch of %s failed: %s\", url, p.err);\n     }\n     run::run_program(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n-                             ~\"-C\", wd, ~\"-f\", tarpath]);\n+                               ~\"-C\", wd.to_str(),\n+                               ~\"-f\", tarpath.to_str()]);\n     install_source(c, wd);\n }\n \n-fn install_file(c: cargo, wd: ~str, path: ~str) {\n+fn install_file(c: cargo, wd: &Path, path: &Path) {\n     run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n-                             ~\"-C\", wd, ~\"-f\", path]);\n+                                  ~\"-C\", wd.to_str(),\n+                                  ~\"-f\", path.to_str()]);\n     install_source(c, wd);\n }\n \n-fn install_package(c: cargo, src: ~str, wd: ~str, pkg: package) {\n+fn install_package(c: cargo, src: ~str, wd: &Path, pkg: package) {\n     let url = copy pkg.url;\n     let method = match pkg.method {\n         ~\"git\" => ~\"git\",\n@@ -850,7 +853,7 @@ fn install_package(c: cargo, src: ~str, wd: ~str, pkg: package) {\n \n     match method {\n         ~\"git\" => install_git(c, wd, url, copy pkg.reference),\n-        ~\"file\" => install_file(c, wd, url),\n+        ~\"file\" => install_file(c, wd, &Path(url)),\n         ~\"curl\" => install_curl(c, wd, copy url),\n         _ => ()\n     }\n@@ -866,7 +869,7 @@ fn cargo_suggestion(c: cargo, fallback: fn())\n     fallback();\n }\n \n-fn install_uuid(c: cargo, wd: ~str, uuid: ~str) {\n+fn install_uuid(c: cargo, wd: &Path, uuid: ~str) {\n     let mut ps = ~[];\n     for_each_package(c, |s, p| {\n         if p.uuid == uuid {\n@@ -890,7 +893,7 @@ fn install_uuid(c: cargo, wd: ~str, uuid: ~str) {\n     }\n }\n \n-fn install_named(c: cargo, wd: ~str, name: ~str) {\n+fn install_named(c: cargo, wd: &Path, name: ~str) {\n     let mut ps = ~[];\n     for_each_package(c, |s, p| {\n         if p.name == name {\n@@ -914,7 +917,7 @@ fn install_named(c: cargo, wd: ~str, name: ~str) {\n     }\n }\n \n-fn install_uuid_specific(c: cargo, wd: ~str, src: ~str, uuid: ~str) {\n+fn install_uuid_specific(c: cargo, wd: &Path, src: ~str, uuid: ~str) {\n     match c.sources.find(src) {\n       some(s) => {\n         let packages = copy s.packages;\n@@ -930,7 +933,7 @@ fn install_uuid_specific(c: cargo, wd: ~str, src: ~str, uuid: ~str) {\n     error(~\"can't find package: \" + src + ~\"/\" + uuid);\n }\n \n-fn install_named_specific(c: cargo, wd: ~str, src: ~str, name: ~str) {\n+fn install_named_specific(c: cargo, wd: &Path, src: ~str, name: ~str) {\n     match c.sources.find(src) {\n         some(s) => {\n           let packages = copy s.packages;\n@@ -952,67 +955,53 @@ fn cmd_uninstall(c: cargo) {\n         return;\n     }\n \n-    let lib = c.libdir;\n-    let bin = c.bindir;\n+    let lib = &c.libdir;\n+    let bin = &c.bindir;\n     let target = c.opts.free[2u];\n \n     // FIXME (#2662): needs stronger pattern matching\n     // FIXME (#2662): needs to uninstall from a specified location in a\n     // cache instead of looking for it (binaries can be uninstalled by\n     // name only)\n+\n+    fn try_uninstall(p: &Path) -> bool {\n+        if os::remove_file(p) {\n+            info(~\"uninstalled: '\" + p.to_str() + ~\"'\");\n+            true\n+        } else {\n+            error(~\"could not uninstall: '\" +\n+                  p.to_str() + ~\"'\");\n+            false\n+        }\n+    }\n+\n     if is_uuid(target) {\n         for os::list_dir(lib).each |file| {\n             match str::find_str(file, ~\"-\" + target + ~\"-\") {\n-                some(idx) => {\n-                    let full = path::normalize(path::connect(lib, file));\n-                    if os::remove_file(full) {\n-                        info(~\"uninstalled: '\" + full + ~\"'\");\n-                    } else {\n-                        error(~\"could not uninstall: '\" + full + ~\"'\");\n-                    }\n-                    return;\n-                }\n-                none => again\n+              some(_) => if !try_uninstall(&lib.push(file)) { return },\n+              none => ()\n             }\n         }\n-\n         error(~\"can't find package with uuid: \" + target);\n     } else {\n         for os::list_dir(lib).each |file| {\n             match str::find_str(file, ~\"lib\" + target + ~\"-\") {\n-                some(idx) => {\n-                    let full = path::normalize(path::connect(lib,\n-                               file));\n-                    if os::remove_file(full) {\n-                        info(~\"uninstalled: '\" + full + ~\"'\");\n-                    } else {\n-                        error(~\"could not uninstall: '\" + full + ~\"'\");\n-                    }\n-                    return;\n-                }\n-                none => again\n+              some(_) => if !try_uninstall(&lib.push(file)) { return },\n+              none => ()\n             }\n         }\n         for os::list_dir(bin).each |file| {\n             match str::find_str(file, target) {\n-                some(idx) => {\n-                    let full = path::normalize(path::connect(bin, file));\n-                    if os::remove_file(full) {\n-                        info(~\"uninstalled: '\" + full + ~\"'\");\n-                    } else {\n-                        error(~\"could not uninstall: '\" + full + ~\"'\");\n-                    }\n-                    return;\n-                }\n-                none => again\n+              some(_) => if !try_uninstall(&lib.push(file)) { return },\n+              none => ()\n             }\n         }\n \n         error(~\"can't find package with name: \" + target);\n     }\n }\n \n-fn install_query(c: cargo, wd: ~str, target: ~str) {\n+fn install_query(c: cargo, wd: &Path, target: ~str) {\n     match c.dep_cache.find(target) {\n         some(inst) => {\n             if inst {\n@@ -1025,7 +1014,7 @@ fn install_query(c: cargo, wd: ~str, target: ~str) {\n     c.dep_cache.insert(target, true);\n \n     if is_archive_path(target) {\n-        install_file(c, wd, target);\n+        install_file(c, wd, &Path(target));\n         return;\n     } else if is_git_url(target) {\n         let reference = if c.opts.free.len() >= 4u {\n@@ -1072,31 +1061,36 @@ fn install_query(c: cargo, wd: ~str, target: ~str) {\n     }\n }\n \n+fn get_temp_workdir(c: cargo) -> Path {\n+    match tempfile::mkdtemp(&c.workdir, \"cargo\") {\n+      some(wd) => wd,\n+      none => fail fmt!(\"needed temp dir: %s\",\n+                        c.workdir.to_str())\n+    }\n+}\n+\n fn cmd_install(c: cargo) unsafe {\n-    let wd_base = c.workdir + path::path_sep();\n-    let wd = match tempfile::mkdtemp(wd_base, ~\"\") {\n-        some(wd) => wd,\n-        none => fail fmt!(\"needed temp dir: %s\", wd_base)\n-    };\n+    let wd = get_temp_workdir(c);\n \n     if vec::len(c.opts.free) == 2u {\n         let cwd = os::getcwd();\n-        let status = run::run_program(~\"cp\", ~[~\"-R\", cwd, wd]);\n+        let status = run::run_program(~\"cp\", ~[~\"-R\", cwd.to_str(),\n+                                               wd.to_str()]);\n \n         if status != 0 {\n-            fail fmt!(\"could not copy directory: %s\", cwd);\n+            fail fmt!(\"could not copy directory: %s\", cwd.to_str());\n         }\n \n-        install_source(c, wd);\n+        install_source(c, &wd);\n         return;\n     }\n \n     sync(c);\n \n     let query = c.opts.free[2];\n-    c.current_install = copy query;\n+    c.current_install = query.to_str();\n \n-    install_query(c, wd, copy query);\n+    install_query(c, &wd, query);\n }\n \n fn sync(c: cargo) {\n@@ -1107,45 +1101,47 @@ fn sync(c: cargo) {\n     }\n }\n \n-fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n+fn sync_one_file(c: cargo, dir: &Path, src: source) -> bool {\n     let name = src.name;\n-    let srcfile = path::connect(dir, ~\"source.json.new\");\n-    let destsrcfile = path::connect(dir, ~\"source.json\");\n-    let pkgfile = path::connect(dir, ~\"packages.json.new\");\n-    let destpkgfile = path::connect(dir, ~\"packages.json\");\n-    let keyfile = path::connect(dir, ~\"key.gpg\");\n-    let srcsigfile = path::connect(dir, ~\"source.json.sig\");\n-    let sigfile = path::connect(dir, ~\"packages.json.sig\");\n-    let url = src.url;\n+    let srcfile = dir.push(\"source.json.new\");\n+    let destsrcfile = dir.push(\"source.json\");\n+    let pkgfile = dir.push(\"packages.json.new\");\n+    let destpkgfile = dir.push(\"packages.json\");\n+    let keyfile = dir.push(\"key.gpg\");\n+    let srcsigfile = dir.push(\"source.json.sig\");\n+    let sigfile = dir.push(\"packages.json.sig\");\n+    let url = Path(src.url);\n     let mut has_src_file = false;\n \n-    if !os::copy_file(path::connect(url, ~\"packages.json\"), pkgfile) {\n-        error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n+    if !os::copy_file(&url.push(\"packages.json\"), &pkgfile) {\n+        error(fmt!(\"fetch for source %s (url %s) failed\",\n+                   name, url.to_str()));\n         return false;\n     }\n \n-    if os::copy_file(path::connect(url, ~\"source.json\"), srcfile) {\n+    if os::copy_file(&url.push(\"source.json\"), &srcfile) {\n         has_src_file = false;\n     }\n \n-    os::copy_file(path::connect(url, ~\"source.json.sig\"), srcsigfile);\n-    os::copy_file(path::connect(url, ~\"packages.json.sig\"), sigfile);\n+    os::copy_file(&url.push(\"source.json.sig\"), &srcsigfile);\n+    os::copy_file(&url.push(\"packages.json.sig\"), &sigfile);\n \n     match copy src.key {\n         some(u) => {\n             let p = run::program_output(~\"curl\",\n-                                        ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n+                                        ~[~\"-f\", ~\"-s\",\n+                                          ~\"-o\", keyfile.to_str(), u]);\n             if p.status != 0 {\n                 error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n                 return false;\n             }\n-            pgp::add(c.root, keyfile);\n+            pgp::add(&c.root, &keyfile);\n         }\n         _ => ()\n     }\n     match (src.key, src.keyfp) {\n         (some(_), some(f)) => {\n-            let r = pgp::verify(c.root, pkgfile, sigfile, f);\n+            let r = pgp::verify(&c.root, &pkgfile, &sigfile, f);\n \n             if !r {\n                 error(fmt!(\"signature verification failed for source %s\",\n@@ -1154,7 +1150,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n             }\n \n             if has_src_file {\n-                let e = pgp::verify(c.root, srcfile, srcsigfile, f);\n+                let e = pgp::verify(&c.root, &srcfile, &srcsigfile, f);\n \n                 if !e {\n                     error(fmt!(\"signature verification failed for source %s\",\n@@ -1166,33 +1162,33 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n         _ => ()\n     }\n \n-    copy_warn(pkgfile, destpkgfile);\n+    copy_warn(&pkgfile, &destpkgfile);\n \n     if has_src_file {\n-        copy_warn(srcfile, destsrcfile);\n+        copy_warn(&srcfile, &destsrcfile);\n     }\n \n-    os::remove_file(keyfile);\n-    os::remove_file(srcfile);\n-    os::remove_file(srcsigfile);\n-    os::remove_file(pkgfile);\n-    os::remove_file(sigfile);\n+    os::remove_file(&keyfile);\n+    os::remove_file(&srcfile);\n+    os::remove_file(&srcsigfile);\n+    os::remove_file(&pkgfile);\n+    os::remove_file(&sigfile);\n \n     info(fmt!(\"synced source: %s\", name));\n \n     return true;\n }\n \n-fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n+fn sync_one_git(c: cargo, dir: &Path, src: source) -> bool {\n     let name = src.name;\n-    let srcfile = path::connect(dir, ~\"source.json\");\n-    let pkgfile = path::connect(dir, ~\"packages.json\");\n-    let keyfile = path::connect(dir, ~\"key.gpg\");\n-    let srcsigfile = path::connect(dir, ~\"source.json.sig\");\n-    let sigfile = path::connect(dir, ~\"packages.json.sig\");\n+    let srcfile = dir.push(\"source.json\");\n+    let pkgfile = dir.push(\"packages.json\");\n+    let keyfile = dir.push(\"key.gpg\");\n+    let srcsigfile = dir.push(\"source.json.sig\");\n+    let sigfile = dir.push(\"packages.json.sig\");\n     let url = src.url;\n \n-    fn rollback(name: ~str, dir: ~str, insecure: bool) {\n+    fn rollback(name: ~str, dir: &Path, insecure: bool) {\n         fn msg(name: ~str, insecure: bool) {\n             error(fmt!(\"could not rollback source: %s\", name));\n \n@@ -1216,8 +1212,8 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n         }\n     }\n \n-    if !os::path_exists(path::connect(dir, ~\".git\")) {\n-        let p = run::program_output(~\"git\", ~[~\"clone\", url, dir]);\n+    if !os::path_exists(&dir.push(\".git\")) {\n+        let p = run::program_output(~\"git\", ~[~\"clone\", url, dir.to_str()]);\n \n         if p.status != 0 {\n             error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n@@ -1238,24 +1234,25 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n         }\n     }\n \n-    let has_src_file = os::path_exists(srcfile);\n+    let has_src_file = os::path_exists(&srcfile);\n \n     match copy src.key {\n         some(u) => {\n             let p = run::program_output(~\"curl\",\n-                                        ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n+                                        ~[~\"-f\", ~\"-s\",\n+                                          ~\"-o\", keyfile.to_str(), u]);\n             if p.status != 0 {\n                 error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n                 rollback(name, dir, false);\n                 return false;\n             }\n-            pgp::add(c.root, keyfile);\n+            pgp::add(&c.root, &keyfile);\n         }\n         _ => ()\n     }\n     match (src.key, src.keyfp) {\n         (some(_), some(f)) => {\n-            let r = pgp::verify(c.root, pkgfile, sigfile, f);\n+            let r = pgp::verify(&c.root, &pkgfile, &sigfile, f);\n \n             if !r {\n                 error(fmt!(\"signature verification failed for source %s\",\n@@ -1265,7 +1262,7 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n             }\n \n             if has_src_file {\n-                let e = pgp::verify(c.root, srcfile, srcsigfile, f);\n+                let e = pgp::verify(&c.root, &srcfile, &srcsigfile, f);\n \n                 if !e {\n                     error(fmt!(\"signature verification failed for source %s\",\n@@ -1278,22 +1275,22 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n         _ => ()\n     }\n \n-    os::remove_file(keyfile);\n+    os::remove_file(&keyfile);\n \n     info(fmt!(\"synced source: %s\", name));\n \n     return true;\n }\n \n-fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n+fn sync_one_curl(c: cargo, dir: &Path, src: source) -> bool {\n     let name = src.name;\n-    let srcfile = path::connect(dir, ~\"source.json.new\");\n-    let destsrcfile = path::connect(dir, ~\"source.json\");\n-    let pkgfile = path::connect(dir, ~\"packages.json.new\");\n-    let destpkgfile = path::connect(dir, ~\"packages.json\");\n-    let keyfile = path::connect(dir, ~\"key.gpg\");\n-    let srcsigfile = path::connect(dir, ~\"source.json.sig\");\n-    let sigfile = path::connect(dir, ~\"packages.json.sig\");\n+    let srcfile = dir.push(\"source.json.new\");\n+    let destsrcfile = dir.push(\"source.json\");\n+    let pkgfile = dir.push(\"packages.json.new\");\n+    let destpkgfile = dir.push(\"packages.json\");\n+    let keyfile = dir.push(\"key.gpg\");\n+    let srcsigfile = dir.push(\"source.json.sig\");\n+    let sigfile = dir.push(\"packages.json.sig\");\n     let mut url = src.url;\n     let smart = !str::ends_with(src.url, ~\"packages.json\");\n     let mut has_src_file = false;\n@@ -1303,7 +1300,8 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n     }\n \n     let p = run::program_output(~\"curl\",\n-                                ~[~\"-f\", ~\"-s\", ~\"-o\", pkgfile, url]);\n+                                ~[~\"-f\", ~\"-s\",\n+                                  ~\"-o\", pkgfile.to_str(), url]);\n \n     if p.status != 0 {\n         error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n@@ -1313,7 +1311,8 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n         url = src.url + ~\"/source.json\";\n         let p =\n             run::program_output(~\"curl\",\n-                                ~[~\"-f\", ~\"-s\", ~\"-o\", srcfile, url]);\n+                                ~[~\"-f\", ~\"-s\",\n+                                  ~\"-o\", srcfile.to_str(), url]);\n \n         if p.status == 0 {\n             has_src_file = true;\n@@ -1323,12 +1322,13 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n     match copy src.key {\n         some(u) => {\n             let p = run::program_output(~\"curl\",\n-                                        ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n+                                        ~[~\"-f\", ~\"-s\",\n+                                          ~\"-o\", keyfile.to_str(), u]);\n             if p.status != 0 {\n                 error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n                 return false;\n             }\n-            pgp::add(c.root, keyfile);\n+            pgp::add(&c.root, &keyfile);\n         }\n         _ => ()\n     }\n@@ -1341,14 +1341,15 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n                 url = src.url + ~\".sig\";\n             }\n \n-            let mut p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n-                        sigfile, url]);\n+            let mut p = run::program_output(~\"curl\",\n+                                            ~[~\"-f\", ~\"-s\", ~\"-o\",\n+                                              sigfile.to_str(), url]);\n             if p.status != 0 {\n                 error(fmt!(\"fetch for source %s (sig %s) failed\", name, url));\n                 return false;\n             }\n \n-            let r = pgp::verify(c.root, pkgfile, sigfile, f);\n+            let r = pgp::verify(&c.root, &pkgfile, &sigfile, f);\n \n             if !r {\n                 error(fmt!(\"signature verification failed for source %s\",\n@@ -1361,14 +1362,14 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n \n                 p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\",\n-                                          srcsigfile, url]);\n+                                          srcsigfile.to_str(), url]);\n                 if p.status != 0 {\n                     error(fmt!(\"fetch for source %s (sig %s) failed\",\n                           name, url));\n                     return false;\n                 }\n \n-                let e = pgp::verify(c.root, srcfile, srcsigfile, f);\n+                let e = pgp::verify(&c.root, &srcfile, &srcsigfile, f);\n \n                 if !e {\n                     error(~\"signature verification failed for \" +\n@@ -1380,17 +1381,17 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n         _ => ()\n     }\n \n-    copy_warn(pkgfile, destpkgfile);\n+    copy_warn(&pkgfile, &destpkgfile);\n \n     if smart && has_src_file {\n-        copy_warn(srcfile, destsrcfile);\n+        copy_warn(&srcfile, &destsrcfile);\n     }\n \n-    os::remove_file(keyfile);\n-    os::remove_file(srcfile);\n-    os::remove_file(srcsigfile);\n-    os::remove_file(pkgfile);\n-    os::remove_file(sigfile);\n+    os::remove_file(&keyfile);\n+    os::remove_file(&srcfile);\n+    os::remove_file(&srcsigfile);\n+    os::remove_file(&pkgfile);\n+    os::remove_file(&sigfile);\n \n     info(fmt!(\"synced source: %s\", name));\n \n@@ -1399,16 +1400,16 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n \n fn sync_one(c: cargo, src: source) {\n     let name = src.name;\n-    let dir = path::connect(c.sourcedir, name);\n+    let dir = c.sourcedir.push(name);\n \n     info(fmt!(\"syncing source: %s...\", name));\n \n-    need_dir(dir);\n+    need_dir(&dir);\n \n     let result = match src.method {\n-        ~\"git\" => sync_one_git(c, dir, src),\n-        ~\"file\" => sync_one_file(c, dir, src),\n-        _ => sync_one_curl(c, dir, src)\n+        ~\"git\" => sync_one_git(c, &dir, src),\n+        ~\"file\" => sync_one_file(c, &dir, src),\n+        _ => sync_one_curl(c, &dir, src)\n     };\n \n     if result {\n@@ -1421,35 +1422,39 @@ fn cmd_init(c: cargo) {\n     let srcurl = ~\"http://www.rust-lang.org/cargo/sources.json\";\n     let sigurl = ~\"http://www.rust-lang.org/cargo/sources.json.sig\";\n \n-    let srcfile = path::connect(c.root, ~\"sources.json.new\");\n-    let sigfile = path::connect(c.root, ~\"sources.json.sig\");\n-    let destsrcfile = path::connect(c.root, ~\"sources.json\");\n+    let srcfile = c.root.push(\"sources.json.new\");\n+    let sigfile = c.root.push(\"sources.json.sig\");\n+    let destsrcfile = c.root.push(\"sources.json\");\n \n     let p =\n-        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\", srcfile, srcurl]);\n+        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n+                                       ~\"-o\", srcfile.to_str(), srcurl]);\n     if p.status != 0 {\n         error(fmt!(\"fetch of sources.json failed: %s\", p.out));\n         return;\n     }\n \n     let p =\n-        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\", sigfile, sigurl]);\n+        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n+                                       ~\"-o\", sigfile.to_str(), sigurl]);\n     if p.status != 0 {\n         error(fmt!(\"fetch of sources.json.sig failed: %s\", p.out));\n         return;\n     }\n \n-    let r = pgp::verify(c.root, srcfile, sigfile, pgp::signing_key_fp());\n+    let r = pgp::verify(&c.root, &srcfile, &sigfile,\n+                        pgp::signing_key_fp());\n     if !r {\n-        error(fmt!(\"signature verification failed for '%s'\", srcfile));\n+        error(fmt!(\"signature verification failed for '%s'\",\n+                   srcfile.to_str()));\n         return;\n     }\n \n-    copy_warn(srcfile, destsrcfile);\n-    os::remove_file(srcfile);\n-    os::remove_file(sigfile);\n+    copy_warn(&srcfile, &destsrcfile);\n+    os::remove_file(&srcfile);\n+    os::remove_file(&sigfile);\n \n-    info(fmt!(\"initialized .cargo in %s\", c.root));\n+    info(fmt!(\"initialized .cargo in %s\", c.root.to_str()));\n }\n \n fn print_pkg(s: source, p: package) {\n@@ -1530,41 +1535,42 @@ fn cmd_search(c: cargo) {\n     info(fmt!(\"found %d packages\", n));\n }\n \n-fn install_to_dir(srcfile: ~str, destdir: ~str) {\n-    let newfile = path::connect(destdir, path::basename(srcfile));\n+fn install_to_dir(srcfile: &Path, destdir: &Path) {\n+    let newfile = destdir.push(option::get(srcfile.filename()));\n \n-    let status = run::run_program(~\"cp\", ~[~\"-r\", srcfile, newfile]);\n+    let status = run::run_program(~\"cp\", ~[~\"-r\", srcfile.to_str(),\n+                                           newfile.to_str()]);\n     if status == 0 {\n-        info(fmt!(\"installed: '%s'\", newfile));\n+        info(fmt!(\"installed: '%s'\", newfile.to_str()));\n     } else {\n-        error(fmt!(\"could not install: '%s'\", newfile));\n+        error(fmt!(\"could not install: '%s'\", newfile.to_str()));\n     }\n }\n \n fn dump_cache(c: cargo) {\n-    need_dir(c.root);\n+    need_dir(&c.root);\n \n-    let out = path::connect(c.root, ~\"cache.json\");\n+    let out = c.root.push(\"cache.json\");\n     let _root = json::dict(map::str_hash());\n \n-    if os::path_exists(out) {\n-        copy_warn(out, path::connect(c.root, ~\"cache.json.old\"));\n+    if os::path_exists(&out) {\n+        copy_warn(&out, &c.root.push(\"cache.json.old\"));\n     }\n }\n fn dump_sources(c: cargo) {\n     if c.sources.size() < 1u {\n         return;\n     }\n \n-    need_dir(c.root);\n+    need_dir(&c.root);\n \n-    let out = path::connect(c.root, ~\"sources.json\");\n+    let out = c.root.push(\"sources.json\");\n \n-    if os::path_exists(out) {\n-        copy_warn(out, path::connect(c.root, ~\"sources.json.old\"));\n+    if os::path_exists(&out) {\n+        copy_warn(&out, &c.root.push(\"sources.json.old\"));\n     }\n \n-    match io::buffered_file_writer(out) {\n+    match io::buffered_file_writer(&out) {\n         result::ok(writer) => {\n             let hash = map::str_hash();\n             let root = json::dict(hash);\n@@ -1600,9 +1606,10 @@ fn dump_sources(c: cargo) {\n     }\n }\n \n-fn copy_warn(srcfile: ~str, destfile: ~str) {\n+fn copy_warn(srcfile: &Path, destfile: &Path) {\n     if !os::copy_file(srcfile, destfile) {\n-        warn(fmt!(\"copying %s to %s failed\", srcfile, destfile));\n+        warn(fmt!(\"copying %s to %s failed\",\n+                  srcfile.to_str(), destfile.to_str()));\n     }\n }\n \n@@ -1894,7 +1901,7 @@ fn main(argv: ~[~str]) {\n \n     let mut c = configure(o);\n     let home = c.root;\n-    let first_time = os::path_exists(path::connect(home, ~\"sources.json\"));\n+    let first_time = os::path_exists(&home.push(\"sources.json\"));\n \n     if !first_time && o.free[1] != ~\"init\" {\n         cmd_init(c);"}, {"sha": "17f3a2060aa05fe13c44933a983d6b62a7ee2505", "filename": "src/cargo/pgp.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Fcargo%2Fpgp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Fcargo%2Fpgp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fpgp.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -63,11 +63,13 @@ fn supported() -> bool {\n     r.status == 0\n }\n \n-fn init(root: ~str) {\n-    let p = path::connect(root, ~\"gpg\");\n-    if !os::path_is_dir(p) {\n-        os::make_dir(p, 0x1c0i32);\n-        let p = run::start_program(~\"gpg\", ~[~\"--homedir\", p, ~\"--import\"]);\n+fn init(root: &Path) {\n+    let p = root.push(\"gpg\");\n+    if !os::path_is_dir(&p) {\n+        os::make_dir(&p, 0x1c0i32);\n+        let p = run::start_program(~\"gpg\", ~[~\"--homedir\",\n+                                             p.to_str(),\n+                                             ~\"--import\"]);\n         p.input().write_str(signing_key());\n         let s = p.finish();\n         if s != 0 {\n@@ -76,19 +78,22 @@ fn init(root: ~str) {\n     }\n }\n \n-fn add(root: ~str, key: ~str) {\n-    let path = path::connect(root, ~\"gpg\");\n+fn add(root: &Path, key: &Path) {\n+    let path = root.push(\"gpg\");\n     let p =\n-        run::program_output(~\"gpg\", ~[~\"--homedir\", path, ~\"--import\", key]);\n+        run::program_output(~\"gpg\", ~[~\"--homedir\", path.to_str(),\n+                                      ~\"--import\", key.to_str()]);\n     if p.status != 0 {\n         fail ~\"pgp add failed: \" + p.out;\n     }\n }\n \n-fn verify(root: ~str, data: ~str, sig: ~str, keyfp: ~str) -> bool {\n-    let path = path::connect(root, ~\"gpg\");\n-    let p = gpg(~[~\"--homedir\", path, ~\"--with-fingerprint\", ~\"--verify\", sig,\n-                 data]);\n+fn verify(root: &Path, data: &Path, sig: &Path, keyfp: ~str) -> bool {\n+    let path = root.push(\"gpg\");\n+    let p = gpg(~[~\"--homedir\", path.to_str(),\n+                  ~\"--with-fingerprint\",\n+                  ~\"--verify\", sig.to_str(),\n+                 data.to_str()]);\n     let res = ~\"Primary key fingerprint: \" + keyfp;\n     for str::split_char(p.err, '\\n').each |line| {\n         if line == res { return true; }"}, {"sha": "021b138ffc10753486f46d3d0d9ce2f008480bf7", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -10,16 +10,16 @@ type config = {\n     run_lib_path: ~str,\n \n     // The rustc executable\n-    rustc_path: ~str,\n+    rustc_path: Path,\n \n     // The directory containing the tests to run\n-    src_base: ~str,\n+    src_base: Path,\n \n     // The directory where programs should be built\n-    build_base: ~str,\n+    build_base: Path,\n \n     // Directory for auxiliary libraries\n-    aux_base: ~str,\n+    aux_base: Path,\n \n     // The name of the stage being built (stage1, etc)\n     stage_id: ~str,\n@@ -34,7 +34,7 @@ type config = {\n     filter: option<~str>,\n \n     // Write out a parseable log of tests that were run\n-    logfile: option<~str>,\n+    logfile: option<Path>,\n \n     // A command line to prefix program execution with,\n     // for running under valgrind"}, {"sha": "6a08c1484611419d137d7a788b284d5223a2ad94", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -42,20 +42,26 @@ fn parse_config(args: ~[~str]) -> config {\n           err(f) => fail getopts::fail_str(f)\n         };\n \n+    fn opt_path(m: getopts::matches, nm: ~str) -> Path {\n+        Path(getopts::opt_str(m, nm))\n+    }\n+\n     return {compile_lib_path: getopts::opt_str(matches, ~\"compile-lib-path\"),\n          run_lib_path: getopts::opt_str(matches, ~\"run-lib-path\"),\n-         rustc_path: getopts::opt_str(matches, ~\"rustc-path\"),\n-         src_base: getopts::opt_str(matches, ~\"src-base\"),\n-         build_base: getopts::opt_str(matches, ~\"build-base\"),\n-         aux_base: getopts::opt_str(matches, ~\"aux-base\"),\n+         rustc_path: opt_path(matches, ~\"rustc-path\"),\n+         src_base: opt_path(matches, ~\"src-base\"),\n+         build_base: opt_path(matches, ~\"build-base\"),\n+         aux_base: opt_path(matches, ~\"aux-base\"),\n          stage_id: getopts::opt_str(matches, ~\"stage-id\"),\n          mode: str_mode(getopts::opt_str(matches, ~\"mode\")),\n          run_ignored: getopts::opt_present(matches, ~\"ignored\"),\n          filter:\n              if vec::len(matches.free) > 0u {\n                  option::some(matches.free[0])\n              } else { option::none },\n-         logfile: getopts::opt_maybe_str(matches, ~\"logfile\"),\n+         logfile: option::map(getopts::opt_maybe_str(matches,\n+                                                     ~\"logfile\"),\n+                              |s| Path(s)),\n          runtool: getopts::opt_maybe_str(matches, ~\"runtool\"),\n          rustcflags: getopts::opt_maybe_str(matches, ~\"rustcflags\"),\n          verbose: getopts::opt_present(matches, ~\"verbose\")};\n@@ -66,9 +72,9 @@ fn log_config(config: config) {\n     logv(c, fmt!(\"configuration:\"));\n     logv(c, fmt!(\"compile_lib_path: %s\", config.compile_lib_path));\n     logv(c, fmt!(\"run_lib_path: %s\", config.run_lib_path));\n-    logv(c, fmt!(\"rustc_path: %s\", config.rustc_path));\n-    logv(c, fmt!(\"src_base: %s\", config.src_base));\n-    logv(c, fmt!(\"build_base: %s\", config.build_base));\n+    logv(c, fmt!(\"rustc_path: %s\", config.rustc_path.to_str()));\n+    logv(c, fmt!(\"src_base: %s\", config.src_base.to_str()));\n+    logv(c, fmt!(\"build_base: %s\", config.build_base.to_str()));\n     logv(c, fmt!(\"stage_id: %s\", config.stage_id));\n     logv(c, fmt!(\"mode: %s\", mode_str(config.mode)));\n     logv(c, fmt!(\"run_ignored: %b\", config.run_ignored));\n@@ -122,34 +128,35 @@ fn test_opts(config: config) -> test::test_opts {\n      run_ignored: config.run_ignored,\n      logfile:\n          match config.logfile {\n-           option::some(s) => option::some(s),\n+           option::some(s) => option::some(s.to_str()),\n            option::none => option::none\n          }\n     }\n }\n \n fn make_tests(config: config) -> ~[test::test_desc] {\n-    debug!(\"making tests from %s\", config.src_base);\n+    debug!(\"making tests from %s\",\n+           config.src_base.to_str());\n     let mut tests = ~[];\n-    for os::list_dir_path(config.src_base).each |file| {\n-        let file = file;\n-        debug!(\"inspecting file %s\", file);\n+    for os::list_dir_path(&config.src_base).each |file| {\n+        let file = copy file;\n+        debug!(\"inspecting file %s\", file.to_str());\n         if is_test(config, file) {\n             vec::push(tests, make_test(config, file))\n         }\n     }\n     return tests;\n }\n \n-fn is_test(config: config, testfile: ~str) -> bool {\n+fn is_test(config: config, testfile: &Path) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions =\n         match config.mode {\n           mode_pretty => ~[~\".rs\"],\n           _ => ~[~\".rc\", ~\".rs\"]\n         };\n     let invalid_prefixes = ~[~\".\", ~\"#\", ~\"~\"];\n-    let name = path::basename(testfile);\n+    let name = option::get(testfile.filename());\n \n     let mut valid = false;\n \n@@ -164,7 +171,7 @@ fn is_test(config: config, testfile: ~str) -> bool {\n     return valid;\n }\n \n-fn make_test(config: config, testfile: ~str) ->\n+fn make_test(config: config, testfile: &Path) ->\n    test::test_desc {\n     {\n         name: make_test_name(config, testfile),\n@@ -174,12 +181,13 @@ fn make_test(config: config, testfile: ~str) ->\n     }\n }\n \n-fn make_test_name(config: config, testfile: ~str) -> ~str {\n-    fmt!(\"[%s] %s\", mode_str(config.mode), testfile)\n+fn make_test_name(config: config, testfile: &Path) -> ~str {\n+    fmt!(\"[%s] %s\", mode_str(config.mode), testfile.to_str())\n }\n \n-fn make_test_closure(config: config, testfile: ~str) -> test::test_fn {\n-    fn~() { runtest::run(config, copy testfile) }\n+fn make_test_closure(config: config, testfile: &Path) -> test::test_fn {\n+    let testfile = testfile.to_str();\n+    fn~() { runtest::run(config, testfile) }\n }\n \n // Local Variables:"}, {"sha": "9dde2f86f96cd924a0ed0ffc44d9d743018683ec", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -6,7 +6,7 @@ export expected_error;\n type expected_error = { line: uint, kind: ~str, msg: ~str };\n \n // Load any test directives embedded in the file\n-fn load_errors(testfile: ~str) -> ~[expected_error] {\n+fn load_errors(testfile: &Path) -> ~[expected_error] {\n     let mut error_patterns = ~[];\n     let rdr = result::get(io::file_reader(testfile));\n     let mut line_num = 1u;"}, {"sha": "2905537d6a186f85cfe81f4c82dda8f8cbc45689", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -14,15 +14,15 @@ type test_props = {\n     compile_flags: option<~str>,\n     // If present, the name of a file that this test should match when\n     // pretty-printed\n-    pp_exact: option<~str>,\n+    pp_exact: option<Path>,\n     // Modules from aux directory that should be compiled\n     aux_builds: ~[~str],\n     // Environment settings to use during execution\n     exec_env: ~[(~str,~str)]\n };\n \n // Load any test directives embedded in the file\n-fn load_props(testfile: ~str) -> test_props {\n+fn load_props(testfile: &Path) -> test_props {\n     let mut error_patterns = ~[];\n     let mut aux_builds = ~[];\n     let mut exec_env = ~[];\n@@ -59,7 +59,7 @@ fn load_props(testfile: ~str) -> test_props {\n     };\n }\n \n-fn is_test_ignored(config: config, testfile: ~str) -> bool {\n+fn is_test_ignored(config: config, testfile: &Path) -> bool {\n     let mut found = false;\n     for iter_header(testfile) |ln| {\n         if parse_name_directive(ln, ~\"xfail-test\") { return true; }\n@@ -74,7 +74,7 @@ fn is_test_ignored(config: config, testfile: ~str) -> bool {\n     }\n }\n \n-fn iter_header(testfile: ~str, it: fn(~str) -> bool) -> bool {\n+fn iter_header(testfile: &Path, it: fn(~str) -> bool) -> bool {\n     let rdr = result::get(io::file_reader(testfile));\n     while !rdr.eof() {\n         let ln = rdr.read_line();\n@@ -114,12 +114,12 @@ fn parse_exec_env(line: ~str) -> option<(~str, ~str)> {\n     }\n }\n \n-fn parse_pp_exact(line: ~str, testfile: ~str) -> option<~str> {\n+fn parse_pp_exact(line: ~str, testfile: &Path) -> option<Path> {\n     match parse_name_value_directive(line, ~\"pp-exact\") {\n-      option::some(s) => option::some(s),\n+      option::some(s) => option::some(Path(s)),\n       option::none => {\n         if parse_name_directive(line, ~\"pp-exact\") {\n-            option::some(path::basename(testfile))\n+            option::some(testfile.file_path())\n         } else {\n             option::none\n         }"}, {"sha": "fa0036466998d39ff1950d3c0d245a745624e17a", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 69, "deletions": 63, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -16,17 +16,18 @@ fn run(config: config, testfile: ~str) {\n         // We're going to be dumping a lot of info. Start on a new line.\n         io::stdout().write_str(~\"\\n\\n\");\n     }\n-    debug!(\"running %s\", testfile);\n-    let props = load_props(testfile);\n+    let testfile = Path(testfile);\n+    debug!(\"running %s\", testfile.to_str());\n+    let props = load_props(&testfile);\n     match config.mode {\n-      mode_compile_fail => run_cfail_test(config, props, testfile),\n-      mode_run_fail => run_rfail_test(config, props, testfile),\n-      mode_run_pass => run_rpass_test(config, props, testfile),\n-      mode_pretty => run_pretty_test(config, props, testfile)\n+      mode_compile_fail => run_cfail_test(config, props, &testfile),\n+      mode_run_fail => run_rfail_test(config, props, &testfile),\n+      mode_run_pass => run_rpass_test(config, props, &testfile),\n+      mode_pretty => run_pretty_test(config, props, &testfile)\n     }\n }\n \n-fn run_cfail_test(config: config, props: test_props, testfile: ~str) {\n+fn run_cfail_test(config: config, props: test_props, testfile: &Path) {\n     let procres = compile_test(config, props, testfile);\n \n     if procres.status == 0 {\n@@ -46,7 +47,7 @@ fn run_cfail_test(config: config, props: test_props, testfile: ~str) {\n     }\n }\n \n-fn run_rfail_test(config: config, props: test_props, testfile: ~str) {\n+fn run_rfail_test(config: config, props: test_props, testfile: &Path) {\n     let mut procres = compile_test(config, props, testfile);\n \n     if procres.status != 0 { fatal_procres(~\"compilation failed!\", procres); }\n@@ -74,7 +75,7 @@ fn check_correct_failure_status(procres: procres) {\n     }\n }\n \n-fn run_rpass_test(config: config, props: test_props, testfile: ~str) {\n+fn run_rpass_test(config: config, props: test_props, testfile: &Path) {\n     let mut procres = compile_test(config, props, testfile);\n \n     if procres.status != 0 { fatal_procres(~\"compilation failed!\", procres); }\n@@ -84,7 +85,7 @@ fn run_rpass_test(config: config, props: test_props, testfile: ~str) {\n     if procres.status != 0 { fatal_procres(~\"test run failed!\", procres); }\n }\n \n-fn run_pretty_test(config: config, props: test_props, testfile: ~str) {\n+fn run_pretty_test(config: config, props: test_props, testfile: &Path) {\n     if option::is_some(props.pp_exact) {\n         logv(config, ~\"testing for exact pretty-printing\");\n     } else { logv(config, ~\"testing for converging pretty-printing\"); }\n@@ -111,8 +112,8 @@ fn run_pretty_test(config: config, props: test_props, testfile: ~str) {\n     let mut expected =\n         match props.pp_exact {\n           option::some(file) => {\n-            let filepath = path::connect(path::dirname(testfile), file);\n-            result::get(io::read_whole_file_str(filepath))\n+            let filepath = testfile.dir_path().push_rel(&file);\n+            result::get(io::read_whole_file_str(&filepath))\n           }\n           option::none => { srcs[vec::len(srcs) - 2u] }\n         };\n@@ -136,15 +137,15 @@ fn run_pretty_test(config: config, props: test_props, testfile: ~str) {\n \n     return;\n \n-    fn print_source(config: config, testfile: ~str, src: ~str) -> procres {\n+    fn print_source(config: config, testfile: &Path, src: ~str) -> procres {\n         compose_and_run(config, testfile, make_pp_args(config, testfile),\n                         ~[], config.compile_lib_path, option::some(src))\n     }\n \n-    fn make_pp_args(config: config, _testfile: ~str) -> procargs {\n+    fn make_pp_args(config: config, _testfile: &Path) -> procargs {\n         let prog = config.rustc_path;\n         let args = ~[~\"-\", ~\"--pretty\", ~\"normal\"];\n-        return {prog: prog, args: args};\n+        return {prog: prog.to_str(), args: args};\n     }\n \n     fn compare_source(expected: ~str, actual: ~str) {\n@@ -168,28 +169,30 @@ actual:\\n\\\n     }\n \n     fn typecheck_source(config: config, props: test_props,\n-                        testfile: ~str, src: ~str) -> procres {\n+                        testfile: &Path, src: ~str) -> procres {\n         compose_and_run_compiler(\n             config, props, testfile,\n             make_typecheck_args(config, testfile),\n             option::some(src))\n     }\n \n-    fn make_typecheck_args(config: config, testfile: ~str) -> procargs {\n+    fn make_typecheck_args(config: config, testfile: &Path) -> procargs {\n         let prog = config.rustc_path;\n         let mut args = ~[~\"-\",\n-                         ~\"--no-trans\", ~\"--lib\", ~\"-L\", config.build_base,\n-                         ~\"-L\", aux_output_dir_name(config, testfile)];\n+                         ~\"--no-trans\", ~\"--lib\",\n+                         ~\"-L\", config.build_base.to_str(),\n+                         ~\"-L\",\n+                         aux_output_dir_name(config, testfile).to_str()];\n         args += split_maybe_args(config.rustcflags);\n-        return {prog: prog, args: args};\n+        return {prog: prog.to_str(), args: args};\n     }\n }\n \n fn check_error_patterns(props: test_props,\n-                        testfile: ~str,\n+                        testfile: &Path,\n                         procres: procres) {\n     if vec::is_empty(props.error_patterns) {\n-        fatal(~\"no error pattern specified in \" + testfile);\n+        fatal(~\"no error pattern specified in \" + testfile.to_str());\n     }\n \n     if procres.status == 0 {\n@@ -228,7 +231,7 @@ fn check_error_patterns(props: test_props,\n }\n \n fn check_expected_errors(expected_errors: ~[errors::expected_error],\n-                         testfile: ~str,\n+                         testfile: &Path,\n                          procres: procres) {\n \n     // true if we found the error in question\n@@ -240,7 +243,7 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n     }\n \n     let prefixes = vec::map(expected_errors, |ee| {\n-        fmt!(\"%s:%u:\", testfile, ee.line)\n+        fmt!(\"%s:%u:\", testfile.to_str(), ee.line)\n     });\n \n     // Scan and extract our error/warning messages,\n@@ -291,8 +294,8 @@ type procargs = {prog: ~str, args: ~[~str]};\n type procres = {status: int, stdout: ~str, stderr: ~str, cmdline: ~str};\n \n fn compile_test(config: config, props: test_props,\n-                testfile: ~str) -> procres {\n-    let link_args = ~[~\"-L\", aux_output_dir_name(config, testfile)];\n+                testfile: &Path) -> procres {\n+    let link_args = ~[~\"-L\", aux_output_dir_name(config, testfile).to_str()];\n     compose_and_run_compiler(\n         config, props, testfile,\n         make_compile_args(config, props, link_args,\n@@ -301,7 +304,7 @@ fn compile_test(config: config, props: test_props,\n }\n \n fn exec_compiled_test(config: config, props: test_props,\n-                      testfile: ~str) -> procres {\n+                      testfile: &Path) -> procres {\n     compose_and_run(config, testfile,\n                     make_run_args(config, props, testfile),\n                     props.exec_env,\n@@ -311,26 +314,28 @@ fn exec_compiled_test(config: config, props: test_props,\n fn compose_and_run_compiler(\n     config: config,\n     props: test_props,\n-    testfile: ~str,\n+    testfile: &Path,\n     args: procargs,\n     input: option<~str>) -> procres {\n \n     if props.aux_builds.is_not_empty() {\n-        ensure_dir(aux_output_dir_name(config, testfile));\n+        ensure_dir(&aux_output_dir_name(config, testfile));\n     }\n \n-    let extra_link_args = ~[~\"-L\", aux_output_dir_name(config, testfile)];\n+    let extra_link_args = ~[~\"-L\",\n+                            aux_output_dir_name(config, testfile).to_str()];\n \n     do vec::iter(props.aux_builds) |rel_ab| {\n-        let abs_ab = path::connect(config.aux_base, rel_ab);\n+        let abs_ab = config.aux_base.push_rel(&Path(rel_ab));\n         let aux_args =\n             make_compile_args(config, props, ~[~\"--lib\"] + extra_link_args,\n-                              |a,b| make_lib_name(a, b, testfile), abs_ab);\n-        let auxres = compose_and_run(config, abs_ab, aux_args, ~[],\n+                              |a,b| make_lib_name(a, b, testfile), &abs_ab);\n+        let auxres = compose_and_run(config, &abs_ab, aux_args, ~[],\n                                      config.compile_lib_path, option::none);\n         if auxres.status != 0 {\n             fatal_procres(\n-                fmt!(\"auxiliary build of %s failed to compile: \", abs_ab),\n+                fmt!(\"auxiliary build of %s failed to compile: \",\n+                     abs_ab.to_str()),\n                 auxres);\n         }\n     }\n@@ -339,14 +344,14 @@ fn compose_and_run_compiler(\n                     config.compile_lib_path, input)\n }\n \n-fn ensure_dir(path: Path) {\n+fn ensure_dir(path: &Path) {\n     if os::path_is_dir(path) { return; }\n     if !os::make_dir(path, 0x1c0i32) {\n-        fail fmt!(\"can't make dir %s\", path);\n+        fail fmt!(\"can't make dir %s\", path.to_str());\n     }\n }\n \n-fn compose_and_run(config: config, testfile: ~str,\n+fn compose_and_run(config: config, testfile: &Path,\n                    procargs: procargs,\n                    procenv: ~[(~str, ~str)],\n                    lib_path: ~str,\n@@ -356,28 +361,30 @@ fn compose_and_run(config: config, testfile: ~str,\n }\n \n fn make_compile_args(config: config, props: test_props, extras: ~[~str],\n-                     xform: fn(config, ~str) -> ~str, testfile: ~str) ->\n-   procargs {\n+                     xform: fn(config, (&Path)) -> Path,\n+                     testfile: &Path) -> procargs {\n     let prog = config.rustc_path;\n-    let mut args = ~[testfile, ~\"-o\", xform(config, testfile),\n-                    ~\"-L\", config.build_base] + extras;\n+    let mut args = ~[testfile.to_str(),\n+                     ~\"-o\", xform(config, testfile).to_str(),\n+                     ~\"-L\", config.build_base.to_str()]\n+        + extras;\n     args += split_maybe_args(config.rustcflags);\n     args += split_maybe_args(props.compile_flags);\n-    return {prog: prog, args: args};\n+    return {prog: prog.to_str(), args: args};\n }\n \n-fn make_lib_name(config: config, auxfile: ~str, testfile: ~str) -> ~str {\n+fn make_lib_name(config: config, auxfile: &Path, testfile: &Path) -> Path {\n     // what we return here is not particularly important, as it\n     // happens; rustc ignores everything except for the directory.\n     let auxname = output_testname(auxfile);\n-    path::connect(aux_output_dir_name(config, testfile), auxname)\n+    aux_output_dir_name(config, testfile).push_rel(&auxname)\n }\n \n-fn make_exe_name(config: config, testfile: ~str) -> ~str {\n-    output_base_name(config, testfile) + os::exe_suffix()\n+fn make_exe_name(config: config, testfile: &Path) -> Path {\n+    Path(output_base_name(config, testfile).to_str() + os::exe_suffix())\n }\n \n-fn make_run_args(config: config, _props: test_props, testfile: ~str) ->\n+fn make_run_args(config: config, _props: test_props, testfile: &Path) ->\n    procargs {\n     let toolargs = {\n             // If we've got another tool to run under (valgrind),\n@@ -390,7 +397,7 @@ fn make_run_args(config: config, _props: test_props, testfile: ~str) ->\n             split_maybe_args(runtool)\n         };\n \n-    let args = toolargs + ~[make_exe_name(config, testfile)];\n+    let args = toolargs + ~[make_exe_name(config, testfile).to_str()];\n     return {prog: args[0], args: vec::slice(args, 1u, vec::len(args))};\n }\n \n@@ -408,7 +415,7 @@ fn split_maybe_args(argstr: option<~str>) -> ~[~str] {\n     }\n }\n \n-fn program_output(config: config, testfile: ~str, lib_path: ~str, prog: ~str,\n+fn program_output(config: config, testfile: &Path, lib_path: ~str, prog: ~str,\n                   args: ~[~str], env: ~[(~str, ~str)],\n                   input: option<~str>) -> procres {\n     let cmdline =\n@@ -445,37 +452,36 @@ fn lib_path_cmd_prefix(path: ~str) -> ~str {\n     fmt!(\"%s=\\\"%s\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n }\n \n-fn dump_output(config: config, testfile: ~str, out: ~str, err: ~str) {\n+fn dump_output(config: config, testfile: &Path, out: ~str, err: ~str) {\n     dump_output_file(config, testfile, out, ~\"out\");\n     dump_output_file(config, testfile, err, ~\"err\");\n     maybe_dump_to_stdout(config, out, err);\n }\n \n-fn dump_output_file(config: config, testfile: ~str,\n+fn dump_output_file(config: config, testfile: &Path,\n                     out: ~str, extension: ~str) {\n     let outfile = make_out_name(config, testfile, extension);\n     let writer = result::get(\n-        io::file_writer(outfile, ~[io::Create, io::Truncate]));\n+        io::file_writer(&outfile, ~[io::Create, io::Truncate]));\n     writer.write_str(out);\n }\n \n-fn make_out_name(config: config, testfile: ~str, extension: ~str) -> ~str {\n-    output_base_name(config, testfile) + ~\".\" + extension\n+fn make_out_name(config: config, testfile: &Path, extension: ~str) -> Path {\n+    output_base_name(config, testfile).with_filetype(extension)\n }\n \n-fn aux_output_dir_name(config: config, testfile: ~str) -> ~str {\n-    output_base_name(config, testfile) + ~\".libaux\"\n+fn aux_output_dir_name(config: config, testfile: &Path) -> Path {\n+    output_base_name(config, testfile).with_filetype(\"libaux\")\n }\n \n-fn output_testname(testfile: ~str) -> ~str {\n-    let parts = str::split_char(path::basename(testfile), '.');\n-    str::connect(vec::slice(parts, 0u, vec::len(parts) - 1u), ~\".\")\n+fn output_testname(testfile: &Path) -> Path {\n+    Path(option::get(testfile.filestem()))\n }\n \n-fn output_base_name(config: config, testfile: ~str) -> ~str {\n-    let base = config.build_base;\n-    let filename = output_testname(testfile);\n-    fmt!(\"%s%s.%s\", base, filename, config.stage_id)\n+fn output_base_name(config: config, testfile: &Path) -> Path {\n+    config.build_base\n+        .push_rel(&output_testname(testfile))\n+        .with_filetype(config.stage_id)\n }\n \n fn maybe_dump_to_stdout(config: config, out: ~str, err: ~str) {"}, {"sha": "7f496acda8fcc1141502fc85871555babe597b7e", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -8,7 +8,7 @@ import syntax::diagnostic;\n enum test_mode { tm_converge, tm_run, }\n type context = { mode: test_mode }; // + rng\n \n-fn write_file(filename: ~str, content: ~str) {\n+fn write_file(filename: &Path, content: ~str) {\n     result::get(\n         io::file_writer(filename, ~[io::Create, io::Truncate]))\n         .write_str(content);\n@@ -18,13 +18,13 @@ fn contains(haystack: ~str, needle: ~str) -> bool {\n     str::contains(haystack, needle)\n }\n \n-fn find_rust_files(&files: ~[~str], path: ~str) {\n-    if str::ends_with(path, ~\".rs\") && !contains(path, ~\"utf8\") {\n+fn find_rust_files(files: &mut ~[Path], path: &Path) {\n+    if path.filetype() == some(~\"rs\") && !contains(path.to_str(), ~\"utf8\") {\n         // ignoring \"utf8\" tests because something is broken\n-        files += ~[path];\n+        vec::push(*files, *path);\n     } else if os::path_is_dir(path)\n-        && !contains(path, ~\"compile-fail\")\n-        && !contains(path, ~\"build\") {\n+        && !contains(path.to_str(), ~\"compile-fail\")\n+        && !contains(path.to_str(), ~\"build\") {\n         for os::list_dir_path(path).each |p| {\n             find_rust_files(files, p);\n         }\n@@ -221,7 +221,7 @@ fn as_str(f: fn@(io::Writer)) -> ~str {\n }\n \n fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n-                         filename: ~str, cx: context) {\n+                         filename: &Path, cx: context) {\n     let stolen = steal(crate, cx.mode);\n     let extra_exprs = vec::filter(common_exprs(),\n                                   |a| safe_to_use_expr(a, cx.mode) );\n@@ -235,14 +235,14 @@ fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n fn check_variants_T<T: copy>(\n   crate: ast::crate,\n   codemap: codemap::codemap,\n-  filename: ~str,\n+  filename: &Path,\n   thing_label: ~str,\n   things: ~[T],\n   stringifier: fn@(@T, syntax::parse::token::ident_interner) -> ~str,\n   replacer: fn@(ast::crate, uint, T, test_mode) -> ast::crate,\n   cx: context\n   ) {\n-    error!(\"%s contains %u %s objects\", filename,\n+    error!(\"%s contains %u %s objects\", filename.to_str(),\n            vec::len(things), thing_label);\n \n     // Assuming we're not generating any token_trees\n@@ -253,6 +253,7 @@ fn check_variants_T<T: copy>(\n     if L < 100u {\n         do under(uint::min(L, 20u)) |i| {\n             log(error, ~\"Replacing... #\" + uint::str(i));\n+            let fname = str::from_slice(filename.to_str());\n             do under(uint::min(L, 30u)) |j| {\n                 log(error, ~\"With... \" + stringifier(@things[j], intr));\n                 let crate2 = @replacer(crate, i, things[j], cx.mode);\n@@ -265,7 +266,7 @@ fn check_variants_T<T: copy>(\n                         intr,\n                         diagnostic::mk_span_handler(handler, codemap),\n                         crate2,\n-                        filename,\n+                        fname,\n                         rdr, a,\n                         pprust::no_ann(),\n                         false))\n@@ -276,11 +277,12 @@ fn check_variants_T<T: copy>(\n                   }\n                   tm_run => {\n                     let file_label = fmt!(\"rusttmp/%s_%s_%u_%u\",\n-                                          last_part(filename),\n+                                          last_part(filename.to_str()),\n                                           thing_label, i, j);\n                     let safe_to_run = !(content_is_dangerous_to_run(*str3)\n                                         || has_raw_pointers(*crate2));\n-                    check_whole_compiler(*str3, file_label, safe_to_run);\n+                    check_whole_compiler(*str3, &Path(file_label),\n+                                         safe_to_run);\n                   }\n                 }\n             }\n@@ -305,9 +307,9 @@ enum happiness {\n // - that would be tricky, requiring use of tasks or serialization\n //   or randomness.\n // This seems to find plenty of bugs as it is :)\n-fn check_whole_compiler(code: ~str, suggested_filename_prefix: ~str,\n+fn check_whole_compiler(code: ~str, suggested_filename_prefix: &Path,\n                         allow_running: bool) {\n-    let filename = suggested_filename_prefix + ~\".rs\";\n+    let filename = &suggested_filename_prefix.with_filetype(\"rs\");\n     write_file(filename, code);\n \n     let compile_result = check_compiling(filename);\n@@ -320,32 +322,32 @@ fn check_whole_compiler(code: ~str, suggested_filename_prefix: ~str,\n     match run_result {\n       passed | cleanly_rejected(_) | known_bug(_) => {\n         removeIfExists(suggested_filename_prefix);\n-        removeIfExists(suggested_filename_prefix + ~\".rs\");\n-        removeDirIfExists(suggested_filename_prefix + ~\".dSYM\");\n+        removeIfExists(&suggested_filename_prefix.with_filetype(\"rs\"));\n+        removeDirIfExists(&suggested_filename_prefix.with_filetype(\"dSYM\"));\n       }\n       failed(s) => {\n         log(error, ~\"check_whole_compiler failure: \" + s);\n-        log(error, ~\"Saved as: \" + filename);\n+        log(error, ~\"Saved as: \" + filename.to_str());\n       }\n     }\n }\n \n-fn removeIfExists(filename: ~str) {\n+fn removeIfExists(filename: &Path) {\n     // So sketchy!\n-    assert !contains(filename, ~\" \");\n-    run::program_output(~\"bash\", ~[~\"-c\", ~\"rm \" + filename]);\n+    assert !contains(filename.to_str(), ~\" \");\n+    run::program_output(~\"bash\", ~[~\"-c\", ~\"rm \" + filename.to_str()]);\n }\n \n-fn removeDirIfExists(filename: ~str) {\n+fn removeDirIfExists(filename: &Path) {\n     // So sketchy!\n-    assert !contains(filename, ~\" \");\n-    run::program_output(~\"bash\", ~[~\"-c\", ~\"rm -r \" + filename]);\n+    assert !contains(filename.to_str(), ~\" \");\n+    run::program_output(~\"bash\", ~[~\"-c\", ~\"rm -r \" + filename.to_str()]);\n }\n \n-fn check_running(exe_filename: ~str) -> happiness {\n+fn check_running(exe_filename: &Path) -> happiness {\n     let p = run::program_output(\n         ~\"/Users/jruderman/scripts/timed_run_rust_program.py\",\n-        ~[exe_filename]);\n+        ~[exe_filename.to_str()]);\n     let comb = p.out + ~\"\\n\" + p.err;\n     if str::len(comb) > 1u {\n         log(error, ~\"comb comb comb: \" + comb);\n@@ -381,11 +383,11 @@ fn check_running(exe_filename: ~str) -> happiness {\n     }\n }\n \n-fn check_compiling(filename: ~str) -> happiness {\n+fn check_compiling(filename: &Path) -> happiness {\n     let p = run::program_output(\n         ~\"/Users/jruderman/code/rust/build/x86_64-apple-darwin/\\\n          stage1/bin/rustc\",\n-        ~[filename]);\n+        ~[filename.to_str()]);\n \n     //error!(\"Status: %d\", p.status);\n     if p.status == 0 {\n@@ -415,11 +417,11 @@ fn check_compiling(filename: ~str) -> happiness {\n \n \n fn parse_and_print(code: @~str) -> ~str {\n-    let filename = ~\"tmp.rs\";\n+    let filename = Path(\"tmp.rs\");\n     let sess = parse::new_parse_sess(option::none);\n-    write_file(filename, *code);\n+    write_file(&filename, *code);\n     let crate = parse::parse_crate_from_source_str(\n-        filename, code, ~[], sess);\n+        filename.to_str(), code, ~[], sess);\n     do io::with_str_reader(*code) |rdr| {\n         as_str(|a|\n                pprust::print_crate(\n@@ -428,7 +430,7 @@ fn parse_and_print(code: @~str) -> ~str {\n                    syntax::parse::token::mk_fake_ident_interner(),\n                    sess.span_diagnostic,\n                    crate,\n-                   filename,\n+                   filename.to_str(),\n                    rdr, a,\n                    pprust::no_ann(),\n                    false) )\n@@ -486,7 +488,7 @@ fn content_might_not_converge(code: ~str) -> bool {\n     return false;\n }\n \n-fn file_might_not_converge(filename: ~str) -> bool {\n+fn file_might_not_converge(filename: &Path) -> bool {\n     let confusing_files = ~[\n       ~\"expr-alt.rs\", // pretty-printing \"(a = b) = c\"\n                      // vs \"a = b = c\" and wrapping\n@@ -496,7 +498,11 @@ fn file_might_not_converge(filename: ~str) -> bool {\n     ];\n \n \n-    for confusing_files.each |f| { if contains(filename, f) { return true; } }\n+    for confusing_files.each |f| {\n+        if contains(filename.to_str(), f) {\n+            return true;\n+        }\n+    }\n \n     return false;\n }\n@@ -519,22 +525,22 @@ fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n         error!(\"Converged after %u iterations\", i);\n     } else {\n         error!(\"Did not converge after %u iterations!\", i);\n-        write_file(~\"round-trip-a.rs\", *oldv);\n-        write_file(~\"round-trip-b.rs\", *newv);\n+        write_file(&Path(\"round-trip-a.rs\"), *oldv);\n+        write_file(&Path(\"round-trip-b.rs\"), *newv);\n         run::run_program(~\"diff\",\n                          ~[~\"-w\", ~\"-u\", ~\"round-trip-a.rs\",\n                           ~\"round-trip-b.rs\"]);\n         fail ~\"Mismatch\";\n     }\n }\n \n-fn check_convergence(files: ~[~str]) {\n+fn check_convergence(files: &[Path]) {\n     error!(\"pp convergence tests: %u files\", vec::len(files));\n     for files.each |file| {\n-        if !file_might_not_converge(file) {\n-            let s = @result::get(io::read_whole_file_str(file));\n+        if !file_might_not_converge(&file) {\n+            let s = @result::get(io::read_whole_file_str(&file));\n             if !content_might_not_converge(*s) {\n-                error!(\"pp converge: %s\", file);\n+                error!(\"pp converge: %s\", file.to_str());\n                 // Change from 7u to 2u once\n                 // https://github.com/mozilla/rust/issues/850 is fixed\n                 check_roundtrip_convergence(s, 7u);\n@@ -543,15 +549,16 @@ fn check_convergence(files: ~[~str]) {\n     }\n }\n \n-fn check_variants(files: ~[~str], cx: context) {\n+fn check_variants(files: &[Path], cx: context) {\n     for files.each |file| {\n-        if cx.mode == tm_converge && file_might_not_converge(file) {\n+        if cx.mode == tm_converge &&\n+            file_might_not_converge(&file) {\n             error!(\"Skipping convergence test based on\\\n                     file_might_not_converge\");\n             again;\n         }\n \n-        let s = @result::get(io::read_whole_file_str(file));\n+        let s = @result::get(io::read_whole_file_str(&file));\n         if contains(*s, ~\"#\") {\n             again; // Macros are confusing\n         }\n@@ -562,11 +569,11 @@ fn check_variants(files: ~[~str], cx: context) {\n             again;\n         }\n \n-        log(error, ~\"check_variants: \" + file);\n+        log(error, ~\"check_variants: \" + file.to_str());\n         let sess = parse::new_parse_sess(option::none);\n         let crate =\n             parse::parse_crate_from_source_str(\n-                file,\n+                file.to_str(),\n                 s, ~[], sess);\n         io::with_str_reader(*s, |rdr| {\n             error!(\"%s\",\n@@ -576,12 +583,12 @@ fn check_variants(files: ~[~str], cx: context) {\n                        syntax::parse::token::mk_fake_ident_interner(),\n                        sess.span_diagnostic,\n                        crate,\n-                       file,\n+                       file.to_str(),\n                        rdr, a,\n                        pprust::no_ann(),\n                        false) ))\n         });\n-        check_variants_of_ast(*crate, sess.cm, file, cx);\n+        check_variants_of_ast(*crate, sess.cm, &file, cx);\n     }\n }\n \n@@ -591,9 +598,9 @@ fn main(args: ~[~str]) {\n         return;\n     }\n     let mut files = ~[];\n-    let root = args[1];\n+    let root = Path(args[1]);\n \n-    find_rust_files(files, root);\n+    find_rust_files(&mut files, &root);\n     error!(\"== check_convergence ==\");\n     check_convergence(files);\n     error!(\"== check_variants: converge ==\");"}, {"sha": "84c0568797c9f0242f70982726f840908fee9742", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -54,7 +54,7 @@ export send_map;\n export hash;\n export cmp;\n export num;\n-export path;\n+export path, path2;\n export managed;\n \n // NDM seems to be necessary for resolve to work"}, {"sha": "c95a42ea3ec1f134c10adaac20a163d547c02ad7", "filename": "src/libcore/core.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -4,7 +4,12 @@\n \n import option::{some, none};\n import option = option::option;\n-import Path = path::Path;\n+\n+import Path = path2::Path;\n+import GenericPath = path2::GenericPath;\n+import WindowsPath = path2::WindowsPath;\n+import PosixPath = path2::PosixPath;\n+\n import tuple::{TupleOps, ExtendedTupleOps};\n import str::{StrSlice, UniqueStr};\n import vec::{ConstVector, CopyableVector, ImmutableVector};\n@@ -14,7 +19,8 @@ import num::Num;\n import ptr::Ptr;\n import to_str::ToStr;\n \n-export Path, option, some, none, unreachable;\n+export Path, WindowsPath, PosixPath, GenericPath;\n+export option, some, none, unreachable;\n export extensions;\n // The following exports are the extension impls for numeric types\n export Num, Times, TimesIx;"}, {"sha": "452aae49984cc52647fe949383492f5404bb20eb", "filename": "src/libcore/io.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -257,13 +257,14 @@ fn FILE_reader(f: *libc::FILE, cleanup: bool) -> Reader {\n \n fn stdin() -> Reader { rustrt::rust_get_stdin() as Reader }\n \n-fn file_reader(path: ~str) -> result<Reader, ~str> {\n-    let f = os::as_c_charp(path, |pathbuf| {\n-        os::as_c_charp(~\"r\", |modebuf|\n+fn file_reader(path: &Path) -> result<Reader, ~str> {\n+    let f = os::as_c_charp(path.to_str(), |pathbuf| {\n+        os::as_c_charp(\"r\", |modebuf|\n             libc::fopen(pathbuf, modebuf)\n         )\n     });\n-    return if f as uint == 0u { result::err(~\"error opening \" + path) }\n+    return if f as uint == 0u { result::err(~\"error opening \"\n+                                            + path.to_str()) }\n     else {\n         result::ok(FILE_reader(f, true))\n     }\n@@ -412,7 +413,7 @@ fn fd_writer(fd: fd_t, cleanup: bool) -> Writer {\n }\n \n \n-fn mk_file_writer(path: ~str, flags: ~[FileFlag])\n+fn mk_file_writer(path: &Path, flags: ~[FileFlag])\n     -> result<Writer, ~str> {\n \n     #[cfg(windows)]\n@@ -430,12 +431,13 @@ fn mk_file_writer(path: ~str, flags: ~[FileFlag])\n           NoFlag => ()\n         }\n     }\n-    let fd = do os::as_c_charp(path) |pathbuf| {\n+    let fd = do os::as_c_charp(path.to_str()) |pathbuf| {\n         libc::open(pathbuf, fflags,\n                    (S_IRUSR | S_IWUSR) as c_int)\n     };\n     if fd < (0 as c_int) {\n-        result::err(fmt!(\"error opening %s: %s\", path, os::last_os_error()))\n+        result::err(fmt!(\"error opening %s: %s\", path.to_str(),\n+                         os::last_os_error()))\n     } else {\n         result::ok(fd_writer(fd, true))\n     }\n@@ -614,19 +616,20 @@ impl<T: Writer> T : WriterUtil {\n     fn write_u8(n: u8) { self.write(&[n]) }\n }\n \n-fn file_writer(path: ~str, flags: ~[FileFlag]) -> result<Writer, ~str> {\n+fn file_writer(path: &Path, flags: ~[FileFlag]) -> result<Writer, ~str> {\n     result::chain(mk_file_writer(path, flags), |w| result::ok(w))\n }\n \n \n // FIXME: fileflags // #2004\n-fn buffered_file_writer(path: ~str) -> result<Writer, ~str> {\n-    let f = do os::as_c_charp(path) |pathbuf| {\n-        do os::as_c_charp(~\"w\") |modebuf| {\n+fn buffered_file_writer(path: &Path) -> result<Writer, ~str> {\n+    let f = do os::as_c_charp(path.to_str()) |pathbuf| {\n+        do os::as_c_charp(\"w\") |modebuf| {\n             libc::fopen(pathbuf, modebuf)\n         }\n     };\n-    return if f as uint == 0u { result::err(~\"error opening \" + path) }\n+    return if f as uint == 0u { result::err(~\"error opening \"\n+                                            + path.to_str()) }\n     else { result::ok(FILE_writer(f, true)) }\n }\n \n@@ -709,19 +712,19 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n     return bpos as uint;\n }\n \n-fn read_whole_file_str(file: ~str) -> result<~str, ~str> {\n+fn read_whole_file_str(file: &Path) -> result<~str, ~str> {\n     result::chain(read_whole_file(file), |bytes| {\n         if str::is_utf8(bytes) {\n             result::ok(str::from_bytes(bytes))\n        } else {\n-           result::err(file + ~\" is not UTF-8\")\n+           result::err(file.to_str() + ~\" is not UTF-8\")\n        }\n     })\n }\n \n // FIXME (#2004): implement this in a low-level way. Going through the\n // abstractions is pointless.\n-fn read_whole_file(file: ~str) -> result<~[u8], ~str> {\n+fn read_whole_file(file: &Path) -> result<~[u8], ~str> {\n     result::chain(file_reader(file), |rdr| {\n         result::ok(rdr.read_whole_stream())\n     })\n@@ -810,7 +813,7 @@ mod tests {\n \n     #[test]\n     fn test_simple() {\n-        let tmpfile: ~str = ~\"tmp/lib-io-test-simple.tmp\";\n+        let tmpfile = &Path(\"tmp/lib-io-test-simple.tmp\");\n         log(debug, tmpfile);\n         let frood: ~str =\n             ~\"A hoopy frood who really knows where his towel is.\";\n@@ -881,7 +884,7 @@ mod tests {\n \n     #[test]\n     fn file_reader_not_exist() {\n-        match io::file_reader(~\"not a file\") {\n+        match io::file_reader(&Path(\"not a file\")) {\n           result::err(e) => {\n             assert e == ~\"error opening not a file\";\n           }\n@@ -891,19 +894,19 @@ mod tests {\n \n     #[test]\n     fn file_writer_bad_name() {\n-        match io::file_writer(~\"?/?\", ~[]) {\n+        match io::file_writer(&Path(\"?/?\"), ~[]) {\n           result::err(e) => {\n-            assert str::starts_with(e, ~\"error opening ?/?\");\n+            assert str::starts_with(e, \"error opening\");\n           }\n           result::ok(_) => fail\n         }\n     }\n \n     #[test]\n     fn buffered_file_writer_bad_name() {\n-        match io::buffered_file_writer(~\"?/?\") {\n+        match io::buffered_file_writer(&Path(\"?/?\")) {\n           result::err(e) => {\n-            assert e == ~\"error opening ?/?\";\n+            assert str::starts_with(e, \"error opening\");\n           }\n           result::ok(_) => fail\n         }"}, {"sha": "4fb3e744235db6350618e77a2d35ad1f9737d237", "filename": "src/libcore/os.rs", "status": "modified", "additions": 120, "deletions": 128, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -1,3 +1,7 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n /*!\n  * Higher-level interfaces to libc::* functions and operating system services.\n  *\n@@ -16,16 +20,12 @@\n  * to write OS-ignorant code by default.\n  */\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n import libc::{c_char, c_void, c_int, c_uint, size_t, ssize_t,\n               mode_t, pid_t, FILE};\n import libc::{close, fclose};\n \n import option::{some, none};\n \n-import getcwd = rustrt::rust_getcwd;\n import consts::*;\n import task::TaskBuilder;\n \n@@ -56,7 +56,11 @@ extern mod rustrt {\n \n const tmpbuf_sz : uint = 1000u;\n \n-fn as_c_charp<T>(+s: ~str, f: fn(*c_char) -> T) -> T {\n+fn getcwd() -> Path {\n+    Path(rustrt::rust_getcwd())\n+}\n+\n+fn as_c_charp<T>(s: &str, f: fn(*c_char) -> T) -> T {\n     str::as_c_str(s, |b| f(b as *c_char))\n }\n \n@@ -106,19 +110,19 @@ mod win32 {\n         return res;\n     }\n \n-    fn as_utf16_p<T>(+s: ~str, f: fn(*u16) -> T) -> T {\n+    fn as_utf16_p<T>(s: &str, f: fn(*u16) -> T) -> T {\n         let mut t = str::to_utf16(s);\n         // Null terminate before passing on.\n         t += ~[0u16];\n         vec::as_buf(t, |buf, _len| f(buf))\n     }\n }\n \n-fn getenv(+n: ~str) -> option<~str> {\n+fn getenv(n: &str) -> option<~str> {\n     global_env::getenv(n)\n }\n \n-fn setenv(+n: ~str, +v: ~str) {\n+fn setenv(n: &str, v: &str) {\n     global_env::setenv(n, v)\n }\n \n@@ -143,17 +147,20 @@ mod global_env {\n         MsgEnv(comm::Chan<~[(~str,~str)]>)\n     }\n \n-    fn getenv(+n: ~str) -> option<~str> {\n+    fn getenv(n: &str) -> option<~str> {\n         let env_ch = get_global_env_chan();\n         let po = comm::port();\n-        comm::send(env_ch, MsgGetEnv(n, comm::chan(po)));\n+        comm::send(env_ch, MsgGetEnv(str::from_slice(n),\n+                                     comm::chan(po)));\n         comm::recv(po)\n     }\n \n-    fn setenv(+n: ~str, +v: ~str) {\n+    fn setenv(n: &str, v: &str) {\n         let env_ch = get_global_env_chan();\n         let po = comm::port();\n-        comm::send(env_ch, MsgSetEnv(n, v, comm::chan(po)));\n+        comm::send(env_ch, MsgSetEnv(str::from_slice(n),\n+                                     str::from_slice(v),\n+                                     comm::chan(po)));\n         comm::recv(po)\n     }\n \n@@ -212,7 +219,7 @@ mod global_env {\n         }\n \n         #[cfg(unix)]\n-        fn getenv(+n: ~str) -> option<~str> {\n+        fn getenv(n: &str) -> option<~str> {\n             unsafe {\n                 let s = str::as_c_str(n, libc::getenv);\n                 return if unsafe::reinterpret_cast(s) == 0 {\n@@ -225,7 +232,7 @@ mod global_env {\n         }\n \n         #[cfg(windows)]\n-        fn getenv(+n: ~str) -> option<~str> {\n+        fn getenv(n: &str) -> option<~str> {\n             import libc::types::os::arch::extra::*;\n             import libc::funcs::extra::kernel32::*;\n             import win32::*;\n@@ -238,7 +245,7 @@ mod global_env {\n \n \n         #[cfg(unix)]\n-        fn setenv(+n: ~str, +v: ~str) {\n+        fn setenv(n: &str, v: &str) {\n \n             // FIXME: remove this when export globs work properly. #1238\n             import libc::funcs::posix01::unistd::setenv;\n@@ -251,7 +258,7 @@ mod global_env {\n \n \n         #[cfg(windows)]\n-        fn setenv(+n: ~str, +v: ~str) {\n+        fn setenv(n: &str, v: &str) {\n             // FIXME: remove imports when export globs work properly. #1238\n             import libc::funcs::extra::kernel32::*;\n             import win32::*;\n@@ -266,7 +273,7 @@ mod global_env {\n }\n \n fn fdopen(fd: c_int) -> *FILE {\n-    return do as_c_charp(~\"r\") |modebuf| {\n+    return do as_c_charp(\"r\") |modebuf| {\n         libc::fdopen(fd, modebuf)\n     };\n }\n@@ -365,8 +372,8 @@ fn dup2(src: c_int, dst: c_int) -> c_int {\n }\n \n \n-fn dll_filename(+base: ~str) -> ~str {\n-    return pre() + base + dll_suffix();\n+fn dll_filename(base: &str) -> ~str {\n+    return pre() + str::from_slice(base) + dll_suffix();\n \n     #[cfg(unix)]\n     fn pre() -> ~str { ~\"lib\" }\n@@ -379,7 +386,7 @@ fn dll_filename(+base: ~str) -> ~str {\n fn self_exe_path() -> option<Path> {\n \n     #[cfg(target_os = \"freebsd\")]\n-    fn load_self() -> option<Path> {\n+    fn load_self() -> option<~str> {\n         unsafe {\n             import libc::funcs::bsd44::*;\n             import libc::consts::os::extra::*;\n@@ -395,17 +402,17 @@ fn self_exe_path() -> option<Path> {\n     }\n \n     #[cfg(target_os = \"linux\")]\n-    fn load_self() -> option<Path> {\n+    fn load_self() -> option<~str> {\n         import libc::funcs::posix01::unistd::readlink;\n         do fill_charp_buf() |buf, sz| {\n-            do as_c_charp(~\"/proc/self/exe\") |proc_self_buf| {\n+            do as_c_charp(\"/proc/self/exe\") |proc_self_buf| {\n                 readlink(proc_self_buf, buf, sz) != (-1 as ssize_t)\n             }\n         }\n     }\n \n     #[cfg(target_os = \"macos\")]\n-    fn load_self() -> option<Path> {\n+    fn load_self() -> option<~str> {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::*;\n         do fill_charp_buf() |buf, sz| {\n@@ -415,7 +422,7 @@ fn self_exe_path() -> option<Path> {\n     }\n \n     #[cfg(windows)]\n-    fn load_self() -> option<Path> {\n+    fn load_self() -> option<~str> {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::types::os::arch::extra::*;\n         import libc::funcs::extra::kernel32::*;\n@@ -426,7 +433,7 @@ fn self_exe_path() -> option<Path> {\n     }\n \n     do option::map(load_self()) |pth| {\n-        path::dirname(pth) + path::path_sep()\n+        Path(pth).dir_path()\n     }\n }\n \n@@ -447,7 +454,7 @@ fn self_exe_path() -> option<Path> {\n fn homedir() -> option<Path> {\n     return match getenv(~\"HOME\") {\n         some(p) => if !str::is_empty(p) {\n-          some(p)\n+          some(Path(p))\n         } else {\n           secondary()\n         },\n@@ -463,7 +470,7 @@ fn homedir() -> option<Path> {\n     fn secondary() -> option<Path> {\n         do option::chain(getenv(~\"USERPROFILE\")) |p| {\n             if !str::is_empty(p) {\n-                some(p)\n+                some(Path(p))\n             } else {\n                 none\n             }\n@@ -484,42 +491,43 @@ fn homedir() -> option<Path> {\n fn tmpdir() -> Path {\n     return lookup();\n \n-    fn getenv_nonempty(+v: Path) -> option<Path> {\n+    fn getenv_nonempty(v: &str) -> option<Path> {\n         match getenv(v) {\n             some(x) =>\n                 if str::is_empty(x) {\n                     none\n                 } else {\n-                    some(x)\n+                    some(Path(x))\n                 },\n             _ => none\n         }\n     }\n \n     #[cfg(unix)]\n     fn lookup() -> Path {\n-        option::get_default(getenv_nonempty(~\"TMPDIR\"), ~\"/tmp\")\n+        option::get_default(getenv_nonempty(\"TMPDIR\"),\n+                            Path(\"/tmp\"))\n     }\n \n     #[cfg(windows)]\n     fn lookup() -> Path {\n         option::get_default(\n-                    option::or(getenv_nonempty(~\"TMP\"),\n-                    option::or(getenv_nonempty(~\"TEMP\"),\n-                    option::or(getenv_nonempty(~\"USERPROFILE\"),\n-                               getenv_nonempty(~\"WINDIR\")))),\n-                    ~\"C:\\\\Windows\")\n+                    option::or(getenv_nonempty(\"TMP\"),\n+                    option::or(getenv_nonempty(\"TEMP\"),\n+                    option::or(getenv_nonempty(\"USERPROFILE\"),\n+                               getenv_nonempty(\"WINDIR\")))),\n+                    Path(\"C:\\\\Windows\"))\n     }\n }\n /// Recursively walk a directory structure\n-fn walk_dir(+p: Path, f: fn(Path) -> bool) {\n+fn walk_dir(p: &Path, f: fn((&Path)) -> bool) {\n \n     walk_dir_(p, f);\n \n-    fn walk_dir_(+p: Path, f: fn(Path) -> bool) -> bool {\n+    fn walk_dir_(p: &Path, f: fn((&Path)) -> bool) -> bool {\n         let mut keepgoing = true;\n         do list_dir(p).each |q| {\n-            let path = path::connect(p, q);\n+            let path = &p.push(q);\n             if !f(path) {\n                 keepgoing = false;\n                 false\n@@ -541,15 +549,15 @@ fn walk_dir(+p: Path, f: fn(Path) -> bool) {\n }\n \n /// Indicates whether a path represents a directory\n-fn path_is_dir(+p: Path) -> bool {\n-    do str::as_c_str(p) |buf| {\n+fn path_is_dir(p: &Path) -> bool {\n+    do str::as_c_str(p.to_str()) |buf| {\n         rustrt::rust_path_is_dir(buf) != 0 as c_int\n     }\n }\n \n /// Indicates whether a path exists\n-fn path_exists(+p: Path) -> bool {\n-    do str::as_c_str(p) |buf| {\n+fn path_exists(p: &Path) -> bool {\n+    do str::as_c_str(p.to_str()) |buf| {\n         rustrt::rust_path_exists(buf) != 0 as c_int\n     }\n }\n@@ -566,58 +574,50 @@ fn path_exists(+p: Path) -> bool {\n // NB: this is here rather than in path because it is a form of environment\n // querying; what it does depends on the process working directory, not just\n // the input paths.\n-fn make_absolute(+p: Path) -> Path {\n-    if path::path_is_absolute(p) {\n-        p\n+fn make_absolute(p: &Path) -> Path {\n+    if p.is_absolute {\n+        copy *p\n     } else {\n-        path::connect(getcwd(), p)\n+        getcwd().push_many(p.components)\n     }\n }\n \n \n /// Creates a directory at the specified path\n-fn make_dir(+p: Path, mode: c_int) -> bool {\n+fn make_dir(p: &Path, mode: c_int) -> bool {\n     return mkdir(p, mode);\n \n     #[cfg(windows)]\n-    fn mkdir(+p: Path, _mode: c_int) -> bool {\n+    fn mkdir(p: &Path, _mode: c_int) -> bool {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::types::os::arch::extra::*;\n         import libc::funcs::extra::kernel32::*;\n         import win32::*;\n         // FIXME: turn mode into something useful? #2623\n-        do as_utf16_p(p) |buf| {\n+        do as_utf16_p(p.to_str()) |buf| {\n             CreateDirectoryW(buf, unsafe { unsafe::reinterpret_cast(0) })\n                 != (0 as BOOL)\n         }\n     }\n \n     #[cfg(unix)]\n-    fn mkdir(+p: Path, mode: c_int) -> bool {\n-        do as_c_charp(p) |c| {\n+    fn mkdir(p: &Path, mode: c_int) -> bool {\n+        do as_c_charp(p.to_str()) |c| {\n             libc::mkdir(c, mode as mode_t) == (0 as c_int)\n         }\n     }\n }\n \n /// Lists the contents of a directory\n-fn list_dir(+p: Path) -> ~[~str] {\n+fn list_dir(p: &Path) -> ~[~str] {\n \n     #[cfg(unix)]\n-    fn star(+p: ~str) -> ~str { p }\n+    fn star(p: &Path) -> Path { copy *p }\n \n     #[cfg(windows)]\n-    fn star(+p: ~str) -> ~str {\n-        let pl = str::len(p);\n-        if pl == 0u || (p[pl - 1u] as char != path::consts::path_sep\n-                        || p[pl - 1u] as char != path::consts::alt_path_sep) {\n-            p + path::path_sep() + ~\"*\"\n-        } else {\n-            p + ~\"*\"\n-        }\n-    }\n+    fn star(p: &Path) -> Path { p.push(\"*\") }\n \n-    do rustrt::rust_list_files(star(p)).filter |filename| {\n+    do rustrt::rust_list_files(star(p).to_str()).filter |filename| {\n         filename != ~\".\" && filename != ~\"..\"\n     }\n }\n@@ -627,90 +627,84 @@ fn list_dir(+p: Path) -> ~[~str] {\n  *\n  * This version prepends each entry with the directory.\n  */\n-fn list_dir_path(+p: Path) -> ~[~str] {\n-    let mut p = p;\n-    let pl = str::len(p);\n-    if pl == 0u || (p[pl - 1u] as char != path::consts::path_sep\n-                    && p[pl - 1u] as char != path::consts::alt_path_sep) {\n-        p += path::path_sep();\n-    }\n-    os::list_dir(p).map(|f| p + f)\n+fn list_dir_path(p: &Path) -> ~[~Path] {\n+    os::list_dir(p).map(|f| ~p.push(f))\n }\n \n /// Removes a directory at the specified path\n-fn remove_dir(+p: Path) -> bool {\n+fn remove_dir(p: &Path) -> bool {\n    return rmdir(p);\n \n     #[cfg(windows)]\n-    fn rmdir(+p: Path) -> bool {\n+    fn rmdir(p: &Path) -> bool {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        return do as_utf16_p(p) |buf| {\n+        return do as_utf16_p(p.to_str()) |buf| {\n             RemoveDirectoryW(buf) != (0 as BOOL)\n         };\n     }\n \n     #[cfg(unix)]\n-    fn rmdir(+p: Path) -> bool {\n-        return do as_c_charp(p) |buf| {\n+    fn rmdir(p: &Path) -> bool {\n+        return do as_c_charp(p.to_str()) |buf| {\n             libc::rmdir(buf) == (0 as c_int)\n         };\n     }\n }\n \n-fn change_dir(+p: Path) -> bool {\n+fn change_dir(p: &Path) -> bool {\n     return chdir(p);\n \n     #[cfg(windows)]\n-    fn chdir(+p: Path) -> bool {\n+    fn chdir(p: &Path) -> bool {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        return do as_utf16_p(p) |buf| {\n+        return do as_utf16_p(p.to_str()) |buf| {\n             SetCurrentDirectoryW(buf) != (0 as BOOL)\n         };\n     }\n \n     #[cfg(unix)]\n-    fn chdir(+p: Path) -> bool {\n-        return do as_c_charp(p) |buf| {\n+    fn chdir(p: &Path) -> bool {\n+        return do as_c_charp(p.to_str()) |buf| {\n             libc::chdir(buf) == (0 as c_int)\n         };\n     }\n }\n \n /// Copies a file from one location to another\n-fn copy_file(+from: Path, +to: Path) -> bool {\n+fn copy_file(from: &Path, to: &Path) -> bool {\n     return do_copy_file(from, to);\n \n     #[cfg(windows)]\n-    fn do_copy_file(+from: Path, +to: Path) -> bool {\n+    fn do_copy_file(from: &Path, to: &Path) -> bool {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        return do as_utf16_p(from) |fromp| {\n-            do as_utf16_p(to) |top| {\n+        return do as_utf16_p(from.to_str()) |fromp| {\n+            do as_utf16_p(to.to_str()) |top| {\n                 CopyFileW(fromp, top, (0 as BOOL)) != (0 as BOOL)\n             }\n         }\n     }\n \n     #[cfg(unix)]\n-    fn do_copy_file(+from: Path, +to: Path) -> bool {\n-        let istream = do as_c_charp(from) |fromp| {\n-            do as_c_charp(~\"rb\") |modebuf| {\n+    fn do_copy_file(from: &Path, to: &Path) -> bool {\n+        let istream = do as_c_charp(from.to_str()) |fromp| {\n+            do as_c_charp(\"rb\") |modebuf| {\n                 libc::fopen(fromp, modebuf)\n             }\n         };\n         if istream as uint == 0u {\n             return false;\n         }\n-        let ostream = do as_c_charp(to) |top| {\n-            do as_c_charp(~\"w+b\") |modebuf| {\n+        let ostream = do as_c_charp(to.to_str()) |top| {\n+            do as_c_charp(\"w+b\") |modebuf| {\n                 libc::fopen(top, modebuf)\n             }\n         };\n@@ -746,24 +740,24 @@ fn copy_file(+from: Path, +to: Path) -> bool {\n }\n \n /// Deletes an existing file\n-fn remove_file(+p: Path) -> bool {\n+fn remove_file(p: &Path) -> bool {\n     return unlink(p);\n \n     #[cfg(windows)]\n-    fn unlink(+p: Path) -> bool {\n+    fn unlink(p: &Path) -> bool {\n         // FIXME (similar to Issue #2006): remove imports when export globs\n         // work properly.\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        return do as_utf16_p(p) |buf| {\n+        return do as_utf16_p(p.to_str()) |buf| {\n             DeleteFileW(buf) != (0 as BOOL)\n         };\n     }\n \n     #[cfg(unix)]\n-    fn unlink(+p: Path) -> bool {\n-        return do as_c_charp(p) |buf| {\n+    fn unlink(p: &Path) -> bool {\n+        return do as_c_charp(p.to_str()) |buf| {\n             libc::unlink(buf) == (0 as c_int)\n         };\n     }\n@@ -887,11 +881,7 @@ mod tests {\n         log(debug, path);\n \n         // Hard to test this function\n-        if os::sysname() != ~\"win32\" {\n-            assert str::starts_with(path, path::path_sep());\n-        } else {\n-            assert path[1] == ':' as u8;\n-        }\n+        assert path.is_absolute;\n     }\n \n     #[test]\n@@ -926,10 +916,10 @@ mod tests {\n     fn test() {\n         assert (!path::path_is_absolute(~\"test-path\"));\n \n-        log(debug, ~\"Current working directory: \" + getcwd());\n+        log(debug, ~\"Current working directory: \" + getcwd().to_str());\n \n-        log(debug, make_absolute(~\"test-path\"));\n-        log(debug, make_absolute(~\"/usr/bin\"));\n+        log(debug, make_absolute(&Path(\"test-path\")));\n+        log(debug, make_absolute(&Path(\"/usr/bin\")));\n     }\n \n     #[test]\n@@ -938,7 +928,7 @@ mod tests {\n         let oldhome = getenv(~\"HOME\");\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n-        assert os::homedir() == some(~\"/home/MountainView\");\n+        assert os::homedir() == some(Path(\"/home/MountainView\"));\n \n         setenv(~\"HOME\", ~\"\");\n         assert os::homedir() == none;\n@@ -959,16 +949,16 @@ mod tests {\n         assert os::homedir() == none;\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n-        assert os::homedir() == some(~\"/home/MountainView\");\n+        assert os::homedir() == some(Path(\"/home/MountainView\"));\n \n         setenv(~\"HOME\", ~\"\");\n \n         setenv(~\"USERPROFILE\", ~\"/home/MountainView\");\n-        assert os::homedir() == some(~\"/home/MountainView\");\n+        assert os::homedir() == some(Path(\"/home/MountainView\"));\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n         setenv(~\"USERPROFILE\", ~\"/home/PaloAlto\");\n-        assert os::homedir() == some(~\"/home/MountainView\");\n+        assert os::homedir() == some(Path(\"/home/MountainView\"));\n \n         option::iter(oldhome, |s| setenv(~\"HOME\", s));\n         option::iter(olduserprofile,\n@@ -977,16 +967,18 @@ mod tests {\n \n     #[test]\n     fn tmpdir() {\n-        assert !str::is_empty(os::tmpdir());\n+        assert !str::is_empty(os::tmpdir().to_str());\n     }\n \n     // Issue #712\n     #[test]\n-    fn test_list_dir_no_invalid_memory_access() { os::list_dir(~\".\"); }\n+    fn test_list_dir_no_invalid_memory_access() {\n+        os::list_dir(&Path(\".\"));\n+    }\n \n     #[test]\n     fn list_dir() {\n-        let dirs = os::list_dir(~\".\");\n+        let dirs = os::list_dir(&Path(\".\"));\n         // Just assuming that we've got some contents in the current directory\n         assert (vec::len(dirs) > 0u);\n \n@@ -995,34 +987,34 @@ mod tests {\n \n     #[test]\n     fn path_is_dir() {\n-        assert (os::path_is_dir(~\".\"));\n-        assert (!os::path_is_dir(~\"test/stdtest/fs.rs\"));\n+        assert (os::path_is_dir(&Path(\".\")));\n+        assert (!os::path_is_dir(&Path(\"test/stdtest/fs.rs\")));\n     }\n \n     #[test]\n     fn path_exists() {\n-        assert (os::path_exists(~\".\"));\n-        assert (!os::path_exists(~\"test/nonexistent-bogus-path\"));\n+        assert (os::path_exists(&Path(\".\")));\n+        assert (!os::path_exists(&Path(\"test/nonexistent-bogus-path\")));\n     }\n \n     #[test]\n     fn copy_file_does_not_exist() {\n-      assert !os::copy_file(~\"test/nonexistent-bogus-path\",\n-                           ~\"test/other-bogus-path\");\n-      assert !os::path_exists(~\"test/other-bogus-path\");\n+      assert !os::copy_file(&Path(\"test/nonexistent-bogus-path\"),\n+                            &Path(\"test/other-bogus-path\"));\n+      assert !os::path_exists(&Path(\"test/other-bogus-path\"));\n     }\n \n     #[test]\n     fn copy_file_ok() {\n       let tempdir = getcwd(); // would like to use $TMPDIR,\n                               // doesn't seem to work on Linux\n-      assert (str::len(tempdir) > 0u);\n-      let in = tempdir + path::path_sep() + ~\"in.txt\";\n-      let out = tempdir + path::path_sep() + ~\"out.txt\";\n+      assert (str::len(tempdir.to_str()) > 0u);\n+      let in = tempdir.push(\"in.txt\");\n+      let out = tempdir.push(\"out.txt\");\n \n       /* Write the temp input file */\n-        let ostream = do as_c_charp(in) |fromp| {\n-            do as_c_charp(~\"w+b\") |modebuf| {\n+        let ostream = do as_c_charp(in.to_str()) |fromp| {\n+            do as_c_charp(\"w+b\") |modebuf| {\n                 libc::fopen(fromp, modebuf)\n             }\n       };\n@@ -1034,14 +1026,14 @@ mod tests {\n                                (str::len(s) + 1u) as size_t, ostream)\n                   == buf.len() as size_t)};\n       assert (libc::fclose(ostream) == (0u as c_int));\n-      let rs = os::copy_file(in, out);\n-      if (!os::path_exists(in)) {\n-        fail (fmt!(\"%s doesn't exist\", in));\n+      let rs = os::copy_file(&in, &out);\n+      if (!os::path_exists(&in)) {\n+        fail (fmt!(\"%s doesn't exist\", in.to_str()));\n       }\n       assert(rs);\n-      let rslt = run::run_program(~\"diff\", ~[in, out]);\n+      let rslt = run::run_program(~\"diff\", ~[in.to_str(), out.to_str()]);\n       assert (rslt == 0);\n-      assert (remove_file(in));\n-      assert (remove_file(out));\n+      assert (remove_file(&in));\n+      assert (remove_file(&out));\n     }\n }"}, {"sha": "9d1351db3ac506784ef84a09b0711dbe599be5d5", "filename": "src/libcore/path2.rs", "status": "modified", "additions": 165, "deletions": 129, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibcore%2Fpath2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibcore%2Fpath2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath2.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -14,73 +14,82 @@ struct PosixPath {\n     components: ~[~str];\n }\n \n-trait Path {\n+trait GenericPath {\n \n-    static fn from_str((&str)) -> self;\n-    fn to_str() -> ~str;\n+    static pure fn from_str((&str)) -> self;\n \n-    fn dirname() -> ~str;\n-    fn filename() -> option<~str>;\n-    fn filestem() -> option<~str>;\n-    fn filetype() -> option<~str>;\n+    pure fn dirname() -> ~str;\n+    pure fn filename() -> option<~str>;\n+    pure fn filestem() -> option<~str>;\n+    pure fn filetype() -> option<~str>;\n \n-    fn with_dirname((&str)) -> self;\n-    fn with_filename((&str)) -> self;\n-    fn with_filestem((&str)) -> self;\n-    fn with_filetype((&str)) -> self;\n+    pure fn with_dirname((&str)) -> self;\n+    pure fn with_filename((&str)) -> self;\n+    pure fn with_filestem((&str)) -> self;\n+    pure fn with_filetype((&str)) -> self;\n \n-    fn push_components((&[~str])) -> self;\n-    fn pop_component() -> self;\n+    pure fn push((&str)) -> self;\n+    pure fn push_rel((&self)) -> self;\n+    pure fn push_many((&[~str])) -> self;\n+    pure fn pop() -> self;\n }\n \n-// FIXME (#3227): when default methods in traits are working, de-duplicate\n-// PosixPath and WindowsPath, most of their methods are common.\n+#[cfg(windows)]\n+type Path = WindowsPath;\n+\n+#[cfg(windows)]\n+pure fn Path(s: &str) -> Path {\n+    from_str::<WindowsPath>(s)\n+}\n+\n+#[cfg(unix)]\n+type Path = PosixPath;\n \n-impl PosixPath : Path {\n+#[cfg(unix)]\n+pure fn Path(s: &str) -> Path {\n+    from_str::<PosixPath>(s)\n+}\n+\n+impl PosixPath : ToStr {\n     fn to_str() -> ~str {\n-        match self.filename() {\n-          none => self.dirname(),\n-          some(ref f) =>\n-          if (self.components.len() == 1 &&\n-              !self.is_absolute) {\n-            copy *f\n-          } else {\n-            self.dirname() + \"/\" + *f\n-          }\n+        let mut s = ~\"\";\n+        if self.is_absolute {\n+            s += \"/\";\n         }\n+        s + str::connect(self.components, \"/\")\n     }\n+}\n \n-    static fn from_str(s: &str) -> PosixPath {\n+// FIXME (#3227): when default methods in traits are working, de-duplicate\n+// PosixPath and WindowsPath, most of their methods are common.\n+impl PosixPath : GenericPath {\n+\n+    static pure fn from_str(s: &str) -> PosixPath {\n         let mut components = str::split_nonempty(s, |c| c == '/');\n         let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n         return PosixPath { is_absolute: is_absolute,\n                            components: normalize(components) }\n     }\n \n-    fn dirname() -> ~str {\n-        let mut s = ~\"\";\n-        if self.is_absolute {\n-            s += \"/\";\n-        }\n-        let mut d = copy self.components;\n-        if d.len() != 0 {\n-            vec::pop(d);\n-        }\n-        s += str::connect(d, \"/\");\n-        if s.len() == 0 {\n-            s = ~\".\";\n+    pure fn dirname() -> ~str {\n+        unchecked {\n+            let s = self.dir_path().to_str();\n+            if s.len() == 0 {\n+                ~\".\"\n+            } else {\n+                s\n+            }\n         }\n-        return s;\n     }\n \n-    fn filename() -> option<~str> {\n+    pure fn filename() -> option<~str> {\n         match self.components.len() {\n           0 => none,\n           n => some(copy self.components[n - 1])\n         }\n     }\n \n-    fn filestem() -> option<~str> {\n+    pure fn filestem() -> option<~str> {\n         match self.filename() {\n           none => none,\n           some(ref f) => {\n@@ -92,7 +101,7 @@ impl PosixPath : Path {\n         }\n     }\n \n-    fn filetype() -> option<~str> {\n+    pure fn filetype() -> option<~str> {\n         match self.filename() {\n           none => none,\n           some(ref f) => {\n@@ -104,28 +113,30 @@ impl PosixPath : Path {\n         }\n     }\n \n-    fn with_dirname(d: &str) -> PosixPath {\n+    pure fn with_dirname(d: &str) -> PosixPath {\n         let dpath = from_str::<PosixPath>(d);\n         match self.filename() {\n-          some(ref f) => dpath.push_components(~[copy *f]),\n+          some(ref f) => dpath.push(*f),\n           none => dpath\n         }\n     }\n \n-    fn with_filename(f: &str) -> PosixPath {\n-        assert ! str::any(f, |c| windows::is_sep(c as u8));\n-        self.dir_path().push_components(~[str::from_slice(f)])\n+    pure fn with_filename(f: &str) -> PosixPath {\n+        unchecked {\n+            assert ! str::any(f, |c| windows::is_sep(c as u8));\n+            self.dir_path().push(f)\n+        }\n     }\n \n-    fn with_filestem(s: &str) -> PosixPath {\n+    pure fn with_filestem(s: &str) -> PosixPath {\n         match self.filetype() {\n           none => self.with_filename(s),\n           some(ref t) =>\n           self.with_filename(str::from_slice(s) + \".\" + *t)\n         }\n     }\n \n-    fn with_filetype(t: &str) -> PosixPath {\n+    pure fn with_filetype(t: &str) -> PosixPath {\n         if t.len() == 0 {\n             match self.filestem() {\n               none => copy self,\n@@ -141,15 +152,15 @@ impl PosixPath : Path {\n         }\n     }\n \n-    fn dir_path() -> PosixPath {\n+    pure fn dir_path() -> PosixPath {\n         if self.components.len() != 0 {\n-            self.pop_component()\n+            self.pop()\n         } else {\n             copy self\n         }\n     }\n \n-    fn file_path() -> PosixPath {\n+    pure fn file_path() -> PosixPath {\n         let cs = match self.filename() {\n           none => ~[],\n           some(ref f) => ~[copy *f]\n@@ -158,42 +169,56 @@ impl PosixPath : Path {\n                            components: cs }\n     }\n \n-    fn push_components(cs: &[~str]) -> PosixPath {\n+    pure fn push_rel(other: &PosixPath) -> PosixPath {\n+        assert !other.is_absolute;\n+        self.push_many(other.components)\n+    }\n+\n+    pure fn push_many(cs: &[~str]) -> PosixPath {\n         return PosixPath { components: normalize(self.components + cs),\n                            ..self }\n     }\n \n-    fn pop_component() -> PosixPath {\n+    pure fn push(s: &str) -> PosixPath {\n+        let mut cs = self.components;\n+        unchecked { vec::push(cs, move str::from_slice(s)); }\n+        cs = normalize(cs);\n+        return PosixPath { components: move cs,\n+                           ..self }\n+    }\n+\n+    pure fn pop() -> PosixPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n-            vec::pop(cs);\n+            unchecked { vec::pop(cs); }\n         }\n-        return PosixPath { components: cs, ..self }\n+        return PosixPath { components: move cs, ..self }\n     }\n-\n-\n-\n }\n \n \n-impl WindowsPath : Path {\n-\n+impl WindowsPath : ToStr {\n     fn to_str() -> ~str {\n-        match self.filename() {\n-          none => self.dirname(),\n-          some(ref f) =>\n-          if (self.components.len() == 1 &&\n-              !self.is_absolute &&\n-              self.host == none &&\n-              self.device == none) {\n-            copy *f\n-          } else {\n-            self.dirname() + \"\\\\\" + *f\n-          }\n+        let mut s = ~\"\";\n+        match self.host {\n+          some(h) => { s += \"\\\\\\\\\"; s += h; }\n+          none => { }\n+        }\n+        match self.device {\n+          some(d) => { s += d; s += \":\"; }\n+          none => { }\n+        }\n+        if self.is_absolute {\n+            s += \"\\\\\";\n         }\n+        s + str::connect(self.components, \"\\\\\")\n     }\n+}\n+\n \n-    static fn from_str(s: &str) -> WindowsPath {\n+impl WindowsPath : GenericPath {\n+\n+    static pure fn from_str(s: &str) -> WindowsPath {\n         let host;\n         let device;\n         let rest;\n@@ -229,38 +254,25 @@ impl WindowsPath : Path {\n                              components: normalize(components) }\n     }\n \n-    fn dirname() -> ~str {\n-        let mut s = ~\"\";\n-        match self.host {\n-          some(h) => { s += \"\\\\\\\\\"; s += h; }\n-          none => { }\n-        }\n-        match self.device {\n-          some(d) => { s += d; s += \":\"; }\n-          none => { }\n-        }\n-        if self.is_absolute {\n-            s += \"\\\\\";\n-        }\n-        let mut d = copy self.components;\n-        if d.len() != 0 {\n-            vec::pop(d);\n-        }\n-        s += str::connect(d, \"\\\\\");\n-        if s.len() == 0 {\n-            s = ~\".\";\n+    pure fn dirname() -> ~str {\n+        unchecked {\n+            let s = self.dir_path().to_str();\n+            if s.len() == 0 {\n+                ~\".\"\n+            } else {\n+                s\n+            }\n         }\n-        return s;\n     }\n \n-    fn filename() -> option<~str> {\n+    pure fn filename() -> option<~str> {\n         match self.components.len() {\n           0 => none,\n           n => some(copy self.components[n - 1])\n         }\n     }\n \n-    fn filestem() -> option<~str> {\n+    pure fn filestem() -> option<~str> {\n         match self.filename() {\n           none => none,\n           some(ref f) => {\n@@ -272,7 +284,7 @@ impl WindowsPath : Path {\n         }\n     }\n \n-    fn filetype() -> option<~str> {\n+    pure fn filetype() -> option<~str> {\n         match self.filename() {\n           none => none,\n           some(ref f) => {\n@@ -284,28 +296,28 @@ impl WindowsPath : Path {\n         }\n     }\n \n-    fn with_dirname(d: &str) -> WindowsPath {\n+    pure fn with_dirname(d: &str) -> WindowsPath {\n         let dpath = from_str::<WindowsPath>(d);\n         match self.filename() {\n-          some(ref f) => dpath.push_components(~[copy *f]),\n+          some(ref f) => dpath.push(*f),\n           none => dpath\n         }\n     }\n \n-    fn with_filename(f: &str) -> WindowsPath {\n+    pure fn with_filename(f: &str) -> WindowsPath {\n         assert ! str::any(f, |c| windows::is_sep(c as u8));\n-        self.dir_path().push_components(~[str::from_slice(f)])\n+        self.dir_path().push(f)\n     }\n \n-    fn with_filestem(s: &str) -> WindowsPath {\n+    pure fn with_filestem(s: &str) -> WindowsPath {\n         match self.filetype() {\n           none => self.with_filename(s),\n           some(ref t) =>\n           self.with_filename(str::from_slice(s) + \".\" + *t)\n         }\n     }\n \n-    fn with_filetype(t: &str) -> WindowsPath {\n+    pure fn with_filetype(t: &str) -> WindowsPath {\n         if t.len() == 0 {\n             match self.filestem() {\n               none => copy self,\n@@ -321,15 +333,15 @@ impl WindowsPath : Path {\n         }\n     }\n \n-    fn dir_path() -> WindowsPath {\n+    pure fn dir_path() -> WindowsPath {\n         if self.components.len() != 0 {\n-            self.pop_component()\n+            self.pop()\n         } else {\n             copy self\n         }\n     }\n \n-    fn file_path() -> WindowsPath {\n+    pure fn file_path() -> WindowsPath {\n         let cs = match self.filename() {\n           none => ~[],\n           some(ref f) => ~[copy *f]\n@@ -340,30 +352,47 @@ impl WindowsPath : Path {\n                              components: cs }\n     }\n \n-    fn push_components(cs: &[~str]) -> WindowsPath {\n+    pure fn push_rel(other: &WindowsPath) -> WindowsPath {\n+        assert !other.is_absolute;\n+        self.push_many(other.components)\n+    }\n+\n+    pure fn push_many(cs: &[~str]) -> WindowsPath {\n         return WindowsPath { components: normalize(self.components + cs),\n                             ..self }\n     }\n \n-    fn pop_component() -> WindowsPath {\n+    pure fn push(s: &str) -> WindowsPath {\n+        let mut cs = self.components;\n+        unchecked { vec::push(cs, move str::from_slice(s)); }\n+        cs = normalize(cs);\n+        return WindowsPath { components: move cs,\n+                             ..self }\n+    }\n+\n+    pure fn pop() -> WindowsPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n-            vec::pop(cs);\n+            unchecked { vec::pop(cs); }\n         }\n-        return WindowsPath { components: cs, ..self }\n+        return WindowsPath { components: move cs, ..self }\n     }\n }\n \n \n-fn normalize(components: &[~str]) -> ~[~str] {\n+pure fn normalize(components: &[~str]) -> ~[~str] {\n     let mut cs = ~[];\n-    for components.each |c| {\n-        if c == ~\".\" { again; }\n-        if c == ~\"..\" && cs.len() != 0 {\n-            vec::pop(cs);\n-            again;\n+    unchecked {\n+        for components.each |c| {\n+            unchecked {\n+                if c == ~\".\" && components.len() > 1 { again; }\n+                if c == ~\"..\" && cs.len() != 0 {\n+                    vec::pop(cs);\n+                    again;\n+                }\n+                vec::push(cs, copy c);\n+            }\n         }\n-        vec::push(cs, copy c);\n     }\n     cs\n }\n@@ -384,6 +413,7 @@ mod posix {\n         }\n \n         t(&(mk(\"hi\")), \"hi\");\n+        t(&(mk(\"/lib\")), \"/lib\");\n         t(&(mk(\"hi/there\")), \"hi/there\");\n         t(&(mk(\"hi/there.txt\")), \"hi/there.txt\");\n \n@@ -401,7 +431,7 @@ mod posix {\n           \"a/foo.txt\");\n \n         t(&(mk(\"a/b/c\")\n-            .push_components([~\"..\"])), \"a/b\");\n+            .push(\"..\")), \"a/b\");\n \n         t(&(mk(\"there.txt\")\n             .with_filetype(\"o\")), \"there.o\");\n@@ -425,7 +455,7 @@ mod posix {\n             \"/usr/lib/there.o\");\n \n         t(&(mk(\"/usr/bin/rust\")\n-            .push_components([~\"lib\", ~\"thingy.so\"])\n+            .push_many([~\"lib\", ~\"thingy.so\"])\n             .with_filestem(\"librustc\")),\n           \"/usr/bin/rust/lib/librustc.so\");\n \n@@ -437,11 +467,11 @@ mod posix {\n mod windows {\n \n     #[inline(always)]\n-    fn is_sep(u: u8) -> bool {\n+    pure fn is_sep(u: u8) -> bool {\n         u == '/' as u8 || u == '\\\\' as u8\n     }\n \n-    fn extract_unc_prefix(s: &str) -> option<(~str,~str)> {\n+    pure fn extract_unc_prefix(s: &str) -> option<(~str,~str)> {\n         if (s.len() > 1 &&\n             s[0] == '\\\\' as u8 &&\n             s[1] == '\\\\' as u8) {\n@@ -458,14 +488,20 @@ mod windows {\n         none\n     }\n \n-    fn extract_drive_prefix(s: &str) -> option<(~str,~str)> {\n-        if (s.len() > 1 &&\n-            libc::isalpha(s[0] as libc::c_int) != 0 &&\n-            s[1] == ':' as u8) {\n-            let rest = if s.len() == 2 { ~\"\" } else { s.slice(2, s.len()) };\n-            return some((s.slice(0,1), rest));\n+    pure fn extract_drive_prefix(s: &str) -> option<(~str,~str)> {\n+        unchecked {\n+            if (s.len() > 1 &&\n+                libc::isalpha(s[0] as libc::c_int) != 0 &&\n+                s[1] == ':' as u8) {\n+                let rest = if s.len() == 2 {\n+                    ~\"\"\n+                } else {\n+                    s.slice(2, s.len())\n+                };\n+                return some((s.slice(0,1), rest));\n+            }\n+            none\n         }\n-        none\n     }\n \n     #[test]\n@@ -532,7 +568,7 @@ mod windows {\n             \"c:\\\\program files C\\\\there.o\");\n \n         t(&(mk(\"c:\\\\program files (x86)\\\\rust\")\n-            .push_components([~\"lib\", ~\"thingy.dll\"])\n+            .push_many([~\"lib\", ~\"thingy.dll\"])\n             .with_filename(\"librustc.dll\")),\n           \"c:\\\\program files (x86)\\\\rust\\\\lib\\\\librustc.dll\");\n "}, {"sha": "8aa798d4576bc06c68491dcfe53be44deecd7fb6", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -4,13 +4,14 @@ import core::option;\n import option::{none, some};\n import rand;\n \n-fn mkdtemp(prefix: ~str, suffix: ~str) -> option<~str> {\n+fn mkdtemp(tmpdir: &Path, suffix: &str) -> option<Path> {\n     let r = rand::rng();\n     let mut i = 0u;\n     while (i < 1000u) {\n-        let s = prefix + r.gen_str(16u) + suffix;\n-        if os::make_dir(s, 0x1c0i32) {  // FIXME: u+rwx (#2349)\n-            return some(s);\n+        let p = tmpdir.push(r.gen_str(16u) +\n+                            str::from_slice(suffix));\n+        if os::make_dir(&p, 0x1c0i32) {  // FIXME: u+rwx (#2349)\n+            return some(p);\n         }\n         i += 1u;\n     }\n@@ -19,11 +20,11 @@ fn mkdtemp(prefix: ~str, suffix: ~str) -> option<~str> {\n \n #[test]\n fn test_mkdtemp() {\n-    let r = mkdtemp(~\"./\", ~\"foobar\");\n+    let r = mkdtemp(&Path(\".\"), \"foobar\");\n     match r {\n         some(p) => {\n-            os::remove_dir(p);\n-            assert(str::ends_with(p, ~\"foobar\"));\n+            os::remove_dir(&p);\n+            assert(str::ends_with(p.to_str(), \"foobar\"));\n         }\n         _ => assert(false)\n     }"}, {"sha": "bd22b8b56d28a9f74183e41ea9d1c3901b128791", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -141,7 +141,7 @@ fn run_tests_console(opts: test_opts,\n     }\n \n     let log_out = match opts.logfile {\n-        some(path) => match io::file_writer(path,\n+        some(path) => match io::file_writer(&Path(path),\n                                             ~[io::Create, io::Truncate]) {\n           result::ok(w) => some(w),\n           result::err(s) => {"}, {"sha": "881691b5f5cd65980a20e3310ca62763786345e2", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -59,7 +59,7 @@ fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     let args = get_mac_args(cx, sp, arg, 1u, option::some(1u), ~\"include\");\n     let file = expr_to_str(cx, args[0], ~\"#include_str requires a string\");\n     let p = parse::new_parser_from_file(cx.parse_sess(), cx.cfg(),\n-                                        res_rel_file(cx, sp, file),\n+                                        &res_rel_file(cx, sp, &Path(file)),\n                                         parse::parser::SOURCE_FILE);\n     return p.parse_expr();\n }\n@@ -70,7 +70,7 @@ fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n \n     let file = expr_to_str(cx, args[0], ~\"#include_str requires a string\");\n \n-    let res = io::read_whole_file_str(res_rel_file(cx, sp, file));\n+    let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path(file)));\n     match res {\n       result::ok(_) => { /* Continue. */ }\n       result::err(e) => {\n@@ -87,7 +87,7 @@ fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n \n     let file = expr_to_str(cx, args[0], ~\"#include_bin requires a string\");\n \n-    match io::read_whole_file(res_rel_file(cx, sp, file)) {\n+    match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n       result::ok(src) => {\n         let u8_exprs = vec::map(src, |char: u8| {\n             mk_u8(cx, sp, char)\n@@ -100,14 +100,13 @@ fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     }\n }\n \n-fn res_rel_file(cx: ext_ctxt, sp: codemap::span, +arg: Path) -> Path {\n+fn res_rel_file(cx: ext_ctxt, sp: codemap::span, arg: &Path) -> Path {\n     // NB: relative paths are resolved relative to the compilation unit\n-    if !path::path_is_absolute(arg) {\n-        let cu = codemap::span_to_filename(sp, cx.codemap());\n-        let dir = path::dirname(cu);\n-        return path::connect(dir, arg);\n+    if !arg.is_absolute {\n+        let cu = Path(codemap::span_to_filename(sp, cx.codemap()));\n+        cu.dir_path().push_many(arg.components)\n     } else {\n-        return arg;\n+        copy *arg\n     }\n }\n "}, {"sha": "b83c687b94bfe057c674138a5a565312b95f91dd", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -49,33 +49,33 @@ fn new_parse_sess_special_handler(sh: span_handler, cm: codemap::codemap)\n              mut chpos: 0u, mut byte_pos: 0u};\n }\n \n-fn parse_crate_from_file(input: ~str, cfg: ast::crate_cfg,\n+fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,\n                          sess: parse_sess) -> @ast::crate {\n-    if str::ends_with(input, ~\".rc\") {\n+    if input.filetype() == some(~\"rc\") {\n         parse_crate_from_crate_file(input, cfg, sess)\n-    } else if str::ends_with(input, ~\".rs\") {\n+    } else if input.filetype() == some(~\"rs\") {\n         parse_crate_from_source_file(input, cfg, sess)\n     } else {\n         sess.span_diagnostic.handler().fatal(~\"unknown input file type: \" +\n-                                             input)\n+                                             input.to_str())\n     }\n }\n \n-fn parse_crate_from_crate_file(input: ~str, cfg: ast::crate_cfg,\n+fn parse_crate_from_crate_file(input: &Path, cfg: ast::crate_cfg,\n                                sess: parse_sess) -> @ast::crate {\n     let (p, rdr) = new_parser_etc_from_file(sess, cfg, input,\n                                             parser::CRATE_FILE);\n     let lo = p.span.lo;\n-    let prefix = path::dirname(input);\n+    let prefix = input.dir_path();\n     let leading_attrs = p.parse_inner_attrs_and_next();\n     let { inner: crate_attrs, next: first_cdir_attr } = leading_attrs;\n     let cdirs = p.parse_crate_directives(token::EOF, first_cdir_attr);\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n     let cx = @{sess: sess, cfg: /* FIXME (#2543) */ copy p.cfg};\n-    let (companionmod, _) = path::splitext(path::basename(input));\n+    let companionmod = option::map(input.filestem(), |s| Path(s));\n     let (m, attrs) = eval::eval_crate_directives_to_mod(\n-        cx, cdirs, prefix, option::some(companionmod));\n+        cx, cdirs, &prefix, &companionmod);\n     let mut hi = p.span.hi;\n     p.expect(token::EOF);\n     return @ast_util::respan(ast_util::mk_sp(lo, hi),\n@@ -85,7 +85,7 @@ fn parse_crate_from_crate_file(input: ~str, cfg: ast::crate_cfg,\n                            config: /* FIXME (#2543) */ copy p.cfg});\n }\n \n-fn parse_crate_from_source_file(input: ~str, cfg: ast::crate_cfg,\n+fn parse_crate_from_source_file(input: &Path, cfg: ast::crate_cfg,\n                                 sess: parse_sess) -> @ast::crate {\n     let (p, rdr) = new_parser_etc_from_file(sess, cfg, input,\n                                             parser::SOURCE_FILE);\n@@ -183,22 +183,23 @@ fn new_parser_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n \n \n fn new_parser_etc_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n-                            +path: ~str, ftype: parser::file_type) ->\n+                            path: &Path, ftype: parser::file_type) ->\n    (parser, string_reader) {\n     let res = io::read_whole_file_str(path);\n     match res {\n       result::ok(_) => { /* Continue. */ }\n       result::err(e) => sess.span_diagnostic.handler().fatal(e)\n     }\n     let src = @result::unwrap(res);\n-    let filemap = codemap::new_filemap(path, src, sess.chpos, sess.byte_pos);\n+    let filemap = codemap::new_filemap(path.to_str(), src,\n+                                       sess.chpos, sess.byte_pos);\n     sess.cm.files.push(filemap);\n     let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n                                         sess.interner);\n     return (parser(sess, cfg, srdr as reader, ftype), srdr);\n }\n \n-fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, +path: ~str,\n+fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, path: &Path,\n                         ftype: parser::file_type) -> parser {\n     let (p, _) = new_parser_etc_from_file(sess, cfg, path, ftype);\n     return p;"}, {"sha": "54ec79de4c12b369a195c49bd042f148ec77ea43", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -9,7 +9,7 @@ type ctx =\n \n fn eval_crate_directives(cx: ctx,\n                          cdirs: ~[@ast::crate_directive],\n-                         prefix: ~str,\n+                         prefix: &Path,\n                          &view_items: ~[@ast::view_item],\n                          &items: ~[@ast::item]) {\n     for cdirs.each |sub_cdir| {\n@@ -18,11 +18,8 @@ fn eval_crate_directives(cx: ctx,\n }\n \n fn eval_crate_directives_to_mod(cx: ctx, cdirs: ~[@ast::crate_directive],\n-                                prefix: ~str, suffix: option<~str>)\n+                                prefix: &Path, suffix: &option<Path>)\n     -> (ast::_mod, ~[ast::attribute]) {\n-    debug!(\"eval crate prefix: %s\", prefix);\n-    debug!(\"eval crate suffix: %s\",\n-           option::get_default(suffix, ~\"none\"));\n     let (cview_items, citems, cattrs)\n         = parse_companion_mod(cx, prefix, suffix);\n     let mut view_items: ~[@ast::view_item] = ~[];\n@@ -43,17 +40,17 @@ companion mod is a .rs file with the same name as the directory.\n We build the path to the companion mod by combining the prefix and the\n optional suffix then adding the .rs extension.\n */\n-fn parse_companion_mod(cx: ctx, prefix: ~str, suffix: option<~str>)\n+fn parse_companion_mod(cx: ctx, prefix: &Path, suffix: &option<Path>)\n     -> (~[@ast::view_item], ~[@ast::item], ~[ast::attribute]) {\n \n-    fn companion_file(+prefix: ~str, suffix: option<~str>) -> ~str {\n-        return match suffix {\n-          option::some(s) => path::connect(prefix, s),\n-          option::none => prefix\n-        } + ~\".rs\";\n+    fn companion_file(prefix: &Path, suffix: &option<Path>) -> Path {\n+        return match *suffix {\n+          option::some(s) => prefix.push_many(s.components),\n+          option::none => copy *prefix\n+        }.with_filetype(\"rs\");\n     }\n \n-    fn file_exists(path: ~str) -> bool {\n+    fn file_exists(path: &Path) -> bool {\n         // Crude, but there's no lib function for this and I'm not\n         // up to writing it just now\n         match io::file_reader(path) {\n@@ -62,8 +59,7 @@ fn parse_companion_mod(cx: ctx, prefix: ~str, suffix: option<~str>)\n         }\n     }\n \n-    let modpath = companion_file(prefix, suffix);\n-    debug!(\"looking for companion mod %s\", modpath);\n+    let modpath = &companion_file(prefix, suffix);\n     if file_exists(modpath) {\n         debug!(\"found companion mod\");\n         let (p0, r0) = new_parser_etc_from_file(cx.sess, cx.cfg,\n@@ -85,19 +81,21 @@ fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n     }\n }\n \n-fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: ~str,\n+fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: &Path,\n                         &view_items: ~[@ast::view_item],\n                         &items: ~[@ast::item]) {\n     match cdir.node {\n       ast::cdir_src_mod(id, attrs) => {\n-        let file_path = cdir_path_opt((cx.sess.interner.get(id) + ~\".rs\"),\n-                                      attrs);\n-        let full_path =\n-            if path::path_is_absolute(file_path) {\n-                file_path\n-            } else { prefix + path::path_sep() + file_path };\n+        let file_path = Path(cdir_path_opt(\n+            cx.sess.interner.get(id) + ~\".rs\", attrs));\n+        let full_path = if file_path.is_absolute {\n+            copy file_path\n+        } else {\n+            prefix.push_many(file_path.components)\n+        };\n         let (p0, r0) =\n-            new_parser_etc_from_file(cx.sess, cx.cfg, full_path, SOURCE_FILE);\n+            new_parser_etc_from_file(cx.sess, cx.cfg,\n+                                     &full_path, SOURCE_FILE);\n         let inner_attrs = p0.parse_inner_attrs_and_next();\n         let mod_attrs = vec::append(attrs, inner_attrs.inner);\n         let first_item_outer_attrs = inner_attrs.next;\n@@ -112,13 +110,14 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: ~str,\n         vec::push(items, i);\n       }\n       ast::cdir_dir_mod(id, cdirs, attrs) => {\n-        let path = cdir_path_opt(*cx.sess.interner.get(id), attrs);\n-        let full_path =\n-            if path::path_is_absolute(path) {\n-                path\n-            } else { prefix + path::path_sep() + path };\n+        let path = Path(cdir_path_opt(*cx.sess.interner.get(id), attrs));\n+        let full_path = if path.is_absolute {\n+            copy path\n+        } else {\n+            prefix.push_many(path.components)\n+        };\n         let (m0, a0) = eval_crate_directives_to_mod(\n-            cx, cdirs, full_path, none);\n+            cx, cdirs, &full_path, &none);\n         let i =\n             @{ident: /* FIXME (#2543) */ copy id,\n               attrs: vec::append(attrs, a0),"}, {"sha": "7c227e012a9bbb0f9de2a0e0db7baae6e06ef7c8", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 51, "deletions": 78, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -57,18 +57,7 @@ mod write {\n         return false;\n     }\n \n-    // Decides what to call an intermediate file, given the name of the output\n-    // and the extension to use.\n-    fn mk_intermediate_name(output_path: ~str, extension: ~str) ->\n-        ~str unsafe {\n-        let stem = match str::find_char(output_path, '.') {\n-          some(dot_pos) => str::slice(output_path, 0u, dot_pos),\n-          none => output_path\n-        };\n-        return stem + ~\".\" + extension;\n-    }\n-\n-    fn run_passes(sess: session, llmod: ModuleRef, output: ~str) {\n+    fn run_passes(sess: session, llmod: ModuleRef, output: &Path) {\n         let opts = sess.opts;\n         if sess.time_llvm_passes() { llvm::LLVMRustEnableTimePasses(); }\n         let mut pm = mk_pass_manager();\n@@ -85,15 +74,15 @@ mod write {\n             match opts.output_type {\n               output_type_bitcode => {\n                 if opts.optimize != session::No {\n-                    let filename = mk_intermediate_name(output, ~\"no-opt.bc\");\n-                    str::as_c_str(filename, |buf| {\n+                    let filename = output.with_filetype(\"no-opt.bc\");\n+                    str::as_c_str(filename.to_str(), |buf| {\n                         llvm::LLVMWriteBitcodeToFile(llmod, buf)\n                     });\n                 }\n               }\n               _ => {\n-                let filename = mk_intermediate_name(output, ~\"bc\");\n-                str::as_c_str(filename, |buf| {\n+                let filename = output.with_filetype(\"bc\");\n+                str::as_c_str(filename.to_str(), |buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf)\n                 });\n               }\n@@ -163,9 +152,9 @@ mod write {\n             if opts.save_temps {\n                 // Always output the bitcode file with --save-temps\n \n-                let filename = mk_intermediate_name(output, ~\"opt.bc\");\n+                let filename = output.with_filetype(\"opt.bc\");\n                 llvm::LLVMRunPassManager(pm.llpm, llmod);\n-                str::as_c_str(filename, |buf| {\n+                str::as_c_str(filename.to_str(), |buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf)\n                 });\n                 pm = mk_pass_manager();\n@@ -175,7 +164,7 @@ mod write {\n                     let _: () = str::as_c_str(\n                         sess.targ_cfg.target_strs.target_triple,\n                         |buf_t| {\n-                            str::as_c_str(output, |buf_o| {\n+                            str::as_c_str(output.to_str(), |buf_o| {\n                                 WriteOutputFile(\n                                     sess,\n                                     pm.llpm,\n@@ -197,7 +186,7 @@ mod write {\n                     let _: () = str::as_c_str(\n                         sess.targ_cfg.target_strs.target_triple,\n                         |buf_t| {\n-                            str::as_c_str(output, |buf_o| {\n+                            str::as_c_str(output.to_str(), |buf_o| {\n                                 WriteOutputFile(\n                                     sess,\n                                     pm.llpm,\n@@ -217,7 +206,7 @@ mod write {\n                 let _: () = str::as_c_str(\n                     sess.targ_cfg.target_strs.target_triple,\n                     |buf_t| {\n-                        str::as_c_str(output, |buf_o| {\n+                        str::as_c_str(output.to_str(), |buf_o| {\n                             WriteOutputFile(\n                                 sess,\n                                 pm.llpm,\n@@ -239,13 +228,13 @@ mod write {\n \n         if opts.output_type == output_type_llvm_assembly {\n             // Given options \"-S --emit-llvm\": output LLVM assembly\n-            str::as_c_str(output, |buf_o| {\n+            str::as_c_str(output.to_str(), |buf_o| {\n                 llvm::LLVMRustAddPrintModulePass(pm.llpm, llmod, buf_o)});\n         } else {\n             // If only a bitcode file is asked for by using the '--emit-llvm'\n             // flag, then output it here\n             llvm::LLVMRunPassManager(pm.llpm, llmod);\n-            str::as_c_str(output,\n+            str::as_c_str(output.to_str(),\n                         |buf| llvm::LLVMWriteBitcodeToFile(llmod, buf) );\n         }\n \n@@ -306,7 +295,7 @@ mod write {\n  *\n  */\n \n-fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n+fn build_link_meta(sess: session, c: ast::crate, output: &Path,\n                    symbol_hasher: &hash::State) -> link_meta {\n \n     type provided_metas =\n@@ -384,21 +373,16 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n     }\n \n     fn crate_meta_name(sess: session, _crate: ast::crate,\n-                       output: ~str, metas: provided_metas) -> ~str {\n+                       output: &Path, metas: provided_metas) -> ~str {\n         return match metas.name {\n               some(v) => v,\n               none => {\n-                let name =\n-                    {\n-                        let mut os =\n-                            str::split_char(path::basename(output), '.');\n-                        if (vec::len(os) < 2u) {\n-                            sess.fatal(fmt!(\"output file name `%s` doesn't\\\n-                              appear to have an extension\", output));\n-                        }\n-                        vec::pop(os);\n-                        str::connect(os, ~\".\")\n-                    };\n+                let name = match output.filestem() {\n+                  none => sess.fatal(fmt!(\"output file name `%s` doesn't\\\n+                                           appear to have a stem\",\n+                                          output.to_str())),\n+                  some(s) => s\n+                };\n                 warn_missing(sess, ~\"name\", name);\n                 name\n               }\n@@ -552,31 +536,17 @@ fn mangle_internal_name_by_seq(ccx: @crate_ctxt, flav: ~str) -> ~str {\n // If the user wants an exe generated we need to invoke\n // cc to link the object file with some libs\n fn link_binary(sess: session,\n-               obj_filename: ~str,\n-               out_filename: ~str,\n+               obj_filename: &Path,\n+               out_filename: &Path,\n                lm: link_meta) {\n-    // Converts a library file name into a cc -l argument\n-    fn unlib(config: @session::config, filename: ~str) -> ~str unsafe {\n-        let rmlib = fn@(filename: ~str) -> ~str {\n-            let found = str::find_str(filename, ~\"lib\");\n-            if config.os == session::os_macos ||\n-                (config.os == session::os_linux ||\n-                 config.os == session::os_freebsd) &&\n-                option::is_some(found) && option::get(found) == 0u {\n-                return str::slice(filename, 3u, str::len(filename));\n-            } else { return filename; }\n-        };\n-        fn rmext(filename: ~str) -> ~str {\n-            let mut parts = str::split_char(filename, '.');\n-            vec::pop(parts);\n-            return str::connect(parts, ~\".\");\n+    // Converts a library file-stem into a cc -l argument\n+    fn unlib(config: @session::config, stem: ~str) -> ~str {\n+        if stem.starts_with(\"lib\") &&\n+            config.os != session::os_win32 {\n+            stem.slice(3, stem.len())\n+        } else {\n+            stem\n         }\n-        return match config.os {\n-              session::os_macos => rmext(rmlib(filename)),\n-              session::os_linux => rmext(rmlib(filename)),\n-              session::os_freebsd => rmext(rmlib(filename)),\n-              _ => rmext(filename)\n-            };\n     }\n \n     let output = if sess.building_library {\n@@ -585,17 +555,19 @@ fn link_binary(sess: session,\n                                   lm.name, lm.extras_hash, lm.vers));\n         debug!(\"link_meta.name:  %s\", lm.name);\n         debug!(\"long_libname: %s\", long_libname);\n-        debug!(\"out_filename: %s\", out_filename);\n-        debug!(\"dirname(out_filename): %s\", path::dirname(out_filename));\n+        debug!(\"out_filename: %s\", out_filename.to_str());\n+        debug!(\"dirname(out_filename): %s\", out_filename.dir_path().to_str());\n \n-        path::connect(path::dirname(out_filename), long_libname)\n-    } else { out_filename };\n+        out_filename.dir_path().push(long_libname)\n+    } else {\n+        *out_filename\n+    };\n \n-    log(debug, ~\"output: \" + output);\n+    log(debug, ~\"output: \" + output.to_str());\n \n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n-    let stage: ~str = ~\"-L\" + sess.filesearch.get_target_lib_path();\n+    let stage: ~str = ~\"-L\" + sess.filesearch.get_target_lib_path().to_str();\n \n     // In the future, FreeBSD will use clang as default compiler.\n     // It would be flexible to use cc (system's default C compiler)\n@@ -609,27 +581,28 @@ fn link_binary(sess: session,\n     let mut cc_args =\n         vec::append(~[stage], sess.targ_cfg.target_strs.cc_args);\n     vec::push(cc_args, ~\"-o\");\n-    vec::push(cc_args, output);\n-    vec::push(cc_args, obj_filename);\n+    vec::push(cc_args, output.to_str());\n+    vec::push(cc_args, obj_filename.to_str());\n \n     let mut lib_cmd;\n     let os = sess.targ_cfg.os;\n     if os == session::os_macos {\n         lib_cmd = ~\"-dynamiclib\";\n-    } else { lib_cmd = ~\"-shared\"; }\n+    } else {\n+        lib_cmd = ~\"-shared\";\n+    }\n \n     // # Crate linking\n \n     let cstore = sess.cstore;\n     for cstore::get_used_crate_files(cstore).each |cratepath| {\n-        if str::ends_with(cratepath, ~\".rlib\") {\n-            vec::push(cc_args, cratepath);\n+        if cratepath.filetype() == some(~\"rlib\") {\n+            vec::push(cc_args, cratepath.to_str());\n             again;\n         }\n-        let cratepath = cratepath;\n-        let dir = path::dirname(cratepath);\n+        let dir = cratepath.dirname();\n         if dir != ~\"\" { vec::push(cc_args, ~\"-L\" + dir); }\n-        let libarg = unlib(sess.targ_cfg, path::basename(cratepath));\n+        let libarg = unlib(sess.targ_cfg, option::get(cratepath.filestem()));\n         vec::push(cc_args, ~\"-l\" + libarg);\n     }\n \n@@ -645,7 +618,7 @@ fn link_binary(sess: session,\n     // forces to make sure that library can be found at runtime.\n \n     let addl_paths = sess.opts.addl_lib_search_paths;\n-    for addl_paths.each |path| { vec::push(cc_args, ~\"-L\" + path); }\n+    for addl_paths.each |path| { vec::push(cc_args, ~\"-L\" + path.to_str()); }\n \n     // The names of the extern libraries\n     let used_libs = cstore::get_used_libraries(cstore);\n@@ -658,7 +631,7 @@ fn link_binary(sess: session,\n         // be rpathed\n         if sess.targ_cfg.os == session::os_macos {\n             vec::push(cc_args, ~\"-Wl,-install_name,@rpath/\"\n-                      + path::basename(output));\n+                      + option::get(output.filename()));\n         }\n     }\n \n@@ -701,7 +674,7 @@ fn link_binary(sess: session,\n \n     // FIXME (#2397): At some point we want to rpath our guesses as to where\n     // extern libraries might live, based on the addl_lib_search_paths\n-    vec::push_all(cc_args, rpath::get_rpath_flags(sess, output));\n+    vec::push_all(cc_args, rpath::get_rpath_flags(sess, &output));\n \n     debug!(\"%s link args: %s\", cc_prog, str::connect(cc_args, ~\" \"));\n     // We run 'cc' here\n@@ -717,14 +690,14 @@ fn link_binary(sess: session,\n \n     // Clean up on Darwin\n     if sess.targ_cfg.os == session::os_macos {\n-        run::run_program(~\"dsymutil\", ~[output]);\n+        run::run_program(~\"dsymutil\", ~[output.to_str()]);\n     }\n \n     // Remove the temporary object file if we aren't saving temps\n     if !sess.opts.save_temps {\n         if ! os::remove_file(obj_filename) {\n             sess.warn(fmt!(\"failed to delete object file `%s`\",\n-                           obj_filename));\n+                           obj_filename.to_str()));\n         }\n     }\n }"}, {"sha": "0d02821a24c6311289e8b2ffdded5efb4cdbe28e", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 119, "deletions": 136, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -13,7 +13,7 @@ pure fn not_win32(os: session::os) -> bool {\n   }\n }\n \n-fn get_rpath_flags(sess: session::session, out_filename: ~str) -> ~[~str] {\n+fn get_rpath_flags(sess: session::session, out_filename: &Path) -> ~[~str] {\n     let os = sess.targ_cfg.os;\n \n     // No rpath on windows\n@@ -23,7 +23,6 @@ fn get_rpath_flags(sess: session::session, out_filename: ~str) -> ~[~str] {\n \n     debug!(\"preparing the RPATH!\");\n \n-    let cwd = os::getcwd();\n     let sysroot = sess.filesearch.sysroot();\n     let output = out_filename;\n     let libs = cstore::get_used_crate_files(sess.cstore);\n@@ -32,50 +31,48 @@ fn get_rpath_flags(sess: session::session, out_filename: ~str) -> ~[~str] {\n     let libs = vec::append_one(libs, get_sysroot_absolute_rt_lib(sess));\n \n     let target_triple = sess.opts.target_triple;\n-    let rpaths = get_rpaths(os, cwd, sysroot, output, libs, target_triple);\n+    let rpaths = get_rpaths(os, &sysroot, output, libs, target_triple);\n     rpaths_to_flags(rpaths)\n }\n \n-fn get_sysroot_absolute_rt_lib(sess: session::session) -> path::Path {\n-    let mut path = vec::append(~[sess.filesearch.sysroot()],\n-                           filesearch::relative_target_lib_path(\n-                               sess.opts.target_triple));\n-    vec::push(path, os::dll_filename(~\"rustrt\"));\n-    path::connect_many(path)\n+fn get_sysroot_absolute_rt_lib(sess: session::session) -> Path {\n+    let r = filesearch::relative_target_lib_path(sess.opts.target_triple);\n+    sess.filesearch.sysroot().push_rel(&r).push(os::dll_filename(\"rustrt\"))\n }\n \n-fn rpaths_to_flags(rpaths: ~[~str]) -> ~[~str] {\n-    vec::map(rpaths, |rpath| fmt!(\"-Wl,-rpath,%s\",rpath) )\n+fn rpaths_to_flags(rpaths: &[Path]) -> ~[~str] {\n+    vec::map(rpaths, |rpath| fmt!(\"-Wl,-rpath,%s\",rpath.to_str()))\n }\n \n-fn get_rpaths(os: session::os, cwd: path::Path, sysroot: path::Path,\n-              output: path::Path, libs: ~[path::Path],\n-              target_triple: ~str) -> ~[~str] {\n-    debug!(\"cwd: %s\", cwd);\n-    debug!(\"sysroot: %s\", sysroot);\n-    debug!(\"output: %s\", output);\n+fn get_rpaths(os: session::os,\n+              sysroot: &Path,\n+              output: &Path,\n+              libs: &[Path],\n+              target_triple: &str) -> ~[Path] {\n+    debug!(\"sysroot: %s\", sysroot.to_str());\n+    debug!(\"output: %s\", output.to_str());\n     debug!(\"libs:\");\n     for libs.each |libpath| {\n-        debug!(\"    %s\", libpath);\n+        debug!(\"    %s\", libpath.to_str());\n     }\n     debug!(\"target_triple: %s\", target_triple);\n \n     // Use relative paths to the libraries. Binaries can be moved\n     // as long as they maintain the relative relationship to the\n     // crates they depend on.\n-    let rel_rpaths = get_rpaths_relative_to_output(os, cwd, output, libs);\n+    let rel_rpaths = get_rpaths_relative_to_output(os, output, libs);\n \n     // Make backup absolute paths to the libraries. Binaries can\n     // be moved as long as the crates they link against don't move.\n-    let abs_rpaths = get_absolute_rpaths(cwd, libs);\n+    let abs_rpaths = get_absolute_rpaths(libs);\n \n     // And a final backup rpath to the global library location.\n-    let fallback_rpaths = ~[get_install_prefix_rpath(cwd, target_triple)];\n+    let fallback_rpaths = ~[get_install_prefix_rpath(target_triple)];\n \n-    fn log_rpaths(desc: ~str, rpaths: ~[~str]) {\n+    fn log_rpaths(desc: &str, rpaths: &[Path]) {\n         debug!(\"%s rpaths:\", desc);\n         for rpaths.each |rpath| {\n-            debug!(\"    %s\", rpath);\n+            debug!(\"    %s\", rpath.to_str());\n         }\n     }\n \n@@ -93,43 +90,37 @@ fn get_rpaths(os: session::os, cwd: path::Path, sysroot: path::Path,\n }\n \n fn get_rpaths_relative_to_output(os: session::os,\n-                                 cwd: path::Path,\n-                                 output: path::Path,\n-                                 libs: ~[path::Path]) -> ~[~str] {\n+                                 output: &Path,\n+                                 libs: &[Path]) -> ~[Path] {\n     vec::map(libs, |a| {\n-        get_rpath_relative_to_output(os, cwd, output, a)\n+        get_rpath_relative_to_output(os, output, &a)\n     })\n }\n \n fn get_rpath_relative_to_output(os: session::os,\n-                                cwd: path::Path,\n-                                output: path::Path,\n-                                &&lib: path::Path) -> ~str {\n+                                output: &Path,\n+                                lib: &Path) -> Path {\n     assert not_win32(os);\n \n     // Mac doesn't appear to support $ORIGIN\n     let prefix = match os {\n-        session::os_linux => ~\"$ORIGIN\" + path::path_sep(),\n-        session::os_freebsd => ~\"$ORIGIN\" + path::path_sep(),\n-        session::os_macos => ~\"@executable_path\" + path::path_sep(),\n+        session::os_linux | session::os_freebsd => \"$ORIGIN\",\n+        session::os_macos => \"@executable_path\",\n         session::os_win32 => core::unreachable()\n     };\n \n-    prefix + get_relative_to(\n-        get_absolute(cwd, output),\n-        get_absolute(cwd, lib))\n+    Path(prefix).push_rel(&get_relative_to(&os::make_absolute(output),\n+                                           &os::make_absolute(lib)))\n }\n \n // Find the relative path from one file to another\n-fn get_relative_to(abs1: path::Path, abs2: path::Path) -> path::Path {\n-    assert path::path_is_absolute(abs1);\n-    assert path::path_is_absolute(abs2);\n+fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n+    assert abs1.is_absolute;\n+    assert abs2.is_absolute;\n     debug!(\"finding relative path from %s to %s\",\n-           abs1, abs2);\n-    let normal1 = path::normalize(abs1);\n-    let normal2 = path::normalize(abs2);\n-    let split1 = path::split(normal1);\n-    let split2 = path::split(normal2);\n+           abs1.to_str(), abs2.to_str());\n+    let split1 = abs1.components;\n+    let split2 = abs2.components;\n     let len1 = vec::len(split1);\n     let len2 = vec::len(split2);\n     assert len1 > 0u;\n@@ -148,48 +139,39 @@ fn get_relative_to(abs1: path::Path, abs2: path::Path) -> path::Path {\n     vec::push_all(path, vec::view(split2, start_idx, len2 - 1u));\n \n     if vec::is_not_empty(path) {\n-        return path::connect_many(path);\n+        return Path(\"\").push_many(path);\n     } else {\n-        return ~\".\";\n+        return Path(\".\");\n     }\n }\n \n-fn get_absolute_rpaths(cwd: path::Path, libs: ~[path::Path]) -> ~[~str] {\n-    vec::map(libs, |a| get_absolute_rpath(cwd, a) )\n+fn get_absolute_rpaths(libs: &[Path]) -> ~[Path] {\n+    vec::map(libs, |a| get_absolute_rpath(&a) )\n }\n \n-fn get_absolute_rpath(cwd: path::Path, &&lib: path::Path) -> ~str {\n-    path::dirname(get_absolute(cwd, lib))\n+fn get_absolute_rpath(lib: &Path) -> Path {\n+    os::make_absolute(lib).dir_path()\n }\n \n-fn get_absolute(cwd: path::Path, lib: path::Path) -> path::Path {\n-    if path::path_is_absolute(lib) {\n-        lib\n-    } else {\n-        path::connect(cwd, lib)\n-    }\n-}\n-\n-fn get_install_prefix_rpath(cwd: path::Path, target_triple: ~str) -> ~str {\n+fn get_install_prefix_rpath(target_triple: &str) -> Path {\n     let install_prefix = env!(\"CFG_PREFIX\");\n \n     if install_prefix == ~\"\" {\n         fail ~\"rustc compiled without CFG_PREFIX environment variable\";\n     }\n \n-    let path = vec::append(\n-        ~[install_prefix],\n-        filesearch::relative_target_lib_path(target_triple));\n-    get_absolute(cwd, path::connect_many(path))\n+    let tlib = filesearch::relative_target_lib_path(target_triple);\n+    os::make_absolute(&Path(install_prefix).push_rel(&tlib))\n }\n \n-fn minimize_rpaths(rpaths: ~[~str]) -> ~[~str] {\n+fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n     let set = map::str_hash::<()>();\n     let mut minimized = ~[];\n     for rpaths.each |rpath| {\n-        if !set.contains_key(rpath) {\n+        let s = rpath.to_str();\n+        if !set.contains_key(s) {\n             vec::push(minimized, rpath);\n-            set.insert(rpath, ());\n+            set.insert(s, ());\n         }\n     }\n     return minimized;\n@@ -199,149 +181,150 @@ fn minimize_rpaths(rpaths: ~[~str]) -> ~[~str] {\n mod test {\n     #[test]\n     fn test_rpaths_to_flags() {\n-        let flags = rpaths_to_flags(~[~\"path1\", ~\"path2\"]);\n+        let flags = rpaths_to_flags(~[Path(\"path1\"),\n+                                      Path(\"path2\")]);\n         assert flags == ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"];\n     }\n \n-    #[test]\n-    fn test_get_absolute1() {\n-        let cwd = ~\"/dir\";\n-        let lib = ~\"some/path/lib\";\n-        let res = get_absolute(cwd, lib);\n-        assert res == ~\"/dir/some/path/lib\";\n-    }\n-\n-    #[test]\n-    fn test_get_absolute2() {\n-        let cwd = ~\"/dir\";\n-        let lib = ~\"/some/path/lib\";\n-        let res = get_absolute(cwd, lib);\n-        assert res == ~\"/some/path/lib\";\n-    }\n-\n     #[test]\n     fn test_prefix_rpath() {\n-        let res = get_install_prefix_rpath(~\"/usr/lib\", ~\"triple\");\n-        let d = path::connect(env!(\"CFG_PREFIX\"), ~\"/lib/rustc/triple/lib\");\n-        assert str::ends_with(res, d);\n+        let res = get_install_prefix_rpath(\"triple\");\n+        let d = Path(env!(\"CFG_PREFIX\"))\n+            .push_rel(&Path(\"lib/rustc/triple/lib\"));\n+        debug!(\"test_prefix_path: %s vs. %s\",\n+               res.to_str(),\n+               d.to_str());\n+        assert str::ends_with(res.to_str(), d.to_str());\n     }\n \n     #[test]\n     fn test_prefix_rpath_abs() {\n-        let res = get_install_prefix_rpath(~\"/usr/lib\", ~\"triple\");\n-        assert path::path_is_absolute(res);\n+        let res = get_install_prefix_rpath(\"triple\");\n+        assert res.is_absolute;\n     }\n \n     #[test]\n     fn test_minimize1() {\n-        let res = minimize_rpaths(~[~\"rpath1\", ~\"rpath2\", ~\"rpath1\"]);\n-        assert res == ~[~\"rpath1\", ~\"rpath2\"];\n+        let res = minimize_rpaths([Path(\"rpath1\"),\n+                                   Path(\"rpath2\"),\n+                                   Path(\"rpath1\")]);\n+        assert res == ~[Path(\"rpath1\"), Path(\"rpath2\")];\n     }\n \n     #[test]\n     fn test_minimize2() {\n-        let res = minimize_rpaths(~[~\"1a\", ~\"2\", ~\"2\", ~\"1a\", ~\"4a\",\n-                                   ~\"1a\", ~\"2\", ~\"3\", ~\"4a\", ~\"3\"]);\n-        assert res == ~[~\"1a\", ~\"2\", ~\"4a\", ~\"3\"];\n+        let res = minimize_rpaths(~[Path(\"1a\"), Path(\"2\"), Path(\"2\"),\n+                                    Path(\"1a\"), Path(\"4a\"),Path(\"1a\"),\n+                                    Path(\"2\"), Path(\"3\"), Path(\"4a\"),\n+                                    Path(\"3\")]);\n+        assert res == ~[Path(\"1a\"), Path(\"2\"), Path(\"4a\"), Path(\"3\")];\n     }\n \n     #[test]\n     fn test_relative_to1() {\n-        let p1 = ~\"/usr/bin/rustc\";\n-        let p2 = ~\"/usr/lib/mylib\";\n-        let res = get_relative_to(p1, p2);\n-        assert res == ~\"../lib\";\n+        let p1 = Path(\"/usr/bin/rustc\");\n+        let p2 = Path(\"/usr/lib/mylib\");\n+        let res = get_relative_to(&p1, &p2);\n+        assert res == Path(\"../lib\");\n     }\n \n     #[test]\n     fn test_relative_to2() {\n-        let p1 = ~\"/usr/bin/rustc\";\n-        let p2 = ~\"/usr/bin/../lib/mylib\";\n-        let res = get_relative_to(p1, p2);\n-        assert res == ~\"../lib\";\n+        let p1 = Path(\"/usr/bin/rustc\");\n+        let p2 = Path(\"/usr/bin/../lib/mylib\");\n+        let res = get_relative_to(&p1, &p2);\n+        assert res == Path(\"../lib\");\n     }\n \n     #[test]\n     fn test_relative_to3() {\n-        let p1 = ~\"/usr/bin/whatever/rustc\";\n-        let p2 = ~\"/usr/lib/whatever/mylib\";\n-        let res = get_relative_to(p1, p2);\n-        assert res == ~\"../../lib/whatever\";\n+        let p1 = Path(\"/usr/bin/whatever/rustc\");\n+        let p2 = Path(\"/usr/lib/whatever/mylib\");\n+        let res = get_relative_to(&p1, &p2);\n+        assert res == Path(\"../../lib/whatever\");\n     }\n \n     #[test]\n     fn test_relative_to4() {\n-        let p1 = ~\"/usr/bin/whatever/../rustc\";\n-        let p2 = ~\"/usr/lib/whatever/mylib\";\n-        let res = get_relative_to(p1, p2);\n-        assert res == ~\"../lib/whatever\";\n+        let p1 = Path(\"/usr/bin/whatever/../rustc\");\n+        let p2 = Path(\"/usr/lib/whatever/mylib\");\n+        let res = get_relative_to(&p1, &p2);\n+        assert res == Path(\"../lib/whatever\");\n     }\n \n     #[test]\n     fn test_relative_to5() {\n-        let p1 = ~\"/usr/bin/whatever/../rustc\";\n-        let p2 = ~\"/usr/lib/whatever/../mylib\";\n-        let res = get_relative_to(p1, p2);\n-        assert res == ~\"../lib\";\n+        let p1 = Path(\"/usr/bin/whatever/../rustc\");\n+        let p2 = Path(\"/usr/lib/whatever/../mylib\");\n+        let res = get_relative_to(&p1, &p2);\n+        assert res == Path(\"../lib\");\n     }\n \n     #[test]\n     fn test_relative_to6() {\n-        let p1 = ~\"/1\";\n-        let p2 = ~\"/2/3\";\n-        let res = get_relative_to(p1, p2);\n-        assert res == ~\"2\";\n+        let p1 = Path(\"/1\");\n+        let p2 = Path(\"/2/3\");\n+        let res = get_relative_to(&p1, &p2);\n+        assert res == Path(\"2\");\n     }\n \n     #[test]\n     fn test_relative_to7() {\n-        let p1 = ~\"/1/2\";\n-        let p2 = ~\"/3\";\n-        let res = get_relative_to(p1, p2);\n-        assert res == ~\"..\";\n+        let p1 = Path(\"/1/2\");\n+        let p2 = Path(\"/3\");\n+        let res = get_relative_to(&p1, &p2);\n+        assert res == Path(\"..\");\n     }\n \n     #[test]\n     fn test_relative_to8() {\n-        let p1 = ~\"/home/brian/Dev/rust/build/\"\n-            + ~\"stage2/lib/rustc/i686-unknown-linux-gnu/lib/librustc.so\";\n-        let p2 = ~\"/home/brian/Dev/rust/build/stage2/bin/..\"\n-            + ~\"/lib/rustc/i686-unknown-linux-gnu/lib/libstd.so\";\n-        let res = get_relative_to(p1, p2);\n-        assert res == ~\".\";\n+        let p1 = Path(\"/home/brian/Dev/rust/build/\").push_rel(\n+            &Path(\"stage2/lib/rustc/i686-unknown-linux-gnu/lib/librustc.so\"));\n+        let p2 = Path(\"/home/brian/Dev/rust/build/stage2/bin/..\").push_rel(\n+            &Path(\"lib/rustc/i686-unknown-linux-gnu/lib/libstd.so\"));\n+        let res = get_relative_to(&p1, &p2);\n+        debug!(\"test_relative_tu8: %s vs. %s\",\n+               res.to_str(),\n+               Path(\".\").to_str());\n+        assert res == Path(\".\");\n     }\n \n     #[test]\n     #[cfg(target_os = \"linux\")]\n     fn test_rpath_relative() {\n       let o = session::os_linux;\n       let res = get_rpath_relative_to_output(o,\n-            ~\"/usr\", ~\"bin/rustc\", ~\"lib/libstd.so\");\n-      assert res == ~\"$ORIGIN/../lib\";\n+            &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n+      assert res == Path(\"$ORIGIN/../lib\");\n     }\n \n     #[test]\n     #[cfg(target_os = \"freebsd\")]\n     fn test_rpath_relative() {\n         let o = session::os_freebsd;\n         let res = get_rpath_relative_to_output(o,\n-            ~\"/usr\", ~\"bin/rustc\", ~\"lib/libstd.so\");\n-        assert res == ~\"$ORIGIN/../lib\";\n+            &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n+        assert res == Path(\"$ORIGIN/../lib\");\n     }\n \n     #[test]\n     #[cfg(target_os = \"macos\")]\n     fn test_rpath_relative() {\n         // this is why refinements would be nice\n         let o = session::os_macos;\n-        let res = get_rpath_relative_to_output(o, ~\"/usr\", ~\"bin/rustc\",\n-                                               ~\"lib/libstd.so\");\n-        assert res == ~\"@executable_path/../lib\";\n+        let res = get_rpath_relative_to_output(o,\n+                                               &Path(\"bin/rustc\"),\n+                                               &Path(\"lib/libstd.so\"));\n+        assert res == Path(\"@executable_path/../lib\");\n     }\n \n     #[test]\n     fn test_get_absolute_rpath() {\n-        let res = get_absolute_rpath(~\"/usr\", ~\"lib/libstd.so\");\n-        assert res == ~\"/usr/lib\";\n+        let res = get_absolute_rpath(&Path(\"lib/libstd.so\"));\n+        debug!(\"test_get_absolute_rpath: %s vs. %s\",\n+               res.to_str(),\n+               os::make_absolute(&Path(\"lib\")).to_str());\n+\n+        assert res == os::make_absolute(&Path(\"lib\"));\n     }\n }"}, {"sha": "c1a371af4dd478019f4657b8ad8c852b01742b37", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -27,7 +27,7 @@ fn anon_src() -> ~str { ~\"<anon>\" }\n \n fn source_name(input: input) -> ~str {\n     match input {\n-      file_input(ifile) => ifile,\n+      file_input(ifile) => ifile.to_str(),\n       str_input(_) => anon_src()\n     }\n }\n@@ -92,7 +92,7 @@ fn parse_cfgspecs(cfgspecs: ~[~str]) -> ast::crate_cfg {\n \n enum input {\n     /// Load source from file\n-    file_input(~str),\n+    file_input(Path),\n     /// The string is the source\n     str_input(~str)\n }\n@@ -101,7 +101,7 @@ fn parse_input(sess: session, cfg: ast::crate_cfg, input: input)\n     -> @ast::crate {\n     match input {\n       file_input(file) => {\n-        parse::parse_crate_from_file(file, cfg, sess.parse_sess)\n+        parse::parse_crate_from_file(&file, cfg, sess.parse_sess)\n       }\n       str_input(src) => {\n         // FIXME (#2319): Don't really want to box the source string\n@@ -236,11 +236,13 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n                 vtable_map: vtable_map};\n \n     let (llmod, link_meta) = time(time_passes, ~\"translation\", ||\n-        trans::base::trans_crate(sess, crate, ty_cx, outputs.obj_filename,\n+        trans::base::trans_crate(sess, crate, ty_cx,\n+                                 &outputs.obj_filename,\n                                  exp_map, exp_map2, maps));\n \n     time(time_passes, ~\"LLVM passes\", ||\n-        link::write::run_passes(sess, llmod, outputs.obj_filename));\n+        link::write::run_passes(sess, llmod,\n+                                &outputs.obj_filename));\n \n     let stop_after_codegen =\n         sess.opts.output_type != link::output_type_exe ||\n@@ -249,14 +251,15 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     if stop_after_codegen { return {crate: crate, tcx: some(ty_cx)}; }\n \n     time(time_passes, ~\"linking\", ||\n-         link::link_binary(sess, outputs.obj_filename,\n-                           outputs.out_filename, link_meta));\n+         link::link_binary(sess,\n+                           &outputs.obj_filename,\n+                           &outputs.out_filename, link_meta));\n \n     return {crate: crate, tcx: some(ty_cx)};\n }\n \n fn compile_input(sess: session, cfg: ast::crate_cfg, input: input,\n-                 outdir: option<~str>, output: option<~str>) {\n+                 outdir: &option<Path>, output: &option<Path>) {\n \n     let upto = if sess.opts.parse_only { cu_parse }\n                else if sess.opts.no_trans { cu_no_trans }\n@@ -483,6 +486,7 @@ fn build_session_options(matches: getopts::matches,\n     let extra_debuginfo = opt_present(matches, ~\"xg\");\n     let debuginfo = opt_present(matches, ~\"g\") || extra_debuginfo;\n     let sysroot_opt = getopts::opt_maybe_str(matches, ~\"sysroot\");\n+    let sysroot_opt = option::map(sysroot_opt, |m| Path(m));\n     let target_opt = getopts::opt_maybe_str(matches, ~\"target\");\n     let save_temps = getopts::opt_present(matches, ~\"save-temps\");\n     match output_type {\n@@ -514,7 +518,9 @@ fn build_session_options(matches: getopts::matches,\n             some(s) => s\n         };\n \n-    let addl_lib_search_paths = getopts::opt_strs(matches, ~\"L\");\n+    let addl_lib_search_paths =\n+        getopts::opt_strs(matches, ~\"L\")\n+        .map(|s| Path(s));\n     let cfg = parse_cfgspecs(getopts::opt_strs(matches, ~\"cfg\"));\n     let test = opt_present(matches, ~\"test\");\n     let sopts: @session::options =\n@@ -614,11 +620,11 @@ fn opts() -> ~[getopts::opt] {\n           optflag(~\"static\"), optflag(~\"gc\")];\n }\n \n-type output_filenames = @{out_filename: ~str, obj_filename:~str};\n+type output_filenames = @{out_filename:Path, obj_filename:Path};\n \n fn build_output_filenames(input: input,\n-                          odir: option<~str>,\n-                          ofile: option<~str>,\n+                          odir: &option<Path>,\n+                          ofile: &option<Path>,\n                           sess: session)\n         -> output_filenames {\n     let obj_path;\n@@ -639,37 +645,30 @@ fn build_output_filenames(input: input,\n           link::output_type_object | link::output_type_exe => ~\"o\"\n         };\n \n-    match ofile {\n+    match *ofile {\n       none => {\n         // \"-\" as input file will cause the parser to read from stdin so we\n         // have to make up a name\n         // We want to toss everything after the final '.'\n-        let dirname = match odir {\n+        let dirpath = match *odir {\n           some(d) => d,\n           none => match input {\n             str_input(_) => os::getcwd(),\n-            file_input(ifile) => path::dirname(ifile)\n+            file_input(ifile) => ifile.dir_path()\n           }\n         };\n \n-        let base_filename = match input {\n-          file_input(ifile) => {\n-            let (path, _) = path::splitext(ifile);\n-            path::basename(path)\n-          }\n+        let stem = match input {\n+          file_input(ifile) => option::get(ifile.filestem()),\n           str_input(_) => ~\"rust_out\"\n         };\n-        let base_path = path::connect(dirname, base_filename);\n-\n \n         if sess.building_library {\n-            let basename = path::basename(base_path);\n-            let dylibname = os::dll_filename(basename);\n-            out_path = path::connect(dirname, dylibname);\n-            obj_path = path::connect(dirname, basename + ~\".\" + obj_suffix);\n+            out_path = dirpath.push(os::dll_filename(stem));\n+            obj_path = dirpath.push(stem).with_filetype(obj_suffix);\n         } else {\n-            out_path = base_path;\n-            obj_path = base_path + ~\".\" + obj_suffix;\n+            out_path = dirpath.push(stem);\n+            obj_path = dirpath.push(stem).with_filetype(obj_suffix);\n         }\n       }\n \n@@ -678,9 +677,7 @@ fn build_output_filenames(input: input,\n         obj_path = if stop_after_codegen {\n             out_file\n         } else {\n-            let (base, _) = path::splitext(out_file);\n-            let modified = base + ~\".\" + obj_suffix;\n-            modified\n+            out_file.with_filetype(obj_suffix)\n         };\n \n         if sess.building_library {\n@@ -690,21 +687,21 @@ fn build_output_filenames(input: input,\n             // lib<basename>-<hash>-<version>.so no matter what.\n         }\n \n-        if odir != none {\n+        if *odir != none {\n             sess.warn(~\"ignoring --out-dir flag due to -o flag.\");\n         }\n       }\n     }\n     return @{out_filename: out_path,\n-          obj_filename: obj_path};\n+             obj_filename: obj_path};\n }\n \n fn early_error(emitter: diagnostic::emitter, msg: ~str) -> ! {\n     emitter(none, msg, diagnostic::fatal);\n     fail;\n }\n \n-fn list_metadata(sess: session, path: ~str, out: io::Writer) {\n+fn list_metadata(sess: session, path: &Path, out: io::Writer) {\n     metadata::loader::list_file_metadata(\n         sess.parse_sess.interner,\n         session::sess_os_to_meta_os(sess.targ_cfg.os), path, out);"}, {"sha": "e26465fce5d376e0f5b4ad12f879e0536d478dec", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -159,7 +159,7 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n             let src = str::from_bytes(io::stdin().read_whole_stream());\n             str_input(src)\n         } else {\n-            file_input(ifile)\n+            file_input(Path(ifile))\n         }\n       }\n       _ => early_error(demitter, ~\"multiple input filenames provided\")\n@@ -168,7 +168,9 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n     let sopts = build_session_options(matches, demitter);\n     let sess = build_session(sopts, demitter);\n     let odir = getopts::opt_maybe_str(matches, ~\"out-dir\");\n+    let odir = option::map(odir, |o| Path(o));\n     let ofile = getopts::opt_maybe_str(matches, ~\"o\");\n+    let ofile = option::map(ofile, |o| Path(o));\n     let cfg = build_configuration(sess, binary, input);\n     let pretty =\n         option::map(getopts::opt_default(matches, ~\"pretty\",\n@@ -185,7 +187,7 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n     if ls {\n         match input {\n           file_input(ifile) => {\n-            list_metadata(sess, ifile, io::stdout());\n+            list_metadata(sess, &ifile, io::stdout());\n           }\n           str_input(_) => {\n             early_error(demitter, ~\"can not list metadata for stdin\");\n@@ -194,7 +196,7 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n         return;\n     }\n \n-    compile_input(sess, cfg, input, odir, ofile);\n+    compile_input(sess, cfg, input, &odir, &ofile);\n }\n \n /*"}, {"sha": "10c0f283525bff24530d43ec53239f1e90204deb", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -89,8 +89,8 @@ type options =\n      lint_opts: ~[(lint::lint, lint::level)],\n      save_temps: bool,\n      output_type: back::link::output_type,\n-     addl_lib_search_paths: ~[~str],\n-     maybe_sysroot: option<~str>,\n+     addl_lib_search_paths: ~[Path],\n+     maybe_sysroot: option<Path>,\n      target_triple: ~str,\n      cfg: ast::crate_cfg,\n      test: bool,\n@@ -111,7 +111,7 @@ type session_ = {targ_cfg: @config,\n                  span_diagnostic: diagnostic::span_handler,\n                  filesearch: filesearch::filesearch,\n                  mut building_library: bool,\n-                 working_dir: ~str,\n+                 working_dir: Path,\n                  lint_settings: lint::lint_settings};\n \n enum session {"}, {"sha": "685717e8e8d8342d8bc64d97de461fa0164187fc", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -199,7 +199,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n         };\n         let cinfo = loader::load_library_crate(load_ctxt);\n \n-        let cfilename = cinfo.ident;\n+        let cfilename = Path(cinfo.ident);\n         let cdata = cinfo.data;\n \n         let attrs = decoder::get_crate_attributes(cdata);\n@@ -225,7 +225,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n \n         let cstore = e.cstore;\n         cstore::set_crate_data(cstore, cnum, cmeta);\n-        cstore::add_used_crate_file(cstore, cfilename);\n+        cstore::add_used_crate_file(cstore, &cfilename);\n         return cnum;\n       }\n       some(cnum) => {"}, {"sha": "d2cab8c31775eb9f0830b5ba391226b6ebdd21c7", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -56,7 +56,7 @@ type cstore_private =\n     @{metas: map::hashmap<ast::crate_num, crate_metadata>,\n       use_crate_map: use_crate_map,\n       mod_path_map: mod_path_map,\n-      mut used_crate_files: ~[~str],\n+      mut used_crate_files: ~[Path],\n       mut used_libraries: ~[~str],\n       mut used_link_args: ~[~str],\n       intr: ident_interner};\n@@ -114,13 +114,13 @@ fn iter_crate_data(cstore: cstore, i: fn(ast::crate_num, crate_metadata)) {\n     for p(cstore).metas.each |k,v| { i(k, v);};\n }\n \n-fn add_used_crate_file(cstore: cstore, lib: ~str) {\n-    if !vec::contains(p(cstore).used_crate_files, lib) {\n-        vec::push(p(cstore).used_crate_files, lib);\n+fn add_used_crate_file(cstore: cstore, lib: &Path) {\n+    if !vec::contains(p(cstore).used_crate_files, copy *lib) {\n+        vec::push(p(cstore).used_crate_files, copy *lib);\n     }\n }\n \n-fn get_used_crate_files(cstore: cstore) -> ~[~str] {\n+fn get_used_crate_files(cstore: cstore) -> ~[Path] {\n     return p(cstore).used_crate_files;\n }\n "}, {"sha": "de0c31b9c3dce703c03d5e440b84ff7cd2193900", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 40, "deletions": 43, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -14,24 +14,22 @@ export get_cargo_root;\n export get_cargo_root_nearest;\n export libdir;\n \n-import path::Path;\n+type pick<T> = fn(path: &Path) -> option<T>;\n \n-type pick<T> = fn(path: Path) -> option<T>;\n-\n-fn pick_file(file: Path, path: Path) -> option<Path> {\n-    if path::basename(path) == file { option::some(path) }\n+fn pick_file(file: Path, path: &Path) -> option<Path> {\n+    if path.file_path() == file { option::some(copy *path) }\n     else { option::none }\n }\n \n trait filesearch {\n     fn sysroot() -> Path;\n     fn lib_search_paths() -> ~[Path];\n     fn get_target_lib_path() -> Path;\n-    fn get_target_lib_file_path(file: Path) -> Path;\n+    fn get_target_lib_file_path(file: &Path) -> Path;\n }\n \n fn mk_filesearch(maybe_sysroot: option<Path>,\n-                 target_triple: ~str,\n+                 target_triple: &str,\n                  addl_lib_search_paths: ~[Path]) -> filesearch {\n     type filesearch_impl = {sysroot: Path,\n                             addl_lib_search_paths: ~[Path],\n@@ -42,7 +40,8 @@ fn mk_filesearch(maybe_sysroot: option<Path>,\n             let mut paths = self.addl_lib_search_paths;\n \n             vec::push(paths,\n-                      make_target_lib_path(self.sysroot, self.target_triple));\n+                      make_target_lib_path(&self.sysroot,\n+                                           self.target_triple));\n             match get_cargo_lib_path_nearest() {\n               result::ok(p) => vec::push(paths, p),\n               result::err(p) => ()\n@@ -54,55 +53,54 @@ fn mk_filesearch(maybe_sysroot: option<Path>,\n             paths\n         }\n         fn get_target_lib_path() -> Path {\n-            make_target_lib_path(self.sysroot, self.target_triple)\n+            make_target_lib_path(&self.sysroot, self.target_triple)\n         }\n-        fn get_target_lib_file_path(file: Path) -> Path {\n-            path::connect(self.get_target_lib_path(), file)\n+        fn get_target_lib_file_path(file: &Path) -> Path {\n+            self.get_target_lib_path().push_rel(file)\n         }\n     }\n \n     let sysroot = get_sysroot(maybe_sysroot);\n-    debug!(\"using sysroot = %s\", sysroot);\n+    debug!(\"using sysroot = %s\", sysroot.to_str());\n     {sysroot: sysroot,\n      addl_lib_search_paths: addl_lib_search_paths,\n-     target_triple: target_triple} as filesearch\n+     target_triple: str::from_slice(target_triple)} as filesearch\n }\n \n fn search<T: copy>(filesearch: filesearch, pick: pick<T>) -> option<T> {\n     let mut rslt = none;\n     for filesearch.lib_search_paths().each |lib_search_path| {\n-        debug!(\"searching %s\", lib_search_path);\n-        for os::list_dir_path(lib_search_path).each |path| {\n-            debug!(\"testing %s\", path);\n+        debug!(\"searching %s\", lib_search_path.to_str());\n+        for os::list_dir_path(&lib_search_path).each |path| {\n+            debug!(\"testing %s\", path.to_str());\n             let maybe_picked = pick(path);\n             if option::is_some(maybe_picked) {\n-                debug!(\"picked %s\", path);\n+                debug!(\"picked %s\", path.to_str());\n                 rslt = maybe_picked;\n                 break;\n             } else {\n-                debug!(\"rejected %s\", path);\n+                debug!(\"rejected %s\", path.to_str());\n             }\n         }\n         if option::is_some(rslt) { break; }\n     }\n     return rslt;\n }\n \n-fn relative_target_lib_path(target_triple: ~str) -> ~[Path] {\n-    ~[libdir(), ~\"rustc\", target_triple, libdir()]\n+fn relative_target_lib_path(target_triple: &str) -> Path {\n+    Path(libdir()).push_many([~\"rustc\",\n+                              str::from_slice(target_triple),\n+                              libdir()])\n }\n \n-fn make_target_lib_path(sysroot: Path,\n-                        target_triple: ~str) -> Path {\n-    let path = vec::append(~[sysroot],\n-                           relative_target_lib_path(target_triple));\n-    let path = path::connect_many(path);\n-    return path;\n+fn make_target_lib_path(sysroot: &Path,\n+                        target_triple: &str) -> Path {\n+    sysroot.push_rel(&relative_target_lib_path(target_triple))\n }\n \n fn get_default_sysroot() -> Path {\n     match os::self_exe_path() {\n-      option::some(p) => path::normalize(path::connect(p, ~\"..\")),\n+      option::some(p) => p.pop(),\n       option::none => fail ~\"can't determine value for sysroot\"\n     }\n }\n@@ -115,15 +113,14 @@ fn get_sysroot(maybe_sysroot: option<Path>) -> Path {\n }\n \n fn get_cargo_sysroot() -> result<Path, ~str> {\n-    let path = ~[get_default_sysroot(), libdir(), ~\"cargo\"];\n-    result::ok(path::connect_many(path))\n+    result::ok(get_default_sysroot().push_many([libdir(), ~\"cargo\"]))\n }\n \n fn get_cargo_root() -> result<Path, ~str> {\n     match os::getenv(~\"CARGO_ROOT\") {\n-        some(_p) => result::ok(_p),\n+        some(_p) => result::ok(Path(_p)),\n         none => match os::homedir() {\n-          some(_q) => result::ok(path::connect(_q, ~\".cargo\")),\n+          some(_q) => result::ok(_q.push(\".cargo\")),\n           none => result::err(~\"no CARGO_ROOT or home directory\")\n         }\n     }\n@@ -132,21 +129,21 @@ fn get_cargo_root() -> result<Path, ~str> {\n fn get_cargo_root_nearest() -> result<Path, ~str> {\n     do result::chain(get_cargo_root()) |p| {\n         let cwd = os::getcwd();\n-        let mut dirname = path::dirname(cwd);\n-        let mut dirpath = path::split(dirname);\n-        let cwd_cargo = path::connect(cwd, ~\".cargo\");\n-        let mut par_cargo = path::connect(dirname, ~\".cargo\");\n+        let cwd_cargo = cwd.push(\".cargo\");\n+        let mut par_cargo = cwd.pop().push(\".cargo\");\n         let mut rslt = result::ok(cwd_cargo);\n \n-        if !os::path_is_dir(cwd_cargo) && cwd_cargo != p {\n-            while vec::is_not_empty(dirpath) && par_cargo != p {\n-                if os::path_is_dir(par_cargo) {\n+        if !os::path_is_dir(&cwd_cargo) && cwd_cargo != p {\n+            while par_cargo != p {\n+                if os::path_is_dir(&par_cargo) {\n                     rslt = result::ok(par_cargo);\n                     break;\n                 }\n-                vec::pop(dirpath);\n-                dirname = path::dirname(dirname);\n-                par_cargo = path::connect(dirname, ~\".cargo\");\n+                if par_cargo.components.len() == 1 {\n+                    // We just checked /.cargo, stop now.\n+                    break;\n+                }\n+                par_cargo = par_cargo.pop().pop().push(\".cargo\");\n             }\n         }\n         rslt\n@@ -155,13 +152,13 @@ fn get_cargo_root_nearest() -> result<Path, ~str> {\n \n fn get_cargo_lib_path() -> result<Path, ~str> {\n     do result::chain(get_cargo_root()) |p| {\n-        result::ok(path::connect(p, libdir()))\n+        result::ok(p.push(libdir()))\n     }\n }\n \n fn get_cargo_lib_path_nearest() -> result<Path, ~str> {\n     do result::chain(get_cargo_root_nearest()) |p| {\n-        result::ok(path::connect(p, libdir()))\n+        result::ok(p.push(libdir()))\n     }\n }\n "}, {"sha": "513b4dd4216fc7bd32a17b98b31a899fdbe20ed4", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -74,27 +74,28 @@ fn find_library_crate_aux(cx: ctxt,\n \n     let mut matches = ~[];\n     filesearch::search(filesearch, |path| {\n-        debug!(\"inspecting file %s\", path);\n-        let f: ~str = path::basename(path);\n+        debug!(\"inspecting file %s\", path.to_str());\n+        let f: ~str = option::get(path.filename());\n         if !(str::starts_with(f, prefix) && str::ends_with(f, suffix)) {\n-            debug!(\"skipping %s, doesn't look like %s*%s\", path, prefix,\n-                   suffix);\n+            debug!(\"skipping %s, doesn't look like %s*%s\", path.to_str(),\n+                   prefix, suffix);\n             option::none::<()>\n         } else {\n-            debug!(\"%s is a candidate\", path);\n+            debug!(\"%s is a candidate\", path.to_str());\n             match get_metadata_section(cx.os, path) {\n               option::some(cvec) => {\n                 if !crate_matches(cvec, cx.metas, cx.hash) {\n-                    debug!(\"skipping %s, metadata doesn't match\", path);\n+                    debug!(\"skipping %s, metadata doesn't match\",\n+                           path.to_str());\n                     option::none::<()>\n                 } else {\n-                    debug!(\"found %s with matching metadata\", path);\n-                    vec::push(matches, {ident: path, data: cvec});\n+                    debug!(\"found %s with matching metadata\", path.to_str());\n+                    vec::push(matches, {ident: path.to_str(), data: cvec});\n                     option::none::<()>\n                 }\n               }\n               _ => {\n-                debug!(\"could not load metadata for %s\", path);\n+                debug!(\"could not load metadata for %s\", path.to_str());\n                 option::none::<()>\n               }\n             }\n@@ -168,10 +169,10 @@ fn metadata_matches(extern_metas: ~[@ast::meta_item],\n }\n \n fn get_metadata_section(os: os,\n-                        filename: ~str) -> option<@~[u8]> unsafe {\n-    let mb = str::as_c_str(filename, |buf| {\n+                        filename: &Path) -> option<@~[u8]> unsafe {\n+    let mb = str::as_c_str(filename.to_str(), |buf| {\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-                                   });\n+    });\n     if mb as int == 0 { return option::none::<@~[u8]>; }\n     let of = match mk_object_file(mb) {\n         option::some(of) => of,\n@@ -204,12 +205,13 @@ fn meta_section_name(os: os) -> ~str {\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-fn list_file_metadata(intr: ident_interner, os: os, path: ~str,\n-                      out: io::Writer) {\n+fn list_file_metadata(intr: ident_interner,\n+                      os: os, path: &Path, out: io::Writer) {\n     match get_metadata_section(os, path) {\n       option::some(bytes) => decoder::list_crate_metadata(intr, bytes, out),\n       option::none => {\n-        out.write_str(~\"could not find metadata in \" + path + ~\".\\n\");\n+        out.write_str(~\"could not find metadata in \"\n+                      + path.to_str() + ~\".\\n\");\n       }\n     }\n }"}, {"sha": "fe0d49a3532420ff23e3cdc358d5d03a797368db", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -5778,7 +5778,7 @@ fn write_abi_version(ccx: @crate_ctxt) {\n fn trans_crate(sess: session::session,\n                crate: @ast::crate,\n                tcx: ty::ctxt,\n-               output: ~str,\n+               output: &Path,\n                emap: resolve3::ExportMap,\n                emap2: resolve3::ExportMap2,\n                maps: astencode::maps)"}, {"sha": "42b8274d78c708f3302c6f340ff7ca6bfdb6599f", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -172,7 +172,7 @@ fn create_compile_unit(cx: @crate_ctxt)\n       option::none => ()\n     }\n \n-    let (_, work_dir) = get_file_path_and_dir(cx.sess.working_dir,\n+    let (_, work_dir) = get_file_path_and_dir(cx.sess.working_dir.to_str(),\n                                               crate_name);\n     let unit_metadata = ~[lltag(tg),\n                          llunused(),\n@@ -197,13 +197,13 @@ fn get_cache(cx: @crate_ctxt) -> metadata_cache {\n     option::get(cx.dbg_cx).llmetadata\n }\n \n-fn get_file_path_and_dir(work_dir: ~str, full_path: ~str) -> (~str, ~str) {\n+fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n     (if str::starts_with(full_path, work_dir) {\n         str::slice(full_path, str::len(work_dir) + 1u,\n                    str::len(full_path))\n     } else {\n-        full_path\n-    }, work_dir)\n+        str::from_slice(full_path)\n+    }, str::from_slice(work_dir))\n }\n \n fn create_file(cx: @crate_ctxt, full_path: ~str) -> @metadata<file_md> {\n@@ -215,8 +215,9 @@ fn create_file(cx: @crate_ctxt, full_path: ~str) -> @metadata<file_md> {\n         option::none => ()\n     }\n \n-    let (file_path, work_dir) = get_file_path_and_dir(cx.sess.working_dir,\n-                                                      full_path);\n+    let (file_path, work_dir) =\n+        get_file_path_and_dir(cx.sess.working_dir.to_str(),\n+                              full_path);\n     let unit_node = create_compile_unit(cx).node;\n     let file_md = ~[lltag(tg),\n                    llstr(file_path),"}, {"sha": "9d95251705227087e77864d28de3d9dffd5ab3fe", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -210,6 +210,9 @@ fn vstore_ty_to_str(cx: ctxt, ty: ~str, vs: ty::vstore) -> ~str {\n       ty::vstore_fixed(_) => {\n         fmt!(\"%s/%s\", ty, vstore_to_str(cx, vs))\n       }\n+      ty::vstore_slice(_) => {\n+        fmt!(\"%s/%s\", vstore_to_str(cx, vs), ty)\n+      }\n       _ => fmt!(\"%s%s\", vstore_to_str(cx, vs), ty)\n     }\n }"}, {"sha": "91f910f5280c1d4b62e298f704abbe915d2d797b", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -51,7 +51,7 @@ fn from_str<T>(source: ~str, owner: srv_owner<T>) -> T {\n }\n \n fn from_file<T>(file: ~str, owner: srv_owner<T>) -> T {\n-    run(owner, file, parse::from_file_sess)\n+    run(owner, file, |sess, f| parse::from_file_sess(sess, &Path(f)))\n }\n \n fn run<T>(owner: srv_owner<T>, source: ~str, +parse: parser) -> T {"}, {"sha": "9bb3d4730d4cfa9ab4afbd5531c068e7b5b04e92", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -28,8 +28,8 @@ enum output_style {\n \n /// The configuration for a rustdoc session\n type config = {\n-    input_crate: ~str,\n-    output_dir: ~str,\n+    input_crate: Path,\n+    output_dir: Path,\n     output_format: output_format,\n     output_style: output_style,\n     pandoc_cmd: option<~str>\n@@ -67,10 +67,10 @@ fn usage() {\n     println(~\"\");\n }\n \n-fn default_config(input_crate: ~str) -> config {\n+fn default_config(input_crate: &Path) -> config {\n     {\n-        input_crate: input_crate,\n-        output_dir: ~\".\",\n+        input_crate: *input_crate,\n+        output_dir: Path(\".\"),\n         output_format: pandoc_html,\n         output_style: doc_per_mod,\n         pandoc_cmd: none\n@@ -103,8 +103,8 @@ fn parse_config_(\n     match getopts::getopts(args, opts) {\n         result::ok(matches) => {\n             if vec::len(matches.free) == 1u {\n-                let input_crate = vec::head(matches.free);\n-                config_from_opts(input_crate, matches, program_output)\n+                let input_crate = Path(vec::head(matches.free));\n+                config_from_opts(&input_crate, matches, program_output)\n             } else if vec::is_empty(matches.free) {\n                 result::err(~\"no crates specified\")\n             } else {\n@@ -118,7 +118,7 @@ fn parse_config_(\n }\n \n fn config_from_opts(\n-    input_crate: ~str,\n+    input_crate: &Path,\n     matches: getopts::matches,\n     program_output: program_output\n ) -> result<config, ~str> {\n@@ -127,6 +127,7 @@ fn config_from_opts(\n     let result = result::ok(config);\n     let result = do result::chain(result) |config| {\n         let output_dir = getopts::opt_maybe_str(matches, opt_output_dir());\n+        let output_dir = option::map(output_dir, |s| Path(s));\n         result::ok({\n             output_dir: option::get_default(output_dir, config.output_dir)\n             with config\n@@ -205,7 +206,7 @@ fn maybe_find_pandoc(\n       none => {\n         ~[~\"pandoc\"] + match os::homedir() {\n           some(dir) => {\n-            ~[path::connect(dir, ~\".cabal/bin/pandoc\")]\n+            ~[dir.push_rel(&Path(\".cabal/bin/pandoc\")).to_str()]\n           }\n           none => ~[]\n         }\n@@ -229,7 +230,7 @@ fn maybe_find_pandoc(\n fn should_find_pandoc() {\n     let config = {\n         output_format: pandoc_html\n-        with default_config(~\"test\")\n+        with default_config(&Path(\"test\"))\n     };\n     let mock_program_output = fn~(_prog: &str, _args: &[~str]) -> {\n         status: int, out: ~str, err: ~str\n@@ -246,7 +247,7 @@ fn should_find_pandoc() {\n fn should_error_with_no_pandoc() {\n     let config = {\n         output_format: pandoc_html\n-        with default_config(~\"test\")\n+        with default_config(&Path(\"test\"))\n     };\n     let mock_program_output = fn~(_prog: &str, _args: &[~str]) -> {\n         status: int, out: ~str, err: ~str\n@@ -282,15 +283,15 @@ fn should_error_with_multiple_crates() {\n #[test]\n fn should_set_output_dir_to_cwd_if_not_provided() {\n     let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert result::get(config).output_dir == ~\".\";\n+    assert result::get(config).output_dir == Path(\".\");\n }\n \n #[test]\n fn should_set_output_dir_if_provided() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-dir\", ~\"snuggles\"\n     ]);\n-    assert result::get(config).output_dir == ~\"snuggles\";\n+    assert result::get(config).output_dir == Path(\"snuggles\");\n }\n \n #[test]"}, {"sha": "47b1cee019c0d95ab8c0a277976e8ecdcc982863", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -81,7 +81,7 @@ fn item_to_entry(\n     let link = match doc {\n       doc::modtag(_) | doc::nmodtag(_)\n       if config.output_style == config::doc_per_mod => {\n-        markdown_writer::make_filename(config, doc::itempage(doc))\n+        markdown_writer::make_filename(config, doc::itempage(doc)).to_str()\n       }\n       _ => {\n         ~\"#\" + pandoc_header_id(markdown_pass::header_text(doc))\n@@ -230,7 +230,7 @@ mod test {\n         do astsrv::from_str(source) |srv| {\n             let config = {\n                 output_style: output_style\n-                with config::default_config(~\"whatever\")\n+                with config::default_config(&Path(\"whatever\"))\n             };\n             let doc = extract::from_srv(srv, ~\"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);"}, {"sha": "da05b935cefae05b1b2b237b2d322cd316c381a9", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -785,7 +785,7 @@ mod test {\n \n             let config = {\n                 output_style: config::doc_per_crate\n-                with config::default_config(~\"whatever\")\n+                with config::default_config(&Path(\"whatever\"))\n             };\n \n             let doc = extract::from_srv(srv, ~\"\");"}, {"sha": "a62f275acc8262a29ff2bdd3dcc071db3120410f", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -66,7 +66,7 @@ fn markdown_writer(\n ) -> writer {\n     let filename = make_local_filename(config, page);\n     do generic_writer |markdown| {\n-        write_file(filename, markdown);\n+        write_file(&filename, markdown);\n     }\n }\n \n@@ -84,7 +84,7 @@ fn pandoc_writer(\n         ~\"--from=markdown\",\n         ~\"--to=html\",\n         ~\"--css=rust.css\",\n-        ~\"--output=\" + filename\n+        ~\"--output=\" + filename.to_str()\n     ];\n \n     do generic_writer |markdown| {\n@@ -166,15 +166,15 @@ fn generic_writer(+process: fn~(markdown: ~str)) -> writer {\n fn make_local_filename(\n     config: config::config,\n     page: doc::page\n-) -> ~str {\n+) -> Path {\n     let filename = make_filename(config, page);\n-    path::connect(config.output_dir, filename)\n+    config.output_dir.push_rel(&filename)\n }\n \n fn make_filename(\n     config: config::config,\n     page: doc::page\n-) -> ~str {\n+) -> Path {\n     let filename = {\n         match page {\n           doc::cratepage(doc) => {\n@@ -196,50 +196,50 @@ fn make_filename(\n       config::pandoc_html => ~\"html\"\n     };\n \n-    filename + ~\".\" + ext\n+    Path(filename).with_filetype(ext)\n }\n \n #[test]\n fn should_use_markdown_file_name_based_off_crate() {\n     let config = {\n-        output_dir: ~\"output/dir\",\n+        output_dir: Path(\"output/dir\"),\n         output_format: config::markdown,\n         output_style: config::doc_per_crate\n-        with config::default_config(~\"input/test.rc\")\n+        with config::default_config(&Path(\"input/test.rc\"))\n     };\n     let doc = test::mk_doc(~\"test\", ~\"\");\n     let page = doc::cratepage(doc.cratedoc());\n     let filename = make_local_filename(config, page);\n-    assert filename == ~\"output/dir/test.md\";\n+    assert filename.to_str() == ~\"output/dir/test.md\";\n }\n \n #[test]\n fn should_name_html_crate_file_name_index_html_when_doc_per_mod() {\n     let config = {\n-        output_dir: ~\"output/dir\",\n+        output_dir: Path(\"output/dir\"),\n         output_format: config::pandoc_html,\n         output_style: config::doc_per_mod\n-        with config::default_config(~\"input/test.rc\")\n+        with config::default_config(&Path(\"input/test.rc\"))\n     };\n     let doc = test::mk_doc(~\"\", ~\"\");\n     let page = doc::cratepage(doc.cratedoc());\n     let filename = make_local_filename(config, page);\n-    assert filename == ~\"output/dir/index.html\";\n+    assert filename.to_str() == ~\"output/dir/index.html\";\n }\n \n #[test]\n fn should_name_mod_file_names_by_path() {\n     let config = {\n-        output_dir: ~\"output/dir\",\n+        output_dir: Path(\"output/dir\"),\n         output_format: config::pandoc_html,\n         output_style: config::doc_per_mod\n-        with config::default_config(~\"input/test.rc\")\n+        with config::default_config(&Path(\"input/test.rc\"))\n     };\n     let doc = test::mk_doc(~\"\", ~\"mod a { mod b { } }\");\n     let modb = doc.cratemod().mods()[0].mods()[0];\n     let page = doc::itempage(doc::modtag(modb));\n     let filename = make_local_filename(config, page);\n-    assert  filename == ~\"output/dir/a_b.html\";\n+    assert  filename == Path(\"output/dir/a_b.html\");\n }\n \n #[cfg(test)]\n@@ -253,7 +253,7 @@ mod test {\n     }\n }\n \n-fn write_file(path: ~str, s: ~str) {\n+fn write_file(path: &Path, s: ~str) {\n     import io::WriterUtil;\n \n     match io::file_writer(path, ~[io::Create, io::Truncate]) {"}, {"sha": "e74700b7b6719a1e2f89492265da12cca7b1764c", "filename": "src/rustdoc/parse.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fparse.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -10,7 +10,7 @@ import syntax::parse;\n \n export from_file, from_str, from_file_sess, from_str_sess;\n \n-fn from_file(file: ~str) -> @ast::crate {\n+fn from_file(file: &Path) -> @ast::crate {\n     parse::parse_crate_from_file(\n         file, ~[], parse::new_parse_sess(none))\n }\n@@ -20,9 +20,9 @@ fn from_str(source: ~str) -> @ast::crate {\n         ~\"-\", @source, ~[], parse::new_parse_sess(none))\n }\n \n-fn from_file_sess(sess: session::session, file: ~str) -> @ast::crate {\n+fn from_file_sess(sess: session::session, file: &Path) -> @ast::crate {\n     parse::parse_crate_from_file(\n-        file, cfg(sess, file_input(file)), sess.parse_sess)\n+        file, cfg(sess, file_input(*file)), sess.parse_sess)\n }\n \n fn from_str_sess(sess: session::session, source: ~str) -> @ast::crate {"}, {"sha": "ec7556afa0ac99c9fe88777c49c5d6a1e0321a87", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -130,13 +130,13 @@ fn time<T>(what: ~str, f: fn() -> T) -> T {\n fn run(config: config::config) {\n \n     let source_file = config.input_crate;\n-    do astsrv::from_file(source_file) |srv| {\n+    do astsrv::from_file(source_file.to_str()) |srv| {\n         do time(~\"wait_ast\") {\n             do astsrv::exec(srv) |_ctxt| { }\n         };\n         let doc = time(~\"extract\", || {\n             let default_name = source_file;\n-            extract::from_srv(srv, default_name)\n+            extract::from_srv(srv, default_name.to_str())\n         });\n         run_passes(srv, doc, ~[\n             tystr_pass::mk_pass(),"}, {"sha": "21525424b1bcd2f16137acb770afac8ec997f57e", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -52,13 +52,11 @@ fn shift_push() {\n }\n \n fn read_line() {\n-    let path = path::connect(\n-        env!(\"CFG_SRC_DIR\"),\n-        ~\"src/test/bench/shootout-k-nucleotide.data\"\n-    );\n+    let path = Path(env!(\"CFG_SRC_DIR\"))\n+        .push_rel(&Path(\"src/test/bench/shootout-k-nucleotide.data\"));\n \n     for int::range(0, 3) |_i| {\n-        let reader = result::get(io::file_reader(path));\n+        let reader = result::get(io::file_reader(&path));\n         while !reader.eof() {\n             reader.read_line();\n         }"}, {"sha": "b9dc89c43c5e6f3aa75a92786efb5fe9d146cd52", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -85,7 +85,8 @@ fn main(args: ~[~str]) {\n     };\n \n     let writer = if os::getenv(~\"RUST_BENCH\").is_some() {\n-        result::get(io::file_writer(~\"./shootout-fasta.data\", ~[io::Truncate, io::Create]))\n+        result::get(io::file_writer(&Path(\"./shootout-fasta.data\"),\n+                                    ~[io::Truncate, io::Create]))\n     } else {\n         io::stdout()\n     };"}, {"sha": "4204a3110de8339814715e6fc51d70741c52a8ce", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -128,11 +128,9 @@ fn main(args: ~[~str]) {\n    let rdr = if os::getenv(~\"RUST_BENCH\").is_some() {\n        // FIXME: Using this compile-time env variable is a crummy way to\n        // get to this massive data set, but #include_bin chokes on it (#2598)\n-       let path = path::connect(\n-           env!(\"CFG_SRC_DIR\"),\n-           ~\"src/test/bench/shootout-k-nucleotide.data\"\n-           );\n-       result::get(io::file_reader(path))\n+       let path = Path(env!(\"CFG_SRC_DIR\"))\n+           .push_rel(&Path(\"src/test/bench/shootout-k-nucleotide.data\"));\n+       result::get(io::file_reader(&path))\n    } else {\n       io::stdin()\n    };"}, {"sha": "54ff0cde9ef961be0fbe879c2aecddeefe5546df", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -126,11 +126,9 @@ fn main(args: ~[~str]) {\n    let rdr = if os::getenv(~\"RUST_BENCH\").is_some() {\n        // FIXME: Using this compile-time env variable is a crummy way to\n        // get to this massive data set, but #include_bin chokes on it (#2598)\n-       let path = path::connect(\n-           env!(\"CFG_SRC_DIR\"),\n-           ~\"src/test/bench/shootout-k-nucleotide.data\"\n-           );\n-       result::get(io::file_reader(path))\n+       let path = Path(env!(\"CFG_SRC_DIR\"))\n+           .push_rel(&Path(\"src/test/bench/shootout-k-nucleotide.data\"));\n+       result::get(io::file_reader(&path))\n    } else {\n       io::stdin()\n    };"}, {"sha": "1d1c2e2ac299cd6349408f4e8e10f3f2e93f7f68", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -112,7 +112,7 @@ fn writer(path: ~str, writech: comm::Chan<comm::Chan<line>>, size: uint)\n         }\n         _ => {\n             result::get(\n-                io::file_writer(path,\n+                io::file_writer(&Path(path),\n                 ~[io::Create, io::Truncate]))\n         }\n     };"}, {"sha": "3ab3a08c8a48a12fbd154a07f9e3c4dbf5063e32", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284b8b1dc348ab8b9c82350dd1b4e53fac1225c/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=c284b8b1dc348ab8b9c82350dd1b4e53fac1225c", "patch": "@@ -80,7 +80,7 @@ impl io::Reader: word_reader {\n }\n \n fn file_word_reader(filename: ~str) -> word_reader {\n-    match io::file_reader(filename) {\n+    match io::file_reader(&Path(filename)) {\n       result::ok(f) => { f as word_reader }\n       result::err(e) => { fail fmt!(\"%?\", e) }\n     }"}]}