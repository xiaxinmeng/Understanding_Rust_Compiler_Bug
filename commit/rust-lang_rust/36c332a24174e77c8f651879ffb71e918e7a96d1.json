{"sha": "36c332a24174e77c8f651879ffb71e918e7a96d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2YzMzMmEyNDE3NGU3N2M4ZjY1MTg3OWZmYjcxZTkxOGU3YTk2ZDE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-04-17T12:24:45Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-04-18T13:28:47Z"}, "message": "introduce local_ctxt in trans.rs to keep crate_ctxt global\n\nThis reduces crate_ctxt copying (which unfortunately did not\nresult in a noticeable speedup), and makes the role of that\ntype a bit more clear.", "tree": {"sha": "c25a7ddfa38a65daf2066fe74de05a1cc16e4fa9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c25a7ddfa38a65daf2066fe74de05a1cc16e4fa9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36c332a24174e77c8f651879ffb71e918e7a96d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36c332a24174e77c8f651879ffb71e918e7a96d1", "html_url": "https://github.com/rust-lang/rust/commit/36c332a24174e77c8f651879ffb71e918e7a96d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36c332a24174e77c8f651879ffb71e918e7a96d1/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9976bb93d6c2ab46979c2bc13480266069fd8b3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9976bb93d6c2ab46979c2bc13480266069fd8b3e", "html_url": "https://github.com/rust-lang/rust/commit/9976bb93d6c2ab46979c2bc13480266069fd8b3e"}], "stats": {"total": 651, "additions": 333, "deletions": 318}, "files": [{"sha": "c3945dccadbe7458fc51235204f6bcc7192d9457", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 333, "deletions": 318, "changes": 651, "blob_url": "https://github.com/rust-lang/rust/blob/36c332a24174e77c8f651879ffb71e918e7a96d1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c332a24174e77c8f651879ffb71e918e7a96d1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=36c332a24174e77c8f651879ffb71e918e7a96d1", "patch": "@@ -108,13 +108,17 @@ state type crate_ctxt = rec(session.session sess,\n                             hashmap[ast.def_id, ValueRef] consts,\n                             hashmap[ast.def_id,()] obj_methods,\n                             hashmap[@ty.t, @tydesc_info] tydescs,\n-                            vec[ast.ty_param] obj_typarams,\n-                            vec[ast.obj_field] obj_fields,\n                             @glue_fns glues,\n                             namegen names,\n                             vec[str] path,\n                             std.sha1.sha1 sha);\n \n+type local_ctxt = rec(vec[str] path,\n+                      vec[ast.ty_param] obj_typarams,\n+                      vec[ast.obj_field] obj_fields,\n+                      @crate_ctxt ccx);\n+                \n+\n type self_vt = rec(ValueRef v, @ty.t t);\n \n state type fn_ctxt = rec(ValueRef llfn,\n@@ -129,7 +133,7 @@ state type fn_ctxt = rec(ValueRef llfn,\n                          hashmap[ast.def_id, ValueRef] lllocals,\n                          hashmap[ast.def_id, ValueRef] llupvars,\n                          mutable vec[ValueRef] lltydescs,\n-                         @crate_ctxt ccx);\n+                         @local_ctxt lcx);\n \n tag cleanup {\n     clean(fn(@block_ctxt cx) -> result);\n@@ -165,7 +169,7 @@ fn sep() -> str {\n     ret \"_\";\n }\n \n-fn extend_path(@crate_ctxt cx, str name) -> @crate_ctxt {\n+fn extend_path(@local_ctxt cx, str name) -> @local_ctxt {\n   ret @rec(path = cx.path + vec(name) with *cx);\n }\n \n@@ -174,18 +178,18 @@ fn path_name(vec[str] path) -> str {\n }\n \n \n-fn mangle_name_by_type(@crate_ctxt cx, @ty.t t) -> str {\n-    cx.sha.reset();\n+fn mangle_name_by_type(@local_ctxt cx, @ty.t t) -> str {\n+    cx.ccx.sha.reset();\n     auto f = metadata.def_to_str;\n-    cx.sha.input_str(metadata.ty_str(t, f));\n+    cx.ccx.sha.input_str(metadata.ty_str(t, f));\n     ret sep() + \"rust\" + sep()\n-        + _str.substr(cx.sha.result_str(), 0u, 16u) + sep()\n+        + _str.substr(cx.ccx.sha.result_str(), 0u, 16u) + sep()\n         + path_name(cx.path);\n }\n \n-fn mangle_name_by_seq(@crate_ctxt cx, str flav) -> str {\n+fn mangle_name_by_seq(@local_ctxt cx, str flav) -> str {\n     ret sep() + \"rust\" + sep()\n-        + cx.names.next(flav) + sep()\n+        + cx.ccx.names.next(flav) + sep()\n         + path_name(cx.path);\n }\n \n@@ -534,8 +538,7 @@ fn type_of(@crate_ctxt cx, @ty.t t) -> TypeRef {\n     ret type_of_inner(cx, t);\n }\n \n-fn type_of_explicit_args(@crate_ctxt cx,\n-                     vec[ty.arg] inputs) -> vec[TypeRef] {\n+fn type_of_explicit_args(@crate_ctxt cx, vec[ty.arg] inputs) -> vec[TypeRef] {\n     let vec[TypeRef] atys = vec();\n     for (ty.arg arg in inputs) {\n         if (ty.type_has_dynamic_size(arg.ty)) {\n@@ -753,11 +756,11 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n     ret llty;\n }\n \n-fn type_of_arg(@crate_ctxt cx, &ty.arg arg) -> TypeRef {\n+fn type_of_arg(@local_ctxt cx, &ty.arg arg) -> TypeRef {\n     alt (arg.ty.struct) {\n         case (ty.ty_param(_)) {\n             if (arg.mode == ast.alias) {\n-                ret T_typaram_ptr(cx.tn);\n+                ret T_typaram_ptr(cx.ccx.tn);\n             }\n         }\n         case (_) {\n@@ -767,25 +770,25 @@ fn type_of_arg(@crate_ctxt cx, &ty.arg arg) -> TypeRef {\n \n     auto typ;\n     if (arg.mode == ast.alias) {\n-        typ = T_ptr(type_of_inner(cx, arg.ty));\n+        typ = T_ptr(type_of_inner(cx.ccx, arg.ty));\n     } else {\n-        typ = type_of_inner(cx, arg.ty);\n+        typ = type_of_inner(cx.ccx, arg.ty);\n     }\n     ret typ;\n }\n \n-fn type_of_ty_param_count_and_ty(@crate_ctxt ccx,\n+fn type_of_ty_param_count_and_ty(@local_ctxt lcx,\n                                  ty.ty_param_count_and_ty tpt) -> TypeRef {\n     alt (tpt._1.struct) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n-            auto llfnty = type_of_fn(ccx, proto, inputs, output, tpt._0);\n-            ret T_fn_pair(ccx.tn, llfnty);\n+            auto llfnty = type_of_fn(lcx.ccx, proto, inputs, output, tpt._0);\n+            ret T_fn_pair(lcx.ccx.tn, llfnty);\n         }\n         case (_) {\n             // fall through\n         }\n     }\n-    ret type_of(ccx, tpt._1);\n+    ret type_of(lcx.ccx, tpt._1);\n }\n \n \n@@ -979,7 +982,7 @@ fn get_simple_extern_fn(&hashmap[str, ValueRef] externs,\n }\n \n fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> result {\n-    auto cxx = cx.fcx.ccx;\n+    auto cxx = cx.fcx.lcx.ccx;\n     auto lltaskptr = cx.build.PtrToInt(cx.fcx.lltaskptr, T_int());\n     auto args2 = vec(lltaskptr) + args;\n     auto t = trans_native_call(cx.build, cxx.glues, lltaskptr,\n@@ -1077,14 +1080,14 @@ fn llalign_of(TypeRef t) -> ValueRef {\n \n fn size_of(@block_ctxt cx, @ty.t t) -> result {\n     if (!ty.type_has_dynamic_size(t)) {\n-        ret res(cx, llsize_of(type_of(cx.fcx.ccx, t)));\n+        ret res(cx, llsize_of(type_of(cx.fcx.lcx.ccx, t)));\n     }\n     ret dynamic_size_of(cx, t);\n }\n \n fn align_of(@block_ctxt cx, @ty.t t) -> result {\n     if (!ty.type_has_dynamic_size(t)) {\n-        ret res(cx, llalign_of(type_of(cx.fcx.ccx, t)));\n+        ret res(cx, llalign_of(type_of(cx.fcx.lcx.ccx, t)));\n     }\n     ret dynamic_align_of(cx, t);\n }\n@@ -1213,7 +1216,7 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n             let ValueRef max_size = alloca(bcx, T_int());\n             bcx.build.Store(C_int(0), max_size);\n \n-            auto variants = tag_variants(bcx.fcx.ccx, tid);\n+            auto variants = tag_variants(bcx.fcx.lcx.ccx, tid);\n             for (variant_info variant in variants) {\n                 // Perform type substitution on the raw argument types.\n                 let vec[@ty.t] raw_tys = variant.args;\n@@ -1370,7 +1373,7 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n         ret res(bcx, bumped);\n     }\n \n-    auto typ = T_ptr(type_of(bcx.fcx.ccx, s.target));\n+    auto typ = T_ptr(type_of(bcx.fcx.lcx.ccx, s.target));\n     ret res(bcx, bcx.build.PointerCast(bumped, typ));\n }\n \n@@ -1385,7 +1388,7 @@ fn GEP_tag(@block_ctxt cx,\n            vec[@ty.t] ty_substs,\n            int ix)\n         -> result {\n-    auto variant = tag_variant_with_id(cx.fcx.ccx, tag_id, variant_id);\n+    auto variant = tag_variant_with_id(cx.fcx.lcx.ccx, tag_id, variant_id);\n \n     // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n     // Separately, store the type of the element we're interested in.\n@@ -1410,7 +1413,7 @@ fn GEP_tag(@block_ctxt cx,\n     // the blob pointer isn't dynamically sized).\n     let ValueRef llunionptr;\n     if (!ty.type_has_dynamic_size(tup_ty)) {\n-        auto llty = type_of(cx.fcx.ccx, tup_ty);\n+        auto llty = type_of(cx.fcx.lcx.ccx, tup_ty);\n         llunionptr = cx.build.TruncOrBitCast(llblobptr, T_ptr(llty));\n     } else {\n         llunionptr = llblobptr;\n@@ -1422,7 +1425,7 @@ fn GEP_tag(@block_ctxt cx,\n     // Cast the result to the appropriate type, if necessary.\n     auto val;\n     if (!ty.type_has_dynamic_size(elem_ty)) {\n-        auto llelemty = type_of(rslt.bcx.fcx.ccx, elem_ty);\n+        auto llelemty = type_of(rslt.bcx.fcx.lcx.ccx, elem_ty);\n         val = rslt.bcx.build.PointerCast(rslt.val, T_ptr(llelemty));\n     } else {\n         val = rslt.val;\n@@ -1447,7 +1450,7 @@ fn trans_malloc_boxed(@block_ctxt cx, @ty.t t) -> result {\n     auto boxed_body = ty.plain_tup_ty(vec(plain_ty(ty.ty_int), t));\n     auto box_ptr = ty.plain_box_ty(t, ast.imm);\n     auto sz = size_of(cx, boxed_body);\n-    auto llty = type_of(cx.fcx.ccx, box_ptr);\n+    auto llty = type_of(cx.fcx.lcx.ccx, box_ptr);\n     ret trans_raw_malloc(sz.bcx, llty, sz.val);\n }\n \n@@ -1520,14 +1523,14 @@ fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n         check (n_params == _vec.len[uint](tys._0));\n         check (n_params == _vec.len[ValueRef](tys._1));\n \n-        if (!cx.fcx.ccx.tydescs.contains_key(t)) {\n-            declare_tydesc(cx.fcx.ccx, t);\n-            define_tydesc(cx.fcx.ccx, t, tys._0);\n+        if (!cx.fcx.lcx.ccx.tydescs.contains_key(t)) {\n+            declare_tydesc(cx.fcx.lcx, t);\n+            define_tydesc(cx.fcx.lcx, t, tys._0);\n         }\n \n-        auto root = cx.fcx.ccx.tydescs.get(t).tydesc;\n+        auto root = cx.fcx.lcx.ccx.tydescs.get(t).tydesc;\n \n-        auto tydescs = alloca(cx, T_array(T_ptr(T_tydesc(cx.fcx.ccx.tn)),\n+        auto tydescs = alloca(cx, T_array(T_ptr(T_tydesc(cx.fcx.lcx.ccx.tn)),\n                                           1u /* for root*/ + n_params));\n \n         auto i = 0;\n@@ -1547,36 +1550,37 @@ fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n         bcx = align.bcx;\n \n         auto v = trans_upcall(bcx, \"upcall_get_type_desc\",\n-                              vec(p2i(bcx.fcx.ccx.crate_ptr),\n+                              vec(p2i(bcx.fcx.lcx.ccx.crate_ptr),\n                                   sz.val,\n                                   align.val,\n                                   C_int((1u + n_params) as int),\n                                   vp2i(bcx, tydescs)));\n \n         ret res(v.bcx, vi2p(v.bcx, v.val,\n-                            T_ptr(T_tydesc(cx.fcx.ccx.tn))));\n+                            T_ptr(T_tydesc(cx.fcx.lcx.ccx.tn))));\n     }\n \n     // Otherwise, generate a tydesc if necessary, and return it.\n-    if (!cx.fcx.ccx.tydescs.contains_key(t)) {\n+    if (!cx.fcx.lcx.ccx.tydescs.contains_key(t)) {\n         let vec[uint] tps = vec();\n-        declare_tydesc(cx.fcx.ccx, t);\n-        define_tydesc(cx.fcx.ccx, t, tps);\n+        declare_tydesc(cx.fcx.lcx, t);\n+        define_tydesc(cx.fcx.lcx, t, tps);\n     }\n-    ret res(cx, cx.fcx.ccx.tydescs.get(t).tydesc);\n+    ret res(cx, cx.fcx.lcx.ccx.tydescs.get(t).tydesc);\n }\n \n // Generates the declaration for (but doesn't fill in) a type descriptor. This\n // needs to be separate from make_tydesc() below, because sometimes type glue\n // functions needs to refer to their own type descriptors.\n-fn declare_tydesc(@crate_ctxt cx, @ty.t t) {\n+fn declare_tydesc(@local_ctxt cx, @ty.t t) {\n     auto take_glue = declare_generic_glue(cx, t, \"take\");\n     auto drop_glue = declare_generic_glue(cx, t, \"drop\");\n+    auto ccx = cx.ccx;\n \n     auto llsize;\n     auto llalign;\n     if (!ty.type_has_dynamic_size(t)) {\n-        auto llty = type_of(cx, t);\n+        auto llty = type_of(ccx, t);\n         llsize = llsize_of(llty);\n         llalign = llalign_of(llty);\n     } else {\n@@ -1586,12 +1590,12 @@ fn declare_tydesc(@crate_ctxt cx, @ty.t t) {\n         llalign = C_int(0);\n     }\n \n-    auto glue_fn_ty = T_ptr(T_glue_fn(cx.tn));\n+    auto glue_fn_ty = T_ptr(T_glue_fn(ccx.tn));\n \n-    auto name = sanitize(cx.names.next(\"tydesc_\" + ty.ty_to_str(t)));\n-    auto gvar = llvm.LLVMAddGlobal(cx.llmod, T_tydesc(cx.tn),\n+    auto name = sanitize(ccx.names.next(\"tydesc_\" + ty.ty_to_str(t)));\n+    auto gvar = llvm.LLVMAddGlobal(ccx.llmod, T_tydesc(ccx.tn),\n                                    _str.buf(name));\n-    auto tydesc = C_struct(vec(C_null(T_ptr(T_ptr(T_tydesc(cx.tn)))),\n+    auto tydesc = C_struct(vec(C_null(T_ptr(T_ptr(T_tydesc(ccx.tn)))),\n                                llsize,\n                                llalign,\n                                take_glue,             // take_glue\n@@ -1613,12 +1617,12 @@ fn declare_tydesc(@crate_ctxt cx, @ty.t t) {\n         drop_glue=drop_glue\n     );\n \n-    cx.tydescs.insert(t, @info);\n+    ccx.tydescs.insert(t, @info);\n }\n \n // declare_tydesc() above must have been called first.\n-fn define_tydesc(@crate_ctxt cx, @ty.t t, vec[uint] ty_params) {\n-    auto info = cx.tydescs.get(t);\n+fn define_tydesc(@local_ctxt cx, @ty.t t, vec[uint] ty_params) {\n+    auto info = cx.ccx.tydescs.get(t);\n     auto gvar = info.tydesc;\n \n     auto tg = make_take_glue;\n@@ -1627,17 +1631,17 @@ fn define_tydesc(@crate_ctxt cx, @ty.t t, vec[uint] ty_params) {\n     auto drop_glue = make_generic_glue(cx, t, info.drop_glue, dg, ty_params);\n }\n \n-fn declare_generic_glue(@crate_ctxt cx, @ty.t t, str name) -> ValueRef {\n-    auto llfnty = T_glue_fn(cx.tn);\n+fn declare_generic_glue(@local_ctxt cx, @ty.t t, str name) -> ValueRef {\n+    auto llfnty = T_glue_fn(cx.ccx.tn);\n \n     auto gcx = @rec(path=vec(\"glue\", name) with *cx);\n     auto fn_name = mangle_name_by_type(gcx, t);\n     fn_name = sanitize(fn_name);\n-    auto llfn = decl_internal_fastcall_fn(cx.llmod, fn_name, llfnty);\n+    auto llfn = decl_internal_fastcall_fn(cx.ccx.llmod, fn_name, llfnty);\n     ret llfn;\n }\n \n-fn make_generic_glue(@crate_ctxt cx, @ty.t t, ValueRef llfn,\n+fn make_generic_glue(@local_ctxt cx, @ty.t t, ValueRef llfn,\n                      val_and_ty_fn helper, vec[uint] ty_params) -> ValueRef {\n     auto fcx = new_fn_ctxt(cx, llfn);\n     auto bcx = new_top_block_ctxt(fcx);\n@@ -1655,7 +1659,7 @@ fn make_generic_glue(@crate_ctxt cx, @ty.t t, ValueRef llfn,\n         if (ty.type_has_dynamic_size(t)) {\n             llty = T_ptr(T_i8());\n         } else {\n-            llty = T_ptr(type_of(cx, t));\n+            llty = T_ptr(type_of(cx.ccx, t));\n         }\n \n         auto ty_param_count = _vec.len[uint](ty_params);\n@@ -1874,7 +1878,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, @ty.t t) -> result {\n             }\n         }\n     }\n-    cx.fcx.ccx.sess.bug(\"bad type in trans.make_drop_glue_inner: \" +\n+    cx.fcx.lcx.ccx.sess.bug(\"bad type in trans.make_drop_glue_inner: \" +\n                         ty.ty_to_str(t));\n     fail;\n }\n@@ -2062,11 +2066,11 @@ fn iter_structural_ty_full(@block_ctxt cx,\n             }\n         }\n         case (ty.ty_tag(?tid, ?tps)) {\n-            auto variants = tag_variants(cx.fcx.ccx, tid);\n+            auto variants = tag_variants(cx.fcx.lcx.ccx, tid);\n             auto n_variants = _vec.len[variant_info](variants);\n \n             // Cast the tags to types we can GEP into.\n-            auto lltagty = T_opaque_tag_ptr(cx.fcx.ccx.tn);\n+            auto lltagty = T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn);\n             auto av_tag = cx.build.PointerCast(av, lltagty);\n             auto bv_tag = cx.build.PointerCast(bv, lltagty);\n \n@@ -2179,7 +2183,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n             ret iter_boxpp(cx, box_cell_a, box_cell_b, f);\n         }\n         case (_) {\n-            cx.fcx.ccx.sess.unimpl(\"type in iter_structural_ty_full\");\n+            cx.fcx.lcx.ccx.sess.unimpl(\"type in iter_structural_ty_full\");\n         }\n     }\n     ret r;\n@@ -2246,7 +2250,7 @@ fn iter_sequence_inner(@block_ctxt cx,\n                   ValueRef src) -> result {\n         auto llptrty;\n         if (!ty.type_has_dynamic_size(elt_ty)) {\n-            auto llty = type_of(cx.fcx.ccx, elt_ty);\n+            auto llty = type_of(cx.fcx.lcx.ccx, elt_ty);\n             llptrty = T_ptr(llty);\n         } else {\n             llptrty = T_ptr(T_ptr(T_i8()));\n@@ -2283,7 +2287,7 @@ fn iter_sequence(@block_ctxt cx,\n         if (ty.type_has_dynamic_size(elt_ty)) {\n             llunit_ty = T_i8();\n         } else {\n-            llunit_ty = type_of(cx.fcx.ccx, elt_ty);\n+            llunit_ty = type_of(cx.fcx.lcx.ccx, elt_ty);\n         }\n \n         auto bcx = cx;\n@@ -2311,7 +2315,7 @@ fn iter_sequence(@block_ctxt cx,\n         }\n         case (_) { fail; }\n     }\n-    cx.fcx.ccx.sess.bug(\"bad type in trans.iter_sequence\");\n+    cx.fcx.lcx.ccx.sess.bug(\"bad type in trans.iter_sequence\");\n     fail;\n }\n \n@@ -2375,7 +2379,7 @@ fn call_memcpy(@block_ctxt cx,\n     auto src_ptr = cx.build.PointerCast(src, T_ptr(T_i8()));\n     auto dst_ptr = cx.build.PointerCast(dst, T_ptr(T_i8()));\n     auto size = cx.build.IntCast(n_bytes, T_int());\n-    ret res(cx, cx.build.FastCall(cx.fcx.ccx.glues.memcpy_glue,\n+    ret res(cx, cx.build.FastCall(cx.fcx.lcx.ccx.glues.memcpy_glue,\n                                   vec(dst_ptr, src_ptr, size)));\n }\n \n@@ -2384,7 +2388,7 @@ fn call_bzero(@block_ctxt cx,\n               ValueRef n_bytes) -> result {\n     auto dst_ptr = cx.build.PointerCast(dst, T_ptr(T_i8()));\n     auto size = cx.build.IntCast(n_bytes, T_int());\n-    ret res(cx, cx.build.FastCall(cx.fcx.ccx.glues.bzero_glue,\n+    ret res(cx, cx.build.FastCall(cx.fcx.lcx.ccx.glues.bzero_glue,\n                                   vec(dst_ptr, size)));\n }\n \n@@ -2434,7 +2438,7 @@ fn copy_ty(@block_ctxt cx,\n         ret memcpy_ty(r.bcx, dst, src, t);\n     }\n \n-    cx.fcx.ccx.sess.bug(\"unexpected type in trans.copy_ty: \" +\n+    cx.fcx.lcx.ccx.sess.bug(\"unexpected type in trans.copy_ty: \" +\n                         ty.ty_to_str(t));\n     fail;\n }\n@@ -2561,7 +2565,7 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n         case (ast.box(_)) {\n             auto e_ty = ty.expr_ty(e);\n             auto e_val = sub.val;\n-            auto box_ty = node_ann_type(sub.bcx.fcx.ccx, a);\n+            auto box_ty = node_ann_type(sub.bcx.fcx.lcx.ccx, a);\n             sub = trans_malloc_boxed(sub.bcx, e_ty);\n             find_scope_cx(cx).cleanups +=\n                 vec(clean(bind drop_ty(_, sub.val, box_ty)));\n@@ -2579,7 +2583,7 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n             // make tags work, since tags have a different LLVM type depending\n             // on whether they're boxed or not.\n             if (!ty.type_has_dynamic_size(e_ty)) {\n-                auto llety = T_ptr(type_of(sub.bcx.fcx.ccx, e_ty));\n+                auto llety = T_ptr(type_of(sub.bcx.fcx.lcx.ccx, e_ty));\n                 body = sub.bcx.build.PointerCast(body, llety);\n             }\n \n@@ -2729,7 +2733,7 @@ fn trans_compare(@block_ctxt cx0, ast.binop op, @ty.t t0,\n \n     } else {\n         // FIXME: compare obj, fn by pointer?\n-        cx.fcx.ccx.sess.unimpl(\"type in trans_compare\");\n+        cx.fcx.lcx.ccx.sess.unimpl(\"type in trans_compare\");\n         ret res(cx, C_bool(false));\n     }\n }\n@@ -2822,7 +2826,7 @@ fn trans_vec_append(@block_ctxt cx, @ty.t t,\n     auto dst = bcx.build.PointerCast(lhs, T_ptr(T_opaque_vec_ptr()));\n     auto src = bcx.build.PointerCast(rhs, T_opaque_vec_ptr());\n \n-    ret res(bcx, bcx.build.FastCall(cx.fcx.ccx.glues.vec_append_glue,\n+    ret res(bcx, bcx.build.FastCall(cx.fcx.lcx.ccx.glues.vec_append_glue,\n                                     vec(cx.fcx.lltaskptr,\n                                         llvec_tydesc.val,\n                                         llelt_tydesc.val,\n@@ -2936,7 +2940,7 @@ fn autoderef(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                 // different types depending on whether they're behind a box\n                 // or not.\n                 if (!ty.type_has_dynamic_size(mt.ty)) {\n-                    auto llty = type_of(cx.fcx.ccx, mt.ty);\n+                    auto llty = type_of(cx.fcx.lcx.ccx, mt.ty);\n                     v1 = cx.build.PointerCast(body, T_ptr(llty));\n                 } else {\n                     v1 = body;\n@@ -3098,9 +3102,9 @@ fn trans_if(@block_ctxt cx, @ast.expr cond,\n             // FIXME: This isn't quite right, particularly re: dynamic types\n             auto expr_ty = ty.expr_ty(elexpr);\n             if (ty.type_has_dynamic_size(expr_ty)) {\n-                expr_llty = T_typaram_ptr(cx.fcx.ccx.tn);\n+                expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n             } else {\n-                expr_llty = type_of(else_res.bcx.fcx.ccx, expr_ty);\n+                expr_llty = type_of(else_res.bcx.fcx.lcx.ccx, expr_ty);\n                 if (ty.type_is_structural(expr_ty)) {\n                     expr_llty = T_ptr(expr_llty);\n                 }\n@@ -3253,7 +3257,7 @@ fn trans_for_each(@block_ctxt cx,\n     auto decl_id;\n     alt (decl.node) {\n         case (ast.decl_local(?local)) {\n-            decl_ty = node_ann_type(cx.fcx.ccx, local.ann);\n+            decl_ty = node_ann_type(cx.fcx.lcx.ccx, local.ann);\n             decl_id = local.id;\n         }\n     }\n@@ -3299,7 +3303,7 @@ fn trans_for_each(@block_ctxt cx,\n \n     // Create an environment and populate it with the bindings.\n     auto tydesc_count = _vec.len[ValueRef](cx.fcx.lltydescs);\n-    auto llenvptrty = T_closure_ptr(cx.fcx.ccx.tn, T_ptr(T_nil()),\n+    auto llenvptrty = T_closure_ptr(cx.fcx.lcx.ccx.tn, T_ptr(T_nil()),\n                                     val_ty(llbindingsptr), tydesc_count);\n     auto llenvptr = alloca(cx, llvm.LLVMGetElementType(llenvptrty));\n \n@@ -3325,26 +3329,26 @@ fn trans_for_each(@block_ctxt cx,\n \n     // Step 2: Declare foreach body function.\n \n-    let str s = mangle_name_by_seq(cx.fcx.ccx, \"foreach\");\n+    let str s = mangle_name_by_seq(cx.fcx.lcx, \"foreach\");\n \n     // The 'env' arg entering the body function is a fake env member (as in\n     // the env-part of the normal rust calling convention) that actually\n     // points to a stack allocated env in this frame. We bundle that env\n     // pointer along with the foreach-body-fn pointer into a 'normal' fn pair\n     // and pass it in as a first class fn-arg to the iterator.\n \n-    auto iter_body_llty = type_of_fn_full(cx.fcx.ccx, ast.proto_fn,\n+    auto iter_body_llty = type_of_fn_full(cx.fcx.lcx.ccx, ast.proto_fn,\n                                           none[TypeRef],\n                                           vec(rec(mode=ast.val, ty=decl_ty)),\n                                           plain_ty(ty.ty_nil), 0u);\n \n-    let ValueRef lliterbody = decl_internal_fastcall_fn(cx.fcx.ccx.llmod,\n+    let ValueRef lliterbody = decl_internal_fastcall_fn(cx.fcx.lcx.ccx.llmod,\n                                                        s, iter_body_llty);\n \n     // FIXME: handle ty params properly.\n     let vec[ast.ty_param] ty_params = vec();\n \n-    auto fcx = new_fn_ctxt(cx.fcx.ccx, lliterbody);\n+    auto fcx = new_fn_ctxt(cx.fcx.lcx, lliterbody);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n@@ -3402,7 +3406,7 @@ fn trans_for_each(@block_ctxt cx,\n \n         case (ast.expr_call(?f, ?args, ?ann)) {\n \n-            auto pair = alloca(cx, T_fn_pair(cx.fcx.ccx.tn,\n+            auto pair = alloca(cx, T_fn_pair(cx.fcx.lcx.ccx.tn,\n                                              iter_body_llty));\n             auto code_cell = cx.build.GEP(pair,\n                                           vec(C_int(0),\n@@ -3412,10 +3416,10 @@ fn trans_for_each(@block_ctxt cx,\n             auto env_cell = cx.build.GEP(pair, vec(C_int(0),\n                                                    C_int(abi.fn_field_box)));\n             auto llenvblobptr = cx.build.PointerCast(llenvptr,\n-                T_opaque_closure_ptr(cx.fcx.ccx.tn));\n+                T_opaque_closure_ptr(cx.fcx.lcx.ccx.tn));\n             cx.build.Store(llenvblobptr, env_cell);\n \n-            // log \"lliterbody: \" + val_str(cx.fcx.ccx.tn, lliterbody);\n+            // log \"lliterbody: \" + val_str(cx.fcx.lcx.ccx.tn, lliterbody);\n             ret trans_call(cx, f,\n                            some[ValueRef](cx.build.Load(pair)),\n                            args,\n@@ -3472,7 +3476,7 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n         case (ast.pat_bind(_, _, _)) { ret res(cx, llval); }\n \n         case (ast.pat_lit(?lt, ?ann)) {\n-            auto lllit = trans_lit(cx.fcx.ccx, *lt, ann);\n+            auto lllit = trans_lit(cx.fcx.lcx.ccx, *lt, ann);\n             auto lltype = ty.ann_to_type(ann);\n             auto lleq = trans_compare(cx, ast.eq, lltype, llval, lllit);\n \n@@ -3483,7 +3487,7 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n \n         case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n             auto lltagptr = cx.build.PointerCast(llval,\n-                T_opaque_tag_ptr(cx.fcx.ccx.tn));\n+                T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n \n             auto lldiscrimptr = cx.build.GEP(lltagptr,\n                                              vec(C_int(0), C_int(0)));\n@@ -3493,7 +3497,7 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n             auto variant_id = vdef._1;\n             auto variant_tag = 0;\n \n-            auto variants = tag_variants(cx.fcx.ccx, vdef._0);\n+            auto variants = tag_variants(cx.fcx.lcx.ccx, vdef._0);\n             auto i = 0;\n             for (variant_info v in variants) {\n                 auto this_variant_id = v.id;\n@@ -3544,7 +3548,7 @@ fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n         case (ast.pat_wild(_)) { ret res(cx, llval); }\n         case (ast.pat_lit(_, _)) { ret res(cx, llval); }\n         case (ast.pat_bind(?id, ?def_id, ?ann)) {\n-            auto ty = node_ann_type(cx.fcx.ccx, ann);\n+            auto ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n \n             auto rslt = alloc_ty(cx, ty);\n             auto dst = rslt.val;\n@@ -3564,7 +3568,7 @@ fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n             auto vdef = option.get[ast.variant_def](vdef_opt);\n \n             auto lltagptr = cx.build.PointerCast(llval,\n-                T_opaque_tag_ptr(cx.fcx.ccx.tn));\n+                T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n             auto llblobptr = cx.build.GEP(lltagptr, vec(C_int(0), C_int(1)));\n \n             auto ty_param_substs = node_ann_ty_params(ann);\n@@ -3621,9 +3625,9 @@ fn trans_alt(@block_ctxt cx, @ast.expr expr,\n     auto expr_ty = ty.ann_to_type(ann);\n     auto expr_llty;\n     if (ty.type_has_dynamic_size(expr_ty)) {\n-        expr_llty = T_typaram_ptr(cx.fcx.ccx.tn);\n+        expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n     } else {\n-        expr_llty = type_of(cx.fcx.ccx, expr_ty);\n+        expr_llty = type_of(cx.fcx.lcx.ccx, expr_ty);\n         if (ty.type_is_structural(expr_ty)) {\n             expr_llty = T_ptr(expr_llty);\n         }\n@@ -3659,10 +3663,10 @@ fn lval_val(@block_ctxt cx, ValueRef val) -> lval_result {\n \n fn trans_external_path(@block_ctxt cx, ast.def_id did,\n                        ty.ty_param_count_and_ty tpt) -> lval_result {\n-    auto ccx = cx.fcx.ccx;\n-    auto name = creader.get_symbol(ccx.sess, did);\n-    auto v = get_extern_const(ccx.externs, ccx.llmod,\n-                              name, type_of_ty_param_count_and_ty(ccx, tpt));\n+    auto lcx = cx.fcx.lcx;\n+    auto name = creader.get_symbol(lcx.ccx.sess, did);\n+    auto v = get_extern_const(lcx.ccx.externs, lcx.ccx.llmod,\n+                              name, type_of_ty_param_count_and_ty(lcx, tpt));\n     ret lval_val(cx, v);\n }\n \n@@ -3672,10 +3676,10 @@ fn lval_generic_fn(@block_ctxt cx,\n                    &ast.ann ann)\n         -> lval_result {\n     auto lv;\n-    if (cx.fcx.ccx.sess.get_targ_crate_num() == fn_id._0) {\n+    if (cx.fcx.lcx.ccx.sess.get_targ_crate_num() == fn_id._0) {\n         // Internal reference.\n-        check (cx.fcx.ccx.fn_pairs.contains_key(fn_id));\n-        lv = lval_val(cx, cx.fcx.ccx.fn_pairs.get(fn_id));\n+        check (cx.fcx.lcx.ccx.fn_pairs.contains_key(fn_id));\n+        lv = lval_val(cx, cx.fcx.lcx.ccx.fn_pairs.get(fn_id));\n     } else {\n         // External reference.\n         lv = trans_external_path(cx, fn_id, tpt);\n@@ -3685,7 +3689,7 @@ fn lval_generic_fn(@block_ctxt cx,\n     let vec[@ty.t] tys;\n     alt (ann) {\n         case (ast.ann_none) {\n-            cx.fcx.ccx.sess.bug(\"no type annotation for path!\");\n+            cx.fcx.lcx.ccx.sess.bug(\"no type annotation for path!\");\n             fail;\n         }\n         case (ast.ann_type(?monoty_, ?tps, _)) {\n@@ -3711,18 +3715,19 @@ fn lval_generic_fn(@block_ctxt cx,\n     ret lv;\n }\n \n-fn lookup_discriminant(@crate_ctxt ccx, ast.def_id tid, ast.def_id vid)\n+fn lookup_discriminant(@local_ctxt lcx, ast.def_id tid, ast.def_id vid)\n         -> ValueRef {\n-    alt (ccx.discrims.find(vid)) {\n+    alt (lcx.ccx.discrims.find(vid)) {\n         case (none[ValueRef]) {\n             // It's an external discriminant that we haven't seen yet.\n-            check (ccx.sess.get_targ_crate_num() != vid._0);\n-            auto sym = creader.get_symbol(ccx.sess, vid);\n-            auto gvar = llvm.LLVMAddGlobal(ccx.llmod, T_int(), _str.buf(sym));\n+            check (lcx.ccx.sess.get_targ_crate_num() != vid._0);\n+            auto sym = creader.get_symbol(lcx.ccx.sess, vid);\n+            auto gvar = llvm.LLVMAddGlobal(lcx.ccx.llmod, T_int(),\n+                                           _str.buf(sym));\n             llvm.LLVMSetLinkage(gvar,\n                                 lib.llvm.LLVMExternalLinkage as llvm.Linkage);\n             llvm.LLVMSetGlobalConstant(gvar, True);\n-            ccx.discrims.insert(vid, gvar);\n+            lcx.ccx.discrims.insert(vid, gvar);\n             ret gvar;\n         }\n         case (some[ValueRef](?llval)) { ret llval; }\n@@ -3765,38 +3770,38 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                     ret lval_mem(cx, cx.fcx.llobjfields.get(did));\n                 }\n                 case (ast.def_fn(?did)) {\n-                    auto tyt = ty.lookup_item_type(cx.fcx.ccx.sess,\n-                        cx.fcx.ccx.type_cache, did);\n+                    auto tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n+                        cx.fcx.lcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (ast.def_obj(?did)) {\n-                    auto tyt = ty.lookup_item_type(cx.fcx.ccx.sess,\n-                        cx.fcx.ccx.type_cache, did);\n+                    auto tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n+                        cx.fcx.lcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (ast.def_variant(?tid, ?vid)) {\n-                    auto v_tyt = ty.lookup_item_type(cx.fcx.ccx.sess,\n-                        cx.fcx.ccx.type_cache, vid);\n+                    auto v_tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n+                        cx.fcx.lcx.ccx.type_cache, vid);\n                     alt (v_tyt._1.struct) {\n                         case (ty.ty_fn(_, _, _)) {\n                             // N-ary variant.\n                             ret lval_generic_fn(cx, v_tyt, vid, ann);\n                         }\n                         case (_) {\n                             // Nullary variant.\n-                            auto tag_ty = node_ann_type(cx.fcx.ccx, ann);\n+                            auto tag_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n                             auto lldiscrim_gv =\n-                                lookup_discriminant(cx.fcx.ccx, tid, vid);\n+                                lookup_discriminant(cx.fcx.lcx, tid, vid);\n                             auto lldiscrim = cx.build.Load(lldiscrim_gv);\n \n                             auto alloc_result = alloc_ty(cx, tag_ty);\n                             auto lltagblob = alloc_result.val;\n \n                             auto lltagty;\n                             if (ty.type_has_dynamic_size(tag_ty)) {\n-                                lltagty = T_opaque_tag(cx.fcx.ccx.tn);\n+                                lltagty = T_opaque_tag(cx.fcx.lcx.ccx.tn);\n                             } else {\n-                                lltagty = type_of(cx.fcx.ccx, tag_ty);\n+                                lltagty = type_of(cx.fcx.lcx.ccx, tag_ty);\n                             }\n                             auto lltagptr = alloc_result.bcx.build.\n                                 PointerCast(lltagblob, T_ptr(lltagty));\n@@ -3812,21 +3817,21 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 }\n                 case (ast.def_const(?did)) {\n                     // TODO: externals\n-                    check (cx.fcx.ccx.consts.contains_key(did));\n-                    ret lval_mem(cx, cx.fcx.ccx.consts.get(did));\n+                    check (cx.fcx.lcx.ccx.consts.contains_key(did));\n+                    ret lval_mem(cx, cx.fcx.lcx.ccx.consts.get(did));\n                 }\n                 case (ast.def_native_fn(?did)) {\n-                    auto tyt = ty.lookup_item_type(cx.fcx.ccx.sess,\n-                        cx.fcx.ccx.type_cache, did);\n+                    auto tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n+                        cx.fcx.lcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (_) {\n-                    cx.fcx.ccx.sess.unimpl(\"def variant in trans\");\n+                    cx.fcx.lcx.ccx.sess.unimpl(\"def variant in trans\");\n                 }\n             }\n         }\n         case (none[ast.def]) {\n-            cx.fcx.ccx.sess.err(\"unresolved expr_path in trans\");\n+            cx.fcx.lcx.ccx.sess.err(\"unresolved expr_path in trans\");\n         }\n     }\n     fail;\n@@ -3840,17 +3845,19 @@ fn trans_field(@block_ctxt cx, &ast.span sp, ValueRef v, @ty.t t0,\n \n     alt (t.struct) {\n         case (ty.ty_tup(_)) {\n-            let uint ix = ty.field_num(cx.fcx.ccx.sess, sp, field);\n+            let uint ix = ty.field_num(cx.fcx.lcx.ccx.sess, sp, field);\n             auto v = GEP_tup_like(r.bcx, t, r.val, vec(0, ix as int));\n             ret lval_mem(v.bcx, v.val);\n         }\n         case (ty.ty_rec(?fields)) {\n-            let uint ix = ty.field_idx(cx.fcx.ccx.sess, sp, field, fields);\n+            let uint ix = ty.field_idx(cx.fcx.lcx.ccx.sess, sp, field,\n+                                       fields);\n             auto v = GEP_tup_like(r.bcx, t, r.val, vec(0, ix as int));\n             ret lval_mem(v.bcx, v.val);\n         }\n         case (ty.ty_obj(?methods)) {\n-            let uint ix = ty.method_idx(cx.fcx.ccx.sess, sp, field, methods);\n+            let uint ix = ty.method_idx(cx.fcx.lcx.ccx.sess, sp, field,\n+                                        methods);\n             auto vtbl = r.bcx.build.GEP(r.val,\n                                         vec(C_int(0),\n                                             C_int(abi.obj_field_vtbl)));\n@@ -3864,7 +3871,7 @@ fn trans_field(@block_ctxt cx, &ast.span sp, ValueRef v, @ty.t t0,\n                     method_ty = some[@ty.t](fn_ty)\n                     with lvo);\n         }\n-        case (_) { cx.fcx.ccx.sess.unimpl(\"field variant in trans_field\"); }\n+        case (_) {cx.fcx.lcx.ccx.sess.unimpl(\"field variant in trans_field\");}\n     }\n     fail;\n }\n@@ -3880,8 +3887,8 @@ fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n \n     // Cast to an LLVM integer. Rust is less strict than LLVM in this regard.\n     auto ix_val;\n-    auto ix_size = llsize_of_real(cx.fcx.ccx, val_ty(ix.val));\n-    auto int_size = llsize_of_real(cx.fcx.ccx, T_int());\n+    auto ix_size = llsize_of_real(cx.fcx.lcx.ccx, val_ty(ix.val));\n+    auto int_size = llsize_of_real(cx.fcx.lcx.ccx, T_int());\n     if (ix_size < int_size) {\n         ix_val = bcx.build.ZExt(ix.val, T_int());\n     } else if (ix_size > int_size) {\n@@ -3890,7 +3897,7 @@ fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n         ix_val = ix.val;\n     }\n \n-    auto unit_ty = node_ann_type(cx.fcx.ccx, ann);\n+    auto unit_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n     llvm.LLVMSetValueName(unit_sz.val, _str.buf(\"unit_sz\"));\n@@ -3920,7 +3927,7 @@ fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n         elt = next_cx.build.GEP(body, vec(C_int(0), ix_val));\n \n         // We're crossing a box boundary here, so we may need to pointer cast.\n-        auto llunitty = type_of(next_cx.fcx.ccx, unit_ty);\n+        auto llunitty = type_of(next_cx.fcx.lcx.ccx, unit_ty);\n         elt = next_cx.build.PointerCast(elt, T_ptr(llunitty));\n     }\n \n@@ -3968,7 +3975,8 @@ fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n             }\n         }\n         case (_) {\n-            cx.fcx.ccx.sess.span_unimpl(e.span, \"expr variant in trans_lval\");\n+            cx.fcx.lcx.ccx.sess.span_unimpl(e.span,\n+                                            \"expr variant in trans_lval\");\n         }\n     }\n     fail;\n@@ -3977,8 +3985,8 @@ fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n     auto e_res = trans_expr(cx, e);\n     auto llsrctype = val_ty(e_res.val);\n-    auto t = node_ann_type(cx.fcx.ccx, ann);\n-    auto lldsttype = type_of(cx.fcx.ccx, t);\n+    auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n+    auto lldsttype = type_of(cx.fcx.lcx.ccx, t);\n     if (!ty.type_is_fp(t)) {\n         // TODO: native-to-native casts\n         if (ty.type_is_native(ty.expr_ty(e))) {\n@@ -4005,12 +4013,12 @@ fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n                                                lldsttype);\n         }\n     } else {\n-        cx.fcx.ccx.sess.unimpl(\"fp cast\");\n+        cx.fcx.lcx.ccx.sess.unimpl(\"fp cast\");\n     }\n     ret e_res;\n }\n \n-fn trans_bind_thunk(@crate_ctxt cx,\n+fn trans_bind_thunk(@local_ctxt cx,\n                     @ty.t incoming_fty,\n                     @ty.t outgoing_fty,\n                     vec[option.t[@ast.expr]] args,\n@@ -4021,14 +4029,16 @@ fn trans_bind_thunk(@crate_ctxt cx,\n     // args forward into a call to outgoing_fty.\n \n     let str s = mangle_name_by_seq(cx, \"thunk\");\n-    let TypeRef llthunk_ty = get_pair_fn_ty(type_of(cx, incoming_fty));\n-    let ValueRef llthunk = decl_internal_fastcall_fn(cx.llmod, s, llthunk_ty);\n+    let TypeRef llthunk_ty = get_pair_fn_ty(type_of(cx.ccx, incoming_fty));\n+    let ValueRef llthunk = decl_internal_fastcall_fn(cx.ccx.llmod,\n+                                                     s, llthunk_ty);\n \n     auto fcx = new_fn_ctxt(cx, llthunk);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n-    auto llclosure_ptr_ty = type_of(cx, ty.plain_box_ty(closure_ty, ast.imm));\n+    auto llclosure_ptr_ty = type_of(cx.ccx, ty.plain_box_ty(closure_ty,\n+                                                            ast.imm));\n     auto llclosure = bcx.build.PointerCast(fcx.llenv, llclosure_ptr_ty);\n \n     auto lltarget = GEP_tup_like(bcx, closure_ty, llclosure,\n@@ -4046,7 +4056,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n \n     auto llretptr = fcx.llretptr;\n     if (ty.type_has_dynamic_size(outgoing_ret_ty)) {\n-        llretptr = bcx.build.PointerCast(llretptr, T_typaram_ptr(cx.tn));\n+        llretptr = bcx.build.PointerCast(llretptr, T_typaram_ptr(cx.ccx.tn));\n     }\n \n     let vec[ValueRef] llargs = vec(llretptr,\n@@ -4071,7 +4081,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n     let int b = 0;\n     let uint outgoing_arg_index = 0u;\n     let vec[TypeRef] llout_arg_tys =\n-        type_of_explicit_args(cx, outgoing_args);\n+        type_of_explicit_args(cx.ccx, outgoing_args);\n \n     for (option.t[@ast.expr] arg in args) {\n \n@@ -4128,7 +4138,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n \n     // Cast the outgoing function to the appropriate type (see the comments in\n     // trans_bind below for why this is necessary).\n-    auto lltargetty = type_of_fn(bcx.fcx.ccx,\n+    auto lltargetty = type_of_fn(bcx.fcx.lcx.ccx,\n                                  ty.ty_fn_proto(outgoing_fty),\n                                  outgoing_args,\n                                  outgoing_ret_ty,\n@@ -4151,7 +4161,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n               &ast.ann ann) -> result {\n     auto f_res = trans_lval(cx, f);\n     if (f_res.is_mem) {\n-        cx.fcx.ccx.sess.unimpl(\"re-binding existing function\");\n+        cx.fcx.lcx.ccx.sess.unimpl(\"re-binding existing function\");\n     } else {\n         let vec[@ast.expr] bound = vec();\n \n@@ -4185,7 +4195,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             ret f_res.res;\n         } else {\n             auto bcx = f_res.res.bcx;\n-            auto pair_t = node_type(cx.fcx.ccx, ann);\n+            auto pair_t = node_type(cx.fcx.lcx.ccx, ann);\n             auto pair_v = alloca(bcx, pair_t);\n \n             // Translate the bound expressions.\n@@ -4248,12 +4258,12 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             // specifically, we know how many type descriptors the outgoing\n             // function has, which type_of() doesn't, as only we know which\n             // item the function refers to.\n-            auto llfnty = type_of_fn(bcx.fcx.ccx,\n+            auto llfnty = type_of_fn(bcx.fcx.lcx.ccx,\n                                      ty.ty_fn_proto(outgoing_fty),\n                                      ty.ty_fn_args(outgoing_fty),\n                                      ty.ty_fn_ret(outgoing_fty),\n                                      ty_param_count);\n-            auto llclosurety = T_ptr(T_fn_pair(bcx.fcx.ccx.tn, llfnty));\n+            auto llclosurety = T_ptr(T_fn_pair(bcx.fcx.lcx.ccx.tn, llfnty));\n \n             // Store thunk-target.\n             auto bound_target =\n@@ -4304,10 +4314,10 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                                            vec(C_int(0),\n                                                C_int(abi.fn_field_code)));\n \n-            let @ty.t pair_ty = node_ann_type(cx.fcx.ccx, ann);\n+            let @ty.t pair_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n \n             let ValueRef llthunk =\n-                trans_bind_thunk(cx.fcx.ccx, pair_ty, outgoing_fty,\n+                trans_bind_thunk(cx.fcx.lcx, pair_ty, outgoing_fty,\n                                  args, closure_ty, bound_tys,\n                                  ty_param_count);\n \n@@ -4320,7 +4330,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             bcx.build.Store\n                 (bcx.build.PointerCast\n                  (box,\n-                  T_opaque_closure_ptr(bcx.fcx.ccx.tn)),\n+                  T_opaque_closure_ptr(bcx.fcx.lcx.ccx.tn)),\n                  pair_box);\n \n             find_scope_cx(cx).cleanups +=\n@@ -4369,8 +4379,8 @@ fn trans_args(@block_ctxt cx,\n         }\n     }\n     if (ty.type_has_dynamic_size(retty)) {\n-        llargs += vec(bcx.build.PointerCast(llretslot,\n-                                            T_typaram_ptr(cx.fcx.ccx.tn)));\n+        llargs += vec(bcx.build.PointerCast\n+                      (llretslot, T_typaram_ptr(cx.fcx.lcx.ccx.tn)));\n     } else if (ty.count_ty_params(retty) != 0u) {\n         // It's possible that the callee has some generic-ness somewhere in\n         // its return value -- say a method signature within an obj or a fn\n@@ -4379,7 +4389,7 @@ fn trans_args(@block_ctxt cx,\n         // view, for the sake of making a type-compatible call.\n         llargs +=\n             vec(cx.build.PointerCast(llretslot,\n-                                     T_ptr(type_of(bcx.fcx.ccx, retty))));\n+                                     T_ptr(type_of(bcx.fcx.lcx.ccx, retty))));\n     } else {\n         llargs += vec(llretslot);\n     }\n@@ -4417,7 +4427,7 @@ fn trans_args(@block_ctxt cx,\n     // First we figure out the caller's view of the types of the arguments.\n     // This will be needed if this is a generic call, because the callee has\n     // to cast her view of the arguments to the caller's view.\n-    auto arg_tys = type_of_explicit_args(cx.fcx.ccx, args);\n+    auto arg_tys = type_of_explicit_args(cx.fcx.lcx.ccx, args);\n \n     auto i = 0u;\n     for (@ast.expr e in es) {\n@@ -4495,7 +4505,7 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n \n     auto f_res = trans_lval(cx, f);\n     auto faddr = f_res.res.val;\n-    auto llenv = C_null(T_opaque_closure_ptr(cx.fcx.ccx.tn));\n+    auto llenv = C_null(T_opaque_closure_ptr(cx.fcx.lcx.ccx.tn));\n \n     alt (f_res.llobj) {\n         case (some[ValueRef](_)) {\n@@ -4543,10 +4553,10 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n     auto llretslot = args_res._2;\n \n     /*\n-    log \"calling: \" + val_str(cx.fcx.ccx.tn, faddr);\n+    log \"calling: \" + val_str(cx.fcx.lcx.ccx.tn, faddr);\n \n     for (ValueRef arg in llargs) {\n-        log \"arg: \" + val_str(cx.fcx.ccx.tn, arg);\n+        log \"arg: \" + val_str(cx.fcx.lcx.ccx.tn, arg);\n     }\n     */\n \n@@ -4568,7 +4578,7 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n              &ast.ann ann) -> result {\n     auto bcx = cx;\n-    auto t = node_ann_type(bcx.fcx.ccx, ann);\n+    auto t = node_ann_type(bcx.fcx.lcx.ccx, ann);\n     auto tup_res = alloc_ty(bcx, t);\n     auto tup_val = tup_res.val;\n     bcx = tup_res.bcx;\n@@ -4591,14 +4601,14 @@ fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n \n fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n              &ast.ann ann) -> result {\n-    auto t = node_ann_type(cx.fcx.ccx, ann);\n+    auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty = t;\n     alt (t.struct) {\n         case (ty.ty_vec(?mt)) {\n             unit_ty = mt.ty;\n         }\n         case (_) {\n-            cx.fcx.ccx.sess.bug(\"non-vec type in trans_vec\");\n+            cx.fcx.lcx.ccx.sess.bug(\"non-vec type in trans_vec\");\n         }\n     }\n \n@@ -4612,7 +4622,7 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n     auto sub = trans_upcall(bcx, \"upcall_new_vec\", vec(data_sz, C_int(0)));\n     bcx = sub.bcx;\n \n-    auto llty = type_of(bcx.fcx.ccx, t);\n+    auto llty = type_of(bcx.fcx.lcx.ccx, t);\n     auto vec_val = vi2p(bcx, sub.val, llty);\n     find_scope_cx(bcx).cleanups +=\n         vec(clean(bind drop_ty(_, vec_val, t)));\n@@ -4645,7 +4655,7 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n \n         auto dst_val;\n         if (!ty.type_has_dynamic_size(unit_ty)) {\n-            auto llunit_ty = type_of(cx.fcx.ccx, unit_ty);\n+            auto llunit_ty = type_of(cx.fcx.lcx.ccx, unit_ty);\n             dst_val = bcx.build.PointerCast(dst_res.val, T_ptr(llunit_ty));\n         } else {\n             dst_val = dst_res.val;\n@@ -4665,7 +4675,7 @@ fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n              option.t[@ast.expr] base, &ast.ann ann) -> result {\n \n     auto bcx = cx;\n-    auto t = node_ann_type(bcx.fcx.ccx, ann);\n+    auto t = node_ann_type(bcx.fcx.lcx.ccx, ann);\n     auto rec_res = alloc_ty(bcx, t);\n     auto rec_val = rec_res.val;\n     bcx = rec_res.bcx;\n@@ -4722,7 +4732,7 @@ fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n     alt (e.node) {\n         case (ast.expr_lit(?lit, ?ann)) {\n-            ret res(cx, trans_lit(cx.fcx.ccx, *lit, ann));\n+            ret res(cx, trans_lit(cx.fcx.lcx.ccx, *lit, ann));\n         }\n \n         case (ast.expr_unary(?op, ?x, ?ann)) {\n@@ -4774,14 +4784,14 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             auto lhs_res = trans_lval(cx, dst);\n             check (lhs_res.is_mem);\n             auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n-            auto t = node_ann_type(cx.fcx.ccx, ann);\n+            auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n             // FIXME: calculate copy init-ness in typestate.\n             ret copy_ty(rhs_res.bcx, DROP_EXISTING,\n                         lhs_res.res.val, rhs_res.val, t);\n         }\n \n         case (ast.expr_assign_op(?op, ?dst, ?src, ?ann)) {\n-            auto t = node_ann_type(cx.fcx.ccx, ann);\n+            auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n             auto lhs_res = trans_lval(cx, dst);\n             check (lhs_res.is_mem);\n             auto lhs_val = load_if_immediate(lhs_res.res.bcx,\n@@ -4979,9 +4989,9 @@ fn trans_check_expr(@block_ctxt cx, @ast.expr e) -> result {\n }\n \n fn trans_fail(@block_ctxt cx, common.span sp, str fail_str) -> result {\n-    auto V_fail_str = p2i(C_cstr(cx.fcx.ccx, fail_str));\n-    auto loc = cx.fcx.ccx.sess.lookup_pos(sp.lo);\n-    auto V_filename = p2i(C_cstr(cx.fcx.ccx, loc.filename));\n+    auto V_fail_str = p2i(C_cstr(cx.fcx.lcx.ccx, fail_str));\n+    auto loc = cx.fcx.lcx.ccx.sess.lookup_pos(sp.lo);\n+    auto V_filename = p2i(C_cstr(cx.fcx.lcx.ccx, loc.filename));\n     auto V_line = loc.line as int;\n     auto args = vec(V_fail_str, V_filename, C_int(V_line));\n \n@@ -5116,26 +5126,26 @@ fn trans_be(@block_ctxt cx, @ast.expr e) -> result {\n \n fn trans_port(@block_ctxt cx, ast.ann ann) -> result {\n \n-    auto t = node_ann_type(cx.fcx.ccx, ann);\n+    auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty;\n     alt (t.struct) {\n         case (ty.ty_port(?t)) {\n             unit_ty = t;\n         }\n         case (_) {\n-            cx.fcx.ccx.sess.bug(\"non-port type in trans_port\");\n+            cx.fcx.lcx.ccx.sess.bug(\"non-port type in trans_port\");\n             fail;\n         }\n     }\n \n-    auto llunit_ty = type_of(cx.fcx.ccx, unit_ty);\n+    auto llunit_ty = type_of(cx.fcx.lcx.ccx, unit_ty);\n \n     auto bcx = cx;\n     auto unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n     auto sub = trans_upcall(bcx, \"upcall_new_port\", vec(unit_sz.val));\n     bcx = sub.bcx;\n-    auto llty = type_of(cx.fcx.ccx, t);\n+    auto llty = type_of(cx.fcx.lcx.ccx, t);\n     auto port_val = vi2p(bcx, sub.val, llty);\n     auto dropref = clean(bind drop_ty(_, port_val, t));\n     find_scope_cx(bcx).cleanups += vec(dropref);\n@@ -5153,8 +5163,8 @@ fn trans_chan(@block_ctxt cx, @ast.expr e, ast.ann ann) -> result {\n     auto sub = trans_upcall(bcx, \"upcall_new_chan\", vec(prt_val));\n     bcx = sub.bcx;\n \n-    auto chan_ty = node_ann_type(bcx.fcx.ccx, ann);\n-    auto chan_llty = type_of(bcx.fcx.ccx, chan_ty);\n+    auto chan_ty = node_ann_type(bcx.fcx.lcx.ccx, ann);\n+    auto chan_llty = type_of(bcx.fcx.lcx.ccx, chan_ty);\n     auto chan_val = vi2p(bcx, sub.val, chan_llty);\n     auto dropref = clean(bind drop_ty(_, chan_val, chan_ty));\n     find_scope_cx(bcx).cleanups += vec(dropref);\n@@ -5171,14 +5181,14 @@ fn trans_send(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n     auto data = trans_expr(bcx, rhs);\n     bcx = data.bcx;\n \n-    auto chan_ty = node_ann_type(cx.fcx.ccx, ann);\n+    auto chan_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty;\n     alt (chan_ty.struct) {\n         case (ty.ty_chan(?t)) {\n             unit_ty = t;\n         }\n         case (_) {\n-            bcx.fcx.ccx.sess.bug(\"non-chan type in trans_send\");\n+            bcx.fcx.lcx.ccx.sess.bug(\"non-chan type in trans_send\");\n             fail;\n         }\n     }\n@@ -5206,7 +5216,7 @@ fn trans_recv(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n     auto data = trans_lval(bcx, lhs);\n     check (data.is_mem);\n     bcx = data.res.bcx;\n-    auto unit_ty = node_ann_type(bcx.fcx.ccx, ann);\n+    auto unit_ty = node_ann_type(bcx.fcx.lcx.ccx, ann);\n \n     // FIXME: calculate copy init-ness in typestate.\n     ret recv_val(bcx, data.res.val, rhs, unit_ty, DROP_EXISTING);\n@@ -5238,7 +5248,7 @@ fn init_local(@block_ctxt cx, @ast.local local) -> result {\n     // Make a note to drop this slot on the way out.\n     check (cx.fcx.lllocals.contains_key(local.id));\n     auto llptr = cx.fcx.lllocals.get(local.id);\n-    auto ty = node_ann_type(cx.fcx.ccx, local.ann);\n+    auto ty = node_ann_type(cx.fcx.lcx.ccx, local.ann);\n     auto bcx = cx;\n \n     find_scope_cx(cx).cleanups +=\n@@ -5269,7 +5279,7 @@ fn zero_alloca(@block_ctxt cx, ValueRef llptr, @ty.t t) -> result {\n         auto llsz = size_of(bcx, t);\n         bcx = call_bzero(llsz.bcx, llptr, llsz.val).bcx;\n     } else {\n-        auto llty = type_of(bcx.fcx.ccx, t);\n+        auto llty = type_of(bcx.fcx.lcx.ccx, t);\n         auto null = lib.llvm.llvm.LLVMConstNull(llty);\n         bcx.build.Store(null, llptr);\n     }\n@@ -5289,12 +5299,12 @@ fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n                     bcx = init_local(bcx, local).bcx;\n                 }\n                 case (ast.decl_item(?i)) {\n-                    trans_item(cx.fcx.ccx, *i);\n+                    trans_item(cx.fcx.lcx, *i);\n                 }\n             }\n         }\n         case (_) {\n-            cx.fcx.ccx.sess.unimpl(\"stmt variant\");\n+            cx.fcx.lcx.ccx.sess.unimpl(\"stmt variant\");\n         }\n     }\n     ret res(bcx, C_nil());\n@@ -5314,7 +5324,7 @@ fn new_block_ctxt(@fn_ctxt cx, block_parent parent,\n     let vec[cleanup] cleanups = vec();\n     let BasicBlockRef llbb =\n         llvm.LLVMAppendBasicBlock(cx.llfn,\n-                                  _str.buf(cx.ccx.names.next(name)));\n+                                  _str.buf(cx.lcx.ccx.names.next(name)));\n \n     ret @rec(llbb=llbb,\n              build=new_builder(llbb),\n@@ -5409,7 +5419,7 @@ fn alloc_ty(@block_ctxt cx, @ty.t t) -> result {\n         cx.fcx.llallocas = n.bcx.llbb;\n         val = array_alloca(cx, T_i8(), n.val);\n     } else {\n-        val = alloca(cx, type_of(cx.fcx.ccx, t));\n+        val = alloca(cx, type_of(cx.fcx.lcx.ccx, t));\n     }\n     // NB: since we've pushed all size calculations in this\n     // function up to the alloca block, we actually return the\n@@ -5421,7 +5431,7 @@ fn alloc_ty(@block_ctxt cx, @ty.t t) -> result {\n }\n \n fn alloc_local(@block_ctxt cx, @ast.local local) -> result {\n-    auto t = node_ann_type(cx.fcx.ccx, local.ann);\n+    auto t = node_ann_type(cx.fcx.lcx.ccx, local.ann);\n     auto r = alloc_ty(cx, t);\n     r.bcx.fcx.lllocals.insert(local.id, r.val);\n     ret r;\n@@ -5508,7 +5518,7 @@ fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n //  - new_fn_ctxt\n //  - trans_args\n \n-fn new_fn_ctxt(@crate_ctxt cx,\n+fn new_fn_ctxt(@local_ctxt cx,\n                ValueRef llfndecl) -> @fn_ctxt {\n \n     let ValueRef llretptr = llvm.LLVMGetParam(llfndecl, 0u);\n@@ -5535,7 +5545,7 @@ fn new_fn_ctxt(@crate_ctxt cx,\n              lllocals=lllocals,\n              llupvars=llupvars,\n              mutable lltydescs=_vec.empty[ValueRef](),\n-             ccx=cx);\n+             lcx=cx);\n }\n \n // NB: must keep 4 fns in sync:\n@@ -5620,7 +5630,7 @@ fn copy_args_to_allocas(@fn_ctxt fcx,\n \n     for (ast.arg aarg in args) {\n         if (aarg.mode != ast.alias) {\n-            auto arg_t = type_of_arg(fcx.ccx, arg_tys.(arg_n));\n+            auto arg_t = type_of_arg(fcx.lcx, arg_tys.(arg_n));\n             auto a = alloca(bcx, arg_t);\n             auto argval = fcx.llargs.get(aarg.id);\n             bcx.build.Store(argval, a);\n@@ -5667,16 +5677,16 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n \n     let vec[@ty.t] field_tys = vec();\n \n-    for (ast.obj_field f in bcx.fcx.ccx.obj_fields) {\n-        field_tys += vec(node_ann_type(bcx.fcx.ccx, f.ann));\n+    for (ast.obj_field f in bcx.fcx.lcx.obj_fields) {\n+        field_tys += vec(node_ann_type(bcx.fcx.lcx.ccx, f.ann));\n     }\n \n     // Synthesize a tuple type for the fields so that GEP_tup_like() can work\n     // its magic.\n     auto fields_tup_ty = ty.plain_tup_ty(field_tys);\n \n-    auto n_typarams = _vec.len[ast.ty_param](bcx.fcx.ccx.obj_typarams);\n-    let TypeRef llobj_box_ty = T_obj_ptr(bcx.fcx.ccx.tn, n_typarams);\n+    auto n_typarams = _vec.len[ast.ty_param](bcx.fcx.lcx.obj_typarams);\n+    let TypeRef llobj_box_ty = T_obj_ptr(bcx.fcx.lcx.ccx.tn, n_typarams);\n \n     auto box_cell =\n         bcx.build.GEP(llself.v,\n@@ -5701,7 +5711,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n     // fields pointer to the appropriate LLVM type. If not, just leave it as\n     // i8 *.\n     if (!ty.type_has_dynamic_size(fields_tup_ty)) {\n-        auto llfields_ty = type_of(fcx.ccx, fields_tup_ty);\n+        auto llfields_ty = type_of(fcx.lcx.ccx, fields_tup_ty);\n         obj_fields = vi2p(bcx, obj_fields, T_ptr(llfields_ty));\n     } else {\n         obj_fields = vi2p(bcx, obj_fields, T_ptr(T_i8()));\n@@ -5710,7 +5720,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n \n     let int i = 0;\n \n-    for (ast.ty_param p in fcx.ccx.obj_typarams) {\n+    for (ast.ty_param p in fcx.lcx.obj_typarams) {\n         let ValueRef lltyparam = bcx.build.GEP(obj_typarams,\n                                                vec(C_int(0),\n                                                    C_int(i)));\n@@ -5720,7 +5730,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n     }\n \n     i = 0;\n-    for (ast.obj_field f in fcx.ccx.obj_fields) {\n+    for (ast.obj_field f in fcx.lcx.obj_fields) {\n         auto rslt = GEP_tup_like(bcx, fields_tup_ty, obj_fields, vec(0, i));\n         bcx = llallocas_block_ctxt(fcx);\n         auto llfield = rslt.val;\n@@ -5731,11 +5741,11 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n     fcx.llallocas = bcx.llbb;\n }\n \n-fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n+fn trans_fn(@local_ctxt cx, &ast._fn f, ast.def_id fid,\n             option.t[tup(TypeRef, @ty.t)] ty_self,\n             &vec[ast.ty_param] ty_params, &ast.ann ann) {\n \n-    auto llfndecl = cx.item_ids.get(fid);\n+    auto llfndecl = cx.ccx.item_ids.get(fid);\n \n     auto fcx = new_fn_ctxt(cx, llfndecl);\n     create_llargs_for_fn_args(fcx, f.proto,\n@@ -5768,7 +5778,7 @@ fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n     new_builder(fcx.llallocas).Br(lltop);\n }\n \n-fn trans_vtbl(@crate_ctxt cx, \n+fn trans_vtbl(@local_ctxt cx, \n               TypeRef llself_ty,\n               @ty.t self_ty,\n               &ast._obj ob,\n@@ -5785,20 +5795,21 @@ fn trans_vtbl(@crate_ctxt cx,\n     for (@ast.method m in meths) {\n \n         auto llfnty = T_nil();\n-        alt (node_ann_type(cx, m.node.ann).struct) {\n+        alt (node_ann_type(cx.ccx, m.node.ann).struct) {\n             case (ty.ty_fn(?proto, ?inputs, ?output)) {\n-                llfnty = type_of_fn_full(cx, proto,\n+                llfnty = type_of_fn_full(cx.ccx, proto,\n                                          some[TypeRef](llself_ty),\n                                          inputs, output,\n                                          _vec.len[ast.ty_param](ty_params));\n             }\n         }\n \n-        let @crate_ctxt mcx = extend_path(cx, m.node.ident);\n+        let @local_ctxt mcx = extend_path(cx, m.node.ident);\n         let str s = mangle_name_by_seq(mcx, \"method\");\n-        let ValueRef llfn = decl_internal_fastcall_fn(cx.llmod, s, llfnty);\n-        cx.item_ids.insert(m.node.id, llfn);\n-        cx.item_symbols.insert(m.node.id, s);\n+        let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s,\n+                                                      llfnty);\n+        cx.ccx.item_ids.insert(m.node.id, llfn);\n+        cx.ccx.item_symbols.insert(m.node.id, s);\n \n         trans_fn(mcx, m.node.meth, m.node.id, \n                  some[tup(TypeRef, @ty.t)](tup(llself_ty, self_ty)),\n@@ -5807,7 +5818,7 @@ fn trans_vtbl(@crate_ctxt cx,\n     }\n     auto vtbl = C_struct(methods);\n     auto vtbl_name = mangle_name_by_seq(cx, \"vtbl\");\n-    auto gvar = llvm.LLVMAddGlobal(cx.llmod, val_ty(vtbl),\n+    auto gvar = llvm.LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl),\n                                    _str.buf(vtbl_name));\n     llvm.LLVMSetInitializer(gvar, vtbl);\n     llvm.LLVMSetGlobalConstant(gvar, True);\n@@ -5816,27 +5827,27 @@ fn trans_vtbl(@crate_ctxt cx,\n     ret gvar;\n }\n \n-fn trans_dtor(@crate_ctxt cx,\n+fn trans_dtor(@local_ctxt cx,\n               TypeRef llself_ty,\n               @ty.t self_ty,\n               &vec[ast.ty_param] ty_params,\n               &@ast.method dtor) -> ValueRef {\n \n     auto llfnty = T_nil();\n-    alt (node_ann_type(cx, dtor.node.ann).struct) {\n+    alt (node_ann_type(cx.ccx, dtor.node.ann).struct) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n-            llfnty = type_of_fn_full(cx, proto,\n+            llfnty = type_of_fn_full(cx.ccx, proto,\n                                      some[TypeRef](llself_ty),\n                                      inputs, output,\n                                      _vec.len[ast.ty_param](ty_params));\n         }\n     }\n \n-    let @crate_ctxt dcx = extend_path(cx, \"drop\");\n+    let @local_ctxt dcx = extend_path(cx, \"drop\");\n     let str s = mangle_name_by_seq(dcx, \"drop\");\n-    let ValueRef llfn = decl_internal_fastcall_fn(cx.llmod, s, llfnty);\n-    cx.item_ids.insert(dtor.node.id, llfn);\n-    cx.item_symbols.insert(dtor.node.id, s);\n+    let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n+    cx.ccx.item_ids.insert(dtor.node.id, llfn);\n+    cx.ccx.item_symbols.insert(dtor.node.id, s);\n \n     trans_fn(dcx, dtor.node.meth, dtor.node.id,\n              some[tup(TypeRef, @ty.t)](tup(llself_ty, self_ty)),\n@@ -5845,10 +5856,10 @@ fn trans_dtor(@crate_ctxt cx,\n     ret llfn;\n }\n \n-fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n+fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n              &vec[ast.ty_param] ty_params, &ast.ann ann) {\n-\n-    auto llctor_decl = cx.item_ids.get(oid);\n+    auto ccx = cx.ccx;\n+    auto llctor_decl = ccx.item_ids.get(oid);\n \n     // Translate obj ctor args to function arguments.\n     let vec[ast.arg] fn_args = vec();\n@@ -5872,7 +5883,7 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n     auto lltop = bcx.llbb;\n \n     auto self_ty = ret_ty_of_fn(ann);\n-    auto llself_ty = type_of(cx, self_ty);\n+    auto llself_ty = type_of(ccx, self_ty);\n     auto pair = bcx.fcx.llretptr;\n     auto vtbl = trans_vtbl(cx, llself_ty, self_ty, ob, ty_params);\n     auto pair_vtbl = bcx.build.GEP(pair,\n@@ -5883,7 +5894,7 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n                                       C_int(abi.obj_field_box)));\n     bcx.build.Store(vtbl, pair_vtbl);\n \n-    let TypeRef llbox_ty = T_opaque_obj_ptr(cx.tn);\n+    let TypeRef llbox_ty = T_opaque_obj_ptr(ccx.tn);\n \n     if (_vec.len[ast.ty_param](ty_params) == 0u &&\n         _vec.len[ty.arg](arg_tys) == 0u) {\n@@ -5927,7 +5938,7 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n                          vec(0, abi.obj_body_elt_tydesc));\n         bcx = body_tydesc.bcx;\n \n-        auto dtor = C_null(T_ptr(T_glue_fn(cx.tn)));\n+        auto dtor = C_null(T_ptr(T_glue_fn(ccx.tn)));\n         alt (ob.dtor) {\n             case (some[@ast.method](?d)) {\n                 dtor = trans_dtor(cx, llself_ty, self_ty, ty_params, d);\n@@ -5980,7 +5991,7 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n     new_builder(fcx.llallocas).Br(lltop);\n }\n \n-fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n+fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n                      &ast.variant variant, int index,\n                      &vec[ast.ty_param] ty_params) {\n     if (_vec.len[ast.variant_arg](variant.node.args) == 0u) {\n@@ -5997,8 +6008,8 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n                            id=varg.id));\n     }\n \n-    check (cx.item_ids.contains_key(variant.node.id));\n-    let ValueRef llfndecl = cx.item_ids.get(variant.node.id);\n+    check (cx.ccx.item_ids.contains_key(variant.node.id));\n+    let ValueRef llfndecl = cx.ccx.item_ids.get(variant.node.id);\n \n     auto fcx = new_fn_ctxt(cx, llfndecl);\n \n@@ -6022,7 +6033,7 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n \n     // Cast the tag to a type we can GEP into.\n     auto lltagptr = bcx.build.PointerCast(fcx.llretptr,\n-                                          T_opaque_tag_ptr(fcx.ccx.tn));\n+                                          T_opaque_tag_ptr(fcx.lcx.ccx.tn));\n \n     auto lldiscrimptr = bcx.build.GEP(lltagptr,\n                                       vec(C_int(0), C_int(0)));\n@@ -6090,7 +6101,7 @@ fn trans_const(@crate_ctxt cx, @ast.expr e,\n     llvm.LLVMSetGlobalConstant(g, True);\n }\n \n-fn trans_item(@crate_ctxt cx, &ast.item item) {\n+fn trans_item(@local_ctxt cx, &ast.item item) {\n     alt (item.node) {\n         case (ast.item_fn(?name, ?f, ?tps, ?fid, ?ann)) {\n             auto sub_cx = extend_path(cx, name);\n@@ -6115,14 +6126,13 @@ fn trans_item(@crate_ctxt cx, &ast.item item) {\n             }\n         }\n         case (ast.item_const(?name, _, ?expr, ?cid, ?ann)) {\n-            auto sub_cx = extend_path(cx, name);\n-            trans_const(sub_cx, expr, cid, ann);\n+            trans_const(cx.ccx, expr, cid, ann);\n         }\n         case (_) { /* fall through */ }\n     }\n }\n \n-fn trans_mod(@crate_ctxt cx, &ast._mod m) {\n+fn trans_mod(@local_ctxt cx, &ast._mod m) {\n     for (@ast.item item in m.items) {\n         trans_item(cx, *item);\n     }\n@@ -6136,34 +6146,35 @@ fn get_pair_fn_ty(TypeRef llpairty) -> TypeRef {\n     ret llvm.LLVMGetElementType(pair_tys.(0));\n }\n \n-fn decl_fn_and_pair(@crate_ctxt cx,\n+fn decl_fn_and_pair(@local_ctxt cx,\n                     str flav,\n                     vec[ast.ty_param] ty_params,\n                     &ast.ann ann,\n                     ast.def_id id) {\n \n     auto llfty;\n     auto llpairty;\n-    alt (node_ann_type(cx, ann).struct) {\n+    auto ccx = cx.ccx;\n+    alt (node_ann_type(ccx, ann).struct) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n-            llfty = type_of_fn(cx, proto, inputs, output,\n+            llfty = type_of_fn(ccx, proto, inputs, output,\n                                _vec.len[ast.ty_param](ty_params));\n-            llpairty = T_fn_pair(cx.tn, llfty);\n+            llpairty = T_fn_pair(ccx.tn, llfty);\n         }\n         case (_) {\n-            cx.sess.bug(\"decl_fn_and_pair(): fn item doesn't have fn type?!\");\n+            ccx.sess.bug(\"decl_fn_and_pair(): fn item doesn't have fn type!\");\n             fail;\n         }\n     }\n \n     // Declare the function itself.\n     let str s = mangle_name_by_seq(cx, flav);\n-    let ValueRef llfn = decl_internal_fastcall_fn(cx.llmod, s, llfty);\n+    let ValueRef llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfty);\n \n     // Declare the global constant pair that points to it.\n-    let str ps = mangle_name_by_type(cx, node_ann_type(cx, ann));\n+    let str ps = mangle_name_by_type(cx, node_ann_type(ccx, ann));\n \n-    register_fn_pair(cx, ps, llpairty, llfn, id);\n+    register_fn_pair(ccx, ps, llpairty, llfn, id);\n }\n \n fn register_fn_pair(@crate_ctxt cx, str ps, TypeRef llpairty, ValueRef llfn,\n@@ -6211,36 +6222,37 @@ fn native_fn_wrapper_type(@crate_ctxt cx, uint ty_param_count, @ty.t x)\n     fail;\n }\n \n-fn decl_native_fn_and_pair(@crate_ctxt cx,\n+fn decl_native_fn_and_pair(@local_ctxt cx,\n                            str name,\n                            &ast.ann ann,\n                            ast.def_id id) {\n-    auto num_ty_param = native_fn_ty_param_count(cx, id);\n+    auto num_ty_param = native_fn_ty_param_count(cx.ccx, id);\n+    auto ccx = cx.ccx;\n \n     // Declare the wrapper.\n-    auto t = node_ann_type(cx, ann);\n-    auto wrapper_type = native_fn_wrapper_type(cx, num_ty_param, t);\n+    auto t = node_ann_type(ccx, ann);\n+    auto wrapper_type = native_fn_wrapper_type(ccx, num_ty_param, t);\n     let str s = mangle_name_by_seq(cx, \"wrapper\");\n-    let ValueRef wrapper_fn = decl_internal_fastcall_fn(cx.llmod, s,\n-                                                       wrapper_type);\n+    let ValueRef wrapper_fn = decl_internal_fastcall_fn(ccx.llmod, s,\n+                                                        wrapper_type);\n \n     // Declare the global constant pair that points to it.\n-    auto wrapper_pair_type = T_fn_pair(cx.tn, wrapper_type);\n-    let str ps = mangle_name_by_type(cx, node_ann_type(cx, ann));\n+    auto wrapper_pair_type = T_fn_pair(ccx.tn, wrapper_type);\n+    let str ps = mangle_name_by_type(cx, node_ann_type(ccx, ann));\n \n-    register_fn_pair(cx, ps, wrapper_pair_type, wrapper_fn, id);\n+    register_fn_pair(ccx, ps, wrapper_pair_type, wrapper_fn, id);\n \n     // Build the wrapper.\n     auto fcx = new_fn_ctxt(cx, wrapper_fn);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n     // Declare the function itself.\n-    auto item = cx.native_items.get(id);\n-    auto fn_type = node_ann_type(cx, ann);  // NB: has no type params\n+    auto item = ccx.native_items.get(id);\n+    auto fn_type = node_ann_type(ccx, ann);  // NB: has no type params\n \n     auto abi = ty.ty_fn_abi(fn_type);\n-    auto llfnty = type_of_native_fn(cx, abi, ty.ty_fn_args(fn_type),\n+    auto llfnty = type_of_native_fn(ccx, abi, ty.ty_fn_args(fn_type),\n                                     ty.ty_fn_ret(fn_type), num_ty_param);\n \n     let vec[ValueRef] call_args = vec();\n@@ -6274,7 +6286,7 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n                 @ty.t t) {\n         if (ty.type_is_integral(t)) {\n             auto lldsttype = T_int();\n-            auto llsrctype = type_of(cx.fcx.ccx, t);\n+            auto llsrctype = type_of(cx.fcx.lcx.ccx, t);\n             if (llvm.LLVMGetIntTypeWidth(lldsttype) >\n                 llvm.LLVMGetIntTypeWidth(llsrctype)) {\n                 args += vec(cx.build.ZExtOrBitCast(v, T_int()));\n@@ -6302,8 +6314,8 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n             i += 1u;\n         }\n         auto llnativefnty = T_fn(call_arg_tys,\n-                                 type_of(cx, ty.ty_fn_ret(fn_type)));\n-        auto llnativefn = get_extern_fn(cx.externs, cx.llmod, name,\n+                                 type_of(ccx, ty.ty_fn_ret(fn_type)));\n+        auto llnativefn = get_extern_fn(ccx.externs, ccx.llmod, name,\n                                         lib.llvm.LLVMCCallConv, llnativefnty);\n         r = bcx.build.Call(llnativefn, call_args);\n         rptr = fcx.llretptr;\n@@ -6315,8 +6327,8 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n             arg_n += 1u;\n         }\n \n-        r = trans_native_call(bcx.build, cx.glues, lltaskptr, cx.externs,\n-                              cx.tn, cx.llmod, name, pass_task, call_args);\n+        r = trans_native_call(bcx.build, ccx.glues, lltaskptr, ccx.externs,\n+                              ccx.tn, ccx.llmod, name, pass_task, call_args);\n         rptr = bcx.build.BitCast(fcx.llretptr, T_ptr(T_i32()));\n     }\n \n@@ -6327,16 +6339,16 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n     new_builder(fcx.llallocas).Br(lltop);\n }\n \n-fn collect_native_item(&@crate_ctxt cx, @ast.native_item i) -> @crate_ctxt {\n+fn collect_native_item(&@local_ctxt cx, @ast.native_item i) -> @local_ctxt {\n     alt (i.node) {\n         case (ast.native_item_fn(?name, _, _, _, ?fid, ?ann)) {\n-            cx.native_items.insert(fid, i);\n-            if (! cx.obj_methods.contains_key(fid)) {\n+            cx.ccx.native_items.insert(fid, i);\n+            if (!cx.ccx.obj_methods.contains_key(fid)) {\n                 decl_native_fn_and_pair(cx, name, ann, fid);\n             }\n         }\n         case (ast.native_item_ty(_, ?tid)) {\n-            cx.native_items.insert(tid, i);\n+            cx.ccx.native_items.insert(tid, i);\n         }\n     }\n     ret cx;\n@@ -6368,36 +6380,37 @@ fn item_name(@ast.item i) -> str {\n     }\n }\n \n-fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n+fn collect_item(&@local_ctxt cx, @ast.item i) -> @local_ctxt {\n+    auto ccx = cx.ccx;\n     alt (i.node) {\n         case (ast.item_const(?name, _, _, ?cid, ?ann)) {\n-            auto typ = node_ann_type(cx, ann);\n-            auto g = llvm.LLVMAddGlobal(cx.llmod, type_of(cx, typ),\n-                                        _str.buf(cx.names.next(name)));\n+            auto typ = node_ann_type(ccx, ann);\n+            auto g = llvm.LLVMAddGlobal(ccx.llmod, type_of(ccx, typ),\n+                                        _str.buf(ccx.names.next(name)));\n             llvm.LLVMSetLinkage(g, lib.llvm.LLVMInternalLinkage\n                                 as llvm.Linkage);\n-            cx.items.insert(cid, i);\n-            cx.consts.insert(cid, g);\n+            ccx.items.insert(cid, i);\n+            ccx.consts.insert(cid, g);\n         }\n \n         case (ast.item_fn(_, _, _, ?did, _)) {\n             // handled below\n         }\n \n         case (ast.item_mod(?name, ?m, ?mid)) {\n-            cx.items.insert(mid, i);\n+            ccx.items.insert(mid, i);\n         }\n \n         case (ast.item_native_mod(_, _, _)) {\n             // empty\n         }\n \n         case (ast.item_ty(_, _, _, ?did, _)) {\n-            cx.items.insert(did, i);\n+            ccx.items.insert(did, i);\n         }\n \n         case (ast.item_tag(?name, ?variants, ?tps, ?tag_id, _)) {\n-            cx.items.insert(tag_id, i);\n+            ccx.items.insert(tag_id, i);\n         }\n \n         case (ast.item_obj(_, _, _, ?did, _)) {\n@@ -6407,22 +6420,22 @@ fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n     ret extend_path(cx, item_name(i));\n }\n \n-fn collect_item_pass2(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n+fn collect_item_pass2(&@local_ctxt cx, @ast.item i) -> @local_ctxt {\n     alt (i.node) {\n         case (ast.item_fn(?name, ?f, ?tps, ?fid, ?ann)) {\n-            cx.items.insert(fid, i);\n-            if (! cx.obj_methods.contains_key(fid)) {\n+            cx.ccx.items.insert(fid, i);\n+            if (!cx.ccx.obj_methods.contains_key(fid)) {\n                 decl_fn_and_pair(extend_path(cx, name), \"fn\",\n                                  tps, ann, fid);\n             }\n         }\n \n         case (ast.item_obj(?name, ?ob, ?tps, ?oid, ?ann)) {\n-            cx.items.insert(oid.ctor, i);\n+            cx.ccx.items.insert(oid.ctor, i);\n             decl_fn_and_pair(extend_path(cx, name), \"obj_ctor\",\n                              tps, ann, oid.ctor);\n             for (@ast.method m in ob.methods) {\n-                cx.obj_methods.insert(m.node.id, ());\n+                cx.ccx.obj_methods.insert(m.node.id, ());\n             }\n         }\n \n@@ -6432,10 +6445,10 @@ fn collect_item_pass2(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n }\n \n \n-fn collect_items(@crate_ctxt cx, @ast.crate crate) {\n+fn collect_items(@local_ctxt cx, @ast.crate crate) {\n \n-    let fold.ast_fold[@crate_ctxt] fld =\n-        fold.new_identity_fold[@crate_ctxt]();\n+    let fold.ast_fold[@local_ctxt] fld =\n+        fold.new_identity_fold[@local_ctxt]();\n \n     // FIXME: It might be better to use a worklist for this. An item\n     // would be added to it if it depends on a not yet seen tag for example.\n@@ -6445,15 +6458,15 @@ fn collect_items(@crate_ctxt cx, @ast.crate crate) {\n               update_env_for_native_item = bind collect_native_item(_,_)\n               with *fld );\n \n-    fold.fold_crate[@crate_ctxt](cx, fld1, crate);\n+    fold.fold_crate[@local_ctxt](cx, fld1, crate);\n \n     auto fld2 = @rec( update_env_for_item = bind collect_item_pass2(_,_)\n                       with *fld );\n \n-    fold.fold_crate[@crate_ctxt](cx, fld2, crate);\n+    fold.fold_crate[@local_ctxt](cx, fld2, crate);\n }\n \n-fn collect_tag_ctor(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n+fn collect_tag_ctor(&@local_ctxt cx, @ast.item i) -> @local_ctxt {\n \n     alt (i.node) {\n \n@@ -6472,20 +6485,20 @@ fn collect_tag_ctor(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n     ret cx;\n }\n \n-fn collect_tag_ctors(@crate_ctxt cx, @ast.crate crate) {\n+fn collect_tag_ctors(@local_ctxt cx, @ast.crate crate) {\n \n-    let fold.ast_fold[@crate_ctxt] fld =\n-        fold.new_identity_fold[@crate_ctxt]();\n+    let fold.ast_fold[@local_ctxt] fld =\n+        fold.new_identity_fold[@local_ctxt]();\n \n     fld = @rec( update_env_for_item = bind collect_tag_ctor(_,_)\n                 with *fld );\n \n-    fold.fold_crate[@crate_ctxt](cx, fld, crate);\n+    fold.fold_crate[@local_ctxt](cx, fld, crate);\n }\n \n // The constant translation pass.\n \n-fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n+fn trans_constant(&@local_ctxt cx, @ast.item it) -> @local_ctxt {\n     alt (it.node) {\n         case (ast.item_tag(?ident, ?variants, _, ?tag_id, _)) {\n             auto i = 0u;\n@@ -6498,14 +6511,14 @@ fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n                 auto s = mangle_name_by_seq(cx,\n                                             #fmt(\"_rust_tag_discrim_%s_%u\",\n                                                  ident, i));\n-                auto discrim_gvar = llvm.LLVMAddGlobal(cx.llmod, T_int(),\n+                auto discrim_gvar = llvm.LLVMAddGlobal(cx.ccx.llmod, T_int(),\n                                                        _str.buf(s));\n \n                 llvm.LLVMSetInitializer(discrim_gvar, discrim_val);\n                 llvm.LLVMSetGlobalConstant(discrim_gvar, True);\n \n-                cx.discrims.insert(variant.node.id, discrim_gvar);\n-                cx.discrim_symbols.insert(variant.node.id, s);\n+                cx.ccx.discrims.insert(variant.node.id, discrim_gvar);\n+                cx.ccx.discrim_symbols.insert(variant.node.id, s);\n \n                 i += 1u;\n             }\n@@ -6515,10 +6528,10 @@ fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n             // FIXME: The whole expr-translation system needs cloning to deal\n             // with consts.\n             auto v = C_int(1);\n-            cx.item_ids.insert(cid, v);\n+            cx.ccx.item_ids.insert(cid, v);\n             auto s = mangle_name_by_type(extend_path(cx, name),\n-                                         node_ann_type(cx, ann));\n-            cx.item_symbols.insert(cid, s);\n+                                         node_ann_type(cx.ccx, ann));\n+            cx.ccx.item_symbols.insert(cid, s);\n         }\n \n         case (_) {\n@@ -6529,13 +6542,13 @@ fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n     ret cx;\n }\n \n-fn trans_constants(@crate_ctxt cx, @ast.crate crate) {\n-    let fold.ast_fold[@crate_ctxt] fld =\n-        fold.new_identity_fold[@crate_ctxt]();\n+fn trans_constants(@local_ctxt cx, @ast.crate crate) {\n+    let fold.ast_fold[@local_ctxt] fld =\n+        fold.new_identity_fold[@local_ctxt]();\n \n     fld = @rec(update_env_for_item = bind trans_constant(_,_) with *fld);\n \n-    fold.fold_crate[@crate_ctxt](cx, fld, crate);\n+    fold.fold_crate[@local_ctxt](cx, fld, crate);\n }\n \n \n@@ -6638,7 +6651,7 @@ fn find_main_fn(@crate_ctxt cx) -> ValueRef {\n     fail;\n }\n \n-fn trans_main_fn(@crate_ctxt cx, ValueRef llcrate) {\n+fn trans_main_fn(@local_ctxt cx, ValueRef llcrate) {\n     auto T_main_args = vec(T_int(), T_int());\n     auto T_rust_start_args = vec(T_int(), T_int(), T_int(), T_int());\n \n@@ -6650,14 +6663,14 @@ fn trans_main_fn(@crate_ctxt cx, ValueRef llcrate) {\n     }\n \n     auto llmain =\n-        decl_cdecl_fn(cx.llmod, main_name, T_fn(T_main_args, T_int()));\n+        decl_cdecl_fn(cx.ccx.llmod, main_name, T_fn(T_main_args, T_int()));\n \n-    auto llrust_start = decl_cdecl_fn(cx.llmod, \"rust_start\",\n+    auto llrust_start = decl_cdecl_fn(cx.ccx.llmod, \"rust_start\",\n                                       T_fn(T_rust_start_args, T_int()));\n \n     auto llargc = llvm.LLVMGetParam(llmain, 0u);\n     auto llargv = llvm.LLVMGetParam(llmain, 1u);\n-    auto llrust_main = find_main_fn(cx);\n+    auto llrust_main = find_main_fn(cx.ccx);\n \n     //\n     // Emit the moral equivalent of:\n@@ -6689,7 +6702,7 @@ fn declare_intrinsics(ModuleRef llmod) -> hashmap[str,ValueRef] {\n \n \n fn trace_str(@block_ctxt cx, str s) {\n-    trans_upcall(cx, \"upcall_trace_str\", vec(p2i(C_cstr(cx.fcx.ccx, s))));\n+    trans_upcall(cx, \"upcall_trace_str\", vec(p2i(C_cstr(cx.fcx.lcx.ccx, s))));\n }\n \n fn trace_word(@block_ctxt cx, ValueRef v) {\n@@ -6702,7 +6715,7 @@ fn trace_ptr(@block_ctxt cx, ValueRef v) {\n \n fn trap(@block_ctxt bcx) {\n     let vec[ValueRef] v = vec();\n-    bcx.build.Call(bcx.fcx.ccx.intrinsics.get(\"llvm.trap\"), v);\n+    bcx.build.Call(bcx.fcx.lcx.ccx.intrinsics.get(\"llvm.trap\"), v);\n }\n tag output_type {\n     output_type_none;\n@@ -6957,9 +6970,9 @@ fn vec_p1_adjusted(@block_ctxt bcx, ValueRef v,\n     ret bcx.build.GEP(vec_p0(bcx, v), vec(len));\n }\n \n-fn trans_vec_append_glue(@crate_ctxt cx) {\n+fn trans_vec_append_glue(@local_ctxt cx) {\n \n-    auto llfn = cx.glues.vec_append_glue;\n+    auto llfn = cx.ccx.glues.vec_append_glue;\n \n     let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 0u);\n     let ValueRef llvec_tydesc = llvm.LLVMGetParam(llfn, 1u);\n@@ -6983,7 +6996,7 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n                     lllocals=new_def_hash[ValueRef](),\n                     llupvars=new_def_hash[ValueRef](),\n                     mutable lltydescs=_vec.empty[ValueRef](),\n-                    ccx=cx);\n+                    lcx=cx);\n \n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n@@ -7174,45 +7187,47 @@ fn trans_crate(session.session sess, @ast.crate crate,\n     let vec[ast.obj_field] obj_fields = vec();\n \n     let vec[str] pth = vec();\n-    auto cx = @rec(sess = sess,\n-                   llmod = llmod,\n-                   td = td,\n-                   tn = tn,\n-                   crate_ptr = crate_ptr,\n-                   externs = new_str_hash[ValueRef](),\n-                   intrinsics = intrinsics,\n-                   item_ids = new_def_hash[ValueRef](),\n-                   items = new_def_hash[@ast.item](),\n-                   native_items = new_def_hash[@ast.native_item](),\n-                   type_cache = type_cache,\n-                   item_symbols = new_def_hash[str](),\n-                   tag_sizes = tag_sizes,\n-                   discrims = new_def_hash[ValueRef](),\n-                   discrim_symbols = new_def_hash[str](),\n-                   fn_pairs = new_def_hash[ValueRef](),\n-                   consts = new_def_hash[ValueRef](),\n-                   obj_methods = new_def_hash[()](),\n-                   tydescs = tydescs,\n+    auto ccx = @rec(sess = sess,\n+                    llmod = llmod,\n+                    td = td,\n+                    tn = tn,\n+                    crate_ptr = crate_ptr,\n+                    externs = new_str_hash[ValueRef](),\n+                    intrinsics = intrinsics,\n+                    item_ids = new_def_hash[ValueRef](),\n+                    items = new_def_hash[@ast.item](),\n+                    native_items = new_def_hash[@ast.native_item](),\n+                    type_cache = type_cache,\n+                    item_symbols = new_def_hash[str](),\n+                    tag_sizes = tag_sizes,\n+                    discrims = new_def_hash[ValueRef](),\n+                    discrim_symbols = new_def_hash[str](),\n+                    fn_pairs = new_def_hash[ValueRef](),\n+                    consts = new_def_hash[ValueRef](),\n+                    obj_methods = new_def_hash[()](),\n+                    tydescs = tydescs,\n+                    glues = glues,\n+                    names = namegen(0),\n+                    path = pth,\n+                    sha = std.sha1.mk_sha1());\n+    auto cx = @rec(path=pth,\n                    obj_typarams = obj_typarams,\n                    obj_fields = obj_fields,\n-                   glues = glues,\n-                   names = namegen(0),\n-                   path = pth,\n-                   sha = std.sha1.mk_sha1());\n+                   ccx = ccx);\n \n-    create_typedefs(cx);\n+    create_typedefs(cx.ccx);\n \n     collect_items(cx, crate);\n     collect_tag_ctors(cx, crate);\n     trans_constants(cx, crate);\n     trans_mod(cx, crate.node.module);\n     trans_vec_append_glue(cx);\n     if (!shared) {\n-        trans_main_fn(cx, cx.crate_ptr);\n+        trans_main_fn(cx, cx.ccx.crate_ptr);\n     }\n \n     // Translate the metadata.\n-    middle.metadata.write_metadata(cx, crate);\n+    middle.metadata.write_metadata(cx.ccx, crate);\n \n     run_passes(llmod, optimize, output, ot);\n }"}]}