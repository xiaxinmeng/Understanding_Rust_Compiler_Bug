{"sha": "49763c3cdb8dc8993f672eacabb9aa684103a657", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5NzYzYzNjZGI4ZGM4OTkzZjY3MmVhY2FiYjlhYTY4NDEwM2E2NTc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-26T00:39:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-26T00:39:00Z"}, "message": "Merge #10029\n\n10029: internal: Improve expand_macro r=Veykril a=Veykril\n\n- Adds a few more newlines to the output making it more readable\r\n- Fixes a bug with multiple derives not being expandable\r\n\r\nThere seems to be an issue with multiple derives in one attribute only showing the expansion of the last derive which I'll have to investigate.\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "0ca6f41f43cfcc895e19d75b0483c12d2da7592f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ca6f41f43cfcc895e19d75b0483c12d2da7592f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49763c3cdb8dc8993f672eacabb9aa684103a657", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhJuKkCRBK7hj4Ov3rIwAAP6kIAHRZ9tpOL4QE/Bcb7ZqZhgQQ\n8HGTWNiKn2ipnYPu9Cxs86IexL26AZlJ4dUke72/4u7Y7uZj4aEiozPCM31/rGrp\n+svGDNQLaYu+maZ5PD7iOpaGDo3JPpNEqABVQolKARWsYGB58W7oJ3z8BGNwWq9q\nUxwlJYHyDCRmfDI2Yjprare7eNRCoPV4dFN0PlJ23LaDTD+qZnMdHcpZ/YpgEf3l\nUqHp1P/Z3eDAx0Bh80kdiD8mrkIwxzD8GoepsPg5X1KI68ukQQr1dS/bauG7oU+Q\n72j+SYOgT+m2FCAQZjVDpt1KXoX+BCmBByLqk0gLFQ1lxRlqA98hhWhGQeY/0JE=\n=GXhe\n-----END PGP SIGNATURE-----\n", "payload": "tree 0ca6f41f43cfcc895e19d75b0483c12d2da7592f\nparent cbbb7f351f1b6297f0da91ea12d323051e71380c\nparent 3f9f63c1bdc388d48d8b75315029e9d426069122\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1629938340 +0000\ncommitter GitHub <noreply@github.com> 1629938340 +0000\n\nMerge #10029\n\n10029: internal: Improve expand_macro r=Veykril a=Veykril\n\n- Adds a few more newlines to the output making it more readable\r\n- Fixes a bug with multiple derives not being expandable\r\n\r\nThere seems to be an issue with multiple derives in one attribute only showing the expansion of the last derive which I'll have to investigate.\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49763c3cdb8dc8993f672eacabb9aa684103a657", "html_url": "https://github.com/rust-lang/rust/commit/49763c3cdb8dc8993f672eacabb9aa684103a657", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49763c3cdb8dc8993f672eacabb9aa684103a657/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbbb7f351f1b6297f0da91ea12d323051e71380c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbbb7f351f1b6297f0da91ea12d323051e71380c", "html_url": "https://github.com/rust-lang/rust/commit/cbbb7f351f1b6297f0da91ea12d323051e71380c"}, {"sha": "3f9f63c1bdc388d48d8b75315029e9d426069122", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f9f63c1bdc388d48d8b75315029e9d426069122", "html_url": "https://github.com/rust-lang/rust/commit/3f9f63c1bdc388d48d8b75315029e9d426069122"}], "stats": {"total": 99, "additions": 63, "deletions": 36}, "files": [{"sha": "9f543b79b56d3f05875783429a40daeadabb47cb", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/49763c3cdb8dc8993f672eacabb9aa684103a657/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49763c3cdb8dc8993f672eacabb9aa684103a657/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=49763c3cdb8dc8993f672eacabb9aa684103a657", "patch": "@@ -8,6 +8,7 @@ use hir_expand::{name::Name, AstId, MacroCallId, MacroDefKind};\n use once_cell::sync::Lazy;\n use profile::Count;\n use rustc_hash::{FxHashMap, FxHashSet};\n+use smallvec::SmallVec;\n use stdx::format_to;\n use syntax::ast;\n \n@@ -61,7 +62,7 @@ pub struct ItemScope {\n     // be all resolved to the last one defined if shadowing happens.\n     legacy_macros: FxHashMap<Name, MacroDefId>,\n     attr_macros: FxHashMap<AstId<ast::Item>, MacroCallId>,\n-    derive_macros: FxHashMap<AstId<ast::Item>, (AttrId, MacroCallId)>,\n+    derive_macros: FxHashMap<AstId<ast::Item>, SmallVec<[(AttrId, MacroCallId); 1]>>,\n }\n \n pub(crate) static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n@@ -189,13 +190,13 @@ impl ItemScope {\n         call: MacroCallId,\n         attr_id: AttrId,\n     ) {\n-        self.derive_macros.insert(item, (attr_id, call));\n+        self.derive_macros.entry(item).or_default().push((attr_id, call));\n     }\n \n     pub(crate) fn derive_macro_invocs(\n         &self,\n     ) -> impl Iterator<Item = (AstId<ast::Item>, (AttrId, MacroCallId))> + '_ {\n-        self.derive_macros.iter().map(|(k, v)| (*k, *v))\n+        self.derive_macros.iter().flat_map(|(k, v)| v.iter().map(move |v| (*k, *v)))\n     }\n \n     pub(crate) fn unnamed_trait_vis(&self, tr: TraitId) -> Option<Visibility> {"}, {"sha": "889b3748adc8fc41e1e819954332fb04f97a33b4", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/49763c3cdb8dc8993f672eacabb9aa684103a657/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49763c3cdb8dc8993f672eacabb9aa684103a657/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=49763c3cdb8dc8993f672eacabb9aa684103a657", "patch": "@@ -3,7 +3,7 @@ use std::iter;\n use hir::Semantics;\n use ide_db::{helpers::pick_best_token, RootDatabase};\n use itertools::Itertools;\n-use syntax::{ast, ted, AstNode, NodeOrToken, SyntaxKind, SyntaxKind::*, SyntaxNode, WalkEvent, T};\n+use syntax::{ast, ted, AstNode, NodeOrToken, SyntaxKind, SyntaxNode, WalkEvent, T};\n \n use crate::FilePosition;\n \n@@ -31,29 +31,29 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n         SyntaxKind::IDENT => 1,\n         _ => 0,\n     })?;\n+    let descended = sema.descend_into_macros(tok.clone());\n+    if let Some(attr) = descended.ancestors().find_map(ast::Attr::cast) {\n+        if let Some((path, tt)) = attr.as_simple_call() {\n+            if path == \"derive\" {\n+                let mut tt = tt.syntax().children_with_tokens().skip(1).join(\"\");\n+                tt.pop();\n+                return sema\n+                    .expand_derive_macro(&attr)\n+                    .map(insert_whitespaces)\n+                    .map(|expansion| ExpandedMacro { name: tt, expansion });\n+            }\n+        }\n+    }\n     let mut expanded = None;\n     let mut name = None;\n     for node in tok.ancestors() {\n-        if let Some(attr) = ast::Attr::cast(node.clone()) {\n-            if let Some((path, tt)) = attr.as_simple_call() {\n-                if path == \"derive\" {\n-                    let mut tt = tt.syntax().children_with_tokens().skip(1).join(\"\");\n-                    tt.pop();\n-                    name = Some(tt);\n-                    expanded = sema.expand_derive_macro(&attr);\n-                    break;\n-                }\n-            }\n-        }\n-\n         if let Some(item) = ast::Item::cast(node.clone()) {\n             if let Some(def) = sema.resolve_attr_macro_call(&item) {\n                 name = def.name(db).map(|name| name.to_string());\n                 expanded = expand_attr_macro_recur(&sema, &item);\n                 break;\n             }\n         }\n-\n         if let Some(mac) = ast::MacroCall::cast(node) {\n             name = Some(mac.path()?.segment()?.name_ref()?.to_string());\n             expanded = expand_macro_recur(&sema, &mac);\n@@ -107,24 +107,26 @@ fn expand<T: AstNode>(\n // FIXME: It would also be cool to share logic here and in the mbe tests,\n // which are pretty unreadable at the moment.\n fn insert_whitespaces(syn: SyntaxNode) -> String {\n+    use SyntaxKind::*;\n     let mut res = String::new();\n-    let mut token_iter = syn\n-        .preorder_with_tokens()\n-        .filter_map(|event| {\n-            if let WalkEvent::Enter(NodeOrToken::Token(token)) = event {\n-                Some(token)\n-            } else {\n-                None\n-            }\n-        })\n-        .peekable();\n \n     let mut indent = 0;\n     let mut last: Option<SyntaxKind> = None;\n \n-    while let Some(token) = token_iter.next() {\n-        let mut is_next = |f: fn(SyntaxKind) -> bool, default| -> bool {\n-            token_iter.peek().map(|it| f(it.kind())).unwrap_or(default)\n+    for event in syn.preorder_with_tokens() {\n+        let token = match event {\n+            WalkEvent::Enter(NodeOrToken::Token(token)) => token,\n+            WalkEvent::Leave(NodeOrToken::Node(node))\n+                if matches!(node.kind(), ATTR | MATCH_ARM | STRUCT | ENUM | UNION | FN | IMPL) =>\n+            {\n+                res.push('\\n');\n+                res.extend(iter::repeat(\" \").take(2 * indent));\n+                continue;\n+            }\n+            _ => continue,\n+        };\n+        let is_next = |f: fn(SyntaxKind) -> bool, default| -> bool {\n+            token.next_token().map(|it| f(it.kind())).unwrap_or(default)\n         };\n         let is_last =\n             |f: fn(SyntaxKind) -> bool, default| -> bool { last.map(f).unwrap_or(default) };\n@@ -182,6 +184,7 @@ mod tests {\n \n     use crate::fixture;\n \n+    #[track_caller]\n     fn check(ra_fixture: &str, expect: Expect) {\n         let (analysis, pos) = fixture::position(ra_fixture);\n         let expansion = analysis.expand_macro(pos).unwrap().unwrap();\n@@ -207,6 +210,7 @@ f$0oo!();\n             expect![[r#\"\n                 foo\n                 fn b(){}\n+\n             \"#]],\n         );\n     }\n@@ -226,11 +230,12 @@ macro_rules! foo {\n f$0oo!();\n         \"#,\n             expect![[r#\"\n-            foo\n-            fn some_thing() -> u32 {\n-              let a = 0;\n-              a+10\n-            }\"#]],\n+                foo\n+                fn some_thing() -> u32 {\n+                  let a = 0;\n+                  a+10\n+                }\n+            \"#]],\n         );\n     }\n \n@@ -343,7 +348,6 @@ fn main() {\n     fn macro_expand_derive() {\n         check(\n             r#\"\n-\n #[rustc_builtin_macro]\n pub macro Clone {}\n \n@@ -353,6 +357,28 @@ struct Foo {}\n             expect![[r#\"\n                 Clone\n                 impl< >crate::clone::Clone for Foo< >{}\n+\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn macro_expand_derive2() {\n+        check(\n+            r#\"\n+#[rustc_builtin_macro]\n+pub macro Clone {}\n+#[rustc_builtin_macro]\n+pub macro Copy {}\n+\n+#[derive(Cop$0y)]\n+#[derive(Clone)]\n+struct Foo {}\n+\"#,\n+            expect![[r#\"\n+                Copy\n+                impl< >crate::marker::Copy for Foo< >{}\n+\n             \"#]],\n         );\n     }"}]}