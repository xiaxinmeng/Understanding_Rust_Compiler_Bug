{"sha": "67f1a08fd8eff669a997950cac6c538dd96718b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ZjFhMDhmZDhlZmY2NjlhOTk3OTUwY2FjNmM1MzhkZDk2NzE4YjM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-21T16:20:56Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-21T16:23:03Z"}, "message": "Some remaining cleanups", "tree": {"sha": "2d19db9e808ae1b92c65675eade448f893ff4d7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d19db9e808ae1b92c65675eade448f893ff4d7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67f1a08fd8eff669a997950cac6c538dd96718b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67f1a08fd8eff669a997950cac6c538dd96718b3", "html_url": "https://github.com/rust-lang/rust/commit/67f1a08fd8eff669a997950cac6c538dd96718b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67f1a08fd8eff669a997950cac6c538dd96718b3/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9d1550001f79390284cf7f0e958981f387a0c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9d1550001f79390284cf7f0e958981f387a0c58", "html_url": "https://github.com/rust-lang/rust/commit/e9d1550001f79390284cf7f0e958981f387a0c58"}], "stats": {"total": 31, "additions": 13, "deletions": 18}, "files": [{"sha": "f1cebbdb983f70c21c20f7d26de02030ff839b68", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67f1a08fd8eff669a997950cac6c538dd96718b3/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67f1a08fd8eff669a997950cac6c538dd96718b3/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=67f1a08fd8eff669a997950cac6c538dd96718b3", "patch": "@@ -373,10 +373,6 @@ impl<'a> InferenceContext<'a> {\n         self.table.unify(ty1, ty2)\n     }\n \n-    fn unify_inner(&mut self, ty1: &Ty, ty2: &Ty) -> InferResult {\n-        self.table.unify_inner(ty1, ty2)\n-    }\n-\n     fn resolve_ty_shallow(&mut self, ty: &Ty) -> Ty {\n         self.resolve_obligations_as_possible();\n         self.table.resolve_ty_shallow(ty)"}, {"sha": "765a02b1ced8a434fdd048fac4c894d04ed4aa98", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/67f1a08fd8eff669a997950cac6c538dd96718b3/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67f1a08fd8eff669a997950cac6c538dd96718b3/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=67f1a08fd8eff669a997950cac6c538dd96718b3", "patch": "@@ -146,7 +146,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             _ => {\n                 // Otherwise, just use unification rules.\n-                self.unify_inner(&from_ty, to_ty)\n+                self.table.try_unify(&from_ty, to_ty)\n             }\n         }\n     }\n@@ -155,15 +155,15 @@ impl<'a> InferenceContext<'a> {\n         let (_is_ref, from_mt, from_inner) = match from_ty.kind(&Interner) {\n             TyKind::Ref(mt, _, ty) => (true, mt, ty),\n             TyKind::Raw(mt, ty) => (false, mt, ty),\n-            _ => return self.unify_inner(&from_ty, to_ty),\n+            _ => return self.table.try_unify(&from_ty, to_ty),\n         };\n \n         coerce_mutabilities(*from_mt, to_mt)?;\n \n         // Check that the types which they point at are compatible.\n         let from_raw = TyKind::Raw(to_mt, from_inner.clone()).intern(&Interner);\n         // FIXME: behavior differs based on is_ref once we're computing adjustments\n-        self.unify_inner(&from_raw, to_ty)\n+        self.table.try_unify(&from_raw, to_ty)\n     }\n \n     /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n@@ -174,7 +174,7 @@ impl<'a> InferenceContext<'a> {\n             TyKind::Ref(mt, _, _) => {\n                 coerce_mutabilities(*mt, to_mt)?;\n             }\n-            _ => return self.unify_inner(&from_ty, to_ty),\n+            _ => return self.table.try_unify(&from_ty, to_ty),\n         };\n \n         // NOTE: this code is mostly copied and adapted from rustc, and\n@@ -228,7 +228,7 @@ impl<'a> InferenceContext<'a> {\n             // from `&mut T` to `&U`.\n             let lt = static_lifetime(); // FIXME: handle lifetimes correctly, see rustc\n             let derefd_from_ty = TyKind::Ref(to_mt, lt, referent_ty).intern(&Interner);\n-            match self.unify_inner(&derefd_from_ty, to_ty) {\n+            match self.table.try_unify(&derefd_from_ty, to_ty) {\n                 Ok(result) => {\n                     found = Some(result);\n                     break;\n@@ -274,7 +274,7 @@ impl<'a> InferenceContext<'a> {\n \n                 Ok(ok)\n             }\n-            _ => self.unify_inner(&from_ty, to_ty),\n+            _ => self.table.try_unify(&from_ty, to_ty),\n         }\n     }\n \n@@ -299,10 +299,10 @@ impl<'a> InferenceContext<'a> {\n             {\n                 let from_unsafe =\n                     TyKind::Function(safe_to_unsafe_fn_ty(from_fn_ptr.clone())).intern(&Interner);\n-                return self.unify_inner(&from_unsafe, to_ty);\n+                return self.table.try_unify(&from_unsafe, to_ty);\n             }\n         }\n-        self.unify_inner(&from_ty, to_ty)\n+        self.table.try_unify(&from_ty, to_ty)\n     }\n \n     /// Attempts to coerce from the type of a non-capturing closure into a\n@@ -323,9 +323,9 @@ impl<'a> InferenceContext<'a> {\n                 //     `unsafe fn(arg0,arg1,...) -> _`\n                 let safety = fn_ty.sig.safety;\n                 let pointer_ty = coerce_closure_fn_ty(from_substs, safety);\n-                self.unify_inner(&pointer_ty, to_ty)\n+                self.table.try_unify(&pointer_ty, to_ty)\n             }\n-            _ => self.unify_inner(&from_ty, to_ty),\n+            _ => self.table.try_unify(&from_ty, to_ty),\n         }\n     }\n "}, {"sha": "4987795e0316270abbeae8c03b07a100b6024f65", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67f1a08fd8eff669a997950cac6c538dd96718b3/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67f1a08fd8eff669a997950cac6c538dd96718b3/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=67f1a08fd8eff669a997950cac6c538dd96718b3", "patch": "@@ -70,7 +70,7 @@ impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n                 let ty = ctx.normalize_associated_types_in(new_vars.apply(ty.clone(), &Interner));\n                 ctx.unify(var.assert_ty_ref(&Interner), &ty);\n             } else {\n-                let _ = ctx.unify_inner(&var, &new_vars.apply(v.clone(), &Interner));\n+                let _ = ctx.try_unify(&var, &new_vars.apply(v.clone(), &Interner));\n             }\n         }\n     }\n@@ -300,9 +300,8 @@ impl<'a> InferenceTable<'a> {\n     }\n \n     /// Unify two types and register new trait goals that arise from that.\n-    // TODO give these two functions better names\n     pub(crate) fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n-        let result = if let Ok(r) = self.unify_inner(ty1, ty2) {\n+        let result = if let Ok(r) = self.try_unify(ty1, ty2) {\n             r\n         } else {\n             return false;\n@@ -313,7 +312,7 @@ impl<'a> InferenceTable<'a> {\n \n     /// Unify two types and return new trait goals arising from it, so the\n     /// caller needs to deal with them.\n-    pub(crate) fn unify_inner<T: Zip<Interner>>(&mut self, t1: &T, t2: &T) -> InferResult {\n+    pub(crate) fn try_unify<T: Zip<Interner>>(&mut self, t1: &T, t2: &T) -> InferResult {\n         match self.var_unification_table.relate(\n             &Interner,\n             &self.db,"}]}