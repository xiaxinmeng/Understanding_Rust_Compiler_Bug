{"sha": "34e8b0aae1fe66e0e0c0f70957cc647361a79ff5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ZThiMGFhZTFmZTY2ZTBlMGMwZjcwOTU3Y2M2NDczNjFhNzlmZjU=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-12T02:46:58Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-17T16:34:41Z"}, "message": "Separate `create_resolver` into a new function", "tree": {"sha": "08b24f0c6c14c6c635acda3dd3552333c44769c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08b24f0c6c14c6c635acda3dd3552333c44769c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34e8b0aae1fe66e0e0c0f70957cc647361a79ff5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34e8b0aae1fe66e0e0c0f70957cc647361a79ff5", "html_url": "https://github.com/rust-lang/rust/commit/34e8b0aae1fe66e0e0c0f70957cc647361a79ff5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34e8b0aae1fe66e0e0c0f70957cc647361a79ff5/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ac58f7bf86cd8a3616484b3ff1a794521368536", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ac58f7bf86cd8a3616484b3ff1a794521368536", "html_url": "https://github.com/rust-lang/rust/commit/0ac58f7bf86cd8a3616484b3ff1a794521368536"}], "stats": {"total": 79, "additions": 43, "deletions": 36}, "files": [{"sha": "cd05d922f5fe60dfad6036f861ac73cbff9c211c", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/34e8b0aae1fe66e0e0c0f70957cc647361a79ff5/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e8b0aae1fe66e0e0c0f70957cc647361a79ff5/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=34e8b0aae1fe66e0e0c0f70957cc647361a79ff5", "patch": "@@ -11,7 +11,7 @@ use rustc_hir::{\n     intravisit::{self, NestedVisitorMap, Visitor},\n     Path,\n };\n-use rustc_interface::interface;\n+use rustc_interface::{interface, Queries};\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n@@ -409,16 +409,10 @@ fn create_config(\n crate fn run_core(\n     options: RustdocOptions,\n ) -> (clean::Crate, RenderInfo, RenderOptions, Lrc<Session>) {\n-    let extern_names: Vec<String> = options\n-        .externs\n-        .iter()\n-        .filter(|(_, entry)| entry.add_prelude)\n-        .map(|(name, _)| name)\n-        .cloned()\n-        .collect();\n     let default_passes = options.default_passes;\n     let output_format = options.output_format;\n     // TODO: fix this clone (especially render_options)\n+    let externs = options.externs.clone();\n     let manual_passes = options.manual_passes.clone();\n     let render_options = options.render_options.clone();\n     let config = create_config(options);\n@@ -430,34 +424,7 @@ crate fn run_core(\n             // We need to hold on to the complete resolver, so we cause everything to be\n             // cloned for the analysis passes to use. Suboptimal, but necessary in the\n             // current architecture.\n-            let resolver = {\n-                let parts = abort_on_err(queries.expansion(), sess).peek();\n-                let resolver = parts.1.borrow();\n-\n-                // Before we actually clone it, let's force all the extern'd crates to\n-                // actually be loaded, just in case they're only referred to inside\n-                // intra-doc-links\n-                resolver.borrow_mut().access(|resolver| {\n-                    sess.time(\"load_extern_crates\", || {\n-                        for extern_name in &extern_names {\n-                            debug!(\"loading extern crate {}\", extern_name);\n-                            resolver\n-                                .resolve_str_path_error(\n-                                    DUMMY_SP,\n-                                    extern_name,\n-                                    TypeNS,\n-                                    LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id(),\n-                                )\n-                                .unwrap_or_else(|()| {\n-                                    panic!(\"Unable to resolve external crate {}\", extern_name)\n-                                });\n-                        }\n-                    });\n-                });\n-\n-                // Now we're good to clone the resolver because everything should be loaded\n-                resolver.clone()\n-            };\n+            let resolver = create_resolver(externs, queries, &sess);\n \n             if sess.has_errors() {\n                 sess.fatal(\"Compilation failed, aborting rustdoc\");\n@@ -482,6 +449,46 @@ crate fn run_core(\n     })\n }\n \n+fn create_resolver<'a>(\n+    externs: config::Externs,\n+    queries: &Queries<'a>,\n+    sess: &Session,\n+) -> Lrc<RefCell<interface::BoxedResolver>> {\n+    let extern_names: Vec<String> = externs\n+        .iter()\n+        .filter(|(_, entry)| entry.add_prelude)\n+        .map(|(name, _)| name)\n+        .cloned()\n+        .collect();\n+\n+    let parts = abort_on_err(queries.expansion(), sess).peek();\n+    let resolver = parts.1.borrow();\n+\n+    // Before we actually clone it, let's force all the extern'd crates to\n+    // actually be loaded, just in case they're only referred to inside\n+    // intra-doc-links\n+    resolver.borrow_mut().access(|resolver| {\n+        sess.time(\"load_extern_crates\", || {\n+            for extern_name in &extern_names {\n+                debug!(\"loading extern crate {}\", extern_name);\n+                resolver\n+                    .resolve_str_path_error(\n+                        DUMMY_SP,\n+                        extern_name,\n+                        TypeNS,\n+                        LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id(),\n+                    )\n+                    .unwrap_or_else(|()| {\n+                        panic!(\"Unable to resolve external crate {}\", extern_name)\n+                    });\n+            }\n+        });\n+    });\n+\n+    // Now we're good to clone the resolver because everything should be loaded\n+    resolver.clone()\n+}\n+\n fn run_global_ctxt(\n     tcx: TyCtxt<'_>,\n     resolver: Rc<RefCell<interface::BoxedResolver>>,"}]}