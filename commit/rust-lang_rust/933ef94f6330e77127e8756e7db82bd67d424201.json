{"sha": "933ef94f6330e77127e8756e7db82bd67d424201", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzM2VmOTRmNjMzMGU3NzEyN2U4NzU2ZTdkYjgyYmQ2N2Q0MjQyMDE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-03-12T10:48:17Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-03-12T10:48:17Z"}, "message": "Move aot code to driver/aot.rs", "tree": {"sha": "fff762354bcace570f50069f8b4f59eb8020233c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fff762354bcace570f50069f8b4f59eb8020233c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/933ef94f6330e77127e8756e7db82bd67d424201", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/933ef94f6330e77127e8756e7db82bd67d424201", "html_url": "https://github.com/rust-lang/rust/commit/933ef94f6330e77127e8756e7db82bd67d424201", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/933ef94f6330e77127e8756e7db82bd67d424201/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03240d89ccab3327a348a2abcbcebf61edbd5293", "url": "https://api.github.com/repos/rust-lang/rust/commits/03240d89ccab3327a348a2abcbcebf61edbd5293", "html_url": "https://github.com/rust-lang/rust/commit/03240d89ccab3327a348a2abcbcebf61edbd5293"}], "stats": {"total": 557, "additions": 281, "deletions": 276}, "files": [{"sha": "d87ab9d85ce0fa8deec1f73c648d7ef8d3d978d7", "filename": "src/driver/aot.rs", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/933ef94f6330e77127e8756e7db82bd67d424201/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933ef94f6330e77127e8756e7db82bd67d424201/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=933ef94f6330e77127e8756e7db82bd67d424201", "patch": "@@ -0,0 +1,278 @@\n+use rustc::dep_graph::{WorkProduct, WorkProductFileKind, WorkProductId};\n+use rustc::middle::cstore::EncodedMetadata;\n+use rustc::mir::mono::CodegenUnit;\n+use rustc::session::config::{DebugInfo, OutputType};\n+use rustc_session::cgu_reuse_tracker::CguReuse;\n+use rustc_codegen_ssa::back::linker::LinkerInfo;\n+use rustc_codegen_ssa::CrateInfo;\n+\n+use crate::prelude::*;\n+\n+use crate::backend::{Emit, WriteDebugInfo};\n+\n+pub(super) fn run_aot(\n+    tcx: TyCtxt<'_>,\n+    metadata: EncodedMetadata,\n+    need_metadata_module: bool,\n+) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n+    let mut work_products = FxHashMap::default();\n+\n+    fn new_module(tcx: TyCtxt<'_>, name: String) -> Module<crate::backend::Backend> {\n+        let module = crate::backend::make_module(tcx.sess, name);\n+        assert_eq!(pointer_ty(tcx), module.target_config().pointer_type());\n+        module\n+    };\n+\n+    struct ModuleCodegenResult(CompiledModule, Option<(WorkProductId, WorkProduct)>);\n+\n+    use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+\n+    impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n+        fn hash_stable(&self, _: &mut HCX, _: &mut StableHasher) {\n+            // do nothing\n+        }\n+    }\n+\n+    fn emit_module<B: Backend>(\n+        tcx: TyCtxt<'_>,\n+        name: String,\n+        kind: ModuleKind,\n+        mut module: Module<B>,\n+        debug: Option<DebugContext>,\n+    ) -> ModuleCodegenResult\n+        where B::Product: Emit + WriteDebugInfo,\n+    {\n+            module.finalize_definitions();\n+            let mut product = module.finish();\n+\n+            if let Some(mut debug) = debug {\n+                debug.emit(&mut product);\n+            }\n+\n+            let tmp_file = tcx\n+                .output_filenames(LOCAL_CRATE)\n+                .temp_path(OutputType::Object, Some(&name));\n+            let obj = product.emit();\n+            std::fs::write(&tmp_file, obj).unwrap();\n+\n+            let work_product = if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() {\n+                None\n+            } else {\n+                rustc_incremental::copy_cgu_workproducts_to_incr_comp_cache_dir(\n+                    tcx.sess,\n+                    &name,\n+                    &[(WorkProductFileKind::Object, tmp_file.clone())],\n+                )\n+            };\n+\n+            ModuleCodegenResult(\n+                CompiledModule {\n+                    name,\n+                    kind,\n+                    object: Some(tmp_file),\n+                    bytecode: None,\n+                    bytecode_compressed: None,\n+                },\n+                work_product,\n+            )\n+        };\n+\n+    let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n+\n+    if tcx.dep_graph.is_fully_enabled() {\n+        for cgu in &*cgus {\n+            tcx.codegen_unit(cgu.name());\n+        }\n+    }\n+\n+    let modules = super::time(tcx, \"codegen mono items\", || {\n+        cgus.iter().map(|cgu| {\n+            let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n+            tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n+\n+            match cgu_reuse {\n+                _ if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() => {}\n+                CguReuse::No => {}\n+                CguReuse::PreLto => {\n+                    let incr_comp_session_dir = tcx.sess.incr_comp_session_dir();\n+                    let mut object = None;\n+                    let work_product = cgu.work_product(tcx);\n+                    for (kind, saved_file) in &work_product.saved_files {\n+                        let obj_out = match kind {\n+                            WorkProductFileKind::Object => {\n+                                let path = tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(&cgu.name().as_str()));\n+                                object = Some(path.clone());\n+                                path\n+                            }\n+                            WorkProductFileKind::Bytecode | WorkProductFileKind::BytecodeCompressed => {\n+                                panic!(\"cg_clif doesn't use bytecode\");\n+                            }\n+                        };\n+                        let source_file = rustc_incremental::in_incr_comp_dir(&incr_comp_session_dir, &saved_file);\n+                        if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n+                            tcx.sess.err(&format!(\n+                                \"unable to copy {} to {}: {}\",\n+                                source_file.display(),\n+                                obj_out.display(),\n+                                err\n+                            ));\n+                        }\n+                    }\n+\n+                    work_products.insert(cgu.work_product_id(), work_product);\n+\n+                    return CompiledModule {\n+                        name: cgu.name().to_string(),\n+                        kind: ModuleKind::Regular,\n+                        object,\n+                        bytecode: None,\n+                        bytecode_compressed: None,\n+                    };\n+                }\n+                CguReuse::PostLto => unreachable!(),\n+            }\n+\n+            let dep_node = cgu.codegen_dep_node(tcx);\n+            let (ModuleCodegenResult(module, work_product), _) =\n+                tcx.dep_graph.with_task(dep_node, tcx, cgu.name(), module_codegen, rustc::dep_graph::hash_result);\n+\n+            fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodegenResult {\n+                let cgu = tcx.codegen_unit(cgu_name);\n+                let mono_items = cgu.items_in_deterministic_order(tcx);\n+\n+                let mut module = new_module(tcx, cgu_name.as_str().to_string());\n+\n+                let mut debug = if tcx.sess.opts.debuginfo != DebugInfo::None {\n+                    let debug = DebugContext::new(\n+                        tcx,\n+                        module.target_config().pointer_type().bytes() as u8,\n+                    );\n+                    Some(debug)\n+                } else {\n+                    None\n+                };\n+\n+                super::codegen_mono_items(tcx, &mut module, debug.as_mut(), mono_items);\n+                crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module);\n+\n+                emit_module(\n+                    tcx,\n+                    cgu.name().as_str().to_string(),\n+                    ModuleKind::Regular,\n+                    module,\n+                    debug,\n+                )\n+            }\n+\n+            if let Some((id, product)) = work_product {\n+                work_products.insert(id, product);\n+            }\n+\n+            module\n+        }).collect::<Vec<_>>()\n+    });\n+\n+    tcx.sess.abort_if_errors();\n+\n+    let mut allocator_module = new_module(tcx, \"allocator_shim\".to_string());\n+    let created_alloc_shim = crate::allocator::codegen(tcx, &mut allocator_module);\n+\n+    let allocator_module = if created_alloc_shim {\n+        let ModuleCodegenResult(module, work_product) = emit_module(\n+            tcx,\n+            \"allocator_shim\".to_string(),\n+            ModuleKind::Allocator,\n+            allocator_module,\n+            None,\n+        );\n+        if let Some((id, product)) = work_product {\n+            work_products.insert(id, product);\n+        }\n+        Some(module)\n+    } else {\n+        None\n+    };\n+\n+    rustc_incremental::assert_dep_graph(tcx);\n+    rustc_incremental::save_dep_graph(tcx);\n+\n+    let metadata_module = if need_metadata_module {\n+        let _timer = tcx.prof.generic_activity(\"codegen crate metadata\");\n+        let (metadata_cgu_name, tmp_file) = tcx.sess.time(\"write compressed metadata\", || {\n+            use rustc::mir::mono::CodegenUnitNameBuilder;\n+\n+            let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+            let metadata_cgu_name = cgu_name_builder\n+                .build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"metadata\"))\n+                .as_str()\n+                .to_string();\n+\n+            let tmp_file = tcx\n+                .output_filenames(LOCAL_CRATE)\n+                .temp_path(OutputType::Metadata, Some(&metadata_cgu_name));\n+\n+            let obj = crate::backend::with_object(tcx.sess, &metadata_cgu_name, |object| {\n+                crate::metadata::write_metadata(tcx, object);\n+            });\n+\n+            std::fs::write(&tmp_file, obj).unwrap();\n+\n+            (metadata_cgu_name, tmp_file)\n+        });\n+\n+        Some(CompiledModule {\n+            name: metadata_cgu_name,\n+            kind: ModuleKind::Metadata,\n+            object: Some(tmp_file),\n+            bytecode: None,\n+            bytecode_compressed: None,\n+        })\n+    } else {\n+        None\n+    };\n+\n+    Box::new((CodegenResults {\n+        crate_name: tcx.crate_name(LOCAL_CRATE),\n+        modules,\n+        allocator_module,\n+        metadata_module,\n+        crate_hash: tcx.crate_hash(LOCAL_CRATE),\n+        metadata,\n+        windows_subsystem: None, // Windows is not yet supported\n+        linker_info: LinkerInfo::new(tcx),\n+        crate_info: CrateInfo::new(tcx),\n+    }, work_products))\n+}\n+\n+// Adapted from https://github.com/rust-lang/rust/blob/303d8aff6092709edd4dbd35b1c88e9aa40bf6d8/src/librustc_codegen_ssa/base.rs#L922-L953\n+fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguReuse {\n+    if !tcx.dep_graph.is_fully_enabled() {\n+        return CguReuse::No;\n+    }\n+\n+    let work_product_id = &cgu.work_product_id();\n+    if tcx.dep_graph.previous_work_product(work_product_id).is_none() {\n+        // We don't have anything cached for this CGU. This can happen\n+        // if the CGU did not exist in the previous session.\n+        return CguReuse::No;\n+    }\n+\n+    // Try to mark the CGU as green. If it we can do so, it means that nothing\n+    // affecting the LLVM module has changed and we can re-use a cached version.\n+    // If we compile with any kind of LTO, this means we can re-use the bitcode\n+    // of the Pre-LTO stage (possibly also the Post-LTO version but we'll only\n+    // know that later). If we are not doing LTO, there is only one optimized\n+    // version of each module, so we re-use that.\n+    let dep_node = cgu.codegen_dep_node(tcx);\n+    assert!(\n+        !tcx.dep_graph.dep_node_exists(&dep_node),\n+        \"CompileCodegenUnit dep-node for CGU `{}` already exists before marking.\",\n+        cgu.name()\n+    );\n+\n+    if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n+        CguReuse::PreLto\n+    } else {\n+        CguReuse::No\n+    }\n+}"}, {"sha": "c676006aecec7ab9c8a9dff97f2630983fbcdcf0", "filename": "src/driver/mod.rs", "status": "modified", "additions": 3, "deletions": 276, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/933ef94f6330e77127e8756e7db82bd67d424201/src%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933ef94f6330e77127e8756e7db82bd67d424201/src%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fmod.rs?ref=933ef94f6330e77127e8756e7db82bd67d424201", "patch": "@@ -1,17 +1,11 @@\n use std::any::Any;\n \n-use rustc::dep_graph::{WorkProduct, WorkProductFileKind, WorkProductId};\n use rustc::middle::cstore::EncodedMetadata;\n-use rustc::mir::mono::{CodegenUnit, Linkage as RLinkage, Visibility};\n-use rustc::session::config::{DebugInfo, OutputType};\n-use rustc_session::cgu_reuse_tracker::CguReuse;\n-use rustc_codegen_ssa::back::linker::LinkerInfo;\n-use rustc_codegen_ssa::CrateInfo;\n+use rustc::mir::mono::{Linkage as RLinkage, Visibility};\n \n use crate::prelude::*;\n \n-use crate::backend::{Emit, WriteDebugInfo};\n-\n+mod aot;\n #[cfg(not(target_arch = \"wasm32\"))]\n mod jit;\n \n@@ -32,241 +26,7 @@ pub fn codegen_crate(\n         panic!(\"jit not supported on wasm\");\n     }\n \n-    run_aot(tcx, metadata, need_metadata_module)\n-}\n-\n-fn run_aot(\n-    tcx: TyCtxt<'_>,\n-    metadata: EncodedMetadata,\n-    need_metadata_module: bool,\n-) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n-    let mut work_products = FxHashMap::default();\n-\n-    fn new_module(tcx: TyCtxt<'_>, name: String) -> Module<crate::backend::Backend> {\n-        let module = crate::backend::make_module(tcx.sess, name);\n-        assert_eq!(pointer_ty(tcx), module.target_config().pointer_type());\n-        module\n-    };\n-\n-    struct ModuleCodegenResult(CompiledModule, Option<(WorkProductId, WorkProduct)>);\n-\n-    use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-\n-    impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n-        fn hash_stable(&self, _: &mut HCX, _: &mut StableHasher) {\n-            // do nothing\n-        }\n-    }\n-\n-    fn emit_module<B: Backend>(\n-        tcx: TyCtxt<'_>,\n-        name: String,\n-        kind: ModuleKind,\n-        mut module: Module<B>,\n-        debug: Option<DebugContext>,\n-    ) -> ModuleCodegenResult\n-        where B::Product: Emit + WriteDebugInfo,\n-    {\n-            module.finalize_definitions();\n-            let mut product = module.finish();\n-\n-            if let Some(mut debug) = debug {\n-                debug.emit(&mut product);\n-            }\n-\n-            let tmp_file = tcx\n-                .output_filenames(LOCAL_CRATE)\n-                .temp_path(OutputType::Object, Some(&name));\n-            let obj = product.emit();\n-            std::fs::write(&tmp_file, obj).unwrap();\n-\n-            let work_product = if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() {\n-                None\n-            } else {\n-                rustc_incremental::copy_cgu_workproducts_to_incr_comp_cache_dir(\n-                    tcx.sess,\n-                    &name,\n-                    &[(WorkProductFileKind::Object, tmp_file.clone())],\n-                )\n-            };\n-\n-            ModuleCodegenResult(\n-                CompiledModule {\n-                    name,\n-                    kind,\n-                    object: Some(tmp_file),\n-                    bytecode: None,\n-                    bytecode_compressed: None,\n-                },\n-                work_product,\n-            )\n-        };\n-\n-    let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n-\n-    if tcx.dep_graph.is_fully_enabled() {\n-        for cgu in &*cgus {\n-            tcx.codegen_unit(cgu.name());\n-        }\n-    }\n-\n-    let modules = time(tcx, \"codegen mono items\", || {\n-        cgus.iter().map(|cgu| {\n-            let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n-            tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n-\n-            match cgu_reuse {\n-                _ if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() => {}\n-                CguReuse::No => {}\n-                CguReuse::PreLto => {\n-                    let incr_comp_session_dir = tcx.sess.incr_comp_session_dir();\n-                    let mut object = None;\n-                    let work_product = cgu.work_product(tcx);\n-                    for (kind, saved_file) in &work_product.saved_files {\n-                        let obj_out = match kind {\n-                            WorkProductFileKind::Object => {\n-                                let path = tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(&cgu.name().as_str()));\n-                                object = Some(path.clone());\n-                                path\n-                            }\n-                            WorkProductFileKind::Bytecode | WorkProductFileKind::BytecodeCompressed => {\n-                                panic!(\"cg_clif doesn't use bytecode\");\n-                            }\n-                        };\n-                        let source_file = rustc_incremental::in_incr_comp_dir(&incr_comp_session_dir, &saved_file);\n-                        if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n-                            tcx.sess.err(&format!(\n-                                \"unable to copy {} to {}: {}\",\n-                                source_file.display(),\n-                                obj_out.display(),\n-                                err\n-                            ));\n-                        }\n-                    }\n-\n-                    work_products.insert(cgu.work_product_id(), work_product);\n-\n-                    return CompiledModule {\n-                        name: cgu.name().to_string(),\n-                        kind: ModuleKind::Regular,\n-                        object,\n-                        bytecode: None,\n-                        bytecode_compressed: None,\n-                    };\n-                }\n-                CguReuse::PostLto => unreachable!(),\n-            }\n-\n-            let dep_node = cgu.codegen_dep_node(tcx);\n-            let (ModuleCodegenResult(module, work_product), _) =\n-                tcx.dep_graph.with_task(dep_node, tcx, cgu.name(), module_codegen, rustc::dep_graph::hash_result);\n-\n-            fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodegenResult {\n-                let cgu = tcx.codegen_unit(cgu_name);\n-                let mono_items = cgu.items_in_deterministic_order(tcx);\n-\n-                let mut module = new_module(tcx, cgu_name.as_str().to_string());\n-\n-                let mut debug = if tcx.sess.opts.debuginfo != DebugInfo::None {\n-                    let debug = DebugContext::new(\n-                        tcx,\n-                        module.target_config().pointer_type().bytes() as u8,\n-                    );\n-                    Some(debug)\n-                } else {\n-                    None\n-                };\n-\n-                codegen_mono_items(tcx, &mut module, debug.as_mut(), mono_items);\n-                crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module);\n-\n-                emit_module(\n-                    tcx,\n-                    cgu.name().as_str().to_string(),\n-                    ModuleKind::Regular,\n-                    module,\n-                    debug,\n-                )\n-            }\n-\n-            if let Some((id, product)) = work_product {\n-                work_products.insert(id, product);\n-            }\n-\n-            module\n-        }).collect::<Vec<_>>()\n-    });\n-\n-    tcx.sess.abort_if_errors();\n-\n-    let mut allocator_module = new_module(tcx, \"allocator_shim\".to_string());\n-    let created_alloc_shim = crate::allocator::codegen(tcx, &mut allocator_module);\n-\n-    let allocator_module = if created_alloc_shim {\n-        let ModuleCodegenResult(module, work_product) = emit_module(\n-            tcx,\n-            \"allocator_shim\".to_string(),\n-            ModuleKind::Allocator,\n-            allocator_module,\n-            None,\n-        );\n-        if let Some((id, product)) = work_product {\n-            work_products.insert(id, product);\n-        }\n-        Some(module)\n-    } else {\n-        None\n-    };\n-\n-    rustc_incremental::assert_dep_graph(tcx);\n-    rustc_incremental::save_dep_graph(tcx);\n-\n-    let metadata_module = if need_metadata_module {\n-        let _timer = tcx.prof.generic_activity(\"codegen crate metadata\");\n-        let (metadata_cgu_name, tmp_file) = tcx.sess.time(\"write compressed metadata\", || {\n-            use rustc::mir::mono::CodegenUnitNameBuilder;\n-\n-            let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n-            let metadata_cgu_name = cgu_name_builder\n-                .build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"metadata\"))\n-                .as_str()\n-                .to_string();\n-\n-            let tmp_file = tcx\n-                .output_filenames(LOCAL_CRATE)\n-                .temp_path(OutputType::Metadata, Some(&metadata_cgu_name));\n-\n-            let obj = crate::backend::with_object(tcx.sess, &metadata_cgu_name, |object| {\n-                crate::metadata::write_metadata(tcx, object);\n-            });\n-\n-            std::fs::write(&tmp_file, obj).unwrap();\n-\n-            (metadata_cgu_name, tmp_file)\n-        });\n-\n-        Some(CompiledModule {\n-            name: metadata_cgu_name,\n-            kind: ModuleKind::Metadata,\n-            object: Some(tmp_file),\n-            bytecode: None,\n-            bytecode_compressed: None,\n-        })\n-    } else {\n-        None\n-    };\n-\n-    Box::new((CodegenResults {\n-        crate_name: tcx.crate_name(LOCAL_CRATE),\n-        modules,\n-        allocator_module,\n-        metadata_module,\n-        crate_hash: tcx.crate_hash(LOCAL_CRATE),\n-        metadata,\n-        windows_subsystem: None, // Windows is not yet supported\n-        linker_info: LinkerInfo::new(tcx),\n-        crate_info: CrateInfo::new(tcx),\n-    }, work_products))\n+    aot::run_aot(tcx, metadata, need_metadata_module)\n }\n \n fn codegen_mono_items<'tcx>(\n@@ -368,36 +128,3 @@ fn time<R>(tcx: TyCtxt<'_>, name: &'static str, f: impl FnOnce() -> R) -> R {\n         tcx.sess.time(name, f)\n     }\n }\n-\n-// Adapted from https://github.com/rust-lang/rust/blob/303d8aff6092709edd4dbd35b1c88e9aa40bf6d8/src/librustc_codegen_ssa/base.rs#L922-L953\n-fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguReuse {\n-    if !tcx.dep_graph.is_fully_enabled() {\n-        return CguReuse::No;\n-    }\n-\n-    let work_product_id = &cgu.work_product_id();\n-    if tcx.dep_graph.previous_work_product(work_product_id).is_none() {\n-        // We don't have anything cached for this CGU. This can happen\n-        // if the CGU did not exist in the previous session.\n-        return CguReuse::No;\n-    }\n-\n-    // Try to mark the CGU as green. If it we can do so, it means that nothing\n-    // affecting the LLVM module has changed and we can re-use a cached version.\n-    // If we compile with any kind of LTO, this means we can re-use the bitcode\n-    // of the Pre-LTO stage (possibly also the Post-LTO version but we'll only\n-    // know that later). If we are not doing LTO, there is only one optimized\n-    // version of each module, so we re-use that.\n-    let dep_node = cgu.codegen_dep_node(tcx);\n-    assert!(\n-        !tcx.dep_graph.dep_node_exists(&dep_node),\n-        \"CompileCodegenUnit dep-node for CGU `{}` already exists before marking.\",\n-        cgu.name()\n-    );\n-\n-    if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n-        CguReuse::PreLto\n-    } else {\n-        CguReuse::No\n-    }\n-}"}]}