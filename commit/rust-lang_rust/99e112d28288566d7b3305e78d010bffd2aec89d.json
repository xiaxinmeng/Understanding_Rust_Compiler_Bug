{"sha": "99e112d28288566d7b3305e78d010bffd2aec89d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZTExMmQyODI4ODU2NmQ3YjMzMDVlNzhkMDEwYmZmZDJhZWM4OWQ=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-05-31T13:20:50Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-06-08T17:24:16Z"}, "message": "Inline the rest of box_region", "tree": {"sha": "adf07cbb727670db05df97e21617f78f2a4c237d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adf07cbb727670db05df97e21617f78f2a4c237d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99e112d28288566d7b3305e78d010bffd2aec89d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99e112d28288566d7b3305e78d010bffd2aec89d", "html_url": "https://github.com/rust-lang/rust/commit/99e112d28288566d7b3305e78d010bffd2aec89d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99e112d28288566d7b3305e78d010bffd2aec89d/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0", "url": "https://api.github.com/repos/rust-lang/rust/commits/86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0", "html_url": "https://github.com/rust-lang/rust/commit/86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0"}], "stats": {"total": 183, "additions": 79, "deletions": 104}, "files": [{"sha": "a1a757b705418c421fdbe92e3b51b8c5219f87be", "filename": "compiler/rustc_data_structures/src/box_region.rs", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0/compiler%2Frustc_data_structures%2Fsrc%2Fbox_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0/compiler%2Frustc_data_structures%2Fsrc%2Fbox_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fbox_region.rs?ref=86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0", "patch": "@@ -1,80 +0,0 @@\n-//! This module provides a way to deal with self-referential data.\n-//!\n-//! The main idea is to allocate such data in a generator frame and then\n-//! give access to it by executing user-provided closures inside that generator.\n-//! The module provides a safe abstraction for the latter task.\n-//!\n-//! The interface consists of two exported macros meant to be used together:\n-//! * `declare_box_region_type` wraps a generator inside a struct with `access`\n-//!   method which accepts closures.\n-//! * `box_region_allow_access` is a helper which should be called inside\n-//!   a generator to actually execute those closures.\n-\n-use std::marker::PhantomData;\n-use std::ops::{Generator, GeneratorState};\n-use std::pin::Pin;\n-\n-#[derive(Copy, Clone)]\n-pub struct AccessAction(*mut dyn FnMut());\n-\n-impl AccessAction {\n-    pub fn get(self) -> *mut dyn FnMut() {\n-        self.0\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub enum Action {\n-    Initial,\n-    Access(AccessAction),\n-    Complete,\n-}\n-\n-pub struct PinnedGenerator<I, A, R> {\n-    generator: Pin<Box<dyn Generator<Action, Yield = YieldType<I, A>, Return = R>>>,\n-}\n-\n-impl<I, A, R> PinnedGenerator<I, A, R> {\n-    pub fn new<T: Generator<Action, Yield = YieldType<I, A>, Return = R> + 'static>(\n-        generator: T,\n-    ) -> (I, Self) {\n-        let mut result = PinnedGenerator { generator: Box::pin(generator) };\n-\n-        // Run it to the first yield to set it up\n-        let init = match Pin::new(&mut result.generator).resume(Action::Initial) {\n-            GeneratorState::Yielded(YieldType::Initial(y)) => y,\n-            _ => panic!(),\n-        };\n-\n-        (init, result)\n-    }\n-\n-    pub unsafe fn access(&mut self, closure: *mut dyn FnMut()) {\n-        // Call the generator, which in turn will call the closure\n-        if let GeneratorState::Complete(_) =\n-            Pin::new(&mut self.generator).resume(Action::Access(AccessAction(closure)))\n-        {\n-            panic!()\n-        }\n-    }\n-\n-    pub fn complete(&mut self) -> R {\n-        // Tell the generator we want it to complete, consuming it and yielding a result\n-        let result = Pin::new(&mut self.generator).resume(Action::Complete);\n-        if let GeneratorState::Complete(r) = result { r } else { panic!() }\n-    }\n-}\n-\n-#[derive(PartialEq)]\n-pub struct Marker<T>(PhantomData<T>);\n-\n-impl<T> Marker<T> {\n-    pub unsafe fn new() -> Self {\n-        Marker(PhantomData)\n-    }\n-}\n-\n-pub enum YieldType<I, A> {\n-    Initial(I),\n-    Accessor(Marker<A>),\n-}"}, {"sha": "d55e471810cd3150eb7a985ecde61151c45de3f3", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99e112d28288566d7b3305e78d010bffd2aec89d/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99e112d28288566d7b3305e78d010bffd2aec89d/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=99e112d28288566d7b3305e78d010bffd2aec89d", "patch": "@@ -10,7 +10,6 @@\n #![feature(array_windows)]\n #![feature(control_flow_enum)]\n #![feature(in_band_lifetimes)]\n-#![feature(generator_trait)]\n #![feature(min_specialization)]\n #![feature(auto_traits)]\n #![feature(nll)]\n@@ -63,7 +62,6 @@ macro_rules! unlikely {\n \n pub mod base_n;\n pub mod binary_search_util;\n-pub mod box_region;\n pub mod captures;\n pub mod flock;\n pub mod functor;"}, {"sha": "a93079c85a8c01c1b059d1e2d98307d7c77f28ac", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 79, "deletions": 22, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/99e112d28288566d7b3305e78d010bffd2aec89d/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99e112d28288566d7b3305e78d010bffd2aec89d/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=99e112d28288566d7b3305e78d010bffd2aec89d", "patch": "@@ -47,7 +47,10 @@ use std::cell::RefCell;\n use std::ffi::OsString;\n use std::io::{self, BufWriter, Write};\n use std::lazy::SyncLazy;\n+use std::marker::PhantomData;\n+use std::ops::{Generator, GeneratorState};\n use std::path::PathBuf;\n+use std::pin::Pin;\n use std::rc::Rc;\n use std::{env, fs, iter};\n \n@@ -85,27 +88,85 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n     counter.count\n }\n \n+#[derive(Copy, Clone)]\n+pub struct AccessAction(*mut dyn FnMut());\n+\n+impl AccessAction {\n+    pub fn get(self) -> *mut dyn FnMut() {\n+        self.0\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum Action {\n+    Initial,\n+    Access(AccessAction),\n+    Complete,\n+}\n+\n+pub struct PinnedGenerator<I, A, R> {\n+    generator: Pin<Box<dyn Generator<Action, Yield = YieldType<I, A>, Return = R>>>,\n+}\n+\n+impl<I, A, R> PinnedGenerator<I, A, R> {\n+    pub fn new<T: Generator<Action, Yield = YieldType<I, A>, Return = R> + 'static>(\n+        generator: T,\n+    ) -> (I, Self) {\n+        let mut result = PinnedGenerator { generator: Box::pin(generator) };\n+\n+        // Run it to the first yield to set it up\n+        let init = match Pin::new(&mut result.generator).resume(Action::Initial) {\n+            GeneratorState::Yielded(YieldType::Initial(y)) => y,\n+            _ => panic!(),\n+        };\n+\n+        (init, result)\n+    }\n+\n+    pub unsafe fn access(&mut self, closure: *mut dyn FnMut()) {\n+        // Call the generator, which in turn will call the closure\n+        if let GeneratorState::Complete(_) =\n+            Pin::new(&mut self.generator).resume(Action::Access(AccessAction(closure)))\n+        {\n+            panic!()\n+        }\n+    }\n+\n+    pub fn complete(&mut self) -> R {\n+        // Tell the generator we want it to complete, consuming it and yielding a result\n+        let result = Pin::new(&mut self.generator).resume(Action::Complete);\n+        if let GeneratorState::Complete(r) = result { r } else { panic!() }\n+    }\n+}\n+\n+#[derive(PartialEq)]\n+pub struct Marker<T>(PhantomData<T>);\n+\n+impl<T> Marker<T> {\n+    pub unsafe fn new() -> Self {\n+        Marker(PhantomData)\n+    }\n+}\n+\n+pub enum YieldType<I, A> {\n+    Initial(I),\n+    Accessor(Marker<A>),\n+}\n+\n pub struct BoxedResolver(\n-    rustc_data_structures::box_region::PinnedGenerator<\n-        Result<ast::Crate>,\n-        fn(&mut Resolver<'_>),\n-        ResolverOutputs,\n-    >,\n+    PinnedGenerator<Result<ast::Crate>, fn(&mut Resolver<'_>), ResolverOutputs>,\n );\n \n impl BoxedResolver {\n     fn new<T>(generator: T) -> (Result<ast::Crate>, Self)\n     where\n         T: ::std::ops::Generator<\n-                rustc_data_structures::box_region::Action,\n-                Yield = rustc_data_structures::box_region::YieldType<\n-                    Result<ast::Crate>,\n-                    fn(&mut Resolver<'_>),\n-                >,\n+                Action,\n+                Yield = YieldType<Result<ast::Crate>, fn(&mut Resolver<'_>)>,\n                 Return = ResolverOutputs,\n             > + 'static,\n     {\n-        let (initial, pinned) = rustc_data_structures::box_region::PinnedGenerator::new(generator);\n+        let (initial, pinned) = PinnedGenerator::new(generator);\n         (initial, BoxedResolver(pinned))\n     }\n \n@@ -135,9 +196,8 @@ impl BoxedResolver {\n \n     fn initial_yield(\n         value: Result<ast::Crate>,\n-    ) -> rustc_data_structures::box_region::YieldType<Result<ast::Crate>, fn(&mut Resolver<'_>)>\n-    {\n-        rustc_data_structures::box_region::YieldType::Initial(value)\n+    ) -> YieldType<Result<ast::Crate>, fn(&mut Resolver<'_>)> {\n+        YieldType::Initial(value)\n     }\n }\n \n@@ -186,20 +246,17 @@ pub fn configure_and_expand(\n \n         loop {\n             match action {\n-                rustc_data_structures::box_region::Action::Access(accessor) => {\n+                Action::Access(accessor) => {\n                     let accessor: &mut dyn FnMut(&mut Resolver<'_>) =\n                         unsafe { ::std::mem::transmute(accessor.get()) };\n                     (*accessor)(&mut resolver);\n                     unsafe {\n-                        let marker = rustc_data_structures::box_region::Marker::<\n-                            fn(&mut Resolver<'_>),\n-                        >::new();\n-                        action =\n-                            yield rustc_data_structures::box_region::YieldType::Accessor(marker);\n+                        let marker = Marker::<fn(&mut Resolver<'_>)>::new();\n+                        action = yield YieldType::Accessor(marker);\n                     };\n                 }\n-                rustc_data_structures::box_region::Action::Complete => break,\n-                rustc_data_structures::box_region::Action::Initial => {\n+                Action::Complete => break,\n+                Action::Initial => {\n                     panic!(\"unexpected box_region action: Initial\")\n                 }\n             }"}]}