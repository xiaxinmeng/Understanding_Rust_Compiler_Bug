{"sha": "e4271cae54c7f4a868c60a1822b91e702e511947", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MjcxY2FlNTRjN2Y0YTg2OGM2MGExODIyYjkxZTcwMmU1MTE5NDc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-01T17:47:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-07T15:16:14Z"}, "message": "core: Add a limited implementation of failure\n\nThis adds an small of failure to libcore, hamstrung by the fact that std::fmt\nhasn't been migrated yet. A few asserts were re-worked to not use std::fmt\nfeatures, but these asserts can go back to their original form once std::fmt has\nmigrated.\n\nThe current failure implementation is to just have some symbols exposed by\nstd::rt::unwind that are linked against by libcore. This is an explicit circular\ndependency, unfortunately. This will be officially supported in the future\nthrough compiler support with much nicer failure messages. Additionally, there\nare two depended-upon symbols today, but in the future there will only be one\n(once std::fmt has migrated).", "tree": {"sha": "96f723ffcdfc21f98b7ff29406f14f77d6ca6689", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96f723ffcdfc21f98b7ff29406f14f77d6ca6689"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4271cae54c7f4a868c60a1822b91e702e511947", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4271cae54c7f4a868c60a1822b91e702e511947", "html_url": "https://github.com/rust-lang/rust/commit/e4271cae54c7f4a868c60a1822b91e702e511947", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4271cae54c7f4a868c60a1822b91e702e511947/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4686cf201804c999fbc24fa3a3245e9c4dc4afe1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4686cf201804c999fbc24fa3a3245e9c4dc4afe1", "html_url": "https://github.com/rust-lang/rust/commit/4686cf201804c999fbc24fa3a3245e9c4dc4afe1"}], "stats": {"total": 232, "additions": 155, "deletions": 77}, "files": [{"sha": "298a3b38ee501ae8788d1eacc16bcbd4ef463ee1", "filename": "src/libcore/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=e4271cae54c7f4a868c60a1822b91e702e511947", "patch": "@@ -214,7 +214,7 @@ pub fn is_digit_radix(c: char, radix: uint) -> bool {\n #[inline]\n pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n     if radix > 36 {\n-        fail!(\"to_digit: radix {} is too high (maximum 36)\", radix);\n+        fail!(\"to_digit: radix is too high (maximum 36)\");\n     }\n     let val = match c {\n       '0' .. '9' => c as uint - ('0' as uint),\n@@ -273,7 +273,7 @@ pub fn to_lowercase(c: char) -> char {\n #[inline]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n-        fail!(\"from_digit: radix {} is to high (maximum 36)\", num);\n+        fail!(\"from_digit: radix is to high (maximum 36)\");\n     }\n     if num < radix {\n         unsafe {"}, {"sha": "efa24fa96f8c3ec1f73824b3df00e9edb39cd301", "filename": "src/libcore/failure.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibcore%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibcore%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffailure.rs?ref=e4271cae54c7f4a868c60a1822b91e702e511947", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Failure support for libcore\n+\n+#![allow(dead_code)]\n+\n+use str::raw::c_str_to_static_slice;\n+\n+// FIXME: Once std::fmt is in libcore, all of these functions should delegate\n+//        to a common failure function with this signature:\n+//\n+//          extern {\n+//              fn rust_unwind(f: &fmt::Arguments, file: &str, line: uint) -> !;\n+//          }\n+//\n+//        Each of these functions can create a temporary fmt::Arguments\n+//        structure to pass to this function.\n+\n+#[cold] #[inline(never)] // this is the slow path, always\n+#[lang=\"fail_\"]\n+#[cfg(not(test))]\n+fn fail_(expr: *u8, file: *u8, line: uint) -> ! {\n+    unsafe {\n+        let expr = c_str_to_static_slice(expr as *i8);\n+        let file = c_str_to_static_slice(file as *i8);\n+        begin_unwind(expr, file, line)\n+    }\n+}\n+\n+#[cold]\n+#[lang=\"fail_bounds_check\"]\n+#[cfg(not(test))]\n+fn fail_bounds_check(file: *u8, line: uint, index: uint, len: uint) -> ! {\n+    #[allow(ctypes)]\n+    extern { fn rust_fail_bounds_check(file: *u8, line: uint,\n+                                       index: uint, len: uint,) -> !; }\n+    unsafe { rust_fail_bounds_check(file, line, index, len) }\n+}\n+\n+#[cold]\n+pub fn begin_unwind(msg: &str, file: &'static str, line: uint) -> ! {\n+    #[allow(ctypes)]\n+    extern { fn rust_begin_unwind(msg: &str, file: &'static str,\n+                                  line: uint) -> !; }\n+    unsafe { rust_begin_unwind(msg, file, line) }\n+}"}, {"sha": "a0938c83eca01ba5c9a1707be04ef92d2c793597", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=e4271cae54c7f4a868c60a1822b91e702e511947", "patch": "@@ -21,6 +21,8 @@\n #![feature(globs, macro_rules, managed_boxes)]\n #![deny(missing_doc)]\n \n+mod macros;\n+\n #[path = \"num/float_macros.rs\"] mod float_macros;\n #[path = \"num/int_macros.rs\"]   mod int_macros;\n #[path = \"num/uint_macros.rs\"]  mod uint_macros;\n@@ -75,7 +77,11 @@ pub mod slice;\n pub mod str;\n pub mod tuple;\n \n-// FIXME: this module should not exist\n+mod failure;\n+\n+// FIXME: this module should not exist. Once owned allocations are no longer a\n+//        language type, this module can move outside to the owned allocation\n+//        crate.\n mod should_not_exist;\n \n mod std {"}, {"sha": "50d5cd81ba00e701d2980931ef174cdd958fa79d", "filename": "src/libcore/macros.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=e4271cae54c7f4a868c60a1822b91e702e511947", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![macro_escape]\n+\n+/// Entry point of failure, for details, see std::macros\n+#[macro_export]\n+macro_rules! fail(\n+    () => (\n+        fail!(\"explicit failure\")\n+    );\n+    ($msg:expr) => (\n+        ::failure::begin_unwind($msg, file!(), line!())\n+    );\n+)\n+\n+/// Runtime assertion, for details see std::macros\n+#[macro_export]\n+macro_rules! assert(\n+    ($cond:expr) => (\n+        if !$cond {\n+            fail!(concat!(\"assertion failed: \", stringify!($cond)))\n+        }\n+    );\n+)\n+\n+/// Runtime assertion, disableable at compile time\n+#[macro_export]\n+macro_rules! debug_assert(\n+    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n+)"}, {"sha": "771d801dcb7d72d7eb45b93402e27cca9ad3d559", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=e4271cae54c7f4a868c60a1822b91e702e511947", "patch": "@@ -255,7 +255,7 @@ mod tests {\n     fn test_overflows() {\n         assert!(MAX > 0);\n         assert!(MIN <= 0);\n-        assert_eq!(MIN + MAX + 1, 0);\n+        assert!(MIN + MAX + 1 == 0);\n     }\n \n     #[test]\n@@ -265,25 +265,25 @@ mod tests {\n \n     #[test]\n     pub fn test_abs() {\n-        assert_eq!((1 as $T).abs(), 1 as $T);\n-        assert_eq!((0 as $T).abs(), 0 as $T);\n-        assert_eq!((-1 as $T).abs(), 1 as $T);\n+        assert!((1 as $T).abs() == 1 as $T);\n+        assert!((0 as $T).abs() == 0 as $T);\n+        assert!((-1 as $T).abs() == 1 as $T);\n     }\n \n     #[test]\n     fn test_abs_sub() {\n-        assert_eq!((-1 as $T).abs_sub(&(1 as $T)), 0 as $T);\n-        assert_eq!((1 as $T).abs_sub(&(1 as $T)), 0 as $T);\n-        assert_eq!((1 as $T).abs_sub(&(0 as $T)), 1 as $T);\n-        assert_eq!((1 as $T).abs_sub(&(-1 as $T)), 2 as $T);\n+        assert!((-1 as $T).abs_sub(&(1 as $T)) == 0 as $T);\n+        assert!((1 as $T).abs_sub(&(1 as $T)) == 0 as $T);\n+        assert!((1 as $T).abs_sub(&(0 as $T)) == 1 as $T);\n+        assert!((1 as $T).abs_sub(&(-1 as $T)) == 2 as $T);\n     }\n \n     #[test]\n     fn test_signum() {\n-        assert_eq!((1 as $T).signum(), 1 as $T);\n-        assert_eq!((0 as $T).signum(), 0 as $T);\n-        assert_eq!((-0 as $T).signum(), 0 as $T);\n-        assert_eq!((-1 as $T).signum(), -1 as $T);\n+        assert!((1 as $T).signum() == 1 as $T);\n+        assert!((0 as $T).signum() == 0 as $T);\n+        assert!((-0 as $T).signum() == 0 as $T);\n+        assert!((-1 as $T).signum() == -1 as $T);\n     }\n \n     #[test]\n@@ -304,33 +304,33 @@ mod tests {\n \n     #[test]\n     fn test_bitwise() {\n-        assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(&(0b1010 as $T)));\n-        assert_eq!(0b1000 as $T, (0b1100 as $T).bitand(&(0b1010 as $T)));\n-        assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(&(0b1010 as $T)));\n-        assert_eq!(0b1110 as $T, (0b0111 as $T).shl(&(1 as $T)));\n-        assert_eq!(0b0111 as $T, (0b1110 as $T).shr(&(1 as $T)));\n-        assert_eq!(-(0b11 as $T) - (1 as $T), (0b11 as $T).not());\n+        assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n+        assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n+        assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n+        assert!(0b1110 as $T == (0b0111 as $T).shl(&(1 as $T)));\n+        assert!(0b0111 as $T == (0b1110 as $T).shr(&(1 as $T)));\n+        assert!(-(0b11 as $T) - (1 as $T) == (0b11 as $T).not());\n     }\n \n     #[test]\n     fn test_count_ones() {\n-        assert_eq!((0b0101100 as $T).count_ones(), 3);\n-        assert_eq!((0b0100001 as $T).count_ones(), 2);\n-        assert_eq!((0b1111001 as $T).count_ones(), 5);\n+        assert!((0b0101100 as $T).count_ones() == 3);\n+        assert!((0b0100001 as $T).count_ones() == 2);\n+        assert!((0b1111001 as $T).count_ones() == 5);\n     }\n \n     #[test]\n     fn test_count_zeros() {\n-        assert_eq!((0b0101100 as $T).count_zeros(), BITS as $T - 3);\n-        assert_eq!((0b0100001 as $T).count_zeros(), BITS as $T - 2);\n-        assert_eq!((0b1111001 as $T).count_zeros(), BITS as $T - 5);\n+        assert!((0b0101100 as $T).count_zeros() == BITS as $T - 3);\n+        assert!((0b0100001 as $T).count_zeros() == BITS as $T - 2);\n+        assert!((0b1111001 as $T).count_zeros() == BITS as $T - 5);\n     }\n \n     #[test]\n     fn test_signed_checked_div() {\n-        assert_eq!(10i.checked_div(&2), Some(5));\n-        assert_eq!(5i.checked_div(&0), None);\n-        assert_eq!(int::MIN.checked_div(&-1), None);\n+        assert!(10i.checked_div(&2) == Some(5));\n+        assert!(5i.checked_div(&0) == None);\n+        assert!(int::MIN.checked_div(&-1) == None);\n     }\n }\n "}, {"sha": "12aaf41b19670e4730edcffc3bc51942ccf054f0", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=e4271cae54c7f4a868c60a1822b91e702e511947", "patch": "@@ -192,7 +192,7 @@ mod tests {\n     fn test_overflows() {\n         assert!(MAX > 0);\n         assert!(MIN <= 0);\n-        assert_eq!(MIN + MAX + 1, 0);\n+        assert!(MIN + MAX + 1 == 0);\n     }\n \n     #[test]\n@@ -202,32 +202,32 @@ mod tests {\n \n     #[test]\n     fn test_bitwise() {\n-        assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(&(0b1010 as $T)));\n-        assert_eq!(0b1000 as $T, (0b1100 as $T).bitand(&(0b1010 as $T)));\n-        assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(&(0b1010 as $T)));\n-        assert_eq!(0b1110 as $T, (0b0111 as $T).shl(&(1 as $T)));\n-        assert_eq!(0b0111 as $T, (0b1110 as $T).shr(&(1 as $T)));\n-        assert_eq!(MAX - (0b1011 as $T), (0b1011 as $T).not());\n+        assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n+        assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n+        assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n+        assert!(0b1110 as $T == (0b0111 as $T).shl(&(1 as $T)));\n+        assert!(0b0111 as $T == (0b1110 as $T).shr(&(1 as $T)));\n+        assert!(MAX - (0b1011 as $T) == (0b1011 as $T).not());\n     }\n \n     #[test]\n     fn test_count_ones() {\n-        assert_eq!((0b0101100 as $T).count_ones(), 3);\n-        assert_eq!((0b0100001 as $T).count_ones(), 2);\n-        assert_eq!((0b1111001 as $T).count_ones(), 5);\n+        assert!((0b0101100 as $T).count_ones() == 3);\n+        assert!((0b0100001 as $T).count_ones() == 2);\n+        assert!((0b1111001 as $T).count_ones() == 5);\n     }\n \n     #[test]\n     fn test_count_zeros() {\n-        assert_eq!((0b0101100 as $T).count_zeros(), BITS as $T - 3);\n-        assert_eq!((0b0100001 as $T).count_zeros(), BITS as $T - 2);\n-        assert_eq!((0b1111001 as $T).count_zeros(), BITS as $T - 5);\n+        assert!((0b0101100 as $T).count_zeros() == BITS as $T - 3);\n+        assert!((0b0100001 as $T).count_zeros() == BITS as $T - 2);\n+        assert!((0b1111001 as $T).count_zeros() == BITS as $T - 5);\n     }\n \n     #[test]\n     fn test_unsigned_checked_div() {\n-        assert_eq!(10u.checked_div(&2), Some(5));\n-        assert_eq!(5u.checked_div(&0), None);\n+        assert!(10u.checked_div(&2) == Some(5));\n+        assert!(5u.checked_div(&0) == None);\n     }\n }\n "}, {"sha": "5b9c314d42b0c688a9254b016a04d0d768afeec1", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=e4271cae54c7f4a868c60a1822b91e702e511947", "patch": "@@ -70,7 +70,7 @@ use self::task::{Task, BlockedTask};\n pub use self::util::default_sched_threads;\n \n // Export unwinding facilities used by the failure macros\n-pub use self::unwind::{begin_unwind, begin_unwind_raw, begin_unwind_fmt};\n+pub use self::unwind::{begin_unwind, begin_unwind_fmt};\n \n pub use self::util::{Stdio, Stdout, Stderr};\n "}, {"sha": "5f3731eb819d3b68e9848c1b78a4d7f8dcb58cb3", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 11, "deletions": 31, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4271cae54c7f4a868c60a1822b91e702e511947/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=e4271cae54c7f4a868c60a1822b91e702e511947", "patch": "@@ -58,7 +58,6 @@\n // Currently Rust uses unwind runtime provided by libgcc.\n \n use any::{Any, AnyRefExt};\n-use c_str::CString;\n use cast;\n use fmt;\n use kinds::Send;\n@@ -298,42 +297,23 @@ pub mod eabi {\n }\n \n #[cold]\n-#[lang=\"fail_\"]\n+#[no_mangle]\n #[cfg(not(test))]\n-pub fn fail_(expr: *u8, file: *u8, line: uint) -> ! {\n-    begin_unwind_raw(expr, file, line);\n-}\n-\n-#[cold]\n-#[lang=\"fail_bounds_check\"]\n-#[cfg(not(test))]\n-pub fn fail_bounds_check(file: *u8, line: uint, index: uint, len: uint) -> ! {\n-    use c_str::ToCStr;\n+pub extern fn rust_fail_bounds_check(file: *u8, line: uint,\n+                                     index: uint, len: uint) -> ! {\n+    use str::raw::c_str_to_static_slice;\n \n     let msg = format!(\"index out of bounds: the len is {} but the index is {}\",\n                       len as uint, index as uint);\n-    msg.with_c_str(|buf| fail_(buf as *u8, file, line))\n+    begin_unwind(msg, unsafe { c_str_to_static_slice(file as *i8) }, line)\n }\n \n-/// This is the entry point of unwinding for things like lang items and such.\n-/// The arguments are normally generated by the compiler, and need to\n-/// have static lifetimes.\n-#[inline(never)] #[cold] // this is the slow path, please never inline this\n-pub fn begin_unwind_raw(msg: *u8, file: *u8, line: uint) -> ! {\n-    use libc::c_char;\n-    #[inline]\n-    fn static_char_ptr(p: *u8) -> &'static str {\n-        let s = unsafe { CString::new(p as *c_char, false) };\n-        match s.as_str() {\n-            Some(s) => unsafe { cast::transmute::<&str, &'static str>(s) },\n-            None => rtabort!(\"message wasn't utf8?\")\n-        }\n-    }\n-\n-    let msg = static_char_ptr(msg);\n-    let file = static_char_ptr(file);\n-\n-    begin_unwind(msg, file, line as uint)\n+// Entry point of failure from the libcore crate\n+#[no_mangle]\n+#[cfg(not(test))]\n+pub extern fn rust_begin_unwind(msg: &str, file: &'static str, line: uint) -> ! {\n+    use str::StrAllocating;\n+    begin_unwind(msg.to_owned(), file, line)\n }\n \n /// The entry point for unwinding with a formatted message."}]}