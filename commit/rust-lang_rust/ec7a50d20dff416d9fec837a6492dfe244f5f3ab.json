{"sha": "ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjN2E1MGQyMGRmZjQxNmQ5ZmVjODM3YTY0OTJkZmUyNDRmNWYzYWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-25T21:28:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-05T16:00:13Z"}, "message": "std: Redesign c_str and c_vec\n\nThis commit is an implementation of [RFC 494][rfc] which removes the entire\n`std::c_vec` module and redesigns the `std::c_str` module as `std::ffi`.\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0494-c_str-and-c_vec-stability.md\n\nThe interface of the new `CString` is outlined in the linked RFC, the primary\nchanges being:\n\n* The `ToCStr` trait is gone, meaning the `with_c_str` and `to_c_str` methods\n  are now gone. These two methods are replaced with a `CString::from_slice`\n  method.\n* The `CString` type is now just a wrapper around `Vec<u8>` with a static\n  guarantee that there is a trailing nul byte with no internal nul bytes. This\n  means that `CString` now implements `Deref<Target = [c_char]>`, which is where\n  it gains most of its methods from. A few helper methods are added to acquire a\n  slice of `u8` instead of `c_char`, as well as including a slice with the\n  trailing nul byte if necessary.\n* All usage of non-owned `CString` values is now done via two functions inside\n  of `std::ffi`, called `c_str_to_bytes` and `c_str_to_bytes_with_nul`. These\n  functions are now the one method used to convert a `*const c_char` to a Rust\n  slice of `u8`.\n\nMany more details, including newly deprecated methods, can be found linked in\nthe RFC. This is a:\n\n[breaking-change]\nCloses #20444", "tree": {"sha": "559c2e05abb4f51d6309a1af3f4e1953a6627e3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/559c2e05abb4f51d6309a1af3f4e1953a6627e3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "html_url": "https://github.com/rust-lang/rust/commit/ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f732ef53d54ccfc3e7728390ffbcea8a696ecee", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f732ef53d54ccfc3e7728390ffbcea8a696ecee", "html_url": "https://github.com/rust-lang/rust/commit/1f732ef53d54ccfc3e7728390ffbcea8a696ecee"}], "stats": {"total": 3026, "additions": 1023, "deletions": 2003}, "files": [{"sha": "7ee1c1a7032a5c4fce6975e1c9d0e0201fe4dbe7", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -451,7 +451,7 @@ them.\n ~~~no_run\n extern crate libc;\n \n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::ptr;\n \n #[link(name = \"readline\")]\n@@ -460,11 +460,10 @@ extern {\n }\n \n fn main() {\n-    \"[my-awesome-shell] $\".with_c_str(|buf| {\n-        unsafe { rl_prompt = buf; }\n-        // get a line, process it\n-        unsafe { rl_prompt = ptr::null(); }\n-    });\n+    let prompt = CString::from_slice(b\"[my-awesome-shell] $\");\n+    unsafe { rl_prompt = prompt.as_ptr(); }\n+    // get a line, process it\n+    unsafe { rl_prompt = ptr::null(); }\n }\n ~~~\n \n@@ -509,23 +508,28 @@ to define a block for all windows systems, not just x86 ones.\n \n # Interoperability with foreign code\n \n-Rust guarantees that the layout of a `struct` is compatible with the platform's representation in C\n-only if the `#[repr(C)]` attribute is applied to it.  `#[repr(C, packed)]` can be used to lay out\n-struct members without padding.  `#[repr(C)]` can also be applied to an enum.\n-\n-Rust's owned boxes (`Box<T>`) use non-nullable pointers as handles which point to the contained\n-object. However, they should not be manually created because they are managed by internal\n-allocators. References can safely be assumed to be non-nullable pointers directly to the type.\n-However, breaking the borrow checking or mutability rules is not guaranteed to be safe, so prefer\n-using raw pointers (`*`) if that's needed because the compiler can't make as many assumptions about\n-them.\n-\n-Vectors and strings share the same basic memory layout, and utilities are available in the `vec` and\n-`str` modules for working with C APIs. However, strings are not terminated with `\\0`. If you need a\n-NUL-terminated string for interoperability with C, you should use the `c_str::to_c_str` function.\n-\n-The standard library includes type aliases and function definitions for the C standard library in\n-the `libc` module, and Rust links against `libc` and `libm` by default.\n+Rust guarantees that the layout of a `struct` is compatible with the platform's\n+representation in C only if the `#[repr(C)]` attribute is applied to it.\n+`#[repr(C, packed)]` can be used to lay out struct members without padding.\n+`#[repr(C)]` can also be applied to an enum.\n+\n+Rust's owned boxes (`Box<T>`) use non-nullable pointers as handles which point\n+to the contained object. However, they should not be manually created because\n+they are managed by internal allocators. References can safely be assumed to be\n+non-nullable pointers directly to the type.  However, breaking the borrow\n+checking or mutability rules is not guaranteed to be safe, so prefer using raw\n+pointers (`*`) if that's needed because the compiler can't make as many\n+assumptions about them.\n+\n+Vectors and strings share the same basic memory layout, and utilities are\n+available in the `vec` and `str` modules for working with C APIs. However,\n+strings are not terminated with `\\0`. If you need a NUL-terminated string for\n+interoperability with C, you should use the `CString` type in the `std::ffi`\n+module.\n+\n+The standard library includes type aliases and function definitions for the C\n+standard library in the `libc` module, and Rust links against `libc` and `libm`\n+by default.\n \n # The \"nullable pointer optimization\"\n "}, {"sha": "11e6c48cfdbad52209f5eaefbe1c34f22183baa3", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -320,30 +320,6 @@ impl String {\n         }\n     }\n \n-    /// Creates a `String` from a null-terminated `*const u8` buffer.\n-    ///\n-    /// This function is unsafe because we dereference memory until we find the\n-    /// NUL character, which is not guaranteed to be present. Additionally, the\n-    /// slice is not checked to see whether it contains valid UTF-8\n-    #[unstable = \"just renamed from `mod raw`\"]\n-    pub unsafe fn from_raw_buf(buf: *const u8) -> String {\n-        String::from_str(str::from_c_str(buf as *const i8))\n-    }\n-\n-    /// Creates a `String` from a `*const u8` buffer of the given length.\n-    ///\n-    /// This function is unsafe because it blindly assumes the validity of the\n-    /// pointer `buf` for `len` bytes of memory. This function will copy the\n-    /// memory from `buf` into a new allocation (owned by the returned\n-    /// `String`).\n-    ///\n-    /// This function is also unsafe because it does not validate that the\n-    /// buffer is valid UTF-8 encoded data.\n-    #[unstable = \"just renamed from `mod raw`\"]\n-    pub unsafe fn from_raw_buf_len(buf: *const u8, len: uint) -> String {\n-        String::from_utf8_unchecked(Vec::from_raw_buf(buf, len))\n-    }\n-\n     /// Converts a vector of bytes to a new `String` without checking if\n     /// it contains valid UTF-8. This is unsafe because it assumes that\n     /// the UTF-8-ness of the vector has already been validated.\n@@ -1126,24 +1102,6 @@ mod tests {\n                    String::from_str(\"\\u{FFFD}\ud801\udc8b\\u{FFFD}\"));\n     }\n \n-    #[test]\n-    fn test_from_buf_len() {\n-        unsafe {\n-            let a = vec![65u8, 65, 65, 65, 65, 65, 65, 0];\n-            assert_eq!(String::from_raw_buf_len(a.as_ptr(), 3), String::from_str(\"AAA\"));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_buf() {\n-        unsafe {\n-            let a = vec![65, 65, 65, 65, 65, 65, 65, 0];\n-            let b = a.as_ptr();\n-            let c = String::from_raw_buf(b);\n-            assert_eq!(c, String::from_str(\"AAAAAAA\"));\n-        }\n-    }\n-\n     #[test]\n     fn test_push_bytes() {\n         let mut s = String::from_str(\"ABC\");"}, {"sha": "8fdd66f83cee4c205d52827a970f6720222a5aca", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -190,7 +190,7 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n /// # Panics\n ///\n /// This function will panic if the string pointed to by `s` is not valid UTF-8.\n-#[unstable = \"may change location based on the outcome of the c_str module\"]\n+#[deprecated = \"use std::ffi::c_str_to_bytes + str::from_utf8\"]\n pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n     let s = s as *const u8;\n     let mut len = 0u;"}, {"sha": "a0c9da3ae6d497a3ddeb818a189c0b2a597f956c", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -21,15 +21,34 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(phase, unboxed_closures)]\n+#![feature(phase, unboxed_closures, associated_types)]\n \n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n extern crate libc;\n \n use libc::{c_void, size_t, c_int};\n-use std::c_vec::CVec;\n+use std::ops::Deref;\n use std::ptr::Unique;\n+use std::slice;\n+\n+pub struct Bytes {\n+    ptr: Unique<u8>,\n+    len: uint,\n+}\n+\n+impl Deref for Bytes {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        unsafe { slice::from_raw_mut_buf(&self.ptr.0, self.len) }\n+    }\n+}\n+\n+impl Drop for Bytes {\n+    fn drop(&mut self) {\n+        unsafe { libc::free(self.ptr.0 as *mut _); }\n+    }\n+}\n \n #[link(name = \"miniz\", kind = \"static\")]\n extern {\n@@ -52,55 +71,55 @@ static LZ_NORM : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n static TINFL_FLAG_PARSE_ZLIB_HEADER : c_int = 0x1; // parse zlib header and adler32 checksum\n static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler32 checksum\n \n-fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n+fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<Bytes> {\n     unsafe {\n         let mut outsz : size_t = 0;\n         let res = tdefl_compress_mem_to_heap(bytes.as_ptr() as *const _,\n                                              bytes.len() as size_t,\n                                              &mut outsz,\n                                              flags);\n         if !res.is_null() {\n-            let res = Unique(res);\n-            Some(CVec::new_with_dtor(res.0 as *mut u8, outsz as uint, move|:| libc::free(res.0)))\n+            let res = Unique(res as *mut u8);\n+            Some(Bytes { ptr: res, len: outsz as uint })\n         } else {\n             None\n         }\n     }\n }\n \n /// Compress a buffer, without writing any sort of header on the output.\n-pub fn deflate_bytes(bytes: &[u8]) -> Option<CVec<u8>> {\n+pub fn deflate_bytes(bytes: &[u8]) -> Option<Bytes> {\n     deflate_bytes_internal(bytes, LZ_NORM)\n }\n \n /// Compress a buffer, using a header that zlib can understand.\n-pub fn deflate_bytes_zlib(bytes: &[u8]) -> Option<CVec<u8>> {\n+pub fn deflate_bytes_zlib(bytes: &[u8]) -> Option<Bytes> {\n     deflate_bytes_internal(bytes, LZ_NORM | TDEFL_WRITE_ZLIB_HEADER)\n }\n \n-fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n+fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<Bytes> {\n     unsafe {\n         let mut outsz : size_t = 0;\n         let res = tinfl_decompress_mem_to_heap(bytes.as_ptr() as *const _,\n                                                bytes.len() as size_t,\n                                                &mut outsz,\n                                                flags);\n         if !res.is_null() {\n-            let res = Unique(res);\n-            Some(CVec::new_with_dtor(res.0 as *mut u8, outsz as uint, move|:| libc::free(res.0)))\n+            let res = Unique(res as *mut u8);\n+            Some(Bytes { ptr: res, len: outsz as uint })\n         } else {\n             None\n         }\n     }\n }\n \n /// Decompress a buffer, without parsing any sort of header on the input.\n-pub fn inflate_bytes(bytes: &[u8]) -> Option<CVec<u8>> {\n+pub fn inflate_bytes(bytes: &[u8]) -> Option<Bytes> {\n     inflate_bytes_internal(bytes, 0)\n }\n \n /// Decompress a buffer that starts with a zlib header.\n-pub fn inflate_bytes_zlib(bytes: &[u8]) -> Option<CVec<u8>> {\n+pub fn inflate_bytes_zlib(bytes: &[u8]) -> Option<Bytes> {\n     inflate_bytes_internal(bytes, TINFL_FLAG_PARSE_ZLIB_HEADER)\n }\n "}, {"sha": "ec0b80c3a5342f26b6af6563ab6a628b0f2810b1", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -23,8 +23,8 @@ use metadata::loader;\n use util::nodemap::{FnvHashMap, NodeMap};\n \n use std::cell::RefCell;\n-use std::c_vec::CVec;\n use std::rc::Rc;\n+use flate::Bytes;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::IdentInterner;\n@@ -36,7 +36,7 @@ use syntax::parse::token::IdentInterner;\n pub type cnum_map = FnvHashMap<ast::CrateNum, ast::CrateNum>;\n \n pub enum MetadataBlob {\n-    MetadataVec(CVec<u8>),\n+    MetadataVec(Bytes),\n     MetadataArchive(loader::ArchiveMetadata),\n }\n "}, {"sha": "7c0645b4ca204037c451ef1c62f6232a7c547360", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -226,7 +226,7 @@ use syntax::codemap::Span;\n use syntax::diagnostic::SpanHandler;\n use util::fs;\n \n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::cmp;\n use std::collections::{HashMap, HashSet};\n use std::io::fs::PathExtensions;\n@@ -720,9 +720,8 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n         }\n     }\n     unsafe {\n-        let mb = filename.with_c_str(|buf| {\n-            llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-        });\n+        let buf = CString::from_slice(filename.as_vec());\n+        let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n         if mb as int == 0 {\n             return Err(format!(\"error reading library: '{}'\",\n                                filename.display()))\n@@ -738,8 +737,9 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let mut name_buf = ptr::null();\n             let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = String::from_raw_buf_len(name_buf as *const u8,\n-                                                name_len as uint);\n+            let name = slice::from_raw_buf(&(name_buf as *const u8),\n+                                           name_len as uint).to_vec();\n+            let name = String::from_utf8(name).unwrap();\n             debug!(\"get_metadata_section: name {}\", name);\n             if read_meta_section_name(is_osx) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);"}, {"sha": "d3555e4c0436354055399d04ab1cbb2f58995c97", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -13,7 +13,7 @@\n use libc;\n use ArchiveRef;\n \n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::mem;\n use std::raw;\n \n@@ -30,9 +30,8 @@ impl ArchiveRO {\n     /// raised.\n     pub fn open(dst: &Path) -> Option<ArchiveRO> {\n         unsafe {\n-            let ar = dst.with_c_str(|dst| {\n-                ::LLVMRustOpenArchive(dst)\n-            });\n+            let s = CString::from_slice(dst.as_vec());\n+            let ar = ::LLVMRustOpenArchive(s.as_ptr());\n             if ar.is_null() {\n                 None\n             } else {\n@@ -45,9 +44,9 @@ impl ArchiveRO {\n     pub fn read<'a>(&'a self, file: &str) -> Option<&'a [u8]> {\n         unsafe {\n             let mut size = 0 as libc::size_t;\n-            let ptr = file.with_c_str(|file| {\n-                ::LLVMRustArchiveReadSection(self.ptr, file, &mut size)\n-            });\n+            let file = CString::from_slice(file.as_bytes());\n+            let ptr = ::LLVMRustArchiveReadSection(self.ptr, file.as_ptr(),\n+                                                   &mut size);\n             if ptr.is_null() {\n                 None\n             } else {"}, {"sha": "854ac5ff5c01cafedf48cc71c1cb8ad6f35d996e", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -47,7 +47,7 @@ pub use self::Visibility::*;\n pub use self::DiagnosticSeverity::*;\n pub use self::Linkage::*;\n \n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::cell::RefCell;\n use std::{raw, mem};\n use libc::{c_uint, c_ushort, uint64_t, c_int, size_t, c_char};\n@@ -2114,10 +2114,9 @@ impl Drop for TargetData {\n }\n \n pub fn mk_target_data(string_rep: &str) -> TargetData {\n+    let string_rep = CString::from_slice(string_rep.as_bytes());\n     TargetData {\n-        lltd: string_rep.with_c_str(|buf| {\n-            unsafe { LLVMCreateTargetData(buf) }\n-        })\n+        lltd: unsafe { LLVMCreateTargetData(string_rep.as_ptr()) }\n     }\n }\n "}, {"sha": "f3e90c43a8414961bcdb979fb15f9dbada402d85", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -20,7 +20,7 @@ use rustc::util::common::time;\n use libc;\n use flate;\n \n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::iter;\n use std::mem;\n use std::num::Int;\n@@ -139,9 +139,10 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     }\n \n     // Internalize everything but the reachable symbols of the current module\n-    let cstrs: Vec<::std::c_str::CString> =\n-        reachable.iter().map(|s| s.to_c_str()).collect();\n-    let arr: Vec<*const libc::c_char> = cstrs.iter().map(|c| c.as_ptr()).collect();\n+    let cstrs: Vec<CString> = reachable.iter().map(|s| {\n+        CString::from_slice(s.as_bytes())\n+    }).collect();\n+    let arr: Vec<*const i8> = cstrs.iter().map(|c| c.as_ptr()).collect();\n     let ptr = arr.as_ptr();\n     unsafe {\n         llvm::LLVMRustRunRestrictionPass(llmod,\n@@ -164,15 +165,15 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     unsafe {\n         let pm = llvm::LLVMCreatePassManager();\n         llvm::LLVMRustAddAnalysisPasses(tm, pm, llmod);\n-        \"verify\".with_c_str(|s| llvm::LLVMRustAddPass(pm, s));\n+        llvm::LLVMRustAddPass(pm, \"verify\\0\".as_ptr() as *const _);\n \n         let builder = llvm::LLVMPassManagerBuilderCreate();\n         llvm::LLVMPassManagerBuilderPopulateLTOPassManager(builder, pm,\n             /* Internalize = */ False,\n             /* RunInliner = */ True);\n         llvm::LLVMPassManagerBuilderDispose(builder);\n \n-        \"verify\".with_c_str(|s| llvm::LLVMRustAddPass(pm, s));\n+        llvm::LLVMRustAddPass(pm, \"verify\\0\".as_ptr() as *const _);\n \n         time(sess.time_passes(), \"LTO passes\", (), |()|\n              llvm::LLVMRunPassManager(pm, llmod));"}, {"sha": "089d7f737d3cf4703376bc9c4901c4d322fe38ea", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 55, "deletions": 57, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -22,7 +22,7 @@ use syntax::codemap;\n use syntax::diagnostic;\n use syntax::diagnostic::{Emitter, Handler, Level, mk_handler};\n \n-use std::c_str::{ToCStr, CString};\n+use std::ffi::{mod, CString};\n use std::io::Command;\n use std::io::fs;\n use std::iter::Unfold;\n@@ -32,7 +32,7 @@ use std::mem;\n use std::sync::{Arc, Mutex};\n use std::sync::mpsc::channel;\n use std::thread;\n-use libc::{c_uint, c_int, c_void};\n+use libc::{mod, c_uint, c_int, c_void};\n \n #[derive(Clone, Copy, PartialEq, PartialOrd, Ord, Eq)]\n pub enum OutputType {\n@@ -49,8 +49,9 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n         if cstr == ptr::null() {\n             handler.fatal(msg[]);\n         } else {\n-            let err = CString::new(cstr, true);\n-            let err = String::from_utf8_lossy(err.as_bytes());\n+            let err = ffi::c_str_to_bytes(&cstr);\n+            let err = String::from_utf8_lossy(err.as_slice()).to_string();\n+            libc::free(cstr as *mut _);\n             handler.fatal(format!(\"{}: {}\",\n                                   msg[],\n                                   err[])[]);\n@@ -66,13 +67,12 @@ pub fn write_output_file(\n         output: &Path,\n         file_type: llvm::FileType) {\n     unsafe {\n-        output.with_c_str(|output| {\n-            let result = llvm::LLVMRustWriteOutputFile(\n-                    target, pm, m, output, file_type);\n-            if !result {\n-                llvm_err(handler, \"could not write output\".to_string());\n-            }\n-        })\n+        let output = CString::from_slice(output.as_vec());\n+        let result = llvm::LLVMRustWriteOutputFile(\n+                target, pm, m, output.as_ptr(), file_type);\n+        if !result {\n+            llvm_err(handler, \"could not write output\".to_string());\n+        }\n     }\n }\n \n@@ -221,28 +221,25 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let triple = sess.target.target.llvm_target[];\n \n     let tm = unsafe {\n-        triple.with_c_str(|t| {\n-            let cpu = match sess.opts.cg.target_cpu {\n-                Some(ref s) => s[],\n-                None => sess.target.target.options.cpu[]\n-            };\n-            cpu.with_c_str(|cpu| {\n-                target_feature(sess).with_c_str(|features| {\n-                    llvm::LLVMRustCreateTargetMachine(\n-                        t, cpu, features,\n-                        code_model,\n-                        reloc_model,\n-                        opt_level,\n-                        true /* EnableSegstk */,\n-                        use_softfp,\n-                        no_fp_elim,\n-                        !any_library && reloc_model == llvm::RelocPIC,\n-                        ffunction_sections,\n-                        fdata_sections,\n-                    )\n-                })\n-            })\n-        })\n+        let triple = CString::from_slice(triple.as_bytes());\n+        let cpu = match sess.opts.cg.target_cpu {\n+            Some(ref s) => s.as_slice(),\n+            None => sess.target.target.options.cpu.as_slice()\n+        };\n+        let cpu = CString::from_slice(cpu.as_bytes());\n+        let features = CString::from_slice(target_feature(sess).as_bytes());\n+        llvm::LLVMRustCreateTargetMachine(\n+            triple.as_ptr(), cpu.as_ptr(), features.as_ptr(),\n+            code_model,\n+            reloc_model,\n+            opt_level,\n+            true /* EnableSegstk */,\n+            use_softfp,\n+            no_fp_elim,\n+            !any_library && reloc_model == llvm::RelocPIC,\n+            ffunction_sections,\n+            fdata_sections,\n+        )\n     };\n \n     if tm.is_null() {\n@@ -371,8 +368,9 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n \n     match llvm::diagnostic::Diagnostic::unpack(info) {\n         llvm::diagnostic::Optimization(opt) => {\n-            let pass_name = CString::new(opt.pass_name, false);\n-            let pass_name = pass_name.as_str().expect(\"got a non-UTF8 pass name from LLVM\");\n+            let pass_name = str::from_utf8(ffi::c_str_to_bytes(&opt.pass_name))\n+                                .ok()\n+                                .expect(\"got a non-UTF8 pass name from LLVM\");\n             let enabled = match cgcx.remark {\n                 AllPasses => true,\n                 SomePasses(ref v) => v.iter().any(|s| *s == pass_name),\n@@ -416,9 +414,9 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n     if config.emit_no_opt_bc {\n         let ext = format!(\"{}.no-opt.bc\", name_extra);\n-        output_names.with_extension(ext[]).with_c_str(|buf| {\n-            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-        })\n+        let out = output_names.with_extension(ext.as_slice());\n+        let out = CString::from_slice(out.as_vec());\n+        llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n     match config.opt_level {\n@@ -433,7 +431,8 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             // If we're verifying or linting, add them to the function pass\n             // manager.\n             let addpass = |&: pass: &str| {\n-                pass.with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n+                let pass = CString::from_slice(pass.as_bytes());\n+                llvm::LLVMRustAddPass(fpm, pass.as_ptr())\n             };\n             if !config.no_verify { assert!(addpass(\"verify\")); }\n \n@@ -445,12 +444,11 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             }\n \n             for pass in config.passes.iter() {\n-                pass.with_c_str(|s| {\n-                    if !llvm::LLVMRustAddPass(mpm, s) {\n-                        cgcx.handler.warn(format!(\"unknown pass {}, ignoring\",\n-                                                  *pass)[]);\n-                    }\n-                })\n+                let pass = CString::from_slice(pass.as_bytes());\n+                if !llvm::LLVMRustAddPass(mpm, pass.as_ptr()) {\n+                    cgcx.handler.warn(format!(\"unknown pass {}, ignoring\",\n+                                              pass).as_slice());\n+                }\n             }\n \n             // Finally, run the actual optimization passes\n@@ -470,9 +468,9 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n                     if config.emit_lto_bc {\n                         let name = format!(\"{}.lto.bc\", name_extra);\n-                        output_names.with_extension(name[]).with_c_str(|buf| {\n-                            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                        })\n+                        let out = output_names.with_extension(name.as_slice());\n+                        let out = CString::from_slice(out.as_vec());\n+                        llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n                     }\n                 },\n                 _ => {},\n@@ -504,18 +502,18 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n     if config.emit_bc {\n         let ext = format!(\"{}.bc\", name_extra);\n-        output_names.with_extension(ext[]).with_c_str(|buf| {\n-            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-        })\n+        let out = output_names.with_extension(ext.as_slice());\n+        let out = CString::from_slice(out.as_vec());\n+        llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n     time(config.time_passes, \"codegen passes\", (), |()| {\n         if config.emit_ir {\n             let ext = format!(\"{}.ll\", name_extra);\n-            output_names.with_extension(ext[]).with_c_str(|output| {\n-                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                    llvm::LLVMRustPrintModule(cpm, llmod, output);\n-                })\n+            let out = output_names.with_extension(ext.as_slice());\n+            let out = CString::from_slice(out.as_vec());\n+            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr());\n             })\n         }\n \n@@ -995,7 +993,7 @@ unsafe fn configure_llvm(sess: &Session) {\n     let mut llvm_args = Vec::new();\n     {\n         let mut add = |&mut : arg: &str| {\n-            let s = arg.to_c_str();\n+            let s = CString::from_slice(arg.as_bytes());\n             llvm_args.push(s.as_ptr());\n             llvm_c_strs.push(s);\n         };\n@@ -1083,7 +1081,7 @@ unsafe fn populate_llvm_passes(fpm: llvm::PassManagerRef,\n \n     match opt {\n         llvm::CodeGenLevelDefault | llvm::CodeGenLevelAggressive => {\n-            \"mergefunc\".with_c_str(|s| llvm::LLVMRustAddPass(mpm, s));\n+            llvm::LLVMRustAddPass(mpm, \"mergefunc\\0\".as_ptr() as *const _);\n         }\n         _ => {}\n     };"}, {"sha": "f18d483f70328bd3389cdc527f445b729c6247ff", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -20,9 +20,8 @@ use trans::expr;\n use trans::type_of;\n use trans::type_::Type;\n \n-use std::c_str::ToCStr;\n-use std::string::String;\n use syntax::ast;\n+use std::ffi::CString;\n use libc::{c_uint, c_char};\n \n // Take an inline assembly expression and splat it out via LLVM\n@@ -121,18 +120,16 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         ast::AsmIntel => llvm::AD_Intel\n     };\n \n-    let r = ia.asm.get().with_c_str(|a| {\n-        constraints.with_c_str(|c| {\n-            InlineAsmCall(bcx,\n-                          a,\n-                          c,\n-                          inputs[],\n+    let asm = CString::from_slice(ia.asm.get().as_bytes());\n+    let constraints = CString::from_slice(constraints.as_bytes());\n+    let r = InlineAsmCall(bcx,\n+                          asm.as_ptr(),\n+                          constraints.as_ptr(),\n+                          inputs.as_slice(),\n                           output_type,\n                           ia.volatile,\n                           ia.alignstack,\n-                          dialect)\n-        })\n-    });\n+                          dialect);\n \n     // Again, based on how many outputs we have\n     if num_outputs == 1 {"}, {"sha": "d9c397d0c159ef6fb85b532cdf51631c299b50ef", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 42, "deletions": 47, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -88,11 +88,12 @@ use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n use libc::{c_uint, uint64_t};\n-use std::c_str::ToCStr;\n+use std::ffi::{mod, CString};\n use std::cell::{Cell, RefCell};\n use std::collections::HashSet;\n use std::mem;\n use std::rc::Rc;\n+use std::str;\n use std::{i8, i16, i32, i64};\n use syntax::abi::{Rust, RustCall, RustIntrinsic, Abi};\n use syntax::ast_util::local_def;\n@@ -187,11 +188,10 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n                ty: Type, output: ty::FnOutput) -> ValueRef {\n \n-    let llfn: ValueRef = name.with_c_str(|buf| {\n-        unsafe {\n-            llvm::LLVMGetOrInsertFunction(ccx.llmod(), buf, ty.to_ref())\n-        }\n-    });\n+    let buf = CString::from_slice(name.as_bytes());\n+    let llfn: ValueRef = unsafe {\n+        llvm::LLVMGetOrInsertFunction(ccx.llmod(), buf.as_ptr(), ty.to_ref())\n+    };\n \n     // diverging functions may unwind, but can never return normally\n     if output == ty::FnDiverging {\n@@ -334,9 +334,8 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n         None => ()\n     }\n     unsafe {\n-        let c = name.with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod(), ty.to_ref(), buf)\n-        });\n+        let buf = CString::from_slice(name.as_bytes());\n+        let c = llvm::LLVMAddGlobal(ccx.llmod(), ty.to_ref(), buf.as_ptr());\n         // Thread-local statics in some other crate need to *always* be linked\n         // against in a thread-local fashion, so we need to be sure to apply the\n         // thread-local attribute locally if it was present remotely. If we\n@@ -475,15 +474,17 @@ pub fn set_always_inline(f: ValueRef) {\n }\n \n pub fn set_split_stack(f: ValueRef) {\n-    \"split-stack\".with_c_str(|buf| {\n-        unsafe { llvm::LLVMAddFunctionAttrString(f, llvm::FunctionIndex as c_uint, buf); }\n-    })\n+    unsafe {\n+        llvm::LLVMAddFunctionAttrString(f, llvm::FunctionIndex as c_uint,\n+                                        \"split-stack\\0\".as_ptr() as *const _);\n+    }\n }\n \n pub fn unset_split_stack(f: ValueRef) {\n-    \"split-stack\".with_c_str(|buf| {\n-        unsafe { llvm::LLVMRemoveFunctionAttrString(f, llvm::FunctionIndex as c_uint, buf); }\n-    })\n+    unsafe {\n+        llvm::LLVMRemoveFunctionAttrString(f, llvm::FunctionIndex as c_uint,\n+                                           \"split-stack\\0\".as_ptr() as *const _);\n+    }\n }\n \n // Double-check that we never ask LLVM to declare the same symbol twice. It\n@@ -537,11 +538,8 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n // Structural comparison: a rather involved form of glue.\n pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n     if cx.sess().opts.cg.save_temps {\n-        s.with_c_str(|buf| {\n-            unsafe {\n-                llvm::LLVMSetValueName(v, buf)\n-            }\n-        })\n+        let buf = CString::from_slice(s.as_bytes());\n+        unsafe { llvm::LLVMSetValueName(v, buf.as_ptr()) }\n     }\n }\n \n@@ -2645,11 +2643,10 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n             unsafe { llvm::LLVMRustSetDLLExportStorageClass(llfn) }\n         }\n \n-        let llbb = \"top\".with_c_str(|buf| {\n-            unsafe {\n-                llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn, buf)\n-            }\n-        });\n+        let llbb = unsafe {\n+            llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn,\n+                                                \"top\\0\".as_ptr() as *const _)\n+        };\n         let bld = ccx.raw_builder();\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n@@ -2670,9 +2667,9 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n                 };\n \n                 let args = {\n-                    let opaque_rust_main = \"rust_main\".with_c_str(|buf| {\n-                        llvm::LLVMBuildPointerCast(bld, rust_main, Type::i8p(ccx).to_ref(), buf)\n-                    });\n+                    let opaque_rust_main = llvm::LLVMBuildPointerCast(bld,\n+                        rust_main, Type::i8p(ccx).to_ref(),\n+                        \"rust_main\\0\".as_ptr() as *const _);\n \n                     vec!(\n                         opaque_rust_main,\n@@ -2779,9 +2776,9 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                 format!(\"Illegal null byte in export_name \\\n                                          value: `{}`\", sym)[]);\n                         }\n-                        let g = sym.with_c_str(|buf| {\n-                            llvm::LLVMAddGlobal(ccx.llmod(), llty, buf)\n-                        });\n+                        let buf = CString::from_slice(sym.as_bytes());\n+                        let g = llvm::LLVMAddGlobal(ccx.llmod(), llty,\n+                                                    buf.as_ptr());\n \n                         if attr::contains_name(i.attrs[],\n                                                \"thread_local\") {\n@@ -2823,9 +2820,8 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                                  sect.get())[]);\n                     }\n                     unsafe {\n-                        sect.get().with_c_str(|buf| {\n-                            llvm::LLVMSetSection(v, buf);\n-                        })\n+                        let buf = CString::from_slice(sect.get().as_bytes());\n+                        llvm::LLVMSetSection(v, buf.as_ptr());\n                     }\n                 },\n                 None => ()\n@@ -2992,26 +2988,23 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n     let name = format!(\"rust_metadata_{}_{}\",\n                        cx.link_meta().crate_name,\n                        cx.link_meta().crate_hash);\n-    let llglobal = name.with_c_str(|buf| {\n-        unsafe {\n-            llvm::LLVMAddGlobal(cx.metadata_llmod(), val_ty(llconst).to_ref(), buf)\n-        }\n-    });\n+    let buf = CString::from_vec(name.into_bytes());\n+    let llglobal = unsafe {\n+        llvm::LLVMAddGlobal(cx.metadata_llmod(), val_ty(llconst).to_ref(),\n+                            buf.as_ptr())\n+    };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n         let name = loader::meta_section_name(cx.sess().target.target.options.is_like_osx);\n-        name.with_c_str(|buf| {\n-            llvm::LLVMSetSection(llglobal, buf)\n-        });\n+        let name = CString::from_slice(name.as_bytes());\n+        llvm::LLVMSetSection(llglobal, name.as_ptr())\n     }\n     return metadata;\n }\n \n /// Find any symbols that are defined in one compilation unit, but not declared\n /// in any other compilation unit.  Give these symbols internal linkage.\n fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n-    use std::c_str::CString;\n-\n     unsafe {\n         let mut declared = HashSet::new();\n \n@@ -3041,7 +3034,8 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n                     continue\n                 }\n \n-                let name = CString::new(llvm::LLVMGetValueName(val), false);\n+                let name = ffi::c_str_to_bytes(&llvm::LLVMGetValueName(val))\n+                               .to_vec();\n                 declared.insert(name);\n             }\n         }\n@@ -3057,9 +3051,10 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n                     continue\n                 }\n \n-                let name = CString::new(llvm::LLVMGetValueName(val), false);\n+                let name = ffi::c_str_to_bytes(&llvm::LLVMGetValueName(val))\n+                               .to_vec();\n                 if !declared.contains(&name) &&\n-                   !reachable.contains(name.as_str().unwrap()) {\n+                   !reachable.contains(str::from_utf8(name.as_slice()).unwrap()) {\n                     llvm::SetLinkage(val, llvm::InternalLinkage);\n                 }\n             }"}, {"sha": "e09d36ddae923188be8407e9942c2aac077713ec", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -20,7 +20,8 @@ use trans::machine::llalign_of_pref;\n use trans::type_::Type;\n use util::nodemap::FnvHashMap;\n use libc::{c_uint, c_char};\n-use std::c_str::ToCStr;\n+\n+use std::ffi::CString;\n use syntax::codemap::Span;\n \n pub struct Builder<'a, 'tcx: 'a> {\n@@ -429,9 +430,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n             } else {\n-                name.with_c_str(|c| {\n-                    llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), c)\n-                })\n+                let name = CString::from_slice(name.as_bytes());\n+                llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(),\n+                                      name.as_ptr())\n             }\n         }\n     }\n@@ -774,12 +775,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let comment_text = format!(\"{} {}\", \"#\",\n                                        sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n-            let asm = comment_text.with_c_str(|c| {\n-                unsafe {\n-                    llvm::LLVMConstInlineAsm(Type::func(&[], &Type::void(self.ccx)).to_ref(),\n-                                             c, noname(), False, False)\n-                }\n-            });\n+            let comment_text = CString::from_vec(comment_text.into_bytes());\n+            let asm = unsafe {\n+                llvm::LLVMConstInlineAsm(Type::func(&[], &Type::void(self.ccx)).to_ref(),\n+                                         comment_text.as_ptr(), noname(), False,\n+                                         False)\n+            };\n             self.call(asm, &[], None);\n         }\n     }\n@@ -926,9 +927,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let bb: BasicBlockRef = llvm::LLVMGetInsertBlock(self.llbuilder);\n             let fn_: ValueRef = llvm::LLVMGetBasicBlockParent(bb);\n             let m: ModuleRef = llvm::LLVMGetGlobalParent(fn_);\n-            let t: ValueRef = \"llvm.trap\".with_c_str(|buf| {\n-                llvm::LLVMGetNamedFunction(m, buf)\n-            });\n+            let p = \"llvm.trap\\0\".as_ptr();\n+            let t: ValueRef = llvm::LLVMGetNamedFunction(m, p as *const _);\n             assert!((t as int != 0));\n             let args: &[ValueRef] = &[];\n             self.count_insn(\"trap\");"}, {"sha": "094f98e988aad202fda3fc3e9535f62c1a3cdcaa", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -44,7 +44,7 @@ use util::nodemap::{FnvHashMap, NodeMap};\n \n use arena::TypedArena;\n use libc::{c_uint, c_char};\n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n use std::vec::Vec;\n use syntax::ast::Ident;\n@@ -401,9 +401,8 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         if self.llreturn.get().is_none() {\n \n             self.llreturn.set(Some(unsafe {\n-                \"return\".with_c_str(|buf| {\n-                    llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(), self.llfn, buf)\n-                })\n+                llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(), self.llfn,\n+                                                    \"return\\0\".as_ptr() as *const _)\n             }))\n         }\n \n@@ -429,11 +428,10 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n                      opt_node_id: Option<ast::NodeId>)\n                      -> Block<'a, 'tcx> {\n         unsafe {\n-            let llbb = name.with_c_str(|buf| {\n-                    llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n-                                                        self.llfn,\n-                                                        buf)\n-                });\n+            let name = CString::from_slice(name.as_bytes());\n+            let llbb = llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n+                                                           self.llfn,\n+                                                           name.as_ptr());\n             BlockS::new(llbb, is_lpad, opt_node_id, self)\n         }\n     }\n@@ -708,7 +706,8 @@ pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n \n pub fn C_floating(s: &str, t: Type) -> ValueRef {\n     unsafe {\n-        s.with_c_str(|buf| llvm::LLVMConstRealOfString(t.to_ref(), buf))\n+        let s = CString::from_slice(s.as_bytes());\n+        llvm::LLVMConstRealOfString(t.to_ref(), s.as_ptr())\n     }\n }\n \n@@ -789,9 +788,8 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n                                                 !null_terminated as Bool);\n \n         let gsym = token::gensym(\"str\");\n-        let g = format!(\"str{}\", gsym.uint()).with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf)\n-        });\n+        let buf = CString::from_vec(format!(\"str{}\", gsym.uint()).into_bytes());\n+        let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf.as_ptr());\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n         llvm::SetLinkage(g, llvm::InternalLinkage);\n@@ -815,9 +813,10 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n         let lldata = C_bytes(cx, data);\n \n         let gsym = token::gensym(\"binary\");\n-        let g = format!(\"binary{}\", gsym.uint()).with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(), buf)\n-        });\n+        let name = format!(\"binary{}\", gsym.uint());\n+        let name = CString::from_vec(name.into_bytes());\n+        let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(),\n+                                    name.as_ptr());\n         llvm::LLVMSetInitializer(g, lldata);\n         llvm::LLVMSetGlobalConstant(g, True);\n         llvm::SetLinkage(g, llvm::InternalLinkage);"}, {"sha": "9432fa8bd3d5983af8f26066f860779e8e98048a", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -24,7 +24,6 @@ use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use util::ppaux::{Repr, ty_to_string};\n \n-use std::c_str::ToCStr;\n use std::iter::repeat;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n@@ -103,9 +102,8 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n \n pub fn const_addr_of(cx: &CrateContext, cv: ValueRef, mutbl: ast::Mutability) -> ValueRef {\n     unsafe {\n-        let gv = \"const\".with_c_str(|name| {\n-            llvm::LLVMAddGlobal(cx.llmod(), val_ty(cv).to_ref(), name)\n-        });\n+        let gv = llvm::LLVMAddGlobal(cx.llmod(), val_ty(cv).to_ref(),\n+                                     \"const\\0\".as_ptr() as *const _);\n         llvm::LLVMSetInitializer(gv, cv);\n         llvm::LLVMSetGlobalConstant(gv,\n                                     if mutbl == ast::MutImmutable {True} else {False});"}, {"sha": "f974a6faf4c19d8e6feb31b7e4cda3417e86a312", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -29,8 +29,8 @@ use util::ppaux::Repr;\n use util::sha2::Sha256;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n \n+use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n-use std::c_str::ToCStr;\n use std::ptr;\n use std::rc::Rc;\n use syntax::ast;\n@@ -221,21 +221,16 @@ impl<'a, 'tcx> Iterator for CrateContextMaybeIterator<'a, 'tcx> {\n \n unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n     let llcx = llvm::LLVMContextCreate();\n-    let llmod = mod_name.with_c_str(|buf| {\n-        llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n-    });\n-    sess.target\n-        .target\n-        .data_layout\n-        .with_c_str(|buf| {\n-        llvm::LLVMSetDataLayout(llmod, buf);\n-    });\n-    sess.target\n-        .target\n-        .llvm_target\n-        .with_c_str(|buf| {\n-        llvm::LLVMRustSetNormalizedTarget(llmod, buf);\n-    });\n+    let mod_name = CString::from_slice(mod_name.as_bytes());\n+    let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n+\n+    let data_layout = sess.target.target.data_layout.as_slice();\n+    let data_layout = CString::from_slice(data_layout.as_bytes());\n+    llvm::LLVMSetDataLayout(llmod, data_layout.as_ptr());\n+\n+    let llvm_target = sess.target.target.llvm_target.as_slice();\n+    let llvm_target = CString::from_slice(llvm_target.as_bytes());\n+    llvm::LLVMRustSetNormalizedTarget(llmod, llvm_target.as_ptr());\n     (llcx, llmod)\n }\n "}, {"sha": "a55953a882f037761cf2d7283d5c14e46d64e503", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 253, "deletions": 273, "changes": 526, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -207,7 +207,7 @@ use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n use util::ppaux;\n \n use libc::c_uint;\n-use std::c_str::{CString, ToCStr};\n+use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n use std::ptr;\n use std::rc::{Rc, Weak};\n@@ -760,14 +760,15 @@ pub fn finalize(cx: &CrateContext) {\n         // for OS X to understand. For more info see #11352\n         // This can be overridden using --llvm-opts -dwarf-version,N.\n         if cx.sess().target.target.options.is_like_osx {\n-            \"Dwarf Version\".with_c_str(\n-                |s| llvm::LLVMRustAddModuleFlag(cx.llmod(), s, 2));\n+            llvm::LLVMRustAddModuleFlag(cx.llmod(),\n+                                        \"Dwarf Version\\0\".as_ptr() as *const _,\n+                                        2)\n         }\n \n         // Prevent bitcode readers from deleting the debug info.\n-        \"Debug Info Version\".with_c_str(\n-            |s| llvm::LLVMRustAddModuleFlag(cx.llmod(), s,\n-                                            llvm::LLVMRustDebugMetadataVersion));\n+        let ptr = \"Debug Info Version\\0\".as_ptr();\n+        llvm::LLVMRustAddModuleFlag(cx.llmod(), ptr as *const _,\n+                                    llvm::LLVMRustDebugMetadataVersion);\n     };\n }\n \n@@ -829,22 +830,20 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n         namespace_node.mangled_name_of_contained_item(var_name[]);\n     let var_scope = namespace_node.scope;\n \n-    var_name.with_c_str(|var_name| {\n-        linkage_name.with_c_str(|linkage_name| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateStaticVariable(DIB(cx),\n-                                                        var_scope,\n-                                                        var_name,\n-                                                        linkage_name,\n-                                                        file_metadata,\n-                                                        line_number,\n-                                                        type_metadata,\n-                                                        is_local_to_unit,\n-                                                        global,\n-                                                        ptr::null_mut());\n-            }\n-        })\n-    });\n+    let var_name = CString::from_slice(var_name.as_bytes());\n+    let linkage_name = CString::from_slice(linkage_name.as_bytes());\n+    unsafe {\n+        llvm::LLVMDIBuilderCreateStaticVariable(DIB(cx),\n+                                                var_scope,\n+                                                var_name.as_ptr(),\n+                                                linkage_name.as_ptr(),\n+                                                file_metadata,\n+                                                line_number,\n+                                                type_metadata,\n+                                                is_local_to_unit,\n+                                                global,\n+                                                ptr::null_mut());\n+    }\n }\n \n /// Creates debug information for the given local variable.\n@@ -1388,28 +1387,26 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let is_local_to_unit = is_node_local_to_unit(cx, fn_ast_id);\n \n-    let fn_metadata = function_name.with_c_str(|function_name| {\n-                          linkage_name.with_c_str(|linkage_name| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateFunction(\n-                    DIB(cx),\n-                    containing_scope,\n-                    function_name,\n-                    linkage_name,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    function_type_metadata,\n-                    is_local_to_unit,\n-                    true,\n-                    scope_line as c_uint,\n-                    FlagPrototyped as c_uint,\n-                    cx.sess().opts.optimize != config::No,\n-                    llfn,\n-                    template_parameters,\n-                    ptr::null_mut())\n-            }\n-        })\n-    });\n+    let function_name = CString::from_slice(function_name.as_bytes());\n+    let linkage_name = CString::from_slice(linkage_name.as_bytes());\n+    let fn_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateFunction(\n+            DIB(cx),\n+            containing_scope,\n+            function_name.as_ptr(),\n+            linkage_name.as_ptr(),\n+            file_metadata,\n+            loc.line as c_uint,\n+            function_type_metadata,\n+            is_local_to_unit,\n+            true,\n+            scope_line as c_uint,\n+            FlagPrototyped as c_uint,\n+            cx.sess().opts.optimize != config::No,\n+            llfn,\n+            template_parameters,\n+            ptr::null_mut())\n+    };\n \n     let scope_map = create_scope_map(cx,\n                                      fn_decl.inputs.as_slice(),\n@@ -1514,19 +1511,18 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n                 let ident = special_idents::type_self;\n \n-                let param_metadata = token::get_ident(ident).get()\n-                                                            .with_c_str(|name| {\n-                    unsafe {\n-                        llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n-                            DIB(cx),\n-                            file_metadata,\n-                            name,\n-                            actual_self_type_metadata,\n-                            ptr::null_mut(),\n-                            0,\n-                            0)\n-                    }\n-                });\n+                let ident = token::get_ident(ident);\n+                let name = CString::from_slice(ident.get().as_bytes());\n+                let param_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                        DIB(cx),\n+                        file_metadata,\n+                        name.as_ptr(),\n+                        actual_self_type_metadata,\n+                        ptr::null_mut(),\n+                        0,\n+                        0)\n+                };\n \n                 template_params.push(param_metadata);\n             }\n@@ -1549,19 +1545,18 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // Again, only create type information if full debuginfo is enabled\n             if cx.sess().opts.debuginfo == FullDebugInfo {\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n-                let param_metadata = token::get_ident(ident).get()\n-                                                            .with_c_str(|name| {\n-                    unsafe {\n-                        llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n-                            DIB(cx),\n-                            file_metadata,\n-                            name,\n-                            actual_type_metadata,\n-                            ptr::null_mut(),\n-                            0,\n-                            0)\n-                    }\n-                });\n+                let ident = token::get_ident(ident);\n+                let name = CString::from_slice(ident.get().as_bytes());\n+                let param_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                        DIB(cx),\n+                        file_metadata,\n+                        name.as_ptr(),\n+                        actual_type_metadata,\n+                        ptr::null_mut(),\n+                        0,\n+                        0)\n+                };\n                 template_params.push(param_metadata);\n             }\n         }\n@@ -1606,19 +1601,19 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n             } else {\n                 match abs_path.path_relative_from(work_dir) {\n                     Some(ref p) if p.is_relative() => {\n-                            // prepend \"./\" if necessary\n-                            let dotdot = b\"..\";\n-                            let prefix = [dotdot[0], ::std::path::SEP_BYTE];\n-                            let mut path_bytes = p.as_vec().to_vec();\n-\n-                            if path_bytes.slice_to(2) != prefix &&\n-                               path_bytes.slice_to(2) != dotdot {\n-                                path_bytes.insert(0, prefix[0]);\n-                                path_bytes.insert(1, prefix[1]);\n-                            }\n-\n-                            path_bytes.to_c_str()\n+                        // prepend \"./\" if necessary\n+                        let dotdot = b\"..\";\n+                        let prefix: &[u8] = &[dotdot[0], ::std::path::SEP_BYTE];\n+                        let mut path_bytes = p.as_vec().to_vec();\n+\n+                        if path_bytes.slice_to(2) != prefix &&\n+                           path_bytes.slice_to(2) != dotdot {\n+                            path_bytes.insert(0, prefix[0]);\n+                            path_bytes.insert(1, prefix[1]);\n                         }\n+\n+                        CString::from_vec(path_bytes)\n+                    }\n                     _ => fallback_path(cx)\n                 }\n             }\n@@ -1630,29 +1625,25 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n     let compile_unit_name = compile_unit_name.as_ptr();\n-    return work_dir.as_vec().with_c_str(|work_dir| {\n-        producer.with_c_str(|producer| {\n-            \"\".with_c_str(|flags| {\n-                \"\".with_c_str(|split_name| {\n-                    unsafe {\n-                        llvm::LLVMDIBuilderCreateCompileUnit(\n-                            debug_context(cx).builder,\n-                            DW_LANG_RUST,\n-                            compile_unit_name,\n-                            work_dir,\n-                            producer,\n-                            cx.sess().opts.optimize != config::No,\n-                            flags,\n-                            0,\n-                            split_name)\n-                    }\n-                })\n-            })\n-        })\n-    });\n+    let work_dir = CString::from_slice(work_dir.as_vec());\n+    let producer = CString::from_slice(producer.as_bytes());\n+    let flags = \"\\0\";\n+    let split_name = \"\\0\";\n+    return unsafe {\n+        llvm::LLVMDIBuilderCreateCompileUnit(\n+            debug_context(cx).builder,\n+            DW_LANG_RUST,\n+            compile_unit_name,\n+            work_dir.as_ptr(),\n+            producer.as_ptr(),\n+            cx.sess().opts.optimize != config::No,\n+            flags.as_ptr() as *const _,\n+            0,\n+            split_name.as_ptr() as *const _)\n+    };\n \n     fn fallback_path(cx: &CrateContext) -> CString {\n-        cx.link_meta().crate_name.to_c_str()\n+        CString::from_slice(cx.link_meta().crate_name.as_bytes())\n     }\n }\n \n@@ -1678,42 +1669,41 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         CapturedVariable => (0, DW_TAG_auto_variable)\n     };\n \n-    let (var_alloca, var_metadata) = name.get().with_c_str(|name| {\n-        match variable_access {\n-            DirectVariable { alloca } => (\n-                alloca,\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateLocalVariable(\n-                        DIB(cx),\n-                        dwarf_tag,\n-                        scope_metadata,\n-                        name,\n-                        file_metadata,\n-                        loc.line as c_uint,\n-                        type_metadata,\n-                        cx.sess().opts.optimize != config::No,\n-                        0,\n-                        argument_index)\n-                }\n-            ),\n-            IndirectVariable { alloca, address_operations } => (\n-                alloca,\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateComplexVariable(\n-                        DIB(cx),\n-                        dwarf_tag,\n-                        scope_metadata,\n-                        name,\n-                        file_metadata,\n-                        loc.line as c_uint,\n-                        type_metadata,\n-                        address_operations.as_ptr(),\n-                        address_operations.len() as c_uint,\n-                        argument_index)\n-                }\n-            )\n-        }\n-    });\n+    let name = CString::from_slice(name.get().as_bytes());\n+    let (var_alloca, var_metadata) = match variable_access {\n+        DirectVariable { alloca } => (\n+            alloca,\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateLocalVariable(\n+                    DIB(cx),\n+                    dwarf_tag,\n+                    scope_metadata,\n+                    name.as_ptr(),\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    type_metadata,\n+                    cx.sess().opts.optimize != config::No,\n+                    0,\n+                    argument_index)\n+            }\n+        ),\n+        IndirectVariable { alloca, address_operations } => (\n+            alloca,\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateComplexVariable(\n+                    DIB(cx),\n+                    dwarf_tag,\n+                    scope_metadata,\n+                    name.as_ptr(),\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    type_metadata,\n+                    address_operations.as_ptr(),\n+                    address_operations.len() as c_uint,\n+                    argument_index)\n+            }\n+        )\n+    };\n \n     set_debug_location(cx, DebugLocation::new(scope_metadata,\n                                               loc.line,\n@@ -1758,14 +1748,12 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n             full_path\n         };\n \n-    let file_metadata =\n-        file_name.with_c_str(|file_name| {\n-            work_dir.with_c_str(|work_dir| {\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n-                }\n-            })\n-        });\n+    let file_name = CString::from_slice(file_name.as_bytes());\n+    let work_dir = CString::from_slice(work_dir.as_bytes());\n+    let file_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name.as_ptr(),\n+                                      work_dir.as_ptr())\n+    };\n \n     let mut created_files = debug_context(cx).created_files.borrow_mut();\n     created_files.insert(full_path.to_string(), file_metadata);\n@@ -1793,16 +1781,14 @@ fn scope_metadata(fcx: &FunctionContext,\n }\n \n fn diverging_type_metadata(cx: &CrateContext) -> DIType {\n-    \"!\".with_c_str(|name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateBasicType(\n-                DIB(cx),\n-                name,\n-                bytes_to_bits(0),\n-                bytes_to_bits(0),\n-                DW_ATE_unsigned)\n-        }\n-    })\n+    unsafe {\n+        llvm::LLVMDIBuilderCreateBasicType(\n+            DIB(cx),\n+            \"!\\0\".as_ptr() as *const _,\n+            bytes_to_bits(0),\n+            bytes_to_bits(0),\n+            DW_ATE_unsigned)\n+    }\n }\n \n fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -1838,16 +1824,15 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let llvm_type = type_of::type_of(cx, t);\n     let (size, align) = size_and_align_of(cx, llvm_type);\n-    let ty_metadata = name.with_c_str(|name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateBasicType(\n-                DIB(cx),\n-                name,\n-                bytes_to_bits(size),\n-                bytes_to_bits(align),\n-                encoding)\n-        }\n-    });\n+    let name = CString::from_slice(name.as_bytes());\n+    let ty_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateBasicType(\n+            DIB(cx),\n+            name.as_ptr(),\n+            bytes_to_bits(size),\n+            bytes_to_bits(align),\n+            encoding)\n+    };\n \n     return ty_metadata;\n }\n@@ -1859,16 +1844,15 @@ fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n     let name = compute_debuginfo_type_name(cx, pointer_type, false);\n-    let ptr_metadata = name.with_c_str(|name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreatePointerType(\n-                DIB(cx),\n-                pointee_type_metadata,\n-                bytes_to_bits(pointer_size),\n-                bytes_to_bits(pointer_align),\n-                name)\n-        }\n-    });\n+    let name = CString::from_slice(name.as_bytes());\n+    let ptr_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreatePointerType(\n+            DIB(cx),\n+            pointee_type_metadata,\n+            bytes_to_bits(pointer_size),\n+            bytes_to_bits(pointer_align),\n+            name.as_ptr())\n+    };\n     return ptr_metadata;\n }\n \n@@ -2478,14 +2462,14 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let enumerators_metadata: Vec<DIDescriptor> = variants\n         .iter()\n         .map(|v| {\n-            token::get_name(v.name).get().with_c_str(|name| {\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateEnumerator(\n-                        DIB(cx),\n-                        name,\n-                        v.disr_val as u64)\n-                }\n-            })\n+            let token = token::get_name(v.name);\n+            let name = CString::from_slice(token.get().as_bytes());\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateEnumerator(\n+                    DIB(cx),\n+                    name.as_ptr(),\n+                    v.disr_val as u64)\n+            }\n         })\n         .collect();\n \n@@ -2509,20 +2493,19 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                   codemap::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n \n-                let discriminant_type_metadata = discriminant_name.get().with_c_str(|name| {\n-                    unsafe {\n-                        llvm::LLVMDIBuilderCreateEnumerationType(\n-                            DIB(cx),\n-                            containing_scope,\n-                            name,\n-                            UNKNOWN_FILE_METADATA,\n-                            UNKNOWN_LINE_NUMBER,\n-                            bytes_to_bits(discriminant_size),\n-                            bytes_to_bits(discriminant_align),\n-                            create_DIArray(DIB(cx), enumerators_metadata[]),\n-                            discriminant_base_type_metadata)\n-                    }\n-                });\n+                let name = CString::from_slice(discriminant_name.get().as_bytes());\n+                let discriminant_type_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateEnumerationType(\n+                        DIB(cx),\n+                        containing_scope,\n+                        name.as_ptr(),\n+                        UNKNOWN_FILE_METADATA,\n+                        UNKNOWN_LINE_NUMBER,\n+                        bytes_to_bits(discriminant_size),\n+                        bytes_to_bits(discriminant_align),\n+                        create_DIArray(DIB(cx), enumerators_metadata.as_slice()),\n+                        discriminant_base_type_metadata)\n+                };\n \n                 debug_context(cx).created_enum_disr_types\n                                  .borrow_mut()\n@@ -2553,24 +2536,22 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                              .borrow()\n                              .get_unique_type_id_as_string(unique_type_id);\n \n-    let enum_metadata = enum_name.with_c_str(|enum_name| {\n-        unique_type_id_str.with_c_str(|unique_type_id_str| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateUnionType(\n-                DIB(cx),\n-                containing_scope,\n-                enum_name,\n-                UNKNOWN_FILE_METADATA,\n-                UNKNOWN_LINE_NUMBER,\n-                bytes_to_bits(enum_type_size),\n-                bytes_to_bits(enum_type_align),\n-                0, // Flags\n-                ptr::null_mut(),\n-                0, // RuntimeLang\n-                unique_type_id_str)\n-            }\n-        })\n-    });\n+    let enum_name = CString::from_slice(enum_name.as_bytes());\n+    let unique_type_id_str = CString::from_slice(unique_type_id_str.as_bytes());\n+    let enum_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateUnionType(\n+        DIB(cx),\n+        containing_scope,\n+        enum_name.as_ptr(),\n+        UNKNOWN_FILE_METADATA,\n+        UNKNOWN_LINE_NUMBER,\n+        bytes_to_bits(enum_type_size),\n+        bytes_to_bits(enum_type_align),\n+        0, // Flags\n+        ptr::null_mut(),\n+        0, // RuntimeLang\n+        unique_type_id_str.as_ptr())\n+    };\n \n     return create_and_register_recursive_type_forward_declaration(\n         cx,\n@@ -2681,21 +2662,20 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                 ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n             };\n \n-            member_description.name.with_c_str(|member_name| {\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateMemberType(\n-                        DIB(cx),\n-                        composite_type_metadata,\n-                        member_name,\n-                        UNKNOWN_FILE_METADATA,\n-                        UNKNOWN_LINE_NUMBER,\n-                        bytes_to_bits(member_size),\n-                        bytes_to_bits(member_align),\n-                        bytes_to_bits(member_offset),\n-                        member_description.flags,\n-                        member_description.type_metadata)\n-                }\n-            })\n+            let member_name = CString::from_slice(member_description.name.as_bytes());\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateMemberType(\n+                    DIB(cx),\n+                    composite_type_metadata,\n+                    member_name.as_ptr(),\n+                    UNKNOWN_FILE_METADATA,\n+                    UNKNOWN_LINE_NUMBER,\n+                    bytes_to_bits(member_size),\n+                    bytes_to_bits(member_align),\n+                    bytes_to_bits(member_offset),\n+                    member_description.flags,\n+                    member_description.type_metadata)\n+            }\n         })\n         .collect();\n \n@@ -2719,30 +2699,28 @@ fn create_struct_stub(cx: &CrateContext,\n     let unique_type_id_str = debug_context(cx).type_map\n                                               .borrow()\n                                               .get_unique_type_id_as_string(unique_type_id);\n+    let name = CString::from_slice(struct_type_name.as_bytes());\n+    let unique_type_id = CString::from_slice(unique_type_id_str.as_bytes());\n     let metadata_stub = unsafe {\n-        struct_type_name.with_c_str(|name| {\n-            unique_type_id_str.with_c_str(|unique_type_id| {\n-                // LLVMDIBuilderCreateStructType() wants an empty array. A null\n-                // pointer will lead to hard to trace and debug LLVM assertions\n-                // later on in llvm/lib/IR/Value.cpp.\n-                let empty_array = create_DIArray(DIB(cx), &[]);\n-\n-                llvm::LLVMDIBuilderCreateStructType(\n-                    DIB(cx),\n-                    containing_scope,\n-                    name,\n-                    UNKNOWN_FILE_METADATA,\n-                    UNKNOWN_LINE_NUMBER,\n-                    bytes_to_bits(struct_size),\n-                    bytes_to_bits(struct_align),\n-                    0,\n-                    ptr::null_mut(),\n-                    empty_array,\n-                    0,\n-                    ptr::null_mut(),\n-                    unique_type_id)\n-            })\n-        })\n+        // LLVMDIBuilderCreateStructType() wants an empty array. A null\n+        // pointer will lead to hard to trace and debug LLVM assertions\n+        // later on in llvm/lib/IR/Value.cpp.\n+        let empty_array = create_DIArray(DIB(cx), &[]);\n+\n+        llvm::LLVMDIBuilderCreateStructType(\n+            DIB(cx),\n+            containing_scope,\n+            name.as_ptr(),\n+            UNKNOWN_FILE_METADATA,\n+            UNKNOWN_LINE_NUMBER,\n+            bytes_to_bits(struct_size),\n+            bytes_to_bits(struct_align),\n+            0,\n+            ptr::null_mut(),\n+            empty_array,\n+            0,\n+            ptr::null_mut(),\n+            unique_type_id.as_ptr())\n     };\n \n     return metadata_stub;\n@@ -4079,18 +4057,18 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n                         None => ptr::null_mut()\n                     };\n                     let namespace_name = token::get_name(name);\n-                    let scope = namespace_name.get().with_c_str(|namespace_name| {\n-                        unsafe {\n-                            llvm::LLVMDIBuilderCreateNameSpace(\n-                                DIB(cx),\n-                                parent_scope,\n-                                namespace_name,\n-                                // cannot reconstruct file ...\n-                                ptr::null_mut(),\n-                                // ... or line information, but that's not so important.\n-                                0)\n-                        }\n-                    });\n+                    let namespace_name = CString::from_slice(namespace_name\n+                                                                .get().as_bytes());\n+                    let scope = unsafe {\n+                        llvm::LLVMDIBuilderCreateNameSpace(\n+                            DIB(cx),\n+                            parent_scope,\n+                            namespace_name.as_ptr(),\n+                            // cannot reconstruct file ...\n+                            ptr::null_mut(),\n+                            // ... or line information, but that's not so important.\n+                            0)\n+                    };\n \n                     let node = Rc::new(NamespaceTreeNode {\n                         name: name,\n@@ -4128,7 +4106,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n /// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext) {\n     if needs_gdb_debug_scripts_section(ccx) {\n-        let empty = b\"\".to_c_str();\n+        let empty = CString::from_slice(b\"\");\n         let gdb_debug_scripts_section_global =\n             get_or_insert_gdb_debug_scripts_section_global(ccx);\n         unsafe {\n@@ -4145,23 +4123,25 @@ pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext)\n /// section.\n fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n                                                   -> llvm::ValueRef {\n-    let section_var_name = b\"__rustc_debug_gdb_scripts_section__\".to_c_str();\n+    let section_var_name = b\"__rustc_debug_gdb_scripts_section__\\0\";\n \n     let section_var = unsafe {\n-        llvm::LLVMGetNamedGlobal(ccx.llmod(), section_var_name.as_ptr())\n+        llvm::LLVMGetNamedGlobal(ccx.llmod(),\n+                                 section_var_name.as_ptr() as *const _)\n     };\n \n     if section_var == ptr::null_mut() {\n-        let section_name = b\".debug_gdb_scripts\".to_c_str();\n+        let section_name = b\".debug_gdb_scripts\\0\";\n         let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n \n         unsafe {\n             let llvm_type = Type::array(&Type::i8(ccx),\n                                         section_contents.len() as u64);\n             let section_var = llvm::LLVMAddGlobal(ccx.llmod(),\n                                                   llvm_type.to_ref(),\n-                                                  section_var_name.as_ptr());\n-            llvm::LLVMSetSection(section_var, section_name.as_ptr());\n+                                                  section_var_name.as_ptr()\n+                                                    as *const _);\n+            llvm::LLVMSetSection(section_var, section_name.as_ptr() as *const _);\n             llvm::LLVMSetInitializer(section_var, C_bytes(ccx, section_contents));\n             llvm::LLVMSetGlobalConstant(section_var, llvm::True);\n             llvm::LLVMSetUnnamedAddr(section_var, llvm::True);"}, {"sha": "1c9be6ae4a8ba5e357566cf1ff2d65834ac56020", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -24,9 +24,10 @@ use trans::type_::Type;\n use trans::type_of::*;\n use trans::type_of;\n use middle::ty::{self, Ty};\n-use middle::subst::{Substs};\n+use middle::subst::Substs;\n+\n+use std::ffi::CString;\n use std::cmp;\n-use std::c_str::ToCStr;\n use libc::c_uint;\n use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n use syntax::abi::{RustIntrinsic, Rust, RustCall, Stdcall, Fastcall, System};\n@@ -132,9 +133,9 @@ pub fn register_static(ccx: &CrateContext,\n             };\n             unsafe {\n                 // Declare a symbol `foo` with the desired linkage.\n-                let g1 = ident.get().with_c_str(|buf| {\n-                    llvm::LLVMAddGlobal(ccx.llmod(), llty2.to_ref(), buf)\n-                });\n+                let buf = CString::from_slice(ident.get().as_bytes());\n+                let g1 = llvm::LLVMAddGlobal(ccx.llmod(), llty2.to_ref(),\n+                                             buf.as_ptr());\n                 llvm::SetLinkage(g1, linkage);\n \n                 // Declare an internal global `extern_with_linkage_foo` which\n@@ -145,19 +146,18 @@ pub fn register_static(ccx: &CrateContext,\n                 // zero.\n                 let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n                 real_name.push_str(ident.get());\n-                let g2 = real_name.with_c_str(|buf| {\n-                    llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf)\n-                });\n+                let real_name = CString::from_vec(real_name.into_bytes());\n+                let g2 = llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(),\n+                                             real_name.as_ptr());\n                 llvm::SetLinkage(g2, llvm::InternalLinkage);\n                 llvm::LLVMSetInitializer(g2, g1);\n                 g2\n             }\n         }\n         None => unsafe {\n             // Generate an external declaration.\n-            ident.get().with_c_str(|buf| {\n-                llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf)\n-            })\n+            let buf = CString::from_slice(ident.get().as_bytes());\n+            llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf.as_ptr())\n         }\n     }\n }\n@@ -606,9 +606,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         //         return r;\n         //     }\n \n-        let the_block =\n-            \"the block\".with_c_str(\n-                |s| llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llwrapfn, s));\n+        let ptr = \"the block\\0\".as_ptr();\n+        let the_block = llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llwrapfn,\n+                                                            ptr as *const _);\n \n         let builder = ccx.builder();\n         builder.position_at_end(the_block);"}, {"sha": "2525220c57021ee0c157bc5d00465731911f6d2f", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -40,8 +40,8 @@ use util::ppaux::{ty_to_short_str, Repr};\n use util::ppaux;\n \n use arena::TypedArena;\n-use std::c_str::ToCStr;\n use libc::c_uint;\n+use std::ffi::CString;\n use syntax::ast;\n use syntax::parse::token;\n \n@@ -498,11 +498,11 @@ pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     let llalign = llalign_of(ccx, llty);\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\");\n     debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_string(ccx.tcx(), t), name);\n-    let gvar = name.with_c_str(|buf| {\n-        unsafe {\n-            llvm::LLVMAddGlobal(ccx.llmod(), ccx.tydesc_type().to_ref(), buf)\n-        }\n-    });\n+    let buf = CString::from_slice(name.as_bytes());\n+    let gvar = unsafe {\n+        llvm::LLVMAddGlobal(ccx.llmod(), ccx.tydesc_type().to_ref(),\n+                            buf.as_ptr())\n+    };\n     note_unique_llvm_symbol(ccx, name);\n \n     let ty_name = token::intern_and_get_ident("}, {"sha": "dec4524e676654785f618b7bf11bf5c9e826dde3", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -34,7 +34,7 @@ use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n use util::ppaux::Repr;\n \n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::rc::Rc;\n use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n@@ -742,9 +742,9 @@ pub fn make_vtable<I: Iterator<Item=ValueRef>>(ccx: &CrateContext,\n     unsafe {\n         let tbl = C_struct(ccx, components[], false);\n         let sym = token::gensym(\"vtable\");\n-        let vt_gvar = format!(\"vtable{}\", sym.uint()).with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod(), val_ty(tbl).to_ref(), buf)\n-        });\n+        let buf = CString::from_vec(format!(\"vtable{}\", sym.uint()).into_bytes());\n+        let vt_gvar = llvm::LLVMAddGlobal(ccx.llmod(), val_ty(tbl).to_ref(),\n+                                          buf.as_ptr());\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n         llvm::LLVMSetGlobalConstant(vt_gvar, llvm::True);\n         llvm::SetLinkage(vt_gvar, llvm::InternalLinkage);"}, {"sha": "3785c2fb9bc54e5b633e3dd36099266ed2840dec", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -19,7 +19,7 @@ use util::nodemap::FnvHashMap;\n \n use syntax::ast;\n \n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::mem;\n use std::cell::RefCell;\n use std::iter::repeat;\n@@ -157,7 +157,8 @@ impl Type {\n     }\n \n     pub fn named_struct(ccx: &CrateContext, name: &str) -> Type {\n-        ty!(name.with_c_str(|s| llvm::LLVMStructCreateNamed(ccx.llcx(), s)))\n+        let name = CString::from_slice(name.as_bytes());\n+        ty!(llvm::LLVMStructCreateNamed(ccx.llcx(), name.as_ptr()))\n     }\n \n     pub fn empty_struct(ccx: &CrateContext) -> Type {"}, {"sha": "dcc90117d26606041d1cc721e52e893706df9c8d", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -20,8 +20,8 @@ pub use self::imp::Lock;\n \n #[cfg(unix)]\n mod imp {\n+    use std::ffi::CString;\n     use libc;\n-    use std::c_str::ToCStr;\n \n     #[cfg(target_os = \"linux\")]\n     mod os {\n@@ -111,9 +111,11 @@ mod imp {\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let fd = p.with_c_str(|s| unsafe {\n-                libc::open(s, libc::O_RDWR | libc::O_CREAT, libc::S_IRWXU)\n-            });\n+            let buf = CString::from_slice(p.as_vec());\n+            let fd = unsafe {\n+                libc::open(buf.as_ptr(), libc::O_RDWR | libc::O_CREAT,\n+                           libc::S_IRWXU)\n+            };\n             assert!(fd > 0);\n             let flock = os::flock {\n                 l_start: 0,"}, {"sha": "3b9265cf569765a39822fea60f54c567ddc9a46a", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -29,7 +29,7 @@\n \n use libc;\n use std::ascii::AsciiExt;\n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::cell::{RefCell, Cell};\n use std::collections::HashMap;\n use std::fmt;\n@@ -215,7 +215,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                 let id = id.as_ref().map(|a| a.as_slice());\n                 s.push_str(highlight::highlight(text.as_slice(), None, id)\n                                      .as_slice());\n-                let output = s.to_c_str();\n+                let output = CString::from_vec(s.into_bytes());\n                 hoedown_buffer_puts(ob, output.as_ptr());\n             })\n         }\n@@ -224,15 +224,16 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n     extern fn header(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n                      level: libc::c_int, opaque: *mut libc::c_void) {\n         // hoedown does this, we may as well too\n-        \"\\n\".with_c_str(|p| unsafe { hoedown_buffer_puts(ob, p) });\n+        unsafe { hoedown_buffer_puts(ob, \"\\n\\0\".as_ptr() as *const _); }\n \n         // Extract the text provided\n         let s = if text.is_null() {\n             \"\".to_string()\n         } else {\n-            unsafe {\n-                String::from_raw_buf_len((*text).data, (*text).size as uint)\n-            }\n+            let s = unsafe {\n+                slice::from_raw_buf(&(*text).data, (*text).size as uint)\n+            };\n+            str::from_utf8(s).unwrap().to_string()\n         };\n \n         // Transform the contents of the header into a hyphenated string\n@@ -273,7 +274,8 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                                format!(\"{} \", sec)\n                            });\n \n-        text.with_c_str(|p| unsafe { hoedown_buffer_puts(ob, p) });\n+        let text = CString::from_vec(text.into_bytes());\n+        unsafe { hoedown_buffer_puts(ob, text.as_ptr()) }\n     }\n \n     reset_headers();"}, {"sha": "9c96a9cac78310d5c0d91a3253599b4ea08abd85", "filename": "src/libstd/c_str.rs", "status": "removed", "additions": 0, "deletions": 857, "changes": 857, "blob_url": "https://github.com/rust-lang/rust/blob/1f732ef53d54ccfc3e7728390ffbcea8a696ecee/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f732ef53d54ccfc3e7728390ffbcea8a696ecee/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=1f732ef53d54ccfc3e7728390ffbcea8a696ecee", "patch": "@@ -1,857 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! C-string manipulation and management\n-//!\n-//! This modules provides the basic methods for creating and manipulating\n-//! null-terminated strings for use with FFI calls (back to C). Most C APIs require\n-//! that the string being passed to them is null-terminated, and by default rust's\n-//! string types are *not* null terminated.\n-//!\n-//! The other problem with translating Rust strings to C strings is that Rust\n-//! strings can validly contain a null-byte in the middle of the string (0 is a\n-//! valid Unicode codepoint). This means that not all Rust strings can actually be\n-//! translated to C strings.\n-//!\n-//! # Creation of a C string\n-//!\n-//! A C string is managed through the `CString` type defined in this module. It\n-//! \"owns\" the internal buffer of characters and will automatically deallocate the\n-//! buffer when the string is dropped. The `ToCStr` trait is implemented for `&str`\n-//! and `&[u8]`, but the conversions can fail due to some of the limitations\n-//! explained above.\n-//!\n-//! This also means that currently whenever a C string is created, an allocation\n-//! must be performed to place the data elsewhere (the lifetime of the C string is\n-//! not tied to the lifetime of the original string/data buffer). If C strings are\n-//! heavily used in applications, then caching may be advisable to prevent\n-//! unnecessary amounts of allocations.\n-//!\n-//! Be carefull to remember that the memory is managed by C allocator API and not\n-//! by Rust allocator API.\n-//! That means that the CString pointers should be freed with C allocator API\n-//! if you intend to do that on your own, as the behaviour if you free them with\n-//! Rust's allocator API is not well defined\n-//!\n-//! An example of creating and using a C string would be:\n-//!\n-//! ```rust\n-//! extern crate libc;\n-//!\n-//! use std::c_str::ToCStr;\n-//!\n-//! extern {\n-//!     fn puts(s: *const libc::c_char);\n-//! }\n-//!\n-//! fn main() {\n-//!     let my_string = \"Hello, world!\";\n-//!\n-//!     // Allocate the C string with an explicit local that owns the string. The\n-//!     // `c_buffer` pointer will be deallocated when `my_c_string` goes out of scope.\n-//!     let my_c_string = my_string.to_c_str();\n-//!     unsafe {\n-//!         puts(my_c_string.as_ptr());\n-//!     }\n-//!\n-//!     // Don't save/return the pointer to the C string, the `c_buffer` will be\n-//!     // deallocated when this block returns!\n-//!     my_string.with_c_str(|c_buffer| {\n-//!         unsafe { puts(c_buffer); }\n-//!     });\n-//! }\n-//! ```\n-\n-use core::prelude::*;\n-use libc;\n-\n-use cmp::Ordering;\n-use fmt;\n-use hash;\n-use mem;\n-use ptr;\n-use slice::{self, IntSliceExt};\n-use str;\n-use string::String;\n-use core::kinds::marker;\n-\n-/// The representation of a C String.\n-///\n-/// This structure wraps a `*libc::c_char`, and will automatically free the\n-/// memory it is pointing to when it goes out of scope.\n-#[allow(missing_copy_implementations)]\n-pub struct CString {\n-    buf: *const libc::c_char,\n-    owns_buffer_: bool,\n-}\n-\n-unsafe impl Send for CString { }\n-unsafe impl Sync for CString { }\n-\n-impl Clone for CString {\n-    /// Clone this CString into a new, uniquely owned CString. For safety\n-    /// reasons, this is always a deep clone with the memory allocated\n-    /// with C's allocator API, rather than the usual shallow clone.\n-    fn clone(&self) -> CString {\n-        let len = self.len() + 1;\n-        let buf = unsafe { libc::malloc(len as libc::size_t) } as *mut libc::c_char;\n-        if buf.is_null() { ::alloc::oom() }\n-        unsafe { ptr::copy_nonoverlapping_memory(buf, self.buf, len); }\n-        CString { buf: buf as *const libc::c_char, owns_buffer_: true }\n-    }\n-}\n-\n-impl PartialEq for CString {\n-    fn eq(&self, other: &CString) -> bool {\n-        // Check if the two strings share the same buffer\n-        if self.buf as uint == other.buf as uint {\n-            true\n-        } else {\n-            unsafe {\n-                libc::strcmp(self.buf, other.buf) == 0\n-            }\n-        }\n-    }\n-}\n-\n-impl PartialOrd for CString {\n-    #[inline]\n-    fn partial_cmp(&self, other: &CString) -> Option<Ordering> {\n-        self.as_bytes().partial_cmp(other.as_bytes())\n-    }\n-}\n-\n-impl Eq for CString {}\n-\n-impl<S: hash::Writer> hash::Hash<S> for CString {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.as_bytes().hash(state)\n-    }\n-}\n-\n-impl CString {\n-    /// Create a C String from a pointer, with memory managed by C's allocator\n-    /// API, so avoid calling it with a pointer to memory managed by Rust's\n-    /// allocator API, as the behaviour would not be well defined.\n-    ///\n-    ///# Panics\n-    ///\n-    /// Panics if `buf` is null\n-    pub unsafe fn new(buf: *const libc::c_char, owns_buffer: bool) -> CString {\n-        assert!(!buf.is_null());\n-        CString { buf: buf, owns_buffer_: owns_buffer }\n-    }\n-\n-    /// Return a pointer to the NUL-terminated string data.\n-    ///\n-    /// `.as_ptr` returns an internal pointer into the `CString`, and\n-    /// may be invalidated when the `CString` falls out of scope (the\n-    /// destructor will run, freeing the allocation if there is\n-    /// one).\n-    ///\n-    /// ```rust\n-    /// use std::c_str::ToCStr;\n-    ///\n-    /// let foo = \"some string\";\n-    ///\n-    /// // right\n-    /// let x = foo.to_c_str();\n-    /// let p = x.as_ptr();\n-    ///\n-    /// // wrong (the CString will be freed, invalidating `p`)\n-    /// let p = foo.to_c_str().as_ptr();\n-    /// ```\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// extern crate libc;\n-    ///\n-    /// use std::c_str::ToCStr;\n-    ///\n-    /// fn main() {\n-    ///     let c_str = \"foo bar\".to_c_str();\n-    ///     unsafe {\n-    ///         libc::puts(c_str.as_ptr());\n-    ///     }\n-    /// }\n-    /// ```\n-    pub fn as_ptr(&self) -> *const libc::c_char {\n-        self.buf\n-    }\n-\n-    /// Return a mutable pointer to the NUL-terminated string data.\n-    ///\n-    /// `.as_mut_ptr` returns an internal pointer into the `CString`, and\n-    /// may be invalidated when the `CString` falls out of scope (the\n-    /// destructor will run, freeing the allocation if there is\n-    /// one).\n-    ///\n-    /// ```rust\n-    /// use std::c_str::ToCStr;\n-    ///\n-    /// let foo = \"some string\";\n-    ///\n-    /// // right\n-    /// let mut x = foo.to_c_str();\n-    /// let p = x.as_mut_ptr();\n-    ///\n-    /// // wrong (the CString will be freed, invalidating `p`)\n-    /// let p = foo.to_c_str().as_mut_ptr();\n-    /// ```\n-    pub fn as_mut_ptr(&mut self) -> *mut libc::c_char {\n-        self.buf as *mut _\n-    }\n-\n-    /// Returns whether or not the `CString` owns the buffer.\n-    pub fn owns_buffer(&self) -> bool {\n-        self.owns_buffer_\n-    }\n-\n-    /// Converts the CString into a `&[u8]` without copying.\n-    /// Includes the terminating NUL byte.\n-    #[inline]\n-    pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n-        unsafe {\n-            slice::from_raw_buf(&self.buf, self.len() + 1).as_unsigned()\n-        }\n-    }\n-\n-    /// Converts the CString into a `&[u8]` without copying.\n-    /// Does not include the terminating NUL byte.\n-    #[inline]\n-    pub fn as_bytes_no_nul<'a>(&'a self) -> &'a [u8] {\n-        unsafe {\n-            slice::from_raw_buf(&self.buf, self.len()).as_unsigned()\n-        }\n-    }\n-\n-    /// Converts the CString into a `&str` without copying.\n-    /// Returns None if the CString is not UTF-8.\n-    #[inline]\n-    pub fn as_str<'a>(&'a self) -> Option<&'a str> {\n-        let buf = self.as_bytes_no_nul();\n-        str::from_utf8(buf).ok()\n-    }\n-\n-    /// Return a CString iterator.\n-    pub fn iter<'a>(&'a self) -> CChars<'a> {\n-        CChars {\n-            ptr: self.buf,\n-            marker: marker::ContravariantLifetime,\n-        }\n-    }\n-\n-    /// Unwraps the wrapped `*libc::c_char` from the `CString` wrapper.\n-    ///\n-    /// Any ownership of the buffer by the `CString` wrapper is\n-    /// forgotten, meaning that the backing allocation of this\n-    /// `CString` is not automatically freed if it owns the\n-    /// allocation. In this case, a user of `.unwrap()` should ensure\n-    /// the allocation is freed, to avoid leaking memory. You should\n-    /// use libc's memory allocator in this case.\n-    ///\n-    /// Prefer `.as_ptr()` when just retrieving a pointer to the\n-    /// string data, as that does not relinquish ownership.\n-    pub unsafe fn into_inner(mut self) -> *const libc::c_char {\n-        self.owns_buffer_ = false;\n-        self.buf\n-    }\n-\n-    /// Return the number of bytes in the CString (not including the NUL\n-    /// terminator).\n-    #[inline]\n-    pub fn len(&self) -> uint {\n-        unsafe { libc::strlen(self.buf) as uint }\n-    }\n-\n-    /// Returns if there are no bytes in this string\n-    #[inline]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-}\n-\n-impl Drop for CString {\n-    fn drop(&mut self) {\n-        if self.owns_buffer_ {\n-            unsafe {\n-                libc::free(self.buf as *mut libc::c_void)\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Show for CString {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        String::from_utf8_lossy(self.as_bytes_no_nul()).fmt(f)\n-    }\n-}\n-\n-/// A generic trait for converting a value to a CString.\n-pub trait ToCStr for Sized? {\n-    /// Copy the receiver into a CString.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the receiver has an interior null.\n-    fn to_c_str(&self) -> CString;\n-\n-    /// Unsafe variant of `to_c_str()` that doesn't check for nulls.\n-    unsafe fn to_c_str_unchecked(&self) -> CString;\n-\n-    /// Work with a temporary CString constructed from the receiver.\n-    /// The provided `*libc::c_char` will be freed immediately upon return.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// extern crate libc;\n-    ///\n-    /// use std::c_str::ToCStr;\n-    ///\n-    /// fn main() {\n-    ///     let s = \"PATH\".with_c_str(|path| unsafe {\n-    ///         libc::getenv(path)\n-    ///     });\n-    /// }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the receiver has an interior null.\n-    #[inline]\n-    fn with_c_str<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        let c_str = self.to_c_str();\n-        f(c_str.as_ptr())\n-    }\n-\n-    /// Unsafe variant of `with_c_str()` that doesn't check for nulls.\n-    #[inline]\n-    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        let c_str = self.to_c_str_unchecked();\n-        f(c_str.as_ptr())\n-    }\n-}\n-\n-impl ToCStr for str {\n-    #[inline]\n-    fn to_c_str(&self) -> CString {\n-        self.as_bytes().to_c_str()\n-    }\n-\n-    #[inline]\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        self.as_bytes().to_c_str_unchecked()\n-    }\n-\n-    #[inline]\n-    fn with_c_str<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        self.as_bytes().with_c_str(f)\n-    }\n-\n-    #[inline]\n-    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        self.as_bytes().with_c_str_unchecked(f)\n-    }\n-}\n-\n-impl ToCStr for String {\n-    #[inline]\n-    fn to_c_str(&self) -> CString {\n-        self.as_bytes().to_c_str()\n-    }\n-\n-    #[inline]\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        self.as_bytes().to_c_str_unchecked()\n-    }\n-\n-    #[inline]\n-    fn with_c_str<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        self.as_bytes().with_c_str(f)\n-    }\n-\n-    #[inline]\n-    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        self.as_bytes().with_c_str_unchecked(f)\n-    }\n-}\n-\n-// The length of the stack allocated buffer for `vec.with_c_str()`\n-const BUF_LEN: uint = 128;\n-\n-impl ToCStr for [u8] {\n-    fn to_c_str(&self) -> CString {\n-        let mut cs = unsafe { self.to_c_str_unchecked() };\n-        check_for_null(self, cs.as_mut_ptr());\n-        cs\n-    }\n-\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        let self_len = self.len();\n-        let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n-        if buf.is_null() { ::alloc::oom() }\n-\n-        ptr::copy_memory(buf, self.as_ptr(), self_len);\n-        *buf.offset(self_len as int) = 0;\n-\n-        CString::new(buf as *const libc::c_char, true)\n-    }\n-\n-    fn with_c_str<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        unsafe { with_c_str(self, true, f) }\n-    }\n-\n-    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        with_c_str(self, false, f)\n-    }\n-}\n-\n-impl<'a, Sized? T: ToCStr> ToCStr for &'a T {\n-    #[inline]\n-    fn to_c_str(&self) -> CString {\n-        (**self).to_c_str()\n-    }\n-\n-    #[inline]\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        (**self).to_c_str_unchecked()\n-    }\n-\n-    #[inline]\n-    fn with_c_str<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        (**self).with_c_str(f)\n-    }\n-\n-    #[inline]\n-    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        (**self).with_c_str_unchecked(f)\n-    }\n-}\n-\n-// Unsafe function that handles possibly copying the &[u8] into a stack array.\n-unsafe fn with_c_str<T, F>(v: &[u8], checked: bool, f: F) -> T where\n-    F: FnOnce(*const libc::c_char) -> T,\n-{\n-    let c_str = if v.len() < BUF_LEN {\n-        let mut buf: [u8; BUF_LEN] = mem::uninitialized();\n-        slice::bytes::copy_memory(&mut buf, v);\n-        buf[v.len()] = 0;\n-\n-        let buf = buf.as_mut_ptr();\n-        if checked {\n-            check_for_null(v, buf as *mut libc::c_char);\n-        }\n-\n-        return f(buf as *const libc::c_char)\n-    } else if checked {\n-        v.to_c_str()\n-    } else {\n-        v.to_c_str_unchecked()\n-    };\n-\n-    f(c_str.as_ptr())\n-}\n-\n-#[inline]\n-fn check_for_null(v: &[u8], buf: *mut libc::c_char) {\n-    for i in range(0, v.len()) {\n-        unsafe {\n-            let p = buf.offset(i as int);\n-            assert!(*p != 0);\n-        }\n-    }\n-}\n-\n-/// External iterator for a CString's bytes.\n-///\n-/// Use with the `std::iter` module.\n-#[allow(raw_pointer_deriving)]\n-#[derive(Clone)]\n-pub struct CChars<'a> {\n-    ptr: *const libc::c_char,\n-    marker: marker::ContravariantLifetime<'a>,\n-}\n-\n-impl<'a> Iterator for CChars<'a> {\n-    type Item = libc::c_char;\n-\n-    fn next(&mut self) -> Option<libc::c_char> {\n-        let ch = unsafe { *self.ptr };\n-        if ch == 0 {\n-            None\n-        } else {\n-            self.ptr = unsafe { self.ptr.offset(1) };\n-            Some(ch)\n-        }\n-    }\n-}\n-\n-/// Parses a C \"multistring\", eg windows env values or\n-/// the req->ptr result in a uv_fs_readdir() call.\n-///\n-/// Optionally, a `count` can be passed in, limiting the\n-/// parsing to only being done `count`-times.\n-///\n-/// The specified closure is invoked with each string that\n-/// is found, and the number of strings found is returned.\n-pub unsafe fn from_c_multistring<F>(buf: *const libc::c_char,\n-                                    count: Option<uint>,\n-                                    mut f: F)\n-                                    -> uint where\n-    F: FnMut(&CString),\n-{\n-\n-    let mut curr_ptr: uint = buf as uint;\n-    let mut ctr = 0;\n-    let (limited_count, limit) = match count {\n-        Some(limit) => (true, limit),\n-        None => (false, 0)\n-    };\n-    while ((limited_count && ctr < limit) || !limited_count)\n-          && *(curr_ptr as *const libc::c_char) != 0 as libc::c_char {\n-        let cstr = CString::new(curr_ptr as *const libc::c_char, false);\n-        f(&cstr);\n-        curr_ptr += cstr.len() + 1;\n-        ctr += 1;\n-    }\n-    return ctr;\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-    use super::*;\n-    use ptr;\n-    use thread::Thread;\n-    use libc;\n-\n-    #[test]\n-    fn test_str_multistring_parsing() {\n-        unsafe {\n-            let input = b\"zero\\0one\\0\\0\";\n-            let ptr = input.as_ptr();\n-            let expected = [\"zero\", \"one\"];\n-            let mut it = expected.iter();\n-            let result = from_c_multistring(ptr as *const libc::c_char, None, |c| {\n-                let cbytes = c.as_bytes_no_nul();\n-                assert_eq!(cbytes, it.next().unwrap().as_bytes());\n-            });\n-            assert_eq!(result, 2);\n-            assert!(it.next().is_none());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_str_to_c_str() {\n-        let c_str = \"\".to_c_str();\n-        unsafe {\n-            assert_eq!(*c_str.as_ptr().offset(0), 0);\n-        }\n-\n-        let c_str = \"hello\".to_c_str();\n-        let buf = c_str.as_ptr();\n-        unsafe {\n-            assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n-            assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n-            assert_eq!(*buf.offset(2), 'l' as libc::c_char);\n-            assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n-            assert_eq!(*buf.offset(4), 'o' as libc::c_char);\n-            assert_eq!(*buf.offset(5), 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_vec_to_c_str() {\n-        let b: &[u8] = &[];\n-        let c_str = b.to_c_str();\n-        unsafe {\n-            assert_eq!(*c_str.as_ptr().offset(0), 0);\n-        }\n-\n-        let c_str = b\"hello\".to_c_str();\n-        let buf = c_str.as_ptr();\n-        unsafe {\n-            assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n-            assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n-            assert_eq!(*buf.offset(2), 'l' as libc::c_char);\n-            assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n-            assert_eq!(*buf.offset(4), 'o' as libc::c_char);\n-            assert_eq!(*buf.offset(5), 0);\n-        }\n-\n-        let c_str = b\"foo\\xFF\".to_c_str();\n-        let buf = c_str.as_ptr();\n-        unsafe {\n-            assert_eq!(*buf.offset(0), 'f' as libc::c_char);\n-            assert_eq!(*buf.offset(1), 'o' as libc::c_char);\n-            assert_eq!(*buf.offset(2), 'o' as libc::c_char);\n-            assert_eq!(*buf.offset(3), 0xffu8 as libc::c_char);\n-            assert_eq!(*buf.offset(4), 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unwrap() {\n-        let c_str = \"hello\".to_c_str();\n-        unsafe { libc::free(c_str.into_inner() as *mut libc::c_void) }\n-    }\n-\n-    #[test]\n-    fn test_as_ptr() {\n-        let c_str = \"hello\".to_c_str();\n-        let len = unsafe { libc::strlen(c_str.as_ptr()) };\n-        assert_eq!(len, 5);\n-    }\n-\n-    #[test]\n-    fn test_iterator() {\n-        let c_str = \"\".to_c_str();\n-        let mut iter = c_str.iter();\n-        assert_eq!(iter.next(), None);\n-\n-        let c_str = \"hello\".to_c_str();\n-        let mut iter = c_str.iter();\n-        assert_eq!(iter.next(), Some('h' as libc::c_char));\n-        assert_eq!(iter.next(), Some('e' as libc::c_char));\n-        assert_eq!(iter.next(), Some('l' as libc::c_char));\n-        assert_eq!(iter.next(), Some('l' as libc::c_char));\n-        assert_eq!(iter.next(), Some('o' as libc::c_char));\n-        assert_eq!(iter.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_to_c_str_fail() {\n-        assert!(Thread::spawn(move|| { \"he\\x00llo\".to_c_str() }).join().is_err());\n-    }\n-\n-    #[test]\n-    fn test_to_c_str_unchecked() {\n-        unsafe {\n-            let c_string = \"he\\x00llo\".to_c_str_unchecked();\n-            let buf = c_string.as_ptr();\n-            assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n-            assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n-            assert_eq!(*buf.offset(2), 0);\n-            assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n-            assert_eq!(*buf.offset(4), 'l' as libc::c_char);\n-            assert_eq!(*buf.offset(5), 'o' as libc::c_char);\n-            assert_eq!(*buf.offset(6), 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_as_bytes() {\n-        let c_str = \"hello\".to_c_str();\n-        assert_eq!(c_str.as_bytes(), b\"hello\\0\");\n-        let c_str = \"\".to_c_str();\n-        assert_eq!(c_str.as_bytes(), b\"\\0\");\n-        let c_str = b\"foo\\xFF\".to_c_str();\n-        assert_eq!(c_str.as_bytes(), b\"foo\\xFF\\0\");\n-    }\n-\n-    #[test]\n-    fn test_as_bytes_no_nul() {\n-        let c_str = \"hello\".to_c_str();\n-        assert_eq!(c_str.as_bytes_no_nul(), b\"hello\");\n-        let c_str = \"\".to_c_str();\n-        let exp: &[u8] = &[];\n-        assert_eq!(c_str.as_bytes_no_nul(), exp);\n-        let c_str = b\"foo\\xFF\".to_c_str();\n-        assert_eq!(c_str.as_bytes_no_nul(), b\"foo\\xFF\");\n-    }\n-\n-    #[test]\n-    fn test_as_str() {\n-        let c_str = \"hello\".to_c_str();\n-        assert_eq!(c_str.as_str(), Some(\"hello\"));\n-        let c_str = \"\".to_c_str();\n-        assert_eq!(c_str.as_str(), Some(\"\"));\n-        let c_str = b\"foo\\xFF\".to_c_str();\n-        assert_eq!(c_str.as_str(), None);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_new_fail() {\n-        let _c_str = unsafe { CString::new(ptr::null(), false) };\n-    }\n-\n-    #[test]\n-    fn test_clone() {\n-        let a = \"hello\".to_c_str();\n-        let b = a.clone();\n-        assert!(a == b);\n-    }\n-\n-    #[test]\n-    fn test_clone_noleak() {\n-        fn foo<F>(f: F) where F: FnOnce(&CString) {\n-            let s = \"test\".to_string();\n-            let c = s.to_c_str();\n-            // give the closure a non-owned CString\n-            let mut c_ = unsafe { CString::new(c.as_ptr(), false) };\n-            f(&c_);\n-            // muck with the buffer for later printing\n-            unsafe { *c_.as_mut_ptr() = 'X' as libc::c_char }\n-        }\n-\n-        let mut c_: Option<CString> = None;\n-        foo(|c| {\n-            c_ = Some(c.clone());\n-            c.clone();\n-            // force a copy, reading the memory\n-            c.as_bytes().to_vec();\n-        });\n-        let c_ = c_.unwrap();\n-        // force a copy, reading the memory\n-        c_.as_bytes().to_vec();\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-\n-    use prelude::v1::*;\n-    use self::test::Bencher;\n-    use libc;\n-    use c_str::ToCStr;\n-\n-    #[inline]\n-    fn check(s: &str, c_str: *const libc::c_char) {\n-        let s_buf = s.as_ptr();\n-        for i in range(0, s.len()) {\n-            unsafe {\n-                assert_eq!(\n-                    *s_buf.offset(i as int) as libc::c_char,\n-                    *c_str.offset(i as int));\n-            }\n-        }\n-    }\n-\n-    static S_SHORT: &'static str = \"Mary\";\n-    static S_MEDIUM: &'static str = \"Mary had a little lamb\";\n-    static S_LONG: &'static str = \"\\\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\";\n-\n-    fn bench_to_string(b: &mut Bencher, s: &str) {\n-        b.iter(|| {\n-            let c_str = s.to_c_str();\n-            check(s, c_str.as_ptr());\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_short(b: &mut Bencher) {\n-        bench_to_string(b, S_SHORT)\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_medium(b: &mut Bencher) {\n-        bench_to_string(b, S_MEDIUM)\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_long(b: &mut Bencher) {\n-        bench_to_string(b, S_LONG)\n-    }\n-\n-    fn bench_to_c_str_unchecked(b: &mut Bencher, s: &str) {\n-        b.iter(|| {\n-            let c_str = unsafe { s.to_c_str_unchecked() };\n-            check(s, c_str.as_ptr())\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_unchecked_short(b: &mut Bencher) {\n-        bench_to_c_str_unchecked(b, S_SHORT)\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_unchecked_medium(b: &mut Bencher) {\n-        bench_to_c_str_unchecked(b, S_MEDIUM)\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_unchecked_long(b: &mut Bencher) {\n-        bench_to_c_str_unchecked(b, S_LONG)\n-    }\n-\n-    fn bench_with_c_str(b: &mut Bencher, s: &str) {\n-        b.iter(|| {\n-            s.with_c_str(|c_str_buf| check(s, c_str_buf))\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_short(b: &mut Bencher) {\n-        bench_with_c_str(b, S_SHORT)\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_medium(b: &mut Bencher) {\n-        bench_with_c_str(b, S_MEDIUM)\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_long(b: &mut Bencher) {\n-        bench_with_c_str(b, S_LONG)\n-    }\n-\n-    fn bench_with_c_str_unchecked(b: &mut Bencher, s: &str) {\n-        b.iter(|| {\n-            unsafe {\n-                s.with_c_str_unchecked(|c_str_buf| check(s, c_str_buf))\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_unchecked_short(b: &mut Bencher) {\n-        bench_with_c_str_unchecked(b, S_SHORT)\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_unchecked_medium(b: &mut Bencher) {\n-        bench_with_c_str_unchecked(b, S_MEDIUM)\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_unchecked_long(b: &mut Bencher) {\n-        bench_with_c_str_unchecked(b, S_LONG)\n-    }\n-}"}, {"sha": "4a20208f31a6ae49ad7c7a80f71eb62bcfc293c4", "filename": "src/libstd/c_vec.rs", "status": "removed", "additions": 0, "deletions": 232, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/1f732ef53d54ccfc3e7728390ffbcea8a696ecee/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f732ef53d54ccfc3e7728390ffbcea8a696ecee/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=1f732ef53d54ccfc3e7728390ffbcea8a696ecee", "patch": "@@ -1,232 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Library to interface with chunks of memory allocated in C.\n-//!\n-//! It is often desirable to safely interface with memory allocated from C,\n-//! encapsulating the unsafety into allocation and destruction time.  Indeed,\n-//! allocating memory externally is currently the only way to give Rust shared\n-//! mut state with C programs that keep their own references; vectors are\n-//! unsuitable because they could be reallocated or moved at any time, and\n-//! importing C memory into a vector takes a one-time snapshot of the memory.\n-//!\n-//! This module simplifies the usage of such external blocks of memory.  Memory\n-//! is encapsulated into an opaque object after creation; the lifecycle of the\n-//! memory can be optionally managed by Rust, if an appropriate destructor\n-//! closure is provided.  Safety is ensured by bounds-checking accesses, which\n-//! are marshalled through get and set functions.\n-//!\n-//! There are three unsafe functions: the two constructors, and the\n-//! unwrap method. The constructors are unsafe for the\n-//! obvious reason (they act on a pointer that cannot be checked inside the\n-//! method), but `unwrap()` is somewhat more subtle in its unsafety.\n-//! It returns the contained pointer, but at the same time destroys the CVec\n-//! without running its destructor. This can be used to pass memory back to\n-//! C, but care must be taken that the ownership of underlying resources are\n-//! handled correctly, i.e. that allocated memory is eventually freed\n-//! if necessary.\n-\n-#![experimental]\n-\n-use kinds::Send;\n-use mem;\n-use ops::{Drop, FnOnce};\n-use option::Option;\n-use option::Option::{Some, None};\n-use ptr::PtrExt;\n-use ptr;\n-use raw;\n-use slice::AsSlice;\n-use thunk::{Thunk};\n-\n-/// The type representing a foreign chunk of memory\n-pub struct CVec<T> {\n-    base: *mut T,\n-    len: uint,\n-    dtor: Option<Thunk>,\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for CVec<T> {\n-    fn drop(&mut self) {\n-        match self.dtor.take() {\n-            None => (),\n-            Some(f) => f.invoke(())\n-        }\n-    }\n-}\n-\n-impl<T> CVec<T> {\n-    /// Create a `CVec` from a raw pointer to a buffer with a given length.\n-    ///\n-    /// Panics if the given pointer is null. The returned vector will not attempt\n-    /// to deallocate the vector when dropped.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * base - A raw pointer to a buffer\n-    /// * len - The number of elements in the buffer\n-    pub unsafe fn new(base: *mut T, len: uint) -> CVec<T> {\n-        assert!(base != ptr::null_mut());\n-        CVec {\n-            base: base,\n-            len: len,\n-            dtor: None,\n-        }\n-    }\n-\n-    /// Create a `CVec` from a foreign buffer, with a given length,\n-    /// and a function to run upon destruction.\n-    ///\n-    /// Panics if the given pointer is null.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * base - A foreign pointer to a buffer\n-    /// * len - The number of elements in the buffer\n-    /// * dtor - A fn to run when the value is destructed, useful\n-    ///          for freeing the buffer, etc.\n-    pub unsafe fn new_with_dtor<F>(base: *mut T,\n-                                   len: uint,\n-                                   dtor: F)\n-                                   -> CVec<T>\n-        where F : FnOnce(), F : Send\n-    {\n-        assert!(base != ptr::null_mut());\n-        let dtor: Thunk = Thunk::new(dtor);\n-        CVec {\n-            base: base,\n-            len: len,\n-            dtor: Some(dtor)\n-        }\n-    }\n-\n-    /// View the stored data as a mutable slice.\n-    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        unsafe {\n-            mem::transmute(raw::Slice { data: self.base as *const T, len: self.len })\n-        }\n-    }\n-\n-    /// Retrieves an element at a given index, returning `None` if the requested\n-    /// index is greater than the length of the vector.\n-    pub fn get<'a>(&'a self, ofs: uint) -> Option<&'a T> {\n-        if ofs < self.len {\n-            Some(unsafe { &*self.base.offset(ofs as int) })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Retrieves a mutable element at a given index, returning `None` if the\n-    /// requested index is greater than the length of the vector.\n-    pub fn get_mut<'a>(&'a mut self, ofs: uint) -> Option<&'a mut T> {\n-        if ofs < self.len {\n-            Some(unsafe { &mut *self.base.offset(ofs as int) })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Unwrap the pointer without running the destructor\n-    ///\n-    /// This method retrieves the underlying pointer, and in the process\n-    /// destroys the CVec but without running the destructor. A use case\n-    /// would be transferring ownership of the buffer to a C function, as\n-    /// in this case you would not want to run the destructor.\n-    ///\n-    /// Note that if you want to access the underlying pointer without\n-    /// cancelling the destructor, you can simply call `transmute` on the return\n-    /// value of `get(0)`.\n-    pub unsafe fn into_inner(mut self) -> *mut T {\n-        self.dtor = None;\n-        self.base\n-    }\n-\n-    /// Returns the number of items in this vector.\n-    pub fn len(&self) -> uint { self.len }\n-\n-    /// Returns whether this vector is empty.\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-}\n-\n-impl<T> AsSlice<T> for CVec<T> {\n-    /// View the stored data as a slice.\n-    fn as_slice<'a>(&'a self) -> &'a [T] {\n-        unsafe {\n-            mem::transmute(raw::Slice { data: self.base as *const T, len: self.len })\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-\n-    use super::CVec;\n-    use libc;\n-    use ptr;\n-\n-    fn malloc(n: uint) -> CVec<u8> {\n-        unsafe {\n-            let mem = ptr::Unique(libc::malloc(n as libc::size_t));\n-            if mem.0.is_null() { ::alloc::oom() }\n-\n-            CVec::new_with_dtor(mem.0 as *mut u8,\n-                                n,\n-                                move|| { libc::free(mem.0 as *mut libc::c_void); })\n-        }\n-    }\n-\n-    #[test]\n-    fn test_basic() {\n-        let mut cv = malloc(16);\n-\n-        *cv.get_mut(3).unwrap() = 8;\n-        *cv.get_mut(4).unwrap() = 9;\n-        assert_eq!(*cv.get(3).unwrap(), 8);\n-        assert_eq!(*cv.get(4).unwrap(), 9);\n-        assert_eq!(cv.len(), 16);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_panic_at_null() {\n-        unsafe {\n-            CVec::new(ptr::null_mut::<u8>(), 9);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_overrun_get() {\n-        let cv = malloc(16);\n-\n-        assert!(cv.get(17).is_none());\n-    }\n-\n-    #[test]\n-    fn test_overrun_set() {\n-        let mut cv = malloc(16);\n-\n-        assert!(cv.get_mut(17).is_none());\n-    }\n-\n-    #[test]\n-    fn test_unwrap() {\n-        unsafe {\n-            let cv = CVec::new_with_dtor(1 as *mut int,\n-                                         0,\n-                                         move|:| panic!(\"Don't run this destructor!\"));\n-            let p = cv.into_inner();\n-            assert_eq!(p, 1 as *mut int);\n-        }\n-    }\n-\n-}"}, {"sha": "66cb1f2c948d9ff28dc0c2fca7cf9c88f2daf13b", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -17,7 +17,7 @@\n \n use prelude::v1::*;\n \n-use c_str::ToCStr;\n+use ffi::CString;\n use mem;\n use os;\n use str;\n@@ -51,13 +51,11 @@ impl DynamicLibrary {\n \n     /// Lazily open a dynamic library. When passed None it gives a\n     /// handle to the calling process\n-    pub fn open<T: ToCStr>(filename: Option<T>)\n-                        -> Result<DynamicLibrary, String> {\n+    pub fn open(filename: Option<&Path>) -> Result<DynamicLibrary, String> {\n         unsafe {\n-            let mut filename = filename;\n             let maybe_library = dl::check_for_errors_in(|| {\n-                match filename.take() {\n-                    Some(name) => dl::open_external(name),\n+                match filename {\n+                    Some(name) => dl::open_external(name.as_vec()),\n                     None => dl::open_internal()\n                 }\n             });\n@@ -131,9 +129,8 @@ impl DynamicLibrary {\n         // T but that feature is still unimplemented\n \n         let maybe_symbol_value = dl::check_for_errors_in(|| {\n-            symbol.with_c_str(|raw_string| {\n-                dl::symbol(self.handle, raw_string)\n-            })\n+            let raw_string = CString::from_slice(symbol.as_bytes());\n+            dl::symbol(self.handle, raw_string.as_ptr())\n         });\n \n         // The value must not be constructed if there is an error so\n@@ -157,7 +154,7 @@ mod test {\n     fn test_loading_cosine() {\n         // The math library does not need to be loaded since it is already\n         // statically linked in\n-        let none: Option<Path> = None; // appease the typechecker\n+        let none: Option<&Path> = None; // appease the typechecker\n         let libm = match DynamicLibrary::open(none) {\n             Err(error) => panic!(\"Could not load self as module: {}\", error),\n             Ok(libm) => libm\n@@ -202,17 +199,17 @@ mod test {\n           target_os = \"freebsd\",\n           target_os = \"dragonfly\"))]\n pub mod dl {\n-    use self::Rtld::*;\n-\n+    pub use self::Rtld::*;\n     use prelude::v1::*;\n-    use c_str::{CString, ToCStr};\n+\n+    use ffi::{self, CString};\n+    use str;\n     use libc;\n     use ptr;\n \n-    pub unsafe fn open_external<T: ToCStr>(filename: T) -> *mut u8 {\n-        filename.with_c_str(|raw_name| {\n-            dlopen(raw_name, Lazy as libc::c_int) as *mut u8\n-        })\n+    pub unsafe fn open_external(filename: &[u8]) -> *mut u8 {\n+        let s = CString::from_slice(filename);\n+        dlopen(s.as_ptr(), Lazy as libc::c_int) as *mut u8\n     }\n \n     pub unsafe fn open_internal() -> *mut u8 {\n@@ -236,8 +233,8 @@ pub mod dl {\n             let ret = if ptr::null() == last_error {\n                 Ok(result)\n             } else {\n-                Err(String::from_str(CString::new(last_error, false).as_str()\n-                    .unwrap()))\n+                let s = ffi::c_str_to_bytes(&last_error);\n+                Err(str::from_utf8(s).unwrap().to_string())\n             };\n \n             ret\n@@ -273,7 +270,6 @@ pub mod dl {\n \n #[cfg(target_os = \"windows\")]\n pub mod dl {\n-    use c_str::ToCStr;\n     use iter::IteratorExt;\n     use libc;\n     use ops::FnOnce;\n@@ -287,10 +283,9 @@ pub mod dl {\n     use string::String;\n     use vec::Vec;\n \n-    pub unsafe fn open_external<T: ToCStr>(filename: T) -> *mut u8 {\n+    pub unsafe fn open_external(filename: &[u8]) -> *mut u8 {\n         // Windows expects Unicode data\n-        let filename_cstr = filename.to_c_str();\n-        let filename_str = str::from_utf8(filename_cstr.as_bytes_no_nul()).unwrap();\n+        let filename_str = str::from_utf8(filename).unwrap();\n         let mut filename_str: Vec<u16> = filename_str.utf16_units().collect();\n         filename_str.push(0);\n         LoadLibraryW(filename_str.as_ptr() as *const libc::c_void) as *mut u8"}, {"sha": "bef2344d9e8bc4e8cae962a3c0c3e0bf821cc772", "filename": "src/libstd/ffi/c_str.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -0,0 +1,218 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fmt;\n+use iter::IteratorExt;\n+use libc;\n+use mem;\n+use ops::Deref;\n+use slice::{self, SliceExt, AsSlice};\n+use string::String;\n+use vec::Vec;\n+\n+/// A type representing a C-compatible string\n+///\n+/// This type serves the primary purpose of being able to generate a\n+/// C-compatible string from a Rust byte slice or vector. An instance of this\n+/// type is a static guarantee that the underlying bytes contain no interior 0\n+/// bytes and the final byte is 0.\n+///\n+/// A `CString` is created from either a byte slice or a byte vector. After\n+/// being created, a `CString` predominately inherits all of its methods from\n+/// the `Deref` implementation to `[libc::c_char]`. Note that the underlying\n+/// array is represented as an array of `libc::c_char` as opposed to `u8`. A\n+/// `u8` slice can be obtained with the `as_bytes` method.  Slices produced from\n+/// a `CString` do *not* contain the trailing nul terminator unless otherwise\n+/// specified.\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// # extern crate libc;\n+/// # fn main() {\n+/// use std::ffi::CString;\n+/// use libc;\n+///\n+/// extern {\n+///     fn my_printer(s: *const libc::c_char);\n+/// }\n+///\n+/// let to_print = \"Hello, world!\";\n+/// let c_to_print = CString::from_slice(to_print.as_bytes());\n+/// unsafe {\n+///     my_printer(c_to_print.as_ptr());\n+/// }\n+/// # }\n+/// ```\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash)]\n+pub struct CString {\n+    inner: Vec<libc::c_char>,\n+}\n+\n+impl CString {\n+    /// Create a new C-compatible string from a byte slice.\n+    ///\n+    /// This method will copy the data of the slice provided into a new\n+    /// allocation, ensuring that there is a trailing 0 byte.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if there are any 0 bytes already in the slice\n+    /// provided.\n+    pub fn from_slice(v: &[u8]) -> CString {\n+        CString::from_vec(v.to_vec())\n+    }\n+\n+    /// Create a C-compatible string from a byte vector.\n+    ///\n+    /// This method will consume ownership of the provided vector, appending a 0\n+    /// byte to the end after verifying that there are no interior 0 bytes.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if there are any 0 bytes already in the vector\n+    /// provided.\n+    pub fn from_vec(v: Vec<u8>) -> CString {\n+        assert!(!v.iter().any(|&x| x == 0));\n+        unsafe { CString::from_vec_unchecked(v) }\n+    }\n+\n+    /// Create a C-compatibel string from a byte vector without checking for\n+    /// interior 0 bytes.\n+    ///\n+    /// This method is equivalent to `from_vec` except that no runtime assertion\n+    /// is made that `v` contains no 0 bytes.\n+    pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString {\n+        v.push(0);\n+        CString { inner: mem::transmute(v) }\n+    }\n+\n+    /// Create a view into this C string which includes the trailing nul\n+    /// terminator at the end of the string.\n+    pub fn as_slice_with_nul(&self) -> &[libc::c_char] { self.inner.as_slice() }\n+\n+    /// Similar to the `as_slice` method, but returns a `u8` slice instead of a\n+    /// `libc::c_char` slice.\n+    pub fn as_bytes(&self) -> &[u8] {\n+        unsafe { mem::transmute(self.as_slice()) }\n+    }\n+\n+    /// Equivalend to `as_slice_with_nul` except that the type returned is a\n+    /// `u8` slice instead of a `libc::c_char` slice.\n+    pub fn as_bytes_with_nul(&self) -> &[u8] {\n+        unsafe { mem::transmute(self.as_slice_with_nul()) }\n+    }\n+}\n+\n+impl Deref for CString {\n+    type Target = [libc::c_char];\n+\n+    fn deref(&self) -> &[libc::c_char] {\n+        self.inner.slice_to(self.inner.len() - 1)\n+    }\n+}\n+\n+impl fmt::Show for CString {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        String::from_utf8_lossy(self.as_bytes()).fmt(f)\n+    }\n+}\n+\n+/// Interpret a C string as a byte slice.\n+///\n+/// This function will calculate the length of the C string provided, and it\n+/// will then return a corresponding slice for the contents of the C string not\n+/// including the nul terminator.\n+///\n+/// This function will tie the lifetime of the returned slice to the lifetime of\n+/// the pointer provided. This is done to help prevent the slice from escaping\n+/// the lifetime of the pointer itself. If a longer lifetime is needed, then\n+/// `mem::copy_lifetime` should be used.\n+///\n+/// This function is unsafe because there is no guarantee of the validity of the\n+/// pointer `raw` or a guarantee that a nul terminator will be found.\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// # extern crate libc;\n+/// # fn main() {\n+/// use std::ffi;\n+/// use std::str;\n+/// use libc;\n+///\n+/// extern {\n+///     fn my_string() -> *const libc::c_char;\n+/// }\n+///\n+/// unsafe {\n+///     let to_print = my_string();\n+///     let slice = ffi::c_str_to_bytes(&to_print);\n+///     println!(\"string returned: {}\", str::from_utf8(slice).unwrap());\n+/// }\n+/// # }\n+/// ```\n+pub unsafe fn c_str_to_bytes<'a>(raw: &'a *const libc::c_char) -> &'a [u8] {\n+    let len = libc::strlen(*raw);\n+    slice::from_raw_buf(&*(raw as *const _ as *const *const u8), len as uint)\n+}\n+\n+/// Interpret a C string as a byte slice with the nul terminator.\n+///\n+/// This function is identical to `from_raw_buf` except that the returned slice\n+/// will include the nul terminator of the string.\n+pub unsafe fn c_str_to_bytes_with_nul<'a>(raw: &'a *const libc::c_char) -> &'a [u8] {\n+    let len = libc::strlen(*raw) + 1;\n+    slice::from_raw_buf(&*(raw as *const _ as *const *const u8), len as uint)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use super::*;\n+    use libc;\n+    use mem;\n+\n+    #[test]\n+    fn c_to_rust() {\n+        let data = b\"123\\0\";\n+        let ptr = data.as_ptr() as *const libc::c_char;\n+        unsafe {\n+            assert_eq!(c_str_to_bytes(&ptr), b\"123\");\n+            assert_eq!(c_str_to_bytes_with_nul(&ptr), b\"123\\0\");\n+        }\n+    }\n+\n+    #[test]\n+    fn simple() {\n+        let s = CString::from_slice(b\"1234\");\n+        assert_eq!(s.as_bytes(), b\"1234\");\n+        assert_eq!(s.as_bytes_with_nul(), b\"1234\\0\");\n+        unsafe {\n+            assert_eq!(s.as_slice(),\n+                       mem::transmute::<_, &[libc::c_char]>(b\"1234\"));\n+            assert_eq!(s.as_slice_with_nul(),\n+                       mem::transmute::<_, &[libc::c_char]>(b\"1234\\0\"));\n+        }\n+    }\n+\n+    #[should_fail] #[test]\n+    fn build_with_zero1() { CString::from_slice(b\"\\0\"); }\n+    #[should_fail] #[test]\n+    fn build_with_zero2() { CString::from_vec(vec![0]); }\n+\n+    #[test]\n+    fn build_with_zero3() {\n+        unsafe {\n+            let s = CString::from_vec_unchecked(vec![0]);\n+            assert_eq!(s.as_bytes(), b\"\\0\");\n+        }\n+    }\n+}"}, {"sha": "cc86f804e3eb1347772e143287da0443728f67e4", "filename": "src/libstd/ffi/mod.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Utilities related to FFI bindings.\n+\n+#![unstable = \"module just underwent fairly large reorganization and the dust \\\n+               still needs to settle\"]\n+\n+pub use self::c_str::CString;\n+pub use self::c_str::c_str_to_bytes;\n+pub use self::c_str::c_str_to_bytes_with_nul;\n+\n+mod c_str;"}, {"sha": "738c70412f78a0aa3def5993a313879ecdeed747", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -22,7 +22,8 @@\n \n use prelude::v1::*;\n \n-use c_str::ToCStr;\n+use ffi::CString;\n+use path::BytesContainer;\n use io::{Listener, Acceptor, IoResult, TimedOut, standard_error};\n use sys::pipe::UnixAcceptor as UnixAcceptorImp;\n use sys::pipe::UnixListener as UnixListenerImp;\n@@ -53,8 +54,9 @@ impl UnixStream {\n     /// let mut stream = UnixStream::connect(&server);\n     /// stream.write(&[1, 2, 3]);\n     /// ```\n-    pub fn connect<P: ToCStr>(path: &P) -> IoResult<UnixStream> {\n-        UnixStreamImp::connect(&path.to_c_str(), None)\n+    pub fn connect<P: BytesContainer>(path: P) -> IoResult<UnixStream> {\n+        let path = CString::from_slice(path.container_as_bytes());\n+        UnixStreamImp::connect(&path, None)\n             .map(|inner| UnixStream { inner: inner })\n     }\n \n@@ -67,13 +69,15 @@ impl UnixStream {\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n     #[experimental = \"the timeout argument is likely to change types\"]\n-    pub fn connect_timeout<P: ToCStr>(path: &P,\n-                                      timeout: Duration) -> IoResult<UnixStream> {\n+    pub fn connect_timeout<P>(path: P, timeout: Duration)\n+                              -> IoResult<UnixStream>\n+                              where P: BytesContainer {\n         if timeout <= Duration::milliseconds(0) {\n             return Err(standard_error(TimedOut));\n         }\n \n-        UnixStreamImp::connect(&path.to_c_str(), Some(timeout.num_milliseconds() as u64))\n+        let path = CString::from_slice(path.container_as_bytes());\n+        UnixStreamImp::connect(&path, Some(timeout.num_milliseconds() as u64))\n             .map(|inner| UnixStream { inner: inner })\n     }\n \n@@ -177,8 +181,9 @@ impl UnixListener {\n     /// }\n     /// # }\n     /// ```\n-    pub fn bind<P: ToCStr>(path: &P) -> IoResult<UnixListener> {\n-        UnixListenerImp::bind(&path.to_c_str())\n+    pub fn bind<P: BytesContainer>(path: P) -> IoResult<UnixListener> {\n+        let path = CString::from_slice(path.container_as_bytes());\n+        UnixListenerImp::bind(&path)\n             .map(|inner| UnixListener { inner: inner })\n     }\n }"}, {"sha": "ea232ad0c3f1b0876b1d860fb1dd1447397b7d1f", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 46, "deletions": 35, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -18,8 +18,8 @@ pub use self::ProcessExit::*;\n \n use prelude::v1::*;\n \n-use c_str::{CString, ToCStr};\n use collections::HashMap;\n+use ffi::CString;\n use fmt;\n use hash::Hash;\n use io::pipe::{PipeStream, PipePair};\n@@ -35,6 +35,7 @@ use sys;\n use thread::Thread;\n \n #[cfg(windows)] use std::hash::sip::SipState;\n+#[cfg(windows)] use str;\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n /// SIGTERM on unix platforms.\n@@ -109,11 +110,11 @@ struct EnvKey(CString);\n impl Hash for EnvKey {\n     fn hash(&self, state: &mut SipState) {\n         let &EnvKey(ref x) = self;\n-        match x.as_str() {\n-            Some(s) => for ch in s.chars() {\n+        match str::from_utf8(x.as_bytes()) {\n+            Ok(s) => for ch in s.chars() {\n                 (ch as u8 as char).to_lowercase().hash(state);\n             },\n-            None => x.hash(state)\n+            Err(..) => x.hash(state)\n         }\n     }\n }\n@@ -123,8 +124,8 @@ impl PartialEq for EnvKey {\n     fn eq(&self, other: &EnvKey) -> bool {\n         let &EnvKey(ref x) = self;\n         let &EnvKey(ref y) = other;\n-        match (x.as_str(), y.as_str()) {\n-            (Some(xs), Some(ys)) => {\n+        match (str::from_utf8(x.as_bytes()), str::from_utf8(y.as_bytes())) {\n+            (Ok(xs), Ok(ys)) => {\n                 if xs.len() != ys.len() {\n                     return false\n                 } else {\n@@ -185,10 +186,10 @@ pub struct Command {\n }\n \n // FIXME (#12938): Until DST lands, we cannot decompose &str into & and str, so\n-// we cannot usefully take ToCStr arguments by reference (without forcing an\n+// we cannot usefully take BytesContainer arguments by reference (without forcing an\n // additional & around &str). So we are instead temporarily adding an instance\n-// for &Path, so that we can take ToCStr as owned. When DST lands, the &Path\n-// instance should be removed, and arguments bound by ToCStr should be passed by\n+// for &Path, so that we can take BytesContainer as owned. When DST lands, the &Path\n+// instance should be removed, and arguments bound by BytesContainer should be passed by\n // reference. (Here: {new, arg, args, env}.)\n \n impl Command {\n@@ -203,9 +204,9 @@ impl Command {\n     ///\n     /// Builder methods are provided to change these defaults and\n     /// otherwise configure the process.\n-    pub fn new<T:ToCStr>(program: T) -> Command {\n+    pub fn new<T: BytesContainer>(program: T) -> Command {\n         Command {\n-            program: program.to_c_str(),\n+            program: CString::from_slice(program.container_as_bytes()),\n             args: Vec::new(),\n             env: None,\n             cwd: None,\n@@ -219,27 +220,29 @@ impl Command {\n     }\n \n     /// Add an argument to pass to the program.\n-    pub fn arg<'a, T: ToCStr>(&'a mut self, arg: T) -> &'a mut Command {\n-        self.args.push(arg.to_c_str());\n+    pub fn arg<'a, T: BytesContainer>(&'a mut self, arg: T) -> &'a mut Command {\n+        self.args.push(CString::from_slice(arg.container_as_bytes()));\n         self\n     }\n \n     /// Add multiple arguments to pass to the program.\n-    pub fn args<'a, T: ToCStr>(&'a mut self, args: &[T]) -> &'a mut Command {\n-        self.args.extend(args.iter().map(|arg| arg.to_c_str()));;\n+    pub fn args<'a, T: BytesContainer>(&'a mut self, args: &[T]) -> &'a mut Command {\n+        self.args.extend(args.iter().map(|arg| {\n+            CString::from_slice(arg.container_as_bytes())\n+        }));\n         self\n     }\n     // Get a mutable borrow of the environment variable map for this `Command`.\n-    fn get_env_map<'a>(&'a mut self) -> &'a mut  EnvMap {\n+    fn get_env_map<'a>(&'a mut self) -> &'a mut EnvMap {\n         match self.env {\n             Some(ref mut map) => map,\n             None => {\n                 // if the env is currently just inheriting from the parent's,\n                 // materialize the parent's env into a hashtable.\n-                self.env = Some(os::env_as_bytes().into_iter()\n-                                   .map(|(k, v)| (EnvKey(k.to_c_str()),\n-                                                  v.to_c_str()))\n-                                   .collect());\n+                self.env = Some(os::env_as_bytes().into_iter().map(|(k, v)| {\n+                    (EnvKey(CString::from_slice(k.as_slice())),\n+                     CString::from_slice(v.as_slice()))\n+                }).collect());\n                 self.env.as_mut().unwrap()\n             }\n         }\n@@ -249,32 +252,40 @@ impl Command {\n     ///\n     /// Note that environment variable names are case-insensitive (but case-preserving) on Windows,\n     /// and case-sensitive on all other platforms.\n-    pub fn env<'a, T: ToCStr, U: ToCStr>(&'a mut self, key: T, val: U)\n-                                         -> &'a mut Command {\n-        self.get_env_map().insert(EnvKey(key.to_c_str()), val.to_c_str());\n+    pub fn env<'a, T, U>(&'a mut self, key: T, val: U)\n+                         -> &'a mut Command\n+                         where T: BytesContainer, U: BytesContainer {\n+        let key = EnvKey(CString::from_slice(key.container_as_bytes()));\n+        let val = CString::from_slice(val.container_as_bytes());\n+        self.get_env_map().insert(key, val);\n         self\n     }\n \n     /// Removes an environment variable mapping.\n-    pub fn env_remove<'a, T: ToCStr>(&'a mut self, key: T) -> &'a mut Command {\n-        self.get_env_map().remove(&EnvKey(key.to_c_str()));\n+    pub fn env_remove<'a, T>(&'a mut self, key: T) -> &'a mut Command\n+                             where T: BytesContainer {\n+        let key = EnvKey(CString::from_slice(key.container_as_bytes()));\n+        self.get_env_map().remove(&key);\n         self\n     }\n \n     /// Sets the entire environment map for the child process.\n     ///\n     /// If the given slice contains multiple instances of an environment\n     /// variable, the *rightmost* instance will determine the value.\n-    pub fn env_set_all<'a, T: ToCStr, U: ToCStr>(&'a mut self, env: &[(T,U)])\n-                                                 -> &'a mut Command {\n-        self.env = Some(env.iter().map(|&(ref k, ref v)| (EnvKey(k.to_c_str()), v.to_c_str()))\n-                                  .collect());\n+    pub fn env_set_all<'a, T, U>(&'a mut self, env: &[(T,U)])\n+                                 -> &'a mut Command\n+                                 where T: BytesContainer, U: BytesContainer {\n+        self.env = Some(env.iter().map(|&(ref k, ref v)| {\n+            (EnvKey(CString::from_slice(k.container_as_bytes())),\n+             CString::from_slice(v.container_as_bytes()))\n+        }).collect());\n         self\n     }\n \n     /// Set the working directory for the child process.\n     pub fn cwd<'a>(&'a mut self, dir: &Path) -> &'a mut Command {\n-        self.cwd = Some(dir.to_c_str());\n+        self.cwd = Some(CString::from_slice(dir.as_vec()));\n         self\n     }\n \n@@ -389,9 +400,9 @@ impl fmt::Show for Command {\n     /// non-utf8 data is lossily converted using the utf8 replacement\n     /// character.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{}\", String::from_utf8_lossy(self.program.as_bytes_no_nul())));\n+        try!(write!(f, \"{}\", String::from_utf8_lossy(self.program.as_bytes())));\n         for arg in self.args.iter() {\n-            try!(write!(f, \" '{}'\", String::from_utf8_lossy(arg.as_bytes_no_nul())));\n+            try!(write!(f, \" '{}'\", String::from_utf8_lossy(arg.as_bytes())));\n         }\n         Ok(())\n     }\n@@ -1208,13 +1219,13 @@ mod tests {\n     #[test]\n     #[cfg(windows)]\n     fn env_map_keys_ci() {\n-        use c_str::ToCStr;\n+        use ffi::CString;\n         use super::EnvKey;\n         let mut cmd = Command::new(\"\");\n         cmd.env(\"path\", \"foo\");\n         cmd.env(\"Path\", \"bar\");\n         let env = &cmd.env.unwrap();\n-        let val = env.get(&EnvKey(\"PATH\".to_c_str()));\n-        assert!(val.unwrap() == &\"bar\".to_c_str());\n+        let val = env.get(&EnvKey(CString::from_slice(b\"PATH\")));\n+        assert!(val.unwrap() == &CString::from_slice(b\"bar\"));\n     }\n }"}, {"sha": "2d3a4639379cfe36276b2e6505c1f611fe4e2d09", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -208,10 +208,10 @@ pub mod num;\n \n /* Runtime and platform support */\n \n-pub mod thread_local;\n-pub mod c_str;\n-pub mod c_vec;\n+pub mod thread_local; // first for macros\n+\n pub mod dynamic_lib;\n+pub mod ffi;\n pub mod fmt;\n pub mod io;\n pub mod os;"}, {"sha": "300ceec4b45bf3a047a54a0947a29395cd8accc3", "filename": "src/libstd/os.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -57,12 +57,10 @@ use string::{String, ToString};\n use sync::atomic::{AtomicInt, ATOMIC_INT_INIT, Ordering};\n use vec::Vec;\n \n-#[cfg(unix)] use c_str::ToCStr;\n+#[cfg(unix)] use ffi::{self, CString};\n \n-#[cfg(unix)]\n-pub use sys::ext as unix;\n-#[cfg(windows)]\n-pub use sys::ext as windows;\n+#[cfg(unix)] pub use sys::ext as unix;\n+#[cfg(windows)] pub use sys::ext as windows;\n \n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n@@ -196,15 +194,14 @@ pub fn getenv(n: &str) -> Option<String> {\n ///\n /// Panics if `n` has any interior NULs.\n pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n-    use c_str::CString;\n-\n     unsafe {\n         with_env_lock(|| {\n-            let s = n.with_c_str(|buf| libc::getenv(buf));\n+            let s = CString::from_slice(n.as_bytes());\n+            let s = libc::getenv(s.as_ptr()) as *const _;\n             if s.is_null() {\n                 None\n             } else {\n-                Some(CString::new(s as *const libc::c_char, false).as_bytes_no_nul().to_vec())\n+                Some(ffi::c_str_to_bytes(&s).to_vec())\n             }\n         })\n     }\n@@ -253,13 +250,12 @@ pub fn setenv<T: BytesContainer>(n: &str, v: T) {\n     fn _setenv(n: &str, v: &[u8]) {\n         unsafe {\n             with_env_lock(|| {\n-                n.with_c_str(|nbuf| {\n-                    v.with_c_str(|vbuf| {\n-                        if libc::funcs::posix01::unistd::setenv(nbuf, vbuf, 1) != 0 {\n-                            panic!(IoError::last_error());\n-                        }\n-                    })\n-                })\n+                let k = CString::from_slice(n.as_bytes());\n+                let v = CString::from_slice(v);\n+                if libc::funcs::posix01::unistd::setenv(k.as_ptr(),\n+                                                        v.as_ptr(), 1) != 0 {\n+                    panic!(IoError::last_error());\n+                }\n             })\n         }\n     }\n@@ -289,11 +285,10 @@ pub fn unsetenv(n: &str) {\n     fn _unsetenv(n: &str) {\n         unsafe {\n             with_env_lock(|| {\n-                n.with_c_str(|nbuf| {\n-                    if libc::funcs::posix01::unistd::unsetenv(nbuf) != 0 {\n-                        panic!(IoError::last_error());\n-                    }\n-                })\n+                let nbuf = CString::from_slice(n.as_bytes());\n+                if libc::funcs::posix01::unistd::unsetenv(nbuf.as_ptr()) != 0 {\n+                    panic!(IoError::last_error());\n+                }\n             })\n         }\n     }\n@@ -618,11 +613,10 @@ pub fn get_exit_status() -> int {\n #[cfg(target_os = \"macos\")]\n unsafe fn load_argc_and_argv(argc: int,\n                              argv: *const *const c_char) -> Vec<Vec<u8>> {\n-    use c_str::CString;\n     use iter::range;\n \n     range(0, argc as uint).map(|i| {\n-        CString::new(*argv.offset(i as int), false).as_bytes_no_nul().to_vec()\n+        ffi::c_str_to_bytes(&*argv.offset(i as int)).to_vec()\n     }).collect()\n }\n \n@@ -652,7 +646,6 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n // res\n #[cfg(target_os = \"ios\")]\n fn real_args_as_bytes() -> Vec<Vec<u8>> {\n-    use c_str::CString;\n     use iter::range;\n     use mem;\n "}, {"sha": "2f014872402cf2d794d145342130e58eb9a072d0", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -62,7 +62,7 @@\n #![experimental]\n \n use core::kinds::Sized;\n-use c_str::CString;\n+use ffi::CString;\n use clone::Clone;\n use fmt;\n use iter::IteratorExt;\n@@ -892,7 +892,7 @@ impl BytesContainer for Vec<u8> {\n impl BytesContainer for CString {\n     #[inline]\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n-        self.as_bytes_no_nul()\n+        self.as_bytes()\n     }\n }\n \n@@ -913,21 +913,3 @@ impl<'a, Sized? T: BytesContainer> BytesContainer for &'a T {\n fn contains_nul<T: BytesContainer>(v: &T) -> bool {\n     v.container_as_bytes().iter().any(|&x| x == 0)\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-    use c_str::ToCStr;\n-    use path::{WindowsPath, PosixPath};\n-\n-    #[test]\n-    fn test_cstring() {\n-        let input = \"/foo/bar/baz\";\n-        let path: PosixPath = PosixPath::new(input.to_c_str());\n-        assert_eq!(path.as_vec(), input.as_bytes());\n-\n-        let input = r\"\\foo\\bar\\baz\";\n-        let path: WindowsPath = WindowsPath::new(input.to_c_str());\n-        assert_eq!(path.as_str().unwrap(), input);\n-    }\n-}"}, {"sha": "013212b27058c3d0168175de08643680141b46c7", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -10,19 +10,16 @@\n \n //! POSIX file path handling\n \n-use c_str::{CString, ToCStr};\n use clone::Clone;\n-use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n+use cmp::{Ordering, Eq, Ord, PartialEq, PartialOrd};\n use hash;\n use io::Writer;\n use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map};\n-use option::Option;\n-use option::Option::{None, Some};\n use kinds::Sized;\n-use str::{FromStr, Str};\n-use str;\n-use slice::{Split, AsSlice, SliceConcatExt, SliceExt};\n+use option::Option::{self, Some, None};\n+use slice::{AsSlice, Split, SliceExt, SliceConcatExt};\n+use str::{self, FromStr, StrExt};\n use vec::Vec;\n \n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n@@ -86,26 +83,6 @@ impl FromStr for Path {\n     }\n }\n \n-// FIXME (#12938): Until DST lands, we cannot decompose &str into & and str, so\n-// we cannot usefully take ToCStr arguments by reference (without forcing an\n-// additional & around &str). So we are instead temporarily adding an instance\n-// for &Path, so that we can take ToCStr as owned. When DST lands, the &Path\n-// instance should be removed, and arguments bound by ToCStr should be passed by\n-// reference.\n-\n-impl ToCStr for Path {\n-    #[inline]\n-    fn to_c_str(&self) -> CString {\n-        // The Path impl guarantees no internal NUL\n-        unsafe { self.to_c_str_unchecked() }\n-    }\n-\n-    #[inline]\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        self.as_vec().to_c_str_unchecked()\n-    }\n-}\n-\n impl<S: hash::Writer> hash::Hash<S> for Path {\n     #[inline]\n     fn hash(&self, state: &mut S) {"}, {"sha": "05129a7ab9da3988c352337e8980c836caec8521", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -15,17 +15,15 @@\n use self::PathPrefix::*;\n \n use ascii::AsciiExt;\n-use c_str::{CString, ToCStr};\n use char::CharExt;\n use clone::Clone;\n-use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n+use cmp::{Ordering, Eq, Ord, PartialEq, PartialOrd};\n use hash;\n use io::Writer;\n use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;\n-use option::Option;\n-use option::Option::{Some, None};\n+use option::Option::{self, Some, None};\n use slice::{SliceExt, SliceConcatExt};\n use str::{SplitTerminator, FromStr, StrExt};\n use string::{String, ToString};\n@@ -112,26 +110,6 @@ impl FromStr for Path {\n     }\n }\n \n-// FIXME (#12938): Until DST lands, we cannot decompose &str into & and str, so\n-// we cannot usefully take ToCStr arguments by reference (without forcing an\n-// additional & around &str). So we are instead temporarily adding an instance\n-// for &Path, so that we can take ToCStr as owned. When DST lands, the &Path\n-// instance should be removed, and arguments bound by ToCStr should be passed by\n-// reference.\n-\n-impl ToCStr for Path {\n-    #[inline]\n-    fn to_c_str(&self) -> CString {\n-        // The Path impl guarantees no internal NUL\n-        unsafe { self.to_c_str_unchecked() }\n-    }\n-\n-    #[inline]\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        self.as_vec().to_c_str_unchecked()\n-    }\n-}\n-\n impl<S: hash::Writer> hash::Hash<S> for Path {\n     #[cfg(not(test))]\n     #[inline]"}, {"sha": "86abacb936501f63124755cd6baeef981c9c7474", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -46,8 +46,9 @@ pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n mod imp {\n     use prelude::v1::*;\n \n+    use libc;\n     use mem;\n-    use slice;\n+    use ffi;\n \n     use sync::{StaticMutex, MUTEX_INIT};\n \n@@ -95,13 +96,9 @@ mod imp {\n     }\n \n     unsafe fn load_argc_and_argv(argc: int, argv: *const *const u8) -> Vec<Vec<u8>> {\n+        let argv = argv as *const *const libc::c_char;\n         range(0, argc as uint).map(|i| {\n-            let arg = *argv.offset(i as int);\n-            let mut len = 0u;\n-            while *arg.offset(len as int) != 0 {\n-                len += 1u;\n-            }\n-            slice::from_raw_buf(&arg, len).to_vec()\n+            ffi::c_str_to_bytes(&*argv.offset(i as int)).to_vec()\n         }).collect()\n     }\n "}, {"sha": "bb0b6fe804bea4e676c0520cee80d4539c8b95e6", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -15,7 +15,7 @@\n use prelude::v1::*;\n \n use os;\n-use sync::atomic::{mod, Ordering};\n+use sync::atomic::{self, Ordering};\n \n pub use sys::backtrace::write;\n "}, {"sha": "71169386c186aee9400b363232787cf25c4a64af", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -67,7 +67,7 @@ use fmt;\n use intrinsics;\n use libc::c_void;\n use mem;\n-use sync::atomic::{mod, Ordering};\n+use sync::atomic::{self, Ordering};\n use sync::{Once, ONCE_INIT};\n \n use rt::libunwind as uw;"}, {"sha": "bc01ce926f8bc4306c43732cfdc51f8a546506af", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -19,7 +19,7 @@ use libc::{self, uintptr_t};\n use os;\n use slice;\n use str;\n-use sync::atomic::{mod, Ordering};\n+use sync::atomic::{self, Ordering};\n \n /// Dynamically inquire about whether we're running under V.\n /// You should usually not use this unless your test definitely"}, {"sha": "a31dcc9884f465fa74c4311f443ac670853c0dac", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -14,7 +14,7 @@\n use io::{self, IoError, IoResult};\n use prelude::v1::*;\n use sys::{last_error, retry};\n-use c_str::CString;\n+use ffi::CString;\n use num::Int;\n use path::BytesContainer;\n use collections;"}, {"sha": "4cf891ac4985eba360859a1cff038719ce3ca9a8", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -12,15 +12,16 @@ use prelude::v1::*;\n use self::SocketStatus::*;\n use self::InAddr::*;\n \n-use c_str::ToCStr;\n+use ffi::CString;\n+use ffi;\n use io::net::addrinfo;\n use io::net::ip::{SocketAddr, IpAddr, Ipv4Addr, Ipv6Addr};\n use io::{IoResult, IoError};\n use libc::{self, c_char, c_int};\n-use c_str::CString;\n use mem;\n use num::Int;\n use ptr::{self, null, null_mut};\n+use str;\n use sys::{self, retry, c, sock_t, last_error, last_net_error, last_gai_error, close_sock,\n           wrlen, msglen_t, os, wouldblock, set_nonblocking, timer, ms_to_timeval,\n           decode_error_detailed};\n@@ -234,9 +235,9 @@ pub fn get_host_addresses(host: Option<&str>, servname: Option<&str>,\n \n     assert!(host.is_some() || servname.is_some());\n \n-    let c_host = host.map(|x| x.to_c_str());\n+    let c_host = host.map(|x| CString::from_slice(x.as_bytes()));\n     let c_host = c_host.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n-    let c_serv = servname.map(|x| x.to_c_str());\n+    let c_serv = servname.map(|x| CString::from_slice(x.as_bytes()));\n     let c_serv = c_serv.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n \n     let hint = hint.map(|hint| {\n@@ -324,7 +325,8 @@ pub fn get_address_name(addr: IpAddr) -> Result<String, IoError> {\n     }\n \n     unsafe {\n-        Ok(CString::new(hostbuf.as_ptr(), false).as_str().unwrap().to_string())\n+        Ok(str::from_utf8(ffi::c_str_to_bytes(&hostbuf.as_ptr()))\n+               .unwrap().to_string())\n     }\n }\n "}, {"sha": "ca268a8f27ff34680a915eff95255b7f4acd2093", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -83,12 +83,13 @@\n /// to symbols. This is a bit of a hokey implementation as-is, but it works for\n /// all unix platforms we support right now, so it at least gets the job done.\n \n-use c_str::CString;\n-use io::{IoResult, Writer};\n+use prelude::v1::*;\n+\n+use ffi;\n+use io::IoResult;\n use libc;\n use mem;\n-use option::Option::{self, Some, None};\n-use result::Result::{Ok, Err};\n+use str;\n use sync::{StaticMutex, MUTEX_INIT};\n \n use sys_common::backtrace::*;\n@@ -105,9 +106,7 @@ use sys_common::backtrace::*;\n #[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n #[inline(never)]\n pub fn write(w: &mut Writer) -> IoResult<()> {\n-    use iter::{IteratorExt, range};\n     use result;\n-    use slice::SliceExt;\n \n     extern {\n         fn backtrace(buf: *mut *mut libc::c_void,\n@@ -234,19 +233,15 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n         output(w, idx,addr, None)\n     } else {\n         output(w, idx, addr, Some(unsafe {\n-            CString::new(info.dli_sname, false)\n+            ffi::c_str_to_bytes(&info.dli_sname)\n         }))\n     }\n }\n \n #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n-    use iter::{Iterator, IteratorExt};\n     use os;\n-    use path::GenericPath;\n-    use ptr::PtrExt;\n     use ptr;\n-    use slice::SliceExt;\n \n     ////////////////////////////////////////////////////////////////////////\n     // libbacktrace.h API\n@@ -368,15 +363,15 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n     if ret == 0 || data.is_null() {\n         output(w, idx, addr, None)\n     } else {\n-        output(w, idx, addr, Some(unsafe { CString::new(data, false) }))\n+        output(w, idx, addr, Some(unsafe { ffi::c_str_to_bytes(&data) }))\n     }\n }\n \n // Finally, after all that work above, we can emit a symbol.\n fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n-          s: Option<CString>) -> IoResult<()> {\n+          s: Option<&[u8]>) -> IoResult<()> {\n     try!(write!(w, \"  {:2}: {:2$} - \", idx, addr, HEX_WIDTH));\n-    match s.as_ref().and_then(|c| c.as_str()) {\n+    match s.and_then(|s| str::from_utf8(s).ok()) {\n         Some(string) => try!(demangle(w, string)),\n         None => try!(write!(w, \"<unknown>\")),\n     }"}, {"sha": "1ad775517bba714aac62f8ea639ed31660d1d935", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -12,7 +12,7 @@\n \n use prelude::v1::*;\n \n-use c_str::{CString, ToCStr};\n+use ffi::{self, CString};\n use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n use io::{IoResult, FileStat, SeekStyle};\n use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n@@ -150,6 +150,10 @@ impl Drop for FileDesc {\n     }\n }\n \n+fn cstr(path: &Path) -> CString {\n+    CString::from_slice(path.as_vec())\n+}\n+\n pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> {\n     let flags = match fm {\n         Open => 0,\n@@ -165,15 +169,15 @@ pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> {\n                             libc::S_IRUSR | libc::S_IWUSR),\n     };\n \n-    let path = path.to_c_str();\n+    let path = cstr(path);\n     match retry(|| unsafe { libc::open(path.as_ptr(), flags, mode) }) {\n         -1 => Err(super::last_error()),\n         fd => Ok(FileDesc::new(fd, true)),\n     }\n }\n \n pub fn mkdir(p: &Path, mode: uint) -> IoResult<()> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     mkerr_libc(unsafe { libc::mkdir(p.as_ptr(), mode as libc::mode_t) })\n }\n \n@@ -182,7 +186,6 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n     use libc::{opendir, readdir_r, closedir};\n \n     fn prune(root: &CString, dirs: Vec<Path>) -> Vec<Path> {\n-        let root = unsafe { CString::new(root.as_ptr(), false) };\n         let root = Path::new(root);\n \n         dirs.into_iter().filter(|path| {\n@@ -199,18 +202,17 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n     let mut buf = Vec::<u8>::with_capacity(size as uint);\n     let ptr = buf.as_mut_ptr() as *mut dirent_t;\n \n-    let p = p.to_c_str();\n+    let p = CString::from_slice(p.as_vec());\n     let dir_ptr = unsafe {opendir(p.as_ptr())};\n \n     if dir_ptr as uint != 0 {\n         let mut paths = vec!();\n         let mut entry_ptr = 0 as *mut dirent_t;\n         while unsafe { readdir_r(dir_ptr, ptr, &mut entry_ptr) == 0 } {\n             if entry_ptr.is_null() { break }\n-            let cstr = unsafe {\n-                CString::new(rust_list_dir_val(entry_ptr), false)\n-            };\n-            paths.push(Path::new(cstr));\n+            paths.push(unsafe {\n+                Path::new(ffi::c_str_to_bytes(&rust_list_dir_val(entry_ptr)))\n+            });\n         }\n         assert_eq!(unsafe { closedir(dir_ptr) }, 0);\n         Ok(prune(&p, paths))\n@@ -220,39 +222,39 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n }\n \n pub fn unlink(p: &Path) -> IoResult<()> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     mkerr_libc(unsafe { libc::unlink(p.as_ptr()) })\n }\n \n pub fn rename(old: &Path, new: &Path) -> IoResult<()> {\n-    let old = old.to_c_str();\n-    let new = new.to_c_str();\n+    let old = cstr(old);\n+    let new = cstr(new);\n     mkerr_libc(unsafe {\n         libc::rename(old.as_ptr(), new.as_ptr())\n     })\n }\n \n pub fn chmod(p: &Path, mode: uint) -> IoResult<()> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     mkerr_libc(retry(|| unsafe {\n         libc::chmod(p.as_ptr(), mode as libc::mode_t)\n     }))\n }\n \n pub fn rmdir(p: &Path) -> IoResult<()> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     mkerr_libc(unsafe { libc::rmdir(p.as_ptr()) })\n }\n \n pub fn chown(p: &Path, uid: int, gid: int) -> IoResult<()> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     mkerr_libc(retry(|| unsafe {\n         libc::chown(p.as_ptr(), uid as libc::uid_t, gid as libc::gid_t)\n     }))\n }\n \n pub fn readlink(p: &Path) -> IoResult<Path> {\n-    let c_path = p.to_c_str();\n+    let c_path = cstr(p);\n     let p = c_path.as_ptr();\n     let mut len = unsafe { libc::pathconf(p as *mut _, libc::_PC_NAME_MAX) };\n     if len == -1 {\n@@ -273,14 +275,14 @@ pub fn readlink(p: &Path) -> IoResult<Path> {\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n-    let src = src.to_c_str();\n-    let dst = dst.to_c_str();\n+    let src = cstr(src);\n+    let dst = cstr(dst);\n     mkerr_libc(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) })\n }\n \n pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n-    let src = src.to_c_str();\n-    let dst = dst.to_c_str();\n+    let src = cstr(src);\n+    let dst = cstr(dst);\n     mkerr_libc(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })\n }\n \n@@ -328,7 +330,7 @@ fn mkstat(stat: &libc::stat) -> FileStat {\n }\n \n pub fn stat(p: &Path) -> IoResult<FileStat> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     match unsafe { libc::stat(p.as_ptr(), &mut stat) } {\n         0 => Ok(mkstat(&stat)),\n@@ -337,7 +339,7 @@ pub fn stat(p: &Path) -> IoResult<FileStat> {\n }\n \n pub fn lstat(p: &Path) -> IoResult<FileStat> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     match unsafe { libc::lstat(p.as_ptr(), &mut stat) } {\n         0 => Ok(mkstat(&stat)),\n@@ -346,7 +348,7 @@ pub fn lstat(p: &Path) -> IoResult<FileStat> {\n }\n \n pub fn utime(p: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     let buf = libc::utimbuf {\n         actime: (atime / 1000) as libc::time_t,\n         modtime: (mtime / 1000) as libc::time_t,"}, {"sha": "6a408aa60f0bfb2aa8bbcbbf8fe3a691fb681e0e", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -15,12 +15,14 @@\n #![allow(unused_unsafe)]\n #![allow(unused_mut)]\n \n-extern crate libc;\n-\n-use num;\n-use num::{Int, SignedInt};\n use prelude::v1::*;\n+\n+use ffi;\n use io::{self, IoResult, IoError};\n+use libc;\n+use num::{Int, SignedInt};\n+use num;\n+use str;\n use sys_common::mkerr_libc;\n \n macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n@@ -78,11 +80,10 @@ extern \"system\" {\n }\n \n pub fn last_gai_error(s: libc::c_int) -> IoError {\n-    use c_str::CString;\n \n     let mut err = decode_error(s);\n     err.detail = Some(unsafe {\n-        CString::new(gai_strerror(s), false).as_str().unwrap().to_string()\n+        str::from_utf8(ffi::c_str_to_bytes(&gai_strerror(s))).unwrap().to_string()\n     });\n     err\n }"}, {"sha": "175c4e2e353f91044fa0453395c27f173671a870", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -12,18 +12,18 @@\n \n use prelude::v1::*;\n \n-use c_str::ToCStr;\n use error::{FromError, Error};\n+use ffi::{self, CString};\n use fmt;\n use io::{IoError, IoResult};\n use libc::{self, c_int, c_char, c_void};\n+use os::TMPBUF_SZ;\n use os;\n use path::{BytesContainer};\n use ptr;\n+use str;\n use sys::fs::FileDesc;\n \n-use os::TMPBUF_SZ;\n-\n const BUF_BYTES : uint = 2048u;\n \n /// Returns the platform-specific value of errno\n@@ -108,7 +108,8 @@ pub fn error_string(errno: i32) -> String {\n             panic!(\"strerror_r failure\");\n         }\n \n-        String::from_raw_buf(p as *const u8)\n+        let p = p as *const _;\n+        str::from_utf8(ffi::c_str_to_bytes(&p)).unwrap().to_string()\n     }\n }\n \n@@ -122,21 +123,17 @@ pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n }\n \n pub fn getcwd() -> IoResult<Path> {\n-    use c_str::CString;\n-\n     let mut buf = [0 as c_char; BUF_BYTES];\n     unsafe {\n         if libc::getcwd(buf.as_mut_ptr(), buf.len() as libc::size_t).is_null() {\n             Err(IoError::last_error())\n         } else {\n-            Ok(Path::new(CString::new(buf.as_ptr(), false)))\n+            Ok(Path::new(ffi::c_str_to_bytes(&buf.as_ptr())))\n         }\n     }\n }\n \n pub unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n-    use c_str::CString;\n-\n     extern {\n         fn rust_env_pairs() -> *const *const c_char;\n     }\n@@ -147,8 +144,7 @@ pub unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n     }\n     let mut result = Vec::new();\n     while *environ != 0 as *const _ {\n-        let env_pair =\n-            CString::new(*environ, false).as_bytes_no_nul().to_vec();\n+        let env_pair = ffi::c_str_to_bytes(&*environ).to_vec();\n         result.push(env_pair);\n         environ = environ.offset(1);\n     }\n@@ -234,14 +230,13 @@ pub fn load_self() -> Option<Vec<u8>> {\n }\n \n pub fn chdir(p: &Path) -> IoResult<()> {\n-    p.with_c_str(|buf| {\n-        unsafe {\n-            match libc::chdir(buf) == (0 as c_int) {\n-                true => Ok(()),\n-                false => Err(IoError::last_error()),\n-            }\n+    let p = CString::from_slice(p.as_vec());\n+    unsafe {\n+        match libc::chdir(p.as_ptr()) == (0 as c_int) {\n+            true => Ok(()),\n+            false => Err(IoError::last_error()),\n         }\n-    })\n+    }\n }\n \n pub fn page_size() -> uint {"}, {"sha": "158a1ce220411439bfeb2f188fdb002bf12ed14d", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -10,8 +10,8 @@\n \n use prelude::v1::*;\n \n+use ffi::CString;\n use libc;\n-use c_str::CString;\n use mem;\n use sync::{Arc, Mutex};\n use sync::atomic::{AtomicBool, Ordering};\n@@ -48,7 +48,7 @@ fn addr_to_sockaddr_un(addr: &CString,\n     }\n     s.sun_family = libc::AF_UNIX as libc::sa_family_t;\n     for (slot, value) in s.sun_path.iter_mut().zip(addr.iter()) {\n-        *slot = value;\n+        *slot = *value;\n     }\n \n     // count the null terminator"}, {"sha": "5bc6b0c703b1c9c90057820cb37f2880bec164aa", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -11,8 +11,8 @@\n use prelude::v1::*;\n use self::Req::*;\n \n-use c_str::{CString, ToCStr};\n use collections;\n+use ffi::CString;\n use hash::Hash;\n use io::process::{ProcessExit, ExitStatus, ExitSignal};\n use io::{self, IoResult, IoError, EndOfFile};\n@@ -101,7 +101,7 @@ impl Process {\n \n                 // We may use this in the child, so perform allocations before the\n                 // fork\n-                let devnull = \"/dev/null\".to_c_str();\n+                let devnull = b\"/dev/null\\0\";\n \n                 set_cloexec(output.fd());\n \n@@ -204,7 +204,7 @@ impl Process {\n                             } else {\n                                 libc::O_RDWR\n                             };\n-                            libc::open(devnull.as_ptr(), flags, 0)\n+                            libc::open(devnull.as_ptr() as *const _, flags, 0)\n                         }\n                         Some(obj) => {\n                             let fd = obj.as_inner().fd();"}, {"sha": "62f3242a2062580360ee277bc83ce9be8cf97767", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -54,7 +54,7 @@ use libc;\n use mem;\n use os;\n use ptr;\n-use sync::atomic::{mod, Ordering};\n+use sync::atomic::{self, Ordering};\n use sync::mpsc::{channel, Sender, Receiver, TryRecvError};\n use sys::c;\n use sys::fs::FileDesc;"}, {"sha": "4ccecfd1f5f2e6cc35f754cbe7049dcd23181388", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -21,7 +21,8 @@\n /// copy of that function in my mingw install (maybe it was broken?). Instead,\n /// this takes the route of using StackWalk64 in order to walk the stack.\n \n-use c_str::CString;\n+use dynamic_lib::DynamicLibrary;\n+use ffi;\n use intrinsics;\n use io::{IoResult, Writer};\n use libc;\n@@ -30,10 +31,9 @@ use ops::Drop;\n use option::Option::{Some, None};\n use path::Path;\n use result::Result::{Ok, Err};\n-use sync::{StaticMutex, MUTEX_INIT};\n use slice::SliceExt;\n-use str::StrExt;\n-use dynamic_lib::DynamicLibrary;\n+use str::{self, StrExt};\n+use sync::{StaticMutex, MUTEX_INIT};\n \n use sys_common::backtrace::*;\n \n@@ -357,11 +357,11 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n \n         if ret == libc::TRUE {\n             try!(write!(w, \" - \"));\n-            let cstr = unsafe { CString::new(info.Name.as_ptr(), false) };\n-            let bytes = cstr.as_bytes();\n-            match cstr.as_str() {\n-                Some(s) => try!(demangle(w, s)),\n-                None => try!(w.write(bytes[..bytes.len()-1])),\n+            let ptr = info.Name.as_ptr() as *const libc::c_char;\n+            let bytes = unsafe { ffi::c_str_to_bytes(&ptr) };\n+            match str::from_utf8(bytes) {\n+                Ok(s) => try!(demangle(w, s)),\n+                Err(..) => try!(w.write(bytes[..bytes.len()-1])),\n             }\n         }\n         try!(w.write(&['\\n' as u8]));"}, {"sha": "945c2e8e7d156ce501ca029f5b54483123a3acd5", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -133,7 +133,7 @@ pub mod compat {\n     use intrinsics::{atomic_store_relaxed, transmute};\n     use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n     use prelude::v1::*;\n-    use c_str::ToCStr;\n+    use ffi::CString;\n \n     extern \"system\" {\n         fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n@@ -147,14 +147,13 @@ pub mod compat {\n     unsafe fn store_func(ptr: *mut uint, module: &str, symbol: &str, fallback: uint) {\n         let mut module: Vec<u16> = module.utf16_units().collect();\n         module.push(0);\n-        symbol.with_c_str(|symbol| {\n-            let handle = GetModuleHandleW(module.as_ptr());\n-            let func: uint = transmute(GetProcAddress(handle, symbol));\n-            atomic_store_relaxed(ptr, if func == 0 {\n-                fallback\n-            } else {\n-                func\n-            })\n+        let symbol = CString::from_slice(symbol.as_bytes());\n+        let handle = GetModuleHandleW(module.as_ptr());\n+        let func: uint = transmute(GetProcAddress(handle, symbol.as_ptr()));\n+        atomic_store_relaxed(ptr, if func == 0 {\n+            fallback\n+        } else {\n+            func\n         })\n     }\n "}, {"sha": "f8c75335b35dc31059790965e7c89e54f52322ec", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -13,7 +13,6 @@\n use alloc::arc::Arc;\n use libc::{self, c_int};\n \n-use c_str::CString;\n use mem;\n use sys::os::fill_utf16_buf_and_decode;\n use path;"}, {"sha": "9996909f2f5bbc18a9781018bd4dd4aaaf952fd1", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -87,16 +87,21 @@\n use prelude::v1::*;\n \n use libc;\n-use c_str::CString;\n+use ffi::CString;\n+use io::{self, IoError, IoResult};\n use mem;\n use ptr;\n-use sync::{Arc, Mutex};\n+use str;\n use sync::atomic::{AtomicBool, Ordering};\n-use io::{self, IoError, IoResult};\n+use sync::{Arc, Mutex};\n \n use sys_common::{self, eof};\n \n-use super::{c, os, timer, to_utf16, decode_error_detailed};\n+use super::{c, os, timer, decode_error_detailed};\n+\n+fn to_utf16(c: &CString) -> IoResult<Vec<u16>> {\n+    super::to_utf16(str::from_utf8(c.as_bytes()).ok())\n+}\n \n struct Event(libc::HANDLE);\n \n@@ -270,7 +275,7 @@ impl UnixStream {\n     }\n \n     pub fn connect(addr: &CString, timeout: Option<u64>) -> IoResult<UnixStream> {\n-        let addr = try!(to_utf16(addr.as_str()));\n+        let addr = try!(to_utf16(addr));\n         let start = timer::now();\n         loop {\n             match UnixStream::try_connect(addr.as_ptr()) {\n@@ -571,7 +576,7 @@ impl UnixListener {\n         // Although we technically don't need the pipe until much later, we\n         // create the initial handle up front to test the validity of the name\n         // and such.\n-        let addr_v = try!(to_utf16(addr.as_str()));\n+        let addr_v = try!(to_utf16(addr));\n         let ret = unsafe { pipe(addr_v.as_ptr(), true) };\n         if ret == libc::INVALID_HANDLE_VALUE {\n             Err(super::last_error())\n@@ -661,7 +666,7 @@ impl UnixAcceptor {\n         // proceed in accepting new clients in the future\n         if self.inner.closed.load(Ordering::SeqCst) { return Err(eof()) }\n \n-        let name = try!(to_utf16(self.listener.name.as_str()));\n+        let name = try!(to_utf16(&self.listener.name));\n \n         // Once we've got a \"server handle\", we need to wait for a client to\n         // connect. The ConnectNamedPipe function will block this thread until\n@@ -753,7 +758,7 @@ impl UnixAcceptor {\n \n impl Clone for UnixAcceptor {\n     fn clone(&self) -> UnixAcceptor {\n-        let name = to_utf16(self.listener.name.as_str()).ok().unwrap();\n+        let name = to_utf16(&self.listener.name).ok().unwrap();\n         UnixAcceptor {\n             inner: self.inner.clone(),\n             event: Event::new(true, false).ok().unwrap(),"}, {"sha": "9b3f2ca03736efa06114e2177623ab3030838ec4", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -10,27 +10,26 @@\n \n use prelude::v1::*;\n \n+use collections;\n+use ffi::CString;\n+use hash::Hash;\n+use io::fs::PathExtensions;\n+use io::process::{ProcessExit, ExitStatus, ExitSignal};\n+use io::{IoResult, IoError};\n+use io;\n use libc::{pid_t, c_void, c_int};\n use libc;\n-use c_str::{CString, ToCStr};\n-use io;\n use mem;\n use os;\n-use ptr;\n-use io::process::{ProcessExit, ExitStatus, ExitSignal};\n-use collections;\n use path::BytesContainer;\n-use hash::Hash;\n-use io::{IoResult, IoError};\n-\n+use ptr;\n+use str;\n+use sys::fs::FileDesc;\n use sys::fs;\n use sys::{self, retry, c, wouldblock, set_nonblocking, ms_to_timeval, timer};\n-use sys::fs::FileDesc;\n use sys_common::helper_thread::Helper;\n use sys_common::{AsInner, mkerr_libc, timeout};\n \n-use io::fs::PathExtensions;\n-\n pub use sys_common::ProcessConfig;\n \n /// A value representing a child process.\n@@ -142,10 +141,10 @@ impl Process {\n                 // Split the value and test each path to see if the\n                 // program exists.\n                 for path in os::split_paths(v.container_as_bytes()).into_iter() {\n-                    let path = path.join(cfg.program().as_bytes_no_nul())\n+                    let path = path.join(cfg.program().as_bytes())\n                                    .with_extension(os::consts::EXE_EXTENSION);\n                     if path.exists() {\n-                        return Some(path.to_c_str())\n+                        return Some(CString::from_slice(path.as_vec()))\n                     }\n                 }\n                 break\n@@ -363,11 +362,11 @@ fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMA\n \n fn make_command_line(prog: &CString, args: &[CString]) -> String {\n     let mut cmd = String::new();\n-    append_arg(&mut cmd, prog.as_str()\n+    append_arg(&mut cmd, str::from_utf8(prog.as_bytes()).ok()\n                              .expect(\"expected program name to be utf-8 encoded\"));\n     for arg in args.iter() {\n         cmd.push(' ');\n-        append_arg(&mut cmd, arg.as_str()\n+        append_arg(&mut cmd, str::from_utf8(arg.as_bytes()).ok()\n                                 .expect(\"expected argument to be utf-8 encoded\"));\n     }\n     return cmd;\n@@ -449,7 +448,7 @@ fn with_dirp<T, F>(d: Option<&CString>, cb: F) -> T where\n {\n     match d {\n       Some(dir) => {\n-          let dir_str = dir.as_str()\n+          let dir_str = str::from_utf8(dir.as_bytes()).ok()\n                            .expect(\"expected workingdirectory to be utf-8 encoded\");\n           let mut dir_str: Vec<u16> = dir_str.utf16_units().collect();\n           dir_str.push(0);"}, {"sha": "6cd94ee5602aa5ccf3db96b0b1f3ccda3dcae6ef", "filename": "src/test/auxiliary/linkage-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -27,7 +27,7 @@ fn bar() { }\n fn baz() { }\n \n pub fn test() {\n-    let none: Option<Path> = None; // appease the typechecker\n+    let none: Option<&Path> = None; // appease the typechecker\n     let lib = DynamicLibrary::open(none).unwrap();\n     unsafe {\n         assert!(lib.symbol::<int>(\"foo\").is_ok());"}, {"sha": "22c322b86c97963d800c3485a482d2c7aa2d846d", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -12,7 +12,7 @@\n \n extern crate libc;\n \n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n \n mod mlibc {\n     use libc::{c_char, c_long, c_longlong};\n@@ -24,11 +24,13 @@ mod mlibc {\n }\n \n fn atol(s: String) -> int {\n-    s.as_slice().with_c_str(|x| unsafe { mlibc::atol(x) as int })\n+    let c = CString::from_slice(s.as_bytes());\n+    unsafe { mlibc::atol(c.as_ptr()) as int }\n }\n \n fn atoll(s: String) -> i64 {\n-    s.as_slice().with_c_str(|x| unsafe { mlibc::atoll(x) as i64 })\n+    let c = CString::from_slice(s.as_bytes());\n+    unsafe { mlibc::atoll(c.as_ptr()) as i64 }\n }\n \n pub fn main() {"}, {"sha": "1a84236793b4f8d6d3d9f623b717fb227be4d9d9", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::{str, string};\n-use std::c_str::ToCStr;\n \n const A: [u8; 2] = ['h' as u8, 'i' as u8];\n const B: &'static [u8; 2] = &A;\n@@ -23,8 +22,5 @@ pub fn main() {\n         assert_eq!(String::from_raw_buf_len(C, B.len()), \"hi\".to_string());\n         assert!(*C == A[0]);\n         assert!(*(&B[0] as *const u8) == A[0]);\n-\n-        let bar = str::from_utf8_unchecked(&A).to_c_str();\n-        assert_eq!(bar.as_str(), \"hi\".to_c_str().as_str());\n     }\n }"}, {"sha": "dff1a1eaa0473aaf7b3a3225051da1d5072ad8ff", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -11,7 +11,7 @@\n // ignore-fast doesn't like extern crate\n \n extern crate libc;\n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n \n mod mlibc {\n     use libc::{c_char, size_t};\n@@ -24,11 +24,10 @@ mod mlibc {\n \n fn strlen(str: String) -> uint {\n     // C string is terminated with a zero\n-    str.as_slice().with_c_str(|buf| {\n-        unsafe {\n-            mlibc::my_strlen(buf) as uint\n-        }\n-    })\n+    let s = CString::from_slice(str.as_bytes());\n+    unsafe {\n+        mlibc::my_strlen(s.as_ptr()) as uint\n+    }\n }\n \n pub fn main() {"}, {"sha": "d610bf09edb958b0503c7795b95f6011cd1a1b18", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -13,8 +13,8 @@\n \n extern crate libc;\n \n+use std::ffi::CString;\n use std::io::TempDir;\n-use std::c_str::ToCStr;\n use std::io::fs::PathExtensions;\n use std::io::fs;\n use std::io;\n@@ -31,20 +31,17 @@ fn rename_directory() {\n         let test_file = &old_path.join(\"temp.txt\");\n \n         /* Write the temp input file */\n-        let ostream = test_file.with_c_str(|fromp| {\n-            \"w+b\".with_c_str(|modebuf| {\n-                libc::fopen(fromp, modebuf)\n-            })\n-        });\n+        let fromp = CString::from_slice(test_file.as_vec());\n+        let modebuf = CString::from_slice(b\"w+b\");\n+        let ostream = libc::fopen(fromp.as_ptr(), modebuf.as_ptr());\n         assert!((ostream as uint != 0u));\n         let s = \"hello\".to_string();\n-        \"hello\".with_c_str(|buf| {\n-            let write_len = libc::fwrite(buf as *const libc::c_void,\n-                                         1u as libc::size_t,\n-                                         (s.len() + 1u) as libc::size_t,\n-                                         ostream);\n-            assert_eq!(write_len, (s.len() + 1) as libc::size_t)\n-        });\n+        let buf = CString::from_slice(b\"hello\");\n+        let write_len = libc::fwrite(buf.as_ptr() as *mut _,\n+                                     1u as libc::size_t,\n+                                     (s.len() + 1u) as libc::size_t,\n+                                     ostream);\n+        assert_eq!(write_len, (s.len() + 1) as libc::size_t);\n         assert_eq!(libc::fclose(ostream), (0u as libc::c_int));\n \n         let new_path = tmpdir.join_many(&[\"quux\", \"blat\"]);"}, {"sha": "de9d7880411a1426ae6c6d6d027f0004b21cac02", "filename": "src/test/run-pass/variadic-ffi.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7a50d20dff416d9fec837a6492dfe244f5f3ab/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs?ref=ec7a50d20dff416d9fec837a6492dfe244f5f3ab", "patch": "@@ -10,7 +10,7 @@\n \n extern crate libc;\n \n-use std::c_str::{CString, ToCStr};\n+use std::ffi::{self, CString};\n use libc::{c_char, c_int};\n \n // ignore-fast doesn't like extern crate\n@@ -22,40 +22,35 @@ extern {\n unsafe fn check<T>(expected: &str, f: |*mut c_char| -> T) {\n     let mut x = [0 as c_char; 50];\n     f(&mut x[0] as *mut c_char);\n-    let res = CString::new(&x[0], false);\n-    assert_eq!(expected, res.as_str().unwrap());\n+    assert_eq!(expected.as_bytes(), ffi::c_str_to_bytes(&x.as_ptr()));\n }\n \n pub fn main() {\n \n     unsafe {\n         // Call with just the named parameter\n-        \"Hello World\\n\".with_c_str(|c| {\n-            check(\"Hello World\\n\", |s| sprintf(s, c));\n-        });\n+        let c = CString::from_slice(b\"Hello World\\n\");\n+        check(\"Hello World\\n\", |s| sprintf(s, c.as_ptr()));\n \n         // Call with variable number of arguments\n-        \"%d %f %c %s\\n\".with_c_str(|c| {\n-            check(\"42 42.500000 a %d %f %c %s\\n\\n\", |s| {\n-                sprintf(s, c, 42i, 42.5f64, 'a' as c_int, c);\n-            })\n+        let c = CString::from_slice(b\"%d %f %c %s\\n\");\n+        check(\"42 42.500000 a %d %f %c %s\\n\\n\", |s| {\n+            sprintf(s, c.as_ptr(), 42i, 42.5f64, 'a' as c_int, c.as_ptr());\n         });\n \n         // Make a function pointer\n-        let x: unsafe extern \"C\" fn(*mut c_char, *const c_char, ...) -> c_int = sprintf;\n+        let x: unsafe extern fn(*mut c_char, *const c_char, ...) -> c_int = sprintf;\n \n         // A function that takes a function pointer\n-        unsafe fn call(p: unsafe extern \"C\" fn(*mut c_char, *const c_char, ...) -> c_int) {\n-            // Call with just the named parameter via fn pointer\n-            \"Hello World\\n\".with_c_str(|c| {\n-                check(\"Hello World\\n\", |s| p(s, c));\n-            });\n+        unsafe fn call(p: unsafe extern fn(*mut c_char, *const c_char, ...) -> c_int) {\n+            // Call with just the named parameter\n+            let c = CString::from_slice(b\"Hello World\\n\");\n+            check(\"Hello World\\n\", |s| sprintf(s, c.as_ptr()));\n \n             // Call with variable number of arguments\n-            \"%d %f %c %s\\n\".with_c_str(|c| {\n-                check(\"42 42.500000 a %d %f %c %s\\n\\n\", |s| {\n-                    p(s, c, 42i, 42.5f64, 'a' as c_int, c);\n-                })\n+            let c = CString::from_slice(b\"%d %f %c %s\\n\");\n+            check(\"42 42.500000 a %d %f %c %s\\n\\n\", |s| {\n+                sprintf(s, c.as_ptr(), 42i, 42.5f64, 'a' as c_int, c.as_ptr());\n             });\n         }\n "}]}