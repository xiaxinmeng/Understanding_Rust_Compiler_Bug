{"sha": "b1fbbf3e48fdcfaa5e875bf457bc098faec30dbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxZmJiZjNlNDhmZGNmYWE1ZTg3NWJmNDU3YmMwOThmYWVjMzBkYmI=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-05-30T17:31:20Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-05-31T04:10:48Z"}, "message": "Add os::split_paths\n\nAdds a platform-specific function, `split_paths` to the `os` module. This\nfunction can be used to parse PATH-like environment variables according to\nlocal platform conventions.\n\nCloses #14352.", "tree": {"sha": "c5f73c492993039e425f26a82a9caec9c39b5293", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5f73c492993039e425f26a82a9caec9c39b5293"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1fbbf3e48fdcfaa5e875bf457bc098faec30dbb", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1fbbf3e48fdcfaa5e875bf457bc098faec30dbb", "html_url": "https://github.com/rust-lang/rust/commit/b1fbbf3e48fdcfaa5e875bf457bc098faec30dbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1fbbf3e48fdcfaa5e875bf457bc098faec30dbb/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc4513202d6f9c6896054ebaa1d99230b06e9f10", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc4513202d6f9c6896054ebaa1d99230b06e9f10", "html_url": "https://github.com/rust-lang/rust/commit/cc4513202d6f9c6896054ebaa1d99230b06e9f10"}], "stats": {"total": 96, "additions": 94, "deletions": 2}, "files": [{"sha": "fa0116b248223d55e7a44ba789e4ac60d561a048", "filename": "src/libstd/os.rs", "status": "modified", "additions": 94, "deletions": 2, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b1fbbf3e48fdcfaa5e875bf457bc098faec30dbb/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1fbbf3e48fdcfaa5e875bf457bc098faec30dbb/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=b1fbbf3e48fdcfaa5e875bf457bc098faec30dbb", "patch": "@@ -38,7 +38,7 @@ use libc;\n use ops::Drop;\n use option::{Some, None, Option};\n use os;\n-use path::{Path, GenericPath};\n+use path::{Path, GenericPath, BytesContainer};\n use ptr::RawPtr;\n use ptr;\n use result::{Err, Ok, Result};\n@@ -395,6 +395,63 @@ pub fn unsetenv(n: &str) {\n     _unsetenv(n);\n }\n \n+#[cfg(unix)]\n+/// Parse a string or vector according to the platform's conventions\n+/// for the `PATH` environment variable. Drops empty paths.\n+pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n+    unparsed.container_as_bytes()\n+            .split(|b| *b == ':' as u8)\n+            .filter(|s| s.len() > 0)\n+            .map(Path::new)\n+            .collect()\n+}\n+\n+#[cfg(windows)]\n+/// Parse a string or vector according to the platform's conventions\n+/// for the `PATH` environment variable. Drops empty paths.\n+pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n+    // On Windows, the PATH environment variable is semicolon separated.  Double\n+    // quotes are used as a way of introducing literal semicolons (since\n+    // c:\\some;dir is a valid Windows path). Double quotes are not themselves\n+    // permitted in path names, so there is no way to escape a double quote.\n+    // Quoted regions can appear in arbitrary locations, so\n+    //\n+    //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n+    //\n+    // Should parse as [c:\\foo, c:\\some;dir, c:\\bar].\n+    //\n+    // (The above is based on testing; there is no clear reference available\n+    // for the grammar.)\n+\n+    let mut parsed = Vec::new();\n+    let mut in_progress = Vec::new();\n+    let mut in_quote = false;\n+\n+    for b in unparsed.container_as_bytes().iter() {\n+        match *b as char {\n+            ';' if !in_quote => {\n+                // ignore zero-length path strings\n+                if in_progress.len() > 0 {\n+                    parsed.push(Path::new(in_progress.as_slice()));\n+                }\n+                in_progress.truncate(0)\n+            }\n+            '\\\"' => {\n+                in_quote = !in_quote;\n+            }\n+            _  => {\n+                in_progress.push(*b);\n+            }\n+        }\n+    }\n+\n+    if in_progress.len() > 0 {\n+        parsed.push(Path::new(in_progress));\n+    }\n+\n+    parsed\n+}\n+\n /// A low-level OS in-memory pipe.\n pub struct Pipe {\n     /// A file descriptor representing the reading end of the pipe. Data written\n@@ -1502,7 +1559,7 @@ mod tests {\n     use c_str::ToCStr;\n     use option;\n     use os::{env, getcwd, getenv, make_absolute};\n-    use os::{setenv, unsetenv};\n+    use os::{split_paths, setenv, unsetenv};\n     use os;\n     use rand::Rng;\n     use rand;\n@@ -1754,5 +1811,40 @@ mod tests {\n         fs::unlink(&path).unwrap();\n     }\n \n+    #[test]\n+    #[cfg(windows)]\n+    fn split_paths_windows() {\n+        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n+            split_paths(unparsed) ==\n+                parsed.iter().map(|s| Path::new(*s)).collect()\n+        }\n+\n+        assert!(check_parse(\"\", []));\n+        assert!(check_parse(r#\"\"\"\"#, []));\n+        assert!(check_parse(\";;\", []));\n+        assert!(check_parse(r\"c:\\\", [r\"c:\\\"]));\n+        assert!(check_parse(r\"c:\\;\", [r\"c:\\\"]));\n+        assert!(check_parse(r\"c:\\;c:\\Program Files\\\",\n+                            [r\"c:\\\", r\"c:\\Program Files\\\"]));\n+        assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, [r\"c:\\\", r\"c:\\foo\\\"]));\n+        assert!(check_parse(r#\"c:\\;c:\\\"foo;bar\"\\;c:\\baz\"#,\n+                            [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]));\n+    }\n+\n+    #[test]\n+    #[cfg(unix)]\n+    fn split_paths_unix() {\n+        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n+            split_paths(unparsed) ==\n+                parsed.iter().map(|s| Path::new(*s)).collect()\n+        }\n+\n+        assert!(check_parse(\"\", []));\n+        assert!(check_parse(\"::\", []));\n+        assert!(check_parse(\"/\", [\"/\"]));\n+        assert!(check_parse(\"/:\", [\"/\"]));\n+        assert!(check_parse(\"/:/usr/local\", [\"/\", \"/usr/local\"]));\n+    }\n+\n     // More recursive_mkdir tests are in extra::tempfile\n }"}]}