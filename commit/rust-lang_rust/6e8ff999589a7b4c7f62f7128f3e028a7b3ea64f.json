{"sha": "6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlOGZmOTk5NTg5YTdiNGM3ZjYyZjcxMjhmM2UwMjhhN2IzZWE2NGY=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-05-27T06:56:52Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-08-21T01:02:23Z"}, "message": "librustc: handle repr on structs, require it for ffi, unify with packed\n\nAs of RFC 18, struct layout is undefined. Opting into a C-compatible struct\nlayout is now down with #[repr(C)]. For consistency, specifying a packed\nlayout is now also down with #[repr(packed)]. Both can be specified.\n\nTo fix errors caused by this, just add #[repr(C)] to the structs, and change\n #[packed] to #[repr(packed)]\n\nCloses #14309\n\n[breaking-change]", "tree": {"sha": "71eb65a9aefa3503f15b4bd8245f36081f658c27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71eb65a9aefa3503f15b4bd8245f36081f658c27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "html_url": "https://github.com/rust-lang/rust/commit/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54bd9e6323742de87a526931a15558319db30604", "url": "https://api.github.com/repos/rust-lang/rust/commits/54bd9e6323742de87a526931a15558319db30604", "html_url": "https://github.com/rust-lang/rust/commit/54bd9e6323742de87a526931a15558319db30604"}], "stats": {"total": 328, "additions": 210, "deletions": 118}, "files": [{"sha": "874c7c2409c999cbfcd71baf197aaed8ec2cc0ba", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -334,6 +334,7 @@ pub mod types {\n                 __variant1,\n                 __variant2,\n             }\n+\n             pub enum FILE {}\n             pub enum fpos_t {}\n         }"}, {"sha": "ec25c27539bfdd754a344653a7ea34e3ff9930af", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -27,7 +27,6 @@\n \n use metadata::csearch;\n use middle::def::*;\n-use middle::trans::adt; // for `adt::is_ffi_safe`\n use middle::typeck::astconv::ast_ty_to_ty;\n use middle::typeck::infer;\n use middle::{typeck, ty, def, pat_util, stability};\n@@ -362,8 +361,13 @@ impl LintPass for CTypes {\n                                          \"found rust type `uint` in foreign module, while \\\n                                           libc::c_uint or libc::c_ulong should be used\");\n                         }\n-                        def::DefTy(def_id) => {\n-                            if !adt::is_ffi_safe(cx.tcx, def_id) {\n+                        def::DefTy(..) => {\n+                            let tty = match cx.tcx.ast_ty_to_ty_cache.borrow().find(&ty.id) {\n+                                Some(&ty::atttce_resolved(t)) => t,\n+                                _ => fail!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n+                            };\n+\n+                            if !ty::is_ffi_safe(cx.tcx, tty) {\n                                 cx.span_lint(CTYPES, ty.span,\n                                              \"found enum type without foreign-function-safe\n                                              representation annotation in foreign module, consider \\\n@@ -770,9 +774,10 @@ impl LintPass for NonCamelCaseTypes {\n             }\n         }\n \n-        let has_extern_repr = it.attrs.iter().fold(attr::ReprAny, |acc, attr| {\n-            attr::find_repr_attr(cx.tcx.sess.diagnostic(), attr, acc)\n-        }) == attr::ReprExtern;\n+        let has_extern_repr = it.attrs.iter().map(|attr| {\n+            attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr).iter()\n+                .any(|r| r == &attr::ReprExtern)\n+        }).any(|x| x);\n         if has_extern_repr { return }\n \n         match it.node {\n@@ -783,6 +788,7 @@ impl LintPass for NonCamelCaseTypes {\n                 check_case(cx, \"trait\", it.ident, it.span)\n             }\n             ast::ItemEnum(ref enum_definition, _) => {\n+                if has_extern_repr { return }\n                 check_case(cx, \"type\", it.ident, it.span);\n                 for variant in enum_definition.variants.iter() {\n                     check_case(cx, \"variant\", variant.node.name, variant.span);"}, {"sha": "0dfdf455743560f093b0fe77381595a4fbedac6b", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -195,9 +195,10 @@ impl<'a> MarkSymbolVisitor<'a> {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n                     ast::ItemStruct(..) => {\n-                        let has_extern_repr = item.attrs.iter().fold(attr::ReprAny, |acc, attr| {\n-                            attr::find_repr_attr(self.tcx.sess.diagnostic(), attr, acc)\n-                        }) == attr::ReprExtern;\n+                        let has_extern_repr = item.attrs.iter().fold(false, |acc, attr| {\n+                            acc || attr::find_repr_attrs(self.tcx.sess.diagnostic(), attr)\n+                                         .iter().any(|&x| x == attr::ReprExtern)\n+                        });\n \n                         visit::walk_item(self, &*item, MarkSymbolVisitorContext {\n                             struct_has_extern_repr: has_extern_repr,"}, {"sha": "483937edd9f7c1962eb65599bfbb08a577295755", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -46,6 +46,8 @@\n #![allow(unsigned_negate)]\n \n use libc::c_ulonglong;\n+use std::collections::Map;\n+use std::num::Int;\n use std::rc::Rc;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n@@ -178,7 +180,8 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n         }\n         ty::ty_enum(def_id, ref substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n-            let hint = ty::lookup_repr_hint(cx.tcx(), def_id);\n+            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id).as_slice().get(0)\n+                .unwrap_or(&attr::ReprAny);\n \n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n \n@@ -266,36 +269,6 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n     }\n }\n \n-/// Determine, without doing translation, whether an ADT must be FFI-safe.\n-/// For use in lint or similar, where being sound but slightly incomplete is acceptable.\n-pub fn is_ffi_safe(tcx: &ty::ctxt, def_id: ast::DefId) -> bool {\n-    match ty::get(ty::lookup_item_type(tcx, def_id).ty).sty {\n-        ty::ty_enum(def_id, _) => {\n-            let variants = ty::enum_variants(tcx, def_id);\n-            // Univariant => like struct/tuple.\n-            if variants.len() <= 1 {\n-                return true;\n-            }\n-            let hint = ty::lookup_repr_hint(tcx, def_id);\n-            // Appropriate representation explicitly selected?\n-            if hint.is_ffi_safe() {\n-                return true;\n-            }\n-            // Option<Box<T>> and similar are used in FFI.  Rather than try to\n-            // resolve type parameters and recognize this case exactly, this\n-            // overapproximates -- assuming that if a non-C-like enum is being\n-            // used in FFI then the user knows what they're doing.\n-            if variants.iter().any(|vi| !vi.args.is_empty()) {\n-                return true;\n-            }\n-            false\n-        }\n-        // struct, tuple, etc.\n-        // (is this right in the present of typedefs?)\n-        _ => true\n-    }\n-}\n-\n // this should probably all be in ty\n struct Case {\n     discr: Disr,\n@@ -427,6 +400,9 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n         }\n         attr::ReprAny => {\n             attempts = choose_shortest;\n+        },\n+        attr::ReprPacked => {\n+            cx.tcx.sess.bug(\"range_to_inttype: found ReprPacked on an enum\");\n         }\n     }\n     for &ity in attempts.iter() {"}, {"sha": "83eb84a326ae78545cfdc8afe0d7f6b10bccd8e6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 73, "deletions": 15, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -481,7 +481,7 @@ pub struct t { inner: *const t_opaque }\n \n impl fmt::Show for t {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        \"*t_opaque\".fmt(f)\n+        write!(f, \"{}\", get(*self))\n     }\n }\n \n@@ -1962,7 +1962,8 @@ def_type_content_sets!(\n         // ReachesManaged /* see [1] below */  = 0b0000_0100__0000_0000__0000,\n         ReachesMutable                      = 0b0000_1000__0000_0000__0000,\n         ReachesNoSync                       = 0b0001_0000__0000_0000__0000,\n-        ReachesAll                          = 0b0001_1111__0000_0000__0000,\n+        ReachesFfiUnsafe                    = 0b0010_0000__0000_0000__0000,\n+        ReachesAll                          = 0b0011_1111__0000_0000__0000,\n \n         // Things that cause values to *move* rather than *copy*\n         Moves                               = 0b0000_0000__0000_1011__0000,\n@@ -2199,38 +2200,44 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n         cache.insert(ty_id, TC::None);\n \n         let result = match get(ty).sty {\n+            // uint and int are ffi-unsafe\n+            ty_uint(ast::TyU) | ty_int(ast::TyI) => {\n+                TC::ReachesFfiUnsafe\n+            }\n+\n             // Scalar and unique types are sendable, and durable\n             ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n             ty_bare_fn(_) | ty::ty_char | ty_str => {\n                 TC::None\n             }\n \n             ty_closure(ref c) => {\n-                closure_contents(cx, &**c)\n+                closure_contents(cx, &**c) | TC::ReachesFfiUnsafe\n             }\n \n             ty_box(typ) => {\n-                tc_ty(cx, typ, cache).managed_pointer()\n+                tc_ty(cx, typ, cache).managed_pointer() | TC::ReachesFfiUnsafe\n             }\n \n             ty_uniq(typ) => {\n-                match get(typ).sty {\n+                TC::ReachesFfiUnsafe | match get(typ).sty {\n                     ty_str => TC::OwnsOwned,\n                     _ => tc_ty(cx, typ, cache).owned_pointer(),\n                 }\n             }\n \n             ty_trait(box ty::TyTrait { bounds, .. }) => {\n-                object_contents(cx, bounds)\n+                object_contents(cx, bounds) | TC::ReachesFfiUnsafe\n             }\n \n             ty_ptr(ref mt) => {\n                 tc_ty(cx, mt.ty, cache).unsafe_pointer()\n             }\n \n             ty_rptr(r, ref mt) => {\n-                match get(mt.ty).sty {\n+                TC::ReachesFfiUnsafe | match get(mt.ty).sty {\n                     ty_str => borrowed_contents(r, ast::MutImmutable),\n+                    ty_vec(..) => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(r, mt.mutbl)),\n                     _ => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(r, mt.mutbl)),\n                 }\n             }\n@@ -2244,6 +2251,11 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 let mut res =\n                     TypeContents::union(flds.as_slice(),\n                                         |f| tc_mt(cx, f.mt, cache));\n+\n+                if !lookup_repr_hints(cx, did).contains(&attr::ReprExtern) {\n+                    res = res | TC::ReachesFfiUnsafe;\n+                }\n+\n                 if ty::has_dtor(cx, did) {\n                     res = res | TC::OwnsDtor;\n                 }\n@@ -2273,9 +2285,49 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                             tc_ty(cx, *arg_ty, cache)\n                         })\n                     });\n+\n                 if ty::has_dtor(cx, did) {\n                     res = res | TC::OwnsDtor;\n                 }\n+\n+                if variants.len() != 0 {\n+                    let repr_hints = lookup_repr_hints(cx, did);\n+                    if repr_hints.len() > 1 {\n+                        // this is an error later on, but this type isn't safe\n+                        res = res | TC::ReachesFfiUnsafe;\n+                    }\n+\n+                    match repr_hints.as_slice().get(0) {\n+                        Some(h) => if !h.is_ffi_safe() {\n+                            res = res | TC::ReachesFfiUnsafe;\n+                        },\n+                        // ReprAny\n+                        None => {\n+                            res = res | TC::ReachesFfiUnsafe;\n+\n+                            // We allow ReprAny enums if they are eligible for\n+                            // the nullable pointer optimization and the\n+                            // contained type is an `extern fn`\n+\n+                            if variants.len() == 2 {\n+                                let mut data_idx = 0;\n+\n+                                if variants.get(0).args.len() == 0 {\n+                                    data_idx = 1;\n+                                }\n+\n+                                if variants.get(data_idx).args.len() == 1 {\n+                                    match get(*variants.get(data_idx).args.get(0)).sty {\n+                                        ty_bare_fn(..) => { res = res - TC::ReachesFfiUnsafe; }\n+                                        _ => { }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+\n                 apply_lang_items(cx, did, res)\n             }\n \n@@ -2427,6 +2479,10 @@ pub fn type_moves_by_default(cx: &ctxt, ty: t) -> bool {\n     type_contents(cx, ty).moves_by_default(cx)\n }\n \n+pub fn is_ffi_safe(cx: &ctxt, ty: t) -> bool {\n+    !type_contents(cx, ty).intersects(TC::ReachesFfiUnsafe)\n+}\n+\n // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n     fn type_requires(cx: &ctxt, seen: &mut Vec<DefId>,\n@@ -3945,7 +4001,7 @@ pub fn substd_enum_variants(cx: &ctxt,\n                          -> Vec<Rc<VariantInfo>> {\n     enum_variants(cx, id).iter().map(|variant_info| {\n         let substd_args = variant_info.args.iter()\n-            .map(|aty| aty.subst(cx, substs)).collect();\n+            .map(|aty| aty.subst(cx, substs)).collect::<Vec<_>>();\n \n         let substd_ctor_ty = variant_info.ctor_ty.subst(cx, substs);\n \n@@ -4168,24 +4224,26 @@ pub fn has_attr(tcx: &ctxt, did: DefId, attr: &str) -> bool {\n     found\n }\n \n-/// Determine whether an item is annotated with `#[packed]`\n+/// Determine whether an item is annotated with `#[repr(packed)]`\n pub fn lookup_packed(tcx: &ctxt, did: DefId) -> bool {\n-    has_attr(tcx, did, \"packed\")\n+    lookup_repr_hints(tcx, did).contains(&attr::ReprPacked)\n }\n \n /// Determine whether an item is annotated with `#[simd]`\n pub fn lookup_simd(tcx: &ctxt, did: DefId) -> bool {\n     has_attr(tcx, did, \"simd\")\n }\n \n-// Obtain the representation annotation for a definition.\n-pub fn lookup_repr_hint(tcx: &ctxt, did: DefId) -> attr::ReprAttr {\n-    let mut acc = attr::ReprAny;\n+/// Obtain the representation annotation for a struct definition.\n+pub fn lookup_repr_hints(tcx: &ctxt, did: DefId) -> Vec<attr::ReprAttr> {\n+    let mut acc = Vec::new();\n+\n     ty::each_attr(tcx, did, |meta| {\n-        acc = attr::find_repr_attr(tcx.sess.diagnostic(), meta, acc);\n+        acc.extend(attr::find_repr_attrs(tcx.sess.diagnostic(), meta).move_iter());\n         true\n     });\n-    return acc;\n+\n+    acc\n }\n \n // Look up a field ID, whether or not it's local"}, {"sha": "5f89a1f48bd3d08272953ee3944032c944e13464", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -4180,13 +4180,13 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                     let inh = blank_inherited_fields(ccx);\n                     let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n                     let declty = match hint {\n-                        attr::ReprAny | attr::ReprExtern => ty::mk_int(),\n+                        attr::ReprAny | attr::ReprPacked | attr::ReprExtern => ty::mk_int(),\n                         attr::ReprInt(_, attr::SignedInt(ity)) => {\n                             ty::mk_mach_int(ity)\n                         }\n                         attr::ReprInt(_, attr::UnsignedInt(ity)) => {\n                             ty::mk_mach_uint(ity)\n-                        }\n+                        },\n                     };\n                     check_const_with_ty(&fcx, e.span, &*e, declty);\n                     // check_expr (from check_const pass) doesn't guarantee\n@@ -4225,6 +4225,9 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                             \"discriminant type specified here\");\n                     }\n                 }\n+                attr::ReprPacked => {\n+                    ccx.tcx.sess.bug(\"range_to_inttype: found ReprPacked on an enum\");\n+                }\n             }\n             disr_vals.push(current_disr_val);\n \n@@ -4238,7 +4241,9 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n         return variants;\n     }\n \n-    let hint = ty::lookup_repr_hint(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id });\n+    let hint = *ty::lookup_repr_hints(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n+                    .as_slice().get(0).unwrap_or(&attr::ReprAny);\n+\n     if hint != attr::ReprAny && vs.len() <= 1 {\n         if vs.len() == 1 {\n             span_err!(ccx.tcx.sess, sp, E0083,"}, {"sha": "8d2305a8a8068296db23f6a4d96a828ab3ccff80", "filename": "src/librustrt/libunwind.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -72,6 +72,7 @@ pub static unwinder_private_data_size: uint = 5;\n #[cfg(target_arch = \"mipsel\")]\n pub static unwinder_private_data_size: uint = 2;\n \n+#[repr(C)]\n pub struct _Unwind_Exception {\n     pub exception_class: _Unwind_Exception_Class,\n     pub exception_cleanup: _Unwind_Exception_Cleanup_Fn,"}, {"sha": "5ef1286500c4f872b78a56e0306cf0cb9c8ee42e", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -701,7 +701,7 @@ mod imp {\n     static IMAGE_FILE_MACHINE_IA64: libc::DWORD = 0x0200;\n     static IMAGE_FILE_MACHINE_AMD64: libc::DWORD = 0x8664;\n \n-    #[packed]\n+    #[repr(packed)]\n     struct SYMBOL_INFO {\n         SizeOfStruct: libc::c_ulong,\n         TypeIndex: libc::c_ulong,"}, {"sha": "4b2a3073755eb5c08f0e59a9d5cff1770ff0ba7e", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -418,19 +418,14 @@ pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[Gc<MetaItem>]) {\n }\n \n \n-/// Fold this over attributes to parse #[repr(...)] forms.\n+/// Parse #[repr(...)] forms.\n ///\n /// Valid repr contents: any of the primitive integral type names (see\n-/// `int_type_of_word`, below) to specify the discriminant type; and `C`, to use\n-/// the same discriminant size that the corresponding C enum would.  These are\n-/// not allowed on univariant or zero-variant enums, which have no discriminant.\n-///\n-/// If a discriminant type is so specified, then the discriminant will be\n-/// present (before fields, if any) with that type; representation\n-/// optimizations which would remove it will not be done.\n-pub fn find_repr_attr(diagnostic: &SpanHandler, attr: &Attribute, acc: ReprAttr)\n-    -> ReprAttr {\n-    let mut acc = acc;\n+/// `int_type_of_word`, below) to specify enum discriminant type; `C`, to use\n+/// the same discriminant size that the corresponding C enum would or C\n+/// structure layout, and `packed` to remove padding.\n+pub fn find_repr_attrs(diagnostic: &SpanHandler, attr: &Attribute) -> Vec<ReprAttr> {\n+    let mut acc = Vec::new();\n     match attr.node.value.node {\n         ast::MetaList(ref s, ref items) if s.equiv(&(\"repr\")) => {\n             mark_used(attr);\n@@ -439,28 +434,26 @@ pub fn find_repr_attr(diagnostic: &SpanHandler, attr: &Attribute, acc: ReprAttr)\n                     ast::MetaWord(ref word) => {\n                         let hint = match word.get() {\n                             // Can't use \"extern\" because it's not a lexical identifier.\n-                            \"C\" => ReprExtern,\n+                            \"C\" => Some(ReprExtern),\n+                            \"packed\" => Some(ReprPacked),\n                             _ => match int_type_of_word(word.get()) {\n-                                Some(ity) => ReprInt(item.span, ity),\n+                                Some(ity) => Some(ReprInt(item.span, ity)),\n                                 None => {\n                                     // Not a word we recognize\n                                     diagnostic.span_err(item.span,\n                                                         \"unrecognized representation hint\");\n-                                    ReprAny\n+                                    None\n                                 }\n                             }\n                         };\n-                        if hint != ReprAny {\n-                            if acc == ReprAny {\n-                                acc = hint;\n-                            } else if acc != hint {\n-                                diagnostic.span_warn(item.span,\n-                                                     \"conflicting representation hint ignored\")\n-                            }\n+\n+                        match hint {\n+                            Some(h) => acc.push(h),\n+                            None => { }\n                         }\n                     }\n                     // Not a word:\n-                    _ => diagnostic.span_err(item.span, \"unrecognized representation hint\")\n+                    _ => diagnostic.span_err(item.span, \"unrecognized enum representation hint\")\n                 }\n             }\n         }\n@@ -490,15 +483,17 @@ fn int_type_of_word(s: &str) -> Option<IntType> {\n pub enum ReprAttr {\n     ReprAny,\n     ReprInt(Span, IntType),\n-    ReprExtern\n+    ReprExtern,\n+    ReprPacked,\n }\n \n impl ReprAttr {\n     pub fn is_ffi_safe(&self) -> bool {\n         match *self {\n             ReprAny => false,\n             ReprInt(_sp, ity) => ity.is_ffi_safe(),\n-            ReprExtern => true\n+            ReprExtern => true,\n+            ReprPacked => false\n         }\n     }\n }\n@@ -523,7 +518,7 @@ impl IntType {\n             SignedInt(ast::TyI16) | UnsignedInt(ast::TyU16) |\n             SignedInt(ast::TyI32) | UnsignedInt(ast::TyU32) |\n             SignedInt(ast::TyI64) | UnsignedInt(ast::TyU64) => true,\n-            _ => false\n+            SignedInt(ast::TyI) | UnsignedInt(ast::TyU) => false\n         }\n     }\n }"}, {"sha": "86f5f93e3cf08d56745114631b2abb4251c46a2c", "filename": "src/test/auxiliary/packed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fauxiliary%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fauxiliary%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fpacked.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[packed]\n+#[repr(packed)]\n pub struct S {\n     a: u8,\n     b: u32"}, {"sha": "eb8e75eae785de88a499f8f508a2dd4a8e716b6f", "filename": "src/test/compile-fail/issue-14309.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fcompile-fail%2Fissue-14309.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fcompile-fail%2Fissue-14309.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14309.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(ctypes)]\n+#![allow(dead_code)]\n+\n+struct A { //~ NOTE consider adding `#[repr(C)]` to this type\n+    x: int\n+}\n+\n+#[repr(C, packed)]\n+struct B {\n+    x: int,\n+    y: A\n+}\n+\n+#[repr(C)]\n+struct C {\n+    x: int\n+}\n+\n+type A2 = A;\n+type B2 = B;\n+type C2 = C;\n+\n+#[repr(C)]\n+struct D {\n+    x: C,\n+    y: A\n+}\n+\n+extern \"C\" {\n+    fn foo(x: A); //~ ERROR found struct without FFI-safe representation used in FFI\n+    fn bar(x: B); //~ ERROR FFI-safe\n+    fn baz(x: C);\n+    fn qux(x: A2); //~ ERROR FFI-safe\n+    fn quux(x: B2); //~ ERROR FFI-safe\n+    fn corge(x: C2);\n+    fn fred(x: D); //~ ERROR FFI-safe\n+}\n+\n+fn main() { }"}, {"sha": "d597006e29dd558ec002a9643ea611a855be8fb7", "filename": "src/test/compile-fail/lint-ctypes-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -19,8 +19,8 @@ enum T { E, F, G }\n extern {\n    fn zf(x: Z);\n    fn uf(x: U);\n-   fn bf(x: B); //~ ERROR found enum type without foreign-function-safe\n-   fn tf(x: T); //~ ERROR found enum type without foreign-function-safe\n+   fn bf(x: B); //~ ERROR found enum without FFI-safe\n+   fn tf(x: T); //~ ERROR found enum without FFI-safe\n }\n \n pub fn main() { }"}, {"sha": "7a1ff5744888dfa89e29eabc1a82e2b866f52eb9", "filename": "src/test/compile-fail/packed-struct-generic-transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -19,7 +19,7 @@ extern crate debug;\n \n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n struct Foo<T,S> {\n     bar: T,\n     baz: S"}, {"sha": "f92cc4b13440c89e47c0538f48775f9d3e81d3f0", "filename": "src/test/compile-fail/packed-struct-transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -19,7 +19,7 @@ extern crate debug;\n \n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n struct Foo {\n     bar: u8,\n     baz: uint"}, {"sha": "ef23e7ee87666a3a62d12100e1a7dabd195014f9", "filename": "src/test/debuginfo/c-style-enum-in-composite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fdebuginfo%2Fc-style-enum-in-composite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fdebuginfo%2Fc-style-enum-in-composite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fc-style-enum-in-composite.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -87,7 +87,7 @@ struct PaddedStruct {\n     e: i16\n }\n \n-#[packed]\n+#[repr(packed)]\n struct PackedStruct {\n     a: i16,\n     b: AnEnum,"}, {"sha": "00a560edbf01af121309c7b609443cc767c0361e", "filename": "src/test/debuginfo/packed-struct-with-destructor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fdebuginfo%2Fpacked-struct-with-destructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fdebuginfo%2Fpacked-struct-with-destructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpacked-struct-with-destructor.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -77,7 +77,7 @@\n \n #![allow(unused_variable)]\n \n-#[packed]\n+#[repr(packed)]\n struct Packed {\n     x: i16,\n     y: i32,\n@@ -88,7 +88,7 @@ impl Drop for Packed {\n     fn drop(&mut self) {}\n }\n \n-#[packed]\n+#[repr(packed)]\n struct PackedInPacked {\n     a: i32,\n     b: Packed,\n@@ -113,15 +113,15 @@ impl Drop for Unpacked {\n     fn drop(&mut self) {}\n }\n \n-#[packed]\n+#[repr(packed)]\n struct UnpackedInPacked {\n     a: i16,\n     b: Unpacked,\n     c: Unpacked,\n     d: i64\n }\n \n-#[packed]\n+#[repr(packed)]\n struct PackedInPackedWithDrop {\n     a: i32,\n     b: Packed,\n@@ -144,7 +144,7 @@ impl Drop for PackedInUnpackedWithDrop {\n     fn drop(&mut self) {}\n }\n \n-#[packed]\n+#[repr(packed)]\n struct UnpackedInPackedWithDrop {\n     a: i16,\n     b: Unpacked,"}, {"sha": "bf2213509cf7c42af92d3ef5ca8d2468ce48e15d", "filename": "src/test/debuginfo/packed-struct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -63,14 +63,14 @@\n \n #![allow(unused_variable)]\n \n-#[packed]\n+#[repr(packed)]\n struct Packed {\n     x: i16,\n     y: i32,\n     z: i64\n }\n \n-#[packed]\n+#[repr(packed)]\n struct PackedInPacked {\n     a: i32,\n     b: Packed,\n@@ -95,7 +95,7 @@ struct Unpacked {\n }\n \n // layout (64 bit): aabb bbbb bbbb bbbb bbbb bbbb bbcc cccc cccc cccc cccc cccc ccdd dddd dd\n-#[packed]\n+#[repr(packed)]\n struct UnpackedInPacked {\n     a: i16,\n     b: Unpacked,"}, {"sha": "8d8daed1393c7f21a2edaa752f1cc13285e0d179", "filename": "src/test/run-make/extern-fn-with-packed-struct/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[packed]\n+#[repr(packed)]\n #[deriving(PartialEq, Show)]\n struct Foo {\n     a: i8,"}, {"sha": "c6c74fe3fda1d59aac5fca873a4c64d78b904091", "filename": "src/test/run-pass/packed-struct-borrow-element.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-struct-borrow-element.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-struct-borrow-element.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-borrow-element.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[packed]\n+#[repr(packed)]\n struct Foo {\n     bar: u8,\n     baz: uint"}, {"sha": "999e4aeeb5977ebacedd0d5195f56da419496a0d", "filename": "src/test/run-pass/packed-struct-generic-layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -10,7 +10,7 @@\n \n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n struct S<T, S> {\n     a: T,\n     b: u8,"}, {"sha": "45791332bbedfae08a6b635a1cf3da428ef73c86", "filename": "src/test/run-pass/packed-struct-generic-size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -10,7 +10,7 @@\n \n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n struct S<T, S> {\n     a: T,\n     b: u8,"}, {"sha": "b4fbf0820cd46b0badead839ab53af6d727bc7e1", "filename": "src/test/run-pass/packed-struct-layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-struct-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-struct-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-layout.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -10,13 +10,13 @@\n \n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n struct S4 {\n     a: u8,\n     b: [u8, .. 3],\n }\n \n-#[packed]\n+#[repr(packed)]\n struct S5 {\n     a: u8,\n     b: u32"}, {"sha": "46ffed0cba9684004caddf2f751bfb65b4c0c0b9", "filename": "src/test/run-pass/packed-struct-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-struct-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-struct-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-match.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[packed]\n+#[repr(packed)]\n struct Foo {\n     bar: u8,\n     baz: uint"}, {"sha": "cfea444d7ffc7ee5100eb6afc29f5690d4748d0d", "filename": "src/test/run-pass/packed-struct-size.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -12,19 +12,19 @@\n use std::mem;\n use std::gc::Gc;\n \n-#[packed]\n+#[repr(packed)]\n struct S4 {\n     a: u8,\n     b: [u8, .. 3],\n }\n \n-#[packed]\n+#[repr(packed)]\n struct S5 {\n     a: u8,\n     b: u32\n }\n \n-#[packed]\n+#[repr(packed)]\n struct S13 {\n     a: i64,\n     b: f32,\n@@ -36,14 +36,14 @@ enum Foo {\n     Baz = 2\n }\n \n-#[packed]\n+#[repr(packed)]\n struct S3_Foo {\n     a: u8,\n     b: u16,\n     c: Foo\n }\n \n-#[packed]\n+#[repr(packed)]\n struct S7_Option {\n     a: f32,\n     b: u8,"}, {"sha": "c20e62351a618ef3ce2d781e0060184cbf9f61cc", "filename": "src/test/run-pass/packed-struct-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -12,7 +12,7 @@\n \n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n #[deriving(PartialEq, Show)]\n struct Foo {\n     bar: u8,"}, {"sha": "5fb43503ccb26b0ccfff993b6959783ea9a5064d", "filename": "src/test/run-pass/packed-tuple-struct-layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-layout.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -10,10 +10,10 @@\n \n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n struct S4(u8,[u8, .. 3]);\n \n-#[packed]\n+#[repr(packed)]\n struct S5(u8,u32);\n \n pub fn main() {"}, {"sha": "f23166288fb55a687df0efe576df890395fda693", "filename": "src/test/run-pass/packed-tuple-struct-size.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs?ref=6e8ff999589a7b4c7f62f7128f3e028a7b3ea64f", "patch": "@@ -12,24 +12,24 @@\n use std::gc::Gc;\n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n struct S4(u8,[u8, .. 3]);\n \n-#[packed]\n+#[repr(packed)]\n struct S5(u8, u32);\n \n-#[packed]\n+#[repr(packed)]\n struct S13(i64, f32, u8);\n \n enum Foo {\n     Bar = 1,\n     Baz = 2\n }\n \n-#[packed]\n+#[repr(packed)]\n struct S3_Foo(u8, u16, Foo);\n \n-#[packed]\n+#[repr(packed)]\n struct S7_Option(f32, u8, u16, Option<Gc<f64>>);\n \n pub fn main() {"}]}