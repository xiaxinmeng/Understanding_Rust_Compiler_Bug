{"sha": "e53625706106e0227656ddd2fa4d7df54ae2b90e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1MzYyNTcwNjEwNmUwMjI3NjU2ZGRkMmZhNGQ3ZGY1NGFlMmI5MGU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-04-11T18:31:54Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-04-20T18:17:03Z"}, "message": "Ensure tail expression will have a `Ty` for E0746\n\nWhen the return type is `!Sized` we look for all the returned\nexpressions in the body to fetch their types and provide a reasonable\nsuggestion. The tail expression of the body is normally evaluated after\nchecking whether the return type is `Sized`. Changing the order of the\nevaluation produces undesirable knock down effects, so we detect the\nspecific case that newcomers are likely to encounter ,returning a single\nbare trait object, and only in that case we evaluate the tail\nexpression's type so that the suggestion will be accurate.", "tree": {"sha": "ca5862cc1e9602ebb3e5c20b671293de8732f9f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca5862cc1e9602ebb3e5c20b671293de8732f9f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e53625706106e0227656ddd2fa4d7df54ae2b90e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e53625706106e0227656ddd2fa4d7df54ae2b90e", "html_url": "https://github.com/rust-lang/rust/commit/e53625706106e0227656ddd2fa4d7df54ae2b90e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e53625706106e0227656ddd2fa4d7df54ae2b90e/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3c96f03b5f6b4457cbabf4f3e1ec6c1aed23385", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c96f03b5f6b4457cbabf4f3e1ec6c1aed23385", "html_url": "https://github.com/rust-lang/rust/commit/d3c96f03b5f6b4457cbabf4f3e1ec6c1aed23385"}], "stats": {"total": 179, "additions": 113, "deletions": 66}, "files": [{"sha": "305667e58f8fb3afb669fd325738051b23763842", "filename": "src/librustc_error_codes/error_codes/E0746.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e53625706106e0227656ddd2fa4d7df54ae2b90e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md", "raw_url": "https://github.com/rust-lang/rust/raw/e53625706106e0227656ddd2fa4d7df54ae2b90e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md?ref=e53625706106e0227656ddd2fa4d7df54ae2b90e", "patch": "@@ -2,8 +2,7 @@ Return types cannot be `dyn Trait`s as they must be `Sized`.\n \n Erroneous code example:\n \n-```compile_fail,E0277\n-# // FIXME: after E0746 is in beta, change the above\n+```compile_fail,E0746\n trait T {\n     fn bar(&self);\n }"}, {"sha": "74c852046a3f73c2566790804ee6907d24f4a5a5", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 73, "deletions": 48, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/e53625706106e0227656ddd2fa4d7df54ae2b90e/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e53625706106e0227656ddd2fa4d7df54ae2b90e/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=e53625706106e0227656ddd2fa4d7df54ae2b90e", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n use rustc_middle::ty::TypeckTables;\n use rustc_middle::ty::{\n-    self, AdtKind, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n+    self, AdtKind, DefIdTree, Infer, InferTy, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n@@ -826,12 +826,28 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             .iter()\n             .filter_map(|expr| tables.node_type_opt(expr.hir_id))\n             .map(|ty| self.resolve_vars_if_possible(&ty));\n-        let (last_ty, all_returns_have_same_type, count) = ret_types.clone().fold(\n-            (None, true, 0),\n-            |(last_ty, mut same, count): (std::option::Option<Ty<'_>>, bool, usize), ty| {\n+        let (last_ty, all_returns_have_same_type, only_never_return) = ret_types.clone().fold(\n+            (None, true, true),\n+            |(last_ty, mut same, only_never_return): (std::option::Option<Ty<'_>>, bool, bool),\n+             ty| {\n                 let ty = self.resolve_vars_if_possible(&ty);\n-                same &= last_ty.map_or(true, |last_ty| last_ty == ty) && ty.kind != ty::Error;\n-                (Some(ty), same, count + 1)\n+                same &=\n+                    ty.kind != ty::Error\n+                        && last_ty.map_or(true, |last_ty| {\n+                            // FIXME: ideally we would use `can_coerce` here instead, but `typeck` comes\n+                            // *after* in the dependency graph.\n+                            match (&ty.kind, &last_ty.kind) {\n+                                (Infer(InferTy::IntVar(_)), Infer(InferTy::IntVar(_)))\n+                                | (Infer(InferTy::FloatVar(_)), Infer(InferTy::FloatVar(_)))\n+                                | (Infer(InferTy::FreshIntTy(_)), Infer(InferTy::FreshIntTy(_)))\n+                                | (\n+                                    Infer(InferTy::FreshFloatTy(_)),\n+                                    Infer(InferTy::FreshFloatTy(_)),\n+                                ) => true,\n+                                _ => ty == last_ty,\n+                            }\n+                        });\n+                (Some(ty), same, only_never_return && matches!(ty.kind, ty::Never))\n             },\n         );\n         let all_returns_conform_to_trait =\n@@ -840,13 +856,14 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     ty::Dynamic(predicates, _) => {\n                         let cause = ObligationCause::misc(ret_ty.span, ret_ty.hir_id);\n                         let param_env = ty::ParamEnv::empty();\n-                        ret_types.all(|returned_ty| {\n-                            predicates.iter().all(|predicate| {\n-                                let pred = predicate.with_self_ty(self.tcx, returned_ty);\n-                                let obl = Obligation::new(cause.clone(), param_env, pred);\n-                                self.predicate_may_hold(&obl)\n+                        only_never_return\n+                            || ret_types.all(|returned_ty| {\n+                                predicates.iter().all(|predicate| {\n+                                    let pred = predicate.with_self_ty(self.tcx, returned_ty);\n+                                    let obl = Obligation::new(cause.clone(), param_env, pred);\n+                                    self.predicate_may_hold(&obl)\n+                                })\n                             })\n-                        }) || count == 0\n                     }\n                     _ => false,\n                 }\n@@ -861,7 +878,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             &ret_ty.kind,\n             sm.span_to_snippet(ret_ty.span),\n             // If any of the return types does not conform to the trait, then we can't\n-            // suggest `impl Trait` nor trait objects, it is a type mismatch error.\n+            // suggest `impl Trait` nor trait objects: it is a type mismatch error.\n             all_returns_conform_to_trait,\n         ) {\n             snippet\n@@ -879,43 +896,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             #using-trait-objects-that-allow-for-values-of-different-types>\";\n         let has_dyn = snippet.split_whitespace().next().map_or(false, |s| s == \"dyn\");\n         let trait_obj = if has_dyn { &snippet[4..] } else { &snippet[..] };\n-        if count == 0 {\n-            // No return paths. Suggest `-> T`, `-> impl Trait`, and if `Trait` is object safe,\n-            // `-> Box<dyn Trait>`.\n-            err.note(\n-                \"currently nothing is being returned, depending on the final implementation \\\n-                 you could change the return type in different ways\",\n-            );\n-            err.span_suggestion(\n-                ret_ty.span,\n-                \"you could use some type `T` that is `T: Sized` as the return type if all return \\\n-                 paths will have the same type\",\n-                \"T\".to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-            err.span_suggestion(\n+        if only_never_return {\n+            // No return paths, probably using `panic!()` or similar.\n+            // Suggest `-> T`, `-> impl Trait`, and if `Trait` is object safe, `-> Box<dyn Trait>`.\n+            suggest_trait_object_return_type_alternatives(\n+                err,\n                 ret_ty.span,\n-                &format!(\n-                    \"you could use `impl {}` as the return type if all return paths will have the \\\n-                     same type but you want to expose only the trait in the signature\",\n-                    trait_obj,\n-                ),\n-                format!(\"impl {}\", trait_obj),\n-                Applicability::MaybeIncorrect,\n+                trait_obj,\n+                is_object_safe,\n             );\n-            err.note(impl_trait_msg);\n-            if is_object_safe {\n-                err.span_suggestion(\n-                    ret_ty.span,\n-                    &format!(\n-                        \"you could use a boxed trait object if all return paths `impl` trait `{}`\",\n-                        trait_obj,\n-                    ),\n-                    format!(\"Box<dyn {}>\", trait_obj),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                err.note(trait_obj_msg);\n-            }\n         } else if let (Some(last_ty), true) = (last_ty, all_returns_have_same_type) {\n             // Suggest `-> impl Trait`.\n             err.span_suggestion(\n@@ -1851,3 +1840,39 @@ impl NextTypeParamName for &[hir::GenericParam<'_>] {\n             .to_string()\n     }\n }\n+\n+fn suggest_trait_object_return_type_alternatives(\n+    err: &mut DiagnosticBuilder<'tcx>,\n+    ret_ty: Span,\n+    trait_obj: &str,\n+    is_object_safe: bool,\n+) {\n+    err.span_suggestion(\n+        ret_ty,\n+        \"use some type `T` that is `T: Sized` as the return type if all return paths have the \\\n+            same type\",\n+        \"T\".to_string(),\n+        Applicability::MaybeIncorrect,\n+    );\n+    err.span_suggestion(\n+        ret_ty,\n+        &format!(\n+            \"use `impl {}` as the return type if all return paths have the same type but you \\\n+                want to expose only the trait in the signature\",\n+            trait_obj,\n+        ),\n+        format!(\"impl {}\", trait_obj),\n+        Applicability::MaybeIncorrect,\n+    );\n+    if is_object_safe {\n+        err.span_suggestion(\n+            ret_ty,\n+            &format!(\n+                \"use a boxed trait object if all return paths implement trait `{}`\",\n+                trait_obj,\n+            ),\n+            format!(\"Box<dyn {}>\", trait_obj),\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}"}, {"sha": "65bcb19b20a8914437cc7ba0ae2fa5a5218f3fe0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e53625706106e0227656ddd2fa4d7df54ae2b90e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e53625706106e0227656ddd2fa4d7df54ae2b90e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e53625706106e0227656ddd2fa4d7df54ae2b90e", "patch": "@@ -1305,7 +1305,6 @@ fn check_fn<'a, 'tcx>(\n     let hir = tcx.hir();\n \n     let declared_ret_ty = fn_sig.output();\n-    fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n     let revealed_ret_ty =\n         fcx.instantiate_opaque_types_from_value(fn_id, &declared_ret_ty, decl.output.span());\n     debug!(\"check_fn: declared_ret_ty: {}, revealed_ret_ty: {}\", declared_ret_ty, revealed_ret_ty);\n@@ -1374,7 +1373,25 @@ fn check_fn<'a, 'tcx>(\n \n     inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n-    fcx.check_return_expr(&body.value);\n+    if let ty::Dynamic(..) = declared_ret_ty.kind {\n+        // FIXME: We need to verify that the return type is `Sized` after the return expression has\n+        // been evaluated so that we have types available for all the nodes being returned, but that\n+        // requires the coerced evaluated type to be stored. Moving `check_return_expr` before this\n+        // causes unsized errors caused by the `declared_ret_ty` to point at the return expression,\n+        // while keeping the current ordering we will ignore the tail expression's type because we\n+        // don't know it yet. We can't do `check_expr_kind` while keeping `check_return_expr`\n+        // because we will trigger \"unreachable expression\" lints unconditionally.\n+        // Because of all of this, we perform a crude check to know whether the simplest `!Sized`\n+        // case that a newcomer might make, returning a bare trait, and in that case we populate\n+        // the tail expression's type so that the suggestion will be correct, but ignore all other\n+        // possible cases.\n+        fcx.check_expr(&body.value);\n+        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n+        tcx.sess.delay_span_bug(decl.output.span(), \"`!Sized` return type\");\n+    } else {\n+        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n+        fcx.check_return_expr(&body.value);\n+    }\n \n     // We insert the deferred_generator_interiors entry after visiting the body.\n     // This ensures that all nested generators appear before the entry of this generator."}, {"sha": "cbf1daabe2b4e69e0af6b205283b75f60a4e1c45", "filename": "src/test/ui/impl-trait/dyn-trait-return-should-be-impl-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e53625706106e0227656ddd2fa4d7df54ae2b90e/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e53625706106e0227656ddd2fa4d7df54ae2b90e/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs?ref=e53625706106e0227656ddd2fa4d7df54ae2b90e", "patch": "@@ -26,7 +26,7 @@ fn bax() -> dyn Trait { //~ ERROR E0746\n     if true {\n         Struct\n     } else {\n-        42\n+        42 //~ ERROR `if` and `else` have incompatible types\n     }\n }\n fn bam() -> Box<dyn Trait> {"}, {"sha": "c55dbd7d2fafe9559d669780b399b9e2bc9d0929", "filename": "src/test/ui/impl-trait/dyn-trait-return-should-be-impl-trait.stderr", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e53625706106e0227656ddd2fa4d7df54ae2b90e/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e53625706106e0227656ddd2fa4d7df54ae2b90e/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr?ref=e53625706106e0227656ddd2fa4d7df54ae2b90e", "patch": "@@ -72,18 +72,15 @@ error[E0746]: return type cannot have an unboxed trait object\n LL | fn bak() -> dyn Trait { unimplemented!() }\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: currently nothing is being returned, depending on the final implementation you could change the return type in different ways\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-help: you could use some type `T` that is `T: Sized` as the return type if all return paths will have the same type\n+help: use some type `T` that is `T: Sized` as the return type if all return paths have the same type\n    |\n LL | fn bak() -> T { unimplemented!() }\n    |             ^\n-help: you could use `impl Trait` as the return type if all return paths will have the same type but you want to expose only the trait in the signature\n+help: use `impl Trait` as the return type if all return paths have the same type but you want to expose only the trait in the signature\n    |\n LL | fn bak() -> impl Trait { unimplemented!() }\n    |             ^^^^^^^^^^\n-help: you could use a boxed trait object if all return paths `impl` trait `Trait`\n+help: use a boxed trait object if all return paths implement trait `Trait`\n    |\n LL | fn bak() -> Box<dyn Trait> { unimplemented!() }\n    |             ^^^^^^^^^^^^^^\n@@ -107,6 +104,18 @@ LL |     }\n LL |     Box::new(42)\n    |\n \n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:29:9\n+   |\n+LL | /     if true {\n+LL | |         Struct\n+   | |         ------ expected because of this\n+LL | |     } else {\n+LL | |         42\n+   | |         ^^ expected struct `Struct`, found integer\n+LL | |     }\n+   | |_____- `if` and `else` have incompatible types\n+\n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:25:13\n    |\n@@ -278,7 +287,7 @@ help: use `impl Trait` as the return type, as all return paths are of type `{int\n LL | fn bay() -> impl Trait {\n    |             ^^^^^^^^^^\n \n-error: aborting due to 19 previous errors\n+error: aborting due to 20 previous errors\n \n Some errors have detailed explanations: E0277, E0308, E0746.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "1eb6822b8a11abb20467db9d06bfda7daa94af32", "filename": "src/test/ui/issues/issue-18107.stderr", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e53625706106e0227656ddd2fa4d7df54ae2b90e/src%2Ftest%2Fui%2Fissues%2Fissue-18107.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e53625706106e0227656ddd2fa4d7df54ae2b90e/src%2Ftest%2Fui%2Fissues%2Fissue-18107.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18107.stderr?ref=e53625706106e0227656ddd2fa4d7df54ae2b90e", "patch": "@@ -4,18 +4,15 @@ error[E0746]: return type cannot have an unboxed trait object\n LL |     dyn AbstractRenderer\n    |     ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: currently nothing is being returned, depending on the final implementation you could change the return type in different ways\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-help: you could use some type `T` that is `T: Sized` as the return type if all return paths will have the same type\n+help: use some type `T` that is `T: Sized` as the return type if all return paths have the same type\n    |\n LL |     T\n    |\n-help: you could use `impl AbstractRenderer` as the return type if all return paths will have the same type but you want to expose only the trait in the signature\n+help: use `impl AbstractRenderer` as the return type if all return paths have the same type but you want to expose only the trait in the signature\n    |\n LL |     impl AbstractRenderer\n    |\n-help: you could use a boxed trait object if all return paths `impl` trait `AbstractRenderer`\n+help: use a boxed trait object if all return paths implement trait `AbstractRenderer`\n    |\n LL |     Box<dyn AbstractRenderer>\n    |"}]}