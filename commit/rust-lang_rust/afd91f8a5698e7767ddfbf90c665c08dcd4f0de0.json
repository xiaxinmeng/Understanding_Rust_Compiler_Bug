{"sha": "afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZDkxZjhhNTY5OGU3NzY3ZGRmYmY5MGM2NjVjMDhkY2Q0ZjBkZTA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-24T05:25:43Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-24T06:01:49Z"}, "message": "Register snapshots. Remove redundant Eq impls, Makefile hacks", "tree": {"sha": "3bc5d52fd888c010ea797f6570c92abe861c183a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bc5d52fd888c010ea797f6570c92abe861c183a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "html_url": "https://github.com/rust-lang/rust/commit/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dae768624de87bcec1160bd29c27af1affe7f5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dae768624de87bcec1160bd29c27af1affe7f5f", "html_url": "https://github.com/rust-lang/rust/commit/2dae768624de87bcec1160bd29c27af1affe7f5f"}], "stats": {"total": 3685, "additions": 8, "deletions": 3677}, "files": [{"sha": "fae389798ec71ff9c39d148b932428dd8b94c9c7", "filename": "Makefile.in", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -357,16 +357,6 @@ EXTRAFLAGS_STAGE$(1) = $$(RUSTFLAGS_STAGE$(1))\n \n CFGFLAG$(1)_T_$(2)_H_$(3) = stage$(1)\n \n-# XXX: Terrible hack. No time to explain! Remove after snapshot.\n-ifeq ($(1),0)\n-ifeq ($(3),i686-unknown-linux-gnu)\n-CFGFLAG$(1)_T_$(2)_H_$(3) = stage1\n-endif\n-ifeq ($(3),i686-apple-darwin)\n-CFGFLAG$(1)_T_$(2)_H_$(3) = stage1\n-endif\n-endif\n-\n STAGE$(1)_T_$(2)_H_$(3) := \t\t\t\t\t\t\\\n \t$$(Q)$$(call CFG_RUN_TARG,$(1),\t\t\t\t\\\n \t\t$$(CFG_VALGRIND_COMPILE$(1)) \t\t\t\\"}, {"sha": "4dcfc608e0ea36d5f364f2edccc7a878df24e384", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -28,30 +28,6 @@ type package = {\n     versions: ~[(~str, ~str)]\n };\n \n-#[cfg(stage0)]\n-impl package : cmp::Ord {\n-    pure fn lt(&&other: package) -> bool {\n-        if self.name.lt(other.name) { return true; }\n-        if other.name.lt(self.name) { return false; }\n-        if self.uuid.lt(other.uuid) { return true; }\n-        if other.uuid.lt(self.uuid) { return false; }\n-        if self.url.lt(other.url) { return true; }\n-        if other.url.lt(self.url) { return false; }\n-        if self.method.lt(other.method) { return true; }\n-        if other.method.lt(self.method) { return false; }\n-        if self.description.lt(other.description) { return true; }\n-        if other.description.lt(self.description) { return false; }\n-        if self.tags.lt(other.tags) { return true; }\n-        if other.tags.lt(self.tags) { return false; }\n-        if self.versions.lt(other.versions) { return true; }\n-        return false;\n-    }\n-    pure fn le(&&other: package) -> bool { !other.lt(self) }\n-    pure fn ge(&&other: package) -> bool { !self.lt(other) }\n-    pure fn gt(&&other: package) -> bool { other.lt(self)  }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl package : cmp::Ord {\n     pure fn lt(other: &package) -> bool {\n         if self.name.lt(&(*other).name) { return true; }\n@@ -123,15 +99,6 @@ type options = {\n \n enum mode { system_mode, user_mode, local_mode }\n \n-#[cfg(stage0)]\n-impl mode : cmp::Eq {\n-    pure fn eq(&&other: mode) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: mode) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl mode : cmp::Eq {\n     pure fn eq(other: &mode) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "3527dbe2f1007d90c1f9755b1e30d63b7b2c5a7c", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -1,14 +1,5 @@\n enum mode { mode_compile_fail, mode_run_fail, mode_run_pass, mode_pretty, }\n \n-#[cfg(stage0)]\n-impl mode : cmp::Eq {\n-    pure fn eq(&&other: mode) -> bool {\n-        other as int == self as int\n-    }\n-    pure fn ne(&&other: mode) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl mode : cmp::Eq {\n     pure fn eq(other: &mode) -> bool {\n         (*other) as int == self as int"}, {"sha": "5e2cf689b7c572f1747cb7fd9bd869f46c233e5c", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -10,15 +10,6 @@ use syntax::diagnostic;\n enum test_mode { tm_converge, tm_run, }\n type context = { mode: test_mode }; // + rng\n \n-#[cfg(stage0)]\n-impl test_mode : cmp::Eq {\n-    pure fn eq(&&other: test_mode) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: test_mode) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl test_mode : cmp::Eq {\n     pure fn eq(other: &test_mode) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "e35e6536410f050ea057c38f2f57364aa6b157cb", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -139,15 +139,6 @@ pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T] {\n #[cfg(notest)]\n mod traits {\n     #[legacy_exports];\n-    #[cfg(stage0)]\n-    impl<T: Copy> @[T]: Add<&[const T],@[T]> {\n-        #[inline(always)]\n-        pure fn add(rhs: &[const T]) -> @[T] {\n-            append(self, rhs)\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     impl<T: Copy> @[T] : Add<&[const T],@[T]> {\n         #[inline(always)]\n         pure fn add(rhs: & &[const T]) -> @[T] {"}, {"sha": "1419aac636965e632345921022106ad8f60c0e1c", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -69,13 +69,6 @@ fn all_values(blk: fn(v: bool)) {\n /// converts truth value to an 8 bit byte\n pure fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n \n-#[cfg(stage0)]\n-impl bool : cmp::Eq {\n-    pure fn eq(&&other: bool) -> bool { self == other }\n-    pure fn ne(&&other: bool) -> bool { self != other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl bool : cmp::Eq {\n     pure fn eq(other: &bool) -> bool { self == (*other) }\n     pure fn ne(other: &bool) -> bool { self != (*other) }"}, {"sha": "fd3715b457c4cb5cacb4e981cb072d469b07bb8c", "filename": "src/libcore/box.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -31,27 +31,11 @@ pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     unsafe { ptr::addr_of(*a) == ptr::addr_of(*b) }\n }\n \n-#[cfg(stage0)]\n-impl<T:Eq> @const T : Eq {\n-    pure fn eq(&&other: @const T) -> bool { *self == *other }\n-    pure fn ne(&&other: @const T) -> bool { *self != *other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T:Eq> @const T : Eq {\n     pure fn eq(other: &@const T) -> bool { *self == *(*other) }\n     pure fn ne(other: &@const T) -> bool { *self != *(*other) }\n }\n \n-#[cfg(stage0)]\n-impl<T:Ord> @const T : Ord {\n-    pure fn lt(&&other: @const T) -> bool { *self < *other }\n-    pure fn le(&&other: @const T) -> bool { *self <= *other }\n-    pure fn ge(&&other: @const T) -> bool { *self >= *other }\n-    pure fn gt(&&other: @const T) -> bool { *self > *other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T:Ord> @const T : Ord {\n     pure fn lt(other: &@const T) -> bool { *self < *(*other) }\n     pure fn le(other: &@const T) -> bool { *self <= *(*other) }"}, {"sha": "e6fab268a5b1617e07acc78f74b1acdc331bb395", "filename": "src/libcore/char.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -185,13 +185,6 @@ pure fn cmp(a: char, b: char) -> int {\n     else { 0 }\n }\n \n-#[cfg(stage0)]\n-impl char: Eq {\n-    pure fn eq(&&other: char) -> bool { self == other }\n-    pure fn ne(&&other: char) -> bool { self != other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl char : Eq {\n     pure fn eq(other: &char) -> bool { self == (*other) }\n     pure fn ne(other: &char) -> bool { self != (*other) }"}, {"sha": "37a8f976d74a12cb322409add41f710570ae5f49", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -32,17 +32,6 @@ mod nounittest {\n      * an `le` method, with the others generated from\n      * default implementations.\n      */\n-    #[cfg(stage0)]\n-    #[lang=\"ord\"]\n-    trait Ord {\n-        pure fn lt(&&other: self) -> bool;\n-        pure fn le(&&other: self) -> bool;\n-        pure fn ge(&&other: self) -> bool;\n-        pure fn gt(&&other: self) -> bool;\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     #[lang=\"ord\"]\n     trait Ord {\n         pure fn lt(other: &self) -> bool;\n@@ -51,7 +40,6 @@ mod nounittest {\n         pure fn gt(other: &self) -> bool;\n     }\n \n-    #[cfg(stage0)]\n     #[lang=\"eq\"]\n     /**\n      * Trait for values that can be compared for equality\n@@ -61,13 +49,6 @@ mod nounittest {\n      * an `eq` method, with the other generated from\n      * a default implementation.\n      */\n-    trait Eq {\n-        pure fn eq(&&other: self) -> bool;\n-        pure fn ne(&&other: self) -> bool;\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     #[lang=\"eq\"]\n     trait Eq {\n         pure fn eq(other: &self) -> bool;\n@@ -82,31 +63,13 @@ mod nounittest {\n #[cfg(test)]\n mod unittest {\n     #[legacy_exports];\n-    #[cfg(stage0)]\n-    trait Ord {\n-        pure fn lt(&&other: self) -> bool;\n-        pure fn le(&&other: self) -> bool;\n-        pure fn ge(&&other: self) -> bool;\n-        pure fn gt(&&other: self) -> bool;\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     trait Ord {\n         pure fn lt(other: &self) -> bool;\n         pure fn le(other: &self) -> bool;\n         pure fn ge(other: &self) -> bool;\n         pure fn gt(other: &self) -> bool;\n     }\n \n-    #[cfg(stage0)]\n-    trait Eq {\n-        pure fn eq(&&other: self) -> bool;\n-        pure fn ne(&&other: self) -> bool;\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     trait Eq {\n         pure fn eq(other: &self) -> bool;\n         pure fn ne(other: &self) -> bool;\n@@ -117,68 +80,26 @@ mod unittest {\n mod unittest {\n     #[legacy_exports];}\n \n-#[cfg(stage0)]\n-pure fn lt<T: Ord>(v1: &T, v2: &T) -> bool {\n-    v1.lt(v2)\n-}\n-\n-#[cfg(stage0)]\n-pure fn le<T: Ord Eq>(v1: &T, v2: &T) -> bool {\n-    v1.lt(v2) || v1.eq(v2)\n-}\n-\n-#[cfg(stage0)]\n-pure fn eq<T: Eq>(v1: &T, v2: &T) -> bool {\n-    v1.eq(v2)\n-}\n-\n-#[cfg(stage0)]\n-pure fn ne<T: Eq>(v1: &T, v2: &T) -> bool {\n-    v1.ne(v2)\n-}\n-\n-#[cfg(stage0)]\n-pure fn ge<T: Ord>(v1: &T, v2: &T) -> bool {\n-    v1.ge(v2)\n-}\n-\n-#[cfg(stage0)]\n-pure fn gt<T: Ord>(v1: &T, v2: &T) -> bool {\n-    v1.gt(v2)\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pure fn lt<T: Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).lt(v2)\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pure fn le<T: Ord Eq>(v1: &T, v2: &T) -> bool {\n     (*v1).lt(v2) || (*v1).eq(v2)\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pure fn eq<T: Eq>(v1: &T, v2: &T) -> bool {\n     (*v1).eq(v2)\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pure fn ne<T: Eq>(v1: &T, v2: &T) -> bool {\n     (*v1).ne(v2)\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pure fn ge<T: Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).ge(v2)\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pure fn gt<T: Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).gt(v2)\n }"}, {"sha": "55e22f7cfe975c73b73174b075c9fa114f38db67", "filename": "src/libcore/either.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -126,28 +126,6 @@ pure fn unwrap_right<T,U>(+eith: Either<T,U>) -> U {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T:Eq,U:Eq> Either<T,U> : Eq {\n-    pure fn eq(&&other: Either<T,U>) -> bool {\n-        match self {\n-            Left(a) => {\n-                match other {\n-                    Left(b) => a.eq(b),\n-                    Right(_) => false\n-                }\n-            }\n-            Right(a) => {\n-                match other {\n-                    Left(_) => false,\n-                    Right(b) => a.eq(b)\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: Either<T,U>) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T:Eq,U:Eq> Either<T,U> : Eq {\n     pure fn eq(other: &Either<T,U>) -> bool {\n         match self {"}, {"sha": "9a992143a11141f977b84ae9b44bafd51e4b674d", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -388,24 +388,6 @@ mod rt {\n \n     enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n \n-#[cfg(stage0)]\n-    impl PadMode: Eq {\n-        pure fn eq(&&other: PadMode) -> bool {\n-            match (self, other) {\n-                (PadSigned, PadSigned) => true,\n-                (PadUnsigned, PadUnsigned) => true,\n-                (PadNozero, PadNozero) => true,\n-                (PadFloat, PadFloat) => true,\n-                (PadSigned, _) => false,\n-                (PadUnsigned, _) => false,\n-                (PadNozero, _) => false,\n-                (PadFloat, _) => false\n-            }\n-        }\n-        pure fn ne(&&other: PadMode) -> bool { !self.eq(other) }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     impl PadMode : Eq {\n         pure fn eq(other: &PadMode) -> bool {\n             match (self, (*other)) {\n@@ -595,24 +577,6 @@ mod rt2 {\n \n     enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n \n-#[cfg(stage0)]\n-    impl PadMode: Eq {\n-        pure fn eq(&&other: PadMode) -> bool {\n-            match (self, other) {\n-                (PadSigned, PadSigned) => true,\n-                (PadUnsigned, PadUnsigned) => true,\n-                (PadNozero, PadNozero) => true,\n-                (PadFloat, PadFloat) => true,\n-                (PadSigned, _) => false,\n-                (PadUnsigned, _) => false,\n-                (PadNozero, _) => false,\n-                (PadFloat, _) => false\n-            }\n-        }\n-        pure fn ne(&&other: PadMode) -> bool { !self.eq(other) }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     impl PadMode : Eq {\n         pure fn eq(other: &PadMode) -> bool {\n             match (self, (*other)) {"}, {"sha": "2cd95269aaf02363a2453a816d866ce376acf295", "filename": "src/libcore/float.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -415,27 +415,11 @@ pure fn sin(x: float) -> float { f64::sin(x as f64) as float }\n pure fn cos(x: float) -> float { f64::cos(x as f64) as float }\n pure fn tan(x: float) -> float { f64::tan(x as f64) as float }\n \n-#[cfg(stage0)]\n-impl float: Eq {\n-    pure fn eq(&&other: float) -> bool { self == other }\n-    pure fn ne(&&other: float) -> bool { self != other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl float : Eq {\n     pure fn eq(other: &float) -> bool { self == (*other) }\n     pure fn ne(other: &float) -> bool { self != (*other) }\n }\n \n-#[cfg(stage0)]\n-impl float: Ord {\n-    pure fn lt(&&other: float) -> bool { self < other }\n-    pure fn le(&&other: float) -> bool { self <= other }\n-    pure fn ge(&&other: float) -> bool { self >= other }\n-    pure fn gt(&&other: float) -> bool { self > other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl float : Ord {\n     pure fn lt(other: &float) -> bool { self < (*other) }\n     pure fn le(other: &float) -> bool { self <= (*other) }"}, {"sha": "e1137e6d269c681badf72b070dc7988f7088291e", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -68,29 +68,13 @@ pure fn abs(i: T) -> T {\n     if is_negative(i) { -i } else { i }\n }\n \n-#[cfg(stage0)]\n-impl T: Ord {\n-    pure fn lt(&&other: T) -> bool { return self < other; }\n-    pure fn le(&&other: T) -> bool { return self <= other; }\n-    pure fn ge(&&other: T) -> bool { return self >= other; }\n-    pure fn gt(&&other: T) -> bool { return self > other; }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl T : Ord {\n     pure fn lt(other: &T) -> bool { return self < (*other); }\n     pure fn le(other: &T) -> bool { return self <= (*other); }\n     pure fn ge(other: &T) -> bool { return self >= (*other); }\n     pure fn gt(other: &T) -> bool { return self > (*other); }\n }\n \n-#[cfg(stage0)]\n-impl T: Eq {\n-    pure fn eq(&&other: T) -> bool { return self == other; }\n-    pure fn ne(&&other: T) -> bool { return self != other; }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl T : Eq {\n     pure fn eq(other: &T) -> bool { return self == (*other); }\n     pure fn ne(other: &T) -> bool { return self != (*other); }"}, {"sha": "7c08e508d51e411d3d4b6b2ff66af808890a9a58", "filename": "src/libcore/io.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -329,18 +329,6 @@ enum FileFlag { Append, Create, Truncate, NoFlag, }\n // What type of writer are we?\n enum WriterType { Screen, File }\n \n-#[cfg(stage0)]\n-impl WriterType: Eq {\n-    pure fn eq(&&other: WriterType) -> bool {\n-        match (self, other) {\n-            (Screen, Screen) | (File, File) => true,\n-            (Screen, _) | (File, _) => false\n-        }\n-    }\n-    pure fn ne(&&other: WriterType) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl WriterType : Eq {\n     pure fn eq(other: &WriterType) -> bool {\n         match (self, (*other)) {"}, {"sha": "28f7d21f57437f925e9315e5f5dafc3c37fef5d1", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -20,66 +20,26 @@ trait Owned {\n     // Empty.\n }\n \n-#[cfg(stage0)]\n-#[lang=\"add\"]\n-trait Add<RHS,Result> {\n-    pure fn add(rhs: RHS) -> Result;\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n #[lang=\"add\"]\n trait Add<RHS,Result> {\n     pure fn add(rhs: &RHS) -> Result;\n }\n \n-#[cfg(stage0)]\n-#[lang=\"sub\"]\n-trait Sub<RHS,Result> {\n-    pure fn sub(rhs: RHS) -> Result;\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n #[lang=\"sub\"]\n trait Sub<RHS,Result> {\n     pure fn sub(rhs: &RHS) -> Result;\n }\n \n-#[cfg(stage0)]\n-#[lang=\"mul\"]\n-trait Mul<RHS,Result> {\n-    pure fn mul(rhs: RHS) -> Result;\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n #[lang=\"mul\"]\n trait Mul<RHS,Result> {\n     pure fn mul(rhs: &RHS) -> Result;\n }\n \n-#[cfg(stage0)]\n-#[lang=\"div\"]\n-trait Div<RHS,Result> {\n-    pure fn div(rhs: RHS) -> Result;\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n #[lang=\"div\"]\n trait Div<RHS,Result> {\n     pure fn div(rhs: &RHS) -> Result;\n }\n \n-#[cfg(stage0)]\n-#[lang=\"modulo\"]\n-trait Modulo<RHS,Result> {\n-    pure fn modulo(rhs: RHS) -> Result;\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n #[lang=\"modulo\"]\n trait Modulo<RHS,Result> {\n     pure fn modulo(rhs: &RHS) -> Result;\n@@ -90,66 +50,26 @@ trait Neg<Result> {\n     pure fn neg() -> Result;\n }\n \n-#[cfg(stage0)]\n-#[lang=\"bitand\"]\n-trait BitAnd<RHS,Result> {\n-    pure fn bitand(rhs: RHS) -> Result;\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n #[lang=\"bitand\"]\n trait BitAnd<RHS,Result> {\n     pure fn bitand(rhs: &RHS) -> Result;\n }\n \n-#[cfg(stage0)]\n-#[lang=\"bitor\"]\n-trait BitOr<RHS,Result> {\n-    pure fn bitor(rhs: RHS) -> Result;\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n #[lang=\"bitor\"]\n trait BitOr<RHS,Result> {\n     pure fn bitor(rhs: &RHS) -> Result;\n }\n \n-#[cfg(stage0)]\n-#[lang=\"bitxor\"]\n-trait BitXor<RHS,Result> {\n-    pure fn bitxor(rhs: RHS) -> Result;\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n #[lang=\"bitxor\"]\n trait BitXor<RHS,Result> {\n     pure fn bitxor(rhs: &RHS) -> Result;\n }\n \n-#[cfg(stage0)]\n-#[lang=\"shl\"]\n-trait Shl<RHS,Result> {\n-    pure fn shl(rhs: RHS) -> Result;\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n #[lang=\"shl\"]\n trait Shl<RHS,Result> {\n     pure fn shl(rhs: &RHS) -> Result;\n }\n \n-#[cfg(stage0)]\n-#[lang=\"shr\"]\n-trait Shr<RHS,Result> {\n-    pure fn shr(rhs: RHS) -> Result;\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n #[lang=\"shr\"]\n trait Shr<RHS,Result> {\n     pure fn shr(rhs: &RHS) -> Result;"}, {"sha": "6ab9a86d8f3d49772c101183f806dccf67b577fd", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -255,28 +255,6 @@ impl<T: Copy> Option<T> {\n     pure fn while_some(blk: fn(+v: T) -> Option<T>) { while_some(self, blk) }\n }\n \n-#[cfg(stage0)]\n-impl<T: Eq> Option<T> : Eq {\n-    pure fn eq(&&other: Option<T>) -> bool {\n-        match self {\n-            None => {\n-                match other {\n-                    None => true,\n-                    Some(_) => false\n-                }\n-            }\n-            Some(self_contents) => {\n-                match other {\n-                    None => false,\n-                    Some(other_contents) => self_contents.eq(other_contents)\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: Option<T>) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T: Eq> Option<T> : Eq {\n     pure fn eq(other: &Option<T>) -> bool {\n         match self {"}, {"sha": "ab847702d68aec916919da9d49ea8f77b63fc548", "filename": "src/libcore/path.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -70,16 +70,6 @@ impl PosixPath : ToStr {\n     }\n }\n \n-#[cfg(stage0)]\n-impl PosixPath : Eq {\n-    pure fn eq(&&other: PosixPath) -> bool {\n-        return self.is_absolute == other.is_absolute &&\n-            self.components == other.components;\n-    }\n-    pure fn ne(&&other: PosixPath) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl PosixPath : Eq {\n     pure fn eq(other: &PosixPath) -> bool {\n         return self.is_absolute == (*other).is_absolute &&\n@@ -88,18 +78,6 @@ impl PosixPath : Eq {\n     pure fn ne(other: &PosixPath) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl WindowsPath : Eq {\n-    pure fn eq(&&other: WindowsPath) -> bool {\n-        return self.host == other.host &&\n-            self.device == other.device &&\n-            self.is_absolute == other.is_absolute &&\n-            self.components == other.components;\n-    }\n-    pure fn ne(&&other: WindowsPath) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl WindowsPath : Eq {\n     pure fn eq(other: &WindowsPath) -> bool {\n         return self.host == (*other).host &&"}, {"sha": "e213ce033d034e7b4de12043e8f14f39c1faed23", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -116,15 +116,6 @@ enum State {\n     Terminated\n }\n \n-#[cfg(stage0)]\n-impl State: Eq {\n-    pure fn eq(&&other: State) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: State) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl State : Eq {\n     pure fn eq(other: &State) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "7a31f42d8c4f3acc17e8db73e7ea57f76e2111b9", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -205,17 +205,6 @@ impl<T> *T: Ptr {\n }\n \n // Equality for pointers\n-#[cfg(stage0)]\n-impl<T> *const T : Eq {\n-    pure fn eq(&&other: *const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&self);\n-        let b: uint = cast::reinterpret_cast(&other);\n-        return a == b;\n-    }\n-    pure fn ne(&&other: *const T) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T> *const T : Eq {\n     pure fn eq(other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&self);\n@@ -226,31 +215,6 @@ impl<T> *const T : Eq {\n }\n \n // Comparison for pointers\n-#[cfg(stage0)]\n-impl<T> *const T : Ord {\n-    pure fn lt(&&other: *const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&self);\n-        let b: uint = cast::reinterpret_cast(&other);\n-        return a < b;\n-    }\n-    pure fn le(&&other: *const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&self);\n-        let b: uint = cast::reinterpret_cast(&other);\n-        return a <= b;\n-    }\n-    pure fn ge(&&other: *const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&self);\n-        let b: uint = cast::reinterpret_cast(&other);\n-        return a >= b;\n-    }\n-    pure fn gt(&&other: *const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&self);\n-        let b: uint = cast::reinterpret_cast(&other);\n-        return a > b;\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T> *const T : Ord {\n     pure fn lt(other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&self);\n@@ -275,28 +239,12 @@ impl<T> *const T : Ord {\n }\n \n // Equality for region pointers\n-#[cfg(stage0)]\n-impl<T:Eq> &const T : Eq {\n-    pure fn eq(&&other: &const T) -> bool { return *self == *other; }\n-    pure fn ne(&&other: &const T) -> bool { return *self != *other; }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T:Eq> &const T : Eq {\n     pure fn eq(other: & &const T) -> bool { return *self == *(*other); }\n     pure fn ne(other: & &const T) -> bool { return *self != *(*other); }\n }\n \n // Comparison for region pointers\n-#[cfg(stage0)]\n-impl<T:Ord> &const T : Ord {\n-    pure fn lt(&&other: &const T) -> bool { *self < *other }\n-    pure fn le(&&other: &const T) -> bool { *self <= *other }\n-    pure fn ge(&&other: &const T) -> bool { *self >= *other }\n-    pure fn gt(&&other: &const T) -> bool { *self > *other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T:Ord> &const T : Ord {\n     pure fn lt(other: & &const T) -> bool { *self < *(*other) }\n     pure fn le(other: & &const T) -> bool { *self <= *(*other) }"}, {"sha": "30b43dd7f849ab6ab95561f550956ff3d16395a5", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -510,15 +510,6 @@ enum EnumVisitState {\n     Degenerate      // This is a degenerate enum (exactly 1 variant)\n }\n \n-#[cfg(stage0)]\n-impl EnumVisitState : cmp::Eq {\n-    pure fn eq(&&other: EnumVisitState) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: EnumVisitState) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl EnumVisitState : cmp::Eq {\n     pure fn eq(other: &EnumVisitState) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "205d375e9db8829d2d48242637b319a33105ea8d", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -354,28 +354,6 @@ fn unwrap_err<T, U>(+res: Result<T, U>) -> U {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T:Eq,U:Eq> Result<T,U> : Eq {\n-    pure fn eq(&&other: Result<T,U>) -> bool {\n-        match self {\n-            Ok(e0a) => {\n-                match other {\n-                    Ok(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            Err(e0a) => {\n-                match other {\n-                    Err(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: Result<T,U>) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T:Eq,U:Eq> Result<T,U> : Eq {\n     pure fn eq(other: &Result<T,U>) -> bool {\n         match self {"}, {"sha": "737cd4d9d50502a94ba0406c918153f867a2a013", "filename": "src/libcore/str.rs", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -804,17 +804,6 @@ pure fn gt(a: &str, b: &str) -> bool {\n     !le(a, b)\n }\n \n-#[cfg(stage0)]\n-impl &str: Eq {\n-    #[inline(always)]\n-    pure fn eq(&&other: &str) -> bool {\n-        eq_slice(self, other)\n-    }\n-    #[inline(always)]\n-    pure fn ne(&&other: &str) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl &str : Eq {\n     #[inline(always)]\n     pure fn eq(other: & &str) -> bool {\n@@ -824,17 +813,6 @@ impl &str : Eq {\n     pure fn ne(other: & &str) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl ~str: Eq {\n-    #[inline(always)]\n-    pure fn eq(&&other: ~str) -> bool {\n-        eq_slice(self, other)\n-    }\n-    #[inline(always)]\n-    pure fn ne(&&other: ~str) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ~str : Eq {\n     #[inline(always)]\n     pure fn eq(other: &~str) -> bool {\n@@ -844,17 +822,6 @@ impl ~str : Eq {\n     pure fn ne(other: &~str) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl @str: Eq {\n-    #[inline(always)]\n-    pure fn eq(&&other: @str) -> bool {\n-        eq_slice(self, other)\n-    }\n-    #[inline(always)]\n-    pure fn ne(&&other: @str) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl @str : Eq {\n     #[inline(always)]\n     pure fn eq(other: &@str) -> bool {\n@@ -864,19 +831,6 @@ impl @str : Eq {\n     pure fn ne(other: &@str) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl ~str : Ord {\n-    #[inline(always)]\n-    pure fn lt(&&other: ~str) -> bool { lt(self, other) }\n-    #[inline(always)]\n-    pure fn le(&&other: ~str) -> bool { le(self, other) }\n-    #[inline(always)]\n-    pure fn ge(&&other: ~str) -> bool { ge(self, other) }\n-    #[inline(always)]\n-    pure fn gt(&&other: ~str) -> bool { gt(self, other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ~str : Ord {\n     #[inline(always)]\n     pure fn lt(other: &~str) -> bool { lt(self, (*other)) }\n@@ -888,19 +842,6 @@ impl ~str : Ord {\n     pure fn gt(other: &~str) -> bool { gt(self, (*other)) }\n }\n \n-#[cfg(stage0)]\n-impl &str : Ord {\n-    #[inline(always)]\n-    pure fn lt(&&other: &str) -> bool { lt(self, other) }\n-    #[inline(always)]\n-    pure fn le(&&other: &str) -> bool { le(self, other) }\n-    #[inline(always)]\n-    pure fn ge(&&other: &str) -> bool { ge(self, other) }\n-    #[inline(always)]\n-    pure fn gt(&&other: &str) -> bool { gt(self, other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl &str : Ord {\n     #[inline(always)]\n     pure fn lt(other: & &str) -> bool { lt(self, (*other)) }\n@@ -912,19 +853,6 @@ impl &str : Ord {\n     pure fn gt(other: & &str) -> bool { gt(self, (*other)) }\n }\n \n-#[cfg(stage0)]\n-impl @str : Ord {\n-    #[inline(always)]\n-    pure fn lt(&&other: @str) -> bool { lt(self, other) }\n-    #[inline(always)]\n-    pure fn le(&&other: @str) -> bool { le(self, other) }\n-    #[inline(always)]\n-    pure fn ge(&&other: @str) -> bool { ge(self, other) }\n-    #[inline(always)]\n-    pure fn gt(&&other: @str) -> bool { gt(self, other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl @str : Ord {\n     #[inline(always)]\n     pure fn lt(other: &@str) -> bool { lt(self, (*other)) }\n@@ -2244,15 +2172,6 @@ impl ~str: UniqueStr {\n #[cfg(notest)]\n mod traits {\n     #[legacy_exports];\n-    #[cfg(stage0)]\n-    impl ~str: Add<&str,~str> {\n-        #[inline(always)]\n-        pure fn add(rhs: &str) -> ~str {\n-            append(copy self, rhs)\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     impl ~str : Add<&str,~str> {\n         #[inline(always)]\n         pure fn add(rhs: & &str) -> ~str {"}, {"sha": "9e2949c37effd902dd0928e50dbf6313621f8a88", "filename": "src/libcore/task.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -83,13 +83,6 @@ enum Task {\n     TaskHandle(task_id)\n }\n \n-#[cfg(stage0)]\n-impl Task : cmp::Eq {\n-    pure fn eq(&&other: Task) -> bool { *self == *other }\n-    pure fn ne(&&other: Task) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Task : cmp::Eq {\n     pure fn eq(other: &Task) -> bool { *self == *(*other) }\n     pure fn ne(other: &Task) -> bool { !self.eq(other) }\n@@ -111,18 +104,6 @@ enum TaskResult {\n     Failure,\n }\n \n-#[cfg(stage0)]\n-impl TaskResult: Eq {\n-    pure fn eq(&&other: TaskResult) -> bool {\n-        match (self, other) {\n-            (Success, Success) | (Failure, Failure) => true,\n-            (Success, _) | (Failure, _) => false\n-        }\n-    }\n-    pure fn ne(&&other: TaskResult) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl TaskResult : Eq {\n     pure fn eq(other: &TaskResult) -> bool {\n         match (self, (*other)) {\n@@ -139,21 +120,6 @@ enum Notification {\n     Exit(Task, TaskResult)\n }\n \n-#[cfg(stage0)]\n-impl Notification : cmp::Eq {\n-    pure fn eq(&&other: Notification) -> bool {\n-        match self {\n-            Exit(e0a, e1a) => {\n-                match other {\n-                    Exit(e0b, e1b) => e0a == e0b && e1a == e1b\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: Notification) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Notification : cmp::Eq {\n     pure fn eq(other: &Notification) -> bool {\n         match self {\n@@ -186,48 +152,6 @@ enum SchedMode {\n     PlatformThread\n }\n \n-#[cfg(stage0)]\n-impl SchedMode : cmp::Eq {\n-    pure fn eq(&&other: SchedMode) -> bool {\n-        match self {\n-            SingleThreaded => {\n-                match other {\n-                    SingleThreaded => true,\n-                    _ => false\n-                }\n-            }\n-            ThreadPerCore => {\n-                match other {\n-                    ThreadPerCore => true,\n-                    _ => false\n-                }\n-            }\n-            ThreadPerTask => {\n-                match other {\n-                    ThreadPerTask => true,\n-                    _ => false\n-                }\n-            }\n-            ManualThreads(e0a) => {\n-                match other {\n-                    ManualThreads(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            PlatformThread => {\n-                match other {\n-                    PlatformThread => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: SchedMode) -> bool {\n-        !self.eq(other)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl SchedMode : cmp::Eq {\n     pure fn eq(other: &SchedMode) -> bool {\n         match self {"}, {"sha": "2fbb88327ed348d1aa0b2b0bfb689ee52d49aaf2", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -6,17 +6,6 @@ use rt::rust_task;\n trait LocalData { }\n impl<T: Owned> @T: LocalData { }\n \n-#[cfg(stage0)]\n-impl LocalData: Eq {\n-    pure fn eq(&&other: LocalData) -> bool unsafe {\n-        let ptr_a: (uint, uint) = cast::reinterpret_cast(&self);\n-        let ptr_b: (uint, uint) = cast::reinterpret_cast(&other);\n-        return ptr_a == ptr_b;\n-    }\n-    pure fn ne(&&other: LocalData) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl LocalData: Eq {\n     pure fn eq(other: &@LocalData) -> bool unsafe {\n         let ptr_a: (uint, uint) = cast::reinterpret_cast(&self);"}, {"sha": "8ec6ed3f0c24b1cece7823c8184d3b4cabd595e2", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -67,25 +67,6 @@ impl<A: Copy, B: Copy> (~[A], ~[B]): ExtendedTupleOps<A,B> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<A: Eq, B: Eq> (A, B): Eq {\n-    pure fn eq(&&other: (A, B)) -> bool {\n-        // XXX: This would be a lot less wordy with ref bindings, but I don't\n-        // trust that they work yet.\n-        match self {\n-            (self_a, self_b) => {\n-                match other {\n-                    (other_a, other_b) => {\n-                        self_a.eq(other_a) && self_b.eq(other_b)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: (A, B)) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<A: Eq, B: Eq> (A, B) : Eq {\n     pure fn eq(other: &(A, B)) -> bool {\n         // XXX: This would be a lot less wordy with ref bindings, but I don't\n@@ -103,28 +84,6 @@ impl<A: Eq, B: Eq> (A, B) : Eq {\n     pure fn ne(other: &(A, B)) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl<A: Ord, B: Ord> (A, B): Ord {\n-    pure fn lt(&&other: (A, B)) -> bool {\n-        match self {\n-            (self_a, self_b) => {\n-                match other {\n-                    (other_a, other_b) => {\n-                        if self_a.lt(other_a) { return true; }\n-                        if other_a.lt(self_a) { return false; }\n-                        if self_b.lt(other_b) { return true; }\n-                        return false;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    pure fn le(&&other: (A, B)) -> bool { !other.lt(self) }\n-    pure fn ge(&&other: (A, B)) -> bool { !self.lt(other) }\n-    pure fn gt(&&other: (A, B)) -> bool { other.lt(self)  }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<A: Ord, B: Ord> (A, B) : Ord {\n     pure fn lt(other: &(A, B)) -> bool {\n         match self {\n@@ -145,27 +104,6 @@ impl<A: Ord, B: Ord> (A, B) : Ord {\n     pure fn gt(other: &(A, B)) -> bool { (*other).lt(&self)  }\n }\n \n-#[cfg(stage0)]\n-impl<A: Eq, B: Eq, C: Eq> (A, B, C): Eq {\n-    pure fn eq(&&other: (A, B, C)) -> bool {\n-        // XXX: This would be a lot less wordy with ref bindings, but I don't\n-        // trust that they work yet.\n-        match self {\n-            (self_a, self_b, self_c) => {\n-                match other {\n-                    (other_a, other_b, other_c) => {\n-                        self_a.eq(other_a) &&\n-                        self_b.eq(other_b) &&\n-                        self_c.eq(other_c)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: (A, B, C)) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<A: Eq, B: Eq, C: Eq> (A, B, C) : Eq {\n     pure fn eq(other: &(A, B, C)) -> bool {\n         // XXX: This would be a lot less wordy with ref bindings, but I don't\n@@ -185,30 +123,6 @@ impl<A: Eq, B: Eq, C: Eq> (A, B, C) : Eq {\n     pure fn ne(other: &(A, B, C)) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl<A: Ord, B: Ord, C: Ord> (A, B, C): Ord {\n-    pure fn lt(&&other: (A, B, C)) -> bool {\n-        match self {\n-            (self_a, self_b, self_c) => {\n-                match other {\n-                    (other_a, other_b, other_c) => {\n-                        if self_a.lt(other_a) { return true; }\n-                        if other_a.lt(self_a) { return false; }\n-                        if self_b.lt(other_b) { return true; }\n-                        if other_b.lt(self_b) { return false; }\n-                        if self_c.lt(other_c) { return true; }\n-                        return false;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    pure fn le(&&other: (A, B, C)) -> bool { !other.lt(self) }\n-    pure fn ge(&&other: (A, B, C)) -> bool { !self.lt(other) }\n-    pure fn gt(&&other: (A, B, C)) -> bool { other.lt(self)  }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<A: Ord, B: Ord, C: Ord> (A, B, C) : Ord {\n     pure fn lt(other: &(A, B, C)) -> bool {\n         match self {"}, {"sha": "8b3a60f4fe35fdfbc72e28771f6b16da3ff4f87d", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -61,29 +61,13 @@ pure fn compl(i: T) -> T {\n     max_value ^ i\n }\n \n-#[cfg(stage0)]\n-impl T: Ord {\n-    pure fn lt(&&other: T) -> bool { self < other }\n-    pure fn le(&&other: T) -> bool { self <= other }\n-    pure fn ge(&&other: T) -> bool { self >= other }\n-    pure fn gt(&&other: T) -> bool { self > other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl T : Ord {\n     pure fn lt(other: &T) -> bool { self < (*other) }\n     pure fn le(other: &T) -> bool { self <= (*other) }\n     pure fn ge(other: &T) -> bool { self >= (*other) }\n     pure fn gt(other: &T) -> bool { self > (*other) }\n }\n \n-#[cfg(stage0)]\n-impl T: Eq {\n-    pure fn eq(&&other: T) -> bool { return self == other; }\n-    pure fn ne(&&other: T) -> bool { return self != other; }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl T : Eq {\n     pure fn eq(other: &T) -> bool { return self == (*other); }\n     pure fn ne(other: &T) -> bool { return self != (*other); }"}, {"sha": "1a752ce0e6c14e9b425c7739ae8f1b8111265f47", "filename": "src/libcore/uniq.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funiq.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -2,27 +2,11 @@\n \n use cmp::{Eq, Ord};\n \n-#[cfg(stage0)]\n-impl<T:Eq> ~const T : Eq {\n-    pure fn eq(&&other: ~const T) -> bool { *self == *other }\n-    pure fn ne(&&other: ~const T) -> bool { *self != *other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T:Eq> ~const T : Eq {\n     pure fn eq(other: &~const T) -> bool { *self == *(*other) }\n     pure fn ne(other: &~const T) -> bool { *self != *(*other) }\n }\n \n-#[cfg(stage0)]\n-impl<T:Ord> ~const T : Ord {\n-    pure fn lt(&&other: ~const T) -> bool { *self < *other }\n-    pure fn le(&&other: ~const T) -> bool { *self <= *other }\n-    pure fn ge(&&other: ~const T) -> bool { *self >= *other }\n-    pure fn gt(&&other: ~const T) -> bool { *self > *other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T:Ord> ~const T : Ord {\n     pure fn lt(other: &~const T) -> bool { *self < *(*other) }\n     pure fn le(other: &~const T) -> bool { *self <= *(*other) }"}, {"sha": "4ccdf12b500b62afdb8b8cba1f79b72f094901c6", "filename": "src/libcore/unit.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funit.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -6,27 +6,11 @@ Functions for the unit type.\n \n use cmp::{Eq, Ord};\n \n-#[cfg(stage0)]\n-impl () : Eq {\n-    pure fn eq(&&_other: ()) -> bool { true }\n-    pure fn ne(&&_other: ()) -> bool { false }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl () : Eq {\n     pure fn eq(_other: &()) -> bool { true }\n     pure fn ne(_other: &()) -> bool { false }\n }\n \n-#[cfg(stage0)]\n-impl () : Ord {\n-    pure fn lt(&&_other: ()) -> bool { false }\n-    pure fn le(&&_other: ()) -> bool { true }\n-    pure fn ge(&&_other: ()) -> bool { true }\n-    pure fn gt(&&_other: ()) -> bool { false }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl () : Ord {\n     pure fn lt(_other: &()) -> bool { false }\n     pure fn le(_other: &()) -> bool { true }"}, {"sha": "d458ac411e358691ee7f52773737c3838fecaf4f", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -1370,47 +1370,20 @@ pure fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n     return true;\n }\n \n-#[cfg(stage0)]\n-impl<T: Eq> &[T]: Eq {\n-    #[inline(always)]\n-    pure fn eq(&&other: &[T]) -> bool { eq(self, other) }\n-    #[inline(always)]\n-    pure fn ne(&&other: &[T]) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T: Eq> &[T] : Eq {\n     #[inline(always)]\n     pure fn eq(other: & &[T]) -> bool { eq(self, (*other)) }\n     #[inline(always)]\n     pure fn ne(other: & &[T]) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl<T: Eq> ~[T]: Eq {\n-    #[inline(always)]\n-    pure fn eq(&&other: ~[T]) -> bool { eq(self, other) }\n-    #[inline(always)]\n-    pure fn ne(&&other: ~[T]) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T: Eq> ~[T] : Eq {\n     #[inline(always)]\n     pure fn eq(other: &~[T]) -> bool { eq(self, (*other)) }\n     #[inline(always)]\n     pure fn ne(other: &~[T]) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl<T: Eq> @[T]: Eq {\n-    #[inline(always)]\n-    pure fn eq(&&other: @[T]) -> bool { eq(self, other) }\n-    #[inline(always)]\n-    pure fn ne(&&other: @[T]) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T: Eq> @[T] : Eq {\n     #[inline(always)]\n     pure fn eq(other: &@[T]) -> bool { eq(self, (*other)) }\n@@ -1439,19 +1412,6 @@ pure fn le<T: Ord>(a: &[T], b: &[T]) -> bool { !lt(b, a) }\n pure fn ge<T: Ord>(a: &[T], b: &[T]) -> bool { !lt(a, b) }\n pure fn gt<T: Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n \n-#[cfg(stage0)]\n-impl<T: Ord> &[T]: Ord {\n-    #[inline(always)]\n-    pure fn lt(&&other: &[T]) -> bool { lt(self, other) }\n-    #[inline(always)]\n-    pure fn le(&&other: &[T]) -> bool { le(self, other) }\n-    #[inline(always)]\n-    pure fn ge(&&other: &[T]) -> bool { ge(self, other) }\n-    #[inline(always)]\n-    pure fn gt(&&other: &[T]) -> bool { gt(self, other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T: Ord> &[T] : Ord {\n     #[inline(always)]\n     pure fn lt(other: & &[T]) -> bool { lt(self, (*other)) }\n@@ -1463,19 +1423,6 @@ impl<T: Ord> &[T] : Ord {\n     pure fn gt(other: & &[T]) -> bool { gt(self, (*other)) }\n }\n \n-#[cfg(stage0)]\n-impl<T: Ord> ~[T]: Ord {\n-    #[inline(always)]\n-    pure fn lt(&&other: ~[T]) -> bool { lt(self, other) }\n-    #[inline(always)]\n-    pure fn le(&&other: ~[T]) -> bool { le(self, other) }\n-    #[inline(always)]\n-    pure fn ge(&&other: ~[T]) -> bool { ge(self, other) }\n-    #[inline(always)]\n-    pure fn gt(&&other: ~[T]) -> bool { gt(self, other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T: Ord> ~[T] : Ord {\n     #[inline(always)]\n     pure fn lt(other: &~[T]) -> bool { lt(self, (*other)) }\n@@ -1487,19 +1434,6 @@ impl<T: Ord> ~[T] : Ord {\n     pure fn gt(other: &~[T]) -> bool { gt(self, (*other)) }\n }\n \n-#[cfg(stage0)]\n-impl<T: Ord> @[T]: Ord {\n-    #[inline(always)]\n-    pure fn lt(&&other: @[T]) -> bool { lt(self, other) }\n-    #[inline(always)]\n-    pure fn le(&&other: @[T]) -> bool { le(self, other) }\n-    #[inline(always)]\n-    pure fn ge(&&other: @[T]) -> bool { ge(self, other) }\n-    #[inline(always)]\n-    pure fn gt(&&other: @[T]) -> bool { gt(self, other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T: Ord> @[T] : Ord {\n     #[inline(always)]\n     pure fn lt(other: &@[T]) -> bool { lt(self, (*other)) }\n@@ -1514,33 +1448,13 @@ impl<T: Ord> @[T] : Ord {\n #[cfg(notest)]\n mod traits {\n     #[legacy_exports];\n-    #[cfg(stage0)]\n-    impl<T: Copy> ~[T]: Add<&[const T],~[T]> {\n-        #[inline(always)]\n-        pure fn add(rhs: &[const T]) -> ~[T] {\n-            append(copy self, rhs)\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     impl<T: Copy> ~[T] : Add<&[const T],~[T]> {\n         #[inline(always)]\n         pure fn add(rhs: & &[const T]) -> ~[T] {\n             append(copy self, (*rhs))\n         }\n     }\n \n-    #[cfg(stage0)]\n-    impl<T: Copy> ~[mut T]: Add<&[const T],~[mut T]> {\n-        #[inline(always)]\n-        pure fn add(rhs: &[const T]) -> ~[mut T] {\n-            append_mut(copy self, rhs)\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     impl<T: Copy> ~[mut T] : Add<&[const T],~[mut T]> {\n         #[inline(always)]\n         pure fn add(rhs: & &[const T]) -> ~[mut T] {"}, {"sha": "17d4b39b01e6419b623fe4599bf93c1eab96f0de", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -240,28 +240,6 @@ mod tests {\n \n     type RecCy = {x: int, y: int, t: Taggy};\n \n-#[cfg(stage0)]\n-    impl Taggy : Eq {\n-        pure fn eq(other: Taggy) -> bool {\n-            match self {\n-              One(a1) => match other {\n-                One(b1) => return a1 == b1,\n-                _ => return false\n-              },\n-              Two(a1, a2) => match other {\n-                Two(b1, b2) => return a1 == b1 && a2 == b2,\n-                _ => return false\n-              },\n-              Three(a1, a2, a3) => match other {\n-                Three(b1, b2, b3) => return a1 == b1 && a2 == b2 && a3 == b3,\n-                _ => return false\n-              }\n-            }\n-        }\n-        pure fn ne(other: Taggy) -> bool { !self.eq(other) }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     impl Taggy : Eq {\n         pure fn eq(other: &Taggy) -> bool {\n             match self {\n@@ -282,31 +260,6 @@ mod tests {\n         pure fn ne(other: &Taggy) -> bool { !self.eq(other) }\n     }\n \n-#[cfg(stage0)]\n-    impl Taggypar<int> : Eq {\n-        //let eq4: EqFn<Taggypar<int>> = |x,y| taggypareq::<int>(x, y);\n-        pure fn eq(other: Taggypar<int>) -> bool {\n-                  match self {\n-                    Onepar::<int>(a1) => match other {\n-                      Onepar::<int>(b1) => return a1 == b1,\n-                      _ => return false\n-                    },\n-                    Twopar::<int>(a1, a2) => match other {\n-                      Twopar::<int>(b1, b2) => return a1 == b1 && a2 == b2,\n-                      _ => return false\n-                    },\n-                    Threepar::<int>(a1, a2, a3) => match other {\n-                      Threepar::<int>(b1, b2, b3) => {\n-                          return a1 == b1 && a2 == b2 && a3 == b3\n-                      }\n-                      _ => return false\n-                    }\n-                  }\n-        }\n-        pure fn ne(other: Taggypar<int>) -> bool { !self.eq(other) }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     impl Taggypar<int> : Eq {\n         //let eq4: EqFn<Taggypar<int>> = |x,y| taggypareq::<int>(x, y);\n         pure fn eq(other: &Taggypar<int>) -> bool {\n@@ -330,15 +283,6 @@ mod tests {\n         pure fn ne(other: &Taggypar<int>) -> bool { !self.eq(other) }\n     }\n \n-#[cfg(stage0)]\n-    impl RecCy : Eq {\n-        pure fn eq(other: RecCy) -> bool {\n-          return self.x == other.x && self.y == other.y && self.t == other.t;\n-        }\n-        pure fn ne(other: RecCy) -> bool { !self.eq(other) }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     impl RecCy : Eq {\n         pure fn eq(other: &RecCy) -> bool {\n           return self.x == (*other).x && self.y == (*other).y &&"}, {"sha": "f8b86d800613f2f931826e056398f96ed48dcbda", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -107,28 +107,6 @@ fn mkname(nm: &str) -> Name {\n         } else { Long(unm) };\n }\n \n-#[cfg(stage0)]\n-impl Name : Eq {\n-    pure fn eq(&&other: Name) -> bool {\n-        match self {\n-            Long(e0a) => {\n-                match other {\n-                    Long(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            Short(e0a) => {\n-                match other {\n-                    Short(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: Name) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Name : Eq {\n     pure fn eq(other: &Name) -> bool {\n         match self {\n@@ -149,15 +127,6 @@ impl Name : Eq {\n     pure fn ne(other: &Name) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl Occur : Eq {\n-    pure fn eq(&&other: Occur) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: Occur) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Occur : Eq {\n     pure fn eq(other: &Occur) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -478,15 +447,6 @@ enum FailType {\n     UnexpectedArgument_,\n }\n \n-#[cfg(stage0)]\n-impl FailType : Eq {\n-    pure fn eq(&&other: FailType) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: FailType) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl FailType : Eq {\n     pure fn eq(other: &FailType) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "0f7bec6344a638d5b0ea6ae468c61b9d6fee16af", "filename": "src/libstd/json.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -676,17 +676,6 @@ pure fn lt(value0: Json, value1: Json) -> bool {\n     }\n }\n \n-#[cfg(stage0)]\n-impl Error : Eq {\n-    pure fn eq(&&other: Error) -> bool {\n-        self.line == other.line &&\n-        self.col == other.col &&\n-        self.msg == other.msg\n-    }\n-    pure fn ne(&&other: Error) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Error : Eq {\n     pure fn eq(other: &Error) -> bool {\n         self.line == (*other).line &&\n@@ -696,27 +685,11 @@ impl Error : Eq {\n     pure fn ne(other: &Error) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl Json : Eq {\n-    pure fn eq(&&other: Json) -> bool { eq(self, other) }\n-    pure fn ne(&&other: Json) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Json : Eq {\n     pure fn eq(other: &Json) -> bool { eq(self, (*other)) }\n     pure fn ne(other: &Json) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl Json : Ord {\n-    pure fn lt(&&other: Json) -> bool { lt(self, other) }\n-    pure fn le(&&other: Json) -> bool { !other.lt(self) }\n-    pure fn ge(&&other: Json) -> bool { !self.lt(other) }\n-    pure fn gt(&&other: Json) -> bool { other.lt(self)  }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Json : Ord {\n     pure fn lt(other: &Json) -> bool { lt(self, (*other))  }\n     pure fn le(other: &Json) -> bool { !(*other).lt(&self) }"}, {"sha": "45eafb3d018ad8533946f8d53dfc7fa3d18474f3", "filename": "src/libstd/list.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -148,28 +148,6 @@ fn each<T>(l: @List<T>, f: fn(T) -> bool) {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T:Eq> List<T> : Eq {\n-    pure fn eq(&&other: List<T>) -> bool {\n-        match self {\n-            Cons(e0a, e1a) => {\n-                match other {\n-                    Cons(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            Nil => {\n-                match other {\n-                    Nil => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: List<T>) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T:Eq> List<T> : Eq {\n     pure fn eq(other: &List<T>) -> bool {\n         match self {"}, {"sha": "74c603e29e91b2db568885704e32eb2f5f7471d5", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -317,15 +317,6 @@ fn userinfo_to_str(+userinfo: UserInfo) -> ~str {\n     }\n }\n \n-#[cfg(stage0)]\n-impl UserInfo : Eq {\n-    pure fn eq(&&other: UserInfo) -> bool {\n-        self.user == other.user && self.pass == other.pass\n-    }\n-    pure fn ne(&&other: UserInfo) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl UserInfo : Eq {\n     pure fn eq(other: &UserInfo) -> bool {\n         self.user == (*other).user && self.pass == (*other).pass\n@@ -386,22 +377,6 @@ enum Input {\n     Unreserved // all other legal characters\n }\n \n-#[cfg(stage0)]\n-impl Input: Eq {\n-    pure fn eq(&&other: Input) -> bool {\n-        match (self, other) {\n-            (Digit, Digit) => true,\n-            (Hex, Hex) => true,\n-            (Unreserved, Unreserved) => true,\n-            (Digit, _) => false,\n-            (Hex, _) => false,\n-            (Unreserved, _) => false\n-        }\n-    }\n-    pure fn ne(&&other: Input) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Input : Eq {\n     pure fn eq(other: &Input) -> bool {\n         match (self, (*other)) {\n@@ -744,24 +719,6 @@ impl Url: to_str::ToStr {\n     }\n }\n \n-#[cfg(stage0)]\n-impl Url: Eq {\n-    pure fn eq(&&other: Url) -> bool {\n-        self.scheme == other.scheme\n-            && self.user == other.user\n-            && self.host == other.host\n-            && self.port == other.port\n-            && self.path == other.path\n-            && self.query == other.query\n-            && self.fragment == other.fragment\n-    }\n-\n-    pure fn ne(&&other: Url) -> bool {\n-        !self.eq(other)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Url : Eq {\n     pure fn eq(other: &Url) -> bool {\n         self.scheme == (*other).scheme"}, {"sha": "51c0ad385ce16f965055ed1c2e70a954bd059113", "filename": "src/libstd/test.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -96,15 +96,6 @@ fn parse_opts(args: &[~str]) -> OptRes {\n \n enum TestResult { TrOk, TrFailed, TrIgnored, }\n \n-#[cfg(stage0)]\n-impl TestResult : Eq {\n-    pure fn eq(&&other: TestResult) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: TestResult) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl TestResult : Eq {\n     pure fn eq(other: &TestResult) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "64f65d15a93ecca92c9d0514fa2495dfa2f65a27", "filename": "src/libstd/time.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -37,15 +37,6 @@ extern mod rustrt {\n /// A record specifying a time value in seconds and nanoseconds.\n type Timespec = {sec: i64, nsec: i32};\n \n-#[cfg(stage0)]\n-impl Timespec : Eq {\n-    pure fn eq(&&other: Timespec) -> bool {\n-        self.sec == other.sec && self.nsec == other.nsec\n-    }\n-    pure fn ne(&&other: Timespec) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Timespec : Eq {\n     pure fn eq(other: &Timespec) -> bool {\n         self.sec == (*other).sec && self.nsec == (*other).nsec\n@@ -101,26 +92,6 @@ type Tm_ = {\n     tm_nsec: i32, // nanoseconds\n };\n \n-#[cfg(stage0)]\n-impl Tm_ : Eq {\n-    pure fn eq(&&other: Tm_) -> bool {\n-        self.tm_sec == other.tm_sec &&\n-        self.tm_min == other.tm_min &&\n-        self.tm_hour == other.tm_hour &&\n-        self.tm_mday == other.tm_mday &&\n-        self.tm_mon == other.tm_mon &&\n-        self.tm_year == other.tm_year &&\n-        self.tm_wday == other.tm_wday &&\n-        self.tm_yday == other.tm_yday &&\n-        self.tm_isdst == other.tm_isdst &&\n-        self.tm_gmtoff == other.tm_gmtoff &&\n-        self.tm_zone == other.tm_zone &&\n-        self.tm_nsec == other.tm_nsec\n-    }\n-    pure fn ne(&&other: Tm_) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Tm_ : Eq {\n     pure fn eq(other: &Tm_) -> bool {\n         self.tm_sec == (*other).tm_sec &&\n@@ -143,13 +114,6 @@ enum Tm {\n     Tm_(Tm_)\n }\n \n-#[cfg(stage0)]\n-impl Tm : Eq {\n-    pure fn eq(&&other: Tm) -> bool { *self == *other }\n-    pure fn ne(&&other: Tm) -> bool { *self != *other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Tm : Eq {\n     pure fn eq(other: &Tm) -> bool { *self == *(*other) }\n     pure fn ne(other: &Tm) -> bool { *self != *(*other) }"}, {"sha": "e9f47e14dbbedb3989bc891ede2804f1b10a9897", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 581, "changes": 581, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -81,15 +81,6 @@ type node_id = int;\n #[auto_serialize]\n type def_id = {crate: crate_num, node: node_id};\n \n-#[cfg(stage0)]\n-impl def_id: cmp::Eq {\n-    pure fn eq(&&other: def_id) -> bool {\n-        self.crate == other.crate && self.node == other.node\n-    }\n-    pure fn ne(&&other: def_id) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl def_id : cmp::Eq {\n     pure fn eq(other: &def_id) -> bool {\n         self.crate == (*other).crate && self.node == (*other).node\n@@ -138,131 +129,6 @@ enum def {\n     def_label(node_id)\n }\n \n-#[cfg(stage0)]\n-impl def : cmp::Eq {\n-    pure fn eq(&&other: def) -> bool {\n-        match self {\n-            def_fn(e0a, e1a) => {\n-                match other {\n-                    def_fn(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_static_method(e0a, e1a) => {\n-                match other {\n-                    def_static_method(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_self(e0a) => {\n-                match other {\n-                    def_self(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_mod(e0a) => {\n-                match other {\n-                    def_mod(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_foreign_mod(e0a) => {\n-                match other {\n-                    def_foreign_mod(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_const(e0a) => {\n-                match other {\n-                    def_const(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_arg(e0a, e1a) => {\n-                match other {\n-                    def_arg(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_local(e0a, e1a) => {\n-                match other {\n-                    def_local(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_variant(e0a, e1a) => {\n-                match other {\n-                    def_variant(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_ty(e0a) => {\n-                match other {\n-                    def_ty(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_prim_ty(e0a) => {\n-                match other {\n-                    def_prim_ty(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_ty_param(e0a, e1a) => {\n-                match other {\n-                    def_ty_param(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_binding(e0a, e1a) => {\n-                match other {\n-                    def_binding(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_use(e0a) => {\n-                match other {\n-                    def_use(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_upvar(e0a, e1a, e2a, e3a) => {\n-                match other {\n-                    def_upvar(e0b, e1b, e2b, e3b) =>\n-                        e0a == e0b && e1a == e1b && e2a == e2b && e3a == e3b,\n-                    _ => false\n-                }\n-            }\n-            def_class(e0a, e1a) => {\n-                match other {\n-                    def_class(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_typaram_binder(e0a) => {\n-                match other {\n-                    def_typaram_binder(e1a) => e0a == e1a,\n-                    _ => false\n-                }\n-            }\n-            def_region(e0a) => {\n-                match other {\n-                    def_region(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_label(e0a) => {\n-                match other {\n-                    def_label(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: def) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl def : cmp::Eq {\n     pure fn eq(other: &def) -> bool {\n         match self {\n@@ -464,40 +330,6 @@ impl binding_mode : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl binding_mode : cmp::Eq {\n-    pure fn eq(&&other: binding_mode) -> bool {\n-        match self {\n-            bind_by_value => {\n-                match other {\n-                    bind_by_value => true,\n-                    _ => false\n-                }\n-            }\n-            bind_by_move => {\n-                match other {\n-                    bind_by_move => true,\n-                    _ => false\n-                }\n-            }\n-            bind_by_ref(e0a) => {\n-                match other {\n-                    bind_by_ref(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            bind_by_implicit_ref => {\n-                match other {\n-                    bind_by_implicit_ref => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: binding_mode) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl binding_mode : cmp::Eq {\n     pure fn eq(other: &binding_mode) -> bool {\n         match self {\n@@ -562,15 +394,6 @@ impl mutability : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl mutability: cmp::Eq {\n-    pure fn eq(&&other: mutability) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: mutability) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl mutability : cmp::Eq {\n     pure fn eq(other: &mutability) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -586,15 +409,6 @@ enum proto {\n     proto_block,   // fn&\n }\n \n-#[cfg(stage0)]\n-impl proto : cmp::Eq {\n-    pure fn eq(&&other: proto) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: proto) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl proto : cmp::Eq {\n     pure fn eq(other: &proto) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -649,15 +463,6 @@ enum binop {\n     gt,\n }\n \n-#[cfg(stage0)]\n-impl binop : cmp::Eq {\n-    pure fn eq(&&other: binop) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: binop) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl binop : cmp::Eq {\n     pure fn eq(other: &binop) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -674,48 +479,6 @@ enum unop {\n     neg\n }\n \n-#[cfg(stage0)]\n-impl unop : cmp::Eq {\n-    pure fn eq(&&other: unop) -> bool {\n-        match self {\n-            box(e0a) => {\n-                match other {\n-                    box(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            uniq(e0a) => {\n-                match other {\n-                    uniq(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            deref => {\n-                match other {\n-                    deref => true,\n-                    _ => false\n-                }\n-            }\n-            not => {\n-                match other {\n-                    not => true,\n-                    _ => false\n-                }\n-            }\n-            neg => {\n-                match other {\n-                    neg => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: unop) -> bool {\n-        !self.eq(other)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl unop : cmp::Eq {\n     pure fn eq(other: &unop) -> bool {\n         match self {\n@@ -776,28 +539,6 @@ impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n-    pure fn eq(&&other: inferable<T>) -> bool {\n-        match self {\n-            expl(e0a) => {\n-                match other {\n-                    expl(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            infer(e0a) => {\n-                match other {\n-                    infer(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: inferable<T>) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n     pure fn eq(other: &inferable<T>) -> bool {\n         match self {\n@@ -829,15 +570,6 @@ impl rmode : to_bytes::IterBytes {\n }\n \n \n-#[cfg(stage0)]\n-impl rmode : cmp::Eq {\n-    pure fn eq(&&other: rmode) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: rmode) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl rmode : cmp::Eq {\n     pure fn eq(other: &rmode) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -866,28 +598,6 @@ enum stmt_ {\n #[auto_serialize]\n enum init_op { init_assign, init_move, }\n \n-#[cfg(stage0)]\n-impl init_op : cmp::Eq {\n-    pure fn eq(&&other: init_op) -> bool {\n-        match self {\n-            init_assign => {\n-                match other {\n-                    init_assign => true,\n-                    _ => false\n-                }\n-            }\n-            init_move => {\n-                match other {\n-                    init_move => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: init_op) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl init_op : cmp::Eq {\n     pure fn eq(other: &init_op) -> bool {\n         match self {\n@@ -938,20 +648,6 @@ type field = spanned<field_>;\n #[auto_serialize]\n enum blk_check_mode { default_blk, unsafe_blk, }\n \n-#[cfg(stage0)]\n-impl blk_check_mode : cmp::Eq {\n-    pure fn eq(&&other: blk_check_mode) -> bool {\n-        match (self, other) {\n-            (default_blk, default_blk) => true,\n-            (unsafe_blk, unsafe_blk) => true,\n-            (default_blk, _) => false,\n-            (unsafe_blk, _) => false,\n-        }\n-    }\n-    pure fn ne(&&other: blk_check_mode) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl blk_check_mode : cmp::Eq {\n     pure fn eq(other: &blk_check_mode) -> bool {\n         match (self, (*other)) {\n@@ -1171,36 +867,6 @@ enum lit_ {\n     lit_bool(bool),\n }\n \n-#[cfg(stage0)]\n-impl ast::lit_: cmp::Eq {\n-    pure fn eq(&&other: ast::lit_) -> bool {\n-        match (self, other) {\n-            (lit_str(a), lit_str(b)) => a == b,\n-            (lit_int(val_a, ty_a), lit_int(val_b, ty_b)) => {\n-                val_a == val_b && ty_a == ty_b\n-            }\n-            (lit_uint(val_a, ty_a), lit_uint(val_b, ty_b)) => {\n-                val_a == val_b && ty_a == ty_b\n-            }\n-            (lit_int_unsuffixed(a), lit_int_unsuffixed(b)) => a == b,\n-            (lit_float(val_a, ty_a), lit_float(val_b, ty_b)) => {\n-                val_a == val_b && ty_a == ty_b\n-            }\n-            (lit_nil, lit_nil) => true,\n-            (lit_bool(a), lit_bool(b)) => a == b,\n-            (lit_str(_), _) => false,\n-            (lit_int(*), _) => false,\n-            (lit_uint(*), _) => false,\n-            (lit_int_unsuffixed(*), _) => false,\n-            (lit_float(*), _) => false,\n-            (lit_nil, _) => false,\n-            (lit_bool(_), _) => false\n-        }\n-    }\n-    pure fn ne(&&other: ast::lit_) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ast::lit_: cmp::Eq {\n     pure fn eq(other: &ast::lit_) -> bool {\n         match (self, *other) {\n@@ -1263,28 +929,6 @@ impl int_ty : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl int_ty: cmp::Eq {\n-    pure fn eq(&&other: int_ty) -> bool {\n-        match (self, other) {\n-            (ty_i, ty_i) => true,\n-            (ty_char, ty_char) => true,\n-            (ty_i8, ty_i8) => true,\n-            (ty_i16, ty_i16) => true,\n-            (ty_i32, ty_i32) => true,\n-            (ty_i64, ty_i64) => true,\n-            (ty_i, _) => false,\n-            (ty_char, _) => false,\n-            (ty_i8, _) => false,\n-            (ty_i16, _) => false,\n-            (ty_i32, _) => false,\n-            (ty_i64, _) => false,\n-        }\n-    }\n-    pure fn ne(&&other: int_ty) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl int_ty : cmp::Eq {\n     pure fn eq(other: &int_ty) -> bool {\n         match (self, (*other)) {\n@@ -1314,26 +958,6 @@ impl uint_ty : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl uint_ty: cmp::Eq {\n-    pure fn eq(&&other: uint_ty) -> bool {\n-        match (self, other) {\n-            (ty_u, ty_u) => true,\n-            (ty_u8, ty_u8) => true,\n-            (ty_u16, ty_u16) => true,\n-            (ty_u32, ty_u32) => true,\n-            (ty_u64, ty_u64) => true,\n-            (ty_u, _) => false,\n-            (ty_u8, _) => false,\n-            (ty_u16, _) => false,\n-            (ty_u32, _) => false,\n-            (ty_u64, _) => false\n-        }\n-    }\n-    pure fn ne(&&other: uint_ty) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl uint_ty : cmp::Eq {\n     pure fn eq(other: &uint_ty) -> bool {\n         match (self, (*other)) {\n@@ -1360,18 +984,6 @@ impl float_ty : to_bytes::IterBytes {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n-#[cfg(stage0)]\n-impl float_ty: cmp::Eq {\n-    pure fn eq(&&other: float_ty) -> bool {\n-        match (self, other) {\n-            (ty_f, ty_f) | (ty_f32, ty_f32) | (ty_f64, ty_f64) => true,\n-            (ty_f, _) | (ty_f32, _) | (ty_f64, _) => false\n-        }\n-    }\n-    pure fn ne(&&other: float_ty) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl float_ty : cmp::Eq {\n     pure fn eq(other: &float_ty) -> bool {\n         match (self, (*other)) {\n@@ -1395,46 +1007,6 @@ enum prim_ty {\n     ty_bool,\n }\n \n-#[cfg(stage0)]\n-impl prim_ty : cmp::Eq {\n-    pure fn eq(&&other: prim_ty) -> bool {\n-        match self {\n-            ty_int(e0a) => {\n-                match other {\n-                    ty_int(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_uint(e0a) => {\n-                match other {\n-                    ty_uint(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_float(e0a) => {\n-                match other {\n-                    ty_float(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_str => {\n-                match other {\n-                    ty_str => true,\n-                    _ => false\n-                }\n-            }\n-            ty_bool => {\n-                match other {\n-                    ty_bool => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: prim_ty) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl prim_ty : cmp::Eq {\n     pure fn eq(other: &prim_ty) -> bool {\n         match self {\n@@ -1507,17 +1079,6 @@ enum ty_ {\n \n // Equality and byte-iter (hashing) can be quite approximate for AST types.\n // since we only care about this for normalizing them to \"real\" types.\n-#[cfg(stage0)]\n-impl ty : cmp::Eq {\n-    pure fn eq(&&other: ty) -> bool {\n-        ptr::addr_of(self) == ptr::addr_of(other)\n-    }\n-    pure fn ne(&&other: ty) -> bool {\n-        ptr::addr_of(self) != ptr::addr_of(other)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ty : cmp::Eq {\n     pure fn eq(other: &ty) -> bool {\n         ptr::addr_of(self) == ptr::addr_of((*other))\n@@ -1557,15 +1118,6 @@ impl purity : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl purity : cmp::Eq {\n-    pure fn eq(&&other: purity) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: purity) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl purity : cmp::Eq {\n     pure fn eq(other: &purity) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -1586,20 +1138,6 @@ impl ret_style : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl ret_style : cmp::Eq {\n-    pure fn eq(&&other: ret_style) -> bool {\n-        match (self, other) {\n-            (noreturn, noreturn) => true,\n-            (return_val, return_val) => true,\n-            (noreturn, _) => false,\n-            (return_val, _) => false,\n-        }\n-    }\n-    pure fn ne(&&other: ret_style) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ret_style : cmp::Eq {\n     pure fn eq(other: &ret_style) -> bool {\n         match (self, (*other)) {\n@@ -1622,52 +1160,6 @@ enum self_ty_ {\n     sty_uniq(mutability)                // by-unique-pointer self: `~self`\n }\n \n-#[cfg(stage0)]\n-impl self_ty_ : cmp::Eq {\n-    pure fn eq(&&other: self_ty_) -> bool {\n-        match self {\n-            sty_static => {\n-                match other {\n-                    sty_static => true,\n-                    _ => false\n-                }\n-            }\n-            sty_by_ref => {\n-                match other {\n-                    sty_by_ref => true,\n-                    _ => false\n-                }\n-            }\n-            sty_value => {\n-                match other {\n-                    sty_value => true,\n-                    _ => false\n-                }\n-            }\n-            sty_region(e0a) => {\n-                match other {\n-                    sty_region(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            sty_box(e0a) => {\n-                match other {\n-                    sty_box(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            sty_uniq(e0a) => {\n-                match other {\n-                    sty_uniq(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: self_ty_) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl self_ty_ : cmp::Eq {\n     pure fn eq(other: &self_ty_) -> bool {\n         match self {\n@@ -1736,38 +1228,13 @@ enum foreign_abi {\n #[auto_serialize]\n enum foreign_mod_sort { named, anonymous }\n \n-#[cfg(stage0)]\n-impl foreign_mod_sort : cmp::Eq {\n-    pure fn eq(&&other: foreign_mod_sort) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: foreign_mod_sort) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl foreign_mod_sort : cmp::Eq {\n     pure fn eq(other: &foreign_mod_sort) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n     pure fn ne(other: &foreign_mod_sort) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl foreign_abi : cmp::Eq {\n-    pure fn eq(&&other: foreign_abi) -> bool {\n-        match (self, other) {\n-            (foreign_abi_rust_intrinsic, foreign_abi_rust_intrinsic) => true,\n-            (foreign_abi_cdecl, foreign_abi_cdecl) => true,\n-            (foreign_abi_stdcall, foreign_abi_stdcall) => true,\n-            (foreign_abi_rust_intrinsic, _) => false,\n-            (foreign_abi_cdecl, _) => false,\n-            (foreign_abi_stdcall, _) => false,\n-        }\n-    }\n-    pure fn ne(&&other: foreign_abi) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl foreign_abi : cmp::Eq {\n     pure fn eq(other: &foreign_abi) -> bool {\n         match (self, (*other)) {\n@@ -1817,15 +1284,6 @@ type path_list_ident = spanned<path_list_ident_>;\n #[auto_serialize]\n enum namespace { module_ns, type_value_ns }\n \n-#[cfg(stage0)]\n-impl namespace : cmp::Eq {\n-    pure fn eq(&&other: namespace) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: namespace) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl namespace : cmp::Eq {\n     pure fn eq(other: &namespace) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -1874,15 +1332,6 @@ type attribute = spanned<attribute_>;\n #[auto_serialize]\n enum attr_style { attr_outer, attr_inner, }\n \n-#[cfg(stage0)]\n-impl attr_style : cmp::Eq {\n-    pure fn eq(&&other: attr_style) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: attr_style) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl attr_style : cmp::Eq {\n     pure fn eq(other: &attr_style) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -1909,22 +1358,6 @@ type trait_ref = {path: @path, ref_id: node_id, impl_id: node_id};\n #[auto_serialize]\n enum visibility { public, private, inherited }\n \n-#[cfg(stage0)]\n-impl visibility : cmp::Eq {\n-    pure fn eq(&&other: visibility) -> bool {\n-        match (self, other) {\n-            (public, public) => true,\n-            (private, private) => true,\n-            (inherited, inherited) => true,\n-            (public, _) => false,\n-            (private, _) => false,\n-            (inherited, _) => false,\n-        }\n-    }\n-    pure fn ne(&&other: visibility) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl visibility : cmp::Eq {\n     pure fn eq(other: &visibility) -> bool {\n         match (self, (*other)) {\n@@ -2002,20 +1435,6 @@ impl class_mutability : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl class_mutability : cmp::Eq {\n-    pure fn eq(&&other: class_mutability) -> bool {\n-        match (self, other) {\n-            (class_mutable, class_mutable) => true,\n-            (class_immutable, class_immutable) => true,\n-            (class_mutable, _) => false,\n-            (class_immutable, _) => false,\n-        }\n-    }\n-    pure fn ne(&&other: class_mutability) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl class_mutability : cmp::Eq {\n     pure fn eq(other: &class_mutability) -> bool {\n         match (self, (*other)) {"}, {"sha": "9a3e94b737fa596c29800fbd15df2a18175e82d9", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -11,28 +11,6 @@ enum path_elt {\n     path_name(ident)\n }\n \n-#[cfg(stage0)]\n-impl path_elt : cmp::Eq {\n-    pure fn eq(&&other: path_elt) -> bool {\n-        match self {\n-            path_mod(e0a) => {\n-                match other {\n-                    path_mod(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            path_name(e0a) => {\n-                match other {\n-                    path_name(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: path_elt) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl path_elt : cmp::Eq {\n     pure fn eq(other: &path_elt) -> bool {\n         match self {"}, {"sha": "eb4ffb26fb157b064b219152536ea1750b2c1dd0", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -337,15 +337,6 @@ enum inline_attr {\n     ia_never,\n }\n \n-#[cfg(stage0)]\n-impl inline_attr : cmp::Eq {\n-    pure fn eq(&&other: inline_attr) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: inline_attr) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl inline_attr : cmp::Eq {\n     pure fn eq(other: &inline_attr) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "ae49e19c8628e2c5966886b262f9b08ea5485588", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -32,15 +32,6 @@ type filename = ~str;\n \n type file_pos = {ch: uint, byte: uint};\n \n-#[cfg(stage0)]\n-impl file_pos: cmp::Eq {\n-    pure fn eq(&&other: file_pos) -> bool {\n-        self.ch == other.ch && self.byte == other.byte\n-    }\n-    pure fn ne(&&other: file_pos) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl file_pos : cmp::Eq {\n     pure fn eq(other: &file_pos) -> bool {\n         self.ch == (*other).ch && self.byte == (*other).byte\n@@ -180,15 +171,6 @@ type expn_info = Option<@expn_info_>;\n \n type span = {lo: uint, hi: uint, expn_info: expn_info};\n \n-#[cfg(stage0)]\n-impl span : cmp::Eq {\n-    pure fn eq(&&other: span) -> bool {\n-        return self.lo == other.lo && self.hi == other.hi;\n-    }\n-    pure fn ne(&&other: span) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl span : cmp::Eq {\n     pure fn eq(other: &span) -> bool {\n         return self.lo == (*other).lo && self.hi == (*other).hi;"}, {"sha": "ca9db6d25ad8c430f1785b7e3a2b924c4057fc1c", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -146,15 +146,6 @@ enum level {\n     note,\n }\n \n-#[cfg(stage0)]\n-impl level : cmp::Eq {\n-    pure fn eq(&&other: level) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: level) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl level : cmp::Eq {\n     pure fn eq(other: &level) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "70b38e83ad59d200cc23e50fc989f94b52e9b1b4", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -5,20 +5,6 @@ use ast_builder::{path, append_types};\n \n enum direction { send, recv }\n \n-#[cfg(stage0)]\n-impl direction : cmp::Eq {\n-    pure fn eq(&&other: direction) -> bool {\n-        match (self, other) {\n-            (send, send) => true,\n-            (recv, recv) => true,\n-            (send, _) => false,\n-            (recv, _) => false,\n-        }\n-    }\n-    pure fn ne(&&other: direction) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl direction : cmp::Eq {\n     pure fn eq(other: &direction) -> bool {\n         match (self, (*other)) {"}, {"sha": "9c705cff7bbb5c5f50b4510453d3b3ec5196af63", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -17,17 +17,6 @@ enum cmnt_style {\n     blank_line, // Just a manual blank line \"\\n\\n\", for layout\n }\n \n-#[cfg(stage0)]\n-impl cmnt_style : cmp::Eq {\n-    pure fn eq(&&other: cmnt_style) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: cmnt_style) -> bool {\n-        (self as uint) != (other as uint)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl cmnt_style : cmp::Eq {\n     pure fn eq(other: &cmnt_style) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "9cfa84ad9e01e2ffa05ad243996a625d20b18dfe", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -25,17 +25,6 @@ pub enum ObsoleteSyntax {\n     ObsoleteModeInFnType\n }\n \n-#[cfg(stage0)]\n-impl ObsoleteSyntax : cmp::Eq {\n-    pure fn eq(&&other: ObsoleteSyntax) -> bool {\n-        self as uint == other as uint\n-    }\n-    pure fn ne(&&other: ObsoleteSyntax) -> bool {\n-        !self.eq(other)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ObsoleteSyntax : cmp::Eq {\n     pure fn eq(other: &ObsoleteSyntax) -> bool {\n         self as uint == (*other) as uint"}, {"sha": "2ffe69c8b10cc2fef5c6243b14aa8fdaa8d6d7d9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -3657,15 +3657,6 @@ impl parser {\n     }\n }\n \n-#[cfg(stage0)]\n-impl restriction : cmp::Eq {\n-    pure fn eq(&&other: restriction) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: restriction) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl restriction : cmp::Eq {\n     pure fn eq(other: &restriction) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "0f9041a2fcdd824740d060acc0d73a4942bf5a80", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 277, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -436,290 +436,13 @@ fn reserved_keyword_table() -> HashMap<~str, ()> {\n     words\n }\n \n-#[cfg(stage0)]\n-impl binop : cmp::Eq {\n-    pure fn eq(&&other: binop) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: binop) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl binop : cmp::Eq {\n     pure fn eq(other: &binop) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n     pure fn ne(other: &binop) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl token : cmp::Eq {\n-    pure fn eq(&&other: token) -> bool {\n-        match self {\n-            EQ => {\n-                match other {\n-                    EQ => true,\n-                    _ => false\n-                }\n-            }\n-            LT => {\n-                match other {\n-                    LT => true,\n-                    _ => false\n-                }\n-            }\n-            LE => {\n-                match other {\n-                    LE => true,\n-                    _ => false\n-                }\n-            }\n-            EQEQ => {\n-                match other {\n-                    EQEQ => true,\n-                    _ => false\n-                }\n-            }\n-            NE => {\n-                match other {\n-                    NE => true,\n-                    _ => false\n-                }\n-            }\n-            GE => {\n-                match other {\n-                    GE => true,\n-                    _ => false\n-                }\n-            }\n-            GT => {\n-                match other {\n-                    GT => true,\n-                    _ => false\n-                }\n-            }\n-            ANDAND => {\n-                match other {\n-                    ANDAND => true,\n-                    _ => false\n-                }\n-            }\n-            OROR => {\n-                match other {\n-                    OROR => true,\n-                    _ => false\n-                }\n-            }\n-            NOT => {\n-                match other {\n-                    NOT => true,\n-                    _ => false\n-                }\n-            }\n-            TILDE => {\n-                match other {\n-                    TILDE => true,\n-                    _ => false\n-                }\n-            }\n-            BINOP(e0a) => {\n-                match other {\n-                    BINOP(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            BINOPEQ(e0a) => {\n-                match other {\n-                    BINOPEQ(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            AT => {\n-                match other {\n-                    AT => true,\n-                    _ => false\n-                }\n-            }\n-            DOT => {\n-                match other {\n-                    DOT => true,\n-                    _ => false\n-                }\n-            }\n-            DOTDOT => {\n-                match other {\n-                    DOTDOT => true,\n-                    _ => false\n-                }\n-            }\n-            ELLIPSIS => {\n-                match other {\n-                    ELLIPSIS => true,\n-                    _ => false\n-                }\n-            }\n-            COMMA => {\n-                match other {\n-                    COMMA => true,\n-                    _ => false\n-                }\n-            }\n-            SEMI => {\n-                match other {\n-                    SEMI => true,\n-                    _ => false\n-                }\n-            }\n-            COLON => {\n-                match other {\n-                    COLON => true,\n-                    _ => false\n-                }\n-            }\n-            MOD_SEP => {\n-                match other {\n-                    MOD_SEP => true,\n-                    _ => false\n-                }\n-            }\n-            RARROW => {\n-                match other {\n-                    RARROW => true,\n-                    _ => false\n-                }\n-            }\n-            LARROW => {\n-                match other {\n-                    LARROW => true,\n-                    _ => false\n-                }\n-            }\n-            DARROW => {\n-                match other {\n-                    DARROW => true,\n-                    _ => false\n-                }\n-            }\n-            FAT_ARROW => {\n-                match other {\n-                    FAT_ARROW => true,\n-                    _ => false\n-                }\n-            }\n-            LPAREN => {\n-                match other {\n-                    LPAREN => true,\n-                    _ => false\n-                }\n-            }\n-            RPAREN => {\n-                match other {\n-                    RPAREN => true,\n-                    _ => false\n-                }\n-            }\n-            LBRACKET => {\n-                match other {\n-                    LBRACKET => true,\n-                    _ => false\n-                }\n-            }\n-            RBRACKET => {\n-                match other {\n-                    RBRACKET => true,\n-                    _ => false\n-                }\n-            }\n-            LBRACE => {\n-                match other {\n-                    LBRACE => true,\n-                    _ => false\n-                }\n-            }\n-            RBRACE => {\n-                match other {\n-                    RBRACE => true,\n-                    _ => false\n-                }\n-            }\n-            POUND => {\n-                match other {\n-                    POUND => true,\n-                    _ => false\n-                }\n-            }\n-            DOLLAR => {\n-                match other {\n-                    DOLLAR => true,\n-                    _ => false\n-                }\n-            }\n-            LIT_INT(e0a, e1a) => {\n-                match other {\n-                    LIT_INT(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            LIT_UINT(e0a, e1a) => {\n-                match other {\n-                    LIT_UINT(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            LIT_INT_UNSUFFIXED(e0a) => {\n-                match other {\n-                    LIT_INT_UNSUFFIXED(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            LIT_FLOAT(e0a, e1a) => {\n-                match other {\n-                    LIT_FLOAT(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            LIT_STR(e0a) => {\n-                match other {\n-                    LIT_STR(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            IDENT(e0a, e1a) => {\n-                match other {\n-                    IDENT(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            UNDERSCORE => {\n-                match other {\n-                    UNDERSCORE => true,\n-                    _ => false\n-                }\n-            }\n-            INTERPOLATED(_) => {\n-                match other {\n-                    INTERPOLATED(_) => true,\n-                    _ => false\n-                }\n-            }\n-            DOC_COMMENT(e0a) => {\n-                match other {\n-                    DOC_COMMENT(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            EOF => {\n-                match other {\n-                    EOF => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: token) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl token : cmp::Eq {\n     pure fn eq(other: &token) -> bool {\n         match self {"}, {"sha": "d474aaeaa0bfeeb42fca1d15c2e29f7c0239bb46", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -55,20 +55,6 @@ use dvec::DVec;\n  */\n enum breaks { consistent, inconsistent, }\n \n-#[cfg(stage0)]\n-impl breaks : cmp::Eq {\n-    pure fn eq(&&other: breaks) -> bool {\n-        match (self, other) {\n-            (consistent, consistent) => true,\n-            (inconsistent, inconsistent) => true,\n-            (consistent, _) => false,\n-            (inconsistent, _) => false,\n-        }\n-    }\n-    pure fn ne(&&other: breaks) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl breaks : cmp::Eq {\n     pure fn eq(other: &breaks) -> bool {\n         match (self, (*other)) {"}, {"sha": "fb3d749673c1a33bf4eaa245a30644efdf3d4d3d", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -26,15 +26,6 @@ enum output_type {\n     output_type_exe,\n }\n \n-#[cfg(stage0)]\n-impl output_type : cmp::Eq {\n-    pure fn eq(&&other: output_type) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: output_type) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl output_type : cmp::Eq {\n     pure fn eq(other: &output_type) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "f890fa85eb3504c67f4ff2162abca04a8b176ed5", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -138,15 +138,6 @@ enum compile_upto {\n     cu_everything,\n }\n \n-#[cfg(stage0)]\n-impl compile_upto : cmp::Eq {\n-    pure fn eq(&&other: compile_upto) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: compile_upto) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl compile_upto : cmp::Eq {\n     pure fn eq(other: &compile_upto) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "1b4b47f1014a637e197979d9105174e82ae45229", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -207,15 +207,6 @@ enum monitor_msg {\n     done,\n }\n \n-#[cfg(stage0)]\n-impl monitor_msg : cmp::Eq {\n-    pure fn eq(&&other: monitor_msg) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: monitor_msg) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl monitor_msg : cmp::Eq {\n     pure fn eq(other: &monitor_msg) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "335e100407830f27fb38eac341e0c09a43a77a6d", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -12,15 +12,6 @@ use middle::lint;\n \n enum os { os_win32, os_macos, os_linux, os_freebsd, }\n \n-#[cfg(stage0)]\n-impl os : cmp::Eq {\n-    pure fn eq(&&other: os) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: os) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl os : cmp::Eq {\n     pure fn eq(other: &os) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -30,15 +21,6 @@ impl os : cmp::Eq {\n \n enum arch { arch_x86, arch_x86_64, arch_arm, }\n \n-#[cfg(stage0)]\n-impl arch: cmp::Eq {\n-    pure fn eq(&&other: arch) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: arch) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl arch : cmp::Eq {\n     pure fn eq(other: &arch) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -112,15 +94,6 @@ enum OptLevel {\n     Aggressive // -O3\n }\n \n-#[cfg(stage0)]\n-impl OptLevel : cmp::Eq {\n-    pure fn eq(&&other: OptLevel) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: OptLevel) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl OptLevel : cmp::Eq {\n     pure fn eq(other: &OptLevel) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "031ce219308050c4a279605eefe47a673cff5e2e", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -128,48 +128,6 @@ enum TypeKind {\n     X86_MMX   = 15\n }\n \n-#[cfg(stage0)]\n-impl TypeKind : cmp::Eq {\n-    pure fn eq(&&other: TypeKind) -> bool {\n-        match (self, other) {\n-            (Void, Void) => true,\n-            (Half, Half) => true,\n-            (Float, Float) => true,\n-            (Double, Double) => true,\n-            (X86_FP80, X86_FP80) => true,\n-            (FP128, FP128) => true,\n-            (PPC_FP128, PPC_FP128) => true,\n-            (Label, Label) => true,\n-            (Integer, Integer) => true,\n-            (Function, Function) => true,\n-            (Struct, Struct) => true,\n-            (Array, Array) => true,\n-            (Pointer, Pointer) => true,\n-            (Vector, Vector) => true,\n-            (Metadata, Metadata) => true,\n-            (X86_MMX, X86_MMX) => true,\n-            (Void, _) => false,\n-            (Half, _) => false,\n-            (Float, _) => false,\n-            (Double, _) => false,\n-            (X86_FP80, _) => false,\n-            (FP128, _) => false,\n-            (PPC_FP128, _) => false,\n-            (Label, _) => false,\n-            (Integer, _) => false,\n-            (Function, _) => false,\n-            (Struct, _) => false,\n-            (Array, _) => false,\n-            (Pointer, _) => false,\n-            (Vector, _) => false,\n-            (Metadata, _) => false,\n-            (X86_MMX, _) => false,\n-        }\n-    }\n-    pure fn ne(&&other: TypeKind) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl TypeKind : cmp::Eq {\n     pure fn eq(other: &TypeKind) -> bool {\n         match (self, (*other)) {"}, {"sha": "c631e40447227cd510aaec302f7b40176b3b1cd1", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -129,15 +129,6 @@ enum Family {\n     InheritedField         // N\n }\n \n-#[cfg(stage0)]\n-impl Family : cmp::Eq {\n-    pure fn eq(&&other: Family) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: Family) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Family : cmp::Eq {\n     pure fn eq(other: &Family) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "4906eb4a0a3a80b37391a49e1e94718547907c18", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -323,53 +323,6 @@ enum bckerr_code {\n     err_out_of_scope(ty::region, ty::region) // superscope, subscope\n }\n \n-#[cfg(stage0)]\n-impl bckerr_code : cmp::Eq {\n-    pure fn eq(&&other: bckerr_code) -> bool {\n-        match self {\n-            err_mut_uniq => {\n-                match other {\n-                    err_mut_uniq => true,\n-                    _ => false\n-                }\n-            }\n-            err_mut_variant => {\n-                match other {\n-                    err_mut_variant => true,\n-                    _ => false\n-                }\n-            }\n-            err_root_not_permitted => {\n-                match other {\n-                    err_root_not_permitted => true,\n-                    _ => false\n-                }\n-            }\n-            err_mutbl(e0a) => {\n-                match other {\n-                    err_mutbl(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            err_out_of_root_scope(e0a, e1a) => {\n-                match other {\n-                    err_out_of_root_scope(e0b, e1b) =>\n-                        e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            err_out_of_scope(e0a, e1a) => {\n-                match other {\n-                    err_out_of_scope(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: bckerr_code) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl bckerr_code : cmp::Eq {\n     pure fn eq(other: &bckerr_code) -> bool {\n         match self {\n@@ -419,15 +372,6 @@ impl bckerr_code : cmp::Eq {\n // that caused it\n type bckerr = {cmt: cmt, code: bckerr_code};\n \n-#[cfg(stage0)]\n-impl bckerr : cmp::Eq {\n-    pure fn eq(&&other: bckerr) -> bool {\n-        self.cmt == other.cmt && self.code == other.code\n-    }\n-    pure fn ne(&&other: bckerr) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl bckerr : cmp::Eq {\n     pure fn eq(other: &bckerr) -> bool {\n         self.cmt == (*other).cmt && self.code == (*other).code\n@@ -461,17 +405,6 @@ fn save_and_restore<T:Copy,U>(&save_and_restore_t: T, f: fn() -> U) -> U {\n \n /// Creates and returns a new root_map\n \n-#[cfg(stage0)]\n-impl root_map_key : cmp::Eq {\n-    pure fn eq(&&other: root_map_key) -> bool {\n-        self.id == other.id && self.derefs == other.derefs\n-    }\n-    pure fn ne(&&other: root_map_key) -> bool {\n-        ! (self == other)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl root_map_key : cmp::Eq {\n     pure fn eq(other: &root_map_key) -> bool {\n         self.id == (*other).id && self.derefs == (*other).derefs"}, {"sha": "c0aaa041d1895f744fbc8f663abd8da73a65c5e6", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -36,28 +36,6 @@ enum purity_cause {\n     pc_cmt(bckerr)\n }\n \n-#[cfg(stage0)]\n-impl purity_cause : cmp::Eq {\n-    pure fn eq(&&other: purity_cause) -> bool {\n-        match self {\n-            pc_pure_fn => {\n-                match other {\n-                    pc_pure_fn => true,\n-                    _ => false\n-                }\n-            }\n-            pc_cmt(e0a) => {\n-                match other {\n-                    pc_cmt(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: purity_cause) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl purity_cause : cmp::Eq {\n     pure fn eq(other: &purity_cause) -> bool {\n         match self {\n@@ -100,15 +78,6 @@ enum assignment_type {\n     at_swap\n }\n \n-#[cfg(stage0)]\n-impl assignment_type : cmp::Eq {\n-    pure fn eq(&&other: assignment_type) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: assignment_type) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl assignment_type : cmp::Eq {\n     pure fn eq(other: &assignment_type) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "0d8d8b8dfe09b6fc2c9e62262df46d60df0284e2", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -124,25 +124,6 @@ enum ctor {\n     range(const_val, const_val),\n }\n \n-#[cfg(stage0)]\n-impl ctor: cmp::Eq {\n-    pure fn eq(&&other: ctor) -> bool {\n-        match (self, other) {\n-            (single, single) => true,\n-            (variant(did_self), variant(did_other)) => did_self == did_other,\n-            (val(cv_self), val(cv_other)) => cv_self == cv_other,\n-            (range(cv0_self, cv1_self), range(cv0_other, cv1_other)) => {\n-                cv0_self == cv0_other && cv1_self == cv1_other\n-            }\n-            (single, _) | (variant(_), _) | (val(_), _) | (range(*), _) => {\n-                false\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: ctor) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ctor : cmp::Eq {\n     pure fn eq(other: &ctor) -> bool {\n         match (self, (*other)) {"}, {"sha": "463bf502036abe4695e6284d0801cd23046bed4a", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -189,23 +189,6 @@ enum const_val {\n     const_bool(bool)\n }\n \n-#[cfg(stage0)]\n-impl const_val: cmp::Eq {\n-    pure fn eq(&&other: const_val) -> bool {\n-        match (self, other) {\n-            (const_float(a), const_float(b)) => a == b,\n-            (const_int(a), const_int(b)) => a == b,\n-            (const_uint(a), const_uint(b)) => a == b,\n-            (const_str(a), const_str(b)) => a == b,\n-            (const_bool(a), const_bool(b)) => a == b,\n-            (const_float(_), _) | (const_int(_), _) | (const_uint(_), _) |\n-            (const_str(_), _) | (const_bool(_), _) => false\n-        }\n-    }\n-    pure fn ne(&&other: const_val) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl const_val : cmp::Eq {\n     pure fn eq(other: &const_val) -> bool {\n         match (self, (*other)) {"}, {"sha": "a6778d83b9963c2345b9faa07f8aafdc0bfc9030", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -66,15 +66,6 @@ enum lint {\n     // dead_assignment\n }\n \n-#[cfg(stage0)]\n-impl lint : cmp::Eq {\n-    pure fn eq(&&other: lint) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: lint) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl lint : cmp::Eq {\n     pure fn eq(other: &lint) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -95,15 +86,6 @@ enum level {\n     allow, warn, deny, forbid\n }\n \n-#[cfg(stage0)]\n-impl level : cmp::Eq {\n-    pure fn eq(&&other: level) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: level) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl level : cmp::Eq {\n     pure fn eq(other: &level) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "a4c9b5f4b355ef5efec9273fdf52623d8f1d11e3", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -127,25 +127,11 @@ type last_use_map = HashMap<node_id, @DVec<node_id>>;\n enum Variable = uint;\n enum LiveNode = uint;\n \n-#[cfg(stage0)]\n-impl Variable : cmp::Eq {\n-    pure fn eq(&&other: Variable) -> bool { *self == *other }\n-    pure fn ne(&&other: Variable) -> bool { *self != *other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Variable : cmp::Eq {\n     pure fn eq(other: &Variable) -> bool { *self == *(*other) }\n     pure fn ne(other: &Variable) -> bool { *self != *(*other) }\n }\n \n-#[cfg(stage0)]\n-impl LiveNode : cmp::Eq {\n-    pure fn eq(&&other: LiveNode) -> bool { *self == *other }\n-    pure fn ne(&&other: LiveNode) -> bool { *self != *other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl LiveNode : cmp::Eq {\n     pure fn eq(other: &LiveNode) -> bool { *self == *(*other) }\n     pure fn ne(other: &LiveNode) -> bool { *self != *(*other) }\n@@ -158,40 +144,6 @@ enum LiveNodeKind {\n     ExitNode\n }\n \n-#[cfg(stage0)]\n-impl LiveNodeKind : cmp::Eq {\n-    pure fn eq(&&other: LiveNodeKind) -> bool {\n-        match self {\n-            FreeVarNode(e0a) => {\n-                match other {\n-                    FreeVarNode(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ExprNode(e0a) => {\n-                match other {\n-                    ExprNode(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            VarDefNode(e0a) => {\n-                match other {\n-                    VarDefNode(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ExitNode => {\n-                match other {\n-                    ExitNode => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: LiveNodeKind) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl LiveNodeKind : cmp::Eq {\n     pure fn eq(other: &LiveNodeKind) -> bool {\n         match self {"}, {"sha": "03d453a84f551492da9b8f77158318b88bbf9363", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -55,71 +55,6 @@ enum categorization {\n     cat_discr(cmt, ast::node_id),   // match discriminant (see preserve())\n }\n \n-#[cfg(stage0)]\n-impl categorization : cmp::Eq {\n-    pure fn eq(&&other: categorization) -> bool {\n-        match self {\n-            cat_rvalue => {\n-                match other {\n-                    cat_rvalue => true,\n-                    _ => false\n-                }\n-            }\n-            cat_special(e0a) => {\n-                match other {\n-                    cat_special(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_local(e0a) => {\n-                match other {\n-                    cat_local(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_binding(e0a) => {\n-                match other {\n-                    cat_binding(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_arg(e0a) => {\n-                match other {\n-                    cat_arg(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_stack_upvar(e0a) => {\n-                match other {\n-                    cat_stack_upvar(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_deref(e0a, e1a, e2a) => {\n-                match other {\n-                    cat_deref(e0b, e1b, e2b) =>\n-                        e0a == e0b && e1a == e1b && e2a == e2b,\n-                    _ => false\n-                }\n-            }\n-            cat_comp(e0a, e1a) => {\n-                match other {\n-                    cat_comp(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            cat_discr(e0a, e1a) => {\n-                match other {\n-                    cat_discr(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: categorization) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl categorization : cmp::Eq {\n     pure fn eq(other: &categorization) -> bool {\n         match self {\n@@ -191,40 +126,6 @@ enum ptr_kind {\n     unsafe_ptr\n }\n \n-#[cfg(stage0)]\n-impl ptr_kind : cmp::Eq {\n-    pure fn eq(&&other: ptr_kind) -> bool {\n-        match self {\n-            uniq_ptr => {\n-                match other {\n-                    uniq_ptr => true,\n-                    _ => false\n-                }\n-            }\n-            gc_ptr => {\n-                match other {\n-                    gc_ptr => true,\n-                    _ => false\n-                }\n-            }\n-            region_ptr(e0a) => {\n-                match other {\n-                    region_ptr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            unsafe_ptr => {\n-                match other {\n-                    unsafe_ptr => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: ptr_kind) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ptr_kind : cmp::Eq {\n     pure fn eq(other: &ptr_kind) -> bool {\n         match self {\n@@ -268,40 +169,6 @@ enum comp_kind {\n                ast::mutability)  // mutability of vec content\n }\n \n-#[cfg(stage0)]\n-impl comp_kind : cmp::Eq {\n-    pure fn eq(&&other: comp_kind) -> bool {\n-        match self {\n-            comp_tuple => {\n-                match other {\n-                    comp_tuple => true,\n-                    _ => false\n-                }\n-            }\n-            comp_variant(e0a) => {\n-                match other {\n-                    comp_variant(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            comp_field(e0a, e1a) => {\n-                match other {\n-                    comp_field(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            comp_index(e0a, e1a) => {\n-                match other {\n-                    comp_index(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: comp_kind) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl comp_kind : cmp::Eq {\n     pure fn eq(other: &comp_kind) -> bool {\n         match self {\n@@ -342,15 +209,6 @@ enum special_kind {\n     sk_heap_upvar\n }\n \n-#[cfg(stage0)]\n-impl special_kind : cmp::Eq {\n-    pure fn eq(&&other: special_kind) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: special_kind) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl special_kind : cmp::Eq {\n     pure fn eq(other: &special_kind) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -370,20 +228,6 @@ type cmt_ = {id: ast::node_id,        // id of expr/pat producing this value\n \n type cmt = @cmt_;\n \n-#[cfg(stage0)]\n-impl cmt_ : cmp::Eq {\n-    pure fn eq(&&other: cmt_) -> bool {\n-        self.id == other.id &&\n-        self.span == other.span &&\n-        self.cat == other.cat &&\n-        self.lp == other.lp &&\n-        self.mutbl == other.mutbl &&\n-        self.ty == other.ty\n-    }\n-    pure fn ne(&&other: cmt_) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl cmt_ : cmp::Eq {\n     pure fn eq(other: &cmt_) -> bool {\n         self.id == (*other).id &&\n@@ -406,40 +250,6 @@ enum loan_path {\n     lp_comp(@loan_path, comp_kind)\n }\n \n-#[cfg(stage0)]\n-impl loan_path : cmp::Eq {\n-    pure fn eq(&&other: loan_path) -> bool {\n-        match self {\n-            lp_local(e0a) => {\n-                match other {\n-                    lp_local(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            lp_arg(e0a) => {\n-                match other {\n-                    lp_arg(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            lp_deref(e0a, e1a) => {\n-                match other {\n-                    lp_deref(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            lp_comp(e0a, e1a) => {\n-                match other {\n-                    lp_comp(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: loan_path) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl loan_path : cmp::Eq {\n     pure fn eq(other: &loan_path) -> bool {\n         match self {"}, {"sha": "cf496ae6683acc88c79f2980682bc6d4621f1356", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -373,15 +373,6 @@ type region_paramd_items = HashMap<ast::node_id, region_variance>;\n type region_dep = {ambient_variance: region_variance, id: ast::node_id};\n type dep_map = HashMap<ast::node_id, @DVec<region_dep>>;\n \n-#[cfg(stage0)]\n-impl region_dep: cmp::Eq {\n-    pure fn eq(&&other: region_dep) -> bool {\n-        self.ambient_variance == other.ambient_variance && self.id == other.id\n-    }\n-    pure fn ne(&&other: region_dep) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl region_dep : cmp::Eq {\n     pure fn eq(other: &region_dep) -> bool {\n         self.ambient_variance == (*other).ambient_variance &&"}, {"sha": "13095ed5ccdd34033939ffa9674493ea05fd8ffb", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -106,15 +106,6 @@ enum PatternBindingMode {\n     IrrefutableMode\n }\n \n-#[cfg(stage0)]\n-impl PatternBindingMode : cmp::Eq {\n-    pure fn eq(&&other: PatternBindingMode) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: PatternBindingMode) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl PatternBindingMode : cmp::Eq {\n     pure fn eq(other: &PatternBindingMode) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -156,15 +147,6 @@ enum Mutability {\n     Immutable\n }\n \n-#[cfg(stage0)]\n-impl Mutability : cmp::Eq {\n-    pure fn eq(&&other: Mutability) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: Mutability) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Mutability : cmp::Eq {\n     pure fn eq(other: &Mutability) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -200,15 +182,6 @@ enum ImportDirectiveNS {\n     AnyNS\n }\n \n-#[cfg(stage0)]\n-impl ImportDirectiveNS : cmp::Eq {\n-    pure fn eq(&&other: ImportDirectiveNS) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: ImportDirectiveNS) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ImportDirectiveNS : cmp::Eq {\n     pure fn eq(other: &ImportDirectiveNS) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -305,15 +278,6 @@ enum XrayFlag {\n     Xray        //< Private items can be accessed.\n }\n \n-#[cfg(stage0)]\n-impl XrayFlag : cmp::Eq {\n-    pure fn eq(&&other: XrayFlag) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: XrayFlag) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl XrayFlag : cmp::Eq {\n     pure fn eq(other: &XrayFlag) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -326,15 +290,6 @@ enum AllowCapturingSelfFlag {\n     DontAllowCapturingSelf,     //< The \"self\" definition cannot be captured.\n }\n \n-#[cfg(stage0)]\n-impl AllowCapturingSelfFlag : cmp::Eq {\n-    pure fn eq(&&other: AllowCapturingSelfFlag) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: AllowCapturingSelfFlag) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl AllowCapturingSelfFlag : cmp::Eq {\n     pure fn eq(other: &AllowCapturingSelfFlag) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -548,15 +503,6 @@ enum Privacy {\n     Public\n }\n \n-#[cfg(stage0)]\n-impl Privacy : cmp::Eq {\n-    pure fn eq(&&other: Privacy) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: Privacy) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Privacy : cmp::Eq {\n     pure fn eq(other: &Privacy) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "11b694bcb1d2d980ffa57179774fc87bb1f722b0", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -675,15 +675,6 @@ fn pick_col(m: &[@Match]) -> uint {\n \n enum branch_kind { no_branch, single, switch, compare, }\n \n-#[cfg(stage0)]\n-impl branch_kind : cmp::Eq {\n-    pure fn eq(&&other: branch_kind) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: branch_kind) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl branch_kind : cmp::Eq {\n     pure fn eq(other: &branch_kind) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "a1ca4287f0ef2226efe2013f27e04b8dfa1bcf9f", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -281,28 +281,6 @@ enum cleanup {\n     clean_temp(ValueRef, fn@(block) -> block, cleantype),\n }\n \n-#[cfg(stage0)]\n-impl cleantype : cmp::Eq {\n-    pure fn eq(&&other: cleantype) -> bool {\n-        match self {\n-            normal_exit_only => {\n-                match other {\n-                    normal_exit_only => true,\n-                    _ => false\n-                }\n-            }\n-            normal_exit_and_unwind => {\n-                match other {\n-                    normal_exit_and_unwind => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: cleantype) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl cleantype : cmp::Eq {\n     pure fn eq(other: &cleantype) -> bool {\n         match self {\n@@ -1135,28 +1113,6 @@ type mono_id_ = {def: ast::def_id, params: ~[mono_param_id]};\n \n type mono_id = @mono_id_;\n \n-#[cfg(stage0)]\n-impl mono_param_id: cmp::Eq {\n-    pure fn eq(&&other: mono_param_id) -> bool {\n-        match (self, other) {\n-            (mono_precise(ty_a, ids_a), mono_precise(ty_b, ids_b)) => {\n-                ty_a == ty_b && ids_a == ids_b\n-            }\n-            (mono_any, mono_any) => true,\n-            (mono_repr(size_a, align_a, is_float_a, mode_a),\n-             mono_repr(size_b, align_b, is_float_b, mode_b)) => {\n-                size_a == size_b && align_a == align_b &&\n-                    is_float_a == is_float_b && mode_a == mode_b\n-            }\n-            (mono_precise(*), _) => false,\n-            (mono_any, _) => false,\n-            (mono_repr(*), _) => false\n-        }\n-    }\n-    pure fn ne(&&other: mono_param_id) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl mono_param_id : cmp::Eq {\n     pure fn eq(other: &mono_param_id) -> bool {\n         match (self, (*other)) {\n@@ -1177,15 +1133,6 @@ impl mono_param_id : cmp::Eq {\n     pure fn ne(other: &mono_param_id) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl mono_id_: cmp::Eq {\n-    pure fn eq(&&other: mono_id_) -> bool {\n-        return self.def == other.def && self.params == other.params;\n-    }\n-    pure fn ne(&&other: mono_id_) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl mono_id_ : cmp::Eq {\n     pure fn eq(other: &mono_id_) -> bool {\n         return self.def == (*other).def && self.params == (*other).params;"}, {"sha": "3f2705a9bcc5919e8fc3311b6ce67e323fe4e37d", "filename": "src/rustc/middle/trans/datum.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -138,16 +138,6 @@ impl DatumMode {\n     }\n }\n \n-#[cfg(stage0)]\n-impl DatumMode: cmp::Eq {\n-    pure fn eq(&&other: DatumMode) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: DatumMode) -> bool { !self.eq(other) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl DatumMode: cmp::Eq {\n     pure fn eq(other: &DatumMode) -> bool {\n         self as uint == (*other as uint)\n@@ -776,20 +766,6 @@ impl DatumBlock {\n     }\n }\n \n-#[cfg(stage0)]\n-impl CopyAction : cmp::Eq {\n-    pure fn eq(&&other: CopyAction) -> bool {\n-        match (self, other) {\n-            (INIT, INIT) => true,\n-            (DROP_EXISTING, DROP_EXISTING) => true,\n-            (INIT, _) => false,\n-            (DROP_EXISTING, _) => false,\n-        }\n-    }\n-    pure fn ne(&&other: CopyAction) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl CopyAction : cmp::Eq {\n     pure fn eq(other: &CopyAction) -> bool {\n         match (self, (*other)) {"}, {"sha": "0a38e19a26c519ca6512188b89cee670737e0fb5", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -147,20 +147,6 @@ impl Dest {\n     }\n }\n \n-#[cfg(stage0)]\n-impl Dest : cmp::Eq {\n-    pure fn eq(&&other: Dest) -> bool {\n-        match (self, other) {\n-            (SaveIn(e0a), SaveIn(e0b)) => e0a == e0b,\n-            (Ignore, Ignore) => true,\n-            (SaveIn(*), _) => false,\n-            (Ignore, _) => false,\n-        }\n-    }\n-    pure fn ne(&&other: Dest) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Dest : cmp::Eq {\n     pure fn eq(other: &Dest) -> bool {\n         match (self, (*other)) {\n@@ -1366,26 +1352,6 @@ enum cast_kind {\n     cast_other,\n }\n \n-#[cfg(stage0)]\n-impl cast_kind : cmp::Eq {\n-    pure fn eq(&&other: cast_kind) -> bool {\n-        match (self, other) {\n-            (cast_pointer, cast_pointer) => true,\n-            (cast_integral, cast_integral) => true,\n-            (cast_float, cast_float) => true,\n-            (cast_enum, cast_enum) => true,\n-            (cast_other, cast_other) => true,\n-            (cast_pointer, _) => false,\n-            (cast_integral, _) => false,\n-            (cast_float, _) => false,\n-            (cast_enum, _) => false,\n-            (cast_other, _) => false,\n-        }\n-    }\n-    pure fn ne(&&other: cast_kind) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl cast_kind : cmp::Eq {\n     pure fn eq(other: &cast_kind) -> bool {\n         match (self, (*other)) {"}, {"sha": "e775b3fd746f277b9f8995b043c8aca863fcf20c", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -40,15 +40,6 @@ enum x86_64_reg_class {\n     memory_class\n }\n \n-#[cfg(stage0)]\n-impl x86_64_reg_class: cmp::Eq {\n-    pure fn eq(&&other: x86_64_reg_class) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: x86_64_reg_class) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl x86_64_reg_class : cmp::Eq {\n     pure fn eq(other: &x86_64_reg_class) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "e09e3d9493d7c74d220ee9333ca814a9f78c5197", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -26,24 +26,6 @@ type nominal_id_ = {did: ast::def_id, parent_id: Option<ast::def_id>,\n                     tps: ~[ty::t]};\n type nominal_id = @nominal_id_;\n \n-#[cfg(stage0)]\n-impl nominal_id_ : core::cmp::Eq {\n-    pure fn eq(&&other: nominal_id_) -> bool {\n-        if self.did != other.did ||\n-            self.parent_id != other.parent_id {\n-            false\n-        } else {\n-            do vec::all2(self.tps, other.tps) |m_tp, n_tp| {\n-                ty::type_id(m_tp) == ty::type_id(n_tp)\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: nominal_id_) -> bool {\n-        ! (self == other)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl nominal_id_ : core::cmp::Eq {\n     pure fn eq(other: &nominal_id_) -> bool {\n         if self.did != other.did ||"}, {"sha": "b063b759845edc935eb7c1afbc24937374b1734e", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 530, "changes": 530, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -235,19 +235,6 @@ type field_ty = {\n type creader_cache_key = {cnum: int, pos: uint, len: uint};\n type creader_cache = HashMap<creader_cache_key, t>;\n \n-#[cfg(stage0)]\n-impl creader_cache_key : cmp::Eq {\n-    pure fn eq(&&other: creader_cache_key) -> bool {\n-        self.cnum == other.cnum &&\n-            self.pos == other.pos &&\n-            self.len == other.len\n-    }\n-    pure fn ne(&&other: creader_cache_key) -> bool {\n-        !(self == other)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl creader_cache_key : cmp::Eq {\n     pure fn eq(other: &creader_cache_key) -> bool {\n         self.cnum == (*other).cnum &&\n@@ -267,15 +254,6 @@ impl creader_cache_key : to_bytes::IterBytes {\n \n type intern_key = {sty: sty, o_def_id: Option<ast::def_id>};\n \n-#[cfg(stage0)]\n-impl intern_key: cmp::Eq {\n-    pure fn eq(&&other: intern_key) -> bool {\n-        self.sty == other.sty && self.o_def_id == other.o_def_id\n-    }\n-    pure fn ne(&&other: intern_key) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl intern_key : cmp::Eq {\n     pure fn eq(other: &intern_key) -> bool {\n         self.sty == (*other).sty && self.o_def_id == (*other).o_def_id\n@@ -300,22 +278,6 @@ type opt_region_variance = Option<region_variance>;\n #[auto_serialize]\n enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n \n-#[cfg(stage0)]\n-impl region_variance: cmp::Eq {\n-    pure fn eq(&&other: region_variance) -> bool {\n-        match (self, other) {\n-            (rv_covariant, rv_covariant) => true,\n-            (rv_invariant, rv_invariant) => true,\n-            (rv_contravariant, rv_contravariant) => true,\n-            (rv_covariant, _) => false,\n-            (rv_invariant, _) => false,\n-            (rv_contravariant, _) => false\n-        }\n-    }\n-    pure fn ne(&&other: region_variance) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl region_variance : cmp::Eq {\n     pure fn eq(other: &region_variance) -> bool {\n         match (self, (*other)) {\n@@ -448,15 +410,6 @@ impl closure_kind : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl closure_kind : cmp::Eq {\n-    pure fn eq(&&other: closure_kind) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: closure_kind) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl closure_kind : cmp::Eq {\n     pure fn eq(other: &closure_kind) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -481,28 +434,6 @@ impl fn_proto : to_bytes::IterBytes {\n     }\n }\n \n-#[cfg(stage0)]\n-impl fn_proto : cmp::Eq {\n-    pure fn eq(&&other: fn_proto) -> bool {\n-        match self {\n-            proto_bare => {\n-                match other {\n-                    proto_bare => true,\n-                    _ => false\n-                }\n-            }\n-            proto_vstore(e0a) => {\n-                match other {\n-                    proto_vstore(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: fn_proto) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl fn_proto : cmp::Eq {\n     pure fn eq(other: &fn_proto) -> bool {\n         match self {\n@@ -562,15 +493,6 @@ type FnTy = FnTyBase<FnMeta>;\n \n type param_ty = {idx: uint, def_id: def_id};\n \n-#[cfg(stage0)]\n-impl param_ty: cmp::Eq {\n-    pure fn eq(&&other: param_ty) -> bool {\n-        self.idx == other.idx && self.def_id == other.def_id\n-    }\n-    pure fn ne(&&other: param_ty) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl param_ty : cmp::Eq {\n     pure fn eq(other: &param_ty) -> bool {\n         self.idx == (*other).idx && self.def_id == (*other).def_id\n@@ -1894,16 +1816,6 @@ fn remove_copyable(k: kind) -> kind {\n     k - kind_(KIND_MASK_COPY | KIND_MASK_DEFAULT_MODE)\n }\n \n-#[cfg(stage0)]\n-impl kind: ops::BitAnd<kind,kind> {\n-    pure fn bitand(other: kind) -> kind {\n-        unsafe {\n-            lower_kind(self, other)\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl kind : ops::BitAnd<kind,kind> {\n     pure fn bitand(other: &kind) -> kind {\n         unsafe {\n@@ -1912,16 +1824,6 @@ impl kind : ops::BitAnd<kind,kind> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl kind: ops::BitOr<kind,kind> {\n-    pure fn bitor(other: kind) -> kind {\n-        unsafe {\n-            raise_kind(self, other)\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl kind : ops::BitOr<kind,kind> {\n     pure fn bitor(other: &kind) -> kind {\n         unsafe {\n@@ -1930,16 +1832,6 @@ impl kind : ops::BitOr<kind,kind> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl kind: ops::Sub<kind,kind> {\n-    pure fn sub(other: kind) -> kind {\n-        unsafe {\n-            kind_(*self & !*other)\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl kind : ops::Sub<kind,kind> {\n     pure fn sub(other: &kind) -> kind {\n         unsafe {\n@@ -4040,88 +3932,27 @@ pure fn determine_inherited_purity(parent_purity: ast::purity,\n     } else { child_purity }\n }\n \n-#[cfg(stage0)]\n-impl mt : cmp::Eq {\n-    pure fn eq(&&other: mt) -> bool {\n-        self.ty == other.ty && self.mutbl == other.mutbl\n-    }\n-    pure fn ne(&&other: mt) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl mt : cmp::Eq {\n     pure fn eq(other: &mt) -> bool {\n         self.ty == (*other).ty && self.mutbl == (*other).mutbl\n     }\n     pure fn ne(other: &mt) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl arg : cmp::Eq {\n-    pure fn eq(&&other: arg) -> bool {\n-        self.mode == other.mode && self.ty == other.ty\n-    }\n-    pure fn ne(&&other: arg) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl arg : cmp::Eq {\n     pure fn eq(other: &arg) -> bool {\n         self.mode == (*other).mode && self.ty == (*other).ty\n     }\n     pure fn ne(other: &arg) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl field : cmp::Eq {\n-    pure fn eq(&&other: field) -> bool {\n-        self.ident == other.ident && self.mt == other.mt\n-    }\n-    pure fn ne(&&other: field) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl field : cmp::Eq {\n     pure fn eq(other: &field) -> bool {\n         self.ident == (*other).ident && self.mt == (*other).mt\n     }\n     pure fn ne(other: &field) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl vstore : cmp::Eq {\n-    pure fn eq(&&other: vstore) -> bool {\n-        match self {\n-            vstore_fixed(e0a) => {\n-                match other {\n-                    vstore_fixed(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            vstore_uniq => {\n-                match other {\n-                    vstore_uniq => true,\n-                    _ => false\n-                }\n-            }\n-            vstore_box => {\n-                match other {\n-                    vstore_box => true,\n-                    _ => false\n-                }\n-            }\n-            vstore_slice(e0a) => {\n-                match other {\n-                    vstore_slice(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: vstore) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl vstore : cmp::Eq {\n     pure fn eq(other: &vstore) -> bool {\n         match self {\n@@ -4154,18 +3985,6 @@ impl vstore : cmp::Eq {\n     pure fn ne(other: &vstore) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl FnMeta : cmp::Eq {\n-    pure fn eq(&&other: FnMeta) -> bool {\n-        self.purity == other.purity &&\n-        self.proto == other.proto &&\n-        self.bounds == other.bounds &&\n-        self.ret_style == other.ret_style\n-    }\n-    pure fn ne(&&other: FnMeta) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl FnMeta : cmp::Eq {\n     pure fn eq(other: &FnMeta) -> bool {\n         self.purity == (*other).purity &&\n@@ -4176,16 +3995,6 @@ impl FnMeta : cmp::Eq {\n     pure fn ne(other: &FnMeta) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl FnSig : cmp::Eq {\n-    pure fn eq(&&other: FnSig) -> bool {\n-        self.inputs == other.inputs &&\n-        self.output == other.output\n-    }\n-    pure fn ne(&&other: FnSig) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl FnSig : cmp::Eq {\n     pure fn eq(other: &FnSig) -> bool {\n         self.inputs == (*other).inputs &&\n@@ -4194,110 +4003,33 @@ impl FnSig : cmp::Eq {\n     pure fn ne(other: &FnSig) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl<M: cmp::Eq> FnTyBase<M> : cmp::Eq {\n-    pure fn eq(&&other: FnTyBase<M>) -> bool {\n-        self.meta == other.meta && self.sig == other.sig\n-    }\n-    pure fn ne(&&other: FnTyBase<M>) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<M: cmp::Eq> FnTyBase<M> : cmp::Eq {\n     pure fn eq(other: &FnTyBase<M>) -> bool {\n         self.meta == (*other).meta && self.sig == (*other).sig\n     }\n     pure fn ne(other: &FnTyBase<M>) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl TyVid: cmp::Eq {\n-    pure fn eq(&&other: TyVid) -> bool { *self == *other }\n-    pure fn ne(&&other: TyVid) -> bool { *self != *other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl TyVid : cmp::Eq {\n     pure fn eq(other: &TyVid) -> bool { *self == *(*other) }\n     pure fn ne(other: &TyVid) -> bool { *self != *(*other) }\n }\n \n-#[cfg(stage0)]\n-impl IntVid: cmp::Eq {\n-    pure fn eq(&&other: IntVid) -> bool { *self == *other }\n-    pure fn ne(&&other: IntVid) -> bool { *self != *other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl IntVid : cmp::Eq {\n     pure fn eq(other: &IntVid) -> bool { *self == *(*other) }\n     pure fn ne(other: &IntVid) -> bool { *self != *(*other) }\n }\n \n-#[cfg(stage0)]\n-impl FnVid: cmp::Eq {\n-    pure fn eq(&&other: FnVid) -> bool { *self == *other }\n-    pure fn ne(&&other: FnVid) -> bool { *self != *other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl FnVid : cmp::Eq {\n     pure fn eq(other: &FnVid) -> bool { *self == *(*other) }\n     pure fn ne(other: &FnVid) -> bool { *self != *(*other) }\n }\n \n-#[cfg(stage0)]\n-impl RegionVid: cmp::Eq {\n-    pure fn eq(&&other: RegionVid) -> bool { *self == *other }\n-    pure fn ne(&&other: RegionVid) -> bool { *self != *other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl RegionVid : cmp::Eq {\n     pure fn eq(other: &RegionVid) -> bool { *self == *(*other) }\n     pure fn ne(other: &RegionVid) -> bool { *self != *(*other) }\n }\n \n-#[cfg(stage0)]\n-impl region : cmp::Eq {\n-    pure fn eq(&&other: region) -> bool {\n-        match self {\n-            re_bound(e0a) => {\n-                match other {\n-                    re_bound(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            re_free(e0a, e1a) => {\n-                match other {\n-                    re_free(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            re_scope(e0a) => {\n-                match other {\n-                    re_scope(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            re_static => {\n-                match other {\n-                    re_static => true,\n-                    _ => false\n-                }\n-            }\n-            re_var(e0a) => {\n-                match other {\n-                    re_var(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: region) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl region : cmp::Eq {\n     pure fn eq(other: &region) -> bool {\n         match self {\n@@ -4336,40 +4068,6 @@ impl region : cmp::Eq {\n     pure fn ne(other: &region) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl bound_region : cmp::Eq {\n-    pure fn eq(&&other: bound_region) -> bool {\n-        match self {\n-            br_self => {\n-                match other {\n-                    br_self => true,\n-                    _ => false\n-                }\n-            }\n-            br_anon(e0a) => {\n-                match other {\n-                    br_anon(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            br_named(e0a) => {\n-                match other {\n-                    br_named(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            br_cap_avoid(e0a, e1a) => {\n-                match other {\n-                    br_cap_avoid(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: bound_region) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl bound_region : cmp::Eq {\n     pure fn eq(other: &bound_region) -> bool {\n         match self {\n@@ -4402,17 +4100,6 @@ impl bound_region : cmp::Eq {\n     pure fn ne(other: &bound_region) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl substs : cmp::Eq {\n-    pure fn eq(&&other: substs) -> bool {\n-        self.self_r == other.self_r &&\n-        self.self_ty == other.self_ty &&\n-        self.tps == other.tps\n-    }\n-    pure fn ne(&&other: substs) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl substs : cmp::Eq {\n     pure fn eq(other: &substs) -> bool {\n         self.self_r == (*other).self_r &&\n@@ -4422,183 +4109,13 @@ impl substs : cmp::Eq {\n     pure fn ne(other: &substs) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl InferTy : cmp::Eq {\n-    pure fn eq(&&other: InferTy) -> bool {\n-        self.to_hash() == other.to_hash()\n-    }\n-    pure fn ne(&&other: InferTy) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl InferTy : cmp::Eq {\n     pure fn eq(other: &InferTy) -> bool {\n         self.to_hash() == (*other).to_hash()\n     }\n     pure fn ne(other: &InferTy) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl sty : cmp::Eq {\n-    pure fn eq(&&other: sty) -> bool {\n-        match self {\n-            ty_nil => {\n-                match other {\n-                    ty_nil => true,\n-                    _ => false\n-                }\n-            }\n-            ty_bot => {\n-                match other {\n-                    ty_bot => true,\n-                    _ => false\n-                }\n-            }\n-            ty_bool => {\n-                match other {\n-                    ty_bool => true,\n-                    _ => false\n-                }\n-            }\n-            ty_int(e0a) => {\n-                match other {\n-                    ty_int(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_uint(e0a) => {\n-                match other {\n-                    ty_uint(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_float(e0a) => {\n-                match other {\n-                    ty_float(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_estr(e0a) => {\n-                match other {\n-                    ty_estr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_enum(e0a, e1a) => {\n-                match other {\n-                    ty_enum(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_box(e0a) => {\n-                match other {\n-                    ty_box(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_uniq(e0a) => {\n-                match other {\n-                    ty_uniq(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_evec(e0a, e1a) => {\n-                match other {\n-                    ty_evec(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_ptr(e0a) => {\n-                match other {\n-                    ty_ptr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_rptr(e0a, e1a) => {\n-                match other {\n-                    ty_rptr(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_rec(e0a) => {\n-                match other {\n-                    ty_rec(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_fn(e0a) => {\n-                match other {\n-                    ty_fn(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_trait(e0a, e1a, e2a) => {\n-                match other {\n-                    ty_trait(e0b, e1b, e2b) =>\n-                        e0a == e0b && e1a == e1b && e2a == e2b,\n-                    _ => false\n-                }\n-            }\n-            ty_class(e0a, e1a) => {\n-                match other {\n-                    ty_class(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_tup(e0a) => {\n-                match other {\n-                    ty_tup(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_infer(e0a) => {\n-                match other {\n-                    ty_infer(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_param(e0a) => {\n-                match other {\n-                    ty_param(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_self => {\n-                match other {\n-                    ty_self => true,\n-                    _ => false\n-                }\n-            }\n-            ty_type => {\n-                match other {\n-                    ty_type => true,\n-                    _ => false\n-                }\n-            }\n-            ty_opaque_box => {\n-                match other {\n-                    ty_opaque_box => true,\n-                    _ => false\n-                }\n-            }\n-            ty_opaque_closure_ptr(e0a) => {\n-                match other {\n-                    ty_opaque_closure_ptr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_unboxed_vec(e0a) => {\n-                match other {\n-                    ty_unboxed_vec(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: sty) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl sty : cmp::Eq {\n     pure fn eq(other: &sty) -> bool {\n         match self {\n@@ -4758,46 +4275,6 @@ impl sty : cmp::Eq {\n     pure fn ne(other: &sty) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl param_bound : cmp::Eq {\n-    pure fn eq(&&other: param_bound) -> bool {\n-        match self {\n-            bound_copy => {\n-                match other {\n-                    bound_copy => true,\n-                    _ => false\n-                }\n-            }\n-            bound_owned => {\n-                match other {\n-                    bound_owned => true,\n-                    _ => false\n-                }\n-            }\n-            bound_send => {\n-                match other {\n-                    bound_send => true,\n-                    _ => false\n-                }\n-            }\n-            bound_const => {\n-                match other {\n-                    bound_const => true,\n-                    _ => false\n-                }\n-            }\n-            bound_trait(e0a) => {\n-                match other {\n-                    bound_trait(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: param_bound) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl param_bound : cmp::Eq {\n     pure fn eq(other: &param_bound) -> bool {\n         match self {\n@@ -4836,13 +4313,6 @@ impl param_bound : cmp::Eq {\n     pure fn ne(other: &param_bound) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl kind : cmp::Eq {\n-    pure fn eq(&&other: kind) -> bool { *self == *other }\n-    pure fn ne(&&other: kind) -> bool { *self != *other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl kind : cmp::Eq {\n     pure fn eq(other: &kind) -> bool { *self == *(*other) }\n     pure fn ne(other: &kind) -> bool { *self != *(*other) }"}, {"sha": "c03128724884e90e910c5ec792e91f1e4fde366a", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -329,28 +329,6 @@ enum Constraint {\n     ConstrainVarSubReg(RegionVid, region)\n }\n \n-#[cfg(stage0)]\n-impl Constraint: cmp::Eq {\n-    pure fn eq(&&other: Constraint) -> bool {\n-        match (self, other) {\n-            (ConstrainVarSubVar(v0a, v1a), ConstrainVarSubVar(v0b, v1b)) => {\n-                v0a == v0b && v1a == v1b\n-            }\n-            (ConstrainRegSubVar(ra, va), ConstrainRegSubVar(rb, vb)) => {\n-                ra == rb && va == vb\n-            }\n-            (ConstrainVarSubReg(va, ra), ConstrainVarSubReg(vb, rb)) => {\n-                va == vb && ra == rb\n-            }\n-            (ConstrainVarSubVar(*), _) => false,\n-            (ConstrainRegSubVar(*), _) => false,\n-            (ConstrainVarSubReg(*), _) => false\n-        }\n-    }\n-    pure fn ne(&&other: Constraint) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Constraint : cmp::Eq {\n     pure fn eq(other: &Constraint) -> bool {\n         match (self, (*other)) {\n@@ -391,15 +369,6 @@ struct TwoRegions {\n     b: region,\n }\n \n-#[cfg(stage0)]\n-impl TwoRegions: cmp::Eq {\n-    pure fn eq(&&other: TwoRegions) -> bool {\n-        self.a == other.a && self.b == other.b\n-    }\n-    pure fn ne(&&other: TwoRegions) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl TwoRegions : cmp::Eq {\n     pure fn eq(other: &TwoRegions) -> bool {\n         self.a == (*other).a && self.b == (*other).b\n@@ -786,15 +755,6 @@ priv impl RegionVarBindings {\n \n enum Direction { Incoming = 0, Outgoing = 1 }\n \n-#[cfg(stage0)]\n-impl Direction : cmp::Eq {\n-    pure fn eq(&&other: Direction) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: Direction) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Direction : cmp::Eq {\n     pure fn eq(other: &Direction) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -804,15 +764,6 @@ impl Direction : cmp::Eq {\n \n enum Classification { Expanding, Contracting }\n \n-#[cfg(stage0)]\n-impl Classification : cmp::Eq {\n-    pure fn eq(&&other: Classification) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: Classification) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Classification : cmp::Eq {\n     pure fn eq(other: &Classification) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "b95e16570435bc2276e6222c7c5e7321b45d769e", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -18,15 +18,6 @@ enum OutputFormat {\n     PandocHtml\n }\n \n-#[cfg(stage0)]\n-impl OutputFormat : cmp::Eq {\n-    pure fn eq(&&other: OutputFormat) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: OutputFormat) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl OutputFormat : cmp::Eq {\n     pure fn eq(other: &OutputFormat) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -42,15 +33,6 @@ enum OutputStyle {\n     DocPerMod\n }\n \n-#[cfg(stage0)]\n-impl OutputStyle : cmp::Eq {\n-    pure fn eq(&&other: OutputStyle) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: OutputStyle) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl OutputStyle : cmp::Eq {\n     pure fn eq(other: &OutputStyle) -> bool {\n         (self as uint) == ((*other) as uint)"}, {"sha": "82bddf11d1617354582a91680d9f458abae0b9c4", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 0, "deletions": 258, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -6,15 +6,6 @@ type Doc_ = {\n     pages: ~[Page]\n };\n \n-#[cfg(stage0)]\n-impl Doc_ : cmp::Eq {\n-    pure fn eq(&&other: Doc_) -> bool {\n-        self.pages == other.pages\n-    }\n-    pure fn ne(&&other: Doc_) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Doc_ : cmp::Eq {\n     pure fn eq(other: &Doc_) -> bool {\n         self.pages == (*other).pages\n@@ -26,13 +17,6 @@ enum Doc {\n     Doc_(Doc_)\n }\n \n-#[cfg(stage0)]\n-impl Doc : cmp::Eq {\n-    pure fn eq(&&other: Doc) -> bool { *self == *other }\n-    pure fn ne(&&other: Doc) -> bool { *self != *other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Doc : cmp::Eq {\n     pure fn eq(other: &Doc) -> bool { *self == *(*other) }\n     pure fn ne(other: &Doc) -> bool { *self != *(*other) }\n@@ -43,28 +27,6 @@ enum Page {\n     ItemPage(ItemTag)\n }\n \n-#[cfg(stage0)]\n-impl Page : cmp::Eq {\n-    pure fn eq(&&other: Page) -> bool {\n-        match self {\n-            CratePage(e0a) => {\n-                match other {\n-                    CratePage(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ItemPage(e0a) => {\n-                match other {\n-                    ItemPage(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: Page) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Page : cmp::Eq {\n     pure fn eq(other: &Page) -> bool {\n         match self {\n@@ -90,15 +52,6 @@ enum Implementation {\n     Provided,\n }\n \n-#[cfg(stage0)]\n-impl Implementation : cmp::Eq {\n-    pure fn eq(&&other: Implementation) -> bool {\n-        (self as uint) == (other as uint)\n-    }\n-    pure fn ne(&&other: Implementation) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Implementation : cmp::Eq {\n     pure fn eq(other: &Implementation) -> bool {\n         (self as uint) == ((*other) as uint)\n@@ -116,15 +69,6 @@ type Section = {\n     body: ~str\n };\n \n-#[cfg(stage0)]\n-impl Section : cmp::Eq {\n-    pure fn eq(&&other: Section) -> bool {\n-        self.header == other.header && self.body == other.body\n-    }\n-    pure fn ne(&&other: Section) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Section : cmp::Eq {\n     pure fn eq(other: &Section) -> bool {\n         self.header == (*other).header && self.body == (*other).body\n@@ -139,15 +83,6 @@ type CrateDoc = {\n     topmod: ModDoc,\n };\n \n-#[cfg(stage0)]\n-impl CrateDoc : cmp::Eq {\n-    pure fn eq(&&other: CrateDoc) -> bool {\n-        self.topmod == other.topmod\n-    }\n-    pure fn ne(&&other: CrateDoc) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl CrateDoc : cmp::Eq {\n     pure fn eq(other: &CrateDoc) -> bool {\n         self.topmod == (*other).topmod\n@@ -167,70 +102,6 @@ enum ItemTag {\n     StructTag(StructDoc)\n }\n \n-#[cfg(stage0)]\n-impl ItemTag : cmp::Eq {\n-    pure fn eq(&&other: ItemTag) -> bool {\n-        match self {\n-            ModTag(e0a) => {\n-                match other {\n-                    ModTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            NmodTag(e0a) => {\n-                match other {\n-                    NmodTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ConstTag(e0a) => {\n-                match other {\n-                    ConstTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            FnTag(e0a) => {\n-                match other {\n-                    FnTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            EnumTag(e0a) => {\n-                match other {\n-                    EnumTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            TraitTag(e0a) => {\n-                match other {\n-                    TraitTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ImplTag(e0a) => {\n-                match other {\n-                    ImplTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            TyTag(e0a) => {\n-                match other {\n-                    TyTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            StructTag(e0a) => {\n-                match other {\n-                    StructTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&&other: ItemTag) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ItemTag : cmp::Eq {\n     pure fn eq(other: &ItemTag) -> bool {\n         match self {\n@@ -304,21 +175,6 @@ type ItemDoc = {\n     reexport: bool\n };\n \n-#[cfg(stage0)]\n-impl ItemDoc : cmp::Eq {\n-    pure fn eq(&&other: ItemDoc) -> bool {\n-        self.id == other.id &&\n-        self.name == other.name &&\n-        self.path == other.path &&\n-        self.brief == other.brief &&\n-        self.desc == other.desc &&\n-        self.sections == other.sections &&\n-        self.reexport == other.reexport\n-    }\n-    pure fn ne(&&other: ItemDoc) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ItemDoc : cmp::Eq {\n     pure fn eq(other: &ItemDoc) -> bool {\n         self.id == (*other).id &&\n@@ -337,15 +193,6 @@ type SimpleItemDoc = {\n     sig: Option<~str>\n };\n \n-#[cfg(stage0)]\n-impl SimpleItemDoc : cmp::Eq {\n-    pure fn eq(&&other: SimpleItemDoc) -> bool {\n-        self.item == other.item && self.sig == other.sig\n-    }\n-    pure fn ne(&&other: SimpleItemDoc) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl SimpleItemDoc : cmp::Eq {\n     pure fn eq(other: &SimpleItemDoc) -> bool {\n         self.item == (*other).item && self.sig == (*other).sig\n@@ -359,17 +206,6 @@ type ModDoc_ = {\n     index: Option<Index>\n };\n \n-#[cfg(stage0)]\n-impl ModDoc_ : cmp::Eq {\n-    pure fn eq(&&other: ModDoc_) -> bool {\n-        self.item == other.item &&\n-        self.items == other.items &&\n-        self.index == other.index\n-    }\n-    pure fn ne(&&other: ModDoc_) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ModDoc_ : cmp::Eq {\n     pure fn eq(other: &ModDoc_) -> bool {\n         self.item == (*other).item &&\n@@ -383,13 +219,6 @@ enum ModDoc {\n     ModDoc_(ModDoc_)\n }\n \n-#[cfg(stage0)]\n-impl ModDoc : cmp::Eq {\n-    pure fn eq(&&other: ModDoc) -> bool { *self == *other }\n-    pure fn ne(&&other: ModDoc) -> bool { *self != *other }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ModDoc : cmp::Eq {\n     pure fn eq(other: &ModDoc) -> bool { *self == *(*other) }\n     pure fn ne(other: &ModDoc) -> bool { *self != *(*other) }\n@@ -401,17 +230,6 @@ type NmodDoc = {\n     index: Option<Index>\n };\n \n-#[cfg(stage0)]\n-impl NmodDoc : cmp::Eq {\n-    pure fn eq(&&other: NmodDoc) -> bool {\n-        self.item == other.item &&\n-        self.fns == other.fns &&\n-        self.index == other.index\n-    }\n-    pure fn ne(&&other: NmodDoc) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl NmodDoc : cmp::Eq {\n     pure fn eq(other: &NmodDoc) -> bool {\n         self.item == (*other).item &&\n@@ -430,15 +248,6 @@ type EnumDoc = {\n     variants: ~[VariantDoc]\n };\n \n-#[cfg(stage0)]\n-impl EnumDoc : cmp::Eq {\n-    pure fn eq(&&other: EnumDoc) -> bool {\n-        self.item == other.item && self.variants == other.variants\n-    }\n-    pure fn ne(&&other: EnumDoc) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl EnumDoc : cmp::Eq {\n     pure fn eq(other: &EnumDoc) -> bool {\n         self.item == (*other).item && self.variants == (*other).variants\n@@ -452,17 +261,6 @@ type VariantDoc = {\n     sig: Option<~str>\n };\n \n-#[cfg(stage0)]\n-impl VariantDoc : cmp::Eq {\n-    pure fn eq(&&other: VariantDoc) -> bool {\n-        self.name == other.name &&\n-        self.desc == other.desc &&\n-        self.sig == other.sig\n-    }\n-    pure fn ne(&&other: VariantDoc) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl VariantDoc : cmp::Eq {\n     pure fn eq(other: &VariantDoc) -> bool {\n         self.name == (*other).name &&\n@@ -477,15 +275,6 @@ type TraitDoc = {\n     methods: ~[MethodDoc]\n };\n \n-#[cfg(stage0)]\n-impl TraitDoc : cmp::Eq {\n-    pure fn eq(&&other: TraitDoc) -> bool {\n-        self.item == other.item && self.methods == other.methods\n-    }\n-    pure fn ne(&&other: TraitDoc) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl TraitDoc : cmp::Eq {\n     pure fn eq(other: &TraitDoc) -> bool {\n         self.item == (*other).item && self.methods == (*other).methods\n@@ -502,20 +291,6 @@ type MethodDoc = {\n     implementation: Implementation,\n };\n \n-#[cfg(stage0)]\n-impl MethodDoc : cmp::Eq {\n-    pure fn eq(&&other: MethodDoc) -> bool {\n-        self.name == other.name &&\n-        self.brief == other.brief &&\n-        self.desc == other.desc &&\n-        self.sections == other.sections &&\n-        self.sig == other.sig &&\n-        self.implementation == other.implementation\n-    }\n-    pure fn ne(&&other: MethodDoc) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl MethodDoc : cmp::Eq {\n     pure fn eq(other: &MethodDoc) -> bool {\n         self.name == (*other).name &&\n@@ -535,18 +310,6 @@ type ImplDoc = {\n     methods: ~[MethodDoc]\n };\n \n-#[cfg(stage0)]\n-impl ImplDoc : cmp::Eq {\n-    pure fn eq(&&other: ImplDoc) -> bool {\n-        self.item == other.item &&\n-        self.trait_types == other.trait_types &&\n-        self.self_ty == other.self_ty &&\n-        self.methods == other.methods\n-    }\n-    pure fn ne(&&other: ImplDoc) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ImplDoc : cmp::Eq {\n     pure fn eq(other: &ImplDoc) -> bool {\n         self.item == (*other).item &&\n@@ -578,15 +341,6 @@ type Index = {\n     entries: ~[IndexEntry]\n };\n \n-#[cfg(stage0)]\n-impl Index : cmp::Eq {\n-    pure fn eq(&&other: Index) -> bool {\n-        self.entries == other.entries\n-    }\n-    pure fn ne(&&other: Index) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Index : cmp::Eq {\n     pure fn eq(other: &Index) -> bool {\n         self.entries == (*other).entries\n@@ -611,18 +365,6 @@ type IndexEntry = {\n     link: ~str\n };\n \n-#[cfg(stage0)]\n-impl IndexEntry : cmp::Eq {\n-    pure fn eq(&&other: IndexEntry) -> bool {\n-        self.kind == other.kind &&\n-        self.name == other.name &&\n-        self.brief == other.brief &&\n-        self.link == other.link\n-    }\n-    pure fn ne(&&other: IndexEntry) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl IndexEntry : cmp::Eq {\n     pure fn eq(other: &IndexEntry) -> bool {\n         self.kind == (*other).kind &&"}, {"sha": "a978f9cc73b8f0c54577e7eebedbcc4c89e02861", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -1,3 +1,11 @@\n+S 2012-09-23 92752a4\n+  macos-i386 0d5130364e8610413c9da965ca5ce6967f32ab3d\n+  macos-x86_64 a0bc17c9025c509b0ecfb35d04e35b8b232f2687\n+  freebsd-x86_64 6568c5ab6199e0e24fb442511ccb2ebad8eb4785\n+  linux-i386 685318ae8cd618eff60b51015ebe51b34383072b\n+  linux-x86_64 d8893f7c2be05bf18fbda26e65a151446251a3bd\n+  winnt-i386 23f8a9d0d788cdcc0a69a3276adb457cf4aa474f\n+\n S 2012-09-12 fa74edf\n   macos-i386 da38aa39fd1515ea765790a3c320194bc50fd602\n   macos-x86_64 7509861e5a6d3e082ad9a9d3474661856b7731c1"}, {"sha": "75b8872d848a993144e10ec93185fbfe6bff58ff", "filename": "src/test/compile-fail/borrowck-loan-in-overloaded-op.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -2,14 +2,6 @@\n \n enum foo = ~uint;\n \n-#[cfg(stage0)]\n-impl foo: Add<foo, foo> {\n-    pure fn add(f: foo) -> foo {\n-        foo(~(**self + **f))\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl foo : Add<foo, foo> {\n     pure fn add(f: &foo) -> foo {\n         foo(~(**self + **(*f)))"}, {"sha": "af1f42be2575d9c31a796a18fc608eab82e85110", "filename": "src/test/compile-fail/borrowck-loan-rcvr-overloaded-op.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -8,14 +8,6 @@ struct Point {\n     y: int,\n }\n \n-#[cfg(stage0)]\n-impl Point : ops::Add<int,int> {\n-    pure fn add(&&z: int) -> int {\n-        self.x + self.y + z\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl Point : ops::Add<int,int> {\n     pure fn add(z: &int) -> int {\n         self.x + self.y + (*z)"}, {"sha": "576496e736c2614b0b617573b4bebfa01a7f9ff5", "filename": "src/test/compile-fail/issue-2587-2.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Ftest%2Fcompile-fail%2Fissue-2587-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91f8a5698e7767ddfbf90c665c08dcd4f0de0/src%2Ftest%2Fcompile-fail%2Fissue-2587-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2587-2.rs?ref=afd91f8a5698e7767ddfbf90c665c08dcd4f0de0", "patch": "@@ -16,14 +16,6 @@ struct S {\n \n fn S(x: int) -> S { S { x: x } }\n \n-#[cfg(stage0)]\n-impl S: Add<S, S> {\n-    pure fn add(rhs: S) -> S {\n-        S { x: self.x + rhs.x }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl S : Add<S, S> {\n     pure fn add(rhs: &S) -> S {\n         S { x: self.x + (*rhs).x }"}]}