{"sha": "76fb7d90ecde3659021341779fea598a6daab013", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZmI3ZDkwZWNkZTM2NTkwMjEzNDE3NzlmZWE1OThhNmRhYWIwMTM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-10-03T18:39:21Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-10-26T19:41:17Z"}, "message": "remove StaticInliner and NaN checking\n\nNaN checking was a lint for a deprecated feature. It can go away.", "tree": {"sha": "deb904e289d86521621c143267d58068797df5af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deb904e289d86521621c143267d58068797df5af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76fb7d90ecde3659021341779fea598a6daab013", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76fb7d90ecde3659021341779fea598a6daab013", "html_url": "https://github.com/rust-lang/rust/commit/76fb7d90ecde3659021341779fea598a6daab013", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76fb7d90ecde3659021341779fea598a6daab013/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37418b850f43fd95596c688c230f5e8d94e1962f", "url": "https://api.github.com/repos/rust-lang/rust/commits/37418b850f43fd95596c688c230f5e8d94e1962f", "html_url": "https://github.com/rust-lang/rust/commit/37418b850f43fd95596c688c230f5e8d94e1962f"}], "stats": {"total": 458, "additions": 184, "deletions": 274}, "files": [{"sha": "d70deb2f862d98617466678113c51967ca8fcf30", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76fb7d90ecde3659021341779fea598a6daab013/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fb7d90ecde3659021341779fea598a6daab013/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=76fb7d90ecde3659021341779fea598a6daab013", "patch": "@@ -40,12 +40,10 @@ use std::cmp::Ordering;\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator, repeat};\n \n-pub fn lower_pat<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: &Pat)\n-                           -> &'a Pattern<'tcx>\n+pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pattern<'tcx>)\n+                                -> &'a Pattern<'tcx>\n {\n-    cx.pattern_arena.alloc(\n-        LiteralExpander.fold_pattern(&Pattern::from_hir(cx.tcx, pat))\n-    )\n+    cx.pattern_arena.alloc(LiteralExpander.fold_pattern(&pat))\n }\n \n struct LiteralExpander;"}, {"sha": "8021b36975a4249e92b3b20fea02a108c92c0b69", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 61, "deletions": 153, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/76fb7d90ecde3659021341779fea598a6daab013/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fb7d90ecde3659021341779fea598a6daab013/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=76fb7d90ecde3659021341779fea598a6daab013", "patch": "@@ -8,20 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use _match::{MatchCheckCtxt, Matrix, lower_pat, is_useful};\n+use _match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n use _match::{DUMMY_WILD_PAT};\n use _match::Usefulness::*;\n use _match::WitnessPreference::*;\n \n+use pattern::{Pattern, PatternContext, PatternError};\n+\n use eval::report_const_eval_err;\n-use eval::{eval_const_expr_partial, const_expr_to_pat, lookup_const_by_id};\n-use eval::EvalHint::ExprTypeChecked;\n \n use rustc::dep_graph::DepNode;\n \n use rustc::hir::pat_util::{pat_bindings, pat_contains_bindings};\n \n-use rustc::middle::const_val::ConstVal;\n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n@@ -39,9 +38,7 @@ use rustc::hir::{self, Pat, PatKind};\n use rustc_back::slice;\n \n use syntax::ast;\n-use syntax::codemap::Spanned;\n use syntax::ptr::P;\n-use syntax::util::move_map::MoveMap;\n use syntax_pos::Span;\n \n struct OuterVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n@@ -80,9 +77,6 @@ impl<'a, 'v, 'tcx> Visitor<'v> for OuterVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> OuterVisitor<'a, 'tcx> {\n-}\n-\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.visit_all_items_in_krate(DepNode::MatchCheck, &mut OuterVisitor { tcx: tcx });\n     tcx.sess.abort_if_errors();\n@@ -112,8 +106,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchVisitor<'a, 'tcx> {\n     fn visit_local(&mut self, loc: &hir::Local) {\n         intravisit::walk_local(self, loc);\n \n-        let pat = StaticInliner::new(self.tcx).fold_pat(loc.pat.clone());\n-        self.check_irrefutable(&pat, false);\n+        self.check_irrefutable(&loc.pat, false);\n \n         // Check legality of move bindings and `@` patterns.\n         self.check_patterns(false, slice::ref_slice(&loc.pat));\n@@ -138,6 +131,27 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n         }\n     }\n \n+    fn report_inlining_errors(&self, patcx: PatternContext, pat_span: Span) {\n+        for error in patcx.errors {\n+            match error {\n+                PatternError::BadConstInPattern(span, def_id) => {\n+                    self.tcx.sess.span_err(\n+                        span,\n+                        &format!(\"constants of the type `{}` \\\n+                                  cannot be used in patterns\",\n+                                 self.tcx.item_path_str(def_id)));\n+                }\n+                PatternError::StaticInPattern(span) => {\n+                    span_err!(self.tcx.sess, span, E0158,\n+                              \"statics cannot be referenced in patterns\");\n+                }\n+                PatternError::ConstEval(err) => {\n+                    report_const_eval_err(self.tcx, &err, pat_span, \"pattern\").emit();\n+                }\n+            }\n+        }\n+    }\n+\n     fn check_match(\n         &self,\n         scrut: &hir::Expr,\n@@ -154,32 +168,36 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             if let Some(ref guard) = arm.guard {\n                 check_for_mutation_in_guard(self, &guard);\n             }\n-        }\n-\n-        let mut static_inliner = StaticInliner::new(self.tcx);\n-        let inlined_arms = arms.iter().map(|arm| {\n-            (arm.pats.iter().map(|pat| {\n-                static_inliner.fold_pat((*pat).clone())\n-            }).collect(), arm.guard.as_ref().map(|e| &**e))\n-        }).collect::<Vec<(Vec<P<Pat>>, Option<&hir::Expr>)>>();\n \n-        // Bail out early if inlining failed.\n-        if static_inliner.failed {\n-            return;\n+            // Third, perform some lints.\n+            for pat in &arm.pats {\n+                check_for_bindings_named_the_same_as_variants(self, pat);\n+            }\n         }\n \n-        for pat in inlined_arms.iter().flat_map(|&(ref pats, _)| pats) {\n-            // Fourth, check if there are any references to NaN that we should warn about.\n-            check_for_static_nan(self, &pat);\n+        MatchCheckCtxt::create_and_enter(self.tcx, |ref cx| {\n+            let mut have_errors = false;\n+\n+            let inlined_arms : Vec<(Vec<_>, _)> = arms.iter().map(|arm| (\n+                arm.pats.iter().map(|pat| {\n+                    let mut patcx = PatternContext::new(self.tcx);\n+                    let pattern = expand_pattern(cx, patcx.lower_pattern(&pat));\n+                    if !patcx.errors.is_empty() {\n+                        self.report_inlining_errors(patcx, pat.span);\n+                        have_errors = true;\n+                    }\n+                    (pattern, &**pat)\n+                }).collect(),\n+                arm.guard.as_ref().map(|e| &**e)\n+            )).collect();\n \n-            // Fifth, check if for any of the patterns that match an enumerated type\n-            // are bindings with the same name as one of the variants of said type.\n-            check_for_bindings_named_the_same_as_variants(self, &pat);\n-        }\n+            // Bail out early if inlining failed.\n+            if have_errors {\n+                return;\n+            }\n \n-        MatchCheckCtxt::create_and_enter(self.tcx, |ref cx| {\n             // Fourth, check for unreachable arms.\n-            check_arms(cx, &inlined_arms[..], source);\n+            check_arms(cx, &inlined_arms, source);\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n@@ -204,7 +222,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 .iter()\n                 .filter(|&&(_, guard)| guard.is_none())\n                 .flat_map(|arm| &arm.0)\n-                .map(|pat| vec![lower_pat(cx, &pat)])\n+                .map(|pat| vec![pat.0])\n                 .collect();\n             check_exhaustive(cx, scrut.span, &matrix, source);\n         })\n@@ -218,8 +236,9 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n         };\n \n         MatchCheckCtxt::create_and_enter(self.tcx, |ref cx| {\n+            let mut patcx = PatternContext::new(self.tcx);\n             let pats : Matrix = vec![vec![\n-                lower_pat(cx, pat)\n+                expand_pattern(cx, patcx.lower_pattern(pat))\n             ]].into_iter().collect();\n \n             let witness = match is_useful(cx, &pats, &[cx.wild_pattern], ConstructWitness) {\n@@ -269,27 +288,6 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     });\n }\n \n-// Check that we do not match against a static NaN (#6804)\n-fn check_for_static_nan(cx: &MatchVisitor, pat: &Pat) {\n-    pat.walk(|p| {\n-        if let PatKind::Lit(ref expr) = p.node {\n-            match eval_const_expr_partial(cx.tcx, &expr, ExprTypeChecked, None) {\n-                Ok(ConstVal::Float(f)) if f.is_nan() => {\n-                    span_warn!(cx.tcx.sess, p.span, E0003,\n-                               \"unmatchable NaN in pattern, \\\n-                                use the is_nan method in a guard instead\");\n-                }\n-                Ok(_) => {}\n-\n-                Err(err) => {\n-                    report_const_eval_err(cx.tcx, &err, p.span, \"pattern\").emit();\n-                }\n-            }\n-        }\n-        true\n-    });\n-}\n-\n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n fn pat_is_catchall(dm: &DefMap, pat: &Pat) -> bool {\n     match pat.node {\n@@ -304,15 +302,16 @@ fn pat_is_catchall(dm: &DefMap, pat: &Pat) -> bool {\n }\n \n // Check for unreachable patterns\n-fn check_arms(cx: &MatchCheckCtxt,\n-              arms: &[(Vec<P<Pat>>, Option<&hir::Expr>)],\n-              source: hir::MatchSource) {\n+fn check_arms<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n+                        arms: &[(Vec<(&Pattern<'tcx>, &'a hir::Pat)>, Option<&hir::Expr>)],\n+                        source: hir::MatchSource)\n+{\n     let mut seen = Matrix::empty();\n     let mut catchall = None;\n     let mut printed_if_let_err = false;\n     for &(ref pats, guard) in arms {\n-        for pat in pats {\n-            let v = vec![lower_pat(cx, &pat)];\n+        for &(pat, hir_pat) in pats {\n+            let v = vec![pat];\n \n             match is_useful(cx, &seen, &v[..], LeaveOutWitness) {\n                 NotUseful => {\n@@ -325,7 +324,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n                                 // find the first arm pattern so we can use its span\n                                 let &(ref first_arm_pats, _) = &arms[0];\n                                 let first_pat = &first_arm_pats[0];\n-                                let span = first_pat.span;\n+                                let span = first_pat.0.span;\n                                 struct_span_err!(cx.tcx.sess, span, E0162,\n                                                 \"irrefutable if-let pattern\")\n                                     .span_label(span, &format!(\"irrefutable pattern\"))\n@@ -338,7 +337,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n                             // find the first arm pattern so we can use its span\n                             let &(ref first_arm_pats, _) = &arms[0];\n                             let first_pat = &first_arm_pats[0];\n-                            let span = first_pat.span;\n+                            let span = first_pat.0.span;\n                             struct_span_err!(cx.tcx.sess, span, E0165,\n                                              \"irrefutable while-let pattern\")\n                                 .span_label(span, &format!(\"irrefutable pattern\"))\n@@ -374,7 +373,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n             }\n             if guard.is_none() {\n                 seen.push(v);\n-                if catchall.is_none() && pat_is_catchall(&cx.tcx.def_map.borrow(), pat) {\n+                if catchall.is_none() && pat_is_catchall(&cx.tcx.def_map.borrow(), hir_pat) {\n                     catchall = Some(pat.span);\n                 }\n             }\n@@ -448,97 +447,6 @@ fn check_exhaustive<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     }\n }\n \n-\n-struct StaticInliner<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    failed: bool\n-}\n-\n-impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n-    pub fn new<'b>(tcx: TyCtxt<'b, 'tcx, 'tcx>) -> StaticInliner<'b, 'tcx> {\n-        StaticInliner {\n-            tcx: tcx,\n-            failed: false\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n-    fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n-        match pat.node {\n-            PatKind::Path(..) => {\n-                match self.tcx.expect_def(pat.id) {\n-                    Def::AssociatedConst(did) | Def::Const(did) => {\n-                        let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n-                        if let Some((const_expr, _)) = lookup_const_by_id(self.tcx, did, substs) {\n-                            match const_expr_to_pat(self.tcx, const_expr, pat.id, pat.span) {\n-                                Ok(new_pat) => return new_pat,\n-                                Err(def_id) => {\n-                                    self.failed = true;\n-                                    self.tcx.sess.span_err(\n-                                        pat.span,\n-                                        &format!(\"constants of the type `{}` \\\n-                                                  cannot be used in patterns\",\n-                                                 self.tcx.item_path_str(def_id)));\n-                                }\n-                            }\n-                        } else {\n-                            self.failed = true;\n-                            span_err!(self.tcx.sess, pat.span, E0158,\n-                                \"statics cannot be referenced in patterns\");\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        pat.map(|Pat { id, node, span }| {\n-            let node = match node {\n-                PatKind::Binding(binding_mode, pth1, sub) => {\n-                    PatKind::Binding(binding_mode, pth1, sub.map(|x| self.fold_pat(x)))\n-                }\n-                PatKind::TupleStruct(pth, pats, ddpos) => {\n-                    PatKind::TupleStruct(pth, pats.move_map(|x| self.fold_pat(x)), ddpos)\n-                }\n-                PatKind::Struct(pth, fields, etc) => {\n-                    let fs = fields.move_map(|f| {\n-                        Spanned {\n-                            span: f.span,\n-                            node: hir::FieldPat {\n-                                name: f.node.name,\n-                                pat: self.fold_pat(f.node.pat),\n-                                is_shorthand: f.node.is_shorthand,\n-                            },\n-                        }\n-                    });\n-                    PatKind::Struct(pth, fs, etc)\n-                }\n-                PatKind::Tuple(elts, ddpos) => {\n-                    PatKind::Tuple(elts.move_map(|x| self.fold_pat(x)), ddpos)\n-                }\n-                PatKind::Box(inner) => PatKind::Box(self.fold_pat(inner)),\n-                PatKind::Ref(inner, mutbl) => PatKind::Ref(self.fold_pat(inner), mutbl),\n-                PatKind::Slice(before, slice, after) => {\n-                    PatKind::Slice(before.move_map(|x| self.fold_pat(x)),\n-                                   slice.map(|x| self.fold_pat(x)),\n-                                   after.move_map(|x| self.fold_pat(x)))\n-                }\n-                PatKind::Wild |\n-                PatKind::Lit(_) |\n-                PatKind::Range(..) |\n-                PatKind::Path(..) => node\n-            };\n-            Pat {\n-                id: id,\n-                node: node,\n-                span: span\n-            }\n-        })\n-    }\n-}\n-\n // Legality of move bindings checking\n fn check_legality_of_move_bindings(cx: &MatchVisitor,\n                                    has_guard: bool,"}, {"sha": "f70583db70a60e483c1f8b145f631fac99c793d4", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76fb7d90ecde3659021341779fea598a6daab013/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fb7d90ecde3659021341779fea598a6daab013/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=76fb7d90ecde3659021341779fea598a6daab013", "patch": "@@ -71,7 +71,7 @@ fn foo(x: Option<String>) {\n \"##,*/\n \n \n-E0003: r##\"\n+/*E0003: r##\"\n Not-a-Number (NaN) values cannot be compared for equality and hence can never\n match the input to a match expression. So, the following will not compile:\n \n@@ -100,7 +100,7 @@ match number {\n }\n ```\n \"##,\n-\n+*/\n \n E0004: r##\"\n This error indicates that the compiler cannot guarantee a matching pattern for"}, {"sha": "c02cca0da72255e5662fff0eda1086dfe1693517", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76fb7d90ecde3659021341779fea598a6daab013/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fb7d90ecde3659021341779fea598a6daab013/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=76fb7d90ecde3659021341779fea598a6daab013", "patch": "@@ -392,7 +392,7 @@ pub fn note_const_eval_err<'a, 'tcx>(\n \n pub fn eval_const_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  e: &Expr) -> ConstVal {\n-    match eval_const_expr_partial(tcx, e, ExprTypeChecked, None) {\n+    match eval_const_expr_checked(tcx, e) {\n         Ok(r) => r,\n         // non-const path still needs to be a fatal error, because enums are funky\n         Err(s) => {\n@@ -407,15 +407,21 @@ pub fn eval_const_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+pub fn eval_const_expr_checked<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                         e: &Expr) -> EvalResult\n+{\n+    eval_const_expr_partial(tcx, e, ExprTypeChecked, None)\n+}\n+\n pub type FnArgMap<'a> = Option<&'a NodeMap<ConstVal>>;\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct ConstEvalErr {\n     pub span: Span,\n     pub kind: ErrKind,\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub enum ErrKind {\n     CannotCast,\n     CannotCastTo(&'static str),"}, {"sha": "4bd797afd0682c43353b2c21546e9733303f5967", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 108, "deletions": 68, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/76fb7d90ecde3659021341779fea598a6daab013/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fb7d90ecde3659021341779fea598a6daab013/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=76fb7d90ecde3659021341779fea598a6daab013", "patch": "@@ -15,6 +15,7 @@ use rustc::mir::repr::{Field, BorrowKind, Mutability};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::Def;\n+use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -23,6 +24,13 @@ use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n+#[derive(Clone, Debug)]\n+pub enum PatternError {\n+    StaticInPattern(Span),\n+    BadConstInPattern(Span, DefId),\n+    ConstEval(eval::ConstEvalErr),\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub enum BindingMode<'tcx> {\n     ByValue,\n@@ -97,78 +105,112 @@ pub enum PatternKind<'tcx> {\n     },\n }\n \n+pub struct PatternContext<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub errors: Vec<PatternError>,\n+}\n+\n impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n     pub fn from_hir(tcx: TyCtxt<'a, 'gcx, 'tcx>, pat: &hir::Pat) -> Self {\n-        let mut ty = tcx.node_id_to_type(pat.id);\n+        let mut pcx = PatternContext::new(tcx);\n+        let result = pcx.lower_pattern(pat);\n+        if !pcx.errors.is_empty() {\n+            span_bug!(pat.span, \"encountered errors lowering pattern: {:?}\", pcx.errors)\n+        }\n+        result\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        PatternContext { tcx: tcx, errors: vec![] }\n+    }\n+\n+    pub fn lower_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n+        let mut ty = self.tcx.node_id_to_type(pat.id);\n \n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n \n             PatKind::Lit(ref value) => {\n-                let value = eval::eval_const_expr(tcx.global_tcx(), value);\n-                PatternKind::Constant { value: value }\n+                match eval::eval_const_expr_checked(self.tcx.global_tcx(), value) {\n+                    Ok(value) => {\n+                        PatternKind::Constant { value: value }\n+                    }\n+                    Err(e) => {\n+                        self.errors.push(PatternError::ConstEval(e));\n+                        PatternKind::Wild\n+                    }\n+                }\n             }\n \n             PatKind::Range(ref lo, ref hi) => {\n-                let lo = eval::eval_const_expr(tcx.global_tcx(), lo);\n-                let hi = eval::eval_const_expr(tcx.global_tcx(), hi);\n-                PatternKind::Range { lo: lo, hi: hi }\n-            },\n+                let r_lo = eval::eval_const_expr_checked(self.tcx.global_tcx(), lo);\n+                if let Err(ref e_lo) = r_lo {\n+                    self.errors.push(PatternError::ConstEval(e_lo.clone()));\n+                }\n+\n+                let r_hi = eval::eval_const_expr_checked(self.tcx.global_tcx(), hi);\n+                if let Err(ref e_hi) = r_hi {\n+                    self.errors.push(PatternError::ConstEval(e_hi.clone()));\n+                }\n+\n+                if let (Ok(lo), Ok(hi)) = (r_lo, r_hi) {\n+                    PatternKind::Range { lo: lo, hi: hi }\n+                } else {\n+                    PatternKind::Wild\n+                }\n+            }\n \n             PatKind::Path(..) => {\n-                match tcx.expect_def(pat.id) {\n+                match self.tcx.expect_def(pat.id) {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                        let tcx = tcx.global_tcx();\n-                        let substs = Some(tcx.node_id_item_substs(pat.id).substs);\n+                        let tcx = self.tcx.global_tcx();\n+                        let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n                         match eval::lookup_const_by_id(tcx, def_id, substs) {\n                             Some((const_expr, _const_ty)) => {\n-                                match eval::const_expr_to_pat(tcx,\n-                                                              const_expr,\n-                                                              pat.id,\n-                                                              pat.span) {\n-                                    Ok(pat) =>\n-                                        return Pattern::from_hir(tcx, &pat),\n-                                    Err(_) =>\n-                                        span_bug!(\n-                                            pat.span, \"illegal constant\"),\n+                                match eval::const_expr_to_pat(\n+                                    tcx, const_expr, pat.id, pat.span)\n+                                {\n+                                    Ok(pat) => return self.lower_pattern(&pat),\n+                                    Err(_) => {\n+                                        self.errors.push(PatternError::BadConstInPattern(\n+                                            pat.span, def_id));\n+                                        PatternKind::Wild\n+                                    }\n                                 }\n                             }\n                             None => {\n-                                span_bug!(\n-                                    pat.span,\n-                                    \"cannot eval constant: {:?}\",\n-                                    def_id)\n+                                self.errors.push(PatternError::StaticInPattern(pat.span));\n+                                PatternKind::Wild\n                             }\n                         }\n                     }\n-                    _ => {\n-                        PatternKind::from_variant_or_leaf(tcx, pat, vec![])\n-                    }\n+                    _ => self.lower_variant_or_leaf(pat, vec![])\n                 }\n             }\n \n             PatKind::Ref(ref subpattern, _) |\n             PatKind::Box(ref subpattern) => {\n-                PatternKind::Deref { subpattern: Self::from_hir(tcx, subpattern) }\n+                PatternKind::Deref { subpattern: self.lower_pattern(subpattern) }\n             }\n \n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n-                let ty = tcx.node_id_to_type(pat.id);\n+                let ty = self.tcx.node_id_to_type(pat.id);\n                 match ty.sty {\n                     ty::TyRef(_, mt) =>\n                         PatternKind::Deref {\n                             subpattern: Pattern {\n                                 ty: mt.ty,\n                                 span: pat.span,\n-                                kind: Box::new(PatternKind::from_slice_or_array(\n-                                    tcx, pat.span, mt.ty, prefix, slice, suffix))\n+                                kind: Box::new(self.slice_or_array_pattern(\n+                                    pat.span, mt.ty, prefix, slice, suffix))\n                             },\n                         },\n \n                     ty::TySlice(..) |\n                     ty::TyArray(..) =>\n-                        PatternKind::from_slice_or_array(\n-                            tcx, pat.span, ty, prefix, slice, suffix),\n+                        self.slice_or_array_pattern(pat.span, ty, prefix, slice, suffix),\n \n                     ref sty =>\n                         span_bug!(\n@@ -179,14 +221,14 @@ impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n             }\n \n             PatKind::Tuple(ref subpatterns, ddpos) => {\n-                match tcx.node_id_to_type(pat.id).sty {\n+                match self.tcx.node_id_to_type(pat.id).sty {\n                     ty::TyTuple(ref tys) => {\n                         let subpatterns =\n                             subpatterns.iter()\n                                        .enumerate_and_adjust(tys.len(), ddpos)\n                                        .map(|(i, subpattern)| FieldPattern {\n                                             field: Field::new(i),\n-                                            pattern: Self::from_hir(tcx, subpattern),\n+                                            pattern: self.lower_pattern(subpattern)\n                                        })\n                                        .collect();\n \n@@ -198,9 +240,9 @@ impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n             }\n \n             PatKind::Binding(bm, ref ident, ref sub) => {\n-                let def_id = tcx.expect_def(pat.id).def_id();\n-                let id = tcx.map.as_local_node_id(def_id).unwrap();\n-                let var_ty = tcx.node_id_to_type(pat.id);\n+                let def_id = self.tcx.expect_def(pat.id).def_id();\n+                let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n+                let var_ty = self.tcx.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n                     _ => None,\n@@ -232,31 +274,31 @@ impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n                     name: ident.node,\n                     var: id,\n                     ty: var_ty,\n-                    subpattern: Self::from_opt_pattern(tcx, sub),\n+                    subpattern: self.lower_opt_pattern(sub),\n                 }\n             }\n \n             PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n-                let pat_ty = tcx.node_id_to_type(pat.id);\n+                let pat_ty = self.tcx.node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n                 };\n-                let variant_def = adt_def.variant_of_def(tcx.expect_def(pat.id));\n+                let variant_def = adt_def.variant_of_def(self.tcx.expect_def(pat.id));\n \n                 let subpatterns =\n                         subpatterns.iter()\n                                    .enumerate_and_adjust(variant_def.fields.len(), ddpos)\n                                    .map(|(i, field)| FieldPattern {\n                                        field: Field::new(i),\n-                                       pattern: Self::from_hir(tcx, field),\n+                                       pattern: self.lower_pattern(field),\n                                    })\n                                    .collect();\n-                PatternKind::from_variant_or_leaf(tcx, pat, subpatterns)\n+                self.lower_variant_or_leaf(pat, subpatterns)\n             }\n \n             PatKind::Struct(_, ref fields, _) => {\n-                let pat_ty = tcx.node_id_to_type(pat.id);\n+                let pat_ty = self.tcx.node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {\n@@ -265,7 +307,7 @@ impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n                             \"struct pattern not applied to an ADT\");\n                     }\n                 };\n-                let variant_def = adt_def.variant_of_def(tcx.expect_def(pat.id));\n+                let variant_def = adt_def.variant_of_def(self.tcx.expect_def(pat.id));\n \n                 let subpatterns =\n                     fields.iter()\n@@ -279,12 +321,12 @@ impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n                               });\n                               FieldPattern {\n                                   field: Field::new(index),\n-                                  pattern: Self::from_hir(tcx, &field.node.pat),\n+                                  pattern: self.lower_pattern(&field.node.pat),\n                               }\n                           })\n                           .collect();\n \n-                PatternKind::from_variant_or_leaf(tcx, pat, subpatterns)\n+                self.lower_variant_or_leaf(pat, subpatterns)\n             }\n         };\n \n@@ -295,62 +337,60 @@ impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n         }\n     }\n \n-    fn from_patterns(tcx: TyCtxt<'a, 'gcx, 'tcx>, pats: &[P<hir::Pat>]) -> Vec<Self> {\n-        pats.iter().map(|p| Self::from_hir(tcx, p)).collect()\n+    fn lower_patterns(&mut self, pats: &[P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n+        pats.iter().map(|p| self.lower_pattern(p)).collect()\n     }\n \n-    fn from_opt_pattern(tcx: TyCtxt<'a, 'gcx, 'tcx>, pat: &Option<P<hir::Pat>>) -> Option<Self>\n+    fn lower_opt_pattern(&mut self, pat: &Option<P<hir::Pat>>) -> Option<Pattern<'tcx>>\n     {\n-        pat.as_ref().map(|p| Self::from_hir(tcx, p))\n+        pat.as_ref().map(|p| self.lower_pattern(p))\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> PatternKind<'tcx> {\n-    fn from_slice_or_array(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn slice_or_array_pattern(\n+        &mut self,\n         span: Span,\n         ty: Ty<'tcx>,\n         prefix: &[P<hir::Pat>],\n         slice: &Option<P<hir::Pat>>,\n         suffix: &[P<hir::Pat>])\n-        -> Self\n+        -> PatternKind<'tcx>\n     {\n         match ty.sty {\n             ty::TySlice(..) => {\n                 // matching a slice or fixed-length array\n                 PatternKind::Slice {\n-                    prefix: Pattern::from_patterns(tcx, prefix),\n-                    slice: Pattern::from_opt_pattern(tcx, slice),\n-                    suffix: Pattern::from_patterns(tcx, suffix),\n+                    prefix: self.lower_patterns(prefix),\n+                    slice: self.lower_opt_pattern(slice),\n+                    suffix: self.lower_patterns(suffix),\n                 }\n             }\n \n             ty::TyArray(_, len) => {\n                 // fixed-length array\n                 assert!(len >= prefix.len() + suffix.len());\n                 PatternKind::Array {\n-                    prefix: Pattern::from_patterns(tcx, prefix),\n-                    slice: Pattern::from_opt_pattern(tcx, slice),\n-                    suffix: Pattern::from_patterns(tcx, suffix),\n+                    prefix: self.lower_patterns(prefix),\n+                    slice: self.lower_opt_pattern(slice),\n+                    suffix: self.lower_patterns(suffix),\n                 }\n             }\n \n             _ => {\n-                span_bug!(span, \"unexpanded macro or bad constant etc\");\n+                span_bug!(span, \"bad slice pattern type {:?}\", ty);\n             }\n         }\n     }\n \n-    fn from_variant_or_leaf(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn lower_variant_or_leaf(\n+        &mut self,\n         pat: &hir::Pat,\n         subpatterns: Vec<FieldPattern<'tcx>>)\n-        -> Self\n+        -> PatternKind<'tcx>\n     {\n-        match tcx.expect_def(pat.id) {\n+        match self.tcx.expect_def(pat.id) {\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n-                let enum_id = tcx.parent_def_id(variant_id).unwrap();\n-                let adt_def = tcx.lookup_adt_def(enum_id);\n+                let enum_id = self.tcx.parent_def_id(variant_id).unwrap();\n+                let adt_def = self.tcx.lookup_adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n                     PatternKind::Variant {\n                         adt_def: adt_def,"}, {"sha": "9b045ed1d02cce60d8eeb7d203bd58557e14896e", "filename": "src/test/compile-fail/const-eval-overflow-2.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76fb7d90ecde3659021341779fea598a6daab013/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fb7d90ecde3659021341779fea598a6daab013/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs?ref=76fb7d90ecde3659021341779fea598a6daab013", "patch": "@@ -21,10 +21,6 @@ const NEG_128: i8 = -128;\n const NEG_NEG_128: i8 = -NEG_128;\n //~^ ERROR constant evaluation error\n //~| attempt to negate with overflow\n-//~| ERROR constant evaluation error\n-//~| attempt to negate with overflow\n-//~| ERROR constant evaluation error\n-//~| attempt to negate with overflow\n \n fn main() {\n     match -128i8 {"}, {"sha": "b40aa2a8e27dcdf67c250265c17081355c165dcc", "filename": "src/test/compile-fail/const-pattern-not-const-evaluable.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76fb7d90ecde3659021341779fea598a6daab013/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fb7d90ecde3659021341779fea598a6daab013/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs?ref=76fb7d90ecde3659021341779fea598a6daab013", "patch": "@@ -19,9 +19,7 @@ use Cake::*;\n const BOO: (Cake, Cake) = (Marmor, BlackForest);\n //~^ ERROR: constant evaluation error [E0080]\n //~| unimplemented constant expression: enum variants\n-//~^^^ ERROR: constant evaluation error [E0080]\n-//~| unimplemented constant expression: enum variants\n-const FOO: Cake = BOO.1; //~ NOTE for expression here\n+const FOO: Cake = BOO.1;\n \n const fn foo() -> Cake {\n     Marmor"}, {"sha": "f6b7e13c4f5e9328593e8bab6c99e8b233d8ffac", "filename": "src/test/compile-fail/issue-6804.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/37418b850f43fd95596c688c230f5e8d94e1962f/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37418b850f43fd95596c688c230f5e8d94e1962f/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs?ref=37418b850f43fd95596c688c230f5e8d94e1962f", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(rustc_attrs)]\n-#![feature(slice_patterns)]\n-#![allow(dead_code)]\n-\n-// Matching against NaN should result in a warning\n-\n-use std::f64::NAN;\n-\n-#[rustc_error]\n-fn main() { //~ ERROR compilation successful\n-    let x = NAN;\n-    match x {\n-        NAN => {},\n-        _ => {},\n-    };\n-    //~^^^ WARNING unmatchable NaN in pattern, use the is_nan method in a guard instead\n-    //~| WARNING floating point constants cannot be used\n-    //~| WARNING this was previously accepted\n-    match [x, 1.0] {\n-        [NAN, _] => {},\n-        _ => {},\n-    };\n-    //~^^^ WARNING unmatchable NaN in pattern, use the is_nan method in a guard instead\n-    //~| WARNING floating point constants cannot be used\n-    //~| WARNING this was previously accepted\n-}"}]}