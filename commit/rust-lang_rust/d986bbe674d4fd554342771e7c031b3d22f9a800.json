{"sha": "d986bbe674d4fd554342771e7c031b3d22f9a800", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ODZiYmU2NzRkNGZkNTU0MzQyNzcxZTdjMDMxYjNkMjJmOWE4MDA=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-02T09:12:47Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-05T04:53:34Z"}, "message": "Implement stackless expansion.", "tree": {"sha": "ac78bfa43f050f5aae67bc577aded5807a178604", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac78bfa43f050f5aae67bc577aded5807a178604"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d986bbe674d4fd554342771e7c031b3d22f9a800", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d986bbe674d4fd554342771e7c031b3d22f9a800", "html_url": "https://github.com/rust-lang/rust/commit/d986bbe674d4fd554342771e7c031b3d22f9a800", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d986bbe674d4fd554342771e7c031b3d22f9a800/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c07ff8d26a6d5c8728419ae4e870b3a65940efbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c07ff8d26a6d5c8728419ae4e870b3a65940efbc", "html_url": "https://github.com/rust-lang/rust/commit/c07ff8d26a6d5c8728419ae4e870b3a65940efbc"}], "stats": {"total": 369, "additions": 191, "deletions": 178}, "files": [{"sha": "edd38ea23e2fd9ecee40ec5407d38f6587b1874c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d986bbe674d4fd554342771e7c031b3d22f9a800/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d986bbe674d4fd554342771e7c031b3d22f9a800/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=d986bbe674d4fd554342771e7c031b3d22f9a800", "patch": "@@ -646,7 +646,6 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn bt_push(&mut self, ei: ExpnInfo) {\n-        self.recursion_count += 1;\n         if self.recursion_count > self.ecfg.recursion_limit {\n             self.span_fatal(ei.call_site,\n                             &format!(\"recursion limit reached while expanding the macro `{}`\",\n@@ -660,17 +659,7 @@ impl<'a> ExtCtxt<'a> {\n             callee: ei.callee\n         });\n     }\n-    pub fn bt_pop(&mut self) {\n-        match self.backtrace {\n-            NO_EXPANSION => self.bug(\"tried to pop without a push\"),\n-            expn_id => {\n-                self.recursion_count -= 1;\n-                self.backtrace = self.codemap().with_expn_info(expn_id, |expn_info| {\n-                    expn_info.map_or(NO_EXPANSION, |ei| ei.call_site.expn_id)\n-                });\n-            }\n-        }\n-    }\n+    pub fn bt_pop(&mut self) {}\n \n     pub fn insert_macro(&mut self, def: ast::MacroDef) {\n         if def.export {\n@@ -799,8 +788,6 @@ impl<'a> ExtCtxt<'a> {\n             self.crate_root = Some(\"std\");\n         }\n \n-        // User extensions must be added before expander.load_macros is called,\n-        // so that macros from external crates shadow user defined extensions.\n         for (name, extension) in user_exts {\n             self.syntax_env.insert(name, extension);\n         }\n@@ -900,7 +887,7 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n /// This environment maps Names to SyntaxExtensions.\n pub struct SyntaxEnv {\n     module_data: Vec<ModuleData>,\n-    current_module: Module,\n+    pub current_module: Module,\n \n     /// All bang-style macro/extension names\n     /// encountered so far; to be used for diagnostics in resolve\n@@ -940,10 +927,6 @@ impl SyntaxEnv {\n         &self.module_data[module.0 as usize]\n     }\n \n-    pub fn set_current_module(&mut self, module: Module) -> Module {\n-        ::std::mem::replace(&mut self.current_module, module)\n-    }\n-\n     pub fn paths(&self) -> Rc<ModulePaths> {\n         self.data(self.current_module).paths.clone()\n     }\n@@ -994,8 +977,6 @@ impl SyntaxEnv {\n     }\n \n     pub fn is_crate_root(&mut self) -> bool {\n-        // The first frame is pushed in `SyntaxEnv::new()` and the second frame is\n-        // pushed when folding the crate root pseudo-module (c.f. noop_fold_crate).\n-        self.current_module.0 <= 1\n+        self.current_module == Module(0)\n     }\n }"}, {"sha": "5624c2634661a6ae4947e181e2a0b5504774ceea", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 182, "deletions": 151, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/d986bbe674d4fd554342771e7c031b3d22f9a800/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d986bbe674d4fd554342771e7c031b3d22f9a800/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d986bbe674d4fd554342771e7c031b3d22f9a800", "patch": "@@ -12,7 +12,7 @@ use ast::{Block, Crate, Ident, Mac_, PatKind};\n use ast::{MacStmtStyle, StmtKind, ItemKind};\n use ast;\n use ext::hygiene::Mark;\n-use ext::placeholders;\n+use ext::placeholders::{self, placeholder, PlaceholderExpander};\n use attr::{self, HasAttrs};\n use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use syntax_pos::{self, Span, ExpnId};\n@@ -28,11 +28,13 @@ use util::small_vector::SmallVector;\n use visit;\n use visit::Visitor;\n \n+use std::collections::HashMap;\n+use std::mem;\n use std::path::PathBuf;\n use std::rc::Rc;\n \n macro_rules! expansions {\n-    ($($kind:ident: $ty:ty, $kind_name:expr, .$make:ident,\n+    ($($kind:ident: $ty:ty [$($vec:ident, $ty_elt:ty)*], $kind_name:expr, .$make:ident,\n             $(.$fold:ident)*  $(lift .$fold_elt:ident)*,\n             $(.$visit:ident)* $(lift .$visit_elt:ident)*;)*) => {\n         #[derive(Copy, Clone)]\n@@ -91,18 +93,32 @@ macro_rules! expansions {\n                 }\n             }\n         }\n+\n+        impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n+            fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+                self.expand(Expansion::OptExpr(Some(expr))).make_opt_expr()\n+            }\n+            $($(fn $fold(&mut self, node: $ty) -> $ty {\n+                self.expand(Expansion::$kind(node)).$make()\n+            })*)*\n+            $($(fn $fold_elt(&mut self, node: $ty_elt) -> $ty {\n+                self.expand(Expansion::$kind(SmallVector::one(node))).$make()\n+            })*)*\n+        }\n     }\n }\n \n expansions! {\n-    Expr: P<ast::Expr>, \"expression\", .make_expr, .fold_expr, .visit_expr;\n-    Pat: P<ast::Pat>,   \"pattern\",    .make_pat,  .fold_pat,  .visit_pat;\n-    Ty: P<ast::Ty>,     \"type\",       .make_ty,   .fold_ty,   .visit_ty;\n-    Stmts: SmallVector<ast::Stmt>, \"statement\", .make_stmts, lift .fold_stmt, lift .visit_stmt;\n-    Items: SmallVector<P<ast::Item>>, \"item\",   .make_items, lift .fold_item, lift .visit_item;\n-    TraitItems: SmallVector<ast::TraitItem>,\n+    Expr: P<ast::Expr> [], \"expression\", .make_expr, .fold_expr, .visit_expr;\n+    Pat: P<ast::Pat>   [], \"pattern\",    .make_pat,  .fold_pat,  .visit_pat;\n+    Ty: P<ast::Ty>     [], \"type\",       .make_ty,   .fold_ty,   .visit_ty;\n+    Stmts: SmallVector<ast::Stmt> [SmallVector, ast::Stmt],\n+        \"statement\",  .make_stmts,       lift .fold_stmt,       lift .visit_stmt;\n+    Items: SmallVector<P<ast::Item>> [SmallVector, P<ast::Item>],\n+        \"item\",       .make_items,       lift .fold_item,       lift .visit_item;\n+    TraitItems: SmallVector<ast::TraitItem> [SmallVector, ast::TraitItem],\n         \"trait item\", .make_trait_items, lift .fold_trait_item, lift .visit_trait_item;\n-    ImplItems: SmallVector<ast::ImplItem>,\n+    ImplItems: SmallVector<ast::ImplItem> [SmallVector, ast::ImplItem],\n         \"impl item\",  .make_impl_items,  lift .fold_impl_item,  lift .visit_impl_item;\n }\n \n@@ -129,6 +145,9 @@ pub struct Invocation {\n     kind: InvocationKind,\n     expansion_kind: ExpansionKind,\n     mark: Mark,\n+    module: Module,\n+    backtrace: ExpnId,\n+    depth: usize,\n }\n \n enum InvocationKind {\n@@ -144,7 +163,6 @@ enum InvocationKind {\n     },\n }\n \n-/// A tree-folder that performs macro expansion\n pub struct MacroExpander<'a, 'b:'a> {\n     pub cx: &'a mut ExtCtxt<'b>,\n     pub single_step: bool,\n@@ -162,13 +180,57 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn strip_unconfigured(&mut self) -> StripUnconfigured {\n-        StripUnconfigured {\n+    fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n+        let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n+\n+        let items = Expansion::Items(SmallVector::many(krate.module.items));\n+        krate.module.items = self.expand(items).make_items().into();\n+        krate.exported_macros = self.cx.exported_macros.clone();\n+\n+        if self.cx.parse_sess.span_diagnostic.err_count() > err_count {\n+            self.cx.parse_sess.span_diagnostic.abort_if_errors();\n+        }\n+\n+        krate\n+    }\n+\n+    // Fully expand all the invocations in `expansion`.\n+    fn expand(&mut self, expansion: Expansion) -> Expansion {\n+        let (expansion, mut invocations) = self.collect_invocations(expansion);\n+        invocations.reverse();\n+\n+        let mut expansions = HashMap::new();\n+        while let Some(invoc) = invocations.pop() {\n+            let Invocation { mark, module, depth, backtrace, .. } = invoc;\n+            self.cx.syntax_env.current_module = module;\n+            self.cx.recursion_count = depth;\n+            self.cx.backtrace = backtrace;\n+\n+            let expansion = self.expand_invoc(invoc);\n+\n+            self.cx.syntax_env.current_module = module;\n+            self.cx.recursion_count = depth + 1;\n+            let (expansion, new_invocations) = self.collect_invocations(expansion);\n+\n+            expansions.insert(mark.as_u32(), expansion);\n+            if !self.single_step {\n+                invocations.extend(new_invocations.into_iter().rev());\n+            }\n+        }\n+\n+        expansion.fold_with(&mut PlaceholderExpander::new(expansions))\n+    }\n+\n+    fn collect_invocations(&mut self, expansion: Expansion) -> (Expansion, Vec<Invocation>) {\n+        let expansion = expansion.fold_with(&mut StripUnconfigured {\n             config: &self.cx.cfg,\n             should_test: self.cx.ecfg.should_test,\n             sess: self.cx.parse_sess,\n             features: self.cx.ecfg.features,\n-        }\n+        });\n+        self.load_macros(&expansion);\n+        let mut collector = InvocationCollector { cx: self.cx, invocations: Vec::new() };\n+        (expansion.fold_with(&mut collector), collector.invocations)\n     }\n \n     fn load_macros(&mut self, node: &Expansion) {\n@@ -210,72 +272,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         });\n     }\n \n-    fn new_invoc(&self, expansion_kind: ExpansionKind, kind: InvocationKind)\n-                 -> Invocation {\n-        Invocation { mark: Mark::fresh(), kind: kind, expansion_kind: expansion_kind }\n-    }\n-\n-    fn new_bang_invoc(\n-        &self, mac: ast::Mac, attrs: Vec<ast::Attribute>, span: Span, kind: ExpansionKind,\n-    ) -> Invocation {\n-        self.new_invoc(kind, InvocationKind::Bang {\n-            attrs: attrs,\n-            mac: mac,\n-            ident: None,\n-            span: span,\n-        })\n-    }\n-\n-    fn new_attr_invoc(&self, attr: ast::Attribute, item: Annotatable, kind: ExpansionKind)\n-                      -> Invocation {\n-        self.new_invoc(kind, InvocationKind::Attr { attr: attr, item: item })\n-    }\n-\n-    // If `item` is an attr invocation, remove and return the macro attribute.\n-    fn classify_item<T: HasAttrs>(&self, mut item: T) -> (T, Option<ast::Attribute>) {\n-        let mut attr = None;\n-        item = item.map_attrs(|mut attrs| {\n-            for i in 0..attrs.len() {\n-                if let Some(extension) = self.cx.syntax_env.find(intern(&attrs[i].name())) {\n-                    match *extension {\n-                        MultiModifier(..) | MultiDecorator(..) => {\n-                            attr = Some(attrs.remove(i));\n-                            break;\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-            attrs\n-        });\n-        (item, attr)\n-    }\n-\n-    // does this attribute list contain \"macro_use\" ?\n-    fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n-        for attr in attrs {\n-            let mut is_use = attr.check_name(\"macro_use\");\n-            if attr.check_name(\"macro_escape\") {\n-                let msg = \"macro_escape is a deprecated synonym for macro_use\";\n-                let mut err = self.cx.struct_span_warn(attr.span, msg);\n-                is_use = true;\n-                if let ast::AttrStyle::Inner = attr.node.style {\n-                    err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n-                } else {\n-                    err.emit();\n-                }\n-            };\n-\n-            if is_use {\n-                if !attr.is_word() {\n-                    self.cx.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n-                }\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n     fn expand_invoc(&mut self, invoc: Invocation) -> Expansion {\n         match invoc.kind {\n             InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc),\n@@ -305,7 +301,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n         });\n \n-        let modified = match *extension {\n+        match *extension {\n             MultiModifier(ref mac) => {\n                 let item = mac.expand(self.cx, attr.span, &attr.node.value, item);\n                 kind.expect_from_annotatables(item)\n@@ -318,12 +314,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 kind.expect_from_annotatables(items)\n             }\n             _ => unreachable!(),\n-        };\n-\n-        self.cx.bt_pop();\n-\n-        let configured = modified.fold_with(&mut self.strip_unconfigured());\n-        configured.fold_with(self)\n+        }\n     }\n \n     /// Expand a macro invocation. Returns the result of expansion.\n@@ -457,30 +448,94 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             return kind.dummy(span);\n         };\n \n-        let marked = expanded.fold_with(&mut Marker {\n+        expanded.fold_with(&mut Marker {\n+            mark: mark,\n+            expn_id: Some(self.cx.backtrace()),\n+        })\n+    }\n+}\n+\n+struct InvocationCollector<'a, 'b: 'a> {\n+    cx: &'a mut ExtCtxt<'b>,\n+    invocations: Vec<Invocation>,\n+}\n+\n+impl<'a, 'b> InvocationCollector<'a, 'b> {\n+    fn collect(&mut self, expansion_kind: ExpansionKind, kind: InvocationKind) -> Expansion {\n+        let mark = Mark::fresh();\n+        self.invocations.push(Invocation {\n+            kind: kind,\n+            expansion_kind: expansion_kind,\n             mark: mark,\n-            expn_id: Some(self.cx.backtrace())\n+            module: self.cx.syntax_env.current_module,\n+            backtrace: self.cx.backtrace,\n+            depth: self.cx.recursion_count,\n         });\n-        let configured = marked.fold_with(&mut self.strip_unconfigured());\n-        self.load_macros(&configured);\n+        placeholder(expansion_kind, mark.as_u32())\n+    }\n \n-        let fully_expanded = if self.single_step {\n-            configured\n-        } else {\n-            configured.fold_with(self)\n-        };\n+    fn collect_bang(\n+        &mut self, mac: ast::Mac, attrs: Vec<ast::Attribute>, span: Span, kind: ExpansionKind,\n+    ) -> Expansion {\n+        self.collect(kind, InvocationKind::Bang { attrs: attrs, mac: mac, ident: None, span: span })\n+    }\n \n-        self.cx.bt_pop();\n-        fully_expanded\n+    fn collect_attr(&mut self, attr: ast::Attribute, item: Annotatable, kind: ExpansionKind)\n+                    -> Expansion {\n+        self.collect(kind, InvocationKind::Attr { attr: attr, item: item })\n+    }\n+\n+    // If `item` is an attr invocation, remove and return the macro attribute.\n+    fn classify_item<T: HasAttrs>(&self, mut item: T) -> (T, Option<ast::Attribute>) {\n+        let mut attr = None;\n+        item = item.map_attrs(|mut attrs| {\n+            for i in 0..attrs.len() {\n+                if let Some(extension) = self.cx.syntax_env.find(intern(&attrs[i].name())) {\n+                    match *extension {\n+                        MultiModifier(..) | MultiDecorator(..) => {\n+                            attr = Some(attrs.remove(i));\n+                            break;\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            attrs\n+        });\n+        (item, attr)\n+    }\n+\n+    // does this attribute list contain \"macro_use\" ?\n+    fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n+        for attr in attrs {\n+            let mut is_use = attr.check_name(\"macro_use\");\n+            if attr.check_name(\"macro_escape\") {\n+                let msg = \"macro_escape is a deprecated synonym for macro_use\";\n+                let mut err = self.cx.struct_span_warn(attr.span, msg);\n+                is_use = true;\n+                if let ast::AttrStyle::Inner = attr.node.style {\n+                    err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n+                } else {\n+                    err.emit();\n+                }\n+            };\n+\n+            if is_use {\n+                if !attr.is_word() {\n+                    self.cx.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n+                }\n+                return true;\n+            }\n+        }\n+        false\n     }\n }\n \n-impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n+impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let expr = expr.unwrap();\n         if let ast::ExprKind::Mac(mac) = expr.node {\n-            let invoc = self.new_bang_invoc(mac, expr.attrs.into(), expr.span, ExpansionKind::Expr);\n-            self.expand_invoc(invoc).make_expr()\n+            self.collect_bang(mac, expr.attrs.into(), expr.span, ExpansionKind::Expr).make_expr()\n         } else {\n             P(noop_fold_expr(expr, self))\n         }\n@@ -489,9 +544,8 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         let expr = expr.unwrap();\n         if let ast::ExprKind::Mac(mac) = expr.node {\n-            let invoc =\n-                self.new_bang_invoc(mac, expr.attrs.into(), expr.span, ExpansionKind::OptExpr);\n-            self.expand_invoc(invoc).make_opt_expr()\n+            self.collect_bang(mac, expr.attrs.into(), expr.span, ExpansionKind::OptExpr)\n+                .make_opt_expr()\n         } else {\n             Some(P(noop_fold_expr(expr, self)))\n         }\n@@ -504,10 +558,8 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         }\n \n         pat.and_then(|pat| match pat.node {\n-            PatKind::Mac(mac) => {\n-                let invoc = self.new_bang_invoc(mac, Vec::new(), pat.span, ExpansionKind::Pat);\n-                self.expand_invoc(invoc).make_pat()\n-            }\n+            PatKind::Mac(mac) =>\n+                self.collect_bang(mac, Vec::new(), pat.span, ExpansionKind::Pat).make_pat(),\n             _ => unreachable!(),\n         })\n     }\n@@ -518,35 +570,34 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n             _ => return noop_fold_stmt(stmt, self),\n         };\n \n-        let invoc = self.new_bang_invoc(mac, attrs.into(), stmt.span, ExpansionKind::Stmts);\n-        let mut fully_expanded = self.expand_invoc(invoc).make_stmts();\n+        let mut placeholder =\n+            self.collect_bang(mac, attrs.into(), stmt.span, ExpansionKind::Stmts).make_stmts();\n \n         // If this is a macro invocation with a semicolon, then apply that\n         // semicolon to the final statement produced by expansion.\n         if style == MacStmtStyle::Semicolon {\n-            if let Some(stmt) = fully_expanded.pop() {\n-                fully_expanded.push(stmt.add_trailing_semicolon());\n+            if let Some(stmt) = placeholder.pop() {\n+                placeholder.push(stmt.add_trailing_semicolon());\n             }\n         }\n \n-        fully_expanded\n+        placeholder\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n         let paths = self.cx.syntax_env.paths();\n         let module = self.cx.syntax_env.add_module(false, true, paths);\n-        let orig_module = self.cx.syntax_env.set_current_module(module);\n-\n+        let orig_module = mem::replace(&mut self.cx.syntax_env.current_module, module);\n         let result = noop_fold_block(block, self);\n-        self.cx.syntax_env.set_current_module(orig_module);\n+        self.cx.syntax_env.current_module = orig_module;\n         result\n     }\n \n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         let (item, attr) = self.classify_item(item);\n         if let Some(attr) = attr {\n-            let invoc = self.new_attr_invoc(attr, Annotatable::Item(item), ExpansionKind::Items);\n-            return self.expand_invoc(invoc).make_items();\n+            let item = Annotatable::Item(item);\n+            return self.collect_attr(attr, item, ExpansionKind::Items).make_items();\n         }\n \n         match item.node {\n@@ -560,13 +611,12 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n \n                 item.and_then(|item| match item.node {\n                     ItemKind::Mac(mac) => {\n-                        let invoc = self.new_invoc(ExpansionKind::Items, InvocationKind::Bang {\n+                        self.collect(ExpansionKind::Items, InvocationKind::Bang {\n                             mac: mac,\n                             attrs: item.attrs,\n                             ident: Some(item.ident),\n                             span: item.span,\n-                        });\n-                        self.expand_invoc(invoc).make_items()\n+                        }).make_items()\n                     }\n                     _ => unreachable!(),\n                 })\n@@ -590,9 +640,9 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n                 let macro_use = self.contains_macro_use(&item.attrs);\n                 let in_block = self.cx.syntax_env.in_block();\n                 let module = self.cx.syntax_env.add_module(macro_use, in_block, Rc::new(paths));\n-                let module = self.cx.syntax_env.set_current_module(module);\n+                let module = mem::replace(&mut self.cx.syntax_env.current_module, module);\n                 let result = noop_fold_item(item, self);\n-                self.cx.syntax_env.set_current_module(module);\n+                self.cx.syntax_env.current_module = module;\n                 result\n             },\n             _ => noop_fold_item(item, self),\n@@ -603,15 +653,13 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         let (item, attr) = self.classify_item(item);\n         if let Some(attr) = attr {\n             let item = Annotatable::TraitItem(P(item));\n-            let invoc = self.new_attr_invoc(attr, item, ExpansionKind::TraitItems);\n-            return self.expand_invoc(invoc).make_trait_items();\n+            return self.collect_attr(attr, item, ExpansionKind::TraitItems).make_trait_items()\n         }\n \n         match item.node {\n             ast::TraitItemKind::Macro(mac) => {\n                 let ast::TraitItem { attrs, span, .. } = item;\n-                let invoc = self.new_bang_invoc(mac, attrs, span, ExpansionKind::TraitItems);\n-                self.expand_invoc(invoc).make_trait_items()\n+                self.collect_bang(mac, attrs, span, ExpansionKind::TraitItems).make_trait_items()\n             }\n             _ => fold::noop_fold_trait_item(item, self),\n         }\n@@ -621,15 +669,13 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         let (item, attr) = self.classify_item(item);\n         if let Some(attr) = attr {\n             let item = Annotatable::ImplItem(P(item));\n-            let invoc = self.new_attr_invoc(attr, item, ExpansionKind::ImplItems);\n-            return self.expand_invoc(invoc).make_impl_items();\n+            return self.collect_attr(attr, item, ExpansionKind::ImplItems).make_impl_items();\n         }\n \n         match item.node {\n             ast::ImplItemKind::Macro(mac) => {\n                 let ast::ImplItem { attrs, span, .. } = item;\n-                let invoc = self.new_bang_invoc(mac, attrs, span, ExpansionKind::ImplItems);\n-                self.expand_invoc(invoc).make_impl_items()\n+                self.collect_bang(mac, attrs, span, ExpansionKind::ImplItems).make_impl_items()\n             }\n             _ => fold::noop_fold_impl_item(item, self),\n         }\n@@ -642,10 +688,8 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         };\n \n         match ty.node {\n-            ast::TyKind::Mac(mac) => {\n-                let invoc = self.new_bang_invoc(mac, Vec::new(), ty.span, ExpansionKind::Ty);\n-                self.expand_invoc(invoc).make_ty()\n-            }\n+            ast::TyKind::Mac(mac) =>\n+                self.collect_bang(mac, Vec::new(), ty.span, ExpansionKind::Ty).make_ty(),\n             _ => unreachable!(),\n         }\n     }\n@@ -699,30 +743,17 @@ impl<'feat> ExpansionConfig<'feat> {\n pub fn expand_crate(cx: &mut ExtCtxt,\n                     user_exts: Vec<NamedSyntaxExtension>,\n                     c: Crate) -> Crate {\n-    let mut expander = MacroExpander::new(cx, false, false);\n-    expand_crate_with_expander(&mut expander, user_exts, c)\n+    cx.initialize(user_exts, &c);\n+    cx.expander().expand_crate(c)\n }\n \n // Expands crate using supplied MacroExpander - allows for\n // non-standard expansion behaviour (e.g. step-wise).\n pub fn expand_crate_with_expander(expander: &mut MacroExpander,\n                                   user_exts: Vec<NamedSyntaxExtension>,\n-                                  mut c: Crate) -> Crate {\n+                                  c: Crate) -> Crate {\n     expander.cx.initialize(user_exts, &c);\n-\n-    let items = Expansion::Items(SmallVector::many(c.module.items));\n-    let configured = items.fold_with(&mut expander.strip_unconfigured());\n-    expander.load_macros(&configured);\n-    c.module.items = configured.make_items().into();\n-\n-    let err_count = expander.cx.parse_sess.span_diagnostic.err_count();\n-    let mut ret = expander.fold_crate(c);\n-    if expander.cx.parse_sess.span_diagnostic.err_count() > err_count {\n-        expander.cx.parse_sess.span_diagnostic.abort_if_errors();\n-    }\n-\n-    ret.exported_macros = expander.cx.exported_macros.clone();\n-    ret\n+    expander.expand_crate(c)\n }\n \n // A Marker adds the given mark to the syntax context and"}, {"sha": "27e8eab62e11482aaa9785943dd8f8d558567bd8", "filename": "src/libsyntax/ext/hygiene.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d986bbe674d4fd554342771e7c031b3d22f9a800/src%2Flibsyntax%2Fext%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d986bbe674d4fd554342771e7c031b3d22f9a800/src%2Flibsyntax%2Fext%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fhygiene.rs?ref=d986bbe674d4fd554342771e7c031b3d22f9a800", "patch": "@@ -40,6 +40,10 @@ impl Mark {\n             ::std::mem::replace(&mut data.next_mark, next_mark)\n         })\n     }\n+\n+    pub fn as_u32(&self) -> u32 {\n+        self.0\n+    }\n }\n \n struct HygieneData {"}, {"sha": "3108296e778a2d9421e99713620513ac0e8a139e", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d986bbe674d4fd554342771e7c031b3d22f9a800/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d986bbe674d4fd554342771e7c031b3d22f9a800/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=d986bbe674d4fd554342771e7c031b3d22f9a800", "patch": "@@ -300,14 +300,11 @@ fn generate_test_harness(sess: &ParseSess,\n         }\n     });\n \n-    let mut fold = TestHarnessGenerator {\n+    TestHarnessGenerator {\n         cx: cx,\n         tests: Vec::new(),\n         tested_submods: Vec::new(),\n-    };\n-    let res = fold.fold_crate(krate);\n-    fold.cx.ext_cx.bt_pop();\n-    return res;\n+    }.fold_crate(krate)\n }\n \n /// Craft a span that will be ignored by the stability lint's"}]}