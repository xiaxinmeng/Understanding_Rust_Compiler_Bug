{"sha": "26e3363c5166effef80aa4bd22f2ea38ecc7cbc3", "node_id": "C_kwDOAAsO6NoAKDI2ZTMzNjNjNTE2NmVmZmVmODBhYTRiZDIyZjJlYTM4ZWNjN2NiYzM", "commit": {"author": {"name": "Alan Egerton", "email": "eggyal@gmail.com", "date": "2023-02-14T09:27:27Z"}, "committer": {"name": "Alan Egerton", "email": "eggyal@gmail.com", "date": "2023-02-14T12:14:58Z"}, "message": "Refactor refcounted structural_impls via functors", "tree": {"sha": "a5e0ef0eff1455eb85333464de1955859f993431", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5e0ef0eff1455eb85333464de1955859f993431"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26e3363c5166effef80aa4bd22f2ea38ecc7cbc3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJFBAABCAAvFiEEvrRBFuOXsbT1OVTHfUwvbCISJTIFAmPre0IRHGVnZ3lhbEBn\nbWFpbC5jb20ACgkQfUwvbCISJTKsfg/9F3mxm3m/9gQ4SGpNC3LA69z7wWXnjmdr\nyfzXzbrqQqX4iIOH0oH0OuI9opClP1A/Bdgh5U33sCjGzhSPhMhMFa2gOGnBvdoA\nYYSAIiJiFudJtBsPm0mTpX0shENw89CFgAI4eZ9Xz//HJjP48Ljuu/lT2bCREsAJ\nSSQelLPPK8WgeaAVcxs8YktYxmKfY19K2odf4fXvB7Tzgvy9c2IVMUzDgKklNi+T\nlrdd4bkFHVlQlN0zPlqzWORxqFd7GZaAuGMBBwRsIIxQt3H3tvyhARD3q2cQWfSx\nQZmHRCFnWDxLyEvGFdFX6WwaCjZ8pr6Djxegw13Yp1OtZUnjbOFxM7qFaNQTrk/I\nRslwmtDa+DxmclYgV+7T9z/EN/PrLd3/eMEPJ+ZpEU12XC2OE0ItDl9+5YXAyaws\nood7bHgXkOKxJVW0By7ocHLWAV67VkoMndMHqCammxCvvfmsCyGZEj5AzgNen36N\ns8FV/H0u+qzIcaxebviBUlQbkr2isPW/SC+KOAC5scvM4O6Z0SAP2P8gijiMptgY\nwoNbjMgbmtnnx5joK0Bqsd5tra3T+UQZpAtoz0AkHFL4WpcMWtexucdQQMtdCiAt\ntgSfhFrCMveFmsAAafPcitVf0e2o7EXtgumNss7bAQzllOvdW5Nl7/qbPj5/NA2Z\nAZXdNoO92xg=\n=4EHU\n-----END PGP SIGNATURE-----", "payload": "tree a5e0ef0eff1455eb85333464de1955859f993431\nparent e9ab7872fd77861e3d182ea85a82c4649c5bb3f8\nauthor Alan Egerton <eggyal@gmail.com> 1676366847 +0000\ncommitter Alan Egerton <eggyal@gmail.com> 1676376898 +0000\n\nRefactor refcounted structural_impls via functors\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26e3363c5166effef80aa4bd22f2ea38ecc7cbc3", "html_url": "https://github.com/rust-lang/rust/commit/26e3363c5166effef80aa4bd22f2ea38ecc7cbc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26e3363c5166effef80aa4bd22f2ea38ecc7cbc3/comments", "author": {"login": "eggyal", "id": 3089613, "node_id": "MDQ6VXNlcjMwODk2MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3089613?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eggyal", "html_url": "https://github.com/eggyal", "followers_url": "https://api.github.com/users/eggyal/followers", "following_url": "https://api.github.com/users/eggyal/following{/other_user}", "gists_url": "https://api.github.com/users/eggyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/eggyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eggyal/subscriptions", "organizations_url": "https://api.github.com/users/eggyal/orgs", "repos_url": "https://api.github.com/users/eggyal/repos", "events_url": "https://api.github.com/users/eggyal/events{/privacy}", "received_events_url": "https://api.github.com/users/eggyal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eggyal", "id": 3089613, "node_id": "MDQ6VXNlcjMwODk2MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3089613?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eggyal", "html_url": "https://github.com/eggyal", "followers_url": "https://api.github.com/users/eggyal/followers", "following_url": "https://api.github.com/users/eggyal/following{/other_user}", "gists_url": "https://api.github.com/users/eggyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/eggyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eggyal/subscriptions", "organizations_url": "https://api.github.com/users/eggyal/orgs", "repos_url": "https://api.github.com/users/eggyal/repos", "events_url": "https://api.github.com/users/eggyal/events{/privacy}", "received_events_url": "https://api.github.com/users/eggyal/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8", "html_url": "https://github.com/rust-lang/rust/commit/e9ab7872fd77861e3d182ea85a82c4649c5bb3f8"}], "stats": {"total": 124, "additions": 55, "deletions": 69}, "files": [{"sha": "28fcf80b31beec30ecf59eb015a86c0c84f577b2", "filename": "compiler/rustc_data_structures/src/functor.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/26e3363c5166effef80aa4bd22f2ea38ecc7cbc3/compiler%2Frustc_data_structures%2Fsrc%2Ffunctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e3363c5166effef80aa4bd22f2ea38ecc7cbc3/compiler%2Frustc_data_structures%2Fsrc%2Ffunctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffunctor.rs?ref=26e3363c5166effef80aa4bd22f2ea38ecc7cbc3", "patch": "@@ -1,5 +1,5 @@\n use rustc_index::vec::{Idx, IndexVec};\n-use std::mem;\n+use std::{mem, rc::Rc, sync::Arc};\n \n pub trait IdFunctor: Sized {\n     type Inner;\n@@ -65,3 +65,52 @@ impl<I: Idx, T> IdFunctor for IndexVec<I, T> {\n         self.raw.try_map_id(f).map(IndexVec::from_raw)\n     }\n }\n+\n+macro_rules! rc {\n+    ($($rc:ident),+) => {$(\n+        impl<T: Clone> IdFunctor for $rc<T> {\n+            type Inner = T;\n+\n+            #[inline]\n+            fn try_map_id<F, E>(mut self, mut f: F) -> Result<Self, E>\n+            where\n+                F: FnMut(Self::Inner) -> Result<Self::Inner, E>,\n+            {\n+                // We merely want to replace the contained `T`, if at all possible,\n+                // so that we don't needlessly allocate a new `$rc` or indeed clone\n+                // the contained type.\n+                unsafe {\n+                    // First step is to ensure that we have a unique reference to\n+                    // the contained type, which `$rc::make_mut` will accomplish (by\n+                    // allocating a new `$rc` and cloning the `T` only if required).\n+                    // This is done *before* casting to `$rc<ManuallyDrop<T>>` so that\n+                    // panicking during `make_mut` does not leak the `T`.\n+                    $rc::make_mut(&mut self);\n+\n+                    // Casting to `$rc<ManuallyDrop<T>>` is safe because `ManuallyDrop`\n+                    // is `repr(transparent)`.\n+                    let ptr = $rc::into_raw(self).cast::<mem::ManuallyDrop<T>>();\n+                    let mut unique = $rc::from_raw(ptr);\n+\n+                    // Call to `$rc::make_mut` above guarantees that `unique` is the\n+                    // sole reference to the contained value, so we can avoid doing\n+                    // a checked `get_mut` here.\n+                    let slot = $rc::get_mut_unchecked(&mut unique);\n+\n+                    // Semantically move the contained type out from `unique`, fold\n+                    // it, then move the folded value back into `unique`. Should\n+                    // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n+                    // value is not re-dropped.\n+                    let owned = mem::ManuallyDrop::take(slot);\n+                    let folded = f(owned)?;\n+                    *slot = mem::ManuallyDrop::new(folded);\n+\n+                    // Cast back to `$rc<T>`.\n+                    Ok($rc::from_raw($rc::into_raw(unique).cast()))\n+                }\n+            }\n+        }\n+    )+};\n+}\n+\n+rc! { Rc, Arc }"}, {"sha": "a94e52fdfe604d35a257942067ca4befd1fa3bcf", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26e3363c5166effef80aa4bd22f2ea38ecc7cbc3/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e3363c5166effef80aa4bd22f2ea38ecc7cbc3/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=26e3363c5166effef80aa4bd22f2ea38ecc7cbc3", "patch": "@@ -26,6 +26,7 @@\n #![feature(test)]\n #![feature(thread_id_value)]\n #![feature(vec_into_raw_parts)]\n+#![feature(get_mut_unchecked)]\n #![allow(rustc::default_hash_types)]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]"}, {"sha": "9db1b0fd13da4edad8d193993533a89164497174", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26e3363c5166effef80aa4bd22f2ea38ecc7cbc3/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e3363c5166effef80aa4bd22f2ea38ecc7cbc3/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=26e3363c5166effef80aa4bd22f2ea38ecc7cbc3", "patch": "@@ -1,6 +1,5 @@\n #![feature(associated_type_defaults)]\n #![feature(fmt_helpers_for_derive)]\n-#![feature(get_mut_unchecked)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n #![feature(rustc_attrs)]"}, {"sha": "3ebe241042f2596e3a0fdf8d9782b106bc575e15", "filename": "compiler/rustc_type_ir/src/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 67, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/26e3363c5166effef80aa4bd22f2ea38ecc7cbc3/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e3363c5166effef80aa4bd22f2ea38ecc7cbc3/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs?ref=26e3363c5166effef80aa4bd22f2ea38ecc7cbc3", "patch": "@@ -8,7 +8,6 @@ use crate::Interner;\n use rustc_data_structures::functor::IdFunctor;\n use rustc_index::vec::{Idx, IndexVec};\n \n-use std::mem::ManuallyDrop;\n use std::ops::ControlFlow;\n use std::rc::Rc;\n use std::sync::Arc;\n@@ -98,39 +97,8 @@ EnumTypeTraversalImpl! {\n }\n \n impl<I: Interner, T: TypeFoldable<I>> TypeFoldable<I> for Rc<T> {\n-    fn try_fold_with<F: FallibleTypeFolder<I>>(mut self, folder: &mut F) -> Result<Self, F::Error> {\n-        // We merely want to replace the contained `T`, if at all possible,\n-        // so that we don't needlessly allocate a new `Rc` or indeed clone\n-        // the contained type.\n-        unsafe {\n-            // First step is to ensure that we have a unique reference to\n-            // the contained type, which `Rc::make_mut` will accomplish (by\n-            // allocating a new `Rc` and cloning the `T` only if required).\n-            // This is done *before* casting to `Rc<ManuallyDrop<T>>` so that\n-            // panicking during `make_mut` does not leak the `T`.\n-            Rc::make_mut(&mut self);\n-\n-            // Casting to `Rc<ManuallyDrop<T>>` is safe because `ManuallyDrop`\n-            // is `repr(transparent)`.\n-            let ptr = Rc::into_raw(self).cast::<ManuallyDrop<T>>();\n-            let mut unique = Rc::from_raw(ptr);\n-\n-            // Call to `Rc::make_mut` above guarantees that `unique` is the\n-            // sole reference to the contained value, so we can avoid doing\n-            // a checked `get_mut` here.\n-            let slot = Rc::get_mut_unchecked(&mut unique);\n-\n-            // Semantically move the contained type out from `unique`, fold\n-            // it, then move the folded value back into `unique`. Should\n-            // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n-            // value is not re-dropped.\n-            let owned = ManuallyDrop::take(slot);\n-            let folded = owned.try_fold_with(folder)?;\n-            *slot = ManuallyDrop::new(folded);\n-\n-            // Cast back to `Rc<T>`.\n-            Ok(Rc::from_raw(Rc::into_raw(unique).cast()))\n-        }\n+    fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|value| value.try_fold_with(folder))\n     }\n }\n \n@@ -141,39 +109,8 @@ impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for Rc<T> {\n }\n \n impl<I: Interner, T: TypeFoldable<I>> TypeFoldable<I> for Arc<T> {\n-    fn try_fold_with<F: FallibleTypeFolder<I>>(mut self, folder: &mut F) -> Result<Self, F::Error> {\n-        // We merely want to replace the contained `T`, if at all possible,\n-        // so that we don't needlessly allocate a new `Arc` or indeed clone\n-        // the contained type.\n-        unsafe {\n-            // First step is to ensure that we have a unique reference to\n-            // the contained type, which `Arc::make_mut` will accomplish (by\n-            // allocating a new `Arc` and cloning the `T` only if required).\n-            // This is done *before* casting to `Arc<ManuallyDrop<T>>` so that\n-            // panicking during `make_mut` does not leak the `T`.\n-            Arc::make_mut(&mut self);\n-\n-            // Casting to `Arc<ManuallyDrop<T>>` is safe because `ManuallyDrop`\n-            // is `repr(transparent)`.\n-            let ptr = Arc::into_raw(self).cast::<ManuallyDrop<T>>();\n-            let mut unique = Arc::from_raw(ptr);\n-\n-            // Call to `Arc::make_mut` above guarantees that `unique` is the\n-            // sole reference to the contained value, so we can avoid doing\n-            // a checked `get_mut` here.\n-            let slot = Arc::get_mut_unchecked(&mut unique);\n-\n-            // Semantically move the contained type out from `unique`, fold\n-            // it, then move the folded value back into `unique`. Should\n-            // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n-            // value is not re-dropped.\n-            let owned = ManuallyDrop::take(slot);\n-            let folded = owned.try_fold_with(folder)?;\n-            *slot = ManuallyDrop::new(folded);\n-\n-            // Cast back to `Arc<T>`.\n-            Ok(Arc::from_raw(Arc::into_raw(unique).cast()))\n-        }\n+    fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|value| value.try_fold_with(folder))\n     }\n }\n "}]}