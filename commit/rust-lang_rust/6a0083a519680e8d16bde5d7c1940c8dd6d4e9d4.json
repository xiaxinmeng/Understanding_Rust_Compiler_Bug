{"sha": "6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhMDA4M2E1MTk2ODBlOGQxNmJkZTVkN2MxOTQwYzhkZDZkNGU5ZDQ=", "commit": {"author": {"name": "Mikhail Rakhmanov", "email": "rakhmanov.m@gmail.com", "date": "2020-06-03T17:26:01Z"}, "committer": {"name": "Mikhail Rakhmanov", "email": "rakhmanov.m@gmail.com", "date": "2020-06-03T17:26:01Z"}, "message": "Merge branch 'master' into compute-lazy-assits\n\n# Conflicts:\n#\tcrates/rust-analyzer/src/main_loop/handlers.rs\n#\tcrates/rust-analyzer/src/to_proto.rs", "tree": {"sha": "2b377141d722257cfea18e74b955aea1a8f6cc1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b377141d722257cfea18e74b955aea1a8f6cc1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "html_url": "https://github.com/rust-lang/rust/commit/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/comments", "author": {"login": "mcrakhman", "id": 16068868, "node_id": "MDQ6VXNlcjE2MDY4ODY4", "avatar_url": "https://avatars.githubusercontent.com/u/16068868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcrakhman", "html_url": "https://github.com/mcrakhman", "followers_url": "https://api.github.com/users/mcrakhman/followers", "following_url": "https://api.github.com/users/mcrakhman/following{/other_user}", "gists_url": "https://api.github.com/users/mcrakhman/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcrakhman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcrakhman/subscriptions", "organizations_url": "https://api.github.com/users/mcrakhman/orgs", "repos_url": "https://api.github.com/users/mcrakhman/repos", "events_url": "https://api.github.com/users/mcrakhman/events{/privacy}", "received_events_url": "https://api.github.com/users/mcrakhman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcrakhman", "id": 16068868, "node_id": "MDQ6VXNlcjE2MDY4ODY4", "avatar_url": "https://avatars.githubusercontent.com/u/16068868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcrakhman", "html_url": "https://github.com/mcrakhman", "followers_url": "https://api.github.com/users/mcrakhman/followers", "following_url": "https://api.github.com/users/mcrakhman/following{/other_user}", "gists_url": "https://api.github.com/users/mcrakhman/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcrakhman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcrakhman/subscriptions", "organizations_url": "https://api.github.com/users/mcrakhman/orgs", "repos_url": "https://api.github.com/users/mcrakhman/repos", "events_url": "https://api.github.com/users/mcrakhman/events{/privacy}", "received_events_url": "https://api.github.com/users/mcrakhman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f7de306f547ecb394a34445fd6ac1d6bc8ab439", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f7de306f547ecb394a34445fd6ac1d6bc8ab439", "html_url": "https://github.com/rust-lang/rust/commit/1f7de306f547ecb394a34445fd6ac1d6bc8ab439"}, {"sha": "794f6da821c5d6e2490b996baffe162e4753262d", "url": "https://api.github.com/repos/rust-lang/rust/commits/794f6da821c5d6e2490b996baffe162e4753262d", "html_url": "https://github.com/rust-lang/rust/commit/794f6da821c5d6e2490b996baffe162e4753262d"}], "stats": {"total": 3020, "additions": 1191, "deletions": 1829}, "files": [{"sha": "aef0fac3397fdf8b3549df237953e0b69522d0ab", "filename": ".gitignore", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -8,3 +8,5 @@ crates/*/target\n *.iml\n .vscode/settings.json\n *.html\n+generated_assists.adoc\n+generated_features.adoc"}, {"sha": "5f88ad0c4db59cf12ce6f253ecf05a5583c10c37", "filename": "Cargo.lock", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -462,9 +462,9 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.3.2\"\n+version = \"1.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"076f042c5b7b98f31d205f1249267e12a6518c1481e9dae9764af19b707d2292\"\n+checksum = \"c398b2b113b55809ceb9ee3e753fcbac793f1956663f3c36549c1346015c2afe\"\n dependencies = [\n  \"autocfg\",\n ]\n@@ -809,19 +809,19 @@ dependencies = [\n \n [[package]]\n name = \"paste\"\n-version = \"0.1.15\"\n+version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d53181dcd37421c08d3b69f887784956674d09c3f9a47a04fece2b130a5b346b\"\n+checksum = \"d508492eeb1e5c38ee696371bf7b9fc33c83d46a7d451606b96458fbbbdc2dec\"\n dependencies = [\n  \"paste-impl\",\n  \"proc-macro-hack\",\n ]\n \n [[package]]\n name = \"paste-impl\"\n-version = \"0.1.15\"\n+version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"05ca490fa1c034a71412b4d1edcb904ec5a0981a4426c9eb2128c0fda7a68d17\"\n+checksum = \"84f328a6a63192b333fce5fbb4be79db6758a4d518dfac6d54412f1492f72d32\"\n dependencies = [\n  \"proc-macro-hack\",\n  \"proc-macro2\",\n@@ -871,9 +871,9 @@ checksum = \"7e0456befd48169b9f13ef0f0ad46d492cf9d2dbb918bcf38e01eed4ce3ec5e4\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.17\"\n+version = \"1.0.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1502d12e458c49a4c9cbff560d0fe0060c252bc29799ed94ca2ed4bb665a0101\"\n+checksum = \"beae6331a816b1f65d04c45b078fd8e6c93e8071771f41b8163255bbd8d7c8fa\"\n dependencies = [\n  \"unicode-xid\",\n ]\n@@ -1401,9 +1401,9 @@ checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n \n [[package]]\n name = \"ryu\"\n-version = \"1.0.4\"\n+version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ed3d612bc64430efeb3f7ee6ef26d590dce0c43249217bddc62112540c7941e1\"\n+checksum = \"71d301d4193d031abdd79ff7e3dd721168a9572ef3fe51a1517aba235bd8f86e\"\n \n [[package]]\n name = \"salsa\"\n@@ -1577,9 +1577,9 @@ checksum = \"ab16ced94dbd8a46c82fd81e3ed9a8727dac2977ea869d217bcc4ea1f122e81f\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.29\"\n+version = \"1.0.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bb37da98a55b1d08529362d9cbb863be17556873df2585904ab9d2bc951291d0\"\n+checksum = \"93a56fabc59dce20fe48b6c832cc249c713e7ed88fa28b0ee0a3bfcaae5fe4e2\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1640,6 +1640,7 @@ dependencies = [\n  \"relative-path\",\n  \"rustc-hash\",\n  \"serde_json\",\n+ \"stdx\",\n  \"text-size\",\n ]\n \n@@ -1798,9 +1799,9 @@ dependencies = [\n \n [[package]]\n name = \"yaml-rust\"\n-version = \"0.4.3\"\n+version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"65923dd1784f44da1d2c3dbbc5e822045628c590ba72123e1c73d3c230c4434d\"\n+checksum = \"39f0c922f1a334134dc2f7a8b67dc5d25f0735263feec974345ff706bcf20b0d\"\n dependencies = [\n  \"linked-hash-map\",\n ]"}, {"sha": "4a06f3bcddb69fa092ab1557443e837984436c0c", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -637,6 +637,10 @@ impl Function {\n         db.function_data(self.id).params.clone()\n     }\n \n+    pub fn is_unsafe(self, db: &dyn HirDatabase) -> bool {\n+        db.function_data(self.id).is_unsafe\n+    }\n+\n     pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n         let _p = profile(\"Function::diagnostics\");\n         let infer = db.infer(self.id.into());\n@@ -1190,6 +1194,10 @@ impl Type {\n         )\n     }\n \n+    pub fn is_raw_ptr(&self) -> bool {\n+        matches!(&self.ty.value, Ty::Apply(ApplicationTy { ctor: TypeCtor::RawPtr(..), .. }))\n+    }\n+\n     pub fn contains_unknown(&self) -> bool {\n         return go(&self.ty.value);\n "}, {"sha": "2eeba057299185a1b1ad308052308740de4645e9", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -87,12 +87,18 @@ impl Attrs {\n     }\n \n     pub(crate) fn new(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Attrs {\n+        let docs = ast::CommentIter::from_syntax_node(owner.syntax()).doc_comment_text().map(\n+            |docs_text| Attr {\n+                input: Some(AttrInput::Literal(SmolStr::new(docs_text))),\n+                path: ModPath::from(hir_expand::name!(doc)),\n+            },\n+        );\n         let mut attrs = owner.attrs().peekable();\n         let entries = if attrs.peek().is_none() {\n             // Avoid heap allocation\n             None\n         } else {\n-            Some(attrs.flat_map(|ast| Attr::from_src(ast, hygiene)).collect())\n+            Some(attrs.flat_map(|ast| Attr::from_src(ast, hygiene)).chain(docs).collect())\n         };\n         Attrs { entries }\n     }"}, {"sha": "807195d25ad98068bd607455d0c2543fd5973dc2", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -34,6 +34,7 @@ pub struct FunctionData {\n     /// True if the first param is `self`. This is relevant to decide whether this\n     /// can be called as a method.\n     pub has_self_param: bool,\n+    pub is_unsafe: bool,\n     pub visibility: RawVisibility,\n }\n \n@@ -85,11 +86,14 @@ impl FunctionData {\n             ret_type\n         };\n \n+        let is_unsafe = src.value.unsafe_token().is_some();\n+\n         let vis_default = RawVisibility::default_for_container(loc.container);\n         let visibility =\n             RawVisibility::from_ast_with_default(db, vis_default, src.map(|s| s.visibility()));\n \n-        let sig = FunctionData { name, params, ret_type, has_self_param, visibility, attrs };\n+        let sig =\n+            FunctionData { name, params, ret_type, has_self_param, is_unsafe, visibility, attrs };\n         Arc::new(sig)\n     }\n }"}, {"sha": "2630b3d895e60db1c6a07ffaee6cb233b37d490e", "filename": "crates/ra_hir_def/src/docs.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -29,6 +29,13 @@ impl Documentation {\n         Documentation(s.into())\n     }\n \n+    pub fn from_ast<N>(node: &N) -> Option<Documentation>\n+    where\n+        N: ast::DocCommentsOwner + ast::AttrsOwner,\n+    {\n+        docs_from_ast(node)\n+    }\n+\n     pub fn as_str(&self) -> &str {\n         &*self.0\n     }\n@@ -70,6 +77,45 @@ impl Documentation {\n     }\n }\n \n-pub(crate) fn docs_from_ast(node: &impl ast::DocCommentsOwner) -> Option<Documentation> {\n-    node.doc_comment_text().map(|it| Documentation::new(&it))\n+pub(crate) fn docs_from_ast<N>(node: &N) -> Option<Documentation>\n+where\n+    N: ast::DocCommentsOwner + ast::AttrsOwner,\n+{\n+    let doc_comment_text = node.doc_comment_text();\n+    let doc_attr_text = expand_doc_attrs(node);\n+    let docs = merge_doc_comments_and_attrs(doc_comment_text, doc_attr_text);\n+    docs.map(|it| Documentation::new(&it))\n+}\n+\n+fn merge_doc_comments_and_attrs(\n+    doc_comment_text: Option<String>,\n+    doc_attr_text: Option<String>,\n+) -> Option<String> {\n+    match (doc_comment_text, doc_attr_text) {\n+        (Some(mut comment_text), Some(attr_text)) => {\n+            comment_text.push_str(\"\\n\\n\");\n+            comment_text.push_str(&attr_text);\n+            Some(comment_text)\n+        }\n+        (Some(comment_text), None) => Some(comment_text),\n+        (None, Some(attr_text)) => Some(attr_text),\n+        (None, None) => None,\n+    }\n+}\n+\n+fn expand_doc_attrs(owner: &dyn ast::AttrsOwner) -> Option<String> {\n+    let mut docs = String::new();\n+    for attr in owner.attrs() {\n+        if let Some((\"doc\", value)) =\n+            attr.as_simple_key_value().as_ref().map(|(k, v)| (k.as_str(), v.as_str()))\n+        {\n+            docs.push_str(value);\n+            docs.push_str(\"\\n\\n\");\n+        }\n+    }\n+    if docs.is_empty() {\n+        None\n+    } else {\n+        Some(docs.trim_end_matches(\"\\n\\n\").to_owned())\n+    }\n }"}, {"sha": "660bdfe3365b2f20182ede8f1c4abd356e049669", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -153,6 +153,7 @@ pub mod known {\n         str,\n         // Special names\n         macro_rules,\n+        doc,\n         // Components of known path (value or mod name)\n         std,\n         core,"}, {"sha": "a721e23c6934544bacf9c8593bf97f7fe1823779", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -125,3 +125,81 @@ pub(crate) fn completions(\n \n     Some(acc)\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::completion_config::CompletionConfig;\n+    use crate::mock_analysis::analysis_and_position;\n+\n+    struct DetailAndDocumentation<'a> {\n+        detail: &'a str,\n+        documentation: &'a str,\n+    }\n+\n+    fn check_detail_and_documentation(fixture: &str, expected: DetailAndDocumentation) {\n+        let (analysis, position) = analysis_and_position(fixture);\n+        let config = CompletionConfig::default();\n+        let completions = analysis.completions(&config, position).unwrap().unwrap();\n+        for item in completions {\n+            if item.detail() == Some(expected.detail) {\n+                let opt = item.documentation();\n+                let doc = opt.as_ref().map(|it| it.as_str());\n+                assert_eq!(doc, Some(expected.documentation));\n+                return;\n+            }\n+        }\n+        panic!(\"completion detail not found: {}\", expected.detail)\n+    }\n+\n+    #[test]\n+    fn test_completion_detail_from_macro_generated_struct_fn_doc_attr() {\n+        check_detail_and_documentation(\n+            r#\"\n+            //- /lib.rs\n+            macro_rules! bar {\n+                () => {\n+                    struct Bar;\n+                    impl Bar {\n+                        #[doc = \"Do the foo\"]\n+                        fn foo(&self) {}\n+                    }\n+                }\n+            }\n+\n+            bar!();\n+\n+            fn foo() {\n+                let bar = Bar;\n+                bar.fo<|>;\n+            }\n+            \"#,\n+            DetailAndDocumentation { detail: \"fn foo(&self)\", documentation: \"Do the foo\" },\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_detail_from_macro_generated_struct_fn_doc_comment() {\n+        check_detail_and_documentation(\n+            r#\"\n+            //- /lib.rs\n+            macro_rules! bar {\n+                () => {\n+                    struct Bar;\n+                    impl Bar {\n+                        /// Do the foo\n+                        fn foo(&self) {}\n+                    }\n+                }\n+            }\n+\n+            bar!();\n+\n+            fn foo() {\n+                let bar = Bar;\n+                bar.fo<|>;\n+            }\n+            \"#,\n+            DetailAndDocumentation { detail: \"fn foo(&self)\", documentation: \" Do the foo\" },\n+        );\n+    }\n+}"}, {"sha": "ca8a6a650994c38f24da8ec16d9f98fe0d5aad21", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -10,7 +10,7 @@ use std::{\n use hir::{Docs, Documentation, HasSource, HirDisplay};\n use ra_ide_db::RootDatabase;\n use ra_syntax::ast::{self, AstNode, NameOwner, VisibilityOwner};\n-use stdx::SepBy;\n+use stdx::{split1, SepBy};\n \n use crate::display::{generic_parameters, where_predicates};\n \n@@ -207,7 +207,16 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n                     res.push(raw_param);\n                 }\n \n-                res.extend(param_list.params().map(|param| param.syntax().text().to_string()));\n+                // macro-generated functions are missing whitespace\n+                fn fmt_param(param: ast::Param) -> String {\n+                    let text = param.syntax().text().to_string();\n+                    match split1(&text, ':') {\n+                        Some((left, right)) => format!(\"{}: {}\", left.trim(), right.trim()),\n+                        _ => text,\n+                    }\n+                }\n+\n+                res.extend(param_list.params().map(fmt_param));\n                 res_types.extend(param_list.params().map(|param| {\n                     let param_text = param.syntax().text().to_string();\n                     match param_text.split(':').nth(1).and_then(|it| it.get(1..)) {"}, {"sha": "9636cd0d6af7ad32bec9d4dff2084933c82d639b", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 114, "deletions": 13, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -1,21 +1,16 @@\n use std::iter::once;\n \n use hir::{\n-    Adt, AsAssocItem, AssocItemContainer, FieldSource, HasSource, HirDisplay, ModuleDef,\n-    ModuleSource, Semantics,\n+    Adt, AsAssocItem, AssocItemContainer, Documentation, FieldSource, HasSource, HirDisplay,\n+    ModuleDef, ModuleSource, Semantics,\n };\n use itertools::Itertools;\n use ra_db::SourceDatabase;\n use ra_ide_db::{\n     defs::{classify_name, classify_name_ref, Definition},\n     RootDatabase,\n };\n-use ra_syntax::{\n-    ast::{self, DocCommentsOwner},\n-    match_ast, AstNode,\n-    SyntaxKind::*,\n-    SyntaxToken, TokenAtOffset,\n-};\n+use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset};\n \n use crate::{\n     display::{macro_label, rust_code_markup, rust_code_markup_with_doc, ShortLabel},\n@@ -169,21 +164,24 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n     return match def {\n         Definition::Macro(it) => {\n             let src = it.source(db);\n-            hover_text(src.value.doc_comment_text(), Some(macro_label(&src.value)), mod_path)\n+            let docs = Documentation::from_ast(&src.value).map(Into::into);\n+            hover_text(docs, Some(macro_label(&src.value)), mod_path)\n         }\n         Definition::Field(it) => {\n             let src = it.source(db);\n             match src.value {\n                 FieldSource::Named(it) => {\n-                    hover_text(it.doc_comment_text(), it.short_label(), mod_path)\n+                    let docs = Documentation::from_ast(&it).map(Into::into);\n+                    hover_text(docs, it.short_label(), mod_path)\n                 }\n                 _ => None,\n             }\n         }\n         Definition::ModuleDef(it) => match it {\n             ModuleDef::Module(it) => match it.definition_source(db).value {\n                 ModuleSource::Module(it) => {\n-                    hover_text(it.doc_comment_text(), it.short_label(), mod_path)\n+                    let docs = Documentation::from_ast(&it).map(Into::into);\n+                    hover_text(docs, it.short_label(), mod_path)\n                 }\n                 _ => None,\n             },\n@@ -208,10 +206,11 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n     fn from_def_source<A, D>(db: &RootDatabase, def: D, mod_path: Option<String>) -> Option<String>\n     where\n         D: HasSource<Ast = A>,\n-        A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n+        A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel + ast::AttrsOwner,\n     {\n         let src = def.source(db);\n-        hover_text(src.value.doc_comment_text(), src.value.short_label(), mod_path)\n+        let docs = Documentation::from_ast(&src.value).map(Into::into);\n+        hover_text(docs, src.value.short_label(), mod_path)\n     }\n }\n \n@@ -951,4 +950,106 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             &[\"mod my\"],\n         );\n     }\n+\n+    #[test]\n+    fn test_hover_struct_doc_comment() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            /// bar docs\n+            struct Bar;\n+\n+            fn foo() {\n+                let bar = Ba<|>r;\n+            }\n+            \"#,\n+            &[\"struct Bar\\n```\\n___\\n\\nbar docs\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_struct_doc_attr() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            #[doc = \"bar docs\"]\n+            struct Bar;\n+\n+            fn foo() {\n+                let bar = Ba<|>r;\n+            }\n+            \"#,\n+            &[\"struct Bar\\n```\\n___\\n\\nbar docs\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_struct_doc_attr_multiple_and_mixed() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            /// bar docs 0\n+            #[doc = \"bar docs 1\"]\n+            #[doc = \"bar docs 2\"]\n+            struct Bar;\n+\n+            fn foo() {\n+                let bar = Ba<|>r;\n+            }\n+            \"#,\n+            &[\"struct Bar\\n```\\n___\\n\\nbar docs 0\\n\\nbar docs 1\\n\\nbar docs 2\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_macro_generated_struct_fn_doc_comment() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            macro_rules! bar {\n+                () => {\n+                    struct Bar;\n+                    impl Bar {\n+                        /// Do the foo\n+                        fn foo(&self) {}\n+                    }\n+                }\n+            }\n+\n+            bar!();\n+\n+            fn foo() {\n+                let bar = Bar;\n+                bar.fo<|>o();\n+            }\n+            \"#,\n+            &[\"Bar\\n```\\n\\n```rust\\nfn foo(&self)\\n```\\n___\\n\\n Do the foo\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_macro_generated_struct_fn_doc_attr() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            macro_rules! bar {\n+                () => {\n+                    struct Bar;\n+                    impl Bar {\n+                        #[doc = \"Do the foo\"]\n+                        fn foo(&self) {}\n+                    }\n+                }\n+            }\n+\n+            bar!();\n+\n+            fn foo() {\n+                let bar = Bar;\n+                bar.fo<|>o();\n+            }\n+            \"#,\n+            &[\"Bar\\n```\\n\\n```rust\\nfn foo(&self)\\n```\\n___\\n\\nDo the foo\"],\n+        );\n+    }\n }"}, {"sha": "fcdc98201f2e465d78224d75e879a00185ac3d4b", "filename": "crates/ra_ide/src/snapshots/highlight_injection.html", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_injection.html", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_injection.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_injection.html?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -10,6 +10,7 @@\n .string_literal     { color: #CC9393; }\n .field              { color: #94BFF3; }\n .function           { color: #93E0E3; }\n+.operator.unsafe    { color: #E28C14; }\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }"}, {"sha": "e97192b614a01e59724ce6e85162f0801b797059", "filename": "crates/ra_ide/src/snapshots/highlight_strings.html", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -10,6 +10,7 @@\n .string_literal     { color: #CC9393; }\n .field              { color: #94BFF3; }\n .function           { color: #93E0E3; }\n+.operator.unsafe    { color: #E28C14; }\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }"}, {"sha": "17ffc727cd064db0435e0083be8e56c4aeb89a46", "filename": "crates/ra_ide/src/snapshots/highlight_unsafe.html", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_unsafe.html", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_unsafe.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_unsafe.html?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -0,0 +1,48 @@\n+\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.lifetime           { color: #DFAF8F; font-style: italic; }\n+.comment            { color: #7F9F7F; }\n+.struct, .enum      { color: #7CB8BB; }\n+.enum_variant       { color: #BDE0F3; }\n+.string_literal     { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.operator.unsafe    { color: #E28C14; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.builtin_type       { color: #8CD0D3; }\n+.type_param         { color: #DFAF8F; }\n+.attribute          { color: #94BFF3; }\n+.numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n+.macro              { color: #94BFF3; }\n+.module             { color: #AFD8AF; }\n+.variable           { color: #DCDCCC; }\n+.format_specifier   { color: #CC696B; }\n+.mutable            { text-decoration: underline; }\n+\n+.keyword            { color: #F0DFAF; font-weight: bold; }\n+.keyword.unsafe     { color: #BC8383; font-weight: bold; }\n+.control            { font-style: italic; }\n+</style>\n+<pre><code><span class=\"keyword unsafe\">unsafe</span> <span class=\"keyword\">fn</span> <span class=\"function declaration unsafe\">unsafe_fn</span>() {}\n+\n+<span class=\"keyword\">struct</span> <span class=\"struct declaration\">HasUnsafeFn</span>;\n+\n+<span class=\"keyword\">impl</span> <span class=\"struct\">HasUnsafeFn</span> {\n+    <span class=\"keyword unsafe\">unsafe</span> <span class=\"keyword\">fn</span> <span class=\"function declaration unsafe\">unsafe_method</span>(&<span class=\"self_keyword\">self</span>) {}\n+}\n+\n+<span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span>() {\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">x</span> = &<span class=\"numeric_literal\">5</span> <span class=\"keyword\">as</span> *<span class=\"keyword\">const</span> <span class=\"builtin_type\">usize</span>;\n+    <span class=\"keyword unsafe\">unsafe</span> {\n+        <span class=\"function unsafe\">unsafe_fn</span>();\n+        <span class=\"struct\">HasUnsafeFn</span>.<span class=\"function unsafe\">unsafe_method</span>();\n+        <span class=\"keyword\">let</span> <span class=\"variable declaration\">y</span> = <span class=\"operator unsafe\">*</span><span class=\"variable\">x</span>;\n+        <span class=\"keyword\">let</span> <span class=\"variable declaration\">z</span> = -<span class=\"variable\">x</span>;\n+    }\n+}</code></pre>\n\\ No newline at end of file"}, {"sha": "42c5f3e5515e7e24fd739fe70cd0550067d9c983", "filename": "crates/ra_ide/src/snapshots/highlighting.html", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -10,6 +10,7 @@\n .string_literal     { color: #CC9393; }\n .field              { color: #94BFF3; }\n .function           { color: #93E0E3; }\n+.operator.unsafe    { color: #E28C14; }\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }"}, {"sha": "2dd61d20d6912cce61c2f14e9ddca9fc5b5f1bb2", "filename": "crates/ra_ide/src/snapshots/rainbow_highlighting.html", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -10,6 +10,7 @@\n .string_literal     { color: #CC9393; }\n .field              { color: #94BFF3; }\n .function           { color: #93E0E3; }\n+.operator.unsafe    { color: #E28C14; }\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }"}, {"sha": "19ecd54d6cf2cdaee5fd20c0e3743fed96e3821e", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -406,6 +406,23 @@ fn highlight_element(\n                 _ => h,\n             }\n         }\n+        PREFIX_EXPR => {\n+            let prefix_expr = element.into_node().and_then(ast::PrefixExpr::cast)?;\n+            match prefix_expr.op_kind() {\n+                Some(ast::PrefixOp::Deref) => {}\n+                _ => return None,\n+            }\n+\n+            let expr = prefix_expr.expr()?;\n+            let ty = sema.type_of_expr(&expr)?;\n+            if !ty.is_raw_ptr() {\n+                return None;\n+            }\n+\n+            let mut h = Highlight::new(HighlightTag::Operator);\n+            h |= HighlightModifier::Unsafe;\n+            h\n+        }\n \n         k if k.is_keyword() => {\n             let h = Highlight::new(HighlightTag::Keyword);\n@@ -458,7 +475,13 @@ fn highlight_name(db: &RootDatabase, def: Definition) -> Highlight {\n         Definition::Field(_) => HighlightTag::Field,\n         Definition::ModuleDef(def) => match def {\n             hir::ModuleDef::Module(_) => HighlightTag::Module,\n-            hir::ModuleDef::Function(_) => HighlightTag::Function,\n+            hir::ModuleDef::Function(func) => {\n+                let mut h = HighlightTag::Function.into();\n+                if func.is_unsafe(db) {\n+                    h |= HighlightModifier::Unsafe;\n+                }\n+                return h;\n+            }\n             hir::ModuleDef::Adt(hir::Adt::Struct(_)) => HighlightTag::Struct,\n             hir::ModuleDef::Adt(hir::Adt::Enum(_)) => HighlightTag::Enum,\n             hir::ModuleDef::Adt(hir::Adt::Union(_)) => HighlightTag::Union,"}, {"sha": "7d946c98dae771ca20d4baf3f8734a2d24de46bf", "filename": "crates/ra_ide/src/syntax_highlighting/html.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -69,6 +69,7 @@ pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padd\n .string_literal     { color: #CC9393; }\n .field              { color: #94BFF3; }\n .function           { color: #93E0E3; }\n+.operator.unsafe    { color: #E28C14; }\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }"}, {"sha": "94f466966a3a642899fbac6109125482dc6ff76c", "filename": "crates/ra_ide/src/syntax_highlighting/tags.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -24,12 +24,14 @@ pub enum HighlightTag {\n     Enum,\n     EnumVariant,\n     Field,\n+    FormatSpecifier,\n     Function,\n     Keyword,\n     Lifetime,\n     Macro,\n     Module,\n     NumericLiteral,\n+    Operator,\n     SelfKeyword,\n     SelfType,\n     Static,\n@@ -41,8 +43,6 @@ pub enum HighlightTag {\n     Union,\n     Local,\n     UnresolvedReference,\n-    FormatSpecifier,\n-    Operator,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n@@ -72,12 +72,14 @@ impl HighlightTag {\n             HighlightTag::Enum => \"enum\",\n             HighlightTag::EnumVariant => \"enum_variant\",\n             HighlightTag::Field => \"field\",\n+            HighlightTag::FormatSpecifier => \"format_specifier\",\n             HighlightTag::Function => \"function\",\n             HighlightTag::Keyword => \"keyword\",\n             HighlightTag::Lifetime => \"lifetime\",\n             HighlightTag::Macro => \"macro\",\n             HighlightTag::Module => \"module\",\n             HighlightTag::NumericLiteral => \"numeric_literal\",\n+            HighlightTag::Operator => \"operator\",\n             HighlightTag::SelfKeyword => \"self_keyword\",\n             HighlightTag::SelfType => \"self_type\",\n             HighlightTag::Static => \"static\",\n@@ -89,8 +91,6 @@ impl HighlightTag {\n             HighlightTag::Union => \"union\",\n             HighlightTag::Local => \"variable\",\n             HighlightTag::UnresolvedReference => \"unresolved_reference\",\n-            HighlightTag::FormatSpecifier => \"format_specifier\",\n-            HighlightTag::Operator => \"operator\",\n         }\n     }\n }"}, {"sha": "36a1aa419bc3e1d6ed12896478b5e496beee9d5e", "filename": "crates/ra_ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -258,3 +258,34 @@ fn main() {\n     fs::write(dst_file, &actual_html).unwrap();\n     assert_eq_text!(expected_html, actual_html);\n }\n+\n+#[test]\n+fn test_unsafe_highlighting() {\n+    let (analysis, file_id) = single_file(\n+        r#\"\n+unsafe fn unsafe_fn() {}\n+\n+struct HasUnsafeFn;\n+\n+impl HasUnsafeFn {\n+    unsafe fn unsafe_method(&self) {}\n+}\n+\n+fn main() {\n+    let x = &5 as *const usize;\n+    unsafe {\n+        unsafe_fn();\n+        HasUnsafeFn.unsafe_method();\n+        let y = *x;\n+        let z = -x;\n+    }\n+}\n+\"#\n+        .trim(),\n+    );\n+    let dst_file = project_dir().join(\"crates/ra_ide/src/snapshots/highlight_unsafe.html\");\n+    let actual_html = &analysis.highlight_as_html(file_id, false).unwrap();\n+    let expected_html = &read_text(&dst_file);\n+    fs::write(dst_file, &actual_html).unwrap();\n+    assert_eq_text!(expected_html, actual_html);\n+}"}, {"sha": "293baecf6a2c1b87f62d6d12b6cf6293110f6493", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -18,9 +18,10 @@\n //! // fn foo() {}\n //! ```\n //!\n-//! After adding a new inline-test, run `cargo collect-tests` to extract\n-//! it as a standalone text-fixture into `tests/data/parser/inline`, and\n-//! run `cargo test` once to create the \"gold\" value.\n+//! After adding a new inline-test, run `cargo xtask codegen` to\n+//! extract it as a standalone text-fixture into\n+//! `crates/ra_syntax/test_data/parser/`, and run `cargo test` once to\n+//! create the \"gold\" value.\n //!\n //! Coding convention: rules like `where_clause` always produce either a\n //! node or an error, rules like `opt_where_clause` may produce nothing."}, {"sha": "09c06fef9359ff9ea1a7e238f920954767c7e0fb", "filename": "crates/ra_project_model/src/json_project.rs", "status": "modified", "additions": 84, "deletions": 5, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -5,6 +5,13 @@ use std::path::PathBuf;\n use rustc_hash::{FxHashMap, FxHashSet};\n use serde::Deserialize;\n \n+/// Roots and crates that compose this Rust project.\n+#[derive(Clone, Debug, Deserialize)]\n+pub struct JsonProject {\n+    pub(crate) roots: Vec<Root>,\n+    pub(crate) crates: Vec<Crate>,\n+}\n+\n /// A root points to the directory which contains Rust crates. rust-analyzer watches all files in\n /// all roots. Roots might be nested.\n #[derive(Clone, Debug, Deserialize)]\n@@ -20,8 +27,17 @@ pub struct Crate {\n     pub(crate) root_module: PathBuf,\n     pub(crate) edition: Edition,\n     pub(crate) deps: Vec<Dep>,\n+\n+    // This is the preferred method of providing cfg options.\n+    #[serde(default)]\n+    pub(crate) cfg: FxHashSet<String>,\n+\n+    // These two are here for transition only.\n+    #[serde(default)]\n     pub(crate) atom_cfgs: FxHashSet<String>,\n+    #[serde(default)]\n     pub(crate) key_value_cfgs: FxHashMap<String, String>,\n+\n     pub(crate) out_dir: Option<PathBuf>,\n     pub(crate) proc_macro_dylib_path: Option<PathBuf>,\n }\n@@ -48,9 +64,72 @@ pub struct Dep {\n     pub(crate) name: String,\n }\n \n-/// Roots and crates that compose this Rust project.\n-#[derive(Clone, Debug, Deserialize)]\n-pub struct JsonProject {\n-    pub(crate) roots: Vec<Root>,\n-    pub(crate) crates: Vec<Crate>,\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use serde_json::json;\n+\n+    #[test]\n+    fn test_crate_deserialization() {\n+        let raw_json = json!(    {\n+            \"crate_id\": 2,\n+            \"root_module\": \"this/is/a/file/path.rs\",\n+            \"deps\": [\n+              {\n+                \"crate\": 1,\n+                \"name\": \"some_dep_crate\"\n+              },\n+            ],\n+            \"edition\": \"2015\",\n+            \"cfg\": [\n+              \"atom_1\",\n+              \"atom_2\",\n+              \"feature=feature_1\",\n+              \"feature=feature_2\",\n+              \"other=value\",\n+            ],\n+\n+        });\n+\n+        let krate: Crate = serde_json::from_value(raw_json).unwrap();\n+\n+        assert!(krate.cfg.contains(&\"atom_1\".to_string()));\n+        assert!(krate.cfg.contains(&\"atom_2\".to_string()));\n+        assert!(krate.cfg.contains(&\"feature=feature_1\".to_string()));\n+        assert!(krate.cfg.contains(&\"feature=feature_2\".to_string()));\n+        assert!(krate.cfg.contains(&\"other=value\".to_string()));\n+    }\n+\n+    #[test]\n+    fn test_crate_deserialization_old_json() {\n+        let raw_json = json!(    {\n+           \"crate_id\": 2,\n+           \"root_module\": \"this/is/a/file/path.rs\",\n+           \"deps\": [\n+             {\n+               \"crate\": 1,\n+               \"name\": \"some_dep_crate\"\n+             },\n+           ],\n+           \"edition\": \"2015\",\n+           \"atom_cfgs\": [\n+             \"atom_1\",\n+             \"atom_2\",\n+           ],\n+           \"key_value_cfgs\": {\n+             \"feature\": \"feature_1\",\n+             \"feature\": \"feature_2\",\n+             \"other\": \"value\",\n+           },\n+        });\n+\n+        let krate: Crate = serde_json::from_value(raw_json).unwrap();\n+\n+        assert!(krate.atom_cfgs.contains(&\"atom_1\".to_string()));\n+        assert!(krate.atom_cfgs.contains(&\"atom_2\".to_string()));\n+        assert!(krate.key_value_cfgs.contains_key(&\"feature\".to_string()));\n+        assert_eq!(krate.key_value_cfgs.get(\"feature\"), Some(&\"feature_2\".to_string()));\n+        assert!(krate.key_value_cfgs.contains_key(&\"other\".to_string()));\n+        assert_eq!(krate.key_value_cfgs.get(\"other\"), Some(&\"value\".to_string()));\n+    }\n }"}, {"sha": "7ad941279506fc8d30ddc5196121019afb4b41ae", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -14,7 +14,7 @@ use std::{\n use anyhow::{bail, Context, Result};\n use ra_cfg::CfgOptions;\n use ra_db::{CrateGraph, CrateName, Edition, Env, ExternSource, ExternSourceId, FileId};\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use serde_json::from_reader;\n \n pub use crate::{\n@@ -32,6 +32,12 @@ pub enum ProjectWorkspace {\n     Json { project: JsonProject },\n }\n \n+impl From<JsonProject> for ProjectWorkspace {\n+    fn from(project: JsonProject) -> ProjectWorkspace {\n+        ProjectWorkspace::Json { project }\n+    }\n+}\n+\n /// `PackageRoot` describes a package root folder.\n /// Which may be an external dependency, or a member of\n /// the current workspace.\n@@ -57,25 +63,25 @@ impl PackageRoot {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum ProjectRoot {\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+pub enum ProjectManifest {\n     ProjectJson(PathBuf),\n     CargoToml(PathBuf),\n }\n \n-impl ProjectRoot {\n-    pub fn from_manifest_file(path: PathBuf) -> Result<ProjectRoot> {\n+impl ProjectManifest {\n+    pub fn from_manifest_file(path: PathBuf) -> Result<ProjectManifest> {\n         if path.ends_with(\"rust-project.json\") {\n-            return Ok(ProjectRoot::ProjectJson(path));\n+            return Ok(ProjectManifest::ProjectJson(path));\n         }\n         if path.ends_with(\"Cargo.toml\") {\n-            return Ok(ProjectRoot::CargoToml(path));\n+            return Ok(ProjectManifest::CargoToml(path));\n         }\n         bail!(\"project root must point to Cargo.toml or rust-project.json: {}\", path.display())\n     }\n \n-    pub fn discover_single(path: &Path) -> Result<ProjectRoot> {\n-        let mut candidates = ProjectRoot::discover(path)?;\n+    pub fn discover_single(path: &Path) -> Result<ProjectManifest> {\n+        let mut candidates = ProjectManifest::discover(path)?;\n         let res = match candidates.pop() {\n             None => bail!(\"no projects\"),\n             Some(it) => it,\n@@ -87,12 +93,12 @@ impl ProjectRoot {\n         Ok(res)\n     }\n \n-    pub fn discover(path: &Path) -> io::Result<Vec<ProjectRoot>> {\n+    pub fn discover(path: &Path) -> io::Result<Vec<ProjectManifest>> {\n         if let Some(project_json) = find_in_parent_dirs(path, \"rust-project.json\") {\n-            return Ok(vec![ProjectRoot::ProjectJson(project_json)]);\n+            return Ok(vec![ProjectManifest::ProjectJson(project_json)]);\n         }\n         return find_cargo_toml(path)\n-            .map(|paths| paths.into_iter().map(ProjectRoot::CargoToml).collect());\n+            .map(|paths| paths.into_iter().map(ProjectManifest::CargoToml).collect());\n \n         fn find_cargo_toml(path: &Path) -> io::Result<Vec<PathBuf>> {\n             match find_in_parent_dirs(path, \"Cargo.toml\") {\n@@ -128,16 +134,28 @@ impl ProjectRoot {\n                 .collect()\n         }\n     }\n+\n+    pub fn discover_all(paths: &[impl AsRef<Path>]) -> Vec<ProjectManifest> {\n+        let mut res = paths\n+            .iter()\n+            .filter_map(|it| ProjectManifest::discover(it.as_ref()).ok())\n+            .flatten()\n+            .collect::<FxHashSet<_>>()\n+            .into_iter()\n+            .collect::<Vec<_>>();\n+        res.sort();\n+        res\n+    }\n }\n \n impl ProjectWorkspace {\n     pub fn load(\n-        root: ProjectRoot,\n+        manifest: ProjectManifest,\n         cargo_features: &CargoConfig,\n         with_sysroot: bool,\n     ) -> Result<ProjectWorkspace> {\n-        let res = match root {\n-            ProjectRoot::ProjectJson(project_json) => {\n+        let res = match manifest {\n+            ProjectManifest::ProjectJson(project_json) => {\n                 let file = File::open(&project_json).with_context(|| {\n                     format!(\"Failed to open json file {}\", project_json.display())\n                 })?;\n@@ -148,7 +166,7 @@ impl ProjectWorkspace {\n                     })?,\n                 }\n             }\n-            ProjectRoot::CargoToml(cargo_toml) => {\n+            ProjectManifest::CargoToml(cargo_toml) => {\n                 let cargo = CargoWorkspace::from_cargo_metadata(&cargo_toml, cargo_features)\n                     .with_context(|| {\n                         format!(\n@@ -252,6 +270,16 @@ impl ProjectWorkspace {\n                         };\n                         let cfg_options = {\n                             let mut opts = default_cfg_options.clone();\n+                            for cfg in &krate.cfg {\n+                                match cfg.find('=') {\n+                                    None => opts.insert_atom(cfg.into()),\n+                                    Some(pos) => {\n+                                        let key = &cfg[..pos];\n+                                        let value = cfg[pos + 1..].trim_matches('\"');\n+                                        opts.insert_key_value(key.into(), value.into());\n+                                    }\n+                                }\n+                            }\n                             for name in &krate.atom_cfgs {\n                                 opts.insert_atom(name.into());\n                             }"}, {"sha": "a8f2454fd96e861209a9345911cef983ce41ace4", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -83,13 +83,22 @@ pub trait DocCommentsOwner: AstNode {\n         CommentIter { iter: self.syntax().children_with_tokens() }\n     }\n \n+    fn doc_comment_text(&self) -> Option<String> {\n+        self.doc_comments().doc_comment_text()\n+    }\n+}\n+\n+impl CommentIter {\n+    pub fn from_syntax_node(syntax_node: &ast::SyntaxNode) -> CommentIter {\n+        CommentIter { iter: syntax_node.children_with_tokens() }\n+    }\n+\n     /// Returns the textual content of a doc comment block as a single string.\n     /// That is, strips leading `///` (+ optional 1 character of whitespace),\n     /// trailing `*/`, trailing whitespace and then joins the lines.\n-    fn doc_comment_text(&self) -> Option<String> {\n+    pub fn doc_comment_text(self) -> Option<String> {\n         let mut has_comments = false;\n         let docs = self\n-            .doc_comments()\n             .filter(|comment| comment.kind().doc.is_some())\n             .map(|comment| {\n                 has_comments = true;"}, {"sha": "8d071ab1ca2b8fac88f216bd2b39f3470cbe987c", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -4,9 +4,14 @@\n mod args;\n \n use lsp_server::Connection;\n-use rust_analyzer::{cli, config::Config, from_json, Result};\n+use rust_analyzer::{\n+    cli,\n+    config::{Config, LinkedProject},\n+    from_json, Result,\n+};\n \n use crate::args::HelpPrinted;\n+use ra_project_model::ProjectManifest;\n \n fn main() -> Result<()> {\n     setup_logging()?;\n@@ -97,28 +102,38 @@ fn run_server() -> Result<()> {\n         log::info!(\"Client '{}' {}\", client_info.name, client_info.version.unwrap_or_default());\n     }\n \n-    let cwd = std::env::current_dir()?;\n-    let root = initialize_params.root_uri.and_then(|it| it.to_file_path().ok()).unwrap_or(cwd);\n-\n-    let workspace_roots = initialize_params\n-        .workspace_folders\n-        .map(|workspaces| {\n-            workspaces.into_iter().filter_map(|it| it.uri.to_file_path().ok()).collect::<Vec<_>>()\n-        })\n-        .filter(|workspaces| !workspaces.is_empty())\n-        .unwrap_or_else(|| vec![root]);\n-\n     let config = {\n         let mut config = Config::default();\n         if let Some(value) = &initialize_params.initialization_options {\n             config.update(value);\n         }\n         config.update_caps(&initialize_params.capabilities);\n \n+        if config.linked_projects.is_empty() {\n+            let cwd = std::env::current_dir()?;\n+            let root =\n+                initialize_params.root_uri.and_then(|it| it.to_file_path().ok()).unwrap_or(cwd);\n+            let workspace_roots = initialize_params\n+                .workspace_folders\n+                .map(|workspaces| {\n+                    workspaces\n+                        .into_iter()\n+                        .filter_map(|it| it.uri.to_file_path().ok())\n+                        .collect::<Vec<_>>()\n+                })\n+                .filter(|workspaces| !workspaces.is_empty())\n+                .unwrap_or_else(|| vec![root]);\n+\n+            config.linked_projects = ProjectManifest::discover_all(&workspace_roots)\n+                .into_iter()\n+                .map(LinkedProject::from)\n+                .collect();\n+        }\n+\n         config\n     };\n \n-    rust_analyzer::main_loop(workspace_roots, config, connection)?;\n+    rust_analyzer::main_loop(config, connection)?;\n \n     log::info!(\"shutting down IO...\");\n     io_threads.join()?;"}, {"sha": "44f856f6b457d2de9af1a1f85fd376eb32383538", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -4,7 +4,7 @@ use ra_cfg::CfgExpr;\n use ra_ide::{FileId, RunnableKind, TestId};\n use ra_project_model::{self, ProjectWorkspace, TargetKind};\n \n-use crate::{world::WorldSnapshot, Result};\n+use crate::{global_state::GlobalStateSnapshot, Result};\n \n /// Abstract representation of Cargo target.\n ///\n@@ -89,7 +89,7 @@ impl CargoTargetSpec {\n     }\n \n     pub(crate) fn for_file(\n-        world: &WorldSnapshot,\n+        world: &GlobalStateSnapshot,\n         file_id: FileId,\n     ) -> Result<Option<CargoTargetSpec>> {\n         let &crate_id = match world.analysis().crate_for(file_id)?.first() {"}, {"sha": "c7e86fe0c48b5b855c9db448add36b812e83b5e7", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -8,7 +8,8 @@ use crossbeam_channel::{unbounded, Receiver};\n use ra_db::{ExternSourceId, FileId, SourceRootId};\n use ra_ide::{AnalysisChange, AnalysisHost};\n use ra_project_model::{\n-    get_rustc_cfg_options, CargoConfig, PackageRoot, ProcMacroClient, ProjectRoot, ProjectWorkspace,\n+    get_rustc_cfg_options, CargoConfig, PackageRoot, ProcMacroClient, ProjectManifest,\n+    ProjectWorkspace,\n };\n use ra_vfs::{RootEntry, Vfs, VfsChange, VfsTask, Watch};\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -28,7 +29,7 @@ pub fn load_cargo(\n     with_proc_macro: bool,\n ) -> Result<(AnalysisHost, FxHashMap<SourceRootId, PackageRoot>)> {\n     let root = std::env::current_dir()?.join(root);\n-    let root = ProjectRoot::discover_single(&root)?;\n+    let root = ProjectManifest::discover_single(&root)?;\n     let ws = ProjectWorkspace::load(\n         root,\n         &CargoConfig { load_out_dirs_from_check, ..Default::default() },"}, {"sha": "23168c3ae9a28f53d151054b4873eeeedbc71826", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -12,14 +12,13 @@ use std::{ffi::OsString, path::PathBuf};\n use lsp_types::ClientCapabilities;\n use ra_flycheck::FlycheckConfig;\n use ra_ide::{AssistConfig, CompletionConfig, InlayHintsConfig};\n-use ra_project_model::CargoConfig;\n+use ra_project_model::{CargoConfig, JsonProject, ProjectManifest};\n use serde::Deserialize;\n \n #[derive(Debug, Clone)]\n pub struct Config {\n     pub client_caps: ClientCapsConfig,\n \n-    pub with_sysroot: bool,\n     pub publish_diagnostics: bool,\n     pub lru_capacity: Option<usize>,\n     pub proc_macro_srv: Option<(PathBuf, Vec<OsString>)>,\n@@ -35,6 +34,27 @@ pub struct Config {\n     pub assist: AssistConfig,\n     pub call_info_full: bool,\n     pub lens: LensConfig,\n+\n+    pub with_sysroot: bool,\n+    pub linked_projects: Vec<LinkedProject>,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum LinkedProject {\n+    ProjectManifest(ProjectManifest),\n+    JsonProject(JsonProject),\n+}\n+\n+impl From<ProjectManifest> for LinkedProject {\n+    fn from(v: ProjectManifest) -> Self {\n+        LinkedProject::ProjectManifest(v)\n+    }\n+}\n+\n+impl From<JsonProject> for LinkedProject {\n+    fn from(v: JsonProject) -> Self {\n+        LinkedProject::JsonProject(v)\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -142,6 +162,7 @@ impl Default for Config {\n             assist: AssistConfig::default(),\n             call_info_full: true,\n             lens: LensConfig::default(),\n+            linked_projects: Vec::new(),\n         }\n     }\n }\n@@ -241,6 +262,22 @@ impl Config {\n             self.lens = LensConfig::NO_LENS;\n         }\n \n+        if let Some(linked_projects) = get::<Vec<ManifestOrJsonProject>>(value, \"/linkedProjects\") {\n+            if !linked_projects.is_empty() {\n+                self.linked_projects.clear();\n+                for linked_project in linked_projects {\n+                    let linked_project = match linked_project {\n+                        ManifestOrJsonProject::Manifest(it) => match ProjectManifest::from_manifest_file(it) {\n+                            Ok(it) => it.into(),\n+                            Err(_) => continue,\n+                        }\n+                        ManifestOrJsonProject::JsonProject(it) => it.into(),\n+                    };\n+                    self.linked_projects.push(linked_project);\n+                }\n+            }\n+        }\n+\n         log::info!(\"Config::update() = {:#?}\", self);\n \n         fn get<'a, T: Deserialize<'a>>(value: &'a serde_json::Value, pointer: &str) -> Option<T> {\n@@ -308,3 +345,10 @@ impl Config {\n         }\n     }\n }\n+\n+#[derive(Deserialize)]\n+#[serde(untagged)]\n+enum ManifestOrJsonProject {\n+    Manifest(PathBuf),\n+    JsonProject(JsonProject),\n+}"}, {"sha": "f0273315e932706b572d3b667faacb8ecdd929a3", "filename": "crates/rust-analyzer/src/diagnostics/snapshots/rust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -29,7 +29,7 @@ expression: diag\n                 },\n             },\n             severity: Some(\n-                Warning,\n+                Hint,\n             ),\n             code: Some(\n                 String("}, {"sha": "04e286780c18313a62dc47092d0d2aad6f442a9d", "filename": "crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -184,7 +184,7 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n         return Vec::new();\n     }\n \n-    let severity = map_level_to_severity(rd.level);\n+    let mut severity = map_level_to_severity(rd.level);\n \n     let mut source = String::from(\"rustc\");\n     let mut code = rd.code.as_ref().map(|c| c.code.clone());\n@@ -226,6 +226,7 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n     }\n \n     if is_unused_or_unnecessary(rd) {\n+        severity = Some(DiagnosticSeverity::Hint);\n         tags.push(DiagnosticTag::Unnecessary);\n     }\n "}, {"sha": "206673829c489b5fc9ac2da597c934d7e81cb0db", "filename": "crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -3,7 +3,7 @@ use ra_db::{FileId, FilePosition, FileRange};\n use ra_ide::{LineCol, LineIndex};\n use ra_syntax::{TextRange, TextSize};\n \n-use crate::{world::WorldSnapshot, Result};\n+use crate::{global_state::GlobalStateSnapshot, Result};\n \n pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> TextSize {\n     let line_col = LineCol { line: position.line as u32, col_utf16: position.character as u32 };\n@@ -16,12 +16,12 @@ pub(crate) fn text_range(line_index: &LineIndex, range: lsp_types::Range) -> Tex\n     TextRange::new(start, end)\n }\n \n-pub(crate) fn file_id(world: &WorldSnapshot, url: &lsp_types::Url) -> Result<FileId> {\n+pub(crate) fn file_id(world: &GlobalStateSnapshot, url: &lsp_types::Url) -> Result<FileId> {\n     world.uri_to_file_id(url)\n }\n \n pub(crate) fn file_position(\n-    world: &WorldSnapshot,\n+    world: &GlobalStateSnapshot,\n     tdpp: lsp_types::TextDocumentPositionParams,\n ) -> Result<FilePosition> {\n     let file_id = file_id(world, &tdpp.text_document.uri)?;\n@@ -31,7 +31,7 @@ pub(crate) fn file_position(\n }\n \n pub(crate) fn file_range(\n-    world: &WorldSnapshot,\n+    world: &GlobalStateSnapshot,\n     text_document_identifier: lsp_types::TextDocumentIdentifier,\n     range: lsp_types::Range,\n ) -> Result<FileRange> {"}, {"sha": "0bebb5bf615a74912bed884b49bb8446ec4ac3a6", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "renamed", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -50,15 +50,15 @@ fn create_flycheck(workspaces: &[ProjectWorkspace], config: &FlycheckConfig) ->\n         })\n }\n \n-/// `WorldState` is the primary mutable state of the language server\n+/// `GlobalState` is the primary mutable state of the language server\n ///\n /// The most interesting components are `vfs`, which stores a consistent\n /// snapshot of the file systems, and `analysis_host`, which stores our\n /// incremental salsa database.\n #[derive(Debug)]\n-pub struct WorldState {\n+pub struct GlobalState {\n     pub config: Config,\n-    pub roots: Vec<PathBuf>,\n+    pub local_roots: Vec<PathBuf>,\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis_host: AnalysisHost,\n     pub vfs: Arc<RwLock<Vfs>>,\n@@ -70,7 +70,7 @@ pub struct WorldState {\n }\n \n /// An immutable snapshot of the world's state at a point in time.\n-pub struct WorldSnapshot {\n+pub struct GlobalStateSnapshot {\n     pub config: Config,\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis: Analysis,\n@@ -79,33 +79,37 @@ pub struct WorldSnapshot {\n     vfs: Arc<RwLock<Vfs>>,\n }\n \n-impl WorldState {\n+impl GlobalState {\n     pub fn new(\n-        folder_roots: Vec<PathBuf>,\n         workspaces: Vec<ProjectWorkspace>,\n         lru_capacity: Option<usize>,\n         exclude_globs: &[Glob],\n         watch: Watch,\n         config: Config,\n-    ) -> WorldState {\n+    ) -> GlobalState {\n         let mut change = AnalysisChange::new();\n \n         let extern_dirs: FxHashSet<_> =\n             workspaces.iter().flat_map(ProjectWorkspace::out_dirs).collect();\n \n+        let mut local_roots = Vec::new();\n         let roots: Vec<_> = {\n             let create_filter = |is_member| {\n                 RustPackageFilterBuilder::default()\n                     .set_member(is_member)\n                     .exclude(exclude_globs.iter().cloned())\n                     .into_vfs_filter()\n             };\n-            folder_roots\n+            workspaces\n                 .iter()\n-                .map(|path| RootEntry::new(path.clone(), create_filter(true)))\n-                .chain(workspaces.iter().flat_map(ProjectWorkspace::to_roots).map(|pkg_root| {\n-                    RootEntry::new(pkg_root.path().to_owned(), create_filter(pkg_root.is_member()))\n-                }))\n+                .flat_map(ProjectWorkspace::to_roots)\n+                .map(|pkg_root| {\n+                    let path = pkg_root.path().to_owned();\n+                    if pkg_root.is_member() {\n+                        local_roots.push(path.clone());\n+                    }\n+                    RootEntry::new(path, create_filter(pkg_root.is_member()))\n+                })\n                 .chain(\n                     extern_dirs\n                         .iter()\n@@ -121,7 +125,7 @@ impl WorldState {\n         let mut extern_source_roots = FxHashMap::default();\n         for r in vfs_roots {\n             let vfs_root_path = vfs.root2path(r);\n-            let is_local = folder_roots.iter().any(|it| vfs_root_path.starts_with(it));\n+            let is_local = local_roots.iter().any(|it| vfs_root_path.starts_with(it));\n             change.add_root(SourceRootId(r.0), is_local);\n             change.set_debug_root_path(SourceRootId(r.0), vfs_root_path.display().to_string());\n \n@@ -176,9 +180,9 @@ impl WorldState {\n \n         let mut analysis_host = AnalysisHost::new(lru_capacity);\n         analysis_host.apply_change(change);\n-        WorldState {\n+        GlobalState {\n             config,\n-            roots: folder_roots,\n+            local_roots,\n             workspaces: Arc::new(workspaces),\n             analysis_host,\n             vfs: Arc::new(RwLock::new(vfs)),\n@@ -216,7 +220,7 @@ impl WorldState {\n             match c {\n                 VfsChange::AddRoot { root, files } => {\n                     let root_path = self.vfs.read().root2path(root);\n-                    let is_local = self.roots.iter().any(|r| root_path.starts_with(r));\n+                    let is_local = self.local_roots.iter().any(|r| root_path.starts_with(r));\n                     if is_local {\n                         *roots_scanned += 1;\n                         for (file, path, text) in files {\n@@ -251,8 +255,8 @@ impl WorldState {\n         self.analysis_host.apply_change(change);\n     }\n \n-    pub fn snapshot(&self) -> WorldSnapshot {\n-        WorldSnapshot {\n+    pub fn snapshot(&self) -> GlobalStateSnapshot {\n+        GlobalStateSnapshot {\n             config: self.config.clone(),\n             workspaces: Arc::clone(&self.workspaces),\n             analysis: self.analysis_host.analysis(),\n@@ -275,7 +279,7 @@ impl WorldState {\n     }\n }\n \n-impl WorldSnapshot {\n+impl GlobalStateSnapshot {\n     pub fn analysis(&self) -> &Analysis {\n         &self.analysis\n     }", "previous_filename": "crates/rust-analyzer/src/world.rs"}, {"sha": "609cb69d3bff6174a15502db7dfd1f19900bb034", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -26,7 +26,7 @@ mod main_loop;\n mod markdown;\n pub mod lsp_ext;\n pub mod config;\n-mod world;\n+mod global_state;\n mod diagnostics;\n mod semantic_tokens;\n "}, {"sha": "e60337b8e8b61fa582b58a4977bc2c84ef8fe3a4", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 71, "deletions": 76, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -12,13 +12,11 @@ use std::{\n     fmt,\n     ops::Range,\n     panic,\n-    path::PathBuf,\n     sync::Arc,\n     time::{Duration, Instant},\n };\n \n use crossbeam_channel::{never, select, unbounded, RecvError, Sender};\n-use itertools::Itertools;\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n use lsp_types::{\n     DidChangeTextDocumentParams, NumberOrString, TextDocumentContentChangeEvent, WorkDoneProgress,\n@@ -36,14 +34,15 @@ use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n \n use crate::{\n-    config::{Config, FilesWatcher},\n+    config::{Config, FilesWatcher, LinkedProject},\n     diagnostics::{to_proto::url_from_path_with_drive_lowercasing, DiagnosticTask},\n-    from_proto, lsp_ext,\n+    from_proto,\n+    global_state::{GlobalState, GlobalStateSnapshot},\n+    lsp_ext,\n     main_loop::{\n         pending_requests::{PendingRequest, PendingRequests},\n         subscriptions::Subscriptions,\n     },\n-    world::{WorldSnapshot, WorldState},\n     Result,\n };\n \n@@ -69,7 +68,7 @@ impl fmt::Display for LspError {\n \n impl Error for LspError {}\n \n-pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection) -> Result<()> {\n+pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n     log::info!(\"initial config: {:#?}\", config);\n \n     // Windows scheduler implements priority boosts: if thread waits for an\n@@ -92,43 +91,37 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n     }\n \n     let mut loop_state = LoopState::default();\n-    let mut world_state = {\n+    let mut global_state = {\n         let workspaces = {\n-            // FIXME: support dynamic workspace loading.\n-            let project_roots: FxHashSet<_> = ws_roots\n-                .iter()\n-                .filter_map(|it| ra_project_model::ProjectRoot::discover(it).ok())\n-                .flatten()\n-                .collect();\n-\n-            if project_roots.is_empty() && config.notifications.cargo_toml_not_found {\n+            if config.linked_projects.is_empty() && config.notifications.cargo_toml_not_found {\n                 show_message(\n                     lsp_types::MessageType::Error,\n-                    format!(\n-                        \"rust-analyzer failed to discover workspace, no Cargo.toml found, dirs searched: {}\",\n-                        ws_roots.iter().format_with(\", \", |it, f| f(&it.display()))\n-                    ),\n+                    \"rust-analyzer failed to discover workspace\".to_string(),\n                     &connection.sender,\n                 );\n             };\n \n-            project_roots\n-                .into_iter()\n-                .filter_map(|root| {\n-                    ra_project_model::ProjectWorkspace::load(\n-                        root,\n-                        &config.cargo,\n-                        config.with_sysroot,\n-                    )\n-                    .map_err(|err| {\n-                        log::error!(\"failed to load workspace: {:#}\", err);\n-                        show_message(\n-                            lsp_types::MessageType::Error,\n-                            format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n-                            &connection.sender,\n-                        );\n-                    })\n-                    .ok()\n+            config\n+                .linked_projects\n+                .iter()\n+                .filter_map(|project| match project {\n+                    LinkedProject::ProjectManifest(manifest) => {\n+                        ra_project_model::ProjectWorkspace::load(\n+                            manifest.clone(),\n+                            &config.cargo,\n+                            config.with_sysroot,\n+                        )\n+                        .map_err(|err| {\n+                            log::error!(\"failed to load workspace: {:#}\", err);\n+                            show_message(\n+                                lsp_types::MessageType::Error,\n+                                format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n+                                &connection.sender,\n+                            );\n+                        })\n+                        .ok()\n+                    }\n+                    LinkedProject::JsonProject(it) => Some(it.clone().into()),\n                 })\n                 .collect::<Vec<_>>()\n         };\n@@ -163,8 +156,7 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n             connection.sender.send(request.into()).unwrap();\n         }\n \n-        WorldState::new(\n-            ws_roots,\n+        GlobalState::new(\n             workspaces,\n             config.lru_capacity,\n             &globs,\n@@ -173,7 +165,7 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n         )\n     };\n \n-    loop_state.roots_total = world_state.vfs.read().n_roots();\n+    loop_state.roots_total = global_state.vfs.read().n_roots();\n \n     let pool = ThreadPool::default();\n     let (task_sender, task_receiver) = unbounded::<Task>();\n@@ -191,12 +183,12 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n                     Err(RecvError) => return Err(\"client exited without shutdown\".into()),\n                 },\n                 recv(task_receiver) -> task => Event::Task(task.unwrap()),\n-                recv(world_state.task_receiver) -> task => match task {\n+                recv(global_state.task_receiver) -> task => match task {\n                     Ok(task) => Event::Vfs(task),\n                     Err(RecvError) => return Err(\"vfs died\".into()),\n                 },\n                 recv(libdata_receiver) -> data => Event::Lib(data.unwrap()),\n-                recv(world_state.flycheck.as_ref().map_or(&never(), |it| &it.task_recv)) -> task => match task {\n+                recv(global_state.flycheck.as_ref().map_or(&never(), |it| &it.task_recv)) -> task => match task {\n                     Ok(task) => Event::CheckWatcher(task),\n                     Err(RecvError) => return Err(\"check watcher died\".into()),\n                 }\n@@ -211,16 +203,16 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n                 &task_sender,\n                 &libdata_sender,\n                 &connection,\n-                &mut world_state,\n+                &mut global_state,\n                 &mut loop_state,\n                 event,\n             )?;\n         }\n     }\n-    world_state.analysis_host.request_cancellation();\n+    global_state.analysis_host.request_cancellation();\n     log::info!(\"waiting for tasks to finish...\");\n     task_receiver.into_iter().for_each(|task| {\n-        on_task(task, &connection.sender, &mut loop_state.pending_requests, &mut world_state)\n+        on_task(task, &connection.sender, &mut loop_state.pending_requests, &mut global_state)\n     });\n     libdata_receiver.into_iter().for_each(drop);\n     log::info!(\"...tasks have finished\");\n@@ -229,7 +221,7 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n     drop(pool);\n     log::info!(\"...threadpool has finished\");\n \n-    let vfs = Arc::try_unwrap(world_state.vfs).expect(\"all snapshots should be dead\");\n+    let vfs = Arc::try_unwrap(global_state.vfs).expect(\"all snapshots should be dead\");\n     drop(vfs);\n \n     Ok(())\n@@ -320,7 +312,7 @@ fn loop_turn(\n     task_sender: &Sender<Task>,\n     libdata_sender: &Sender<LibraryData>,\n     connection: &Connection,\n-    world_state: &mut WorldState,\n+    global_state: &mut GlobalState,\n     loop_state: &mut LoopState,\n     event: Event,\n ) -> Result<()> {\n@@ -336,22 +328,22 @@ fn loop_turn(\n \n     match event {\n         Event::Task(task) => {\n-            on_task(task, &connection.sender, &mut loop_state.pending_requests, world_state);\n-            world_state.maybe_collect_garbage();\n+            on_task(task, &connection.sender, &mut loop_state.pending_requests, global_state);\n+            global_state.maybe_collect_garbage();\n         }\n         Event::Vfs(task) => {\n-            world_state.vfs.write().handle_task(task);\n+            global_state.vfs.write().handle_task(task);\n         }\n         Event::Lib(lib) => {\n-            world_state.add_lib(lib);\n-            world_state.maybe_collect_garbage();\n+            global_state.add_lib(lib);\n+            global_state.maybe_collect_garbage();\n             loop_state.in_flight_libraries -= 1;\n             loop_state.roots_scanned += 1;\n         }\n-        Event::CheckWatcher(task) => on_check_task(task, world_state, task_sender)?,\n+        Event::CheckWatcher(task) => on_check_task(task, global_state, task_sender)?,\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => on_request(\n-                world_state,\n+                global_state,\n                 &mut loop_state.pending_requests,\n                 pool,\n                 task_sender,\n@@ -360,7 +352,7 @@ fn loop_turn(\n                 req,\n             )?,\n             Message::Notification(not) => {\n-                on_notification(&connection.sender, world_state, loop_state, not)?;\n+                on_notification(&connection.sender, global_state, loop_state, not)?;\n             }\n             Message::Response(resp) => {\n                 let removed = loop_state.pending_responses.remove(&resp.id);\n@@ -379,9 +371,9 @@ fn loop_turn(\n                         }\n                         (None, Some(configs)) => {\n                             if let Some(new_config) = configs.get(0) {\n-                                let mut config = world_state.config.clone();\n+                                let mut config = global_state.config.clone();\n                                 config.update(&new_config);\n-                                world_state.update_configuration(config);\n+                                global_state.update_configuration(config);\n                             }\n                         }\n                         (None, None) => {\n@@ -394,7 +386,7 @@ fn loop_turn(\n     };\n \n     let mut state_changed = false;\n-    if let Some(changes) = world_state.process_changes(&mut loop_state.roots_scanned) {\n+    if let Some(changes) = global_state.process_changes(&mut loop_state.roots_scanned) {\n         state_changed = true;\n         loop_state.pending_libraries.extend(changes);\n     }\n@@ -416,7 +408,7 @@ fn loop_turn(\n     }\n \n     let show_progress =\n-        !loop_state.workspace_loaded && world_state.config.client_caps.work_done_progress;\n+        !loop_state.workspace_loaded && global_state.config.client_caps.work_done_progress;\n \n     if !loop_state.workspace_loaded\n         && loop_state.roots_scanned == loop_state.roots_total\n@@ -425,7 +417,7 @@ fn loop_turn(\n     {\n         state_changed = true;\n         loop_state.workspace_loaded = true;\n-        if let Some(flycheck) = &world_state.flycheck {\n+        if let Some(flycheck) = &global_state.flycheck {\n             flycheck.update();\n         }\n     }\n@@ -437,13 +429,13 @@ fn loop_turn(\n     if state_changed && loop_state.workspace_loaded {\n         update_file_notifications_on_threadpool(\n             pool,\n-            world_state.snapshot(),\n+            global_state.snapshot(),\n             task_sender.clone(),\n             loop_state.subscriptions.subscriptions(),\n         );\n         pool.execute({\n             let subs = loop_state.subscriptions.subscriptions();\n-            let snap = world_state.snapshot();\n+            let snap = global_state.snapshot();\n             move || snap.analysis().prime_caches(subs).unwrap_or_else(|_: Canceled| ())\n         });\n     }\n@@ -467,7 +459,7 @@ fn on_task(\n     task: Task,\n     msg_sender: &Sender<Message>,\n     pending_requests: &mut PendingRequests,\n-    state: &mut WorldState,\n+    state: &mut GlobalState,\n ) {\n     match task {\n         Task::Respond(response) => {\n@@ -485,7 +477,7 @@ fn on_task(\n }\n \n fn on_request(\n-    world: &mut WorldState,\n+    global_state: &mut GlobalState,\n     pending_requests: &mut PendingRequests,\n     pool: &ThreadPool,\n     task_sender: &Sender<Task>,\n@@ -496,7 +488,7 @@ fn on_request(\n     let mut pool_dispatcher = PoolDispatcher {\n         req: Some(req),\n         pool,\n-        world,\n+        global_state,\n         task_sender,\n         msg_sender,\n         pending_requests,\n@@ -553,7 +545,7 @@ fn on_request(\n \n fn on_notification(\n     msg_sender: &Sender<Message>,\n-    state: &mut WorldState,\n+    state: &mut GlobalState,\n     loop_state: &mut LoopState,\n     not: Notification,\n ) -> Result<()> {\n@@ -727,7 +719,7 @@ fn apply_document_changes(\n \n fn on_check_task(\n     task: CheckTask,\n-    world_state: &mut WorldState,\n+    global_state: &mut GlobalState,\n     task_sender: &Sender<Task>,\n ) -> Result<()> {\n     match task {\n@@ -746,7 +738,7 @@ fn on_check_task(\n                     .uri\n                     .to_file_path()\n                     .map_err(|()| format!(\"invalid uri: {}\", diag.location.uri))?;\n-                let file_id = match world_state.vfs.read().path2file(&path) {\n+                let file_id = match global_state.vfs.read().path2file(&path) {\n                     Some(file) => FileId(file.0),\n                     None => {\n                         log::error!(\n@@ -766,7 +758,7 @@ fn on_check_task(\n         }\n \n         CheckTask::Status(status) => {\n-            if world_state.config.client_caps.work_done_progress {\n+            if global_state.config.client_caps.work_done_progress {\n                 let progress = match status {\n                     Status::Being => {\n                         lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n@@ -805,7 +797,7 @@ fn on_check_task(\n     Ok(())\n }\n \n-fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state: &mut WorldState) {\n+fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state: &mut GlobalState) {\n     let subscriptions = state.diagnostics.handle_task(task);\n \n     for file_id in subscriptions {\n@@ -880,7 +872,7 @@ fn send_startup_progress(sender: &Sender<Message>, loop_state: &mut LoopState) {\n struct PoolDispatcher<'a> {\n     req: Option<Request>,\n     pool: &'a ThreadPool,\n-    world: &'a mut WorldState,\n+    global_state: &'a mut GlobalState,\n     pending_requests: &'a mut PendingRequests,\n     msg_sender: &'a Sender<Message>,\n     task_sender: &'a Sender<Task>,\n@@ -891,7 +883,7 @@ impl<'a> PoolDispatcher<'a> {\n     /// Dispatches the request onto the current thread\n     fn on_sync<R>(\n         &mut self,\n-        f: fn(&mut WorldState, R::Params) -> Result<R::Result>,\n+        f: fn(&mut GlobalState, R::Params) -> Result<R::Result>,\n     ) -> Result<&mut Self>\n     where\n         R: lsp_types::request::Request + 'static,\n@@ -904,18 +896,21 @@ impl<'a> PoolDispatcher<'a> {\n                 return Ok(self);\n             }\n         };\n-        let world = panic::AssertUnwindSafe(&mut *self.world);\n+        let world = panic::AssertUnwindSafe(&mut *self.global_state);\n         let task = panic::catch_unwind(move || {\n             let result = f(world.0, params);\n             result_to_task::<R>(id, result)\n         })\n         .map_err(|_| format!(\"sync task {:?} panicked\", R::METHOD))?;\n-        on_task(task, self.msg_sender, self.pending_requests, self.world);\n+        on_task(task, self.msg_sender, self.pending_requests, self.global_state);\n         Ok(self)\n     }\n \n     /// Dispatches the request onto thread pool\n-    fn on<R>(&mut self, f: fn(WorldSnapshot, R::Params) -> Result<R::Result>) -> Result<&mut Self>\n+    fn on<R>(\n+        &mut self,\n+        f: fn(GlobalStateSnapshot, R::Params) -> Result<R::Result>,\n+    ) -> Result<&mut Self>\n     where\n         R: lsp_types::request::Request + 'static,\n         R::Params: DeserializeOwned + Send + 'static,\n@@ -929,7 +924,7 @@ impl<'a> PoolDispatcher<'a> {\n         };\n \n         self.pool.execute({\n-            let world = self.world.snapshot();\n+            let world = self.global_state.snapshot();\n             let sender = self.task_sender.clone();\n             move || {\n                 let result = f(world, params);\n@@ -1013,7 +1008,7 @@ where\n \n fn update_file_notifications_on_threadpool(\n     pool: &ThreadPool,\n-    world: WorldSnapshot,\n+    world: GlobalStateSnapshot,\n     task_sender: Sender<Task>,\n     subscriptions: Vec<FileId>,\n ) {"}, {"sha": "a3361d6dc5e9d3f7f655830a4fa9751a67886058", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 197, "deletions": 193, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -32,17 +32,16 @@ use crate::{\n     config::RustfmtConfig,\n     diagnostics::DiagnosticTask,\n     from_json, from_proto,\n+    global_state::GlobalStateSnapshot,\n     lsp_ext::{self, InlayHint, InlayHintsParams},\n-    to_proto,\n-    world::WorldSnapshot,\n-    LspError, Result,\n+    to_proto, LspError, Result,\n };\n \n-pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n+pub fn handle_analyzer_status(snap: GlobalStateSnapshot, _: ()) -> Result<String> {\n     let _p = profile(\"handle_analyzer_status\");\n-    let mut buf = world.status();\n+    let mut buf = snap.status();\n     format_to!(buf, \"\\n\\nrequests:\\n\");\n-    let requests = world.latest_requests.read();\n+    let requests = snap.latest_requests.read();\n     for (is_last, r) in requests.iter() {\n         let mark = if is_last { \"*\" } else { \" \" };\n         format_to!(buf, \"{}{:4} {:<36}{}ms\\n\", mark, r.id, r.method, r.duration.as_millis());\n@@ -51,37 +50,37 @@ pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n }\n \n pub fn handle_syntax_tree(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::SyntaxTreeParams,\n ) -> Result<String> {\n     let _p = profile(\"handle_syntax_tree\");\n-    let id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(id)?;\n+    let id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(id)?;\n     let text_range = params.range.map(|r| from_proto::text_range(&line_index, r));\n-    let res = world.analysis().syntax_tree(id, text_range)?;\n+    let res = snap.analysis().syntax_tree(id, text_range)?;\n     Ok(res)\n }\n \n pub fn handle_expand_macro(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::ExpandMacroParams,\n ) -> Result<Option<lsp_ext::ExpandedMacro>> {\n     let _p = profile(\"handle_expand_macro\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let offset = from_proto::offset(&line_index, params.position);\n \n-    let res = world.analysis().expand_macro(FilePosition { file_id, offset })?;\n+    let res = snap.analysis().expand_macro(FilePosition { file_id, offset })?;\n     Ok(res.map(|it| lsp_ext::ExpandedMacro { name: it.name, expansion: it.expansion }))\n }\n \n pub fn handle_selection_range(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::SelectionRangeParams,\n ) -> Result<Option<Vec<lsp_types::SelectionRange>>> {\n     let _p = profile(\"handle_selection_range\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let res: Result<Vec<lsp_types::SelectionRange>> = params\n         .positions\n         .into_iter()\n@@ -93,7 +92,7 @@ pub fn handle_selection_range(\n                 loop {\n                     ranges.push(range);\n                     let frange = FileRange { file_id, range };\n-                    let next = world.analysis().extend_selection(frange)?;\n+                    let next = snap.analysis().extend_selection(frange)?;\n                     if next == range {\n                         break;\n                     } else {\n@@ -119,18 +118,18 @@ pub fn handle_selection_range(\n }\n \n pub fn handle_matching_brace(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::MatchingBraceParams,\n ) -> Result<Vec<Position>> {\n     let _p = profile(\"handle_matching_brace\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let res = params\n         .positions\n         .into_iter()\n         .map(|position| {\n             let offset = from_proto::offset(&line_index, position);\n-            let offset = match world.analysis().matching_brace(FilePosition { file_id, offset }) {\n+            let offset = match snap.analysis().matching_brace(FilePosition { file_id, offset }) {\n                 Ok(Some(matching_brace_offset)) => matching_brace_offset,\n                 Err(_) | Ok(None) => offset,\n             };\n@@ -141,17 +140,17 @@ pub fn handle_matching_brace(\n }\n \n pub fn handle_join_lines(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::JoinLinesParams,\n ) -> Result<Vec<lsp_types::TextEdit>> {\n     let _p = profile(\"handle_join_lines\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let line_endings = world.file_line_endings(file_id);\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_endings = snap.file_line_endings(file_id);\n     let mut res = TextEdit::default();\n     for range in params.ranges {\n         let range = from_proto::text_range(&line_index, range);\n-        let edit = world.analysis().join_lines(FileRange { file_id, range })?;\n+        let edit = snap.analysis().join_lines(FileRange { file_id, range })?;\n         match res.union(edit) {\n             Ok(()) => (),\n             Err(_edit) => {\n@@ -164,37 +163,37 @@ pub fn handle_join_lines(\n }\n \n pub fn handle_on_enter(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentPositionParams,\n ) -> Result<Option<Vec<lsp_ext::SnippetTextEdit>>> {\n     let _p = profile(\"handle_on_enter\");\n-    let position = from_proto::file_position(&world, params)?;\n-    let edit = match world.analysis().on_enter(position)? {\n+    let position = from_proto::file_position(&snap, params)?;\n+    let edit = match snap.analysis().on_enter(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n-    let line_endings = world.file_line_endings(position.file_id);\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_endings = snap.file_line_endings(position.file_id);\n     let edit = to_proto::snippet_text_edit_vec(&line_index, line_endings, true, edit);\n     Ok(Some(edit))\n }\n \n // Don't forget to add new trigger characters to `ServerCapabilities` in `caps.rs`.\n pub fn handle_on_type_formatting(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::DocumentOnTypeFormattingParams,\n ) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n     let _p = profile(\"handle_on_type_formatting\");\n-    let mut position = from_proto::file_position(&world, params.text_document_position)?;\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n-    let line_endings = world.file_line_endings(position.file_id);\n+    let mut position = from_proto::file_position(&snap, params.text_document_position)?;\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_endings = snap.file_line_endings(position.file_id);\n \n     // in `ra_ide`, the `on_type` invariant is that\n     // `text.char_at(position) == typed_char`.\n     position.offset -= TextSize::of('.');\n     let char_typed = params.ch.chars().next().unwrap_or('\\0');\n     assert!({\n-        let text = world.analysis().file_text(position.file_id)?;\n+        let text = snap.analysis().file_text(position.file_id)?;\n         text[usize::from(position.offset)..].starts_with(char_typed)\n     });\n \n@@ -206,7 +205,7 @@ pub fn handle_on_type_formatting(\n         return Ok(None);\n     }\n \n-    let edit = world.analysis().on_char_typed(position, char_typed)?;\n+    let edit = snap.analysis().on_char_typed(position, char_typed)?;\n     let mut edit = match edit {\n         Some(it) => it,\n         None => return Ok(None),\n@@ -220,16 +219,16 @@ pub fn handle_on_type_formatting(\n }\n \n pub fn handle_document_symbol(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::DocumentSymbolParams,\n ) -> Result<Option<lsp_types::DocumentSymbolResponse>> {\n     let _p = profile(\"handle_document_symbol\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n \n     let mut parents: Vec<(DocumentSymbol, Option<usize>)> = Vec::new();\n \n-    for symbol in world.analysis().file_structure(file_id)? {\n+    for symbol in snap.analysis().file_structure(file_id)? {\n         let doc_symbol = DocumentSymbol {\n             name: symbol.label,\n             detail: symbol.detail,\n@@ -255,10 +254,10 @@ pub fn handle_document_symbol(\n         }\n     }\n \n-    let res = if world.config.client_caps.hierarchical_symbols {\n+    let res = if snap.config.client_caps.hierarchical_symbols {\n         document_symbols.into()\n     } else {\n-        let url = to_proto::url(&world, file_id)?;\n+        let url = to_proto::url(&snap, file_id)?;\n         let mut symbol_information = Vec::<SymbolInformation>::new();\n         for symbol in document_symbols {\n             flatten_document_symbol(&symbol, None, &url, &mut symbol_information);\n@@ -288,7 +287,7 @@ pub fn handle_document_symbol(\n }\n \n pub fn handle_workspace_symbol(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::WorkspaceSymbolParams,\n ) -> Result<Option<Vec<SymbolInformation>>> {\n     let _p = profile(\"handle_workspace_symbol\");\n@@ -306,22 +305,22 @@ pub fn handle_workspace_symbol(\n         q.limit(128);\n         q\n     };\n-    let mut res = exec_query(&world, query)?;\n+    let mut res = exec_query(&snap, query)?;\n     if res.is_empty() && !all_symbols {\n         let mut query = Query::new(params.query);\n         query.limit(128);\n-        res = exec_query(&world, query)?;\n+        res = exec_query(&snap, query)?;\n     }\n \n     return Ok(Some(res));\n \n-    fn exec_query(world: &WorldSnapshot, query: Query) -> Result<Vec<SymbolInformation>> {\n+    fn exec_query(snap: &GlobalStateSnapshot, query: Query) -> Result<Vec<SymbolInformation>> {\n         let mut res = Vec::new();\n-        for nav in world.analysis().symbol_search(query)? {\n+        for nav in snap.analysis().symbol_search(query)? {\n             let info = SymbolInformation {\n                 name: nav.name().to_string(),\n                 kind: to_proto::symbol_kind(nav.kind()),\n-                location: to_proto::location(world, nav.file_range())?,\n+                location: to_proto::location(snap, nav.file_range())?,\n                 container_name: nav.container_name().map(|v| v.to_string()),\n                 deprecated: None,\n             };\n@@ -332,73 +331,73 @@ pub fn handle_workspace_symbol(\n }\n \n pub fn handle_goto_definition(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::GotoDefinitionParams,\n ) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n     let _p = profile(\"handle_goto_definition\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let nav_info = match world.analysis().goto_definition(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let nav_info = match snap.analysis().goto_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n     let src = FileRange { file_id: position.file_id, range: nav_info.range };\n-    let res = to_proto::goto_definition_response(&world, Some(src), nav_info.info)?;\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n     Ok(Some(res))\n }\n \n pub fn handle_goto_implementation(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::request::GotoImplementationParams,\n ) -> Result<Option<lsp_types::request::GotoImplementationResponse>> {\n     let _p = profile(\"handle_goto_implementation\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let nav_info = match world.analysis().goto_implementation(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let nav_info = match snap.analysis().goto_implementation(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n     let src = FileRange { file_id: position.file_id, range: nav_info.range };\n-    let res = to_proto::goto_definition_response(&world, Some(src), nav_info.info)?;\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n     Ok(Some(res))\n }\n \n pub fn handle_goto_type_definition(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::request::GotoTypeDefinitionParams,\n ) -> Result<Option<lsp_types::request::GotoTypeDefinitionResponse>> {\n     let _p = profile(\"handle_goto_type_definition\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let nav_info = match world.analysis().goto_type_definition(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let nav_info = match snap.analysis().goto_type_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n     let src = FileRange { file_id: position.file_id, range: nav_info.range };\n-    let res = to_proto::goto_definition_response(&world, Some(src), nav_info.info)?;\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n     Ok(Some(res))\n }\n \n pub fn handle_parent_module(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentPositionParams,\n ) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n     let _p = profile(\"handle_parent_module\");\n-    let position = from_proto::file_position(&world, params)?;\n-    let navs = world.analysis().parent_module(position)?;\n-    let res = to_proto::goto_definition_response(&world, None, navs)?;\n+    let position = from_proto::file_position(&snap, params)?;\n+    let navs = snap.analysis().parent_module(position)?;\n+    let res = to_proto::goto_definition_response(&snap, None, navs)?;\n     Ok(Some(res))\n }\n \n pub fn handle_runnables(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::RunnablesParams,\n ) -> Result<Vec<lsp_ext::Runnable>> {\n     let _p = profile(\"handle_runnables\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let offset = params.position.map(|it| from_proto::offset(&line_index, it));\n     let mut res = Vec::new();\n-    let workspace_root = world.workspace_root_for(file_id);\n-    let cargo_spec = CargoTargetSpec::for_file(&world, file_id)?;\n-    for runnable in world.analysis().runnables(file_id)? {\n+    let workspace_root = snap.workspace_root_for(file_id);\n+    let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n+    for runnable in snap.analysis().runnables(file_id)? {\n         if let Some(offset) = offset {\n             if !runnable.nav.full_range().contains_inclusive(offset) {\n                 continue;\n@@ -413,7 +412,7 @@ pub fn handle_runnables(\n                 }\n             }\n         }\n-        res.push(to_proto::runnable(&world, file_id, runnable)?);\n+        res.push(to_proto::runnable(&snap, file_id, runnable)?);\n     }\n \n     // Add `cargo check` and `cargo test` for the whole package\n@@ -453,16 +452,16 @@ pub fn handle_runnables(\n }\n \n pub fn handle_completion(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::CompletionParams,\n ) -> Result<Option<lsp_types::CompletionResponse>> {\n     let _p = profile(\"handle_completion\");\n-    let position = from_proto::file_position(&world, params.text_document_position)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position)?;\n     let completion_triggered_after_single_colon = {\n         let mut res = false;\n         if let Some(ctx) = params.context {\n             if ctx.trigger_character.unwrap_or_default() == \":\" {\n-                let source_file = world.analysis().parse(position.file_id)?;\n+                let source_file = snap.analysis().parse(position.file_id)?;\n                 let syntax = source_file.syntax();\n                 let text = syntax.text();\n                 if let Some(next_char) = text.char_at(position.offset) {\n@@ -480,12 +479,12 @@ pub fn handle_completion(\n         return Ok(None);\n     }\n \n-    let items = match world.analysis().completions(&world.config.completion, position)? {\n+    let items = match snap.analysis().completions(&snap.config.completion, position)? {\n         None => return Ok(None),\n         Some(items) => items,\n     };\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n-    let line_endings = world.file_line_endings(position.file_id);\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_endings = snap.file_line_endings(position.file_id);\n     let items: Vec<CompletionItem> = items\n         .into_iter()\n         .map(|item| to_proto::completion_item(&line_index, line_endings, item))\n@@ -495,15 +494,15 @@ pub fn handle_completion(\n }\n \n pub fn handle_folding_range(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: FoldingRangeParams,\n ) -> Result<Option<Vec<FoldingRange>>> {\n     let _p = profile(\"handle_folding_range\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let folds = world.analysis().folding_ranges(file_id)?;\n-    let text = world.analysis().file_text(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let line_folding_only = world.config.client_caps.line_folding_only;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let folds = snap.analysis().folding_ranges(file_id)?;\n+    let text = snap.analysis().file_text(file_id)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_folding_only = snap.config.client_caps.line_folding_only;\n     let res = folds\n         .into_iter()\n         .map(|it| to_proto::folding_range(&*text, &line_index, line_folding_only, it))\n@@ -512,16 +511,16 @@ pub fn handle_folding_range(\n }\n \n pub fn handle_signature_help(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::SignatureHelpParams,\n ) -> Result<Option<lsp_types::SignatureHelp>> {\n     let _p = profile(\"handle_signature_help\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let call_info = match world.analysis().call_info(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let call_info = match snap.analysis().call_info(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let concise = !world.config.call_info_full;\n+    let concise = !snap.config.call_info_full;\n     let mut active_parameter = call_info.active_parameter.map(|it| it as i64);\n     if concise && call_info.signature.has_self_param {\n         active_parameter = active_parameter.map(|it| it.saturating_sub(1));\n@@ -535,14 +534,17 @@ pub fn handle_signature_help(\n     }))\n }\n \n-pub fn handle_hover(world: WorldSnapshot, params: lsp_types::HoverParams) -> Result<Option<Hover>> {\n+pub fn handle_hover(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::HoverParams,\n+) -> Result<Option<Hover>> {\n     let _p = profile(\"handle_hover\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let info = match world.analysis().hover(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let info = match snap.analysis().hover(position)? {\n         None => return Ok(None),\n         Some(info) => info,\n     };\n-    let line_index = world.analysis.file_line_index(position.file_id)?;\n+    let line_index = snap.analysis.file_line_index(position.file_id)?;\n     let range = to_proto::range(&line_index, info.range);\n     let res = Hover {\n         contents: HoverContents::Markup(MarkupContent {\n@@ -555,26 +557,29 @@ pub fn handle_hover(world: WorldSnapshot, params: lsp_types::HoverParams) -> Res\n }\n \n pub fn handle_prepare_rename(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentPositionParams,\n ) -> Result<Option<PrepareRenameResponse>> {\n     let _p = profile(\"handle_prepare_rename\");\n-    let position = from_proto::file_position(&world, params)?;\n+    let position = from_proto::file_position(&snap, params)?;\n \n-    let optional_change = world.analysis().rename(position, \"dummy\")?;\n+    let optional_change = snap.analysis().rename(position, \"dummy\")?;\n     let range = match optional_change {\n         None => return Ok(None),\n         Some(it) => it.range,\n     };\n \n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n     let range = to_proto::range(&line_index, range);\n     Ok(Some(PrepareRenameResponse::Range(range)))\n }\n \n-pub fn handle_rename(world: WorldSnapshot, params: RenameParams) -> Result<Option<WorkspaceEdit>> {\n+pub fn handle_rename(\n+    snap: GlobalStateSnapshot,\n+    params: RenameParams,\n+) -> Result<Option<WorkspaceEdit>> {\n     let _p = profile(\"handle_rename\");\n-    let position = from_proto::file_position(&world, params.text_document_position)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position)?;\n \n     if params.new_name.is_empty() {\n         return Err(LspError::new(\n@@ -584,61 +589,61 @@ pub fn handle_rename(world: WorldSnapshot, params: RenameParams) -> Result<Optio\n         .into());\n     }\n \n-    let optional_change = world.analysis().rename(position, &*params.new_name)?;\n+    let optional_change = snap.analysis().rename(position, &*params.new_name)?;\n     let source_change = match optional_change {\n         None => return Ok(None),\n         Some(it) => it.info,\n     };\n-    let workspace_edit = to_proto::workspace_edit(&world, source_change)?;\n+    let workspace_edit = to_proto::workspace_edit(&snap, source_change)?;\n     Ok(Some(workspace_edit))\n }\n \n pub fn handle_references(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::ReferenceParams,\n ) -> Result<Option<Vec<Location>>> {\n     let _p = profile(\"handle_references\");\n-    let position = from_proto::file_position(&world, params.text_document_position)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position)?;\n \n-    let refs = match world.analysis().find_all_refs(position, None)? {\n+    let refs = match snap.analysis().find_all_refs(position, None)? {\n         None => return Ok(None),\n         Some(refs) => refs,\n     };\n \n     let locations = if params.context.include_declaration {\n         refs.into_iter()\n-            .filter_map(|reference| to_proto::location(&world, reference.file_range).ok())\n+            .filter_map(|reference| to_proto::location(&snap, reference.file_range).ok())\n             .collect()\n     } else {\n         // Only iterate over the references if include_declaration was false\n         refs.references()\n             .iter()\n-            .filter_map(|reference| to_proto::location(&world, reference.file_range).ok())\n+            .filter_map(|reference| to_proto::location(&snap, reference.file_range).ok())\n             .collect()\n     };\n \n     Ok(Some(locations))\n }\n \n pub fn handle_formatting(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: DocumentFormattingParams,\n ) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n     let _p = profile(\"handle_formatting\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let file = world.analysis().file_text(file_id)?;\n-    let crate_ids = world.analysis().crate_for(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let file = snap.analysis().file_text(file_id)?;\n+    let crate_ids = snap.analysis().crate_for(file_id)?;\n \n-    let file_line_index = world.analysis().file_line_index(file_id)?;\n+    let file_line_index = snap.analysis().file_line_index(file_id)?;\n     let end_position = to_proto::position(&file_line_index, TextSize::of(file.as_str()));\n \n-    let mut rustfmt = match &world.config.rustfmt {\n+    let mut rustfmt = match &snap.config.rustfmt {\n         RustfmtConfig::Rustfmt { extra_args } => {\n             let mut cmd = process::Command::new(\"rustfmt\");\n             cmd.args(extra_args);\n             if let Some(&crate_id) = crate_ids.first() {\n                 // Assume all crates are in the same edition\n-                let edition = world.analysis().crate_edition(crate_id)?;\n+                let edition = snap.analysis().crate_edition(crate_id)?;\n                 cmd.arg(\"--edition\");\n                 cmd.arg(edition.to_string());\n             }\n@@ -697,15 +702,14 @@ pub fn handle_formatting(\n }\n \n fn handle_fixes(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     params: &lsp_types::CodeActionParams,\n     res: &mut Vec<lsp_ext::CodeAction>,\n ) -> Result<()> {\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let range = from_proto::text_range(&line_index, params.range);\n-\n-    let diagnostics = world.analysis().diagnostics(file_id)?;\n+    let diagnostics = snap.analysis().diagnostics(file_id)?;\n \n     let fixes_from_diagnostics = diagnostics\n         .into_iter()\n@@ -714,18 +718,19 @@ fn handle_fixes(\n         .map(|(_range, fix)| fix);\n     for fix in fixes_from_diagnostics {\n         let title = fix.label;\n-        let edit = to_proto::snippet_workspace_edit(&world, fix.source_change)?;\n+        let edit = to_proto::snippet_workspace_edit(&snap, fix.source_change)?;\n         let action = lsp_ext::CodeAction {\n             title,\n             id: None,\n             group: None,\n-            kind: None,\n+            kind: Some(lsp_types::code_action_kind::QUICKFIX.into()),\n             edit: Some(edit),\n             command: None,\n         };\n         res.push(action);\n     }\n-    for fix in world.check_fixes.get(&file_id).into_iter().flatten() {\n+\n+    for fix in snap.check_fixes.get(&file_id).into_iter().flatten() {\n         let fix_range = from_proto::text_range(&line_index, fix.range);\n         if fix_range.intersect(range).is_none() {\n             continue;\n@@ -736,81 +741,78 @@ fn handle_fixes(\n }\n \n pub fn handle_code_action(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::CodeActionParams,\n ) -> Result<Option<Vec<lsp_ext::CodeAction>>> {\n     let _p = profile(\"handle_code_action\");\n     // We intentionally don't support command-based actions, as those either\n     // requires custom client-code anyway, or requires server-initiated edits.\n     // Server initiated edits break causality, so we avoid those as well.\n-    if !world.config.client_caps.code_action_literals {\n+    if !snap.config.client_caps.code_action_literals {\n         return Ok(None);\n     }\n \n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let range = from_proto::text_range(&line_index, params.range);\n     let frange = FileRange { file_id, range };\n     let mut res: Vec<lsp_ext::CodeAction> = Vec::new();\n \n-    handle_fixes(&world, &params, &mut res)?;\n+    handle_fixes(&snap, &params, &mut res)?;\n \n-    if world.config.client_caps.resolve_code_action {\n-        for (index, assist) in world\n-            .analysis()\n-            .unresolved_assists(&world.config.assist, frange)?\n-            .into_iter()\n-            .enumerate()\n+    if snap.config.client_caps.resolve_code_action {\n+        for (index, assist) in\n+            snap.analysis().unresolved_assists(&snap.config.assist, frange)?.into_iter().enumerate()\n         {\n-            res.push(to_proto::unresolved_code_action(&world, assist, index)?);\n+            res.push(to_proto::unresolved_code_action(&snap, assist, index)?);\n         }\n     } else {\n-        for assist in world.analysis().resolved_assists(&world.config.assist, frange)?.into_iter() {\n-            res.push(to_proto::resolved_code_action(&world, assist)?);\n+        for assist in snap.analysis().resolved_assists(&snap.config.assist, frange)?.into_iter() {\n+            res.push(to_proto::resolved_code_action(&snap, assist)?);\n         }\n     }\n \n     Ok(Some(res))\n }\n \n pub fn handle_resolve_code_action(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::ResolveCodeActionParams,\n ) -> Result<Option<lsp_ext::SnippetWorkspaceEdit>> {\n     let _p = profile(\"handle_resolve_code_action\");\n-    let file_id = from_proto::file_id(&world, &params.code_action_params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.code_action_params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let range = from_proto::text_range(&line_index, params.code_action_params.range);\n     let frange = FileRange { file_id, range };\n \n-    let assists = world.analysis().resolved_assists(&world.config.assist, frange)?;\n+    let assists = snap.analysis().resolved_assists(&snap.config.assist, frange)?;\n     let id_components = params.id.split(\":\").collect::<Vec<&str>>();\n     let index = id_components.last().unwrap().parse::<usize>().unwrap();\n     let id_string = id_components.first().unwrap();\n     let assist = &assists[index];\n     assert!(assist.assist.id.0 == *id_string);\n-    Ok(to_proto::resolved_code_action(&world, assist.clone())?.edit)\n+    Ok(to_proto::resolved_code_action(&snap, assist.clone())?.edit)\n }\n \n pub fn handle_code_lens(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::CodeLensParams,\n ) -> Result<Option<Vec<CodeLens>>> {\n     let _p = profile(\"handle_code_lens\");\n     let mut lenses: Vec<CodeLens> = Default::default();\n \n-    if world.config.lens.none() {\n+    if snap.config.lens.none() {\n         // early return before any db query!\n         return Ok(Some(lenses));\n     }\n \n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let cargo_spec = CargoTargetSpec::for_file(&world, file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n \n-    if world.config.lens.runnable() {\n+    if snap.config.lens.runnable() {\n         // Gather runnables\n-        for runnable in world.analysis().runnables(file_id)? {\n+        for runnable in snap.analysis().runnables(file_id)? {\n             let (run_title, debugee) = match &runnable.kind {\n                 RunnableKind::Test { .. } | RunnableKind::TestMod { .. } => {\n                     (\"\u25b6\\u{fe0e} Run Test\", true)\n@@ -836,8 +838,8 @@ pub fn handle_code_lens(\n             };\n \n             let range = to_proto::range(&line_index, runnable.nav.range());\n-            let r = to_proto::runnable(&world, file_id, runnable)?;\n-            if world.config.lens.run {\n+            let r = to_proto::runnable(&snap, file_id, runnable)?;\n+            if snap.config.lens.run {\n                 let lens = CodeLens {\n                     range,\n                     command: Some(Command {\n@@ -850,7 +852,7 @@ pub fn handle_code_lens(\n                 lenses.push(lens);\n             }\n \n-            if debugee && world.config.lens.debug {\n+            if debugee && snap.config.lens.debug {\n                 let debug_lens = CodeLens {\n                     range,\n                     command: Some(Command {\n@@ -865,11 +867,10 @@ pub fn handle_code_lens(\n         }\n     }\n \n-    if world.config.lens.impementations {\n+    if snap.config.lens.impementations {\n         // Handle impls\n         lenses.extend(\n-            world\n-                .analysis()\n+            snap.analysis()\n                 .file_structure(file_id)?\n                 .into_iter()\n                 .filter(|it| match it.kind {\n@@ -904,14 +905,17 @@ enum CodeLensResolveData {\n     Impls(lsp_types::request::GotoImplementationParams),\n }\n \n-pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Result<CodeLens> {\n+pub fn handle_code_lens_resolve(\n+    snap: GlobalStateSnapshot,\n+    code_lens: CodeLens,\n+) -> Result<CodeLens> {\n     let _p = profile(\"handle_code_lens_resolve\");\n     let data = code_lens.data.unwrap();\n     let resolve = from_json::<Option<CodeLensResolveData>>(\"CodeLensResolveData\", data)?;\n     match resolve {\n         Some(CodeLensResolveData::Impls(lens_params)) => {\n             let locations: Vec<Location> =\n-                match handle_goto_implementation(world, lens_params.clone())? {\n+                match handle_goto_implementation(snap, lens_params.clone())? {\n                     Some(lsp_types::GotoDefinitionResponse::Scalar(loc)) => vec![loc],\n                     Some(lsp_types::GotoDefinitionResponse::Array(locs)) => locs,\n                     Some(lsp_types::GotoDefinitionResponse::Link(links)) => links\n@@ -950,14 +954,14 @@ pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Re\n }\n \n pub fn handle_document_highlight(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::DocumentHighlightParams,\n ) -> Result<Option<Vec<DocumentHighlight>>> {\n     let _p = profile(\"handle_document_highlight\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n \n-    let refs = match world\n+    let refs = match snap\n         .analysis()\n         .find_all_refs(position, Some(SearchScope::single_file(position.file_id)))?\n     {\n@@ -977,19 +981,19 @@ pub fn handle_document_highlight(\n }\n \n pub fn handle_ssr(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::SsrParams,\n ) -> Result<lsp_types::WorkspaceEdit> {\n     let _p = profile(\"handle_ssr\");\n     let source_change =\n-        world.analysis().structural_search_replace(&params.query, params.parse_only)??;\n-    to_proto::workspace_edit(&world, source_change)\n+        snap.analysis().structural_search_replace(&params.query, params.parse_only)??;\n+    to_proto::workspace_edit(&snap, source_change)\n }\n \n-pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<DiagnosticTask> {\n+pub fn publish_diagnostics(snap: &GlobalStateSnapshot, file_id: FileId) -> Result<DiagnosticTask> {\n     let _p = profile(\"publish_diagnostics\");\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let diagnostics: Vec<Diagnostic> = world\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let diagnostics: Vec<Diagnostic> = snap\n         .analysis()\n         .diagnostics(file_id)?\n         .into_iter()\n@@ -1007,28 +1011,28 @@ pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<Dia\n }\n \n pub fn handle_inlay_hints(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: InlayHintsParams,\n ) -> Result<Vec<InlayHint>> {\n     let _p = profile(\"handle_inlay_hints\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let analysis = world.analysis();\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let analysis = snap.analysis();\n     let line_index = analysis.file_line_index(file_id)?;\n     Ok(analysis\n-        .inlay_hints(file_id, &world.config.inlay_hints)?\n+        .inlay_hints(file_id, &snap.config.inlay_hints)?\n         .into_iter()\n         .map(|it| to_proto::inlay_int(&line_index, it))\n         .collect())\n }\n \n pub fn handle_call_hierarchy_prepare(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: CallHierarchyPrepareParams,\n ) -> Result<Option<Vec<CallHierarchyItem>>> {\n     let _p = profile(\"handle_call_hierarchy_prepare\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n \n-    let nav_info = match world.analysis().call_hierarchy(position)? {\n+    let nav_info = match snap.analysis().call_hierarchy(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -1037,24 +1041,24 @@ pub fn handle_call_hierarchy_prepare(\n     let res = navs\n         .into_iter()\n         .filter(|it| it.kind() == SyntaxKind::FN_DEF)\n-        .map(|it| to_proto::call_hierarchy_item(&world, it))\n+        .map(|it| to_proto::call_hierarchy_item(&snap, it))\n         .collect::<Result<Vec<_>>>()?;\n \n     Ok(Some(res))\n }\n \n pub fn handle_call_hierarchy_incoming(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: CallHierarchyIncomingCallsParams,\n ) -> Result<Option<Vec<CallHierarchyIncomingCall>>> {\n     let _p = profile(\"handle_call_hierarchy_incoming\");\n     let item = params.item;\n \n     let doc = TextDocumentIdentifier::new(item.uri);\n-    let frange = from_proto::file_range(&world, doc, item.range)?;\n+    let frange = from_proto::file_range(&snap, doc, item.range)?;\n     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n-    let call_items = match world.analysis().incoming_calls(fpos)? {\n+    let call_items = match snap.analysis().incoming_calls(fpos)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -1063,8 +1067,8 @@ pub fn handle_call_hierarchy_incoming(\n \n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id();\n-        let line_index = world.analysis().file_line_index(file_id)?;\n-        let item = to_proto::call_hierarchy_item(&world, call_item.target)?;\n+        let line_index = snap.analysis().file_line_index(file_id)?;\n+        let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n         res.push(CallHierarchyIncomingCall {\n             from: item,\n             from_ranges: call_item\n@@ -1079,17 +1083,17 @@ pub fn handle_call_hierarchy_incoming(\n }\n \n pub fn handle_call_hierarchy_outgoing(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: CallHierarchyOutgoingCallsParams,\n ) -> Result<Option<Vec<CallHierarchyOutgoingCall>>> {\n     let _p = profile(\"handle_call_hierarchy_outgoing\");\n     let item = params.item;\n \n     let doc = TextDocumentIdentifier::new(item.uri);\n-    let frange = from_proto::file_range(&world, doc, item.range)?;\n+    let frange = from_proto::file_range(&snap, doc, item.range)?;\n     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n-    let call_items = match world.analysis().outgoing_calls(fpos)? {\n+    let call_items = match snap.analysis().outgoing_calls(fpos)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -1098,8 +1102,8 @@ pub fn handle_call_hierarchy_outgoing(\n \n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id();\n-        let line_index = world.analysis().file_line_index(file_id)?;\n-        let item = to_proto::call_hierarchy_item(&world, call_item.target)?;\n+        let line_index = snap.analysis().file_line_index(file_id)?;\n+        let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n         res.push(CallHierarchyOutgoingCall {\n             to: item,\n             from_ranges: call_item\n@@ -1114,31 +1118,31 @@ pub fn handle_call_hierarchy_outgoing(\n }\n \n pub fn handle_semantic_tokens(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: SemanticTokensParams,\n ) -> Result<Option<SemanticTokensResult>> {\n     let _p = profile(\"handle_semantic_tokens\");\n \n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let text = world.analysis().file_text(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let text = snap.analysis().file_text(file_id)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n \n-    let highlights = world.analysis().highlight(file_id)?;\n+    let highlights = snap.analysis().highlight(file_id)?;\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n     Ok(Some(semantic_tokens.into()))\n }\n \n pub fn handle_semantic_tokens_range(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: SemanticTokensRangeParams,\n ) -> Result<Option<SemanticTokensRangeResult>> {\n     let _p = profile(\"handle_semantic_tokens_range\");\n \n-    let frange = from_proto::file_range(&world, params.text_document, params.range)?;\n-    let text = world.analysis().file_text(frange.file_id)?;\n-    let line_index = world.analysis().file_line_index(frange.file_id)?;\n+    let frange = from_proto::file_range(&snap, params.text_document, params.range)?;\n+    let text = snap.analysis().file_text(frange.file_id)?;\n+    let line_index = snap.analysis().file_line_index(frange.file_id)?;\n \n-    let highlights = world.analysis().highlight_range(frange)?;\n+    let highlights = snap.analysis().highlight_range(frange)?;\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n     Ok(Some(semantic_tokens.into()))\n }"}, {"sha": "1da4d80eceab0cabae2a4c55040c08849abf92f0", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 46, "deletions": 42, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -10,7 +10,8 @@ use ra_syntax::{SyntaxKind, TextRange, TextSize};\n use ra_vfs::LineEndings;\n \n use crate::{\n-    cargo_target_spec::CargoTargetSpec, lsp_ext, semantic_tokens, world::WorldSnapshot, Result,\n+    cargo_target_spec::CargoTargetSpec, global_state::GlobalStateSnapshot, lsp_ext,\n+    semantic_tokens, Result,\n };\n \n pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {\n@@ -384,41 +385,44 @@ pub(crate) fn folding_range(\n     }\n }\n \n-pub(crate) fn url(world: &WorldSnapshot, file_id: FileId) -> Result<lsp_types::Url> {\n-    world.file_id_to_uri(file_id)\n+pub(crate) fn url(snap: &GlobalStateSnapshot, file_id: FileId) -> Result<lsp_types::Url> {\n+    snap.file_id_to_uri(file_id)\n }\n \n pub(crate) fn versioned_text_document_identifier(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     file_id: FileId,\n     version: Option<i64>,\n ) -> Result<lsp_types::VersionedTextDocumentIdentifier> {\n-    let res = lsp_types::VersionedTextDocumentIdentifier { uri: url(world, file_id)?, version };\n+    let res = lsp_types::VersionedTextDocumentIdentifier { uri: url(snap, file_id)?, version };\n     Ok(res)\n }\n \n-pub(crate) fn location(world: &WorldSnapshot, frange: FileRange) -> Result<lsp_types::Location> {\n-    let url = url(world, frange.file_id)?;\n-    let line_index = world.analysis().file_line_index(frange.file_id)?;\n+pub(crate) fn location(\n+    snap: &GlobalStateSnapshot,\n+    frange: FileRange,\n+) -> Result<lsp_types::Location> {\n+    let url = url(snap, frange.file_id)?;\n+    let line_index = snap.analysis().file_line_index(frange.file_id)?;\n     let range = range(&line_index, frange.range);\n     let loc = lsp_types::Location::new(url, range);\n     Ok(loc)\n }\n \n pub(crate) fn location_link(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     src: Option<FileRange>,\n     target: NavigationTarget,\n ) -> Result<lsp_types::LocationLink> {\n     let origin_selection_range = match src {\n         Some(src) => {\n-            let line_index = world.analysis().file_line_index(src.file_id)?;\n+            let line_index = snap.analysis().file_line_index(src.file_id)?;\n             let range = range(&line_index, src.range);\n             Some(range)\n         }\n         None => None,\n     };\n-    let (target_uri, target_range, target_selection_range) = location_info(world, target)?;\n+    let (target_uri, target_range, target_selection_range) = location_info(snap, target)?;\n     let res = lsp_types::LocationLink {\n         origin_selection_range,\n         target_uri,\n@@ -429,35 +433,35 @@ pub(crate) fn location_link(\n }\n \n fn location_info(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     target: NavigationTarget,\n ) -> Result<(lsp_types::Url, lsp_types::Range, lsp_types::Range)> {\n-    let line_index = world.analysis().file_line_index(target.file_id())?;\n+    let line_index = snap.analysis().file_line_index(target.file_id())?;\n \n-    let target_uri = url(world, target.file_id())?;\n+    let target_uri = url(snap, target.file_id())?;\n     let target_range = range(&line_index, target.full_range());\n     let target_selection_range =\n         target.focus_range().map(|it| range(&line_index, it)).unwrap_or(target_range);\n     Ok((target_uri, target_range, target_selection_range))\n }\n \n pub(crate) fn goto_definition_response(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     src: Option<FileRange>,\n     targets: Vec<NavigationTarget>,\n ) -> Result<lsp_types::GotoDefinitionResponse> {\n-    if world.config.client_caps.location_link {\n+    if snap.config.client_caps.location_link {\n         let links = targets\n             .into_iter()\n-            .map(|nav| location_link(world, src, nav))\n+            .map(|nav| location_link(snap, src, nav))\n             .collect::<Result<Vec<_>>>()?;\n         Ok(links.into())\n     } else {\n         let locations = targets\n             .into_iter()\n             .map(|nav| {\n                 location(\n-                    world,\n+                    snap,\n                     FileRange {\n                         file_id: nav.file_id(),\n                         range: nav.focus_range().unwrap_or(nav.range()),\n@@ -470,13 +474,13 @@ pub(crate) fn goto_definition_response(\n }\n \n pub(crate) fn snippet_text_document_edit(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     is_snippet: bool,\n     source_file_edit: SourceFileEdit,\n ) -> Result<lsp_ext::SnippetTextDocumentEdit> {\n-    let text_document = versioned_text_document_identifier(world, source_file_edit.file_id, None)?;\n-    let line_index = world.analysis().file_line_index(source_file_edit.file_id)?;\n-    let line_endings = world.file_line_endings(source_file_edit.file_id);\n+    let text_document = versioned_text_document_identifier(snap, source_file_edit.file_id, None)?;\n+    let line_index = snap.analysis().file_line_index(source_file_edit.file_id)?;\n+    let line_endings = snap.file_line_endings(source_file_edit.file_id);\n     let edits = source_file_edit\n         .edit\n         .into_iter()\n@@ -486,34 +490,34 @@ pub(crate) fn snippet_text_document_edit(\n }\n \n pub(crate) fn resource_op(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     file_system_edit: FileSystemEdit,\n ) -> Result<lsp_types::ResourceOp> {\n     let res = match file_system_edit {\n         FileSystemEdit::CreateFile { source_root, path } => {\n-            let uri = world.path_to_uri(source_root, &path)?;\n+            let uri = snap.path_to_uri(source_root, &path)?;\n             lsp_types::ResourceOp::Create(lsp_types::CreateFile { uri, options: None })\n         }\n         FileSystemEdit::MoveFile { src, dst_source_root, dst_path } => {\n-            let old_uri = world.file_id_to_uri(src)?;\n-            let new_uri = world.path_to_uri(dst_source_root, &dst_path)?;\n+            let old_uri = snap.file_id_to_uri(src)?;\n+            let new_uri = snap.path_to_uri(dst_source_root, &dst_path)?;\n             lsp_types::ResourceOp::Rename(lsp_types::RenameFile { old_uri, new_uri, options: None })\n         }\n     };\n     Ok(res)\n }\n \n pub(crate) fn snippet_workspace_edit(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     source_change: SourceChange,\n ) -> Result<lsp_ext::SnippetWorkspaceEdit> {\n     let mut document_changes: Vec<lsp_ext::SnippetDocumentChangeOperation> = Vec::new();\n     for op in source_change.file_system_edits {\n-        let op = resource_op(&world, op)?;\n+        let op = resource_op(&snap, op)?;\n         document_changes.push(lsp_ext::SnippetDocumentChangeOperation::Op(op));\n     }\n     for edit in source_change.source_file_edits {\n-        let edit = snippet_text_document_edit(&world, source_change.is_snippet, edit)?;\n+        let edit = snippet_text_document_edit(&snap, source_change.is_snippet, edit)?;\n         document_changes.push(lsp_ext::SnippetDocumentChangeOperation::Edit(edit));\n     }\n     let workspace_edit =\n@@ -522,11 +526,11 @@ pub(crate) fn snippet_workspace_edit(\n }\n \n pub(crate) fn workspace_edit(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     source_change: SourceChange,\n ) -> Result<lsp_types::WorkspaceEdit> {\n     assert!(!source_change.is_snippet);\n-    snippet_workspace_edit(world, source_change).map(|it| it.into())\n+    snippet_workspace_edit(snap, source_change).map(|it| it.into())\n }\n \n impl From<lsp_ext::SnippetWorkspaceEdit> for lsp_types::WorkspaceEdit {\n@@ -565,13 +569,13 @@ impl From<lsp_ext::SnippetWorkspaceEdit> for lsp_types::WorkspaceEdit {\n }\n \n pub fn call_hierarchy_item(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     target: NavigationTarget,\n ) -> Result<lsp_types::CallHierarchyItem> {\n     let name = target.name().to_string();\n     let detail = target.description().map(|it| it.to_string());\n     let kind = symbol_kind(target.kind());\n-    let (uri, range, selection_range) = location_info(world, target)?;\n+    let (uri, range, selection_range) = location_info(snap, target)?;\n     Ok(lsp_types::CallHierarchyItem { name, kind, tags: None, detail, uri, range, selection_range })\n }\n \n@@ -620,14 +624,14 @@ fn main() <fold>{\n }\n \n pub(crate) fn unresolved_code_action(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     assist: Assist,\n     index: usize,\n ) -> Result<lsp_ext::CodeAction> {\n     let res = lsp_ext::CodeAction {\n         title: assist.label,\n         id: Some(format!(\"{}:{}\", assist.id.0.to_owned(), index.to_string())),\n-        group: assist.group.filter(|_| world.config.client_caps.code_action_group).map(|gr| gr.0),\n+        group: assist.group.filter(|_| snap.config.client_caps.code_action_group).map(|gr| gr.0),\n         kind: Some(String::new()),\n         edit: None,\n         command: None,\n@@ -636,25 +640,25 @@ pub(crate) fn unresolved_code_action(\n }\n \n pub(crate) fn resolved_code_action(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     assist: ResolvedAssist,\n ) -> Result<lsp_ext::CodeAction> {\n     let change = assist.source_change;\n-    unresolved_code_action(world, assist.assist, 0).and_then(|it| {\n+    unresolved_code_action(snap, assist.assist, 0).and_then(|it| {\n         Ok(lsp_ext::CodeAction {\n             id: None,\n-            edit: Some(snippet_workspace_edit(world, change)?),\n+            edit: Some(snippet_workspace_edit(snap, change)?),\n             ..it\n         })\n     })\n }\n \n pub(crate) fn runnable(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     file_id: FileId,\n     runnable: Runnable,\n ) -> Result<lsp_ext::Runnable> {\n-    let spec = CargoTargetSpec::for_file(world, file_id)?;\n+    let spec = CargoTargetSpec::for_file(snap, file_id)?;\n     let target = spec.as_ref().map(|s| s.target.clone());\n     let (cargo_args, executable_args) =\n         CargoTargetSpec::runnable_args(spec, &runnable.kind, &runnable.cfg_exprs)?;\n@@ -667,14 +671,14 @@ pub(crate) fn runnable(\n             target.map_or_else(|| \"run binary\".to_string(), |t| format!(\"run {}\", t))\n         }\n     };\n-    let location = location_link(world, None, runnable.nav)?;\n+    let location = location_link(snap, None, runnable.nav)?;\n \n     Ok(lsp_ext::Runnable {\n         label,\n         location: Some(location),\n         kind: lsp_ext::RunnableKind::Cargo,\n         args: lsp_ext::CargoRunnable {\n-            workspace_root: world.workspace_root_for(file_id).map(|root| root.to_owned()),\n+            workspace_root: snap.workspace_root_for(file_id).map(|root| root.to_owned()),\n             cargo_args,\n             executable_args,\n         },"}, {"sha": "ad347631054b7f8ae6c1f4dd3ec0d7570c0970ab", "filename": "crates/rust-analyzer/tests/heavy_tests/main.rs", "status": "modified", "additions": 3, "deletions": 51, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -58,55 +58,6 @@ use std::collections::Spam;\n     eprintln!(\"completion took {:?}\", completion_start.elapsed());\n }\n \n-#[test]\n-fn test_runnables_no_project() {\n-    if skip_slow_tests() {\n-        return;\n-    }\n-\n-    let server = project(\n-        r\"\n-//- lib.rs\n-#[test]\n-fn foo() {\n-}\n-\",\n-    );\n-    server.wait_until_workspace_is_loaded();\n-    server.request::<Runnables>(\n-        RunnablesParams { text_document: server.doc_id(\"lib.rs\"), position: None },\n-        json!([\n-            {\n-              \"args\": {\n-                \"cargoArgs\": [\"test\"],\n-                \"executableArgs\": [\"foo\", \"--nocapture\"],\n-              },\n-              \"kind\": \"cargo\",\n-              \"label\": \"test foo\",\n-              \"location\": {\n-                \"targetRange\": {\n-                  \"end\": { \"character\": 1, \"line\": 2 },\n-                  \"start\": { \"character\": 0, \"line\": 0 }\n-                },\n-                \"targetSelectionRange\": {\n-                  \"end\": { \"character\": 6, \"line\": 1 },\n-                  \"start\": { \"character\": 3, \"line\": 1 }\n-                },\n-                \"targetUri\": \"file:///[..]/lib.rs\"\n-              }\n-            },\n-            {\n-              \"args\": {\n-                \"cargoArgs\": [\"check\", \"--workspace\"],\n-                \"executableArgs\": [],\n-              },\n-              \"kind\": \"cargo\",\n-              \"label\": \"cargo check --workspace\"\n-            }\n-        ]),\n-    );\n-}\n-\n #[test]\n fn test_runnables_project() {\n     if skip_slow_tests() {\n@@ -347,6 +298,7 @@ fn main() {}\n                 }\n               ]\n             },\n+            \"kind\": \"quickfix\",\n             \"title\": \"Create module\"\n         }]),\n     );\n@@ -379,8 +331,7 @@ fn test_missing_module_code_action_in_json_project() {\n             \"root_module\": path.join(\"src/lib.rs\"),\n             \"deps\": [],\n             \"edition\": \"2015\",\n-            \"atom_cfgs\": [],\n-            \"key_value_cfgs\": {}\n+            \"cfg\": [ \"cfg_atom_1\", \"feature=cfg_1\"],\n         } ]\n     });\n \n@@ -418,6 +369,7 @@ fn main() {{}}\n                 }\n               ]\n             },\n+            \"kind\": \"quickfix\",\n             \"title\": \"Create module\"\n         }]),\n     );"}, {"sha": "30d03b622b91f13c28091efb4faa5d487cfeb345", "filename": "crates/rust-analyzer/tests/heavy_tests/support.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -19,8 +19,9 @@ use serde_json::{to_string_pretty, Value};\n use tempfile::TempDir;\n use test_utils::{find_mismatch, parse_fixture};\n \n+use ra_project_model::ProjectManifest;\n use rust_analyzer::{\n-    config::{ClientCapsConfig, Config},\n+    config::{ClientCapsConfig, Config, LinkedProject},\n     main_loop,\n };\n \n@@ -42,7 +43,7 @@ impl<'a> Project<'a> {\n         self\n     }\n \n-    pub fn root(mut self, path: &str) -> Project<'a> {\n+    pub(crate) fn root(mut self, path: &str) -> Project<'a> {\n         self.roots.push(path.into());\n         self\n     }\n@@ -74,7 +75,16 @@ impl<'a> Project<'a> {\n             paths.push((path, entry.text));\n         }\n \n-        let roots = self.roots.into_iter().map(|root| tmp_dir.path().join(root)).collect();\n+        let mut roots =\n+            self.roots.into_iter().map(|root| tmp_dir.path().join(root)).collect::<Vec<_>>();\n+        if roots.is_empty() {\n+            roots.push(tmp_dir.path().to_path_buf());\n+        }\n+        let linked_projects = roots\n+            .into_iter()\n+            .map(|it| ProjectManifest::discover_single(&it).unwrap())\n+            .map(LinkedProject::from)\n+            .collect::<Vec<_>>();\n \n         let mut config = Config {\n             client_caps: ClientCapsConfig {\n@@ -84,14 +94,15 @@ impl<'a> Project<'a> {\n                 ..Default::default()\n             },\n             with_sysroot: self.with_sysroot,\n+            linked_projects,\n             ..Config::default()\n         };\n \n         if let Some(f) = &self.config {\n             f(&mut config)\n         }\n \n-        Server::new(tmp_dir, config, roots, paths)\n+        Server::new(tmp_dir, config, paths)\n     }\n }\n \n@@ -109,20 +120,12 @@ pub struct Server {\n }\n \n impl Server {\n-    fn new(\n-        dir: TempDir,\n-        config: Config,\n-        roots: Vec<PathBuf>,\n-        files: Vec<(PathBuf, String)>,\n-    ) -> Server {\n-        let path = dir.path().to_path_buf();\n-\n-        let roots = if roots.is_empty() { vec![path] } else { roots };\n+    fn new(dir: TempDir, config: Config, files: Vec<(PathBuf, String)>) -> Server {\n         let (connection, client) = Connection::memory();\n \n         let _thread = jod_thread::Builder::new()\n             .name(\"test server\".to_string())\n-            .spawn(move || main_loop(roots, config, connection).unwrap())\n+            .spawn(move || main_loop(config, connection).unwrap())\n             .expect(\"failed to spawn a thread\");\n \n         let res ="}, {"sha": "c0356344ca24e94f75a75d1fb08f225241f7a261", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -124,3 +124,8 @@ pub fn replace(buf: &mut String, from: char, to: &str) {\n     // FIXME: do this in place.\n     *buf = buf.replace(from, to)\n }\n+\n+pub fn split1(haystack: &str, delim: char) -> Option<(&str, &str)> {\n+    let idx = haystack.find(delim)?;\n+    Some((&haystack[..idx], &haystack[idx + delim.len_utf8()..]))\n+}"}, {"sha": "8840bf36ae325c79b39eaccaaa2ebdd56fa709d2", "filename": "crates/test_utils/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Ftest_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Ftest_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2FCargo.toml?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -14,4 +14,5 @@ serde_json = \"1.0.48\"\n relative-path = \"1.0.0\"\n rustc-hash = \"1.1.0\"\n \n-ra_cfg = { path = \"../ra_cfg\" }\n\\ No newline at end of file\n+ra_cfg = { path = \"../ra_cfg\" }\n+stdx = { path = \"../stdx\" }\n\\ No newline at end of file"}, {"sha": "2141bfc202779a705eb7da0f378b2a94b61896d8", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -15,6 +15,7 @@ use std::{\n };\n \n pub use ra_cfg::CfgOptions;\n+use stdx::split1;\n \n pub use relative_path::{RelativePath, RelativePathBuf};\n pub use rustc_hash::FxHashMap;\n@@ -332,11 +333,6 @@ fn parse_meta(meta: &str) -> FixtureMeta {\n     FixtureMeta::File(FileMeta { path, crate_name: krate, deps, edition, cfg, env })\n }\n \n-fn split1(haystack: &str, delim: char) -> Option<(&str, &str)> {\n-    let idx = haystack.find(delim)?;\n-    Some((&haystack[..idx], &haystack[idx + delim.len_utf8()..]))\n-}\n-\n /// Adjusts the indentation of the first line to the minimum indentation of the rest of the lines.\n /// This allows fixtures to start off in a different indentation, e.g. to align the first line with\n /// the other lines visually:"}, {"sha": "1de5a2aab1d75d6c4c3d5158d842ed11271d9281", "filename": "docs/dev/README.md", "status": "modified", "additions": 104, "deletions": 1, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -30,7 +30,7 @@ https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0\n \n * [good-first-issue](https://github.com/rust-analyzer/rust-analyzer/labels/good%20first%20issue)\n   are good issues to get into the project.\n-* [E-mentor](https://github.com/rust-analyzer/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-mentor)\n+* [E-has-instructions](https://github.com/rust-analyzer/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-has-instructions)\n   issues have links to the code in question and tests.\n * [E-easy](https://github.com/rust-analyzer/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-easy),\n   [E-medium](https://github.com/rust-analyzer/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-medium),\n@@ -117,6 +117,109 @@ Additionally, I use `cargo run --release -p rust-analyzer -- analysis-stats\n path/to/some/rust/crate` to run a batch analysis. This is primarily useful for\n performance optimizations, or for bug minimization.\n \n+# Code Style & Review Process\n+\n+Our approach to \"clean code\" is two fold:\n+\n+* We generally don't block PRs on style changes.\n+* At the same time, all code in rust-analyzer is constantly refactored.\n+\n+It is explicitly OK for reviewer to flag only some nits in the PR, and than send a follow up cleanup PR for things which are easier to explain by example, cc-ing the original author.\n+Sending small cleanup PRs (like rename a single local variable) is encouraged.\n+\n+## Scale of Changes\n+\n+Everyone knows that it's better to send small & focused pull requests.\n+The problem is, sometimes you *have* to, eg, rewrite the whole compiler, and that just doesn't fit into a set of isolated PRs.\n+\n+The main thing too keep an eye on is the boundaries between various components.\n+There are three kinds of changes:\n+\n+1. Internals of a single component are changed.\n+   Specifically, you don't change any `pub` items.\n+   A good example here would be an addition of a new assist.\n+\n+2. API of a component is expanded.\n+   Specifically, you add a new `pub` function which wasn't there before.\n+   A good example here would be expansion of assist API, for example, to implement lazy assists or assists groups.\n+\n+3. A new dependency between components is introduced.\n+   Specifically, you add a `pub use` reexport from another crate or you add a new line to `[dependencies]` section of `Cargo.toml`.\n+   A good example here would be adding reference search capability to the assists crates.\n+\n+For the first group, the change is generally merged as long as:\n+\n+* it works for the happy case,\n+* it has tests,\n+* it doesn't panic for unhappy case.\n+\n+For the second group, the change would be subjected to quite a bit of scrutiny and iteration.\n+The new API needs to be right (or at least easy to change later).\n+The actual implementation doesn't matter that much.\n+It's very important to minimize the amount of changed lines of code for changes of the second kind.\n+Often, you start doing change of the first kind, only to realise that you need to elevate to a change of the second kind.\n+In this case, we'll probably ask you to split API changes into a separate PR.\n+\n+Changes of the third group should be pretty rare, so we don't specify any specific process for them.\n+That said, adding an innocent-looking `pub use` is a very simple way to break encapsulation, keep an eye on it!\n+\n+Note: if you enjoyed this abstract hand-waving about boundaries, you might appreciate\n+https://www.tedinski.com/2018/02/06/system-boundaries.html\n+\n+## Order of Imports\n+\n+We separate import groups with blank lines\n+\n+```\n+mod x;\n+mod y;\n+\n+use std::{ ... }\n+\n+use crate_foo::{ ... }\n+use crate_bar::{ ... }\n+\n+use crate::{}\n+\n+use super::{} // but prefer `use crate::`\n+```\n+\n+## Order of Items\n+\n+Optimize for the reader who sees the file for the first time, and wants to get the general idea about what's going on.\n+People read things from top to bottom, so place most important things first.\n+\n+Specifically, if all items except one are private, always put the non-private item on top.\n+\n+Put `struct`s and `enum`s first, functions and impls last.\n+\n+Do\n+\n+```\n+// Good\n+struct Foo {\n+  bars: Vec<Bar>\n+}\n+\n+struct Bar;\n+```\n+\n+rather than\n+\n+```\n+// Not as good\n+struct Bar;\n+\n+struct Foo {\n+  bars: Vec<Bar>\n+}\n+```\n+\n+## Documentation\n+\n+For `.md` and `.adoc` files, prefer a sentence-per-line format, don't wrap lines.\n+If the line is too long, you want to split the sentence in two :-)\n+\n # Logging\n \n Logging is done by both rust-analyzer and VS Code, so it might be tricky to"}, {"sha": "4d2fb31d4840fe50f9a86ffeb8ebd9a62500bb7f", "filename": "docs/user/generated_assists.adoc", "status": "removed", "additions": 0, "deletions": 1015, "changes": 1015, "blob_url": "https://github.com/rust-lang/rust/blob/1f7de306f547ecb394a34445fd6ac1d6bc8ab439/docs%2Fuser%2Fgenerated_assists.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/1f7de306f547ecb394a34445fd6ac1d6bc8ab439/docs%2Fuser%2Fgenerated_assists.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_assists.adoc?ref=1f7de306f547ecb394a34445fd6ac1d6bc8ab439", "patch": "@@ -1,1015 +0,0 @@\n-[discrete]\n-=== `add_custom_impl`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_custom_impl.rs#L14[add_custom_impl.rs]\n-\n-Adds impl block for derived trait.\n-\n-.Before\n-```rust\n-#[derive(Deb\u2503ug, Display)]\n-struct S;\n-```\n-\n-.After\n-```rust\n-#[derive(Display)]\n-struct S;\n-\n-impl Debug for S {\n-    $0\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_derive`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_derive.rs#L9[add_derive.rs]\n-\n-Adds a new `#[derive()]` clause to a struct or enum.\n-\n-.Before\n-```rust\n-struct Point {\n-    x: u32,\n-    y: u32,\u2503\n-}\n-```\n-\n-.After\n-```rust\n-#[derive($0)]\n-struct Point {\n-    x: u32,\n-    y: u32,\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_explicit_type`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_explicit_type.rs#L9[add_explicit_type.rs]\n-\n-Specify type for a let binding.\n-\n-.Before\n-```rust\n-fn main() {\n-    let x\u2503 = 92;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    let x: i32 = 92;\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_from_impl_for_enum`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_from_impl_for_enum.rs#L7[add_from_impl_for_enum.rs]\n-\n-Adds a From impl for an enum variant with one tuple field.\n-\n-.Before\n-```rust\n-enum A { \u2503One(u32) }\n-```\n-\n-.After\n-```rust\n-enum A { One(u32) }\n-\n-impl From<u32> for A {\n-    fn from(v: u32) -> Self {\n-        A::One(v)\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_function`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_function.rs#L19[add_function.rs]\n-\n-Adds a stub function with a signature matching the function under the cursor.\n-\n-.Before\n-```rust\n-struct Baz;\n-fn baz() -> Baz { Baz }\n-fn foo() {\n-    bar\u2503(\"\", baz());\n-}\n-\n-```\n-\n-.After\n-```rust\n-struct Baz;\n-fn baz() -> Baz { Baz }\n-fn foo() {\n-    bar(\"\", baz());\n-}\n-\n-fn bar(arg: &str, baz: Baz) {\n-    ${0:todo!()}\n-}\n-\n-```\n-\n-\n-[discrete]\n-=== `add_hash`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/raw_string.rs#L65[raw_string.rs]\n-\n-Adds a hash to a raw string literal.\n-\n-.Before\n-```rust\n-fn main() {\n-    r#\"Hello,\u2503 World!\"#;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    r##\"Hello, World!\"##;\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_impl`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_impl.rs#L6[add_impl.rs]\n-\n-Adds a new inherent impl for a type.\n-\n-.Before\n-```rust\n-struct Ctx<T: Clone> {\n-    data: T,\u2503\n-}\n-```\n-\n-.After\n-```rust\n-struct Ctx<T: Clone> {\n-    data: T,\n-}\n-\n-impl<T: Clone> Ctx<T> {\n-    $0\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_impl_default_members`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_missing_impl_members.rs#L64[add_missing_impl_members.rs]\n-\n-Adds scaffold for overriding default impl members.\n-\n-.Before\n-```rust\n-trait Trait {\n-    Type X;\n-    fn foo(&self);\n-    fn bar(&self) {}\n-}\n-\n-impl Trait for () {\n-    Type X = ();\n-    fn foo(&self) {}\u2503\n-\n-}\n-```\n-\n-.After\n-```rust\n-trait Trait {\n-    Type X;\n-    fn foo(&self);\n-    fn bar(&self) {}\n-}\n-\n-impl Trait for () {\n-    Type X = ();\n-    fn foo(&self) {}\n-    $0fn bar(&self) {}\n-\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_impl_missing_members`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_missing_impl_members.rs#L24[add_missing_impl_members.rs]\n-\n-Adds scaffold for required impl members.\n-\n-.Before\n-```rust\n-trait Trait<T> {\n-    Type X;\n-    fn foo(&self) -> T;\n-    fn bar(&self) {}\n-}\n-\n-impl Trait<u32> for () {\u2503\n-\n-}\n-```\n-\n-.After\n-```rust\n-trait Trait<T> {\n-    Type X;\n-    fn foo(&self) -> T;\n-    fn bar(&self) {}\n-}\n-\n-impl Trait<u32> for () {\n-    fn foo(&self) -> u32 {\n-        ${0:todo!()}\n-    }\n-\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_new`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_new.rs#L12[add_new.rs]\n-\n-Adds a new inherent impl for a type.\n-\n-.Before\n-```rust\n-struct Ctx<T: Clone> {\n-     data: T,\u2503\n-}\n-```\n-\n-.After\n-```rust\n-struct Ctx<T: Clone> {\n-     data: T,\n-}\n-\n-impl<T: Clone> Ctx<T> {\n-    fn $0new(data: T) -> Self { Self { data } }\n-}\n-\n-```\n-\n-\n-[discrete]\n-=== `add_turbo_fish`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_turbo_fish.rs#L10[add_turbo_fish.rs]\n-\n-Adds `::<_>` to a call of a generic method or function.\n-\n-.Before\n-```rust\n-fn make<T>() -> T { todo!() }\n-fn main() {\n-    let x = make\u2503();\n-}\n-```\n-\n-.After\n-```rust\n-fn make<T>() -> T { todo!() }\n-fn main() {\n-    let x = make::<${0:_}>();\n-}\n-```\n-\n-\n-[discrete]\n-=== `apply_demorgan`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/apply_demorgan.rs#L5[apply_demorgan.rs]\n-\n-Apply [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws).\n-This transforms expressions of the form `!l || !r` into `!(l && r)`.\n-This also works with `&&`. This assist can only be applied with the cursor\n-on either `||` or `&&`, with both operands being a negation of some kind.\n-This means something of the form `!x` or `x != y`.\n-\n-.Before\n-```rust\n-fn main() {\n-    if x != 4 ||\u2503 !y {}\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    if !(x == 4 && y) {}\n-}\n-```\n-\n-\n-[discrete]\n-=== `auto_import`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/auto_import.rs#L18[auto_import.rs]\n-\n-If the name is unresolved, provides all possible imports for it.\n-\n-.Before\n-```rust\n-fn main() {\n-    let map = HashMap\u2503::new();\n-}\n-```\n-\n-.After\n-```rust\n-use std::collections::HashMap;\n-\n-fn main() {\n-    let map = HashMap::new();\n-}\n-```\n-\n-\n-[discrete]\n-=== `change_return_type_to_result`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/change_return_type_to_result.rs#L8[change_return_type_to_result.rs]\n-\n-Change the function's return type to Result.\n-\n-.Before\n-```rust\n-fn foo() -> i32\u2503 { 42i32 }\n-```\n-\n-.After\n-```rust\n-fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n-```\n-\n-\n-[discrete]\n-=== `change_visibility`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/change_visibility.rs#L14[change_visibility.rs]\n-\n-Adds or changes existing visibility specifier.\n-\n-.Before\n-```rust\n-\u2503fn frobnicate() {}\n-```\n-\n-.After\n-```rust\n-pub(crate) fn frobnicate() {}\n-```\n-\n-\n-[discrete]\n-=== `convert_to_guarded_return`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/early_return.rs#L21[early_return.rs]\n-\n-Replace a large conditional with a guarded return.\n-\n-.Before\n-```rust\n-fn main() {\n-    \u2503if cond {\n-        foo();\n-        bar();\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    if !cond {\n-        return;\n-    }\n-    foo();\n-    bar();\n-}\n-```\n-\n-\n-[discrete]\n-=== `fill_match_arms`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/fill_match_arms.rs#L14[fill_match_arms.rs]\n-\n-Adds missing clauses to a `match` expression.\n-\n-.Before\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        \u2503\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        $0Action::Move { distance } => {}\n-        Action::Stop => {}\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `fix_visibility`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/fix_visibility.rs#L13[fix_visibility.rs]\n-\n-Makes inaccessible item public.\n-\n-.Before\n-```rust\n-mod m {\n-    fn frobnicate() {}\n-}\n-fn main() {\n-    m::frobnicate\u2503() {}\n-}\n-```\n-\n-.After\n-```rust\n-mod m {\n-    $0pub(crate) fn frobnicate() {}\n-}\n-fn main() {\n-    m::frobnicate() {}\n-}\n-```\n-\n-\n-[discrete]\n-=== `flip_binexpr`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/flip_binexpr.rs#L5[flip_binexpr.rs]\n-\n-Flips operands of a binary expression.\n-\n-.Before\n-```rust\n-fn main() {\n-    let _ = 90 +\u2503 2;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    let _ = 2 + 90;\n-}\n-```\n-\n-\n-[discrete]\n-=== `flip_comma`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/flip_comma.rs#L5[flip_comma.rs]\n-\n-Flips two comma-separated items.\n-\n-.Before\n-```rust\n-fn main() {\n-    ((1, 2),\u2503 (3, 4));\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    ((3, 4), (1, 2));\n-}\n-```\n-\n-\n-[discrete]\n-=== `flip_trait_bound`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/flip_trait_bound.rs#L9[flip_trait_bound.rs]\n-\n-Flips two trait bounds.\n-\n-.Before\n-```rust\n-fn foo<T: Clone +\u2503 Copy>() { }\n-```\n-\n-.After\n-```rust\n-fn foo<T: Copy + Clone>() { }\n-```\n-\n-\n-[discrete]\n-=== `inline_local_variable`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/inline_local_variable.rs#L13[inline_local_variable.rs]\n-\n-Inlines local variable.\n-\n-.Before\n-```rust\n-fn main() {\n-    let x\u2503 = 1 + 2;\n-    x * 4;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    (1 + 2) * 4;\n-}\n-```\n-\n-\n-[discrete]\n-=== `introduce_named_lifetime`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/introduce_named_lifetime.rs#L12[introduce_named_lifetime.rs]\n-\n-Change an anonymous lifetime to a named lifetime.\n-\n-.Before\n-```rust\n-impl Cursor<'_\u2503> {\n-    fn node(self) -> &SyntaxNode {\n-        match self {\n-            Cursor::Replace(node) | Cursor::Before(node) => node,\n-        }\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-impl<'a> Cursor<'a> {\n-    fn node(self) -> &SyntaxNode {\n-        match self {\n-            Cursor::Replace(node) | Cursor::Before(node) => node,\n-        }\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `introduce_variable`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/introduce_variable.rs#L14[introduce_variable.rs]\n-\n-Extracts subexpression into a variable.\n-\n-.Before\n-```rust\n-fn main() {\n-    \u2503(1 + 2)\u2503 * 4;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    let $0var_name = (1 + 2);\n-    var_name * 4;\n-}\n-```\n-\n-\n-[discrete]\n-=== `invert_if`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/invert_if.rs#L12[invert_if.rs]\n-\n-Apply invert_if\n-This transforms if expressions of the form `if !x {A} else {B}` into `if x {B} else {A}`\n-This also works with `!=`. This assist can only be applied with the cursor\n-on `if`.\n-\n-.Before\n-```rust\n-fn main() {\n-    if\u2503 !y { A } else { B }\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    if y { B } else { A }\n-}\n-```\n-\n-\n-[discrete]\n-=== `make_raw_string`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/raw_string.rs#L10[raw_string.rs]\n-\n-Adds `r#` to a plain string literal.\n-\n-.Before\n-```rust\n-fn main() {\n-    \"Hello,\u2503 World!\";\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    r#\"Hello, World!\"#;\n-}\n-```\n-\n-\n-[discrete]\n-=== `make_usual_string`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/raw_string.rs#L39[raw_string.rs]\n-\n-Turns a raw string into a plain string.\n-\n-.Before\n-```rust\n-fn main() {\n-    r#\"Hello,\u2503 \"World!\"\"#;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    \"Hello, \\\"World!\\\"\";\n-}\n-```\n-\n-\n-[discrete]\n-=== `merge_imports`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/merge_imports.rs#L14[merge_imports.rs]\n-\n-Merges two imports with a common prefix.\n-\n-.Before\n-```rust\n-use std::\u2503fmt::Formatter;\n-use std::io;\n-```\n-\n-.After\n-```rust\n-use std::{fmt::Formatter, io};\n-```\n-\n-\n-[discrete]\n-=== `merge_match_arms`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/merge_match_arms.rs#L11[merge_match_arms.rs]\n-\n-Merges identical match arms.\n-\n-.Before\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        \u2503Action::Move(..) => foo(),\n-        Action::Stop => foo(),\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move(..) | Action::Stop => foo(),\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `move_arm_cond_to_match_guard`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/move_guard.rs#L56[move_guard.rs]\n-\n-Moves if expression from match arm body into a guard.\n-\n-.Before\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } => \u2503if distance > 10 { foo() },\n-        _ => (),\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } if distance > 10 => foo(),\n-        _ => (),\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `move_bounds_to_where_clause`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/move_bounds.rs#L10[move_bounds.rs]\n-\n-Moves inline type bounds to a where clause.\n-\n-.Before\n-```rust\n-fn apply<T, U, \u2503F: FnOnce(T) -> U>(f: F, x: T) -> U {\n-    f(x)\n-}\n-```\n-\n-.After\n-```rust\n-fn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n-    f(x)\n-}\n-```\n-\n-\n-[discrete]\n-=== `move_guard_to_arm_body`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/move_guard.rs#L8[move_guard.rs]\n-\n-Moves match guard into match arm body.\n-\n-.Before\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } \u2503if distance > 10 => foo(),\n-        _ => (),\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } => if distance > 10 { foo() },\n-        _ => (),\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `remove_dbg`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/remove_dbg.rs#L8[remove_dbg.rs]\n-\n-Removes `dbg!()` macro call.\n-\n-.Before\n-```rust\n-fn main() {\n-    \u2503dbg!(92);\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    92;\n-}\n-```\n-\n-\n-[discrete]\n-=== `remove_hash`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/raw_string.rs#L89[raw_string.rs]\n-\n-Removes a hash from a raw string literal.\n-\n-.Before\n-```rust\n-fn main() {\n-    r#\"Hello,\u2503 World!\"#;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    r\"Hello, World!\";\n-}\n-```\n-\n-\n-[discrete]\n-=== `remove_mut`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/remove_mut.rs#L5[remove_mut.rs]\n-\n-Removes the `mut` keyword.\n-\n-.Before\n-```rust\n-impl Walrus {\n-    fn feed(&mut\u2503 self, amount: u32) {}\n-}\n-```\n-\n-.After\n-```rust\n-impl Walrus {\n-    fn feed(&self, amount: u32) {}\n-}\n-```\n-\n-\n-[discrete]\n-=== `reorder_fields`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/reorder_fields.rs#L10[reorder_fields.rs]\n-\n-Reorder the fields of record literals and record patterns in the same order as in\n-the definition.\n-\n-.Before\n-```rust\n-struct Foo {foo: i32, bar: i32};\n-const test: Foo = \u2503Foo {bar: 0, foo: 1}\n-```\n-\n-.After\n-```rust\n-struct Foo {foo: i32, bar: i32};\n-const test: Foo = Foo {foo: 1, bar: 0}\n-```\n-\n-\n-[discrete]\n-=== `replace_if_let_with_match`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/replace_if_let_with_match.rs#L13[replace_if_let_with_match.rs]\n-\n-Replaces `if let` with an else branch with a `match` expression.\n-\n-.Before\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    \u2503if let Action::Move { distance } = action {\n-        foo(distance)\n-    } else {\n-        bar()\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } => foo(distance),\n-        _ => bar(),\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `replace_let_with_if_let`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/replace_let_with_if_let.rs#L14[replace_let_with_if_let.rs]\n-\n-Replaces `let` with an `if-let`.\n-\n-.Before\n-```rust\n-\n-fn main(action: Action) {\n-    \u2503let x = compute();\n-}\n-\n-fn compute() -> Option<i32> { None }\n-```\n-\n-.After\n-```rust\n-\n-fn main(action: Action) {\n-    if let Some(x) = compute() {\n-    }\n-}\n-\n-fn compute() -> Option<i32> { None }\n-```\n-\n-\n-[discrete]\n-=== `replace_qualified_name_with_use`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/replace_qualified_name_with_use.rs#L6[replace_qualified_name_with_use.rs]\n-\n-Adds a use statement for a given fully-qualified name.\n-\n-.Before\n-```rust\n-fn process(map: std::collections::\u2503HashMap<String, String>) {}\n-```\n-\n-.After\n-```rust\n-use std::collections::HashMap;\n-\n-fn process(map: HashMap<String, String>) {}\n-```\n-\n-\n-[discrete]\n-=== `replace_unwrap_with_match`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/replace_unwrap_with_match.rs#L17[replace_unwrap_with_match.rs]\n-\n-Replaces `unwrap` a `match` expression. Works for Result and Option.\n-\n-.Before\n-```rust\n-enum Result<T, E> { Ok(T), Err(E) }\n-fn main() {\n-    let x: Result<i32, i32> = Result::Ok(92);\n-    let y = x.\u2503unwrap();\n-}\n-```\n-\n-.After\n-```rust\n-enum Result<T, E> { Ok(T), Err(E) }\n-fn main() {\n-    let x: Result<i32, i32> = Result::Ok(92);\n-    let y = match x {\n-        Ok(a) => a,\n-        $0_ => unreachable!(),\n-    };\n-}\n-```\n-\n-\n-[discrete]\n-=== `split_import`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/split_import.rs#L7[split_import.rs]\n-\n-Wraps the tail of import into braces.\n-\n-.Before\n-```rust\n-use std::\u2503collections::HashMap;\n-```\n-\n-.After\n-```rust\n-use std::{collections::HashMap};\n-```\n-\n-\n-[discrete]\n-=== `unwrap_block`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/unwrap_block.rs#L9[unwrap_block.rs]\n-\n-This assist removes if...else, for, while and loop control statements to just keep the body.\n-\n-.Before\n-```rust\n-fn foo() {\n-    if true {\u2503\n-        println!(\"foo\");\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-fn foo() {\n-    println!(\"foo\");\n-}\n-```"}, {"sha": "12812fa0be7e32f8c020a19b17fd5f468aac8bdb", "filename": "docs/user/generated_features.adoc", "status": "removed", "additions": 0, "deletions": 298, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/1f7de306f547ecb394a34445fd6ac1d6bc8ab439/docs%2Fuser%2Fgenerated_features.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/1f7de306f547ecb394a34445fd6ac1d6bc8ab439/docs%2Fuser%2Fgenerated_features.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_features.adoc?ref=1f7de306f547ecb394a34445fd6ac1d6bc8ab439", "patch": "@@ -1,298 +0,0 @@\n-=== Expand Macro Recursively\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/expand_macro.rs#L15[expand_macro.rs]\n-\n-Shows the full macro expansion of the macro at current cursor.\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Expand macro recursively**\n-|===\n-\n-\n-=== Extend Selection\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/extend_selection.rs#L15[extend_selection.rs]\n-\n-Extends the current selection to the encompassing syntactic construct\n-(expression, statement, item, module, etc). It works with multiple cursors.\n-\n-|===\n-| Editor  | Shortcut\n-\n-| VS Code | kbd:[Ctrl+Shift+\u2192]\n-|===\n-\n-\n-=== File Structure\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/display/structure.rs#L17[structure.rs]\n-\n-Provides a tree of the symbols defined in the file. Can be used to\n-\n-* fuzzy search symbol in a file (super useful)\n-* draw breadcrumbs to describe the context around the cursor\n-* draw outline of the file\n-\n-|===\n-| Editor  | Shortcut\n-\n-| VS Code | kbd:[Ctrl+Shift+O]\n-|===\n-\n-\n-=== Go to Definition\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/goto_definition.rs#L18[goto_definition.rs]\n-\n-Navigates to the definition of an identifier.\n-\n-|===\n-| Editor  | Shortcut\n-\n-| VS Code | kbd:[F12]\n-|===\n-\n-\n-=== Go to Implementation\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/goto_implementation.rs#L7[goto_implementation.rs]\n-\n-Navigates to the impl block of structs, enums or traits. Also implemented as a code lens.\n-\n-|===\n-| Editor  | Shortcut\n-\n-| VS Code | kbd:[Ctrl+F12]\n-|===\n-\n-\n-=== Go to Type Definition\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/goto_type_definition.rs#L6[goto_type_definition.rs]\n-\n-Navigates to the type of an identifier.\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Go to Type Definition*\n-|===\n-\n-\n-=== Hover\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/hover.rs#L63[hover.rs]\n-\n-Shows additional information, like type of an expression or documentation for definition when \"focusing\" code.\n-Focusing is usually hovering with a mouse, but can also be triggered with a shortcut.\n-\n-\n-=== Inlay Hints\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/inlay_hints.rs#L40[inlay_hints.rs]\n-\n-rust-analyzer shows additional information inline with the source code.\n-Editors usually render this using read-only virtual text snippets interspersed with code.\n-\n-rust-analyzer shows hits for\n-\n-* types of local variables\n-* names of function arguments\n-* types of chained expressions\n-\n-**Note:** VS Code does not have native support for inlay hints https://github.com/microsoft/vscode/issues/16221[yet] and the hints are implemented using decorations.\n-This approach has limitations, the caret movement and bracket highlighting near the edges of the hint may be weird:\n-https://github.com/rust-analyzer/rust-analyzer/issues/1623[1], https://github.com/rust-analyzer/rust-analyzer/issues/3453[2].\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Toggle inlay hints*\n-|===\n-\n-\n-=== Join Lines\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/join_lines.rs#L12[join_lines.rs]\n-\n-Join selected lines into one, smartly fixing up whitespace, trailing commas, and braces.\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Join lines**\n-|===\n-\n-\n-=== Magic Completions\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/completion.rs#L38[completion.rs]\n-\n-In addition to usual reference completion, rust-analyzer provides some \u2728magic\u2728\n-completions as well:\n-\n-Keywords like `if`, `else` `while`, `loop` are completed with braces, and cursor\n-is placed at the appropriate position. Even though `if` is easy to type, you\n-still want to complete it, to get ` { }` for free! `return` is inserted with a\n-space or `;` depending on the return type of the function.\n-\n-When completing a function call, `()` are automatically inserted. If a function\n-takes arguments, the cursor is positioned inside the parenthesis.\n-\n-There are postfix completions, which can be triggered by typing something like\n-`foo().if`. The word after `.` determines postfix completion. Possible variants are:\n-\n-- `expr.if` -> `if expr {}` or `if let ... {}` for `Option` or `Result`\n-- `expr.match` -> `match expr {}`\n-- `expr.while` -> `while expr {}` or `while let ... {}` for `Option` or `Result`\n-- `expr.ref` -> `&expr`\n-- `expr.refm` -> `&mut expr`\n-- `expr.not` -> `!expr`\n-- `expr.dbg` -> `dbg!(expr)`\n-\n-There also snippet completions:\n-\n-.Expressions\n-- `pd` -> `println!(\"{:?}\")`\n-- `ppd` -> `println!(\"{:#?}\")`\n-\n-.Items\n-- `tfn` -> `#[test] fn f(){}`\n-- `tmod` ->\n-```rust\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_fn() {}\n-}\n-```\n-\n-\n-=== Matching Brace\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/matching_brace.rs#L3[matching_brace.rs]\n-\n-If the cursor is on any brace (`<>(){}[]`) which is a part of a brace-pair,\n-moves cursor to the matching brace. It uses the actual parser to determine\n-braces, so it won't confuse generics with comparisons.\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Find matching brace**\n-|===\n-\n-\n-=== On Typing Assists\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/typing.rs#L35[typing.rs]\n-\n-Some features trigger on typing certain characters:\n-\n-- typing `let =` tries to smartly add `;` if `=` is followed by an existing expression\n-- Enter inside comments automatically inserts `///`\n-- typing `.` in a chain method call auto-indents\n-\n-\n-=== Parent Module\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/parent_module.rs#L12[parent_module.rs]\n-\n-Navigates to the parent module of the current module.\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Locate parent module**\n-|===\n-\n-\n-=== Run\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/runnables.rs#L45[runnables.rs]\n-\n-Shows a popup suggesting to run a test/benchmark/binary **at the current cursor\n-location**. Super useful for repeatedly running just a single test. Do bind this\n-to a shortcut!\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Run**\n-|===\n-\n-\n-=== Semantic Syntax Highlighting\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/syntax_highlighting.rs#L33[syntax_highlighting.rs]\n-\n-rust-analyzer highlights the code semantically.\n-For example, `bar` in `foo::Bar` might be colored differently depending on whether `Bar` is an enum or a trait.\n-rust-analyzer does not specify colors directly, instead it assigns tag (like `struct`) and a set of modifiers (like `declaration`) to each token.\n-It's up to the client to map those to specific colors.\n-\n-The general rule is that a reference to an entity gets colored the same way as the entity itself.\n-We also give special modifier for `mut` and `&mut` local variables.\n-\n-\n-=== Show Syntax Tree\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/syntax_tree.rs#L9[syntax_tree.rs]\n-\n-Shows the parse tree of the current file. It exists mostly for debugging\n-rust-analyzer itself.\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Show Syntax Tree**\n-|===\n-\n-\n-=== Status\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/status.rs#L27[status.rs]\n-\n-Shows internal statistic about memory usage of rust-analyzer.\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Status**\n-|===\n-\n-\n-=== Structural Seach and Replace\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/ssr.rs#L26[ssr.rs]\n-\n-Search and replace with named wildcards that will match any expression.\n-The syntax for a structural search replace command is `<search_pattern> ==>> <replace_pattern>`.\n-A `$<name>:expr` placeholder in the search pattern will match any expression and `$<name>` will reference it in the replacement.\n-Available via the command `rust-analyzer.ssr`.\n-\n-```rust\n-// Using structural search replace command [foo($a:expr, $b:expr) ==>> ($a).foo($b)]\n-\n-// BEFORE\n-String::from(foo(y + 5, z))\n-\n-// AFTER\n-String::from((y + 5).foo(z))\n-```\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Structural Search Replace**\n-|===\n-\n-\n-=== Workspace Symbol\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide_db/src/symbol_index.rs#L113[symbol_index.rs]\n-\n-Uses fuzzy-search to find types, modules and functions by name across your\n-project and dependencies. This is **the** most useful feature, which improves code\n-navigation tremendously. It mostly works on top of the built-in LSP\n-functionality, however `#` and `*` symbols can be used to narrow down the\n-search. Specifically,\n-\n-- `Foo` searches for `Foo` type in the current workspace\n-- `foo#` searches for `foo` function in the current workspace\n-- `Foo*` searches for `Foo` type among dependencies, including `stdlib`\n-- `foo#*` searches for `foo` function among dependencies\n-\n-That is, `#` switches from \"types\" to all symbols, `*` switches from the current\n-workspace to dependencies.\n-\n-|===\n-| Editor  | Shortcut\n-\n-| VS Code | kbd:[Ctrl+T]\n-|==="}, {"sha": "ea714f49addf05145defc3a20bfe303c66f1fd5c", "filename": "docs/user/manual.adoc", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/docs%2Fuser%2Fmanual.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/docs%2Fuser%2Fmanual.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fmanual.adoc?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -269,6 +269,57 @@ Gnome Builder currently has support for RLS, and there's no way to configure the\n 1. Rename, symlink or copy the `rust-analyzer` binary to `rls` and place it somewhere Builder can find (in `PATH`, or under `~/.cargo/bin`).\n 2. Enable the Rust Builder plugin.\n \n+== Non-Cargo Based Projects\n+\n+rust-analyzer does not require Cargo.\n+However, if you use some other build system, you'll have to describe the structure of your project for rust-analyzer in the `rust-project.json` format:\n+\n+[source,TypeScript]\n+----\n+interface JsonProject {\n+   /// The set of paths containing the crates for this project.\n+   /// Any `Crate` must be nested inside some `root`.\n+   roots: string[];\n+   /// The set of crates comprising the current project.\n+   /// Must include all transitive dependencies as well as sysroot crate (libstd, libcore and such).\n+   crates: Crate[];\n+}\n+\n+interface Crate {\n+    /// Path to the root module of the crate.\n+    root_module: string;\n+    /// Edition of the crate.\n+    edition: \"2015\" | \"2018\";\n+    /// Dependencies\n+    deps: Dep[];\n+    /// The set of cfgs activated for a given crate, like `[\"unix\", \"feature=foo\", \"feature=bar\"]`.\n+    cfg: string[];\n+\n+    /// value of the OUT_DIR env variable.\n+    out_dir?: string;\n+    /// For proc-macro crates, path to compiles proc-macro (.so file).\n+    proc_macro_dylib_path?: string;\n+}\n+\n+interface Dep {\n+    /// Index of a crate in the `crates` array.\n+    crate: number,\n+    /// Name as should appear in the (implicit) `extern crate name` declaration.\n+    name: string,\n+}\n+----\n+\n+This format is provisional and subject to change.\n+Specifically, the `roots` setup will be different eventually.\n+\n+There are tree ways to feed `rust-project.json` to rust-analyzer:\n+\n+* Place `rust-project.json` file at the root of the project, and rust-anlayzer will discover it.\n+* Specify `\"rust-analyzer.linkedProjects\": [ \"path/to/rust-project.json\" ]` in the settings (and make sure that your LSP client sends settings as a part of initialize request).\n+* Specify `\"rust-analyzer.linkedProjects\": [ { \"roots\": [...], \"crates\": [...] }]` inline.\n+\n+See https://github.com/rust-analyzer/rust-project.json-example for a small example.\n+\n == Features\n \n include::./generated_features.adoc[]"}, {"sha": "30ab7ba4a9f831fcd78b80cd0cae68047eb25b71", "filename": "editors/code/package.json", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -475,6 +475,25 @@\n                     \"markdownDescription\": \"Whether to show Implementations lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n                     \"type\": \"boolean\",\n                     \"default\": true\n+                },\n+                \"rust-analyzer.linkedProjects\": {\n+                    \"markdownDescription\": [\n+                        \"Disable project auto-discovery in favor of explicitly specified set of projects.\",\n+                        \"Elements must be paths pointing to Cargo.toml, rust-project.json, or JSON objects in rust-project.json format\"\n+                    ],\n+                    \"type\": \"array\",\n+                    \"items\": {\n+                        \"type\": [\n+                            \"string\",\n+                            \"object\"\n+                        ]\n+                    },\n+                    \"default\": null\n+                },\n+                \"rust-analyzer.withSysroot\": {\n+                    \"markdownDescription\": \"Internal config for debugging, disables loading of sysroot crates\",\n+                    \"type\": \"boolean\",\n+                    \"default\": true\n                 }\n             }\n         },"}, {"sha": "f5f4b964a4c1a2a16c05b6b25821965ead780807", "filename": "xtask/src/codegen.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/xtask%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/xtask%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -18,8 +18,10 @@ use std::{\n use crate::{not_bash::fs2, project_root, Result};\n \n pub use self::{\n-    gen_assists_docs::generate_assists_docs, gen_feature_docs::generate_feature_docs,\n-    gen_parser_tests::generate_parser_tests, gen_syntax::generate_syntax,\n+    gen_assists_docs::{generate_assists_docs, generate_assists_tests},\n+    gen_feature_docs::generate_feature_docs,\n+    gen_parser_tests::generate_parser_tests,\n+    gen_syntax::generate_syntax,\n };\n \n const GRAMMAR_DIR: &str = \"crates/ra_parser/src/grammar\";"}, {"sha": "526941f73aceb05338fe7dc7d0b234796ce0e8de", "filename": "xtask/src/codegen/gen_assists_docs.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -7,16 +7,17 @@ use crate::{\n     project_root, rust_files, Result,\n };\n \n-pub fn generate_assists_docs(mode: Mode) -> Result<()> {\n+pub fn generate_assists_tests(mode: Mode) -> Result<()> {\n     let assists = Assist::collect()?;\n-    generate_tests(&assists, mode)?;\n+    generate_tests(&assists, mode)\n+}\n \n+pub fn generate_assists_docs(mode: Mode) -> Result<()> {\n+    let assists = Assist::collect()?;\n     let contents = assists.into_iter().map(|it| it.to_string()).collect::<Vec<_>>().join(\"\\n\\n\");\n     let contents = contents.trim().to_string() + \"\\n\";\n     let dst = project_root().join(\"docs/user/generated_assists.adoc\");\n-    codegen::update(&dst, &contents, mode)?;\n-\n-    Ok(())\n+    codegen::update(&dst, &contents, mode)\n }\n \n #[derive(Debug)]"}, {"sha": "739f49f7be8183dde593fafa619b0e248c218938", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -160,6 +160,8 @@ pub fn run_release(dry_run: bool) -> Result<()> {\n         run!(\"git reset --hard tags/nightly\")?;\n         run!(\"git push\")?;\n     }\n+    codegen::generate_assists_docs(Mode::Overwrite)?;\n+    codegen::generate_feature_docs(Mode::Overwrite)?;\n \n     let website_root = project_root().join(\"../rust-analyzer.github.io\");\n     let changelog_dir = website_root.join(\"./thisweek/_posts\");"}, {"sha": "81bb3a33f29e5118a10a817c181c62504793006c", "filename": "xtask/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -74,6 +74,7 @@ FLAGS:\n             args.finish()?;\n             codegen::generate_syntax(Mode::Overwrite)?;\n             codegen::generate_parser_tests(Mode::Overwrite)?;\n+            codegen::generate_assists_tests(Mode::Overwrite)?;\n             codegen::generate_assists_docs(Mode::Overwrite)?;\n             codegen::generate_feature_docs(Mode::Overwrite)?;\n             Ok(())"}, {"sha": "d38ac7f17e78e818069db71dd0e3b07a6dd22f22", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=6a0083a519680e8d16bde5d7c1940c8dd6d4e9d4", "patch": "@@ -25,18 +25,11 @@ fn generated_tests_are_fresh() {\n \n #[test]\n fn generated_assists_are_fresh() {\n-    if let Err(error) = codegen::generate_assists_docs(Mode::Verify) {\n+    if let Err(error) = codegen::generate_assists_tests(Mode::Verify) {\n         panic!(\"{}. Please update assists by running `cargo xtask codegen`\", error);\n     }\n }\n \n-#[test]\n-fn generated_features_are_fresh() {\n-    if let Err(error) = codegen::generate_feature_docs(Mode::Verify) {\n-        panic!(\"{}. Please update features by running `cargo xtask codegen`\", error);\n-    }\n-}\n-\n #[test]\n fn check_code_formatting() {\n     if let Err(error) = run_rustfmt(Mode::Verify) {\n@@ -180,13 +173,11 @@ impl TidyDocs {\n }\n \n fn is_exclude_dir(p: &Path, dirs_to_exclude: &[&str]) -> bool {\n-    let mut cur_path = p;\n-    while let Some(path) = cur_path.parent() {\n-        if dirs_to_exclude.iter().any(|dir| path.ends_with(dir)) {\n-            return true;\n-        }\n-        cur_path = path;\n-    }\n-\n-    false\n+    p.strip_prefix(project_root())\n+        .unwrap()\n+        .components()\n+        .rev()\n+        .skip(1)\n+        .filter_map(|it| it.as_os_str().to_str())\n+        .any(|it| dirs_to_exclude.contains(&it))\n }"}]}