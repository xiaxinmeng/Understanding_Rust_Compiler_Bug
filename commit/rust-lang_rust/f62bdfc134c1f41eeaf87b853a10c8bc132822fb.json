{"sha": "f62bdfc134c1f41eeaf87b853a10c8bc132822fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MmJkZmMxMzRjMWY0MWVlYWY4N2I4NTNhMTBjOGJjMTMyODIyZmI=", "commit": {"author": {"name": "Ryan Scheel (Havvy)", "email": "ryan.havvy@gmail.com", "date": "2014-03-23T00:50:59Z"}, "committer": {"name": "Ryan Scheel (Havvy)", "email": "ryan.havvy@gmail.com", "date": "2014-03-23T00:50:59Z"}, "message": "Change types T,U to R (recv), S (sender) in libsync/comm.rs", "tree": {"sha": "12d153495646cfd5583c4f6a01e228e5bbd7accb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12d153495646cfd5583c4f6a01e228e5bbd7accb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f62bdfc134c1f41eeaf87b853a10c8bc132822fb", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f62bdfc134c1f41eeaf87b853a10c8bc132822fb", "html_url": "https://github.com/rust-lang/rust/commit/f62bdfc134c1f41eeaf87b853a10c8bc132822fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f62bdfc134c1f41eeaf87b853a10c8bc132822fb/comments", "author": {"login": "Havvy", "id": 731722, "node_id": "MDQ6VXNlcjczMTcyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/731722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Havvy", "html_url": "https://github.com/Havvy", "followers_url": "https://api.github.com/users/Havvy/followers", "following_url": "https://api.github.com/users/Havvy/following{/other_user}", "gists_url": "https://api.github.com/users/Havvy/gists{/gist_id}", "starred_url": "https://api.github.com/users/Havvy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Havvy/subscriptions", "organizations_url": "https://api.github.com/users/Havvy/orgs", "repos_url": "https://api.github.com/users/Havvy/repos", "events_url": "https://api.github.com/users/Havvy/events{/privacy}", "received_events_url": "https://api.github.com/users/Havvy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Havvy", "id": 731722, "node_id": "MDQ6VXNlcjczMTcyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/731722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Havvy", "html_url": "https://github.com/Havvy", "followers_url": "https://api.github.com/users/Havvy/followers", "following_url": "https://api.github.com/users/Havvy/following{/other_user}", "gists_url": "https://api.github.com/users/Havvy/gists{/gist_id}", "starred_url": "https://api.github.com/users/Havvy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Havvy/subscriptions", "organizations_url": "https://api.github.com/users/Havvy/orgs", "repos_url": "https://api.github.com/users/Havvy/repos", "events_url": "https://api.github.com/users/Havvy/events{/privacy}", "received_events_url": "https://api.github.com/users/Havvy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a73d2c70d4c24b85f3846d79b241ba1eb5f95e23", "url": "https://api.github.com/repos/rust-lang/rust/commits/a73d2c70d4c24b85f3846d79b241ba1eb5f95e23", "html_url": "https://github.com/rust-lang/rust/commit/a73d2c70d4c24b85f3846d79b241ba1eb5f95e23"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "aecea37cce8b563aca65478c5fd23ad8a1fe2486", "filename": "src/libsync/comm.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f62bdfc134c1f41eeaf87b853a10c8bc132822fb/src%2Flibsync%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62bdfc134c1f41eeaf87b853a10c8bc132822fb/src%2Flibsync%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm.rs?ref=f62bdfc134c1f41eeaf87b853a10c8bc132822fb", "patch": "@@ -19,68 +19,68 @@ Higher level communication abstractions.\n use std::comm;\n \n /// An extension of `pipes::stream` that allows both sending and receiving.\n-pub struct DuplexStream<T, U> {\n-    priv tx: Sender<T>,\n-    priv rx: Receiver<U>,\n+pub struct DuplexStream<S, R> {\n+    priv tx: Sender<S>,\n+    priv rx: Receiver<R>,\n }\n \n /// Creates a bidirectional stream.\n-pub fn duplex<T: Send, U: Send>() -> (DuplexStream<T, U>, DuplexStream<U, T>) {\n+pub fn duplex<S: Send, R: Send>() -> (DuplexStream<S, R>, DuplexStream<R, S>) {\n     let (tx1, rx1) = channel();\n     let (tx2, rx2) = channel();\n     (DuplexStream { tx: tx1, rx: rx2 },\n      DuplexStream { tx: tx2, rx: rx1 })\n }\n \n // Allow these methods to be used without import:\n-impl<T:Send,U:Send> DuplexStream<T, U> {\n-    pub fn send(&self, x: T) {\n+impl<S:Send,R:Send> DuplexStream<S, R> {\n+    pub fn send(&self, x: S) {\n         self.tx.send(x)\n     }\n-    pub fn try_send(&self, x: T) -> bool {\n+    pub fn try_send(&self, x: S) -> bool {\n         self.tx.try_send(x)\n     }\n-    pub fn recv(&self) -> U {\n+    pub fn recv(&self) -> R {\n         self.rx.recv()\n     }\n-    pub fn try_recv(&self) -> comm::TryRecvResult<U> {\n+    pub fn try_recv(&self) -> comm::TryRecvResult<R> {\n         self.rx.try_recv()\n     }\n-    pub fn recv_opt(&self) -> Option<U> {\n+    pub fn recv_opt(&self) -> Option<R> {\n         self.rx.recv_opt()\n     }\n }\n \n /// An extension of `pipes::stream` that provides synchronous message sending.\n-pub struct SyncSender<T> { priv duplex_stream: DuplexStream<T, ()> }\n+pub struct SyncSender<S> { priv duplex_stream: DuplexStream<S, ()> }\n /// An extension of `pipes::stream` that acknowledges each message received.\n-pub struct SyncReceiver<T> { priv duplex_stream: DuplexStream<(), T> }\n+pub struct SyncReceiver<R> { priv duplex_stream: DuplexStream<(), R> }\n \n-impl<T: Send> SyncSender<T> {\n-    pub fn send(&self, val: T) {\n+impl<S: Send> SyncSender<S> {\n+    pub fn send(&self, val: S) {\n         assert!(self.try_send(val), \"SyncSender.send: receiving port closed\");\n     }\n \n     /// Sends a message, or report if the receiver has closed the connection\n     /// before receiving.\n-    pub fn try_send(&self, val: T) -> bool {\n+    pub fn try_send(&self, val: S) -> bool {\n         self.duplex_stream.try_send(val) && self.duplex_stream.recv_opt().is_some()\n     }\n }\n \n-impl<T: Send> SyncReceiver<T> {\n-    pub fn recv(&self) -> T {\n+impl<R: Send> SyncReceiver<R> {\n+    pub fn recv(&self) -> R {\n         self.recv_opt().expect(\"SyncReceiver.recv: sending channel closed\")\n     }\n \n-    pub fn recv_opt(&self) -> Option<T> {\n+    pub fn recv_opt(&self) -> Option<R> {\n         self.duplex_stream.recv_opt().map(|val| {\n             self.duplex_stream.try_send(());\n             val\n         })\n     }\n \n-    pub fn try_recv(&self) -> comm::TryRecvResult<T> {\n+    pub fn try_recv(&self) -> comm::TryRecvResult<R> {\n         match self.duplex_stream.try_recv() {\n             comm::Data(t) => { self.duplex_stream.try_send(()); comm::Data(t) }\n             state => state,"}]}