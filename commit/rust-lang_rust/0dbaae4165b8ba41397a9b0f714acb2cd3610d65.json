{"sha": "0dbaae4165b8ba41397a9b0f714acb2cd3610d65", "node_id": "C_kwDOAAsO6NoAKDBkYmFhZTQxNjViOGJhNDEzOTdhOWIwZjcxNGFjYjJjZDM2MTBkNjU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-22T03:11:25Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-09T20:37:50Z"}, "message": "Make alias bounds sound in the new solver", "tree": {"sha": "29865fbb201f353084bd47622ee261ac44dcb8d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29865fbb201f353084bd47622ee261ac44dcb8d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dbaae4165b8ba41397a9b0f714acb2cd3610d65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dbaae4165b8ba41397a9b0f714acb2cd3610d65", "html_url": "https://github.com/rust-lang/rust/commit/0dbaae4165b8ba41397a9b0f714acb2cd3610d65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dbaae4165b8ba41397a9b0f714acb2cd3610d65/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a37c2f0523c87147b64f1b8099fc9df22e8c53e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a37c2f0523c87147b64f1b8099fc9df22e8c53e", "html_url": "https://github.com/rust-lang/rust/commit/3a37c2f0523c87147b64f1b8099fc9df22e8c53e"}], "stats": {"total": 235, "additions": 233, "deletions": 2}, "files": [{"sha": "0f42d5f12628f7ffca362aebe61779a34a51c629", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "modified", "additions": 114, "deletions": 2, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/0dbaae4165b8ba41397a9b0f714acb2cd3610d65/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbaae4165b8ba41397a9b0f714acb2cd3610d65/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=0dbaae4165b8ba41397a9b0f714acb2cd3610d65", "patch": "@@ -8,6 +8,7 @@ use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate;\n+use rustc_infer::traits::Reveal;\n use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, MaybeCause, QueryResult};\n use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::TypeFoldable;\n@@ -87,7 +88,9 @@ pub(super) enum CandidateSource {\n }\n \n /// Methods used to assemble candidates for either trait or projection goals.\n-pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n+pub(super) trait GoalKind<'tcx>:\n+    TypeFoldable<TyCtxt<'tcx>> + Copy + Eq + std::fmt::Display\n+{\n     fn self_ty(self) -> Ty<'tcx>;\n \n     fn trait_ref(self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx>;\n@@ -106,6 +109,16 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n     ) -> QueryResult<'tcx>;\n \n+    /// Consider a bound originating from the item bounds of an alias. For this we\n+    /// require that the well-formed requirements of the self type of the goal\n+    /// are \"satisfied from the param-env\".\n+    /// See [`EvalCtxt::validate_alias_bound_self_from_param_env`].\n+    fn consider_alias_bound_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx>;\n+\n     // Consider a clause specifically for a `dyn Trait` self type. This requires\n     // additionally checking all of the supertraits and object bounds to hold,\n     // since they're not implied by the well-formedness of the object type.\n@@ -463,7 +476,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         for assumption in self.tcx().item_bounds(alias_ty.def_id).subst(self.tcx(), alias_ty.substs)\n         {\n-            match G::consider_implied_clause(self, goal, assumption, []) {\n+            match G::consider_alias_bound_candidate(self, goal, assumption) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::AliasBound, result })\n                 }\n@@ -472,6 +485,105 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    /// Check that we are allowed to use an alias bound originating from the self\n+    /// type of this goal. This means something different depending on the self type's\n+    /// alias kind.\n+    ///\n+    /// * Projection: Given a goal with a self type such as `<Ty as Trait>::Assoc`,\n+    /// we require that the bound `Ty: Trait` can be proven using either a nested alias\n+    /// bound candidate, or a param-env candidate.\n+    ///\n+    /// * Opaque: The param-env must be in `Reveal::UserFacing` mode. Otherwise,\n+    /// the goal should be proven by using the hidden type instead.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub(super) fn validate_alias_bound_self_from_param_env<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+    ) -> QueryResult<'tcx> {\n+        match *goal.predicate.self_ty().kind() {\n+            ty::Alias(ty::Projection, projection_ty) => {\n+                let mut param_env_candidates = vec![];\n+                let self_trait_ref = projection_ty.trait_ref(self.tcx());\n+\n+                if self_trait_ref.self_ty().is_ty_var() {\n+                    return self\n+                        .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n+                }\n+\n+                let trait_goal: Goal<'_, ty::TraitPredicate<'tcx>> = goal.with(\n+                    self.tcx(),\n+                    ty::TraitPredicate {\n+                        trait_ref: self_trait_ref,\n+                        constness: ty::BoundConstness::NotConst,\n+                        polarity: ty::ImplPolarity::Positive,\n+                    },\n+                );\n+\n+                self.assemble_param_env_candidates(trait_goal, &mut param_env_candidates);\n+                // FIXME: We probably need some sort of recursion depth check here.\n+                // Can't come up with an example yet, though, and the worst case\n+                // we can have is a compiler stack overflow...\n+                self.assemble_alias_bound_candidates(trait_goal, &mut param_env_candidates);\n+\n+                // FIXME: We must also consider alias-bound candidates for a peculiar\n+                // class of built-in candidates that I'll call \"defaulted\" built-ins.\n+                //\n+                // For example, we always know that `T: Pointee` is implemented, but\n+                // we do not always know what `<T as Pointee>::Metadata` actually is,\n+                // similar to if we had a user-defined impl with a `default type ...`.\n+                // For these traits, since we're not able to always normalize their\n+                // associated types to a concrete type, we must consider their alias bounds\n+                // instead, so we can prove bounds such as `<T as Pointee>::Metadata: Copy`.\n+                self.assemble_alias_bound_candidates_for_builtin_impl_default_items(\n+                    trait_goal,\n+                    &mut param_env_candidates,\n+                );\n+\n+                self.merge_candidates(param_env_candidates)\n+            }\n+            ty::Alias(ty::Opaque, _opaque_ty) => match goal.param_env.reveal() {\n+                Reveal::UserFacing => {\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                }\n+                Reveal::All => return Err(NoSolution),\n+            },\n+            _ => bug!(\"only expected to be called on alias tys\"),\n+        }\n+    }\n+\n+    /// Assemble a subset of builtin impl candidates for a class of candidates called\n+    /// \"defaulted\" built-in traits.\n+    ///\n+    /// For example, we always know that `T: Pointee` is implemented, but we do not\n+    /// always know what `<T as Pointee>::Metadata` actually is! See the comment in\n+    /// [`EvalCtxt::validate_alias_bound_self_from_param_env`] for more detail.\n+    #[instrument(level = \"debug\", skip_all)]\n+    fn assemble_alias_bound_candidates_for_builtin_impl_default_items<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let lang_items = self.tcx().lang_items();\n+        let trait_def_id = goal.predicate.trait_def_id(self.tcx());\n+\n+        // You probably shouldn't add anything to this list unless you\n+        // know what you're doing.\n+        let result = if lang_items.pointee_trait() == Some(trait_def_id) {\n+            G::consider_builtin_pointee_candidate(self, goal)\n+        } else if lang_items.discriminant_kind_trait() == Some(trait_def_id) {\n+            G::consider_builtin_discriminant_kind_candidate(self, goal)\n+        } else {\n+            Err(NoSolution)\n+        };\n+\n+        match result {\n+            Ok(result) => {\n+                candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n+            }\n+            Err(NoSolution) => (),\n+        }\n+    }\n+\n     #[instrument(level = \"debug\", skip_all)]\n     fn assemble_object_bound_candidates<G: GoalKind<'tcx>>(\n         &mut self,"}, {"sha": "85ac7f15a2fb684f5ac9921041b2ebdec441b0ec", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0dbaae4165b8ba41397a9b0f714acb2cd3610d65/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbaae4165b8ba41397a9b0f714acb2cd3610d65/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=0dbaae4165b8ba41397a9b0f714acb2cd3610d65", "patch": "@@ -83,6 +83,30 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         }\n     }\n \n+    fn consider_alias_bound_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n+            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n+        {\n+            ecx.probe(|ecx| {\n+                let assumption_projection_pred =\n+                    ecx.instantiate_binder_with_infer(poly_projection_pred);\n+                ecx.eq(\n+                    goal.param_env,\n+                    goal.predicate.projection_ty,\n+                    assumption_projection_pred.projection_ty,\n+                )?;\n+                ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)?;\n+                ecx.validate_alias_bound_self_from_param_env(goal)\n+            })\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n     fn consider_object_bound_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,"}, {"sha": "0f6fd4059b445a7c8c8784a452bb8af0cae40078", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0dbaae4165b8ba41397a9b0f714acb2cd3610d65/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbaae4165b8ba41397a9b0f714acb2cd3610d65/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=0dbaae4165b8ba41397a9b0f714acb2cd3610d65", "patch": "@@ -105,6 +105,30 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         }\n     }\n \n+    fn consider_alias_bound_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n+            && poly_trait_pred.def_id() == goal.predicate.def_id()\n+        {\n+            // FIXME: Constness and polarity\n+            ecx.probe(|ecx| {\n+                let assumption_trait_pred =\n+                    ecx.instantiate_binder_with_infer(poly_trait_pred);\n+                ecx.eq(\n+                    goal.param_env,\n+                    goal.predicate.trait_ref,\n+                    assumption_trait_pred.trait_ref,\n+                )?;\n+                ecx.validate_alias_bound_self_from_param_env(goal)\n+            })\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n     fn consider_object_bound_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,"}, {"sha": "00294c708f1fa059701f02808d1fad4f3e018378", "filename": "tests/ui/traits/new-solver/alias-bound-unsound.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0dbaae4165b8ba41397a9b0f714acb2cd3610d65/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbaae4165b8ba41397a9b0f714acb2cd3610d65/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.rs?ref=0dbaae4165b8ba41397a9b0f714acb2cd3610d65", "patch": "@@ -0,0 +1,27 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+// Makes sure that alias bounds are not unsound!\n+\n+#![feature(trivial_bounds)]\n+\n+trait Foo {\n+    type Item: Copy\n+    where\n+        <Self as Foo>::Item: Copy;\n+\n+    fn copy_me(x: &Self::Item) -> Self::Item {\n+        *x\n+    }\n+}\n+\n+impl Foo for () {\n+    type Item = String where String: Copy;\n+}\n+\n+fn main() {\n+    let x = String::from(\"hello, world\");\n+    drop(<() as Foo>::copy_me(&x));\n+    //~^ ERROR `<() as Foo>::Item: Copy` is not satisfied\n+    //~| ERROR `<() as Foo>::Item` is not well-formed\n+    println!(\"{x}\");\n+}"}, {"sha": "9a43d2a6639ce86bf4ded8d1ca86277a8fa41b01", "filename": "tests/ui/traits/new-solver/alias-bound-unsound.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0dbaae4165b8ba41397a9b0f714acb2cd3610d65/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0dbaae4165b8ba41397a9b0f714acb2cd3610d65/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.stderr?ref=0dbaae4165b8ba41397a9b0f714acb2cd3610d65", "patch": "@@ -0,0 +1,24 @@\n+error[E0277]: the trait bound `<() as Foo>::Item: Copy` is not satisfied\n+  --> $DIR/alias-bound-unsound.rs:23:10\n+   |\n+LL |     drop(<() as Foo>::copy_me(&x));\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `<() as Foo>::Item`\n+   |\n+note: required by a bound in `Foo::Item`\n+  --> $DIR/alias-bound-unsound.rs:10:30\n+   |\n+LL |     type Item: Copy\n+   |          ---- required by a bound in this associated type\n+LL |     where\n+LL |         <Self as Foo>::Item: Copy;\n+   |                              ^^^^ required by this bound in `Foo::Item`\n+\n+error: the type `<() as Foo>::Item` is not well-formed\n+  --> $DIR/alias-bound-unsound.rs:23:10\n+   |\n+LL |     drop(<() as Foo>::copy_me(&x));\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c365902dbe5e833a07f1e5f98f247d1774b708aa", "filename": "tests/ui/traits/new-solver/nested-alias-bound.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0dbaae4165b8ba41397a9b0f714acb2cd3610d65/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-alias-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbaae4165b8ba41397a9b0f714acb2cd3610d65/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-alias-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-alias-bound.rs?ref=0dbaae4165b8ba41397a9b0f714acb2cd3610d65", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait A {\n+    type A: B;\n+}\n+\n+trait B {\n+    type B: C;\n+}\n+\n+trait C {}\n+\n+fn needs_c<T: C>() {}\n+\n+fn test<T: A>() {\n+    needs_c::<<T::A as B>::B>();\n+}\n+\n+fn main() {}"}]}