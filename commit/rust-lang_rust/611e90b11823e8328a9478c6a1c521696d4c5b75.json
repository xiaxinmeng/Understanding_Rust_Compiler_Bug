{"sha": "611e90b11823e8328a9478c6a1c521696d4c5b75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMWU5MGIxMTgyM2U4MzI4YTk0NzhjNmExYzUyMTY5NmQ0YzViNzU=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-17T23:42:16Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:03:30Z"}, "message": "Simplify intrinsic match statement", "tree": {"sha": "0f3404329d168d433c6d75b8942c2165e1cd22c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f3404329d168d433c6d75b8942c2165e1cd22c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/611e90b11823e8328a9478c6a1c521696d4c5b75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/611e90b11823e8328a9478c6a1c521696d4c5b75", "html_url": "https://github.com/rust-lang/rust/commit/611e90b11823e8328a9478c6a1c521696d4c5b75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/611e90b11823e8328a9478c6a1c521696d4c5b75/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c693bcc6253aa1b82e633c0fd0a5252c5812460b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c693bcc6253aa1b82e633c0fd0a5252c5812460b", "html_url": "https://github.com/rust-lang/rust/commit/c693bcc6253aa1b82e633c0fd0a5252c5812460b"}], "stats": {"total": 73, "additions": 36, "deletions": 37}, "files": [{"sha": "8501364ba36e04361931e5d73afd60be31c1d2fe", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/611e90b11823e8328a9478c6a1c521696d4c5b75/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/611e90b11823e8328a9478c6a1c521696d4c5b75/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=611e90b11823e8328a9478c6a1c521696d4c5b75", "patch": "@@ -116,32 +116,32 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     let llret_ty = type_of::type_of(ccx, ret_ty);\n \n     let simple = get_simple_intrinsic(ccx, name);\n-    let llval = match (simple, name) {\n-        (Some(llfn), _) => {\n-            bcx.call(llfn, &llargs, None)\n+    let llval = match name {\n+        _ if simple.is_some() => {\n+            bcx.call(simple.unwrap(), &llargs, None)\n         }\n-        (_, \"likely\") => {\n+        \"likely\" => {\n             let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n             bcx.call(expect, &[llargs[0], C_bool(ccx, true)], None)\n         }\n-        (_, \"unlikely\") => {\n+        \"unlikely\" => {\n             let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n             bcx.call(expect, &[llargs[0], C_bool(ccx, false)], None)\n         }\n-        (_, \"try\") => {\n+        \"try\" => {\n             try_intrinsic(bcx, llargs[0], llargs[1], llargs[2], llresult);\n             C_nil(ccx)\n         }\n-        (_, \"breakpoint\") => {\n+        \"breakpoint\" => {\n             let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));\n             bcx.call(llfn, &[], None)\n         }\n-        (_, \"size_of\") => {\n+        \"size_of\" => {\n             let tp_ty = substs.type_at(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n         }\n-        (_, \"size_of_val\") => {\n+        \"size_of_val\" => {\n             let tp_ty = substs.type_at(0);\n             if !type_is_sized(tcx, tp_ty) {\n                 let (llsize, _) =\n@@ -152,11 +152,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                 C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n             }\n         }\n-        (_, \"min_align_of\") => {\n+        \"min_align_of\" => {\n             let tp_ty = substs.type_at(0);\n             C_uint(ccx, type_of::align_of(ccx, tp_ty))\n         }\n-        (_, \"min_align_of_val\") => {\n+        \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n             if !type_is_sized(tcx, tp_ty) {\n                 let (_, llalign) =\n@@ -166,20 +166,20 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                 C_uint(ccx, type_of::align_of(ccx, tp_ty))\n             }\n         }\n-        (_, \"pref_align_of\") => {\n+        \"pref_align_of\" => {\n             let tp_ty = substs.type_at(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty))\n         }\n-        (_, \"type_name\") => {\n+        \"type_name\" => {\n             let tp_ty = substs.type_at(0);\n             let ty_name = Symbol::intern(&tp_ty.to_string()).as_str();\n             C_str_slice(ccx, ty_name)\n         }\n-        (_, \"type_id\") => {\n+        \"type_id\" => {\n             C_u64(ccx, ccx.tcx().type_id_hash(substs.type_at(0)))\n         }\n-        (_, \"init\") => {\n+        \"init\" => {\n             let ty = substs.type_at(0);\n             if !type_is_zero_size(ccx, ty) {\n                 // Just zero out the stack slot.\n@@ -191,26 +191,26 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             C_nil(ccx)\n         }\n         // Effectively no-ops\n-        (_, \"uninit\") | (_, \"forget\") => {\n+        \"uninit\" | \"forget\" => {\n             C_nil(ccx)\n         }\n-        (_, \"needs_drop\") => {\n+        \"needs_drop\" => {\n             let tp_ty = substs.type_at(0);\n \n             C_bool(ccx, bcx.fcx().type_needs_drop(tp_ty))\n         }\n-        (_, \"offset\") => {\n+        \"offset\" => {\n             let ptr = llargs[0];\n             let offset = llargs[1];\n             bcx.inbounds_gep(ptr, &[offset])\n         }\n-        (_, \"arith_offset\") => {\n+        \"arith_offset\" => {\n             let ptr = llargs[0];\n             let offset = llargs[1];\n             bcx.gep(ptr, &[offset])\n         }\n \n-        (_, \"copy_nonoverlapping\") => {\n+        \"copy_nonoverlapping\" => {\n             copy_intrinsic(bcx,\n                            false,\n                            false,\n@@ -219,7 +219,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                            llargs[0],\n                            llargs[2])\n         }\n-        (_, \"copy\") => {\n+        \"copy\" => {\n             copy_intrinsic(bcx,\n                            true,\n                            false,\n@@ -228,11 +228,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                            llargs[0],\n                            llargs[2])\n         }\n-        (_, \"write_bytes\") => {\n+        \"write_bytes\" => {\n             memset_intrinsic(bcx, false, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n         }\n \n-        (_, \"volatile_copy_nonoverlapping_memory\") => {\n+        \"volatile_copy_nonoverlapping_memory\" => {\n             copy_intrinsic(bcx,\n                            false,\n                            true,\n@@ -241,7 +241,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                            llargs[1],\n                            llargs[2])\n         }\n-        (_, \"volatile_copy_memory\") => {\n+        \"volatile_copy_memory\" => {\n             copy_intrinsic(bcx,\n                            true,\n                            true,\n@@ -250,10 +250,10 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                            llargs[1],\n                            llargs[2])\n         }\n-        (_, \"volatile_set_memory\") => {\n+        \"volatile_set_memory\" => {\n             memset_intrinsic(bcx, true, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n         }\n-        (_, \"volatile_load\") => {\n+        \"volatile_load\" => {\n             let tp_ty = substs.type_at(0);\n             let mut ptr = llargs[0];\n             if let Some(ty) = fn_ty.ret.cast {\n@@ -265,7 +265,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             }\n             to_immediate(bcx, load, tp_ty)\n         },\n-        (_, \"volatile_store\") => {\n+        \"volatile_store\" => {\n             let tp_ty = substs.type_at(0);\n             if type_is_fat_ptr(bcx.tcx(), tp_ty) {\n                 bcx.volatile_store(llargs[1], get_dataptr(bcx, llargs[0]));\n@@ -285,10 +285,10 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             C_nil(ccx)\n         },\n \n-        (_, \"ctlz\") | (_, \"cttz\") | (_, \"ctpop\") | (_, \"bswap\") |\n-        (_, \"add_with_overflow\") | (_, \"sub_with_overflow\") | (_, \"mul_with_overflow\") |\n-        (_, \"overflowing_add\") | (_, \"overflowing_sub\") | (_, \"overflowing_mul\") |\n-        (_, \"unchecked_div\") | (_, \"unchecked_rem\") => {\n+        \"ctlz\" | \"cttz\" | \"ctpop\" | \"bswap\" |\n+        \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n+        \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n+        \"unchecked_div\" | \"unchecked_rem\" => {\n             let sty = &arg_tys[0].sty;\n             match int_type_width_signed(sty, ccx) {\n                 Some((width, signed)) =>\n@@ -340,8 +340,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             }\n \n         },\n-        (_, \"fadd_fast\") | (_, \"fsub_fast\") | (_, \"fmul_fast\") | (_, \"fdiv_fast\") |\n-        (_, \"frem_fast\") => {\n+        \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n             let sty = &arg_tys[0].sty;\n             match float_type_width(sty) {\n                 Some(_width) =>\n@@ -364,7 +363,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n \n         },\n \n-        (_, \"discriminant_value\") => {\n+        \"discriminant_value\" => {\n             let val_ty = substs.type_at(0);\n             match val_ty.sty {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n@@ -374,7 +373,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                 _ => C_null(llret_ty)\n             }\n         }\n-        (_, name) if name.starts_with(\"simd_\") => {\n+        name if name.starts_with(\"simd_\") => {\n             generic_simd_intrinsic(bcx, name,\n                                    callee_ty,\n                                    &llargs,\n@@ -383,7 +382,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         }\n         // This requires that atomic intrinsics follow a specific naming pattern:\n         // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n-        (_, name) if name.starts_with(\"atomic_\") => {\n+        name if name.starts_with(\"atomic_\") => {\n             use llvm::AtomicOrdering::*;\n \n             let split: Vec<&str> = name.split('_').collect();\n@@ -501,7 +500,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n \n         }\n \n-        (..) => {\n+        _ => {\n             let intr = match Intrinsic::find(&name) {\n                 Some(intr) => intr,\n                 None => bug!(\"unknown intrinsic '{}'\", name),"}]}