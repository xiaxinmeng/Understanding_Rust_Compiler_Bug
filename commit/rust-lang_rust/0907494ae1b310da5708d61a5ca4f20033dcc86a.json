{"sha": "0907494ae1b310da5708d61a5ca4f20033dcc86a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MDc0OTRhZTFiMzEwZGE1NzA4ZDYxYTVjYTRmMjAwMzNkY2M4NmE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-05T03:12:38Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-05T03:12:38Z"}, "message": "miri: use AllocId instead of u64.", "tree": {"sha": "8b6f131971fb97eff465ec5eeba4bb17f07f6d34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b6f131971fb97eff465ec5eeba4bb17f07f6d34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0907494ae1b310da5708d61a5ca4f20033dcc86a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0907494ae1b310da5708d61a5ca4f20033dcc86a", "html_url": "https://github.com/rust-lang/rust/commit/0907494ae1b310da5708d61a5ca4f20033dcc86a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0907494ae1b310da5708d61a5ca4f20033dcc86a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e7a609e635b728eba65d471c985ab462dc4cfc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e7a609e635b728eba65d471c985ab462dc4cfc7", "html_url": "https://github.com/rust-lang/rust/commit/8e7a609e635b728eba65d471c985ab462dc4cfc7"}], "stats": {"total": 143, "additions": 71, "deletions": 72}, "files": [{"sha": "8ffea62f6be51a16cf2fbaa2a515a46c24135be1", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=0907494ae1b310da5708d61a5ca4f20033dcc86a", "patch": "@@ -145,7 +145,7 @@ impl<'tcx> MemoryPointer {\n }\n \n \n-#[derive(Copy, Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug)]\n+#[derive(Copy, Clone, Default, Eq, Hash, Ord, PartialEq, PartialOrd, Debug)]\n pub struct AllocId(pub u64);\n \n impl fmt::Display for AllocId {"}, {"sha": "e78bee7c01bb3915025c49ae10a15b97b044528a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0907494ae1b310da5708d61a5ca4f20033dcc86a", "patch": "@@ -895,31 +895,29 @@ pub struct InterpretInterner<'tcx> {\n     allocs: FxHashSet<&'tcx interpret::Allocation>,\n \n     /// Allows obtaining function instance handles via a unique identifier\n-    functions: FxHashMap<u64, Instance<'tcx>>,\n+    functions: FxHashMap<interpret::AllocId, Instance<'tcx>>,\n \n     /// Inverse map of `interpret_functions`.\n     /// Used so we don't allocate a new pointer every time we need one\n-    function_cache: FxHashMap<Instance<'tcx>, u64>,\n+    function_cache: FxHashMap<Instance<'tcx>, interpret::AllocId>,\n \n     /// Allows obtaining const allocs via a unique identifier\n-    alloc_by_id: FxHashMap<u64, &'tcx interpret::Allocation>,\n+    alloc_by_id: FxHashMap<interpret::AllocId, &'tcx interpret::Allocation>,\n \n     /// The AllocId to assign to the next new regular allocation.\n     /// Always incremented, never gets smaller.\n-    next_id: u64,\n+    next_id: interpret::AllocId,\n \n     /// Allows checking whether a constant already has an allocation\n-    ///\n-    /// The pointers are to the beginning of an `alloc_by_id` allocation\n-    alloc_cache: FxHashMap<interpret::GlobalId<'tcx>, interpret::Pointer>,\n+    alloc_cache: FxHashMap<interpret::GlobalId<'tcx>, interpret::AllocId>,\n \n     /// A cache for basic byte allocations keyed by their contents. This is used to deduplicate\n     /// allocations for string and bytestring literals.\n-    literal_alloc_cache: FxHashMap<Vec<u8>, u64>,\n+    literal_alloc_cache: FxHashMap<Vec<u8>, interpret::AllocId>,\n }\n \n impl<'tcx> InterpretInterner<'tcx> {\n-    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> u64 {\n+    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> interpret::AllocId {\n         if let Some(&alloc_id) = self.function_cache.get(&instance) {\n             return alloc_id;\n         }\n@@ -932,29 +930,29 @@ impl<'tcx> InterpretInterner<'tcx> {\n \n     pub fn get_fn(\n         &self,\n-        id: u64,\n+        id: interpret::AllocId,\n     ) -> Option<Instance<'tcx>> {\n         self.functions.get(&id).cloned()\n     }\n \n     pub fn get_alloc(\n         &self,\n-        id: u64,\n+        id: interpret::AllocId,\n     ) -> Option<&'tcx interpret::Allocation> {\n         self.alloc_by_id.get(&id).cloned()\n     }\n \n     pub fn get_cached(\n         &self,\n         global_id: interpret::GlobalId<'tcx>,\n-    ) -> Option<interpret::Pointer> {\n+    ) -> Option<interpret::AllocId> {\n         self.alloc_cache.get(&global_id).cloned()\n     }\n \n     pub fn cache(\n         &mut self,\n         global_id: interpret::GlobalId<'tcx>,\n-        ptr: interpret::Pointer,\n+        ptr: interpret::AllocId,\n     ) {\n         if let Some(old) = self.alloc_cache.insert(global_id, ptr) {\n             bug!(\"tried to cache {:?}, but was already existing as {:#?}\", global_id, old);\n@@ -963,7 +961,7 @@ impl<'tcx> InterpretInterner<'tcx> {\n \n     pub fn intern_at_reserved(\n         &mut self,\n-        id: u64,\n+        id: interpret::AllocId,\n         alloc: &'tcx interpret::Allocation,\n     ) {\n         if let Some(old) = self.alloc_by_id.insert(id, alloc) {\n@@ -975,9 +973,9 @@ impl<'tcx> InterpretInterner<'tcx> {\n     /// yet have an allocation backing it.\n     pub fn reserve(\n         &mut self,\n-    ) -> u64 {\n+    ) -> interpret::AllocId {\n         let next = self.next_id;\n-        self.next_id = self.next_id\n+        self.next_id.0 = self.next_id.0\n             .checked_add(1)\n             .expect(\"You overflowed a u64 by incrementing by 1... \\\n                      You've just earned yourself a free drink if we ever meet. \\\n@@ -1069,7 +1067,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Allocates a byte or string literal for `mir::interpret`\n-    pub fn allocate_cached(self, bytes: &[u8]) -> u64 {\n+    pub fn allocate_cached(self, bytes: &[u8]) -> interpret::AllocId {\n         // check whether we already allocated this literal or a constant with the same memory\n         if let Some(&alloc_id) = self.interpret_interner.borrow().literal_alloc_cache.get(bytes) {\n             return alloc_id;"}, {"sha": "3705534929fadc0b268ec5e40c90d4e7f5bbe320", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=0907494ae1b310da5708d61a5ca4f20033dcc86a", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n \n-use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, Pointer, PrimVal};\n+use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, MemoryPointer, Pointer, PrimVal};\n use super::{Place, EvalContext, StackPopCleanup, ValTy};\n \n use rustc_const_math::ConstInt;\n@@ -67,7 +67,7 @@ pub fn eval_body<'a, 'tcx>(\n             layout.align,\n             None,\n         )?;\n-        tcx.interpret_interner.borrow_mut().cache(cid, ptr.into());\n+        tcx.interpret_interner.borrow_mut().cache(cid, ptr.alloc_id);\n         let cleanup = StackPopCleanup::MarkStatic(Mutability::Immutable);\n         let name = ty::tls::with(|tcx| tcx.item_path_str(instance.def_id()));\n         trace!(\"const_eval: pushing stack frame for global: {}\", name);\n@@ -81,8 +81,8 @@ pub fn eval_body<'a, 'tcx>(\n \n         while ecx.step()? {}\n     }\n-    let value = tcx.interpret_interner.borrow().get_cached(cid).expect(\"global not cached\");\n-    Ok((value, instance_ty))\n+    let alloc = tcx.interpret_interner.borrow().get_cached(cid).expect(\"global not cached\");\n+    Ok((MemoryPointer::new(alloc, 0).into(), instance_ty))\n }\n \n pub fn eval_body_as_integer<'a, 'tcx>("}, {"sha": "000358f44b6c1de07be2e4fc1fd41e49a87fd260", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=0907494ae1b310da5708d61a5ca4f20033dcc86a", "patch": "@@ -950,8 +950,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn read_global_as_value(&self, gid: GlobalId, layout: TyLayout) -> Value {\n-        Value::ByRef(self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"global not cached\"),\n-                     layout.align)\n+        let alloc = self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"global not cached\");\n+        Value::ByRef(MemoryPointer::new(alloc, 0).into(), layout.align)\n     }\n \n     pub fn force_allocation(&mut self, place: Place) -> EvalResult<'tcx, Place> {"}, {"sha": "c2989dbaaf11fb7f3fc50f447caaf579cd2bbbeb", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=0907494ae1b310da5708d61a5ca4f20033dcc86a", "patch": "@@ -2,7 +2,7 @@\n //! This separation exists to ensure that no fancy miri features like\n //! interpreting common C functions leak into CTFE.\n \n-use rustc::mir::interpret::{EvalResult, PrimVal, MemoryPointer, AccessKind};\n+use rustc::mir::interpret::{AllocId, EvalResult, PrimVal, MemoryPointer, AccessKind};\n use super::{EvalContext, Place, ValTy, Memory};\n \n use rustc::mir;\n@@ -89,12 +89,12 @@ pub trait Machine<'tcx>: Sized {\n \n     fn add_lock<'a>(\n         _mem: &mut Memory<'a, 'tcx, Self>,\n-        _id: u64,\n+        _id: AllocId,\n     ) {}\n \n     fn free_lock<'a>(\n         _mem: &mut Memory<'a, 'tcx, Self>,\n-        _id: u64,\n+        _id: AllocId,\n         _len: u64,\n     ) -> EvalResult<'tcx> {\n         Ok(())"}, {"sha": "3a28eae2d1c49e502773a5d8e505a7137ff1cb76", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=0907494ae1b310da5708d61a5ca4f20033dcc86a", "patch": "@@ -34,15 +34,15 @@ pub struct Memory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     pub data: M::MemoryData,\n \n     /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n-    alloc_kind: HashMap<u64, MemoryKind<M::MemoryKinds>>,\n+    alloc_kind: HashMap<AllocId, MemoryKind<M::MemoryKinds>>,\n \n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n-    alloc_map: HashMap<u64, Allocation>,\n+    alloc_map: HashMap<AllocId, Allocation>,\n \n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n     ///\n     /// Stores statics while they are being processed, before they are interned and thus frozen\n-    uninitialized_statics: HashMap<u64, Allocation>,\n+    uninitialized_statics: HashMap<AllocId, Allocation>,\n \n     /// Number of virtual bytes allocated.\n     memory_usage: u64,\n@@ -73,17 +73,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     pub fn allocations<'x>(\n         &'x self,\n     ) -> impl Iterator<Item = (AllocId, &'x Allocation)> {\n-        self.alloc_map.iter().map(|(&id, alloc)| (AllocId(id), alloc))\n+        self.alloc_map.iter().map(|(&id, alloc)| (id, alloc))\n     }\n \n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> MemoryPointer {\n         let id = self.tcx.interpret_interner.borrow_mut().create_fn_alloc(instance);\n-        MemoryPointer::new(AllocId(id), 0)\n+        MemoryPointer::new(id, 0)\n     }\n \n     pub fn allocate_cached(&mut self, bytes: &[u8]) -> MemoryPointer {\n         let id = self.tcx.allocate_cached(bytes);\n-        MemoryPointer::new(AllocId(id), 0)\n+        MemoryPointer::new(id, 0)\n     }\n \n     /// kind is `None` for statics\n@@ -121,7 +121,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             },\n             Some(MemoryKind::MutableStatic) => bug!(\"don't allocate mutable statics directly\")\n         }\n-        Ok(MemoryPointer::new(AllocId(id), 0))\n+        Ok(MemoryPointer::new(id, 0))\n     }\n \n     pub fn reallocate(\n@@ -136,8 +136,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         if ptr.offset != 0 {\n             return err!(ReallocateNonBasePtr);\n         }\n-        if self.alloc_map.contains_key(&ptr.alloc_id.0) {\n-            let alloc_kind = self.alloc_kind[&ptr.alloc_id.0];\n+        if self.alloc_map.contains_key(&ptr.alloc_id) {\n+            let alloc_kind = self.alloc_kind[&ptr.alloc_id];\n             if alloc_kind != kind {\n                 return err!(ReallocatedWrongMemoryKind(\n                     format!(\"{:?}\", alloc_kind),\n@@ -163,7 +163,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     pub fn deallocate_local(&mut self, ptr: MemoryPointer) -> EvalResult<'tcx> {\n-        match self.alloc_kind.get(&ptr.alloc_id.0).cloned() {\n+        match self.alloc_kind.get(&ptr.alloc_id).cloned() {\n             // for a constant like `const FOO: &i32 = &1;` the local containing\n             // the `1` is referred to by the global. We transitively marked everything\n             // the global refers to as static itself, so we don't free it here\n@@ -185,19 +185,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             return err!(DeallocateNonBasePtr);\n         }\n \n-        let alloc = match self.alloc_map.remove(&ptr.alloc_id.0) {\n+        let alloc = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n-            None => if self.uninitialized_statics.contains_key(&ptr.alloc_id.0) {\n+            None => if self.uninitialized_statics.contains_key(&ptr.alloc_id) {\n                 return err!(DeallocatedWrongMemoryKind(\n                     \"uninitializedstatic\".to_string(),\n                     format!(\"{:?}\", kind),\n                 ))\n-            } else if self.tcx.interpret_interner.borrow().get_fn(ptr.alloc_id.0).is_some() {\n+            } else if self.tcx.interpret_interner.borrow().get_fn(ptr.alloc_id).is_some() {\n                 return err!(DeallocatedWrongMemoryKind(\n                     \"function\".to_string(),\n                     format!(\"{:?}\", kind),\n                 ))\n-            } else if self.tcx.interpret_interner.borrow().get_alloc(ptr.alloc_id.0).is_some() {\n+            } else if self.tcx.interpret_interner.borrow().get_alloc(ptr.alloc_id).is_some() {\n                 return err!(DeallocatedWrongMemoryKind(\n                     \"static\".to_string(),\n                     format!(\"{:?}\", kind),\n@@ -207,14 +207,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             },\n         };\n \n-        let alloc_kind = self.alloc_kind.remove(&ptr.alloc_id.0).expect(\"alloc_map out of sync with alloc_kind\");\n+        let alloc_kind = self.alloc_kind.remove(&ptr.alloc_id).expect(\"alloc_map out of sync with alloc_kind\");\n \n         // It is okay for us to still holds locks on deallocation -- for example, we could store data we own\n         // in a local, and the local could be deallocated (from StorageDead) before the function returns.\n         // However, we should check *something*.  For now, we make sure that there is no conflicting write\n         // lock by another frame.  We *have* to permit deallocation if we hold a read lock.\n         // TODO: Figure out the exact rules here.\n-        M::free_lock(self, ptr.alloc_id.0, alloc.bytes.len() as u64)?;\n+        M::free_lock(self, ptr.alloc_id, alloc.bytes.len() as u64)?;\n \n         if alloc_kind != kind {\n             return err!(DeallocatedWrongMemoryKind(\n@@ -295,17 +295,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n         // normal alloc?\n-        match self.alloc_map.get(&id.0) {\n+        match self.alloc_map.get(&id) {\n                     Some(alloc) => Ok(alloc),\n             // uninitialized static alloc?\n-            None => match self.uninitialized_statics.get(&id.0) {\n+            None => match self.uninitialized_statics.get(&id) {\n                 Some(alloc) => Ok(alloc),\n                 None => {\n                     let int = self.tcx.interpret_interner.borrow();\n                     // static alloc?\n-                    int.get_alloc(id.0)\n+                    int.get_alloc(id)\n                         // no alloc? produce an error\n-                        .ok_or_else(|| if int.get_fn(id.0).is_some() {\n+                        .ok_or_else(|| if int.get_fn(id).is_some() {\n                             EvalErrorKind::DerefFunctionPointer.into()\n                         } else {\n                             EvalErrorKind::DanglingPointerDeref.into()\n@@ -320,17 +320,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         id: AllocId,\n     ) -> EvalResult<'tcx, &mut Allocation> {\n         // normal alloc?\n-        match self.alloc_map.get_mut(&id.0) {\n+        match self.alloc_map.get_mut(&id) {\n             Some(alloc) => Ok(alloc),\n             // uninitialized static alloc?\n-            None => match self.uninitialized_statics.get_mut(&id.0) {\n+            None => match self.uninitialized_statics.get_mut(&id) {\n                 Some(alloc) => Ok(alloc),\n                 None => {\n                     let int = self.tcx.interpret_interner.borrow();\n                     // no alloc or immutable alloc? produce an error\n-                    if int.get_alloc(id.0).is_some() {\n+                    if int.get_alloc(id).is_some() {\n                         err!(ModifiedConstantMemory)\n-                    } else if int.get_fn(id.0).is_some() {\n+                    } else if int.get_fn(id).is_some() {\n                         err!(DerefFunctionPointer)\n                     } else {\n                         err!(DanglingPointerDeref)\n@@ -348,7 +348,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         self.tcx\n             .interpret_interner\n             .borrow()\n-            .get_fn(ptr.alloc_id.0)\n+            .get_fn(ptr.alloc_id)\n             .ok_or(EvalErrorKind::ExecuteMemory.into())\n     }\n \n@@ -372,21 +372,21 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n             let (alloc, immutable) =\n                 // normal alloc?\n-                match self.alloc_map.get(&id.0) {\n-                    Some(a) => (a, match self.alloc_kind[&id.0] {\n+                match self.alloc_map.get(&id) {\n+                    Some(a) => (a, match self.alloc_kind[&id] {\n                         MemoryKind::Stack => \" (stack)\".to_owned(),\n                         MemoryKind::Machine(m) => format!(\" ({:?})\", m),\n                         MemoryKind::MutableStatic => \" (static mut)\".to_owned(),\n                     }),\n                     // uninitialized static alloc?\n-                    None => match self.uninitialized_statics.get(&id.0) {\n+                    None => match self.uninitialized_statics.get(&id) {\n                         Some(a) => (a, \" (static in the process of initialization)\".to_owned()),\n                         None => {\n                             let int = self.tcx.interpret_interner.borrow();\n                             // static alloc?\n-                            match int.get_alloc(id.0) {\n+                            match int.get_alloc(id) {\n                                 Some(a) => (a, \"(immutable)\".to_owned()),\n-                                None => if let Some(func) = int.get_fn(id.0) {\n+                                None => if let Some(func) = int.get_fn(id) {\n                                     trace!(\"{} {}\", msg, func);\n                     continue;\n                                 } else {\n@@ -445,7 +445,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         let leaks: Vec<_> = self.alloc_map\n             .keys()\n             .filter_map(|key| if kinds[key] != MemoryKind::MutableStatic {\n-                Some(AllocId(*key))\n+                Some(*key)\n             } else {\n                 None\n             })\n@@ -528,7 +528,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         alloc: AllocId,\n         mutability: Mutability,\n     ) -> EvalResult<'tcx> {\n-        match self.alloc_kind.get(&alloc.0) {\n+        match self.alloc_kind.get(&alloc) {\n             // do not go into immutable statics\n             None |\n             // or mutable statics\n@@ -550,13 +550,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             mutability\n         );\n         if mutability == Mutability::Immutable {\n-            let alloc = self.alloc_map.remove(&alloc_id.0);\n-            let kind = self.alloc_kind.remove(&alloc_id.0);\n+            let alloc = self.alloc_map.remove(&alloc_id);\n+            let kind = self.alloc_kind.remove(&alloc_id);\n             assert_ne!(kind, Some(MemoryKind::MutableStatic));\n-            let uninit = self.uninitialized_statics.remove(&alloc_id.0);\n+            let uninit = self.uninitialized_statics.remove(&alloc_id);\n             if let Some(alloc) = alloc.or(uninit) {\n                 let alloc = self.tcx.intern_const_alloc(alloc);\n-                self.tcx.interpret_interner.borrow_mut().intern_at_reserved(alloc_id.0, alloc);\n+                self.tcx.interpret_interner.borrow_mut().intern_at_reserved(alloc_id, alloc);\n                 // recurse into inner allocations\n                 for &alloc in alloc.relocations.values() {\n                     self.mark_inner_allocation_initialized(alloc, mutability)?;\n@@ -565,17 +565,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             return Ok(());\n         }\n         // We are marking the static as initialized, so move it out of the uninit map\n-        if let Some(uninit) = self.uninitialized_statics.remove(&alloc_id.0) {\n-            self.alloc_map.insert(alloc_id.0, uninit);\n+        if let Some(uninit) = self.uninitialized_statics.remove(&alloc_id) {\n+            self.alloc_map.insert(alloc_id, uninit);\n         }\n         // do not use `self.get_mut(alloc_id)` here, because we might have already marked a\n         // sub-element or have circular pointers (e.g. `Rc`-cycles)\n-        let relocations = match self.alloc_map.get_mut(&alloc_id.0) {\n+        let relocations = match self.alloc_map.get_mut(&alloc_id) {\n             Some(&mut Allocation {\n                      ref mut relocations,\n                      ..\n                  }) => {\n-                match self.alloc_kind.get(&alloc_id.0) {\n+                match self.alloc_kind.get(&alloc_id) {\n                     // const eval results can refer to \"locals\".\n                     // E.g. `const Foo: &u32 = &1;` refers to the temp local that stores the `1`\n                     None |\n@@ -587,7 +587,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                     },\n                 }\n                 // overwrite or insert\n-                self.alloc_kind.insert(alloc_id.0, MemoryKind::MutableStatic);\n+                self.alloc_kind.insert(alloc_id, MemoryKind::MutableStatic);\n                 // take out the relocations vector to free the borrow on self, so we can call\n                 // mark recursively\n                 mem::replace(relocations, Default::default())\n@@ -600,7 +600,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n         // put back the relocations\n         self.alloc_map\n-            .get_mut(&alloc_id.0)\n+            .get_mut(&alloc_id)\n             .expect(\"checked above\")\n             .relocations = relocations;\n         Ok(())"}, {"sha": "ac16118c7afd70d72ac311a8a9fa50948413d3f8", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=0907494ae1b310da5708d61a5ca4f20033dcc86a", "patch": "@@ -194,8 +194,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     promoted: None,\n                 };\n                 let layout = self.layout_of(self.place_ty(mir_place))?;\n+                let alloc = self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"uncached global\");\n                 Place::Ptr {\n-                    ptr: self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"uncached global\"),\n+                    ptr: MemoryPointer::new(alloc, 0).into(),\n                     align: layout.align,\n                     extra: PlaceExtra::None,\n                 }"}, {"sha": "2b0f9041d511573e2ba4662aee5e5acb5c84ecfb", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0907494ae1b310da5708d61a5ca4f20033dcc86a/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=0907494ae1b310da5708d61a5ca4f20033dcc86a", "patch": "@@ -180,7 +180,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             layout.align,\n             None,\n         )?;\n-        self.tcx.interpret_interner.borrow_mut().cache(cid, ptr.into());\n+        self.tcx.interpret_interner.borrow_mut().cache(cid, ptr.alloc_id);\n         let internally_mutable = !layout.ty.is_freeze(self.tcx, self.param_env, span);\n         let mutability = if mutability == Mutability::Mutable || internally_mutable {\n             Mutability::Mutable\n@@ -265,7 +265,7 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n                         layout.align,\n                         None,\n                     )?;\n-                    this.ecx.tcx.interpret_interner.borrow_mut().cache(cid, ptr.into());\n+                    this.ecx.tcx.interpret_interner.borrow_mut().cache(cid, ptr.alloc_id);\n                     trace!(\"pushing stack frame for {:?}\", index);\n                     this.ecx.push_stack_frame(\n                         this.instance,"}]}