{"sha": "3583f2758b438a9274b6b7f00bf4e586058e55d9", "node_id": "C_kwDOAAsO6NoAKDM1ODNmMjc1OGI0MzhhOTI3NGI2YjdmMDBiZjRlNTg2MDU4ZTU1ZDk", "commit": {"author": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2022-11-03T18:52:08Z"}, "committer": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2022-11-03T18:52:16Z"}, "message": "Cleanups", "tree": {"sha": "c46e92a7acce33a9f6724276375d12b90d939770", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c46e92a7acce33a9f6724276375d12b90d939770"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3583f2758b438a9274b6b7f00bf4e586058e55d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3583f2758b438a9274b6b7f00bf4e586058e55d9", "html_url": "https://github.com/rust-lang/rust/commit/3583f2758b438a9274b6b7f00bf4e586058e55d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3583f2758b438a9274b6b7f00bf4e586058e55d9/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "160b19429523ea44c4c3b7cad4233b2a35f58b8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/160b19429523ea44c4c3b7cad4233b2a35f58b8f", "html_url": "https://github.com/rust-lang/rust/commit/160b19429523ea44c4c3b7cad4233b2a35f58b8f"}], "stats": {"total": 157, "additions": 56, "deletions": 101}, "files": [{"sha": "2c7b3bbf31c201531459586effe51e2cfab70725", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3583f2758b438a9274b6b7f00bf4e586058e55d9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3583f2758b438a9274b6b7f00bf4e586058e55d9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=3583f2758b438a9274b6b7f00bf4e586058e55d9", "patch": "@@ -55,8 +55,7 @@ pub enum MethodError<'tcx> {\n     // not-in-scope traits which may work.\n     PrivateMatch(DefKind, DefId, Vec<DefId>),\n \n-    // Found a `Self: Sized` bound where `Self` is a trait object, also the caller may have\n-    // forgotten to import a trait.\n+    // Found a `Self: Sized` bound where `Self` is a trait object.\n     IllegalSizedBound(Vec<DefId>, bool, Span),\n \n     // Found a match, but the return type is wrong"}, {"sha": "e88701685bc6d47a5451a25e7a9d7733d4506988", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3583f2758b438a9274b6b7f00bf4e586058e55d9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3583f2758b438a9274b6b7f00bf4e586058e55d9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=3583f2758b438a9274b6b7f00bf4e586058e55d9", "patch": "@@ -1019,7 +1019,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         let out_of_scope_traits = match self.pick_core() {\n             Some(Ok(p)) => vec![p.item.container_id(self.tcx)],\n-            //Some(Ok(p)) => p.iter().map(|p| p.item.container().id()).collect(),\n             Some(Err(MethodError::Ambiguity(v))) => v\n                 .into_iter()\n                 .map(|source| match source {"}, {"sha": "04ecd2757b427d3aa9e9cc97a2301fd5d6c5ebc7", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 39, "deletions": 97, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/3583f2758b438a9274b6b7f00bf4e586058e55d9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3583f2758b438a9274b6b7f00bf4e586058e55d9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=3583f2758b438a9274b6b7f00bf4e586058e55d9", "patch": "@@ -248,7 +248,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         match error {\n             MethodError::NoMatch(NoMatchData {\n-                static_candidates: mut static_sources,\n+                mut static_candidates,\n                 unsatisfied_predicates,\n                 out_of_scope_traits,\n                 lev_candidate,\n@@ -288,9 +288,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if generics.len() > 0 {\n                         let mut autoderef = self.autoderef(span, actual);\n                         let candidate_found = autoderef.any(|(ty, _)| {\n-                            if let ty::Adt(adt_deref, _) = ty.kind() {\n+                            if let ty::Adt(adt_def, _) = ty.kind() {\n                                 self.tcx\n-                                    .inherent_impls(adt_deref.did())\n+                                    .inherent_impls(adt_def.did())\n                                     .iter()\n                                     .filter_map(|def_id| self.associated_value(*def_id, item_name))\n                                     .count()\n@@ -348,15 +348,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n \n                 let ty_span = match actual.kind() {\n-                    ty::Param(param_type) => {\n-                        let generics = self.tcx.generics_of(self.body_id.owner.to_def_id());\n-                        let type_param = generics.type_param(param_type, self.tcx);\n-                        Some(self.tcx.def_span(type_param.def_id))\n-                    }\n+                    ty::Param(param_type) => Some(\n+                        param_type.span_from_generics(self.tcx, self.body_id.owner.to_def_id()),\n+                    ),\n                     ty::Adt(def, _) if def.did().is_local() => Some(tcx.def_span(def.did())),\n                     _ => None,\n                 };\n-\n                 if let Some(span) = ty_span {\n                     err.span_label(\n                         span,\n@@ -386,17 +383,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 let mut custom_span_label = false;\n \n-                if !static_sources.is_empty() {\n+                if !static_candidates.is_empty() {\n                     err.note(\n                         \"found the following associated functions; to be used as methods, \\\n                          functions must have a `self` parameter\",\n                     );\n                     err.span_label(span, \"this is an associated function, not a method\");\n                     custom_span_label = true;\n                 }\n-                if static_sources.len() == 1 {\n+                if static_candidates.len() == 1 {\n                     let ty_str =\n-                        if let Some(CandidateSource::Impl(impl_did)) = static_sources.get(0) {\n+                        if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0) {\n                             // When the \"method\" is resolved through dereferencing, we really want the\n                             // original type that has the associated function for accurate suggestions.\n                             // (#61411)\n@@ -422,9 +419,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         err.help(&format!(\"try with `{}::{}`\", ty_str, item_name,));\n                     }\n \n-                    report_candidates(span, &mut err, &mut static_sources, sugg_span);\n-                } else if static_sources.len() > 1 {\n-                    report_candidates(span, &mut err, &mut static_sources, sugg_span);\n+                    report_candidates(span, &mut err, &mut static_candidates, sugg_span);\n+                } else if static_candidates.len() > 1 {\n+                    report_candidates(span, &mut err, &mut static_candidates, sugg_span);\n                 }\n \n                 let mut bound_spans = vec![];\n@@ -496,24 +493,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             if let (ty::Param(_), ty::PredicateKind::Trait(p)) =\n                                 (self_ty.kind(), parent_pred.kind().skip_binder())\n                             {\n+                                let hir = self.tcx.hir();\n                                 let node = match p.trait_ref.self_ty().kind() {\n                                     ty::Param(_) => {\n                                         // Account for `fn` items like in `issue-35677.rs` to\n                                         // suggest restricting its type params.\n-                                        let did = self.tcx.hir().body_owner_def_id(hir::BodyId {\n-                                            hir_id: self.body_id,\n-                                        });\n-                                        Some(\n-                                            self.tcx\n-                                                .hir()\n-                                                .get(self.tcx.hir().local_def_id_to_hir_id(did)),\n-                                        )\n+                                        let parent_body =\n+                                            hir.body_owner(hir::BodyId { hir_id: self.body_id });\n+                                        Some(hir.get(parent_body))\n+                                    }\n+                                    ty::Adt(def, _) => {\n+                                        def.did().as_local().map(|def_id| hir.get_by_def_id(def_id))\n                                     }\n-                                    ty::Adt(def, _) => def.did().as_local().map(|def_id| {\n-                                        self.tcx\n-                                            .hir()\n-                                            .get(self.tcx.hir().local_def_id_to_hir_id(def_id))\n-                                    }),\n                                     _ => None,\n                                 };\n                                 if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n@@ -605,7 +596,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .iter()\n                         .filter_map(|(p, parent, c)| c.as_ref().map(|c| (p, parent, c)))\n                         .filter_map(|(p, parent, c)| match c.code() {\n-                            ObligationCauseCode::ImplDerivedObligation(ref data) => {\n+                            ObligationCauseCode::ImplDerivedObligation(data) => {\n                                 Some((&data.derived, p, parent, data.impl_def_id, data))\n                             }\n                             _ => None,\n@@ -620,22 +611,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         match self.tcx.hir().get_if_local(impl_def_id) {\n                             // Unmet obligation comes from a `derive` macro, point at it once to\n                             // avoid multiple span labels pointing at the same place.\n-                            Some(Node::Item(hir::Item {\n-                                kind: hir::ItemKind::Trait(..),\n-                                ident,\n-                                ..\n-                            })) if matches!(\n-                                ident.span.ctxt().outer_expn_data().kind,\n-                                ExpnKind::Macro(MacroKind::Derive, _)\n-                            ) =>\n-                            {\n-                                let span = ident.span.ctxt().outer_expn_data().call_site;\n-                                let mut spans: MultiSpan = span.into();\n-                                spans.push_span_label(span, derive_msg);\n-                                let entry = spanned_predicates.entry(spans);\n-                                entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n-                            }\n-\n                             Some(Node::Item(hir::Item {\n                                 kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, .. }),\n                                 ..\n@@ -659,34 +634,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n                             }\n \n-                            // Unmet obligation coming from a `trait`.\n-                            Some(Node::Item(hir::Item {\n-                                kind: hir::ItemKind::Trait(..),\n-                                ident,\n-                                span: item_span,\n-                                ..\n-                            })) if !matches!(\n-                                ident.span.ctxt().outer_expn_data().kind,\n-                                ExpnKind::Macro(MacroKind::Derive, _)\n-                            ) =>\n-                            {\n-                                if let Some(pred) = parent_p {\n-                                    // Done to add the \"doesn't satisfy\" `span_label`.\n-                                    let _ = format_pred(*pred);\n-                                }\n-                                skip_list.insert(p);\n-                                let mut spans = if cause.span != *item_span {\n-                                    let mut spans: MultiSpan = cause.span.into();\n-                                    spans.push_span_label(cause.span, unsatisfied_msg);\n-                                    spans\n-                                } else {\n-                                    ident.span.into()\n-                                };\n-                                spans.push_span_label(ident.span, \"in this trait\");\n-                                let entry = spanned_predicates.entry(spans);\n-                                entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n-                            }\n-\n                             // Unmet obligation coming from an `impl`.\n                             Some(Node::Item(hir::Item {\n                                 kind:\n@@ -695,19 +642,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     }),\n                                 span: item_span,\n                                 ..\n-                            })) if !matches!(\n-                                self_ty.span.ctxt().outer_expn_data().kind,\n-                                ExpnKind::Macro(MacroKind::Derive, _)\n-                            ) && !matches!(\n-                                of_trait.as_ref().map(|t| t\n-                                    .path\n-                                    .span\n-                                    .ctxt()\n-                                    .outer_expn_data()\n-                                    .kind),\n-                                Some(ExpnKind::Macro(MacroKind::Derive, _))\n-                            ) =>\n-                            {\n+                            })) => {\n                                 let sized_pred =\n                                     unsatisfied_predicates.iter().any(|(pred, _, _)| {\n                                         match pred.kind().skip_binder() {\n@@ -759,7 +694,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let entry = spanned_predicates.entry(spans);\n                                 entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n                             }\n-                            _ => {}\n+                            Some(_) => unreachable!(),\n+                            None => (),\n                         }\n                     }\n                     let mut spanned_predicates: Vec<_> = spanned_predicates.into_iter().collect();\n@@ -863,7 +799,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             .on_unimplemented_note(trait_ref, &obligation);\n                                         (message, label)\n                                     })\n-                                    .unwrap_or((None, None))\n+                                    .unwrap()\n                             } else {\n                                 (None, None)\n                             };\n@@ -972,7 +908,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // If the method name is the name of a field with a function or closure type,\n                 // give a helping note that it has to be called as `(x.f)(...)`.\n                 if let SelfSource::MethodCall(expr) = source {\n-                    if !self.suggest_field_call(span, rcvr_ty, expr, item_name, &mut err)\n+                    if !self.suggest_calling_field_as_fn(span, rcvr_ty, expr, item_name, &mut err)\n                         && lev_candidate.is_none()\n                         && !custom_span_label\n                     {\n@@ -982,10 +918,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     label_span_not_found(&mut err);\n                 }\n \n-                // Don't suggest (for example) `expr.field.method()` if `expr.method()`\n-                // doesn't exist due to unsatisfied predicates.\n+                // Don't suggest (for example) `expr.field.clone()` if `expr.clone()`\n+                // can't be called due to `typeof(expr): Clone` not holding.\n                 if unsatisfied_predicates.is_empty() {\n-                    self.check_for_field_method(&mut err, source, span, actual, item_name);\n+                    self.suggest_calling_method_on_field(&mut err, source, span, actual, item_name);\n                 }\n \n                 self.check_for_inner_self(&mut err, source, span, actual, item_name);\n@@ -1007,7 +943,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         source,\n                         out_of_scope_traits,\n                         &unsatisfied_predicates,\n-                        &static_sources,\n+                        &static_candidates,\n                         unsatisfied_bounds,\n                     );\n                 }\n@@ -1146,7 +1082,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         None\n     }\n \n-    fn suggest_field_call(\n+    /// Suggest calling a field with a type that implements the `Fn*` traits instead of a method with\n+    /// the same name as the field i.e. `(a.my_fn_ptr)(10)` instead of `a.my_fn_ptr(10)`.\n+    fn suggest_calling_field_as_fn(\n         &self,\n         span: Span,\n         rcvr_ty: Ty<'tcx>,\n@@ -1408,7 +1346,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n-    fn check_for_field_method(\n+    /// Suggest calling a method on a field i.e. `a.field.bar()` instead of `a.bar()`\n+    fn suggest_calling_method_on_field(\n         &self,\n         err: &mut Diagnostic,\n         source: SelfSource<'tcx>,\n@@ -2021,7 +1960,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         let mut alt_rcvr_sugg = false;\n         if let (SelfSource::MethodCall(rcvr), false) = (source, unsatisfied_bounds) {\n-            debug!(?span, ?item_name, ?rcvr_ty, ?rcvr);\n+            debug!(\n+                \"suggest_traits_to_import: span={:?}, item_name={:?}, rcvr_ty={:?}, rcvr={:?}\",\n+                span, item_name, rcvr_ty, rcvr\n+            );\n             let skippable = [\n                 self.tcx.lang_items().clone_trait(),\n                 self.tcx.lang_items().deref_trait(),\n@@ -2060,7 +2002,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // suggestions are generally misleading (see #94218).\n                         break;\n                     }\n-                    _ => {}\n+                    Err(_) => (),\n                 }\n \n                 for (rcvr_ty, pre) in &["}, {"sha": "07ee758b32c1fc6cd0bfb93d87bcfd1120577f2e", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3583f2758b438a9274b6b7f00bf4e586058e55d9/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3583f2758b438a9274b6b7f00bf4e586058e55d9/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=3583f2758b438a9274b6b7f00bf4e586058e55d9", "patch": "@@ -203,13 +203,20 @@ pub struct UnifyReceiverContext<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, Default)]\n+#[derive(Clone, PartialEq, Eq, Hash, Lift, Default)]\n pub struct InternedObligationCauseCode<'tcx> {\n     /// `None` for `ObligationCauseCode::MiscObligation` (a common case, occurs ~60% of\n     /// the time). `Some` otherwise.\n     code: Option<Lrc<ObligationCauseCode<'tcx>>>,\n }\n \n+impl<'tcx> std::fmt::Debug for InternedObligationCauseCode<'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        let cause: &ObligationCauseCode<'_> = self;\n+        cause.fmt(f)\n+    }\n+}\n+\n impl<'tcx> ObligationCauseCode<'tcx> {\n     #[inline(always)]\n     fn into(self) -> InternedObligationCauseCode<'tcx> {"}, {"sha": "5f108bf0ef30644a1849beab3e4bb6838a7f2d82", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3583f2758b438a9274b6b7f00bf4e586058e55d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3583f2758b438a9274b6b7f00bf4e586058e55d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=3583f2758b438a9274b6b7f00bf4e586058e55d9", "patch": "@@ -20,6 +20,7 @@ use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable;\n use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi;\n use std::borrow::Cow;\n@@ -1282,6 +1283,12 @@ impl<'tcx> ParamTy {\n     pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         tcx.mk_ty_param(self.index, self.name)\n     }\n+\n+    pub fn span_from_generics(&self, tcx: TyCtxt<'tcx>, item_with_generics: DefId) -> Span {\n+        let generics = tcx.generics_of(item_with_generics);\n+        let type_param = generics.type_param(self, tcx);\n+        tcx.def_span(type_param.def_id)\n+    }\n }\n \n #[derive(Copy, Clone, Hash, TyEncodable, TyDecodable, Eq, PartialEq, Ord, PartialOrd)]"}, {"sha": "fb062ea71c4ce775bf6c74cf4c153dde6a74a1f3", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3583f2758b438a9274b6b7f00bf4e586058e55d9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3583f2758b438a9274b6b7f00bf4e586058e55d9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=3583f2758b438a9274b6b7f00bf4e586058e55d9", "patch": "@@ -27,6 +27,7 @@ pub struct OnUnimplementedDirective {\n }\n \n #[derive(Default)]\n+/// For the `#[rustc_on_unimplemented]` attribute\n pub struct OnUnimplementedNote {\n     pub message: Option<String>,\n     pub label: Option<String>,"}]}