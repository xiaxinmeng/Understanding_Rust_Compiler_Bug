{"sha": "211d1e073527915f7ce1854ad8b30dc0c45845e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMWQxZTA3MzUyNzkxNWY3Y2UxODU0YWQ4YjMwZGMwYzQ1ODQ1ZTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-17T01:04:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-17T01:04:36Z"}, "message": "Auto merge of #63648 - Centril:rollup-2kpdrj1, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #63149 (resolve: Populate external modules in more automatic and lazy way)\n - #63545 (Feature gate 'yield $expr?' pre-expansion)\n - #63548 (Update rustc-demangle to 0.1.16.)\n - #63558 (Remap paths for proc-macro crates.)\n - #63641 (add git keyword to submodule comments in config.example.toml)\n - #63642 (Rename overflowing_{add,sub,mul} intrinsics to wrapping_{add,sub,mul}.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "b0f6d090762cc3f19f2217afec4bba476b2e663a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0f6d090762cc3f19f2217afec4bba476b2e663a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/211d1e073527915f7ce1854ad8b30dc0c45845e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/211d1e073527915f7ce1854ad8b30dc0c45845e8", "html_url": "https://github.com/rust-lang/rust/commit/211d1e073527915f7ce1854ad8b30dc0c45845e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/211d1e073527915f7ce1854ad8b30dc0c45845e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdfd698f37184da42254a03ed466ab1f90e6fb6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdfd698f37184da42254a03ed466ab1f90e6fb6c", "html_url": "https://github.com/rust-lang/rust/commit/bdfd698f37184da42254a03ed466ab1f90e6fb6c"}, {"sha": "e8fb78bf6c120470d2134e92c26f22c1b8a75187", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8fb78bf6c120470d2134e92c26f22c1b8a75187", "html_url": "https://github.com/rust-lang/rust/commit/e8fb78bf6c120470d2134e92c26f22c1b8a75187"}], "stats": {"total": 478, "additions": 271, "deletions": 207}, "files": [{"sha": "c784246ba396ec46a75c54b5b773dc9022c6a603", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -106,7 +106,7 @@ dependencies = [\n  \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.60 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-core 1.0.0\",\n ]\n \n@@ -2729,7 +2729,7 @@ dependencies = [\n \n [[package]]\n name = \"rustc-demangle\"\n-version = \"0.1.15\"\n+version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2887,7 +2887,7 @@ dependencies = [\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"punycode 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n  \"rustc_target 0.0.0\",\n@@ -4592,7 +4592,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rustc-ap-serialize 546.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"61673783f2089e01033ffa82d1988f55175402071b31253a358292e1624d4602\"\n \"checksum rustc-ap-syntax 546.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"28f3dd1346d5b0269c07a4a78855e309a298ab569c9c1302d4d4f57f8eee4e84\"\n \"checksum rustc-ap-syntax_pos 546.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"45e67b526dbda3a0c7dab91c8947d43685e7697f52686a4949da3c179cd7c979\"\n-\"checksum rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a7f4dccf6f4891ebcc0c39f9b6eb1a83b9bf5d747cb439ec6fba4f3b977038af\"\n+\"checksum rustc-demangle 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c691c0e608126e00913e33f0ccf3727d5fc84573623b8d65b2df340b5201783\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d2e07e19601f21c59aad953c2632172ba70cb27e685771514ea66e4062b3363\"\n \"checksum rustc-rayon-core 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"79d38ca7cbc22fa59f09d8534ea4b27f67b0facf0cbe274433aceea227a02543\""}, {"sha": "a3ec4f2044cbd720fe469e89d744d0294a6f42cd", "filename": "config.toml.example", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -141,10 +141,10 @@\n # library and facade crates.\n #compiler-docs = false\n \n-# Indicate whether submodules are managed and updated automatically.\n+# Indicate whether git submodules are managed and updated automatically.\n #submodules = true\n \n-# Update submodules only when the checked out commit in the submodules differs\n+# Update git submodules only when the checked out commit in the submodules differs\n # from what is committed in the main rustc repo.\n #fast-submodules = true\n "}, {"sha": "da372781738d66e7a2ecf94c10ce618b214d8ecb", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -102,8 +102,13 @@ fn main() {\n     // FIXME: the fact that core here is excluded is due to core_arch from our stdarch submodule\n     // being broken on the beta compiler with bootstrap passed, so this is a temporary workaround\n     // (we've just snapped, so there are no cfg(bootstrap) related annotations in core).\n-    if stage == \"0\" && crate_name != Some(\"core\") {\n-        cmd.arg(\"--cfg\").arg(\"bootstrap\");\n+    if stage == \"0\" {\n+        if crate_name != Some(\"core\") {\n+            cmd.arg(\"--cfg\").arg(\"bootstrap\");\n+        } else {\n+            // NOTE(eddyb) see FIXME above, except now we need annotations again in core.\n+            cmd.arg(\"--cfg\").arg(\"boostrap_stdarch_ignore_this\");\n+        }\n     }\n \n     // Print backtrace in case of ICE\n@@ -276,10 +281,6 @@ fn main() {\n                 cmd.arg(\"-C\").arg(\"target-feature=-crt-static\");\n             }\n         }\n-\n-        if let Ok(map) = env::var(\"RUSTC_DEBUGINFO_MAP\") {\n-            cmd.arg(\"--remap-path-prefix\").arg(&map);\n-        }\n     } else {\n         // Override linker if necessary.\n         if let Ok(host_linker) = env::var(\"RUSTC_HOST_LINKER\") {\n@@ -296,6 +297,10 @@ fn main() {\n         }\n     }\n \n+    if let Ok(map) = env::var(\"RUSTC_DEBUGINFO_MAP\") {\n+        cmd.arg(\"--remap-path-prefix\").arg(&map);\n+    }\n+\n     // Force all crates compiled by this compiler to (a) be unstable and (b)\n     // allow the `rustc_private` feature to link to other unstable crates\n     // also in the sysroot. We also do this for host crates, since those"}, {"sha": "d145f2212f93a639e2c4ab50dff24b5b6b64ef57", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -1293,18 +1293,40 @@ extern \"rust-intrinsic\" {\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_add` method. For example,\n     /// [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n+    #[cfg(boostrap_stdarch_ignore_this)]\n     pub fn overflowing_add<T>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_sub` method. For example,\n     /// [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n+    #[cfg(boostrap_stdarch_ignore_this)]\n     pub fn overflowing_sub<T>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_mul` method. For example,\n     /// [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)\n+    #[cfg(boostrap_stdarch_ignore_this)]\n     pub fn overflowing_mul<T>(a: T, b: T) -> T;\n \n+    /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `wrapping_add` method. For example,\n+    /// [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n+    #[cfg(not(boostrap_stdarch_ignore_this))]\n+    pub fn wrapping_add<T>(a: T, b: T) -> T;\n+    /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `wrapping_sub` method. For example,\n+    /// [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n+    #[cfg(not(boostrap_stdarch_ignore_this))]\n+    pub fn wrapping_sub<T>(a: T, b: T) -> T;\n+    /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `wrapping_mul` method. For example,\n+    /// [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)\n+    #[cfg(not(boostrap_stdarch_ignore_this))]\n+    pub fn wrapping_mul<T>(a: T, b: T) -> T;\n+\n     /// Computes `a + b`, while saturating at numeric bounds.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_add` method. For example,"}, {"sha": "b46e06f8d8ada93b5c8089cef11cfa14dac22e71", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -1112,7 +1112,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_add(self, rhs: Self) -> Self {\n-                intrinsics::overflowing_add(self, rhs)\n+                #[cfg(boostrap_stdarch_ignore_this)] {\n+                    intrinsics::overflowing_add(self, rhs)\n+                }\n+\n+                #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                    intrinsics::wrapping_add(self, rhs)\n+                }\n             }\n         }\n \n@@ -1135,7 +1141,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_sub(self, rhs: Self) -> Self {\n-                intrinsics::overflowing_sub(self, rhs)\n+                #[cfg(boostrap_stdarch_ignore_this)] {\n+                    intrinsics::overflowing_sub(self, rhs)\n+                }\n+\n+                #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                    intrinsics::wrapping_sub(self, rhs)\n+                }\n             }\n         }\n \n@@ -1157,7 +1169,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_mul(self, rhs: Self) -> Self {\n-                intrinsics::overflowing_mul(self, rhs)\n+                #[cfg(boostrap_stdarch_ignore_this)] {\n+                    intrinsics::overflowing_mul(self, rhs)\n+                }\n+\n+                #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                    intrinsics::wrapping_mul(self, rhs)\n+                }\n             }\n         }\n \n@@ -3031,7 +3049,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_add(self, rhs: Self) -> Self {\n-                intrinsics::overflowing_add(self, rhs)\n+                #[cfg(boostrap_stdarch_ignore_this)] {\n+                    intrinsics::overflowing_add(self, rhs)\n+                }\n+\n+                #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                    intrinsics::wrapping_add(self, rhs)\n+                }\n             }\n         }\n \n@@ -3053,7 +3077,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_sub(self, rhs: Self) -> Self {\n-                intrinsics::overflowing_sub(self, rhs)\n+                #[cfg(boostrap_stdarch_ignore_this)] {\n+                    intrinsics::overflowing_sub(self, rhs)\n+                }\n+\n+                #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                    intrinsics::wrapping_sub(self, rhs)\n+                }\n             }\n         }\n \n@@ -3076,7 +3106,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n         #[inline]\n         pub const fn wrapping_mul(self, rhs: Self) -> Self {\n-            intrinsics::overflowing_mul(self, rhs)\n+            #[cfg(boostrap_stdarch_ignore_this)] {\n+                intrinsics::overflowing_mul(self, rhs)\n+            }\n+\n+            #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                intrinsics::wrapping_mul(self, rhs)\n+            }\n         }\n \n         doc_comment! {"}, {"sha": "9483ffca448e3daec91450dee6055194490874a4", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -328,7 +328,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             },\n             \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n             \"bitreverse\" | \"add_with_overflow\" | \"sub_with_overflow\" |\n-            \"mul_with_overflow\" | \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n+            \"mul_with_overflow\" | \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" |\n             \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" |\n             \"unchecked_add\" | \"unchecked_sub\" | \"unchecked_mul\" | \"exact_div\" |\n             \"rotate_left\" | \"rotate_right\" | \"saturating_add\" | \"saturating_sub\" => {\n@@ -398,9 +398,9 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n                                 return;\n                             },\n-                            \"overflowing_add\" => self.add(args[0].immediate(), args[1].immediate()),\n-                            \"overflowing_sub\" => self.sub(args[0].immediate(), args[1].immediate()),\n-                            \"overflowing_mul\" => self.mul(args[0].immediate(), args[1].immediate()),\n+                            \"wrapping_add\" => self.add(args[0].immediate(), args[1].immediate()),\n+                            \"wrapping_sub\" => self.sub(args[0].immediate(), args[1].immediate()),\n+                            \"wrapping_mul\" => self.mul(args[0].immediate(), args[1].immediate()),\n                             \"exact_div\" =>\n                                 if signed {\n                                     self.exactsdiv(args[0].immediate(), args[1].immediate())"}, {"sha": "89b50c5daccaeac6d1b81184e1fa94c03b50d8a1", "filename": "src/librustc_codegen_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_codegen_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_codegen_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2FCargo.toml?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -13,7 +13,7 @@ test = false\n flate2 = \"1.0\"\n log = \"0.4\"\n punycode = \"0.4.0\"\n-rustc-demangle = \"0.1.15\"\n+rustc-demangle = \"0.1.16\"\n \n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "ee105fed1a324aadf7dd68ccbf33cc5f25623071", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -110,18 +110,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 self.write_scalar(out_val, dest)?;\n             }\n-            | \"overflowing_add\"\n-            | \"overflowing_sub\"\n-            | \"overflowing_mul\"\n+            | \"wrapping_add\"\n+            | \"wrapping_sub\"\n+            | \"wrapping_mul\"\n             | \"add_with_overflow\"\n             | \"sub_with_overflow\"\n             | \"mul_with_overflow\" => {\n                 let lhs = self.read_immediate(args[0])?;\n                 let rhs = self.read_immediate(args[1])?;\n                 let (bin_op, ignore_overflow) = match intrinsic_name {\n-                    \"overflowing_add\" => (BinOp::Add, true),\n-                    \"overflowing_sub\" => (BinOp::Sub, true),\n-                    \"overflowing_mul\" => (BinOp::Mul, true),\n+                    \"wrapping_add\" => (BinOp::Add, true),\n+                    \"wrapping_sub\" => (BinOp::Sub, true),\n+                    \"wrapping_mul\" => (BinOp::Mul, true),\n                     \"add_with_overflow\" => (BinOp::Add, false),\n                     \"sub_with_overflow\" => (BinOp::Sub, false),\n                     \"mul_with_overflow\" => (BinOp::Mul, false),"}, {"sha": "649cccc36c346e88c9542912250db9762bdd9c02", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -537,9 +537,9 @@ impl Qualif for IsNotPromotable {\n                             | \"cttz_nonzero\"\n                             | \"ctlz\"\n                             | \"ctlz_nonzero\"\n-                            | \"overflowing_add\"\n-                            | \"overflowing_sub\"\n-                            | \"overflowing_mul\"\n+                            | \"wrapping_add\"\n+                            | \"wrapping_sub\"\n+                            | \"wrapping_mul\"\n                             | \"unchecked_shl\"\n                             | \"unchecked_shr\"\n                             | \"rotate_left\""}, {"sha": "334d0cee9fbe7412a7e401c9e8afbf963c151f61", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -379,9 +379,9 @@ fn is_intrinsic_whitelisted(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n         | \"add_with_overflow\" // ~> .overflowing_add\n         | \"sub_with_overflow\" // ~> .overflowing_sub\n         | \"mul_with_overflow\" // ~> .overflowing_mul\n-        | \"overflowing_add\" // ~> .wrapping_add\n-        | \"overflowing_sub\" // ~> .wrapping_sub\n-        | \"overflowing_mul\" // ~> .wrapping_mul\n+        | \"wrapping_add\" // ~> .wrapping_add\n+        | \"wrapping_sub\" // ~> .wrapping_sub\n+        | \"wrapping_mul\" // ~> .wrapping_mul\n         | \"saturating_add\" // ~> .saturating_add\n         | \"saturating_sub\" // ~> .saturating_sub\n         | \"unchecked_shl\" // ~> .wrapping_shl"}, {"sha": "1510d74babb6d8b17abe6213e2f4eb5a4f2385e1", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 53, "deletions": 66, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -16,6 +16,7 @@ use crate::{ResolutionError, Determinacy, PathResult, CrateLint};\n use rustc::bug;\n use rustc::hir::def::{self, *};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n+use rustc::hir::map::DefCollector;\n use rustc::ty;\n use rustc::middle::cstore::CrateStore;\n use rustc_metadata::cstore::LoadedMacro;\n@@ -159,33 +160,34 @@ impl<'a> Resolver<'a> {\n         Some(ext)\n     }\n \n-    /// Ensures that the reduced graph rooted at the given external module\n-    /// is built, building it if it is not.\n-    crate fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n-        if module.populated.get() { return }\n-        let def_id = module.def_id().unwrap();\n-        for child in self.cstore.item_children_untracked(def_id, self.session) {\n-            let child = child.map_id(|_| panic!(\"unexpected id\"));\n-            BuildReducedGraphVisitor { parent_scope: ParentScope::module(module), r: self }\n-                .build_reduced_graph_for_external_crate_res(child);\n-        }\n-        module.populated.set(true)\n-    }\n-\n     crate fn build_reduced_graph(\n         &mut self, fragment: &AstFragment, parent_scope: ParentScope<'a>\n     ) -> LegacyScope<'a> {\n+        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, parent_scope.expansion));\n         let mut visitor = BuildReducedGraphVisitor { r: self, parent_scope };\n         fragment.visit_with(&mut visitor);\n         visitor.parent_scope.legacy\n     }\n+\n+    crate fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n+        let def_id = module.def_id().expect(\"unpopulated module without a def-id\");\n+        for child in self.cstore.item_children_untracked(def_id, self.session) {\n+            let child = child.map_id(|_| panic!(\"unexpected id\"));\n+            BuildReducedGraphVisitor { r: self, parent_scope: ParentScope::module(module) }\n+                .build_reduced_graph_for_external_crate_res(child);\n+        }\n+    }\n }\n \n struct BuildReducedGraphVisitor<'a, 'b> {\n     r: &'b mut Resolver<'a>,\n     parent_scope: ParentScope<'a>,\n }\n \n+impl<'a> AsMut<Resolver<'a>> for BuildReducedGraphVisitor<'a, '_> {\n+    fn as_mut(&mut self) -> &mut Resolver<'a> { self.r }\n+}\n+\n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n         let parent_scope = &self.parent_scope;\n@@ -603,8 +605,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     self.r.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n                 };\n \n-                self.r.populate_module_if_necessary(module);\n-\n                 let used = self.process_legacy_macro_imports(item, module);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.r.arenas);\n@@ -879,80 +879,67 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         // This is only a guess, two equivalent idents may incorrectly get different gensyms here.\n         let ident = ident.gensym_if_underscore();\n         let expansion = ExpnId::root(); // FIXME(jseyfried) intercrate hygiene\n+        // Record primary definitions.\n         match res {\n             Res::Def(kind @ DefKind::Mod, def_id)\n-            | Res::Def(kind @ DefKind::Enum, def_id) => {\n+            | Res::Def(kind @ DefKind::Enum, def_id)\n+            | Res::Def(kind @ DefKind::Trait, def_id) => {\n                 let module = self.r.new_module(parent,\n                                              ModuleKind::Def(kind, def_id, ident.name),\n                                              def_id,\n                                              expansion,\n                                              span);\n                 self.r.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n             }\n-            Res::Def(DefKind::Variant, _)\n+            Res::Def(DefKind::Struct, _)\n+            | Res::Def(DefKind::Union, _)\n+            | Res::Def(DefKind::Variant, _)\n             | Res::Def(DefKind::TyAlias, _)\n             | Res::Def(DefKind::ForeignTy, _)\n             | Res::Def(DefKind::OpaqueTy, _)\n             | Res::Def(DefKind::TraitAlias, _)\n+            | Res::Def(DefKind::AssocTy, _)\n+            | Res::Def(DefKind::AssocOpaqueTy, _)\n             | Res::PrimTy(..)\n-            | Res::ToolMod => {\n-                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n-            }\n+            | Res::ToolMod =>\n+                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion)),\n             Res::Def(DefKind::Fn, _)\n+            | Res::Def(DefKind::Method, _)\n             | Res::Def(DefKind::Static, _)\n             | Res::Def(DefKind::Const, _)\n-            | Res::Def(DefKind::Ctor(CtorOf::Variant, ..), _) => {\n-                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n-            }\n-            Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n-                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n-\n-                if let Some(struct_def_id) =\n-                        self.r.cstore.def_key(def_id).parent\n-                            .map(|index| DefId { krate: def_id.krate, index: index }) {\n-                    self.r.struct_constructors.insert(struct_def_id, (res, vis));\n-                }\n-            }\n-            Res::Def(DefKind::Trait, def_id) => {\n-                let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n-                let module = self.r.new_module(parent,\n-                                             module_kind,\n-                                             parent.normal_ancestor_id,\n-                                             expansion,\n-                                             span);\n-                self.r.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n-\n-                for child in self.r.cstore.item_children_untracked(def_id, self.r.session) {\n-                    let res = child.res.map_id(|_| panic!(\"unexpected id\"));\n-                    let ns = if let Res::Def(DefKind::AssocTy, _) = res {\n-                        TypeNS\n-                    } else { ValueNS };\n-                    self.r.define(module, child.ident, ns,\n-                                (res, ty::Visibility::Public, DUMMY_SP, expansion));\n-\n-                    if self.r.cstore.associated_item_cloned_untracked(child.res.def_id())\n-                           .method_has_self_argument {\n-                        self.r.has_self.insert(res.def_id());\n-                    }\n-                }\n-                module.populated.set(true);\n-            }\n+            | Res::Def(DefKind::AssocConst, _)\n+            | Res::Def(DefKind::Ctor(..), _) =>\n+                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion)),\n+            Res::Def(DefKind::Macro(..), _)\n+            | Res::NonMacroAttr(..) =>\n+                self.r.define(parent, ident, MacroNS, (res, vis, DUMMY_SP, expansion)),\n+            Res::Def(DefKind::TyParam, _) | Res::Def(DefKind::ConstParam, _)\n+            | Res::Local(..) | Res::SelfTy(..) | Res::SelfCtor(..) | Res::Err =>\n+                bug!(\"unexpected resolution: {:?}\", res)\n+        }\n+        // Record some extra data for better diagnostics.\n+        match res {\n             Res::Def(DefKind::Struct, def_id) | Res::Def(DefKind::Union, def_id) => {\n-                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n-\n-                // Record field names for error reporting.\n                 let field_names = self.r.cstore.struct_field_names_untracked(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n-            Res::Def(DefKind::Macro(..), _) | Res::NonMacroAttr(..) => {\n-                self.r.define(parent, ident, MacroNS, (res, vis, DUMMY_SP, expansion));\n+            Res::Def(DefKind::Method, def_id) => {\n+                if self.r.cstore.associated_item_cloned_untracked(def_id).method_has_self_argument {\n+                    self.r.has_self.insert(def_id);\n+                }\n+            }\n+            Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n+                let parent = self.r.cstore.def_key(def_id).parent;\n+                if let Some(struct_def_id) = parent.map(|index| DefId { index, ..def_id }) {\n+                    self.r.struct_constructors.insert(struct_def_id, (res, vis));\n+                }\n             }\n-            _ => bug!(\"unexpected resolution: {:?}\", res)\n+            _ => {}\n         }\n     }\n \n     fn legacy_import_macro(&mut self,\n-                           name: Name,\n+                           name: ast::Name,\n                            binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n@@ -1021,9 +1008,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         if let Some(span) = import_all {\n             let directive = macro_use_directive(self, span);\n             self.r.potentially_unused_imports.push(directive);\n-            module.for_each_child(|ident, ns, binding| if ns == MacroNS {\n-                let imported_binding = self.r.import(binding, directive);\n-                self.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n+            module.for_each_child(self, |this, ident, ns, binding| if ns == MacroNS {\n+                let imported_binding = this.r.import(binding, directive);\n+                this.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n             });\n         } else {\n             for ident in single_imports.iter().cloned() {"}, {"sha": "afdcec19d8ef6014f8a190bb8a742cf3c9df5ae8", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -73,20 +73,23 @@ crate fn add_typo_suggestion(\n     false\n }\n \n-crate fn add_module_candidates(\n-    module: Module<'_>, names: &mut Vec<TypoSuggestion>, filter_fn: &impl Fn(Res) -> bool\n-) {\n-    for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n-        if let Some(binding) = resolution.borrow().binding {\n-            let res = binding.res();\n-            if filter_fn(res) {\n-                names.push(TypoSuggestion::from_res(ident.name, res));\n+impl<'a> Resolver<'a> {\n+    crate fn add_module_candidates(\n+        &mut self,\n+        module: Module<'a>,\n+        names: &mut Vec<TypoSuggestion>,\n+        filter_fn: &impl Fn(Res) -> bool,\n+    ) {\n+        for (&(ident, _), resolution) in self.resolutions(module).borrow().iter() {\n+            if let Some(binding) = resolution.borrow().binding {\n+                let res = binding.res();\n+                if filter_fn(res) {\n+                    names.push(TypoSuggestion::from_res(ident.name, res));\n+                }\n             }\n         }\n     }\n-}\n \n-impl<'a> Resolver<'a> {\n     /// Combines an error with provided span and emits it.\n     ///\n     /// This takes the error provided, combines it with the span and any additional spans inside the\n@@ -402,10 +405,10 @@ impl<'a> Resolver<'a> {\n                 Scope::CrateRoot => {\n                     let root_ident = Ident::new(kw::PathRoot, ident.span);\n                     let root_module = this.resolve_crate_root(root_ident);\n-                    add_module_candidates(root_module, &mut suggestions, filter_fn);\n+                    this.add_module_candidates(root_module, &mut suggestions, filter_fn);\n                 }\n                 Scope::Module(module) => {\n-                    add_module_candidates(module, &mut suggestions, filter_fn);\n+                    this.add_module_candidates(module, &mut suggestions, filter_fn);\n                 }\n                 Scope::MacroUsePrelude => {\n                     suggestions.extend(this.macro_use_prelude.iter().filter_map(|(name, binding)| {\n@@ -453,7 +456,7 @@ impl<'a> Resolver<'a> {\n                 Scope::StdLibPrelude => {\n                     if let Some(prelude) = this.prelude {\n                         let mut tmp_suggestions = Vec::new();\n-                        add_module_candidates(prelude, &mut tmp_suggestions, filter_fn);\n+                        this.add_module_candidates(prelude, &mut tmp_suggestions, filter_fn);\n                         suggestions.extend(tmp_suggestions.into_iter().filter(|s| {\n                             use_prelude || this.is_builtin_macro(s.res)\n                         }));\n@@ -509,11 +512,9 @@ impl<'a> Resolver<'a> {\n         while let Some((in_module,\n                         path_segments,\n                         in_module_is_extern)) = worklist.pop() {\n-            self.populate_module_if_necessary(in_module);\n-\n             // We have to visit module children in deterministic order to avoid\n             // instabilities in reported imports (#43552).\n-            in_module.for_each_child_stable(|ident, ns, name_binding| {\n+            in_module.for_each_child_stable(self, |this, ident, ns, name_binding| {\n                 // avoid imports entirely\n                 if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n                 // avoid non-importable candidates as well\n@@ -547,7 +548,7 @@ impl<'a> Resolver<'a> {\n                         // outside crate private modules => no need to check this)\n                         if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                             let did = match res {\n-                                Res::Def(DefKind::Ctor(..), did) => self.parent(did),\n+                                Res::Def(DefKind::Ctor(..), did) => this.parent(did),\n                                 _ => res.opt_def_id(),\n                             };\n                             candidates.push(ImportSuggestion { did, path });\n@@ -607,8 +608,6 @@ impl<'a> Resolver<'a> {\n                         krate: crate_id,\n                         index: CRATE_DEF_INDEX,\n                     });\n-                    self.populate_module_if_necessary(&crate_root);\n-\n                     suggestions.extend(self.lookup_import_candidates_from_module(\n                         lookup_ident, namespace, crate_root, ident, &filter_fn));\n                 }\n@@ -805,7 +804,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ///            at the root of the crate instead of the module where it is defined\n     /// ```\n     pub(crate) fn check_for_module_export_macro(\n-        &self,\n+        &mut self,\n         directive: &'b ImportDirective<'b>,\n         module: ModuleOrUniformRoot<'b>,\n         ident: Ident,\n@@ -826,7 +825,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             return None;\n         }\n \n-        let resolutions = crate_module.resolutions.borrow();\n+        let resolutions = self.r.resolutions(crate_module).borrow();\n         let resolution = resolutions.get(&(ident, MacroNS))?;\n         let binding = resolution.borrow().binding()?;\n         if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = binding.res() {"}, {"sha": "d8bd86699b7af966982543c6143c77599f8d110d", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -1929,7 +1929,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let mut traits = module.traits.borrow_mut();\n         if traits.is_none() {\n             let mut collected_traits = Vec::new();\n-            module.for_each_child(|name, ns, binding| {\n+            module.for_each_child(self.r, |_, name, ns, binding| {\n                 if ns != TypeNS { return }\n                 match binding.res() {\n                     Res::Def(DefKind::Trait, _) |"}, {"sha": "a822fa049ca1c5467175d881af0110230c7d1b4c", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -1,8 +1,7 @@\n use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n use crate::path_names_to_string;\n-use crate::diagnostics::{add_typo_suggestion, add_module_candidates};\n-use crate::diagnostics::{ImportSuggestion, TypoSuggestion};\n+use crate::diagnostics::{add_typo_suggestion, ImportSuggestion, TypoSuggestion};\n use crate::late::{LateResolutionVisitor, RibKind};\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n@@ -548,7 +547,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                 // Items in scope\n                 if let RibKind::ModuleRibKind(module) = rib.kind {\n                     // Items from this module\n-                    add_module_candidates(module, &mut names, &filter_fn);\n+                    self.r.add_module_candidates(module, &mut names, &filter_fn);\n \n                     if let ModuleKind::Block(..) = module.kind {\n                         // We can see through blocks\n@@ -577,7 +576,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                             }));\n \n                             if let Some(prelude) = self.r.prelude {\n-                                add_module_candidates(prelude, &mut names, &filter_fn);\n+                                self.r.add_module_candidates(prelude, &mut names, &filter_fn);\n                             }\n                         }\n                         break;\n@@ -599,7 +598,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                 mod_path, Some(TypeNS), false, span, CrateLint::No\n             ) {\n                 if let ModuleOrUniformRoot::Module(module) = module {\n-                    add_module_candidates(module, &mut names, &filter_fn);\n+                    self.r.add_module_candidates(module, &mut names, &filter_fn);\n                 }\n             }\n         }\n@@ -717,9 +716,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n             // abort if the module is already found\n             if result.is_some() { break; }\n \n-            self.r.populate_module_if_necessary(in_module);\n-\n-            in_module.for_each_child_stable(|ident, _, name_binding| {\n+            in_module.for_each_child_stable(self.r, |_, ident, _, name_binding| {\n                 // abort if the module is already found or if name_binding is private external\n                 if result.is_some() || !name_binding.vis.is_visible_locally() {\n                     return\n@@ -750,10 +747,8 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n \n     fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n         self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n-            self.r.populate_module_if_necessary(enum_module);\n-\n             let mut variants = Vec::new();\n-            enum_module.for_each_child_stable(|ident, _, name_binding| {\n+            enum_module.for_each_child_stable(self.r, |_, ident, _, name_binding| {\n                 if let Res::Def(DefKind::Variant, _) = name_binding.res() {\n                     let mut segms = enum_import_suggestion.path.segments.clone();\n                     segms.push(ast::PathSegment::from_ident(ident));"}, {"sha": "12c4f5bfe8e617f8fb538d147c4297ae4d55a279", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -431,6 +431,8 @@ impl ModuleKind {\n     }\n }\n \n+type Resolutions<'a> = RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>;\n+\n /// One node in the tree of modules.\n pub struct ModuleData<'a> {\n     parent: Option<Module<'a>>,\n@@ -439,7 +441,11 @@ pub struct ModuleData<'a> {\n     // The def id of the closest normal module (`mod`) ancestor (including this module).\n     normal_ancestor_id: DefId,\n \n-    resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n+    // Mapping between names and their (possibly in-progress) resolutions in this module.\n+    // Resolutions in modules from other crates are not populated until accessed.\n+    lazy_resolutions: Resolutions<'a>,\n+    // True if this is a module from other crate that needs to be populated on access.\n+    populate_on_access: Cell<bool>,\n \n     // Macro invocations that can expand into items in this module.\n     unresolved_invocations: RefCell<FxHashSet<ExpnId>>,\n@@ -452,11 +458,6 @@ pub struct ModuleData<'a> {\n     // Used to memoize the traits in this module for faster searches through all traits in scope.\n     traits: RefCell<Option<Box<[(Ident, &'a NameBinding<'a>)]>>>,\n \n-    // Whether this module is populated. If not populated, any attempt to\n-    // access the children must be preceded with a\n-    // `populate_module_if_necessary` call.\n-    populated: Cell<bool>,\n-\n     /// Span of the module itself. Used for error reporting.\n     span: Span,\n \n@@ -475,30 +476,34 @@ impl<'a> ModuleData<'a> {\n             parent,\n             kind,\n             normal_ancestor_id,\n-            resolutions: Default::default(),\n+            lazy_resolutions: Default::default(),\n+            populate_on_access: Cell::new(!normal_ancestor_id.is_local()),\n             unresolved_invocations: Default::default(),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new(Vec::new()),\n             traits: RefCell::new(None),\n-            populated: Cell::new(normal_ancestor_id.is_local()),\n             span,\n             expansion,\n         }\n     }\n \n-    fn for_each_child<F: FnMut(Ident, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n-        for (&(ident, ns), name_resolution) in self.resolutions.borrow().iter() {\n-            name_resolution.borrow().binding.map(|binding| f(ident, ns, binding));\n+    fn for_each_child<R, F>(&'a self, resolver: &mut R, mut f: F)\n+        where R: AsMut<Resolver<'a>>, F: FnMut(&mut R, Ident, Namespace, &'a NameBinding<'a>)\n+    {\n+        for (&(ident, ns), name_resolution) in resolver.as_mut().resolutions(self).borrow().iter() {\n+            name_resolution.borrow().binding.map(|binding| f(resolver, ident, ns, binding));\n         }\n     }\n \n-    fn for_each_child_stable<F: FnMut(Ident, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n-        let resolutions = self.resolutions.borrow();\n+    fn for_each_child_stable<R, F>(&'a self, resolver: &mut R, mut f: F)\n+        where R: AsMut<Resolver<'a>>, F: FnMut(&mut R, Ident, Namespace, &'a NameBinding<'a>)\n+    {\n+        let resolutions = resolver.as_mut().resolutions(self).borrow();\n         let mut resolutions = resolutions.iter().collect::<Vec<_>>();\n         resolutions.sort_by_cached_key(|&(&(ident, ns), _)| (ident.as_str(), ns));\n         for &(&(ident, ns), &resolution) in resolutions.iter() {\n-            resolution.borrow().binding.map(|binding| f(ident, ns, binding));\n+            resolution.borrow().binding.map(|binding| f(resolver, ident, ns, binding));\n         }\n     }\n \n@@ -983,6 +988,10 @@ impl<'a> ResolverArenas<'a> {\n     }\n }\n \n+impl<'a> AsMut<Resolver<'a>> for Resolver<'a> {\n+    fn as_mut(&mut self) -> &mut Resolver<'a> { self }\n+}\n+\n impl<'a, 'b> ty::DefIdTree for &'a Resolver<'b> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n         match id.krate {\n@@ -1248,6 +1257,20 @@ impl<'a> Resolver<'a> {\n         self.arenas.alloc_module(module)\n     }\n \n+    fn resolutions(&mut self, module: Module<'a>) -> &'a Resolutions<'a> {\n+        if module.populate_on_access.get() {\n+            module.populate_on_access.set(false);\n+            self.build_reduced_graph_external(module);\n+        }\n+        &module.lazy_resolutions\n+    }\n+\n+    fn resolution(&mut self, module: Module<'a>, ident: Ident, ns: Namespace)\n+                  -> &'a RefCell<NameResolution<'a>> {\n+        *self.resolutions(module).borrow_mut().entry((ident.modern(), ns))\n+               .or_insert_with(|| self.arenas.alloc_name_resolution())\n+    }\n+\n     fn record_use(&mut self, ident: Ident, ns: Namespace,\n                   used_binding: &'a NameBinding<'a>, is_lexical_scope: bool) {\n         if let Some((b2, kind)) = used_binding.ambiguity {\n@@ -2634,7 +2657,6 @@ impl<'a> Resolver<'a> {\n                     return None;\n                 };\n                 let crate_root = self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n-                self.populate_module_if_necessary(&crate_root);\n                 Some((crate_root, ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n                     .to_name_binding(self.arenas))\n             }"}, {"sha": "6f49377c187aa91a8103159d65c7c41cedb0a80f", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -8,7 +8,6 @@ use crate::{ModuleOrUniformRoot, KNOWN_TOOLS};\n use crate::Namespace::*;\n use crate::resolve_imports::ImportResolver;\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n-use rustc::hir::map::DefCollector;\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, Ident};\n@@ -131,7 +130,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n         parent_scope.module.unresolved_invocations.borrow_mut().extend(derives);\n \n         // Integrate the new AST fragment into all the definition and module structures.\n-        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, expansion));\n         let output_legacy_scope = self.build_reduced_graph(fragment, parent_scope);\n         self.output_legacy_scopes.insert(expansion, output_legacy_scope);\n     }"}, {"sha": "b49f1868706695674667f097f10563e96b2bf7e0", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -7,9 +7,8 @@ use crate::{CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, ParentScope\n use crate::Determinacy::{self, *};\n use crate::Namespace::{self, TypeNS, MacroNS};\n use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n-use crate::{Resolver, ResolutionError, Segment};\n+use crate::{Resolver, ResolutionError, Segment, ModuleKind};\n use crate::{names_to_string, module_to_string};\n-use crate::ModuleKind;\n use crate::diagnostics::Suggestion;\n \n use errors::Applicability;\n@@ -37,7 +36,7 @@ use syntax_pos::{MultiSpan, Span};\n \n use log::*;\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::Cell;\n use std::{mem, ptr};\n \n type Res = def::Res<NodeId>;\n@@ -161,12 +160,6 @@ impl<'a> NameResolution<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    crate fn resolution(&self, module: Module<'a>, ident: Ident, ns: Namespace)\n-                  -> &'a RefCell<NameResolution<'a>> {\n-        *module.resolutions.borrow_mut().entry((ident.modern(), ns))\n-               .or_insert_with(|| self.arenas.alloc_name_resolution())\n-    }\n-\n     crate fn resolve_ident_in_module_unadjusted(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n@@ -242,8 +235,6 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        self.populate_module_if_necessary(module);\n-\n         let resolution = self.resolution(module, ident, ns)\n             .try_borrow_mut()\n             .map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n@@ -1027,7 +1018,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n             return if all_ns_failed {\n                 let resolutions = match module {\n-                    ModuleOrUniformRoot::Module(module) => Some(module.resolutions.borrow()),\n+                    ModuleOrUniformRoot::Module(module) =>\n+                        Some(self.r.resolutions(module).borrow()),\n                     _ => None,\n                 };\n                 let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n@@ -1265,8 +1257,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             }\n         };\n \n-        self.r.populate_module_if_necessary(module);\n-\n         if module.is_trait() {\n             self.r.session.span_err(directive.span, \"items in traits are not importable.\");\n             return;\n@@ -1282,8 +1272,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n-        let bindings = module.resolutions.borrow().iter().filter_map(|(&ident, resolution)| {\n-            resolution.borrow().binding().map(|binding| (ident, binding))\n+        let bindings = self.r.resolutions(module).borrow().iter().filter_map(|(ident, resolution)| {\n+            resolution.borrow().binding().map(|binding| (*ident, binding))\n         }).collect::<Vec<_>>();\n         for ((mut ident, ns), binding) in bindings {\n             let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n@@ -1310,7 +1300,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         let mut reexports = Vec::new();\n \n-        for (&(ident, ns), resolution) in module.resolutions.borrow().iter() {\n+        for (&(ident, ns), resolution) in self.r.resolutions(module).borrow().iter() {\n             let resolution = &mut *resolution.borrow_mut();\n             let binding = match resolution.binding {\n                 Some(binding) => binding,\n@@ -1369,8 +1359,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                             Some(ModuleOrUniformRoot::Module(module)) => module,\n                             _ => bug!(\"module should exist\"),\n                         };\n-                        let resolutions = imported_module.parent.expect(\"parent should exist\")\n-                            .resolutions.borrow();\n+                        let parent_module = imported_module.parent.expect(\"parent should exist\");\n+                        let resolutions = self.r.resolutions(parent_module).borrow();\n                         let enum_path_segment_index = directive.module_path.len() - 1;\n                         let enum_ident = directive.module_path[enum_path_segment_index].ident;\n "}, {"sha": "dfbf8bcd0f60fcdf26d583f381480ea469b3cc02", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -67,7 +67,7 @@ pub fn intrisic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n     match intrinsic {\n         \"size_of\" | \"min_align_of\" | \"needs_drop\" |\n         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n-        \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n+        \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" |\n         \"saturating_add\" | \"saturating_sub\" |\n         \"rotate_left\" | \"rotate_right\" |\n         \"ctpop\" | \"ctlz\" | \"cttz\" | \"bswap\" | \"bitreverse\" |\n@@ -314,7 +314,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                 (1, vec![param(0), param(0)], param(0)),\n             \"unchecked_add\" | \"unchecked_sub\" | \"unchecked_mul\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n-            \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n+            \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n             \"saturating_add\" | \"saturating_sub\" =>\n                 (1, vec![param(0), param(0)], param(0)),"}, {"sha": "1a87a903156d2482c93db88f7d85ec9232b83932", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -30,7 +30,6 @@ use crate::tokenstream::TokenTree;\n \n use errors::{Applicability, DiagnosticBuilder, Handler};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lock;\n use rustc_target::spec::abi::Abi;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use log::debug;\n@@ -2088,11 +2087,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                        \"type ascription is experimental\");\n                 }\n             }\n-            ast::ExprKind::Yield(..) => {\n-                gate_feature_post!(&self, generators,\n-                                  e.span,\n-                                  \"yield syntax is experimental\");\n-            }\n             ast::ExprKind::TryBlock(_) => {\n                 gate_feature_post!(&self, try_blocks, e.span, \"`try` expression is experimental\");\n             }\n@@ -2427,10 +2421,6 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n     features\n }\n \n-fn for_each_in_lock<T>(vec: &Lock<Vec<T>>, f: impl Fn(&T)) {\n-    vec.borrow().iter().for_each(f);\n-}\n-\n pub fn check_crate(krate: &ast::Crate,\n                    sess: &ParseSess,\n                    features: &Features,\n@@ -2443,26 +2433,16 @@ pub fn check_crate(krate: &ast::Crate,\n         plugin_attributes,\n     };\n \n-    for_each_in_lock(&sess.param_attr_spans, |span| gate_feature!(\n-        &ctx,\n-        param_attrs,\n-        *span,\n-        \"attributes on function parameters are unstable\"\n-    ));\n-\n-    for_each_in_lock(&sess.let_chains_spans, |span| gate_feature!(\n-        &ctx,\n-        let_chains,\n-        *span,\n-        \"`let` expressions in this position are experimental\"\n-    ));\n-\n-    for_each_in_lock(&sess.async_closure_spans, |span| gate_feature!(\n-        &ctx,\n-        async_closure,\n-        *span,\n-        \"async closures are unstable\"\n-    ));\n+    macro_rules! gate_all {\n+        ($spans:ident, $gate:ident, $msg:literal) => {\n+            for span in &*sess.$spans.borrow() { gate_feature!(&ctx, $gate, *span, $msg); }\n+        }\n+    }\n+\n+    gate_all!(param_attr_spans, param_attrs, \"attributes on function parameters are unstable\");\n+    gate_all!(let_chains_spans, let_chains, \"`let` expressions in this position are experimental\");\n+    gate_all!(async_closure_spans, async_closure, \"async closures are unstable\");\n+    gate_all!(yield_spans, generators, \"yield syntax is experimental\");\n \n     let visitor = &mut PostExpansionVisitor {\n         context: &ctx,"}, {"sha": "9088f929372c999737844fbc147189a6dc34c9ef", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -63,6 +63,8 @@ pub struct ParseSess {\n     pub let_chains_spans: Lock<Vec<Span>>,\n     // Places where `async || ..` exprs were used and should be feature gated.\n     pub async_closure_spans: Lock<Vec<Span>>,\n+    // Places where `yield e?` exprs were used and should be feature gated.\n+    pub yield_spans: Lock<Vec<Span>>,\n     pub injected_crate_name: Once<Symbol>,\n }\n \n@@ -92,6 +94,7 @@ impl ParseSess {\n             param_attr_spans: Lock::new(Vec::new()),\n             let_chains_spans: Lock::new(Vec::new()),\n             async_closure_spans: Lock::new(Vec::new()),\n+            yield_spans: Lock::new(Vec::new()),\n             injected_crate_name: Once::new(),\n         }\n     }"}, {"sha": "ccc6bd1506709155920216bfc0c00842d3ce522a", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -997,6 +997,9 @@ impl<'a> Parser<'a> {\n                     } else {\n                         ex = ExprKind::Yield(None);\n                     }\n+\n+                    let span = lo.to(hi);\n+                    self.sess.yield_spans.borrow_mut().push(span);\n                 } else if self.eat_keyword(kw::Let) {\n                     return self.parse_let_expr(attrs);\n                 } else if is_span_rust_2018 && self.eat_keyword(kw::Await) {"}, {"sha": "382d891feed8437b8a65397d8a83b8da7a516785", "filename": "src/test/ui/feature-gates/feature-gate-generators.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generators.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -2,3 +2,9 @@ fn main() {\n     yield true; //~ ERROR yield syntax is experimental\n                 //~^ ERROR yield statement outside of generator literal\n }\n+\n+#[cfg(FALSE)]\n+fn foo() {\n+    yield; //~ ERROR yield syntax is experimental\n+    yield 0; //~ ERROR yield syntax is experimental\n+}"}, {"sha": "24b814b410c9d5582d41b76ffa40e8dfa51d769a", "filename": "src/test/ui/feature-gates/feature-gate-generators.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generators.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generators.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generators.stderr?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -7,12 +7,30 @@ LL |     yield true;\n    = note: for more information, see https://github.com/rust-lang/rust/issues/43122\n    = help: add `#![feature(generators)]` to the crate attributes to enable\n \n+error[E0658]: yield syntax is experimental\n+  --> $DIR/feature-gate-generators.rs:8:5\n+   |\n+LL |     yield;\n+   |     ^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/43122\n+   = help: add `#![feature(generators)]` to the crate attributes to enable\n+\n+error[E0658]: yield syntax is experimental\n+  --> $DIR/feature-gate-generators.rs:9:5\n+   |\n+LL |     yield 0;\n+   |     ^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/43122\n+   = help: add `#![feature(generators)]` to the crate attributes to enable\n+\n error[E0627]: yield statement outside of generator literal\n   --> $DIR/feature-gate-generators.rs:2:5\n    |\n LL |     yield true;\n    |     ^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "de8efdde737f0c3dd514b25d21e2c18d66479f4c", "filename": "src/test/ui/symbol-names/issue-60925.legacy.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.legacy.stderr?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -4,13 +4,13 @@ error: symbol-name(_ZN11issue_609253foo37Foo$LT$issue_60925..llv$u6d$..Foo$GT$3f\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling(issue_60925::foo::Foo<issue_60925::llv$u6d$..Foo$GT$::foo::h059a991a004536ad)\n+error: demangling(issue_60925::foo::Foo<issue_60925::llvm::Foo>::foo::h059a991a004536ad)\n   --> $DIR/issue-60925.rs:21:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling-alt(issue_60925::foo::Foo<issue_60925::llv$u6d$..Foo$GT$::foo)\n+error: demangling-alt(issue_60925::foo::Foo<issue_60925::llvm::Foo>::foo)\n   --> $DIR/issue-60925.rs:21:9\n    |\n LL |         #[rustc_symbol_name]"}, {"sha": "02438351dbc6efbd7cae7be3410d395f5f462904", "filename": "src/test/ui/symbol-names/issue-60925.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211d1e073527915f7ce1854ad8b30dc0c45845e8/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.rs?ref=211d1e073527915f7ce1854ad8b30dc0c45845e8", "patch": "@@ -20,8 +20,8 @@ mod foo {\n     impl Foo<::llvm::Foo> {\n         #[rustc_symbol_name]\n         //[legacy]~^ ERROR symbol-name(_ZN11issue_609253foo37Foo$LT$issue_60925..llv$u6d$..Foo$GT$3foo\n-        //[legacy]~| ERROR demangling(issue_60925::foo::Foo<issue_60925::llv$u6d$..Foo$GT$::foo\n-        //[legacy]~| ERROR demangling-alt(issue_60925::foo::Foo<issue_60925::llv$u6d$..Foo$GT$::foo)\n+        //[legacy]~| ERROR demangling(issue_60925::foo::Foo<issue_60925::llvm::Foo>::foo\n+        //[legacy]~| ERROR demangling-alt(issue_60925::foo::Foo<issue_60925::llvm::Foo>::foo)\n          //[v0]~^^^^ ERROR symbol-name(_RNvMNtCs4fqI2P2rA04_11issue_609253fooINtB2_3FooNtNtB4_4llvm3FooE3foo)\n             //[v0]~| ERROR demangling(<issue_60925[317d481089b8c8fe]::foo::Foo<issue_60925[317d481089b8c8fe]::llvm::Foo>>::foo)\n             //[v0]~| ERROR demangling-alt(<issue_60925::foo::Foo<issue_60925::llvm::Foo>>::foo)"}]}