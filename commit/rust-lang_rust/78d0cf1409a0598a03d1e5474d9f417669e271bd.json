{"sha": "78d0cf1409a0598a03d1e5474d9f417669e271bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ZDBjZjE0MDlhMDU5OGEwM2QxZTU0NzRkOWY0MTc2NjllMjcxYmQ=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-21T17:31:40Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-21T17:31:40Z"}, "message": "dlist: Factor out pop and push operations by list node\n\nFactor out internal methods for pop/push ~Node<T>, This allows moving\nnodes instead of destructuring and allocating new.\n\nMake use of this in .merge() so that it requires no allocations when\nmerging two DList.", "tree": {"sha": "6bf7b6d78f96fe0681fd5bfaceecd244bf40adbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bf7b6d78f96fe0681fd5bfaceecd244bf40adbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78d0cf1409a0598a03d1e5474d9f417669e271bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78d0cf1409a0598a03d1e5474d9f417669e271bd", "html_url": "https://github.com/rust-lang/rust/commit/78d0cf1409a0598a03d1e5474d9f417669e271bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78d0cf1409a0598a03d1e5474d9f417669e271bd/comments", "author": null, "committer": null, "parents": [{"sha": "5336bdcab1b452e2192332b3397f315d4ee51e51", "url": "https://api.github.com/repos/rust-lang/rust/commits/5336bdcab1b452e2192332b3397f315d4ee51e51", "html_url": "https://github.com/rust-lang/rust/commit/5336bdcab1b452e2192332b3397f315d4ee51e51"}], "stats": {"total": 158, "additions": 104, "deletions": 54}, "files": [{"sha": "9e8982ecf8d619f549df16985f82e4d53c709e19", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 104, "deletions": 54, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/78d0cf1409a0598a03d1e5474d9f417669e271bd/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78d0cf1409a0598a03d1e5474d9f417669e271bd/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=78d0cf1409a0598a03d1e5474d9f417669e271bd", "patch": "@@ -102,6 +102,12 @@ impl<T> Clone for Rawlink<T> {\n     }\n }\n \n+impl<T> Node<T> {\n+    fn new(v: T) -> Node<T> {\n+        Node{value: v, next: None, prev: Rawlink::none()}\n+    }\n+}\n+\n /// Set the .prev field on `next`, then return `Some(next)`\n fn link_with_prev<T>(mut next: ~Node<T>, prev: Rawlink<Node<T>>) -> Link<T> {\n     next.prev = prev;\n@@ -131,6 +137,66 @@ impl<T> Mutable for DList<T> {\n     }\n }\n \n+// private methods\n+impl<T> DList<T> {\n+    /// Add a Node first in the list\n+    #[inline]\n+    fn push_front_node(&mut self, mut new_head: ~Node<T>) {\n+        match self.list_head {\n+            None => {\n+                self.list_tail = Rawlink::some(new_head);\n+                self.list_head = link_with_prev(new_head, Rawlink::none());\n+            }\n+            Some(ref mut head) => {\n+                new_head.prev = Rawlink::none();\n+                head.prev = Rawlink::some(new_head);\n+                util::swap(head, &mut new_head);\n+                head.next = Some(new_head);\n+            }\n+        }\n+        self.length += 1;\n+    }\n+\n+    /// Remove the first Node and return it, or None if the list is empty\n+    #[inline]\n+    fn pop_front_node(&mut self) -> Option<~Node<T>> {\n+        do self.list_head.take().map_consume |mut front_node| {\n+            self.length -= 1;\n+            match front_node.next.take() {\n+                Some(node) => self.list_head = link_with_prev(node, Rawlink::none()),\n+                None => self.list_tail = Rawlink::none()\n+            }\n+            front_node\n+        }\n+    }\n+\n+    /// Add a Node last in the list\n+    #[inline]\n+    fn push_back_node(&mut self, mut new_tail: ~Node<T>) {\n+        match self.list_tail.resolve() {\n+            None => return self.push_front_node(new_tail),\n+            Some(tail) => {\n+                self.list_tail = Rawlink::some(new_tail);\n+                tail.next = link_with_prev(new_tail, Rawlink::some(tail));\n+            }\n+        }\n+        self.length += 1;\n+    }\n+\n+    /// Remove the last Node and return it, or None if the list is empty\n+    #[inline]\n+    fn pop_back_node(&mut self) -> Option<~Node<T>> {\n+        do self.list_tail.resolve().map_consume |tail| {\n+            self.length -= 1;\n+            self.list_tail = tail.prev;\n+            match tail.prev.resolve() {\n+                None => self.list_head.take_unwrap(),\n+                Some(tail_prev) => tail_prev.next.take_unwrap()\n+            }\n+        }\n+    }\n+}\n+\n impl<T> Deque<T> for DList<T> {\n     /// Provide a reference to the front element, or None if the list is empty\n     #[inline]\n@@ -156,66 +222,32 @@ impl<T> Deque<T> for DList<T> {\n         self.list_tail.resolve().map_mut(|tail| &mut tail.value)\n     }\n \n-    /// Add an element last in the list\n+    /// Add an element first in the list\n     ///\n     /// O(1)\n-    fn push_back(&mut self, elt: T) {\n-        match self.list_tail.resolve() {\n-            None => return self.push_front(elt),\n-            Some(tail) => {\n-                let mut new_tail = ~Node{value: elt, next: None, prev: self.list_tail};\n-                self.list_tail = Rawlink::some(new_tail);\n-                tail.next = Some(new_tail);\n-            }\n-        }\n-        self.length += 1;\n+    fn push_front(&mut self, elt: T) {\n+        self.push_front_node(~Node::new(elt))\n     }\n \n-    /// Remove the last element and return it, or None if the list is empty\n+    /// Remove the first element and return it, or None if the list is empty\n     ///\n     /// O(1)\n-    fn pop_back(&mut self) -> Option<T> {\n-        do self.list_tail.resolve().map_consume |tail| {\n-            self.length -= 1;\n-            self.list_tail = tail.prev;\n-            match tail.prev.resolve() {\n-                None => self.list_head.take_unwrap().value,\n-                Some(tail_prev) => tail_prev.next.take_unwrap().value\n-            }\n-        }\n+    fn pop_front(&mut self) -> Option<T> {\n+        self.pop_front_node().map_consume(|~Node{value, _}| value)\n     }\n \n-    /// Add an element first in the list\n+    /// Add an element last in the list\n     ///\n     /// O(1)\n-    fn push_front(&mut self, elt: T) {\n-        let mut new_head = ~Node{value: elt, next: None, prev: Rawlink::none()};\n-        match self.list_head {\n-            None => {\n-                self.list_tail = Rawlink::some(new_head);\n-                self.list_head = Some(new_head);\n-            }\n-            Some(ref mut head) => {\n-                head.prev = Rawlink::some(new_head);\n-                util::swap(head, &mut new_head);\n-                head.next = Some(new_head);\n-            }\n-        }\n-        self.length += 1;\n+    fn push_back(&mut self, elt: T) {\n+        self.push_back_node(~Node::new(elt))\n     }\n \n-    /// Remove the first element and return it, or None if the list is empty\n+    /// Remove the last element and return it, or None if the list is empty\n     ///\n     /// O(1)\n-    fn pop_front(&mut self) -> Option<T> {\n-        do self.list_head.take().map_consume |~Node{value, next, _}| {\n-            self.length -= 1;\n-            match next {\n-                Some(node) => self.list_head = link_with_prev(node, Rawlink::none()),\n-                None => self.list_tail = Rawlink::none()\n-            }\n-            value\n-        }\n+    fn pop_back(&mut self) -> Option<T> {\n+        self.pop_back_node().map_consume(|~Node{value, _}| value)\n     }\n }\n \n@@ -289,7 +321,7 @@ impl<T> DList<T> {\n                 if take_a {\n                     it.next();\n                 } else {\n-                    it.insert_next(other.pop_front().unwrap());\n+                    it.insert_next_node(other.pop_front_node().unwrap());\n                 }\n             }\n         }\n@@ -433,25 +465,34 @@ pub trait ListInsertion<A> {\n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A>;\n }\n \n-impl<'self, A> ListInsertion<A> for MutDListIterator<'self, A> {\n-    fn insert_next(&mut self, elt: A) {\n-        // Insert an element before `self.head` so that it is between the\n+// private methods for MutDListIterator\n+impl<'self, A> MutDListIterator<'self, A> {\n+    fn insert_next_node(&mut self, mut ins_node: ~Node<A>) {\n+        // Insert before `self.head` so that it is between the\n         // previously yielded element and self.head.\n+        //\n+        // The inserted node will not appear in further iteration.\n         match self.head.resolve() {\n-            None => { self.list.push_back(elt); }\n+            None => { self.list.push_back_node(ins_node); }\n             Some(node) => {\n                 let prev_node = match node.prev.resolve() {\n-                    None => return self.list.push_front(elt),\n+                    None => return self.list.push_front_node(ins_node),\n                     Some(prev) => prev,\n                 };\n-                let mut ins_node = ~Node{value: elt, next: None, prev: Rawlink::none()};\n                 let node_own = prev_node.next.take_unwrap();\n                 ins_node.next = link_with_prev(node_own, Rawlink::some(ins_node));\n                 prev_node.next = link_with_prev(ins_node, Rawlink::some(prev_node));\n                 self.list.length += 1;\n             }\n         }\n     }\n+}\n+\n+impl<'self, A> ListInsertion<A> for MutDListIterator<'self, A> {\n+    #[inline]\n+    fn insert_next(&mut self, elt: A) {\n+        self.insert_next_node(~Node::new(elt))\n+    }\n \n     #[inline]\n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A> {\n@@ -929,7 +970,6 @@ mod tests {\n             m.push(0);\n         }\n     }\n-\n     #[bench]\n     fn bench_push_back_pop_back(b: &mut test::BenchHarness) {\n         let mut m = DList::new::<int>();\n@@ -947,6 +987,16 @@ mod tests {\n         }\n     }\n \n+    #[bench]\n+    fn bench_push_front_pop_front(b: &mut test::BenchHarness) {\n+        let mut m = DList::new::<int>();\n+        do b.iter {\n+            m.push_front(0);\n+            m.pop_front();\n+        }\n+    }\n+\n+\n     #[bench]\n     fn bench_iter(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];"}]}