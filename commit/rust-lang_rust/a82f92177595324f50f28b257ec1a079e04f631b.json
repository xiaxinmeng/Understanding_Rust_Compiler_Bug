{"sha": "a82f92177595324f50f28b257ec1a079e04f631b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MmY5MjE3NzU5NTMyNGY1MGYyOGIyNTdlYzFhMDc5ZTA0ZjYzMWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-02T07:59:27Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-02T18:39:18Z"}, "message": "rustc: Add some suppot for mixing rlibs and dylibs\n\nCurrently, rustc requires that a linkage be a product of 100% rlibs or 100%\ndylibs. This is to satisfy the requirement that each object appear at most once\nin the final output products. This is a bit limiting, and the upcoming libcore\nlibrary cannot exist as a dylib, so these rules must change.\n\nThe goal of this commit is to enable *some* use cases for mixing rlibs and\ndylibs, primarily libcore's use case. It is not targeted at allowing an\nexhaustive number of linkage flavors.\n\nThere is a new dependency_format module in rustc which calculates what format\neach upstream library should be linked as in each output type of the current\nunit of compilation. The module itself contains many gory details about what's\ngoing on here.\n\ncc #10729", "tree": {"sha": "95f850ab25f15da886e15900d95470d69b81afd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95f850ab25f15da886e15900d95470d69b81afd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a82f92177595324f50f28b257ec1a079e04f631b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a82f92177595324f50f28b257ec1a079e04f631b", "html_url": "https://github.com/rust-lang/rust/commit/a82f92177595324f50f28b257ec1a079e04f631b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a82f92177595324f50f28b257ec1a079e04f631b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adcbf539550eab5ef0b351b1d198d10acecf5301", "url": "https://api.github.com/repos/rust-lang/rust/commits/adcbf539550eab5ef0b351b1d198d10acecf5301", "html_url": "https://github.com/rust-lang/rust/commit/adcbf539550eab5ef0b351b1d198d10acecf5301"}], "stats": {"total": 693, "additions": 543, "deletions": 150}, "files": [{"sha": "ac6bb12e410bb9ef1a890aab09564a7e2677eda2", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 87, "deletions": 133, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -884,10 +884,10 @@ fn link_binary_output(sess: &Session,\n             link_staticlib(sess, &obj_filename, &out_filename);\n         }\n         session::CrateTypeExecutable => {\n-            link_natively(sess, false, &obj_filename, &out_filename);\n+            link_natively(sess, trans, false, &obj_filename, &out_filename);\n         }\n         session::CrateTypeDylib => {\n-            link_natively(sess, true, &obj_filename, &out_filename);\n+            link_natively(sess, trans, true, &obj_filename, &out_filename);\n         }\n     }\n \n@@ -1037,13 +1037,13 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n //\n // This will invoke the system linker/cc to create the resulting file. This\n // links to all upstream files as well.\n-fn link_natively(sess: &Session, dylib: bool, obj_filename: &Path,\n-                 out_filename: &Path) {\n+fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n+                 obj_filename: &Path, out_filename: &Path) {\n     let tmpdir = TempDir::new(\"rustc\").expect(\"needs a temp dir\");\n     // The invocations of cc share some flags across platforms\n     let cc_prog = get_cc_prog(sess);\n     let mut cc_args = sess.targ_cfg.target_strs.cc_args.clone();\n-    cc_args.push_all_move(link_args(sess, dylib, tmpdir.path(),\n+    cc_args.push_all_move(link_args(sess, dylib, tmpdir.path(), trans,\n                                     obj_filename, out_filename));\n     if (sess.opts.debugging_opts & session::PRINT_LINK_ARGS) != 0 {\n         println!(\"{} link args: '{}'\", cc_prog, cc_args.connect(\"' '\"));\n@@ -1092,6 +1092,7 @@ fn link_natively(sess: &Session, dylib: bool, obj_filename: &Path,\n fn link_args(sess: &Session,\n              dylib: bool,\n              tmpdir: &Path,\n+             trans: &CrateTranslation,\n              obj_filename: &Path,\n              out_filename: &Path) -> Vec<~str> {\n \n@@ -1251,7 +1252,7 @@ fn link_args(sess: &Session,\n     // this kind of behavior is pretty platform specific and generally not\n     // recommended anyway, so I don't think we're shooting ourself in the foot\n     // much with that.\n-    add_upstream_rust_crates(&mut args, sess, dylib, tmpdir);\n+    add_upstream_rust_crates(&mut args, sess, dylib, tmpdir, trans);\n     add_local_native_libraries(&mut args, sess);\n     add_upstream_native_libraries(&mut args, sess);\n \n@@ -1361,73 +1362,44 @@ fn add_local_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n-                            dylib: bool, tmpdir: &Path) {\n-\n-    // As a limitation of the current implementation, we require that everything\n-    // must be static or everything must be dynamic. The reasons for this are a\n-    // little subtle, but as with staticlibs and rlibs, the goal is to prevent\n-    // duplicate copies of the same library showing up. For example, a static\n-    // immediate dependency might show up as an upstream dynamic dependency and\n-    // we currently have no way of knowing that. We know that all dynamic\n-    // libraries require dynamic dependencies (see above), so it's satisfactory\n-    // to include either all static libraries or all dynamic libraries.\n+                            dylib: bool, tmpdir: &Path,\n+                            trans: &CrateTranslation) {\n+    // All of the heavy lifting has previously been accomplished by the\n+    // dependency_format module of the compiler. This is just crawling the\n+    // output of that module, adding crates as necessary.\n     //\n-    // With this limitation, we expose a compiler default linkage type and an\n-    // option to reverse that preference. The current behavior looks like:\n-    //\n-    // * If a dylib is being created, upstream dependencies must be dylibs\n-    // * If nothing else is specified, static linking is preferred\n-    // * If the -C prefer-dynamic flag is given, dynamic linking is preferred\n-    // * If one form of linking fails, the second is also attempted\n-    // * If both forms fail, then we emit an error message\n-\n-    let dynamic = get_deps(&sess.cstore, cstore::RequireDynamic);\n-    let statik = get_deps(&sess.cstore, cstore::RequireStatic);\n-    match (dynamic, statik, sess.opts.cg.prefer_dynamic, dylib) {\n-        (_, Some(deps), false, false) => {\n-            add_static_crates(args, sess, tmpdir, deps)\n-        }\n-\n-        (None, Some(deps), true, false) => {\n-            // If you opted in to dynamic linking and we decided to emit a\n-            // static output, you should probably be notified of such an event!\n-            sess.warn(\"dynamic linking was preferred, but dependencies \\\n-                       could not all be found in a dylib format.\");\n-            sess.warn(\"linking statically instead, using rlibs\");\n-            add_static_crates(args, sess, tmpdir, deps)\n-        }\n+    // Linking to a rlib involves just passing it to the linker (the linker\n+    // will slurp up the object files inside), and linking to a dynamic library\n+    // involves just passing the right -l flag.\n \n-        (Some(deps), _, _, _) => add_dynamic_crates(args, sess, deps),\n+    let data = if dylib {\n+        trans.crate_formats.get(&session::CrateTypeDylib)\n+    } else {\n+        trans.crate_formats.get(&session::CrateTypeExecutable)\n+    };\n \n-        (None, _, _, true) => {\n-            sess.err(\"dylib output requested, but some depenencies could not \\\n-                      be found in the dylib format\");\n-            let deps = sess.cstore.get_used_crates(cstore::RequireDynamic);\n-            for (cnum, path) in deps.move_iter() {\n-                if path.is_some() { continue }\n-                let name = sess.cstore.get_crate_data(cnum).name.clone();\n-                sess.note(format!(\"dylib not found: {}\", name));\n+    // Invoke get_used_crates to ensure that we get a topological sorting of\n+    // crates.\n+    let deps = sess.cstore.get_used_crates(cstore::RequireDynamic);\n+\n+    for &(cnum, _) in deps.iter() {\n+        // We may not pass all crates through to the linker. Some crates may\n+        // appear statically in an existing dylib, meaning we'll pick up all the\n+        // symbols from the dylib.\n+        let kind = match *data.get(cnum as uint - 1) {\n+            Some(t) => t,\n+            None => continue\n+        };\n+        let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n+        match kind {\n+            cstore::RequireDynamic => {\n+                add_dynamic_crate(args, sess, src.dylib.unwrap())\n             }\n-        }\n-\n-        (None, None, pref, false) => {\n-            let (pref, name) = if pref {\n-                sess.err(\"dynamic linking is preferred, but dependencies were \\\n-                          not found in either dylib or rlib format\");\n-                (cstore::RequireDynamic, \"dylib\")\n-            } else {\n-                sess.err(\"dependencies were not all found in either dylib or \\\n-                          rlib format\");\n-                (cstore::RequireStatic, \"rlib\")\n-            };\n-            sess.note(format!(\"dependencies not found in the `{}` format\",\n-                              name));\n-            for (cnum, path) in sess.cstore.get_used_crates(pref).move_iter() {\n-                if path.is_some() { continue }\n-                let name = sess.cstore.get_crate_data(cnum).name.clone();\n-                sess.note(name);\n+            cstore::RequireStatic => {\n+                add_static_crate(args, sess, tmpdir, cnum, src.rlib.unwrap())\n             }\n         }\n+\n     }\n \n     // Converts a library file-stem into a cc -l argument\n@@ -1439,82 +1411,64 @@ fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n         }\n     }\n \n-    // Attempts to find all dependencies with a certain linkage preference,\n-    // returning `None` if not all libraries could be found with that\n-    // preference.\n-    fn get_deps(cstore: &cstore::CStore,  preference: cstore::LinkagePreference)\n-            -> Option<Vec<(ast::CrateNum, Path)> >\n-    {\n-        let crates = cstore.get_used_crates(preference);\n-        if crates.iter().all(|&(_, ref p)| p.is_some()) {\n-            Some(crates.move_iter().map(|(a, b)| (a, b.unwrap())).collect())\n-        } else {\n-            None\n-        }\n-    }\n-\n     // Adds the static \"rlib\" versions of all crates to the command line.\n-    fn add_static_crates(args: &mut Vec<~str>, sess: &Session, tmpdir: &Path,\n-                         crates: Vec<(ast::CrateNum, Path)>) {\n-        for (cnum, cratepath) in crates.move_iter() {\n-            // When performing LTO on an executable output, all of the\n-            // bytecode from the upstream libraries has already been\n-            // included in our object file output. We need to modify all of\n-            // the upstream archives to remove their corresponding object\n-            // file to make sure we don't pull the same code in twice.\n-            //\n-            // We must continue to link to the upstream archives to be sure\n-            // to pull in native static dependencies. As the final caveat,\n-            // on linux it is apparently illegal to link to a blank archive,\n-            // so if an archive no longer has any object files in it after\n-            // we remove `lib.o`, then don't link against it at all.\n-            //\n-            // If we're not doing LTO, then our job is simply to just link\n-            // against the archive.\n-            if sess.lto() {\n-                let name = sess.cstore.get_crate_data(cnum).name.clone();\n-                time(sess.time_passes(), format!(\"altering {}.rlib\", name),\n-                     (), |()| {\n-                    let dst = tmpdir.join(cratepath.filename().unwrap());\n-                    match fs::copy(&cratepath, &dst) {\n-                        Ok(..) => {}\n-                        Err(e) => {\n-                            sess.err(format!(\"failed to copy {} to {}: {}\",\n-                                             cratepath.display(),\n-                                             dst.display(),\n-                                             e));\n-                            sess.abort_if_errors();\n-                        }\n-                    }\n-                    let dst_str = dst.as_str().unwrap().to_owned();\n-                    let mut archive = Archive::open(sess, dst);\n-                    archive.remove_file(format!(\"{}.o\", name));\n-                    let files = archive.files();\n-                    if files.iter().any(|s| s.ends_with(\".o\")) {\n-                        args.push(dst_str);\n+    fn add_static_crate(args: &mut Vec<~str>, sess: &Session, tmpdir: &Path,\n+                        cnum: ast::CrateNum, cratepath: Path) {\n+        // When performing LTO on an executable output, all of the\n+        // bytecode from the upstream libraries has already been\n+        // included in our object file output. We need to modify all of\n+        // the upstream archives to remove their corresponding object\n+        // file to make sure we don't pull the same code in twice.\n+        //\n+        // We must continue to link to the upstream archives to be sure\n+        // to pull in native static dependencies. As the final caveat,\n+        // on linux it is apparently illegal to link to a blank archive,\n+        // so if an archive no longer has any object files in it after\n+        // we remove `lib.o`, then don't link against it at all.\n+        //\n+        // If we're not doing LTO, then our job is simply to just link\n+        // against the archive.\n+        if sess.lto() {\n+            let name = sess.cstore.get_crate_data(cnum).name.clone();\n+            time(sess.time_passes(), format!(\"altering {}.rlib\", name),\n+                 (), |()| {\n+                let dst = tmpdir.join(cratepath.filename().unwrap());\n+                match fs::copy(&cratepath, &dst) {\n+                    Ok(..) => {}\n+                    Err(e) => {\n+                        sess.err(format!(\"failed to copy {} to {}: {}\",\n+                                         cratepath.display(),\n+                                         dst.display(),\n+                                         e));\n+                        sess.abort_if_errors();\n                     }\n-                });\n-            } else {\n-                args.push(cratepath.as_str().unwrap().to_owned());\n-            }\n+                }\n+                let dst_str = dst.as_str().unwrap().to_owned();\n+                let mut archive = Archive::open(sess, dst);\n+                archive.remove_file(format!(\"{}.o\", name));\n+                let files = archive.files();\n+                if files.iter().any(|s| s.ends_with(\".o\")) {\n+                    args.push(dst_str);\n+                }\n+            });\n+        } else {\n+            args.push(cratepath.as_str().unwrap().to_owned());\n         }\n     }\n \n     // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crates(args: &mut Vec<~str>, sess: &Session,\n-                          crates: Vec<(ast::CrateNum, Path)> ) {\n+    fn add_dynamic_crate(args: &mut Vec<~str>, sess: &Session,\n+                         cratepath: Path) {\n         // If we're performing LTO, then it should have been previously required\n         // that all upstream rust dependencies were available in an rlib format.\n         assert!(!sess.lto());\n \n-        for (_, cratepath) in crates.move_iter() {\n-            // Just need to tell the linker about where the library lives and\n-            // what its name is\n-            let dir = cratepath.dirname_str().unwrap();\n-            if !dir.is_empty() { args.push(\"-L\" + dir); }\n-            let libarg = unlib(&sess.targ_cfg, cratepath.filestem_str().unwrap());\n-            args.push(\"-l\" + libarg);\n-        }\n+        // Just need to tell the linker about where the library lives and\n+        // what its name is\n+        let dir = cratepath.dirname_str().unwrap();\n+        if !dir.is_empty() { args.push(\"-L\" + dir); }\n+        let libarg = unlib(&sess.targ_cfg, cratepath.filestem_str().unwrap());\n+        args.push(\"-l\" + libarg);\n     }\n }\n "}, {"sha": "f2e3c106bf6beb84a5fb71b2dfce9bbff6b2ba59", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -24,6 +24,7 @@ use metadata::cstore::CStore;\n use metadata::creader::Loader;\n use metadata;\n use middle::{trans, freevars, kind, ty, typeck, lint, reachable};\n+use middle::dependency_format;\n use middle;\n use util::common::time;\n use util::ppaux;\n@@ -383,7 +384,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         ty_cx: ty_cx,\n         exported_items: exported_items,\n         public_items: public_items,\n-        reachable: reachable_map\n+        reachable: reachable_map,\n     }\n }\n \n@@ -394,18 +395,22 @@ pub struct CrateTranslation {\n     pub link: LinkMeta,\n     pub metadata: Vec<u8>,\n     pub reachable: Vec<~str>,\n+    pub crate_formats: dependency_format::Dependencies,\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n pub fn phase_4_translate_to_llvm(krate: ast::Crate,\n                                  analysis: CrateAnalysis,\n                                  outputs: &OutputFilenames) -> (ty::ctxt, CrateTranslation) {\n-    // Option dance to work around the lack of stack once closures.\n     let time_passes = analysis.ty_cx.sess.time_passes();\n-    let mut analysis = Some(analysis);\n-    time(time_passes, \"translation\", krate, |krate|\n-         trans::base::trans_crate(krate, analysis.take_unwrap(), outputs))\n+\n+    time(time_passes, \"resolving dependency formats\", (), |_|\n+         dependency_format::calculate(&analysis.ty_cx));\n+\n+    // Option dance to work around the lack of stack once closures.\n+    time(time_passes, \"translation\", (krate, analysis), |(krate, analysis)|\n+         trans::base::trans_crate(krate, analysis, outputs))\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file"}, {"sha": "4af50d1ae46113dd9b8c809b1cdbefad3d627881", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -126,7 +126,7 @@ pub enum DebugInfoLevel {\n pub struct Options {\n     // The crate config requested for the session, which may be combined\n     // with additional crate configurations during the compile process\n-    pub crate_types: Vec<CrateType> ,\n+    pub crate_types: Vec<CrateType>,\n \n     pub gc: bool,\n     pub optimize: OptLevel,\n@@ -167,7 +167,7 @@ pub enum EntryFnType {\n     EntryNone,\n }\n \n-#[deriving(Eq, Ord, Clone, TotalOrd, TotalEq)]\n+#[deriving(Eq, Ord, Clone, TotalOrd, TotalEq, Hash)]\n pub enum CrateType {\n     CrateTypeExecutable,\n     CrateTypeDylib,"}, {"sha": "e165242397a0c7b276ff744cdff2b38f4a238cc7", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -93,6 +93,7 @@ pub mod middle {\n     pub mod cfg;\n     pub mod dead;\n     pub mod expr_use_visitor;\n+    pub mod dependency_format;\n }\n \n pub mod front {"}, {"sha": "839b0e08d37952a8e192d96d6bbc06fc5713411f", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -203,6 +203,8 @@ pub static tag_macro_def: uint = 0x8d;\n \n pub static tag_crate_triple: uint = 0x66;\n \n+pub static tag_dylib_dependency_formats: uint = 0x67;\n+\n #[deriving(Clone, Show)]\n pub struct LinkMeta {\n     pub crateid: CrateId,"}, {"sha": "ea764f132b72dd8c02b03127e870a062476a4c70", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -284,3 +284,11 @@ pub fn get_tuple_struct_definition_if_ctor(cstore: &cstore::CStore,\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_tuple_struct_definition_if_ctor(&*cdata, def_id.node)\n }\n+\n+pub fn get_dylib_dependency_formats(cstore: &cstore::CStore,\n+                                    cnum: ast::CrateNum)\n+    -> Vec<(ast::CrateNum, cstore::LinkagePreference)>\n+{\n+    let cdata = cstore.get_crate_data(cnum);\n+    decoder::get_dylib_dependency_formats(&*cdata)\n+}"}, {"sha": "390df9c0809897f4d9df3c126814053b9d22d3c6", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -45,7 +45,7 @@ pub struct crate_metadata {\n     pub span: Span,\n }\n \n-#[deriving(Eq)]\n+#[deriving(Show, Eq, Clone)]\n pub enum LinkagePreference {\n     RequireDynamic,\n     RequireStatic,"}, {"sha": "302bba2f56b6c3eac2bec66725084c5c8791a42a", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -1273,3 +1273,29 @@ pub fn get_exported_macros(data: &[u8]) -> Vec<~str> {\n     });\n     result\n }\n+\n+pub fn get_dylib_dependency_formats(cdata: Cmd)\n+    -> Vec<(ast::CrateNum, cstore::LinkagePreference)>\n+{\n+    let formats = reader::get_doc(reader::Doc(cdata.data()),\n+                                  tag_dylib_dependency_formats);\n+    let mut result = Vec::new();\n+\n+    debug!(\"found dylib deps: {}\", formats.as_str_slice());\n+    for spec in formats.as_str_slice().split(',') {\n+        if spec.len() == 0 { continue }\n+        let cnum = spec.split(':').nth(0).unwrap();\n+        let link = spec.split(':').nth(1).unwrap();\n+        let cnum = from_str(cnum).unwrap();\n+        let cnum = match cdata.cnum_map.find(&cnum) {\n+            Some(&n) => n,\n+            None => fail!(\"didn't find a crate in the cnum_map\")\n+        };\n+        result.push((cnum, if link == \"d\" {\n+            cstore::RequireDynamic\n+        } else {\n+            cstore::RequireStatic\n+        }));\n+    }\n+    return result;\n+}"}, {"sha": "684745daa3cfae95137c304a59a43cd143ec23b1", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -14,6 +14,7 @@\n #![allow(non_camel_case_types)]\n \n use back::svh::Svh;\n+use driver::session;\n use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n@@ -1696,6 +1697,23 @@ fn encode_crate_triple(ebml_w: &mut Encoder, triple: &str) {\n     ebml_w.end_tag();\n }\n \n+fn encode_dylib_dependency_formats(ebml_w: &mut Encoder, ecx: &EncodeContext) {\n+    ebml_w.start_tag(tag_dylib_dependency_formats);\n+    match ecx.tcx.dependency_formats.borrow().find(&session::CrateTypeDylib) {\n+        Some(arr) => {\n+            let s = arr.iter().enumerate().filter_map(|(i, slot)| {\n+                slot.map(|kind| format!(\"{}:{}\", i + 1, match kind {\n+                    cstore::RequireDynamic => \"d\",\n+                    cstore::RequireStatic => \"s\",\n+                }))\n+            }).collect::<Vec<~str>>();\n+            ebml_w.writer.write(s.connect(\",\").as_bytes());\n+        }\n+        None => {}\n+    }\n+    ebml_w.end_tag();\n+}\n+\n // NB: Increment this as you change the metadata encoding version.\n pub static metadata_encoding_version : &'static [u8] =\n     &[0x72, //'r' as u8,\n@@ -1767,6 +1785,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n     encode_crate_id(&mut ebml_w, &ecx.link_meta.crateid);\n     encode_crate_triple(&mut ebml_w, tcx.sess.targ_cfg.target_strs.target_triple);\n     encode_hash(&mut ebml_w, &ecx.link_meta.crate_hash);\n+    encode_dylib_dependency_formats(&mut ebml_w, &ecx);\n \n     let mut i = ebml_w.writer.tell().unwrap();\n     let crate_attrs = synthesize_crate_attrs(&ecx, krate);"}, {"sha": "7b5ef2bf2be629b0fa0f77047b68617c79d1b9ce", "filename": "src/librustc/middle/dependency_format.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -0,0 +1,229 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Resolution of mixing rlibs and dylibs\n+//!\n+//! When producing a final artifact, such as a dynamic library, the compiler has\n+//! a choice between linking an rlib or linking a dylib of all upstream\n+//! dependencies. The linking phase must guarantee, however, that a library only\n+//! show up once in the object file. For example, it is illegal for library A to\n+//! be statically linked to B and C in separate dylibs, and then link B and C\n+//! into a crate D (because library A appears twice).\n+//!\n+//! The job of this module is to calculate what format each upstream crate\n+//! should be used when linking each output type requested in this session. This\n+//! generally follows this set of rules:\n+//!\n+//!     1. Each library must appear exactly once in the output.\n+//!     2. Each rlib contains only one library (it's just an object file)\n+//!     3. Each dylib can contain more than one library (due to static linking),\n+//!        and can also bring in many dynamic dependencies.\n+//!\n+//! With these constraints in mind, it's generally a very difficult problem to\n+//! find a solution that's not \"all rlibs\" or \"all dylibs\". I have suspicions\n+//! that NP-ness may come into the picture here...\n+//!\n+//! The current selection algorithm below looks mostly similar to:\n+//!\n+//!     1. If static linking is required, then require all upstream dependencies\n+//!        to be available as rlibs. If not, generate an error.\n+//!     2. If static linking is requested (generating an executable), then\n+//!        attempt to use all upstream dependencies as rlibs. If any are not\n+//!        found, bail out and continue to step 3.\n+//!     3. Static linking has failed, at least one library must be dynamically\n+//!        linked. Apply a heuristic by greedily maximizing the number of\n+//!        dynamically linked libraries.\n+//!     4. Each upstream dependency available as a dynamic library is\n+//!        registered. The dependencies all propagate, adding to a map. It is\n+//!        possible for a dylib to add a static library as a dependency, but it\n+//!        is illegal for two dylibs to add the same static library as a\n+//!        dependency. The same dylib can be added twice. Additionally, it is\n+//!        illegal to add a static dependency when it was previously found as a\n+//!        dylib (and vice versa)\n+//!     5. After all dynamic dependencies have been traversed, re-traverse the\n+//!        remaining dependencies and add them statically (if they haven't been\n+//!        added already).\n+//!\n+//! While not perfect, this algorithm should help support use-cases such as leaf\n+//! dependencies being static while the larger tree of inner dependencies are\n+//! all dynamic. This isn't currently very well battle tested, so it will likely\n+//! fall short in some use cases.\n+//!\n+//! Currently, there is no way to specify the preference of linkage with a\n+//! particular library (other than a global dynamic/static switch).\n+//! Additionally, the algorithm is geared towards finding *any* solution rather\n+//! than finding a number of solutions (there are normally quite a few).\n+\n+use collections::HashMap;\n+use syntax::ast;\n+\n+use driver::session;\n+use metadata::cstore;\n+use metadata::csearch;\n+use middle::ty;\n+\n+/// A list of dependencies for a certain crate type.\n+///\n+/// The length of this vector is the same as the number of external crates used.\n+/// The value is None if the crate does not need to be linked (it was found\n+/// statically in another dylib), or Some(kind) if it needs to be linked as\n+/// `kind` (either static or dynamic).\n+pub type DependencyList = Vec<Option<cstore::LinkagePreference>>;\n+\n+/// A mapping of all required dependencies for a particular flavor of output.\n+///\n+/// This is local to the tcx, and is generally relevant to one session.\n+pub type Dependencies = HashMap<session::CrateType, DependencyList>;\n+\n+pub fn calculate(tcx: &ty::ctxt) {\n+    let mut fmts = tcx.dependency_formats.borrow_mut();\n+    for &ty in tcx.sess.crate_types.borrow().iter() {\n+        fmts.insert(ty, calculate_type(&tcx.sess, ty));\n+    }\n+    tcx.sess.abort_if_errors();\n+}\n+\n+fn calculate_type(sess: &session::Session,\n+                  ty: session::CrateType) -> DependencyList {\n+    match ty {\n+        // If the global prefer_dynamic switch is turned off, first attempt\n+        // static linkage (this can fail).\n+        session::CrateTypeExecutable if !sess.opts.cg.prefer_dynamic => {\n+            match attempt_static(sess) {\n+                Some(v) => return v,\n+                None => {}\n+            }\n+        }\n+\n+        // No linkage happens with rlibs, we just needed the metadata (which we\n+        // got long ago), so don't bother with anything.\n+        session::CrateTypeRlib => return Vec::new(),\n+\n+        // Staticlibs must have all static dependencies. If any fail to be\n+        // found, we generate some nice pretty errors.\n+        session::CrateTypeStaticlib => {\n+            match attempt_static(sess) {\n+                Some(v) => return v,\n+                None => {}\n+            }\n+            sess.cstore.iter_crate_data(|cnum, data| {\n+                let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n+                if src.rlib.is_some() { return }\n+                sess.err(format!(\"dependency `{}` not found in rlib format\",\n+                                 data.name));\n+            });\n+            return Vec::new();\n+        }\n+\n+        // Everything else falls through below\n+        session::CrateTypeExecutable | session::CrateTypeDylib => {},\n+    }\n+\n+    let mut formats = HashMap::new();\n+\n+    // Sweep all crates for found dylibs. Add all dylibs, as well as their\n+    // dependencies, ensuring there are no conflicts. The only valid case for a\n+    // dependency to be relied upon twice is for both cases to rely on a dylib.\n+    sess.cstore.iter_crate_data(|cnum, data| {\n+        let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n+        if src.dylib.is_some() {\n+            add_library(sess, cnum, cstore::RequireDynamic, &mut formats);\n+            debug!(\"adding dylib: {}\", data.name);\n+            let deps = csearch::get_dylib_dependency_formats(&sess.cstore, cnum);\n+            for &(depnum, style) in deps.iter() {\n+                add_library(sess, depnum, style, &mut formats);\n+                debug!(\"adding {}: {}\", style,\n+                       sess.cstore.get_crate_data(depnum).name.clone());\n+            }\n+        }\n+    });\n+\n+    // Collect what we've got so far in the return vector.\n+    let mut ret = range(1, sess.cstore.next_crate_num()).map(|i| {\n+        match formats.find(&i).map(|v| *v) {\n+            v @ Some(cstore::RequireDynamic) => v,\n+            _ => None,\n+        }\n+    }).collect::<Vec<_>>();\n+\n+    // Run through the dependency list again, and add any missing libraries as\n+    // static libraries.\n+    sess.cstore.iter_crate_data(|cnum, data| {\n+        let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n+        if src.dylib.is_none() && !formats.contains_key(&cnum) {\n+            assert!(src.rlib.is_some());\n+            add_library(sess, cnum, cstore::RequireStatic, &mut formats);\n+            *ret.get_mut(cnum as uint - 1) = Some(cstore::RequireStatic);\n+            debug!(\"adding staticlib: {}\", data.name);\n+        }\n+    });\n+\n+    // When dylib B links to dylib A, then when using B we must also link to A.\n+    // It could be the case, however, that the rlib for A is present (hence we\n+    // found metadata), but the dylib for A has since been removed.\n+    //\n+    // For situations like this, we perform one last pass over the dependencies,\n+    // making sure that everything is available in the requested format.\n+    for (cnum, kind) in ret.iter().enumerate() {\n+        let cnum = cnum as ast::CrateNum;\n+        let src = sess.cstore.get_used_crate_source(cnum + 1).unwrap();\n+        match *kind {\n+            None => continue,\n+            Some(cstore::RequireStatic) if src.rlib.is_some() => continue,\n+            Some(cstore::RequireDynamic) if src.dylib.is_some() => continue,\n+            Some(kind) => {\n+                let data = sess.cstore.get_crate_data(cnum + 1);\n+                sess.err(format!(\"crate `{}` required to be available in {}, \\\n+                                  but it was not available in this form\",\n+                                 data.name,\n+                                 match kind {\n+                                     cstore::RequireStatic => \"rlib\",\n+                                     cstore::RequireDynamic => \"dylib\",\n+                                 }));\n+            }\n+        }\n+    }\n+\n+    return ret;\n+}\n+\n+fn add_library(sess: &session::Session,\n+               cnum: ast::CrateNum,\n+               link: cstore::LinkagePreference,\n+               m: &mut HashMap<ast::CrateNum, cstore::LinkagePreference>) {\n+    match m.find(&cnum) {\n+        Some(&link2) => {\n+            // If the linkages differ, then we'd have two copies of the library\n+            // if we continued linking. If the linkages are both static, then we\n+            // would also have two copies of the library (static from two\n+            // different locations).\n+            //\n+            // This error is probably a little obscure, but I imagine that it\n+            // can be refined over time.\n+            if link2 != link || link == cstore::RequireStatic {\n+                let data = sess.cstore.get_crate_data(cnum);\n+                sess.err(format!(\"cannot satisfy dependencies so `{}` only \\\n+                                  shows up once\", data.name));\n+                sess.note(\"having upstream crates all available in one format \\\n+                           will likely make this go away\");\n+            }\n+        }\n+        None => { m.insert(cnum, link); }\n+    }\n+}\n+\n+fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n+    let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n+    if crates.iter().all(|&(_, ref p)| p.is_some()) {\n+        Some(crates.move_iter().map(|_| Some(cstore::RequireStatic)).collect())\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "09d4f526af18911bd4f62a6df091e7a853611139", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -2194,6 +2194,7 @@ pub fn trans_crate(krate: ast::Crate,\n     reachable.push(\"rust_eh_personality_catch\".to_owned()); // referenced from rt/rust_try.ll\n \n     let metadata_module = ccx.metadata_llmod;\n+    let formats = ccx.tcx.dependency_formats.borrow().clone();\n \n     (ccx.tcx, CrateTranslation {\n         context: llcx,\n@@ -2202,5 +2203,6 @@ pub fn trans_crate(krate: ast::Crate,\n         metadata_module: metadata_module,\n         metadata: metadata,\n         reachable: reachable,\n+        crate_formats: formats,\n     })\n }"}, {"sha": "d223170459d890bc2978c30792462b1fc808af88", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -15,6 +15,7 @@ use driver::session::Session;\n use metadata::csearch;\n use mc = middle::mem_categorization;\n use middle::const_eval;\n+use middle::dependency_format;\n use middle::lang_items::{ExchangeHeapLangItem, OpaqueStructLangItem};\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n use middle::freevars;\n@@ -349,6 +350,8 @@ pub struct ctxt {\n \n     pub method_map: typeck::MethodMap,\n     pub vtable_map: typeck::vtable_map,\n+\n+    pub dependency_formats: RefCell<dependency_format::Dependencies>,\n }\n \n pub enum tbox_flag {\n@@ -1123,6 +1126,7 @@ pub fn mk_ctxt(s: Session,\n         extern_const_variants: RefCell::new(DefIdMap::new()),\n         method_map: RefCell::new(FnvHashMap::new()),\n         vtable_map: RefCell::new(FnvHashMap::new()),\n+        dependency_formats: RefCell::new(HashMap::new()),\n     }\n }\n "}, {"sha": "a978eacbfd1df9c37360d2d0dfffcb06d820ad82", "filename": "src/test/auxiliary/issue-12133-dylib2.rs", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Fauxiliary%2Fissue-12133-dylib2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Fauxiliary%2Fissue-12133-dylib2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-12133-dylib2.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -8,13 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// aux-build:issue-12133-rlib.rs\n-// aux-build:issue-12133-dylib.rs\n // no-prefer-dynamic\n \n-// error-pattern: dylib output requested, but some depenencies could not\n-\n #![crate_type = \"dylib\"]\n \n extern crate a = \"issue-12133-rlib\";\n extern crate b = \"issue-12133-dylib\";\n+", "previous_filename": "src/test/compile-fail/issue-12133-3.rs"}, {"sha": "e665cb2e5350ddde1229971e5a6149a3bd347d61", "filename": "src/test/run-make/mixing-formats/Makefile", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-make%2Fmixing-formats%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-make%2Fmixing-formats%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmixing-formats%2FMakefile?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -0,0 +1,74 @@\n+-include ../tools.mk\n+\n+# Testing various mixings of rlibs and dylibs. Makes sure that it's possible to\n+# link an rlib to a dylib. The dependency tree among the file looks like:\n+#\n+#\t\t\t\tfoo\n+#\t\t\t      /     \\\n+#\t\t\t    bar1   bar2\n+#\t\t\t   /    \\ /\n+#\t\t\t baz    baz2\n+#\n+# This is generally testing the permutations of the foo/bar1/bar2 layer against\n+# the baz/baz2 layer\n+\n+all:\n+\t# Building just baz\n+\t$(RUSTC) --crate-type=rlib  foo.rs\n+\t$(RUSTC) --crate-type=dylib bar1.rs\n+\t$(RUSTC) --crate-type=dylib,rlib baz.rs\n+\t$(RUSTC) --crate-type=bin baz.rs\n+\trm $(TMPDIR)/*\n+\t$(RUSTC) --crate-type=dylib foo.rs\n+\t$(RUSTC) --crate-type=rlib  bar1.rs\n+\t$(RUSTC) --crate-type=dylib,rlib baz.rs\n+\t$(RUSTC) --crate-type=bin baz.rs\n+\trm $(TMPDIR)/*\n+\t# Building baz2\n+\t$(RUSTC) --crate-type=rlib  foo.rs\n+\t$(RUSTC) --crate-type=dylib bar1.rs\n+\t$(RUSTC) --crate-type=dylib bar2.rs\n+\t$(RUSTC) --crate-type=dylib baz2.rs && exit 1 || exit 0\n+\t$(RUSTC) --crate-type=bin baz2.rs && exit 1 || exit 0\n+\trm $(TMPDIR)/*\n+\t$(RUSTC) --crate-type=rlib  foo.rs\n+\t$(RUSTC) --crate-type=rlib  bar1.rs\n+\t$(RUSTC) --crate-type=dylib bar2.rs\n+\t$(RUSTC) --crate-type=dylib,rlib baz2.rs\n+\t$(RUSTC) --crate-type=bin baz2.rs\n+\trm $(TMPDIR)/*\n+\t$(RUSTC) --crate-type=rlib  foo.rs\n+\t$(RUSTC) --crate-type=dylib bar1.rs\n+\t$(RUSTC) --crate-type=rlib  bar2.rs\n+\t$(RUSTC) --crate-type=dylib,rlib baz2.rs\n+\t$(RUSTC) --crate-type=bin baz2.rs\n+\trm $(TMPDIR)/*\n+\t$(RUSTC) --crate-type=rlib  foo.rs\n+\t$(RUSTC) --crate-type=rlib  bar1.rs\n+\t$(RUSTC) --crate-type=rlib  bar2.rs\n+\t$(RUSTC) --crate-type=dylib,rlib baz2.rs\n+\t$(RUSTC) --crate-type=bin baz2.rs\n+\trm $(TMPDIR)/*\n+\t$(RUSTC) --crate-type=dylib foo.rs\n+\t$(RUSTC) --crate-type=rlib  bar1.rs\n+\t$(RUSTC) --crate-type=rlib  bar2.rs\n+\t$(RUSTC) --crate-type=dylib,rlib baz2.rs\n+\t$(RUSTC) --crate-type=bin baz2.rs\n+\trm $(TMPDIR)/*\n+\t$(RUSTC) --crate-type=dylib foo.rs\n+\t$(RUSTC) --crate-type=dylib bar1.rs\n+\t$(RUSTC) --crate-type=rlib  bar2.rs\n+\t$(RUSTC) --crate-type=dylib,rlib baz2.rs\n+\t$(RUSTC) --crate-type=bin baz2.rs\n+\trm $(TMPDIR)/*\n+\t$(RUSTC) --crate-type=dylib foo.rs\n+\t$(RUSTC) --crate-type=rlib  bar1.rs\n+\t$(RUSTC) --crate-type=dylib bar2.rs\n+\t$(RUSTC) --crate-type=dylib,rlib baz2.rs\n+\t$(RUSTC) --crate-type=bin baz2.rs\n+\trm $(TMPDIR)/*\n+\t$(RUSTC) --crate-type=dylib foo.rs\n+\t$(RUSTC) --crate-type=dylib bar1.rs\n+\t$(RUSTC) --crate-type=dylib bar2.rs\n+\t$(RUSTC) --crate-type=dylib,rlib baz2.rs\n+\t$(RUSTC) --crate-type=bin baz2.rs"}, {"sha": "4b4916fe96d636eaf83d1bb07d9852b6ece1cebf", "filename": "src/test/run-make/mixing-formats/bar1.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-make%2Fmixing-formats%2Fbar1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-make%2Fmixing-formats%2Fbar1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmixing-formats%2Fbar1.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate foo;"}, {"sha": "4b4916fe96d636eaf83d1bb07d9852b6ece1cebf", "filename": "src/test/run-make/mixing-formats/bar2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-make%2Fmixing-formats%2Fbar2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-make%2Fmixing-formats%2Fbar2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmixing-formats%2Fbar2.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate foo;"}, {"sha": "3fb90f6a854f6538c2029a87d753559c126f2144", "filename": "src/test/run-make/mixing-formats/baz.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-make%2Fmixing-formats%2Fbaz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-make%2Fmixing-formats%2Fbaz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmixing-formats%2Fbaz.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate bar1;\n+\n+fn main() {}"}, {"sha": "4cfa65330bd1901a91109e26e681e78858997675", "filename": "src/test/run-make/mixing-formats/baz2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-make%2Fmixing-formats%2Fbaz2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-make%2Fmixing-formats%2Fbaz2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmixing-formats%2Fbaz2.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate bar1;\n+extern crate bar2;\n+\n+fn main() {}\n+"}, {"sha": "e6c760257380c6639446ab5e533b74c2a17b7a3e", "filename": "src/test/run-make/mixing-formats/foo.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-make%2Fmixing-formats%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-make%2Fmixing-formats%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmixing-formats%2Ffoo.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms."}, {"sha": "4de0cb3276290b11ed7cc018bbf203df2ecef7f3", "filename": "src/test/run-make/mixing-libs/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-make%2Fmixing-libs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-make%2Fmixing-libs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmixing-libs%2FMakefile?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -2,7 +2,7 @@\n \n all:\n \t$(RUSTC) rlib.rs\n-\t$(RUSTC) dylib.rs && exit 1 || exit 0\n+\t$(RUSTC) dylib.rs\n \t$(RUSTC) rlib.rs --crate-type=dylib\n \t$(RUSTC) dylib.rs\n \trm $(call DYLIB,rlib-*)"}, {"sha": "91003672f3a52250018a0ef29a67c765ca6ac601", "filename": "src/test/run-pass/issue-12133-1.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-pass%2Fissue-12133-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-pass%2Fissue-12133-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12133-1.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -11,8 +11,6 @@\n // aux-build:issue-12133-rlib.rs\n // aux-build:issue-12133-dylib.rs\n \n-// error-pattern: dynamic linking is preferred, but dependencies were not found\n-\n extern crate a = \"issue-12133-rlib\";\n extern crate b = \"issue-12133-dylib\";\n ", "previous_filename": "src/test/compile-fail/issue-12133-1.rs"}, {"sha": "877d4f706e964e1031edda3c72dbecb63781d512", "filename": "src/test/run-pass/issue-12133-2.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-pass%2Fissue-12133-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-pass%2Fissue-12133-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12133-2.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -12,8 +12,6 @@\n // aux-build:issue-12133-dylib.rs\n // no-prefer-dynamic\n \n-// error-pattern: dependencies were not all found in either dylib or rlib format\n-\n extern crate a = \"issue-12133-rlib\";\n extern crate b = \"issue-12133-dylib\";\n ", "previous_filename": "src/test/compile-fail/issue-12133-2.rs"}, {"sha": "35f4d86efe055b351065f2871df0e5db9255df4b", "filename": "src/test/run-pass/issue-12133-3.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-pass%2Fissue-12133-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82f92177595324f50f28b257ec1a079e04f631b/src%2Ftest%2Frun-pass%2Fissue-12133-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12133-3.rs?ref=a82f92177595324f50f28b257ec1a079e04f631b", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-12133-rlib.rs\n+// aux-build:issue-12133-dylib.rs\n+// aux-build:issue-12133-dylib2.rs\n+\n+extern crate other = \"issue-12133-dylib2\";\n+\n+fn main() {}"}]}