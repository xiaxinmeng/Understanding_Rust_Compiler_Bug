{"sha": "98491827b920884e4ea1182dcacce2a650dde861", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NDkxODI3YjkyMDg4NGU0ZWExMTgyZGNhY2NlMmE2NTBkZGU4NjE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-03-05T02:48:54Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-03-11T21:39:15Z"}, "message": "syntax: move indirection around {Trait,Impl}Item, from within.", "tree": {"sha": "ea55dc4ff5b7e7007183f78ca8cb0896957df352", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea55dc4ff5b7e7007183f78ca8cb0896957df352"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98491827b920884e4ea1182dcacce2a650dde861", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98491827b920884e4ea1182dcacce2a650dde861", "html_url": "https://github.com/rust-lang/rust/commit/98491827b920884e4ea1182dcacce2a650dde861", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98491827b920884e4ea1182dcacce2a650dde861/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f899513a30165946a75ff7f515ab37a226e72172", "url": "https://api.github.com/repos/rust-lang/rust/commits/f899513a30165946a75ff7f515ab37a226e72172", "html_url": "https://github.com/rust-lang/rust/commit/f899513a30165946a75ff7f515ab37a226e72172"}], "stats": {"total": 636, "additions": 274, "deletions": 362}, "files": [{"sha": "44c01eba2ce5e7824a54dd44aac315b7346ceaa5", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -851,7 +851,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n                                    associated_type: &ty::AssociatedType,\n                                    impl_path: PathElems,\n                                    parent_id: NodeId,\n-                                   typedef_opt: Option<P<ast::Typedef>>) {\n+                                   typedef_opt: Option<&ast::Typedef>) {\n     debug!(\"encode_info_for_associated_type({:?},{:?})\",\n            associated_type.def_id,\n            token::get_name(associated_type.name));\n@@ -873,13 +873,9 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     let elem = ast_map::PathName(associated_type.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n \n-    match typedef_opt {\n-        None => {}\n-        Some(typedef) => {\n-            encode_attributes(rbml_w, &typedef.attrs);\n-            encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx,\n-                                                         typedef.id));\n-        }\n+    if let Some(typedef) = typedef_opt {\n+        encode_attributes(rbml_w, &typedef.attrs);\n+        encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx, typedef.id));\n     }\n \n     rbml_w.end_tag();\n@@ -1226,7 +1222,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let num_implemented_methods = ast_items.len();\n         for (i, &trait_item_def_id) in items.iter().enumerate() {\n             let ast_item = if i < num_implemented_methods {\n-                Some(&ast_items[i])\n+                Some(&*ast_items[i])\n             } else {\n                 None\n             };\n@@ -1265,7 +1261,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                                     &**associated_type,\n                                                     path.clone(),\n                                                     item.id,\n-                                                    Some((*typedef).clone()))\n+                                                    Some(typedef))\n                 }\n                 (ty::TypeTraitItem(ref associated_type), _) => {\n                     encode_info_for_associated_type(ecx,\n@@ -1387,7 +1383,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             encode_parent_sort(rbml_w, 't');\n \n-            let trait_item = &ms[i];\n+            let trait_item = &*ms[i];\n             let encode_trait_item = |rbml_w: &mut Encoder| {\n                 // If this is a static method, we've already\n                 // encoded this.\n@@ -1397,23 +1393,23 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_bounds_and_type_for_item(rbml_w, ecx, item_def_id.def_id().local_id());\n                 }\n             };\n-            match trait_item {\n-                &ast::RequiredMethod(ref m) => {\n+            match *trait_item {\n+                ast::RequiredMethod(ref m) => {\n                     encode_attributes(rbml_w, &m.attrs);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'r');\n                     encode_method_argument_names(rbml_w, &*m.decl);\n                 }\n \n-                &ast::ProvidedMethod(ref m) => {\n+                ast::ProvidedMethod(ref m) => {\n                     encode_attributes(rbml_w, &m.attrs);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'p');\n                     encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n                     encode_method_argument_names(rbml_w, &*m.pe_fn_decl());\n                 }\n \n-                &ast::TypeTraitItem(ref associated_type) => {\n+                ast::TypeTraitItem(ref associated_type) => {\n                     encode_attributes(rbml_w,\n                                       &associated_type.attrs);\n                     encode_item_sort(rbml_w, 't');"}, {"sha": "20b0307f47a325d6e8d6d4c5db702c324d4f7276", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -425,9 +425,9 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n                 }\n                 ast::TypeTraitItem(ref associated_type) => {\n                     ast::TypeTraitItem(\n-                        P(fold::noop_fold_associated_type(\n-                            (**associated_type).clone(),\n-                            &mut fld)))\n+                        fold::noop_fold_associated_type(\n+                            (*associated_type).clone(),\n+                            &mut fld))\n                 }\n             })\n         }\n@@ -441,7 +441,7 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n                 }\n                 ast::TypeImplItem(ref td) => {\n                     ast::TypeImplItem(\n-                        P(fold::noop_fold_typedef((**td).clone(), &mut fld)))\n+                        fold::noop_fold_typedef((*td).clone(), &mut fld))\n                 }\n             })\n         }"}, {"sha": "37cb23ff4f030a6fd38419bc1ecbcb7dcc7bdb89", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -357,7 +357,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n             }\n             ast::ItemImpl(_, _, _, Some(ref _trait_ref), _, ref impl_items) => {\n                 for impl_item in impl_items {\n-                    match *impl_item {\n+                    match **impl_item {\n                         ast::MethodImplItem(ref method) => {\n                             self.worklist.push(method.id);\n                         }\n@@ -586,7 +586,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n             ast::ProvidedMethod(ref method) => {\n                 visit::walk_block(self, &*method.pe_body())\n             }\n-            ast::RequiredMethod(_) => {}\n+            ast::RequiredMethod(_) |\n             ast::TypeTraitItem(_) => {}\n         }\n     }"}, {"sha": "35f904c2ee841d82fb697618fc85026c0c3740b7", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -315,7 +315,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 match *impl_item {\n                     ast::MethodImplItem(ref method) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n-                        if method_might_be_inlined(self.tcx, &**method, did) {\n+                        if method_might_be_inlined(self.tcx, method, did) {\n                             visit::walk_block(self, method.pe_body())\n                         }\n                     }"}, {"sha": "d1a02ff82e5441189c71ffd6e6717ab9d31b2eca", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -22,8 +22,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n use syntax::{attr, visit};\n use syntax::ast;\n use syntax::ast::{Attribute, Block, Crate, DefId, FnDecl, NodeId, Variant};\n-use syntax::ast::{Item, RequiredMethod, ProvidedMethod, TraitItem};\n-use syntax::ast::{TypeMethod, Method, Generics, StructField, TypeTraitItem};\n+use syntax::ast::{Item, TypeMethod, Method, Generics, StructField};\n use syntax::ast_util::is_local;\n use syntax::attr::{Stability, AttrMetaMethods};\n use syntax::visit::{FnKind, FkMethod, Visitor};\n@@ -134,19 +133,20 @@ impl<'a, 'v> Visitor<'v> for Annotator<'a> {\n         // a stability attribute, so we don't recurse.\n     }\n \n-    fn visit_trait_item(&mut self, t: &TraitItem) {\n+    fn visit_trait_item(&mut self, t: &ast::TraitItem) {\n         let (id, attrs, sp) = match *t {\n-            RequiredMethod(TypeMethod {id, ref attrs, span, ..}) => (id, attrs, span),\n+            ast::RequiredMethod(TypeMethod {id, ref attrs, span, ..}) => (id, attrs, span),\n \n             // work around lack of pattern matching for @ types\n-            ProvidedMethod(ref method) => {\n-                match **method {\n+            ast::ProvidedMethod(ref method) => {\n+                match *method {\n                     Method {ref attrs, id, span, ..} => (id, attrs, span),\n                 }\n             }\n \n-            TypeTraitItem(ref typedef) => (typedef.ty_param.id, &typedef.attrs,\n-                                           typedef.ty_param.span),\n+            ast::TypeTraitItem(ref typedef) => {\n+                (typedef.ty_param.id, &typedef.attrs, typedef.ty_param.span)\n+            }\n         };\n         self.annotate(id, true, attrs, sp, |v| visit::walk_trait_item(v, t), true);\n     }\n@@ -335,7 +335,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n             let trait_items = ty::trait_items(tcx, trait_did);\n \n             for impl_item in impl_items {\n-                let (ident, span) = match *impl_item {\n+                let (ident, span) = match **impl_item {\n                     ast::MethodImplItem(ref method) => {\n                         (match method.node {\n                             ast::MethDecl(ident, _, _, _, _, _, _, _) => ident,"}, {"sha": "f6920dc52cdcce16c8e8fa1e73917973e649eead", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -5080,39 +5080,23 @@ pub fn provided_source(cx: &ctxt, id: ast::DefId) -> Option<ast::DefId> {\n pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                     -> Vec<Rc<Method<'tcx>>> {\n     if is_local(id) {\n-        match cx.map.find(id.node) {\n-            Some(ast_map::NodeItem(item)) => {\n-                match item.node {\n-                    ItemTrait(_, _, _, ref ms) => {\n-                        let (_, p) =\n-                            ast_util::split_trait_methods(&ms[..]);\n-                        p.iter()\n-                         .map(|m| {\n-                            match impl_or_trait_item(\n-                                    cx,\n-                                    ast_util::local_def(m.id)) {\n-                                MethodTraitItem(m) => m,\n-                                TypeTraitItem(_) => {\n-                                    cx.sess.bug(\"provided_trait_methods(): \\\n-                                                 split_trait_methods() put \\\n-                                                 associated types in the \\\n-                                                 provided method bucket?!\")\n-                                }\n-                            }\n-                         }).collect()\n-                    }\n-                    _ => {\n-                        cx.sess.bug(&format!(\"provided_trait_methods: `{:?}` is \\\n-                                             not a trait\",\n-                                            id))\n+        if let ItemTrait(_, _, _, ref ms) = cx.map.expect_item(id.node).node {\n+            ms.iter().filter_map(|ti| {\n+                if let ast::ProvidedMethod(ref m) = **ti {\n+                    match impl_or_trait_item(cx, ast_util::local_def(m.id)) {\n+                        MethodTraitItem(m) => Some(m),\n+                        TypeTraitItem(_) => {\n+                            cx.sess.bug(\"provided_trait_methods(): \\\n+                                         associated type found from \\\n+                                         looking up ProvidedMethod?!\")\n+                        }\n                     }\n+                } else {\n+                    None\n                 }\n-            }\n-            _ => {\n-                cx.sess.bug(&format!(\"provided_trait_methods: `{:?}` is not a \\\n-                                     trait\",\n-                                    id))\n-            }\n+            }).collect()\n+        } else {\n+            cx.sess.bug(&format!(\"provided_trait_methods: `{:?}` is not a trait\", id))\n         }\n     } else {\n         csearch::get_provided_trait_methods(cx, id)"}, {"sha": "a979c4919952a40ec79f2e934c3cec54c31294a2", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -94,7 +94,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n             // private.\n             ast::ItemTrait(_, _, _, ref methods) if item.vis != ast::Public => {\n                 for m in methods {\n-                    match *m {\n+                    match **m {\n                         ast::ProvidedMethod(ref m) => {\n                             self.parents.insert(m.id, item.id);\n                         }\n@@ -280,7 +280,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n \n                 if public_ty || public_trait {\n                     for impl_item in impl_items {\n-                        match *impl_item {\n+                        match **impl_item {\n                             ast::MethodImplItem(ref method) => {\n                                 let meth_public =\n                                     match method.pe_explicit_self().node {\n@@ -301,7 +301,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             // is public\n             ast::ItemTrait(_, _, _, ref methods) if public_first => {\n                 for method in methods {\n-                    match *method {\n+                    match **method {\n                         ast::ProvidedMethod(ref m) => {\n                             debug!(\"provided {}\", m.id);\n                             self.exported_items.insert(m.id);\n@@ -1088,7 +1088,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                                 \"visibility qualifiers have no effect on trait \\\n                                  impls\");\n                 for impl_item in impl_items {\n-                    match *impl_item {\n+                    match **impl_item {\n                         ast::MethodImplItem(ref m) => {\n                             check_inherited(m.span, m.pe_vis(), \"\");\n                         }\n@@ -1123,7 +1123,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n \n             ast::ItemTrait(_, _, _, ref methods) => {\n                 for m in methods {\n-                    match *m {\n+                    match **m {\n                         ast::ProvidedMethod(ref m) => {\n                             check_inherited(m.span, m.pe_vis(),\n                                             \"unnecessary visibility\");\n@@ -1165,7 +1165,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n         match item.node {\n             ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n                 for impl_item in impl_items {\n-                    match *impl_item {\n+                    match **impl_item {\n                         ast::MethodImplItem(ref m) => {\n                             check_inherited(tcx, m.span, m.pe_vis());\n                         }\n@@ -1188,7 +1188,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n \n             ast::ItemTrait(_, _, _, ref methods) => {\n                 for m in methods {\n-                    match *m {\n+                    match **m {\n                         ast::RequiredMethod(..) => {}\n                         ast::ProvidedMethod(ref m) => check_inherited(tcx, m.span,\n                                                                 m.pe_vis()),\n@@ -1352,7 +1352,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     trait_ref.is_some() ||\n                     impl_items.iter()\n                               .any(|impl_item| {\n-                                  match *impl_item {\n+                                  match **impl_item {\n                                       ast::MethodImplItem(ref m) => {\n                                           self.exported_items.contains(&m.id)\n                                       }\n@@ -1369,9 +1369,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     match *trait_ref {\n                         None => {\n                             for impl_item in impl_items {\n-                                match *impl_item {\n+                                match **impl_item {\n                                     ast::MethodImplItem(ref method) => {\n-                                        visit::walk_method_helper(self, &**method)\n+                                        visit::walk_method_helper(self, method)\n                                     }\n                                     ast::TypeImplItem(_) => {}\n                                 }\n@@ -1395,7 +1395,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n                             // Those in 3. are warned with this call.\n                             for impl_item in impl_items {\n-                                match *impl_item {\n+                                match **impl_item {\n                                     ast::MethodImplItem(..) => {},\n                                     ast::TypeImplItem(ref typedef) => {\n                                         self.visit_ty(&typedef.typ);\n@@ -1409,14 +1409,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for impl_item in impl_items {\n-                        match *impl_item {\n+                        match **impl_item {\n                             ast::MethodImplItem(ref method) => {\n                                 if method.pe_explicit_self().node ==\n                                         ast::SelfStatic &&\n                                         self.exported_items\n                                             .contains(&method.id) {\n                                     found_pub_static = true;\n-                                    visit::walk_method_helper(self, &**method);\n+                                    visit::walk_method_helper(self, method);\n                                 }\n                             }\n                             ast::TypeImplItem(_) => {}"}, {"sha": "48fb03e1efb856444e1bb76e82bdfdd130ea8b91", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -48,7 +48,7 @@ use syntax::ast::UnnamedField;\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::{Visibility};\n use syntax::ast;\n-use syntax::ast_util::{self, local_def};\n+use syntax::ast_util::{self, local_def, PostExpansionMethod};\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::{self, special_idents};\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -525,28 +525,32 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 // Add the names of all the items to the trait info.\n                 for trait_item in items {\n-                    let (name, trait_item_id) = match *trait_item {\n+                    let (name, trait_item_id) = match **trait_item {\n                         ast::RequiredMethod(_) |\n                         ast::ProvidedMethod(_) => {\n-                            let ty_m = ast_util::trait_item_to_ty_method(trait_item);\n-\n-                            let name = ty_m.ident.name;\n+                            let (id, name, span) = match **trait_item {\n+                                ast::RequiredMethod(ref m) => {\n+                                    (m.id, m.ident.name, m.span)\n+                                }\n+                                ast::ProvidedMethod(ref m) => {\n+                                    (m.id, m.pe_ident().name, m.span)\n+                                }\n+                                _ => unreachable!()\n+                            };\n \n                             // Add it as a name in the trait module.\n-                            let def = DefMethod(local_def(ty_m.id),\n+                            let def = DefMethod(local_def(id),\n                                                 FromTrait(local_def(item.id)));\n \n                             let method_name_bindings =\n                                 self.add_child(name,\n                                                &module_parent,\n                                                ForbidDuplicateTypesAndValues,\n-                                               ty_m.span);\n+                                               span);\n                             // NB: not IMPORTABLE\n-                            method_name_bindings.define_value(def,\n-                                                              ty_m.span,\n-                                                              PUBLIC);\n+                            method_name_bindings.define_value(def, span, PUBLIC);\n \n-                            (name, local_def(ty_m.id))\n+                            (name, local_def(id))\n                         }\n                         ast::TypeTraitItem(ref associated_type) => {\n                             let def = DefAssociatedTy(local_def(item.id),"}, {"sha": "cb1540e0f4f43cbf33076486c5023a0b71df7317", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -86,6 +86,7 @@ use syntax::ast_util::{PostExpansionMethod, local_def, walk_pat};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n use syntax::parse::token::{self, special_names, special_idents};\n+use syntax::ptr::P;\n use syntax::codemap::{self, Span, Pos};\n use syntax::visit::{self, Visitor};\n \n@@ -2812,7 +2813,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         //\n                         // FIXME #4951: Do we need a node ID here?\n \n-                        let type_parameters = match *trait_item {\n+                        let type_parameters = match **trait_item {\n                             ast::RequiredMethod(ref ty_m) => {\n                                 HasTypeParameters(&ty_m.generics,\n                                                   FnSpace,\n@@ -3049,7 +3050,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               generics: &Generics,\n                               opt_trait_reference: &Option<TraitRef>,\n                               self_type: &Ty,\n-                              impl_items: &[ImplItem]) {\n+                              impl_items: &[P<ImplItem>]) {\n         // If applicable, create a rib for the type parameters.\n         self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                        TypeSpace,\n@@ -3065,7 +3066,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 this.with_current_self_type(self_type, |this| {\n                     for impl_item in impl_items {\n-                        match *impl_item {\n+                        match **impl_item {\n                             MethodImplItem(ref method) => {\n                                 // If this is a trait impl, ensure the method\n                                 // exists in trait\n@@ -3079,7 +3080,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                       FnSpace,\n                                                       MethodRibKind);\n                                 this.with_type_parameter_rib(type_parameters, |this| {\n-                                    visit::walk_method_helper(this, &**method);\n+                                    visit::walk_method_helper(this, method);\n                                 });\n                             }\n                             TypeImplItem(ref typedef) => {"}, {"sha": "13e3db4ba75c280ef0b689a0eb7292a667419484", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -656,7 +656,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     type_parameters: &ast::Generics,\n                     trait_ref: &Option<ast::TraitRef>,\n                     typ: &ast::Ty,\n-                    impl_items: &Vec<ast::ImplItem>) {\n+                    impl_items: &[P<ast::ImplItem>]) {\n         let trait_id = trait_ref.as_ref().and_then(|tr| self.lookup_type_ref(tr.ref_id));\n         match typ.node {\n             // Common case impl for a struct or something basic.\n@@ -698,9 +698,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n         for impl_item in impl_items {\n-            match *impl_item {\n+            match **impl_item {\n                 ast::MethodImplItem(ref method) => {\n-                    visit::walk_method_helper(self, &**method)\n+                    visit::walk_method_helper(self, method)\n                 }\n                 ast::TypeImplItem(ref typedef) => {\n                     visit::walk_ty(self, &*typedef.typ)\n@@ -713,7 +713,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                      item: &ast::Item,\n                      generics: &ast::Generics,\n                      trait_refs: &OwnedSlice<ast::TyParamBound>,\n-                     methods: &Vec<ast::TraitItem>) {\n+                     methods: &[P<ast::TraitItem>]) {\n         let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n@@ -1296,7 +1296,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                             qualname,\n                                             method_type.id);\n             }\n-            ast::ProvidedMethod(ref method) => self.process_method(&**method),\n+            ast::ProvidedMethod(ref method) => self.process_method(method),\n             ast::TypeTraitItem(_) => {}\n         }\n     }"}, {"sha": "77df121580d81d89eb8584cd3b1288b5850f1270", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -1283,7 +1283,7 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n                                   in has_nested_returns\")\n                 }\n                 ast::TypeTraitItem(_) => {\n-                    tcx.sess.bug(\"unexpected variant: type trait item in \\\n+                    tcx.sess.bug(\"unexpected variant: associated type trait item in \\\n                                   has_nested_returns\")\n                 }\n             }\n@@ -1299,7 +1299,7 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n                     }\n                 }\n                 ast::TypeImplItem(_) => {\n-                    tcx.sess.bug(\"unexpected variant: type impl item in \\\n+                    tcx.sess.bug(\"unexpected variant: associated type impl item in \\\n                                   has_nested_returns\")\n                 }\n             }\n@@ -2826,18 +2826,18 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                     method in get_item_val()\");\n                 }\n                 ast::ProvidedMethod(ref m) => {\n-                    register_method(ccx, id, &**m)\n+                    register_method(ccx, id, m)\n                 }\n             }\n         }\n \n         ast_map::NodeImplItem(ii) => {\n             match *ii {\n-                ast::MethodImplItem(ref m) => register_method(ccx, id, &**m),\n+                ast::MethodImplItem(ref m) => register_method(ccx, id, m),\n                 ast::TypeImplItem(ref typedef) => {\n                     ccx.sess().span_bug(typedef.span,\n-                                        \"unexpected variant: required impl \\\n-                                         method in get_item_val()\")\n+                                        \"unexpected variant: associated type \\\n+                                        in get_item_val()\")\n                 }\n             }\n         }"}, {"sha": "14889190a85afe795bdc69aaccfb4c2f35c87704", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -129,56 +129,54 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n              with a non-item parent\");\n         }\n         csearch::FoundAst::Found(&ast::IITraitItem(_, ref trait_item)) => {\n-            match *trait_item {\n+            let id = match *trait_item {\n+                ast::ProvidedMethod(ref mth) => mth.id,\n                 ast::RequiredMethod(_) => ccx.sess().bug(\"found RequiredMethod IITraitItem\"),\n-                ast::ProvidedMethod(ref mth) => {\n-                    ccx.external().borrow_mut().insert(fn_id, Some(mth.id));\n-                    ccx.external_srcs().borrow_mut().insert(mth.id, fn_id);\n+                ast::TypeTraitItem(_) => ccx.sess().bug(\"found TypeTraitItem IITraitItem\"),\n+            };\n+            ccx.external().borrow_mut().insert(fn_id, Some(id));\n+            ccx.external_srcs().borrow_mut().insert(id, fn_id);\n \n-                    ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n+            ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n \n-                    // If this is a default method, we can't look up the\n-                    // impl type. But we aren't going to translate anyways, so\n-                    // don't.\n-                    local_def(mth.id)\n-                }\n-                ast::TypeTraitItem(_) => {\n-                    ccx.sess().bug(\"found TypeTraitItem IITraitItem\")\n-                }\n-            }\n+            // If this is a default method, we can't look up the\n+            // impl type. But we aren't going to translate anyways, so\n+            // don't.\n+            local_def(id)\n         }\n         csearch::FoundAst::Found(&ast::IIImplItem(impl_did, ref impl_item)) => {\n-            match *impl_item {\n+            let (id, monomorphic_method) = match *impl_item {\n                 ast::MethodImplItem(ref mth) => {\n-                    ccx.external().borrow_mut().insert(fn_id, Some(mth.id));\n-                    ccx.external_srcs().borrow_mut().insert(mth.id, fn_id);\n-\n-                    ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n-\n                     let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n                     let unparameterized = impl_tpt.generics.types.is_empty() &&\n                             mth.pe_generics().ty_params.is_empty();\n \n-                    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-                    if unparameterized {\n-                        let llfn = get_item_val(ccx, mth.id);\n-                        trans_fn(ccx,\n-                                 &*mth.pe_fn_decl(),\n-                                 &*mth.pe_body(),\n-                                 llfn,\n-                                 empty_substs,\n-                                 mth.id,\n-                                 &[]);\n-                        // Use InternalLinkage so LLVM can optimize more\n-                        // aggressively.\n-                        SetLinkage(llfn, InternalLinkage);\n-                    }\n-                    local_def(mth.id)\n+                    (mth.id, if unparameterized { Some(mth) } else { None })\n                 }\n                 ast::TypeImplItem(_) => {\n                     ccx.sess().bug(\"found TypeImplItem IIImplItem\")\n                 }\n+            };\n+\n+            ccx.external().borrow_mut().insert(fn_id, Some(id));\n+            ccx.external_srcs().borrow_mut().insert(id, fn_id);\n+\n+            ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n+\n+            if let Some(mth) = monomorphic_method {\n+                let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+                let llfn = get_item_val(ccx, mth.id);\n+                trans_fn(ccx,\n+                         &*mth.pe_fn_decl(),\n+                         &*mth.pe_body(),\n+                         llfn,\n+                         empty_substs,\n+                         mth.id,\n+                         &[]);\n+                // Use InternalLinkage so LLVM can optimize more aggressively.\n+                SetLinkage(llfn, InternalLinkage);\n             }\n+            local_def(id)\n         }\n     };\n "}, {"sha": "8bbd688d63cd7a1e4923fe0497486ce6c4a7de51", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -43,6 +43,7 @@ use syntax::parse::token;\n use syntax::{ast, ast_map, attr, visit};\n use syntax::ast_util::PostExpansionMethod;\n use syntax::codemap::DUMMY_SP;\n+use syntax::ptr::P;\n \n // drop_glue pointer, size, align.\n const VTABLE_OFFSET: uint = 3;\n@@ -53,7 +54,7 @@ const VTABLE_OFFSET: uint = 3;\n /// see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n pub fn trans_impl(ccx: &CrateContext,\n                   name: ast::Ident,\n-                  impl_items: &[ast::ImplItem],\n+                  impl_items: &[P<ast::ImplItem>],\n                   generics: &ast::Generics,\n                   id: ast::NodeId) {\n     let _icx = push_ctxt(\"meth::trans_impl\");\n@@ -66,17 +67,17 @@ pub fn trans_impl(ccx: &CrateContext,\n     if !generics.ty_params.is_empty() {\n         let mut v = TransItemVisitor{ ccx: ccx };\n         for impl_item in impl_items {\n-            match *impl_item {\n+            match **impl_item {\n                 ast::MethodImplItem(ref method) => {\n-                    visit::walk_method_helper(&mut v, &**method);\n+                    visit::walk_method_helper(&mut v, method);\n                 }\n                 ast::TypeImplItem(_) => {}\n             }\n         }\n         return;\n     }\n     for impl_item in impl_items {\n-        match *impl_item {\n+        match **impl_item {\n             ast::MethodImplItem(ref method) => {\n                 if method.pe_generics().ty_params.len() == 0 {\n                     let trans_everywhere = attr::requests_inline(&method.attrs);\n@@ -99,7 +100,7 @@ pub fn trans_impl(ccx: &CrateContext,\n                 let mut v = TransItemVisitor {\n                     ccx: ccx,\n                 };\n-                visit::walk_method_helper(&mut v, &**method);\n+                visit::walk_method_helper(&mut v, method);\n             }\n             ast::TypeImplItem(_) => {}\n         }"}, {"sha": "9d364df5553c18e7e676689c9b538000e6d8d9e3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -1096,7 +1096,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         match this.tcx().map.expect_item(trait_did.node).node {\n             ast::ItemTrait(_, _, _, ref trait_items) => {\n                 trait_items.iter().filter_map(|i| {\n-                    if let ast::TypeTraitItem(ref assoc) = *i {\n+                    if let ast::TypeTraitItem(ref assoc) = **i {\n                         if assoc.ty_param.ident.name == assoc_name {\n                             return Some(ast_util::local_def(assoc.ty_param.id));\n                         }"}, {"sha": "c625d826713542db00615f2681c3b9f602e562c7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -739,9 +739,9 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n           }\n \n         for impl_item in impl_items {\n-            match *impl_item {\n+            match **impl_item {\n                 ast::MethodImplItem(ref m) => {\n-                    check_method_body(ccx, &impl_pty.generics, &**m);\n+                    check_method_body(ccx, &impl_pty.generics, m);\n                 }\n                 ast::TypeImplItem(_) => {\n                     // Nothing to do here.\n@@ -754,13 +754,13 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n         check_trait_on_unimplemented(ccx, generics, it);\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n         for trait_method in trait_methods {\n-            match *trait_method {\n+            match **trait_method {\n                 RequiredMethod(..) => {\n                     // Nothing to do, since required methods don't have\n                     // bodies to check.\n                 }\n                 ProvidedMethod(ref m) => {\n-                    check_method_body(ccx, &trait_def.generics, &**m);\n+                    check_method_body(ccx, &trait_def.generics, m);\n                 }\n                 TypeTraitItem(_) => {\n                     // Nothing to do.\n@@ -876,15 +876,15 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_span: Span,\n                                             impl_trait_ref: &ty::TraitRef<'tcx>,\n-                                            impl_items: &[ast::ImplItem]) {\n+                                            impl_items: &[P<ast::ImplItem>]) {\n     // Locate trait methods\n     let tcx = ccx.tcx;\n     let trait_items = ty::trait_items(tcx, impl_trait_ref.def_id);\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n-        match *impl_item {\n+        match **impl_item {\n             ast::MethodImplItem(ref impl_method) => {\n                 let impl_method_def_id = local_def(impl_method.id);\n                 let impl_item_ty = ty::impl_or_trait_item(ccx.tcx,\n@@ -978,7 +978,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ty::MethodTraitItem(ref trait_method) => {\n                 let is_implemented =\n                     impl_items.iter().any(|ii| {\n-                        match *ii {\n+                        match **ii {\n                             ast::MethodImplItem(ref m) => {\n                                 m.pe_ident().name == trait_method.name\n                             }\n@@ -993,7 +993,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             }\n             ty::TypeTraitItem(ref associated_type) => {\n                 let is_implemented = impl_items.iter().any(|ii| {\n-                    match *ii {\n+                    match **ii {\n                         ast::TypeImplItem(ref typedef) => {\n                             typedef.ident.name == associated_type.name\n                         }"}, {"sha": "6c7c3cf08bc30953f85df92d8ae88a8f6b3b58a0", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -501,7 +501,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     fn visit_trait_item(&mut self, t: &'v ast::TraitItem) {\n         match t {\n             &ast::TraitItem::ProvidedMethod(_) |\n-            &ast::TraitItem::TypeTraitItem(_) => {},\n+            &ast::TraitItem::TypeTraitItem(_) => {}\n             &ast::TraitItem::RequiredMethod(ref method) => {\n                 match ty::impl_or_trait_item(self.tcx(), local_def(method.id)) {\n                     ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {"}, {"sha": "b990ba0ab24f95a8878f8a57d002915c79a7ce78", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -279,7 +279,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 let mut items: Vec<ImplOrTraitItemId> =\n                         ast_items.iter()\n                                  .map(|ast_item| {\n-                            match *ast_item {\n+                            match **ast_item {\n                                 ast::MethodImplItem(ref ast_method) => {\n                                     MethodTraitItemId(\n                                         local_def(ast_method.id))"}, {"sha": "4d98aed8006b2a678ec3ca0caccbcdcfe59998d9", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -631,17 +631,16 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             // For each method, construct a suitable ty::Method and\n             // store it into the `tcx.impl_or_trait_items` table:\n             for trait_item in trait_items {\n-                match *trait_item {\n+                match **trait_item {\n                     ast::RequiredMethod(_) |\n                     ast::ProvidedMethod(_) => {\n-                        let ty_method = Rc::new(match *trait_item {\n+                        let ty_method = Rc::new(match **trait_item {\n                             ast::RequiredMethod(ref m) => {\n                                 ty_method_of_trait_method(\n                                     ccx,\n                                     trait_id,\n                                     &trait_def.generics,\n                                     &trait_predicates,\n-                                    &trait_items[..],\n                                     &m.id,\n                                     &m.ident.name,\n                                     &m.explicit_self,\n@@ -656,7 +655,6 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     trait_id,\n                                     &trait_def.generics,\n                                     &trait_predicates,\n-                                    &trait_items[..],\n                                     &m.id,\n                                     &m.pe_ident().name,\n                                     m.pe_explicit_self(),\n@@ -702,7 +700,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             // Add an entry mapping\n             let trait_item_def_ids =\n                 Rc::new(trait_items.iter().map(|ti| {\n-                    match *ti {\n+                    match **ti {\n                         ast::RequiredMethod(ref ty_method) => {\n                             ty::MethodTraitItemId(local_def(ty_method.id))\n                         }\n@@ -736,7 +734,6 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            trait_id: ast::NodeId,\n                                            trait_generics: &ty::Generics<'tcx>,\n                                            trait_bounds: &ty::GenericPredicates<'tcx>,\n-                                           _trait_items: &[ast::TraitItem],\n                                            m_id: &ast::NodeId,\n                                            m_name: &ast::Name,\n                                            m_explicit_self: &ast::ExplicitSelf,\n@@ -1016,9 +1013,9 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n             let mut methods = Vec::new();\n             for impl_item in impl_items {\n-                match *impl_item {\n+                match **impl_item {\n                     ast::MethodImplItem(ref method) => {\n-                        methods.push(&**method);\n+                        methods.push(method);\n                     }\n                     ast::TypeImplItem(ref typedef) => {\n                         if opt_trait_ref.is_none() {\n@@ -1059,7 +1056,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                             parent_visibility);\n \n             for impl_item in impl_items {\n-                match *impl_item {\n+                match **impl_item {\n                     ast::MethodImplItem(ref method) => {\n                         let body_id = method.pe_body().id;\n                         check_method_self_type(ccx,\n@@ -1099,9 +1096,9 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             let untransformed_rcvr_ty = ty::mk_self_type(tcx);\n             convert_methods(ccx,\n                             TraitContainer(local_def(it.id)),\n-                            trait_items.iter().filter_map(|m| match *m {\n+                            trait_items.iter().filter_map(|m| match **m {\n                                 ast::RequiredMethod(_) => None,\n-                                ast::ProvidedMethod(ref m) => Some(&**m),\n+                                ast::ProvidedMethod(ref m) => Some(m),\n                                 ast::TypeTraitItem(_) => None,\n                             }),\n                             untransformed_rcvr_ty,\n@@ -1118,7 +1115,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             // we have a method type stored for every method.\n             for trait_item in trait_items {\n                 let self_type = ty::mk_self_type(tcx);\n-                match *trait_item {\n+                match **trait_item {\n                     ast::RequiredMethod(ref type_method) => {\n                         let rscope = BindingRscope::new();\n                         check_method_self_type(ccx,\n@@ -1139,7 +1136,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                     ast::TypeTraitItem(ref associated_type) => {\n                         convert_associated_type(ccx,\n                                                 &*trait_def,\n-                                                &**associated_type);\n+                                                associated_type);\n                     }\n                 }\n             }\n@@ -1354,7 +1351,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let associated_type_names: Vec<_> =\n         items.iter()\n              .filter_map(|item| {\n-                 match *item {\n+                 match **item {\n                      ast::RequiredMethod(_) | ast::ProvidedMethod(_) => None,\n                      ast::TypeTraitItem(ref data) => Some(data.ty_param.ident.name),\n                  }\n@@ -1484,13 +1481,13 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n                                                  ast_generics: &ast::Generics,\n                                                  trait_predicates: &ty::GenericPredicates<'tcx>,\n                                                  self_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n-                                                 trait_items: &[ast::TraitItem])\n+                                                 trait_items: &[P<ast::TraitItem>])\n                                                  -> Vec<ty::Predicate<'tcx>>\n     {\n         trait_items\n             .iter()\n             .flat_map(|trait_item| {\n-                let assoc_type_def = match *trait_item {\n+                let assoc_type_def = match **trait_item {\n                     ast::TypeTraitItem(ref assoc_type) => &assoc_type.ty_param,\n                     ast::RequiredMethod(..) | ast::ProvidedMethod(..) => {\n                         return vec!().into_iter();"}, {"sha": "5a4deaa2e726672eab0bb6f9675aef25c0a8a779", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -174,7 +174,7 @@ pub struct Constant {\n pub struct Trait {\n     pub unsafety: ast::Unsafety,\n     pub name: Ident,\n-    pub items: Vec<ast::TraitItem>, //should be TraitItem\n+    pub items: Vec<P<ast::TraitItem>>, //should be TraitItem\n     pub generics: ast::Generics,\n     pub bounds: Vec<ast::TyParamBound>,\n     pub attrs: Vec<ast::Attribute>,\n@@ -190,7 +190,7 @@ pub struct Impl {\n     pub generics: ast::Generics,\n     pub trait_: Option<ast::TraitRef>,\n     pub for_: P<ast::Ty>,\n-    pub items: Vec<ast::ImplItem>,\n+    pub items: Vec<P<ast::ImplItem>>,\n     pub attrs: Vec<ast::Attribute>,\n     pub whence: Span,\n     pub vis: ast::Visibility,"}, {"sha": "fafcc056dedfb6dcb8faa006f64b5ecc011a2fb5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -1081,14 +1081,14 @@ pub struct TypeMethod {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TraitItem {\n     RequiredMethod(TypeMethod),\n-    ProvidedMethod(P<Method>),\n-    TypeTraitItem(P<AssociatedType>),\n+    ProvidedMethod(Method),\n+    TypeTraitItem(AssociatedType),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ImplItem {\n-    MethodImplItem(P<Method>),\n-    TypeImplItem(P<Typedef>),\n+    MethodImplItem(Method),\n+    TypeImplItem(Typedef),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -1659,7 +1659,7 @@ pub enum Item_ {\n     ItemTrait(Unsafety,\n               Generics,\n               TyParamBounds,\n-              Vec<TraitItem>),\n+              Vec<P<TraitItem>>),\n \n     // Default trait implementations\n     // `impl Trait for ..`\n@@ -1669,7 +1669,7 @@ pub enum Item_ {\n              Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n-             Vec<ImplItem>),\n+             Vec<P<ImplItem>>),\n     /// A macro invocation (which includes macro definition)\n     ItemMac(Mac),\n }"}, {"sha": "8d605ea50cda6b9bc728757b82e685f155ad4212", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -206,12 +206,12 @@ impl<'a> FnLikeNode<'a> {\n                 _ => panic!(\"item FnLikeNode that is not fn-like\"),\n             },\n             ast_map::NodeTraitItem(t) => match *t {\n-                ast::ProvidedMethod(ref m) => method(&**m),\n+                ast::ProvidedMethod(ref m) => method(m),\n                 _ => panic!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             ast_map::NodeImplItem(ii) => {\n                 match *ii {\n-                    ast::MethodImplItem(ref m) => method(&**m),\n+                    ast::MethodImplItem(ref m) => method(m),\n                     ast::TypeImplItem(_) => {\n                         panic!(\"impl method FnLikeNode that is not fn-like\")\n                     }"}, {"sha": "4db6f9bc3c52bf384cdaba5f66d77a5ae958fb4f", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -14,12 +14,11 @@ use self::MapEntry::*;\n \n use abi;\n use ast::*;\n-use ast_util;\n+use ast_util::{self, PostExpansionMethod};\n use codemap::{DUMMY_SP, Span, Spanned};\n use fold::Folder;\n use parse::token;\n use print::pprust;\n-use ptr::P;\n use visit::{self, Visitor};\n \n use arena::TypedArena;\n@@ -741,14 +740,11 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         match i.node {\n             ItemImpl(_, _, _, _, _, ref impl_items) => {\n                 for impl_item in impl_items {\n-                    match *impl_item {\n-                        MethodImplItem(ref m) => {\n-                            self.insert(m.id, NodeImplItem(impl_item));\n-                        }\n-                        TypeImplItem(ref t) => {\n-                            self.insert(t.id, NodeImplItem(impl_item));\n-                        }\n-                    }\n+                    let id = match **impl_item {\n+                        MethodImplItem(ref m) => m.id,\n+                        TypeImplItem(ref t) => t.id,\n+                    };\n+                    self.insert(id, NodeImplItem(impl_item));\n                 }\n             }\n             ItemEnum(ref enum_definition, _) => {\n@@ -778,17 +774,12 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                 }\n \n                 for tm in trait_items {\n-                    match *tm {\n-                        RequiredMethod(ref m) => {\n-                            self.insert(m.id, NodeTraitItem(tm));\n-                        }\n-                        ProvidedMethod(ref m) => {\n-                            self.insert(m.id, NodeTraitItem(tm));\n-                        }\n-                        TypeTraitItem(ref typ) => {\n-                            self.insert(typ.ty_param.id, NodeTraitItem(tm));\n-                        }\n-                    }\n+                    let id = match **tm {\n+                        RequiredMethod(ref m) => m.id,\n+                        ProvidedMethod(ref m) => m.id,\n+                        TypeTraitItem(ref typ) => typ.ty_param.id,\n+                    };\n+                    self.insert(id, NodeTraitItem(tm));\n                 }\n             }\n             _ => {}\n@@ -933,7 +924,7 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n             TypeTraitItem(at) => {\n                 IITraitItem(\n                     fld.fold_ops.new_def_id(d),\n-                    TypeTraitItem(P(fld.fold_associated_type((*at).clone()))))\n+                    TypeTraitItem(fld.fold_associated_type(at)))\n             }\n         },\n         IIImplItem(d, m) => match m {\n@@ -944,7 +935,7 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n             }\n             TypeImplItem(t) => {\n                 IIImplItem(fld.fold_ops.new_def_id(d),\n-                           TypeImplItem(P(fld.fold_typedef((*t).clone()))))\n+                           TypeImplItem(fld.fold_typedef(t)))\n             }\n         },\n         IIForeign(i) => IIForeign(fld.fold_foreign_item(i))\n@@ -1064,7 +1055,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                     }\n                 }\n                 TypeImplItem(ref t) => {\n-                    format!(\"typedef {} in {}{}\",\n+                    format!(\"assoc type {} in {}{}\",\n                             token::get_ident(t.ident),\n                             map.path_to_string(id),\n                             id_str)\n@@ -1073,15 +1064,20 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         }\n         Some(NodeTraitItem(ref tm)) => {\n             match **tm {\n-                RequiredMethod(_) | ProvidedMethod(_) => {\n-                    let m = ast_util::trait_item_to_ty_method(&**tm);\n-                    format!(\"method {} in {}{}\",\n+                RequiredMethod(ref m) => {\n+                    format!(\"required method {} in {}{}\",\n                             token::get_ident(m.ident),\n                             map.path_to_string(id),\n                             id_str)\n                 }\n+                ProvidedMethod(ref m) => {\n+                    format!(\"provided method {} in {}{}\",\n+                            token::get_ident(m.pe_ident()),\n+                            map.path_to_string(id),\n+                            id_str)\n+                }\n                 TypeTraitItem(ref t) => {\n-                    format!(\"type item {} in {}{}\",\n+                    format!(\"assoc type {} in {}{}\",\n                             token::get_ident(t.ty_param.ident),\n                             map.path_to_string(id),\n                             id_str)"}, {"sha": "a8804b595d403b1bcd32f7448fd14cebfad984e2", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -268,62 +268,6 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: Option<&Ty>) -> Ident\n     token::gensym_ident(&pretty[..])\n }\n \n-pub fn trait_method_to_ty_method(method: &Method) -> TypeMethod {\n-    match method.node {\n-        MethDecl(ident,\n-                 ref generics,\n-                 abi,\n-                 ref explicit_self,\n-                 unsafety,\n-                 ref decl,\n-                 _,\n-                 vis) => {\n-            TypeMethod {\n-                ident: ident,\n-                attrs: method.attrs.clone(),\n-                unsafety: unsafety,\n-                decl: (*decl).clone(),\n-                generics: generics.clone(),\n-                explicit_self: (*explicit_self).clone(),\n-                id: method.id,\n-                span: method.span,\n-                vis: vis,\n-                abi: abi,\n-            }\n-        },\n-        MethMac(_) => panic!(\"expected non-macro method declaration\")\n-    }\n-}\n-\n-/// extract a TypeMethod from a TraitItem. if the TraitItem is\n-/// a default, pull out the useful fields to make a TypeMethod\n-//\n-// NB: to be used only after expansion is complete, and macros are gone.\n-pub fn trait_item_to_ty_method(method: &TraitItem) -> TypeMethod {\n-    match *method {\n-        RequiredMethod(ref m) => (*m).clone(),\n-        ProvidedMethod(ref m) => trait_method_to_ty_method(&**m),\n-        TypeTraitItem(_) => {\n-            panic!(\"trait_method_to_ty_method(): expected method but found \\\n-                   typedef\")\n-        }\n-    }\n-}\n-\n-pub fn split_trait_methods(trait_methods: &[TraitItem])\n-                           -> (Vec<TypeMethod>, Vec<P<Method>> ) {\n-    let mut reqd = Vec::new();\n-    let mut provd = Vec::new();\n-    for trt_method in trait_methods {\n-        match *trt_method {\n-            RequiredMethod(ref tm) => reqd.push((*tm).clone()),\n-            ProvidedMethod(ref m) => provd.push((*m).clone()),\n-            TypeTraitItem(_) => {}\n-        }\n-    };\n-    (reqd, provd)\n-}\n-\n pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n     match field.node.kind {\n         ast::NamedField(_, v) | ast::UnnamedField(v) => v"}, {"sha": "b999680ff1a9abf2c7f169d3c395af83baa04d29", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -86,42 +86,37 @@ impl Annotatable {\n         match *self {\n             Annotatable::Item(ref i) => &i.attrs,\n             Annotatable::TraitItem(ref i) => match *i {\n-                ast::TraitItem::RequiredMethod(ref tm) => &tm.attrs,\n-                ast::TraitItem::ProvidedMethod(ref m) => &m.attrs,\n-                ast::TraitItem::TypeTraitItem(ref at) => &at.attrs,\n+                ast::RequiredMethod(ref tm) => &tm.attrs,\n+                ast::ProvidedMethod(ref m) => &m.attrs,\n+                ast::TypeTraitItem(ref at) => &at.attrs,\n             },\n             Annotatable::ImplItem(ref i) => match *i {\n-                ast::ImplItem::MethodImplItem(ref m) => &m.attrs,\n-                ast::ImplItem::TypeImplItem(ref t) => &t.attrs,\n+                ast::MethodImplItem(ref m) => &m.attrs,\n+                ast::TypeImplItem(ref t) => &t.attrs,\n             }\n         }\n     }\n \n     pub fn fold_attrs(self, attrs: Vec<ast::Attribute>) -> Annotatable {\n         match self {\n-            Annotatable::Item(i) => Annotatable::Item(P(ast::Item {\n+            Annotatable::Item(i) => Annotatable::Item(i.map(|i| ast::Item {\n                 attrs: attrs,\n-                ..(*i).clone()\n+                ..i\n             })),\n-            Annotatable::TraitItem(i) => match i {\n-                ast::TraitItem::RequiredMethod(tm) => Annotatable::TraitItem(\n-                    ast::TraitItem::RequiredMethod(\n-                        ast::TypeMethod { attrs: attrs, ..tm })),\n-                ast::TraitItem::ProvidedMethod(m) => Annotatable::TraitItem(\n-                    ast::TraitItem::ProvidedMethod(P(\n-                        ast::Method { attrs: attrs, ..(*m).clone() }))),\n-                ast::TraitItem::TypeTraitItem(at) => Annotatable::TraitItem(\n-                    ast::TraitItem::TypeTraitItem(P(\n-                        ast::AssociatedType { attrs: attrs, ..(*at).clone() }))),\n-            },\n-            Annotatable::ImplItem(i) => match i {\n-                ast::ImplItem::MethodImplItem(m) => Annotatable::ImplItem(\n-                    ast::ImplItem::MethodImplItem(P(\n-                        ast::Method { attrs: attrs, ..(*m).clone() }))),\n-                ast::ImplItem::TypeImplItem(t) => Annotatable::ImplItem(\n-                    ast::ImplItem::TypeImplItem(P(\n-                        ast::Typedef { attrs: attrs, ..(*t).clone() }))),\n-            }\n+            Annotatable::TraitItem(i) => Annotatable::TraitItem(match i {\n+                ast::RequiredMethod(tm) =>\n+                    ast::RequiredMethod(ast::TypeMethod { attrs: attrs, ..tm }),\n+                ast::ProvidedMethod(m) =>\n+                    ast::ProvidedMethod(ast::Method { attrs: attrs, ..m }),\n+                ast::TypeTraitItem(at) =>\n+                    ast::TypeTraitItem(ast::AssociatedType { attrs: attrs, ..at }),\n+            }),\n+            Annotatable::ImplItem(i) => Annotatable::ImplItem(match i {\n+                ast::MethodImplItem(m) =>\n+                    ast::MethodImplItem(ast::Method { attrs: attrs, ..m }),\n+                ast::TypeImplItem(t) =>\n+                    ast::TypeImplItem(ast::Typedef { attrs: attrs, ..t }),\n+            })\n         }\n     }\n \n@@ -249,7 +244,7 @@ pub trait MacResult {\n     }\n \n     /// Create zero or more methods.\n-    fn make_methods(self: Box<Self>) -> Option<SmallVector<P<ast::Method>>> {\n+    fn make_methods(self: Box<Self>) -> Option<SmallVector<ast::Method>> {\n         None\n     }\n \n@@ -295,7 +290,7 @@ make_MacEager! {\n     expr: P<ast::Expr>,\n     pat: P<ast::Pat>,\n     items: SmallVector<P<ast::Item>>,\n-    methods: SmallVector<P<ast::Method>>,\n+    methods: SmallVector<ast::Method>,\n     stmt: P<ast::Stmt>,\n }\n \n@@ -308,7 +303,7 @@ impl MacResult for MacEager {\n         self.items\n     }\n \n-    fn make_methods(self: Box<Self>) -> Option<SmallVector<P<ast::Method>>> {\n+    fn make_methods(self: Box<Self>) -> Option<SmallVector<ast::Method>> {\n         self.methods\n     }\n \n@@ -397,7 +392,7 @@ impl MacResult for DummyResult {\n             Some(SmallVector::zero())\n         }\n     }\n-    fn make_methods(self: Box<DummyResult>) -> Option<SmallVector<P<ast::Method>>> {\n+    fn make_methods(self: Box<DummyResult>) -> Option<SmallVector<ast::Method>> {\n         if self.expr_only {\n             None\n         } else {"}, {"sha": "0573289150c84cd5a62c5eb51a22a97c488d5973", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -386,12 +386,12 @@ impl<'a> TraitDef<'a> {\n                            cx: &mut ExtCtxt,\n                            type_ident: Ident,\n                            generics: &Generics,\n-                           methods: Vec<P<ast::Method>>) -> P<ast::Item> {\n+                           methods: Vec<ast::Method>) -> P<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n         // Transform associated types from `deriving::ty::Ty` into `ast::Typedef`\n         let associated_types = self.associated_types.iter().map(|&(ident, ref type_def)| {\n-            P(ast::Typedef {\n+            ast::Typedef {\n                 id: ast::DUMMY_NODE_ID,\n                 span: self.span,\n                 ident: ident,\n@@ -402,7 +402,7 @@ impl<'a> TraitDef<'a> {\n                     type_ident,\n                     generics\n                 ),\n-            })\n+            }\n         });\n \n         let Generics { mut lifetimes, ty_params, mut where_clause } =\n@@ -517,7 +517,7 @@ impl<'a> TraitDef<'a> {\n                                      associated_types.map(|type_| {\n                                          ast::TypeImplItem(type_)\n                                      })\n-                                 ).collect()))\n+                                 ).map(P).collect()))\n     }\n \n     fn expand_struct_def(&self,\n@@ -702,7 +702,7 @@ impl<'a> MethodDef<'a> {\n                      abi: Abi,\n                      explicit_self: ast::ExplicitSelf,\n                      arg_types: Vec<(Ident, P<ast::Ty>)> ,\n-                     body: P<Expr>) -> P<ast::Method> {\n+                     body: P<Expr>) -> ast::Method {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n@@ -725,7 +725,7 @@ impl<'a> MethodDef<'a> {\n         let body_block = cx.block_expr(body);\n \n         // Create the method.\n-        P(ast::Method {\n+        ast::Method {\n             attrs: self.attributes.clone(),\n             id: ast::DUMMY_NODE_ID,\n             span: trait_.span,\n@@ -737,7 +737,7 @@ impl<'a> MethodDef<'a> {\n                                 fn_decl,\n                                 body_block,\n                                 ast::Inherited)\n-        })\n+        }\n     }\n \n     /// ```"}, {"sha": "96859b94f1dde2ab9205cc1627a499ae69bcb781", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -1185,7 +1185,7 @@ fn expand_annotatable(a: Annotatable,\n             }\n             ast::TraitItem::TypeTraitItem(t) => {\n                 SmallVector::one(Annotatable::TraitItem(\n-                    ast::TraitItem::TypeTraitItem(P(fld.fold_associated_type((*t).clone())))))\n+                    ast::TraitItem::TypeTraitItem(fld.fold_associated_type(t))))\n             }\n         },\n         Annotatable::ImplItem(it) => match it {\n@@ -1195,7 +1195,7 @@ fn expand_annotatable(a: Annotatable,\n             }\n             ast::ImplItem::TypeImplItem(t) => {\n                 SmallVector::one(Annotatable::ImplItem(\n-                    ast::ImplItem::TypeImplItem(P(fld.fold_typedef((*t).clone())))))\n+                    ast::ImplItem::TypeImplItem(fld.fold_typedef(t))))\n             }\n         }\n     };\n@@ -1293,8 +1293,8 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n }\n \n // expand a method\n-fn expand_method(m: P<ast::Method>, fld: &mut MacroExpander) -> SmallVector<P<ast::Method>> {\n-    m.and_then(|m| match m.node {\n+fn expand_method(m: ast::Method, fld: &mut MacroExpander) -> SmallVector<ast::Method> {\n+    match m.node {\n         ast::MethDecl(ident,\n                       generics,\n                       abi,\n@@ -1306,7 +1306,7 @@ fn expand_method(m: P<ast::Method>, fld: &mut MacroExpander) -> SmallVector<P<as\n             let id = fld.new_id(m.id);\n             let (rewritten_fn_decl, rewritten_body)\n                 = expand_and_rename_fn_decl_and_block(decl, body, fld);\n-            SmallVector::one(P(ast::Method {\n+            SmallVector::one(ast::Method {\n                     attrs: fold::fold_attrs(m.attrs, fld),\n                     id: id,\n                     span: fld.new_span(m.span),\n@@ -1318,7 +1318,7 @@ fn expand_method(m: P<ast::Method>, fld: &mut MacroExpander) -> SmallVector<P<as\n                                         rewritten_fn_decl,\n                                         rewritten_body,\n                                         vis)\n-                }))\n+                })\n         },\n         ast::MethMac(mac) => {\n             let maybe_new_methods =\n@@ -1339,7 +1339,7 @@ fn expand_method(m: P<ast::Method>, fld: &mut MacroExpander) -> SmallVector<P<as\n                 None => SmallVector::zero()\n             }\n         }\n-    })\n+    }\n }\n \n /// Given a fn_decl and a block and a MacroExpander, expand the fn_decl, then use the\n@@ -1418,7 +1418,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_impl_item(i, self)\n     }\n \n-    fn fold_method(&mut self, method: P<ast::Method>) -> SmallVector<P<ast::Method>> {\n+    fn fold_method(&mut self, method: ast::Method) -> SmallVector<ast::Method> {\n         expand_method(method, self)\n     }\n \n@@ -1565,7 +1565,7 @@ fn mark_item(expr: P<ast::Item>, m: Mrk) -> P<ast::Item> {\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_method(expr: P<ast::Method>, m: Mrk) -> P<ast::Method> {\n+fn mark_method(expr: ast::Method, m: Mrk) -> ast::Method {\n     Marker{mark:m}.fold_method(expr)\n         .expect_one(\"marking an item didn't return exactly one method\")\n }"}, {"sha": "dcdfad4632de35a4b6067061d84779066bc56f9b", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -82,7 +82,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         Some(ret)\n     }\n \n-    fn make_methods(self: Box<ParserAnyMacro<'a>>) -> Option<SmallVector<P<ast::Method>>> {\n+    fn make_methods(self: Box<ParserAnyMacro<'a>>) -> Option<SmallVector<ast::Method>> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();"}, {"sha": "5109a19fdb6f66bd482858bb2874259de044ba40", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -98,11 +98,11 @@ pub trait Folder : Sized {\n         noop_fold_item_underscore(i, self)\n     }\n \n-    fn fold_trait_item(&mut self, i: TraitItem) -> SmallVector<TraitItem> {\n+    fn fold_trait_item(&mut self, i: P<TraitItem>) -> SmallVector<P<TraitItem>> {\n         noop_fold_trait_item(i, self)\n     }\n \n-    fn fold_impl_item(&mut self, i: ImplItem) -> SmallVector<ImplItem> {\n+    fn fold_impl_item(&mut self, i: P<ImplItem>) -> SmallVector<P<ImplItem>> {\n         noop_fold_impl_item(i, self)\n     }\n \n@@ -114,7 +114,7 @@ pub trait Folder : Sized {\n         noop_fold_type_method(m, self)\n     }\n \n-    fn fold_method(&mut self, m: P<Method>) -> SmallVector<P<Method>> {\n+    fn fold_method(&mut self, m: Method) -> SmallVector<Method> {\n         noop_fold_method(m, self)\n     }\n \n@@ -1018,34 +1018,30 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n     }\n }\n \n-pub fn noop_fold_trait_item<T: Folder>(i: TraitItem, folder: &mut T) -> SmallVector<TraitItem> {\n-    match i {\n-        RequiredMethod(m) => {\n-                SmallVector::one(RequiredMethod(\n-                        folder.fold_type_method(m)))\n-        }\n+pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n+                                       -> SmallVector<P<TraitItem>> {\n+    i.map(|i| SmallVector::one(P(match i {\n+        RequiredMethod(m) => RequiredMethod(folder.fold_type_method(m)),\n         ProvidedMethod(method) => {\n-            folder.fold_method(method).into_iter()\n-                .map(|m| ProvidedMethod(m)).collect()\n+            return folder.fold_method(method).into_iter()\n+                         .map(|m| P(ProvidedMethod(m))).collect();\n         }\n         TypeTraitItem(at) => {\n-            SmallVector::one(TypeTraitItem(P(\n-                        folder.fold_associated_type(\n-                            (*at).clone()))))\n+            TypeTraitItem(folder.fold_associated_type(at))\n         }\n-    }\n+    })))\n }\n \n-pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T) -> SmallVector<ImplItem> {\n-    match i {\n-        MethodImplItem(ref x) => {\n-            folder.fold_method((*x).clone()).into_iter().map(|m| MethodImplItem(m)).collect()\n+pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T)\n+                                      -> SmallVector<P<ImplItem>> {\n+    i.and_then(|i| match i {\n+        MethodImplItem(x) => {\n+            folder.fold_method(x).into_iter().map(|m| P(MethodImplItem(m))).collect()\n         }\n-        TypeImplItem(ref t) => {\n-            SmallVector::one(TypeImplItem(\n-                    P(folder.fold_typedef((**t).clone()))))\n+        TypeImplItem(t) => {\n+            SmallVector::one(TypeImplItem(folder.fold_typedef(t)))\n         }\n-    }\n+    })\n }\n \n pub fn noop_fold_type_method<T: Folder>(m: TypeMethod, fld: &mut T) -> TypeMethod {\n@@ -1173,8 +1169,9 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) ->\n \n // Default fold over a method.\n // Invariant: produces exactly one method.\n-pub fn noop_fold_method<T: Folder>(m: P<Method>, folder: &mut T) -> SmallVector<P<Method>> {\n-    SmallVector::one(m.map(|Method {id, attrs, node, span}| Method {\n+pub fn noop_fold_method<T: Folder>(Method {id, attrs, node, span}: Method, folder: &mut T)\n+                                   -> SmallVector<Method> {\n+    SmallVector::one(Method {\n         id: folder.new_id(id),\n         attrs: fold_attrs(attrs, folder),\n         node: match node {\n@@ -1198,7 +1195,7 @@ pub fn noop_fold_method<T: Folder>(m: P<Method>, folder: &mut T) -> SmallVector<\n             MethMac(mac) => MethMac(folder.fold_mac(mac)),\n         },\n         span: folder.new_span(span)\n-    }))\n+    })\n }\n \n pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {"}, {"sha": "63c0f4e1cfa3594951478879ae1cc8662d769948", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -1307,7 +1307,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the items in a trait declaration\n-    pub fn parse_trait_items(&mut self) -> Vec<TraitItem> {\n+    pub fn parse_trait_items(&mut self) -> Vec<P<TraitItem>> {\n         self.parse_unspanned_seq(\n             &token::OpenDelim(token::Brace),\n             &token::CloseDelim(token::Brace),\n@@ -1316,7 +1316,7 @@ impl<'a> Parser<'a> {\n             let attrs = p.parse_outer_attributes();\n \n             if p.eat_keyword(keywords::Type) {\n-                TypeTraitItem(P(p.parse_associated_type(attrs)))\n+                P(TypeTraitItem(p.parse_associated_type(attrs)))\n             } else {\n                 let lo = p.span.lo;\n \n@@ -1346,7 +1346,7 @@ impl<'a> Parser<'a> {\n                   token::Semi => {\n                     p.bump();\n                     debug!(\"parse_trait_methods(): parsing required method\");\n-                    RequiredMethod(TypeMethod {\n+                    P(RequiredMethod(TypeMethod {\n                         ident: ident,\n                         attrs: attrs,\n                         unsafety: style,\n@@ -1357,15 +1357,15 @@ impl<'a> Parser<'a> {\n                         id: ast::DUMMY_NODE_ID,\n                         span: mk_sp(lo, hi),\n                         vis: vis,\n-                    })\n+                    }))\n                   }\n                   token::OpenDelim(token::Brace) => {\n                     debug!(\"parse_trait_methods(): parsing provided method\");\n                     let (inner_attrs, body) =\n                         p.parse_inner_attrs_and_block();\n                     let mut attrs = attrs;\n                     attrs.push_all(&inner_attrs[..]);\n-                    ProvidedMethod(P(ast::Method {\n+                    P(ProvidedMethod(ast::Method {\n                         attrs: attrs,\n                         id: ast::DUMMY_NODE_ID,\n                         span: mk_sp(lo, hi),\n@@ -4692,7 +4692,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a method in a trait impl\n-    pub fn parse_method_with_outer_attributes(&mut self) -> P<Method> {\n+    pub fn parse_method_with_outer_attributes(&mut self) -> Method {\n         let attrs = self.parse_outer_attributes();\n         let visa = self.parse_visibility();\n         self.parse_method(attrs, visa)\n@@ -4713,7 +4713,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_method(&mut self,\n                         attrs: Vec<Attribute>,\n                         visa: Visibility)\n-                        -> P<Method> {\n+                        -> Method {\n         let lo = self.span.lo;\n \n         // code copied from parse_macro_use_or_failure... abstraction!\n@@ -4772,12 +4772,12 @@ impl<'a> Parser<'a> {\n                  body_span.hi, new_attrs)\n             }\n         };\n-        P(ast::Method {\n+        ast::Method {\n             attrs: new_attrs,\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, hi),\n             node: method_,\n-        })\n+        }\n     }\n \n     /// Parse trait Foo { ... }\n@@ -4808,7 +4808,7 @@ impl<'a> Parser<'a> {\n         (ident, ItemTrait(unsafety, tps, bounds, meths), None)\n     }\n \n-    fn parse_impl_items(&mut self) -> (Vec<ImplItem>, Vec<Attribute>) {\n+    fn parse_impl_items(&mut self) -> (Vec<P<ImplItem>>, Vec<Attribute>) {\n         let mut impl_items = Vec::new();\n         self.expect(&token::OpenDelim(token::Brace));\n         let (inner_attrs, mut method_attrs) =\n@@ -4821,13 +4821,13 @@ impl<'a> Parser<'a> {\n \n             let vis = self.parse_visibility();\n             if self.eat_keyword(keywords::Type) {\n-                impl_items.push(TypeImplItem(P(self.parse_typedef(\n+                impl_items.push(P(TypeImplItem(self.parse_typedef(\n                             method_attrs,\n                             vis))))\n             } else {\n-                impl_items.push(MethodImplItem(self.parse_method(\n+                impl_items.push(P(MethodImplItem(self.parse_method(\n                             method_attrs,\n-                            vis)));\n+                            vis))));\n             }\n             method_attrs = vec![];\n         }"}, {"sha": "863c000dd40e521aa2f135f1d21e7481cf00210d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -12,8 +12,7 @@ pub use self::AnnNode::*;\n \n use abi;\n use ast;\n-use ast::{MethodImplItem, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n-use ast::{RequiredMethod, ProvidedMethod, TypeImplItem, TypeTraitItem};\n+use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast_util;\n use attr;\n use owned_slice::OwnedSlice;\n@@ -977,12 +976,12 @@ impl<'a> State<'a> {\n                 try!(self.bopen());\n                 try!(self.print_inner_attributes(&item.attrs));\n                 for impl_item in impl_items {\n-                    match *impl_item {\n+                    match **impl_item {\n                         ast::MethodImplItem(ref meth) => {\n-                            try!(self.print_method(&**meth));\n+                            try!(self.print_method(meth));\n                         }\n                         ast::TypeImplItem(ref typ) => {\n-                            try!(self.print_typedef(&**typ));\n+                            try!(self.print_typedef(typ));\n                         }\n                     }\n                 }\n@@ -1258,16 +1257,16 @@ impl<'a> State<'a> {\n     pub fn print_trait_method(&mut self,\n                               m: &ast::TraitItem) -> io::Result<()> {\n         match *m {\n-            RequiredMethod(ref ty_m) => self.print_ty_method(ty_m),\n-            ProvidedMethod(ref m) => self.print_method(&**m),\n-            TypeTraitItem(ref t) => self.print_associated_type(&**t),\n+            ast::RequiredMethod(ref ty_m) => self.print_ty_method(ty_m),\n+            ast::ProvidedMethod(ref m) => self.print_method(m),\n+            ast::TypeTraitItem(ref t) => self.print_associated_type(t),\n         }\n     }\n \n     pub fn print_impl_item(&mut self, ii: &ast::ImplItem) -> io::Result<()> {\n         match *ii {\n-            MethodImplItem(ref m) => self.print_method(&**m),\n-            TypeImplItem(ref td) => self.print_typedef(&**td),\n+            ast::MethodImplItem(ref m) => self.print_method(m),\n+            ast::TypeImplItem(ref td) => self.print_typedef(td),\n         }\n     }\n "}, {"sha": "4222bd58a07ea8baf67b5e9cd12737a326962d59", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98491827b920884e4ea1182dcacce2a650dde861/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=98491827b920884e4ea1182dcacce2a650dde861", "patch": "@@ -144,7 +144,7 @@ pub fn walk_inlined_item<'v,V>(visitor: &mut V, item: &'v InlinedItem)\n         IIForeign(ref i) => visitor.visit_foreign_item(&**i),\n         IITraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n         IIImplItem(_, MethodImplItem(ref m)) => {\n-            walk_method_helper(visitor, &**m)\n+            walk_method_helper(visitor, m)\n         }\n         IIImplItem(_, TypeImplItem(ref typedef)) => {\n             visitor.visit_ident(typedef.span, typedef.ident);\n@@ -294,9 +294,9 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             }\n             visitor.visit_ty(&**typ);\n             for impl_item in impl_items {\n-                match *impl_item {\n+                match **impl_item {\n                     MethodImplItem(ref method) => {\n-                        walk_method_helper(visitor, &**method)\n+                        walk_method_helper(visitor, method)\n                     }\n                     TypeImplItem(ref typedef) => {\n                         visitor.visit_ident(typedef.span, typedef.ident);\n@@ -678,7 +678,7 @@ pub fn walk_ty_method<'v, V: Visitor<'v>>(visitor: &mut V, method_type: &'v Type\n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_method: &'v TraitItem) {\n     match *trait_method {\n         RequiredMethod(ref method_type) => visitor.visit_ty_method(method_type),\n-        ProvidedMethod(ref method) => walk_method_helper(visitor, &**method),\n+        ProvidedMethod(ref method) => walk_method_helper(visitor, method),\n         TypeTraitItem(ref associated_type) => {\n             walk_ty_param(visitor, &associated_type.ty_param);\n         }"}]}