{"sha": "71006bd6545015d7ae8e4c18589812bc1f6373dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMDA2YmQ2NTQ1MDE1ZDdhZThlNGMxODU4OTgxMmJjMWY2MzczZGQ=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "root@localhost", "date": "2015-06-21T17:44:25Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "root@localhost", "date": "2015-06-21T17:58:56Z"}, "message": "StrSearcher: Use trait to specialize two way algorithm by case\n\nUse a trait to be able to implement both the fast search that skips to\neach match, and the slower search that emits `Reject` intervals\nregularly. The latter is important for uses of `next_reject`.", "tree": {"sha": "128b7b9370a47c64b91e61b870505f4442bb67af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/128b7b9370a47c64b91e61b870505f4442bb67af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71006bd6545015d7ae8e4c18589812bc1f6373dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71006bd6545015d7ae8e4c18589812bc1f6373dd", "html_url": "https://github.com/rust-lang/rust/commit/71006bd6545015d7ae8e4c18589812bc1f6373dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71006bd6545015d7ae8e4c18589812bc1f6373dd/comments", "author": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "committer": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6dd2031a363d0b46caea06ef77209f678327719", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6dd2031a363d0b46caea06ef77209f678327719", "html_url": "https://github.com/rust-lang/rust/commit/a6dd2031a363d0b46caea06ef77209f678327719"}], "stats": {"total": 190, "additions": 133, "deletions": 57}, "files": [{"sha": "6d68615a8cfd73ebb9b8328d09dec3cbef8ded78", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 133, "deletions": 57, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/71006bd6545015d7ae8e4c18589812bc1f6373dd/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71006bd6545015d7ae8e4c18589812bc1f6373dd/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=71006bd6545015d7ae8e4c18589812bc1f6373dd", "patch": "@@ -544,11 +544,7 @@ pub struct StrSearcher<'a, 'b> {\n #[derive(Clone, Debug)]\n enum StrSearcherImpl {\n     Empty(EmptyNeedle),\n-    TwoWay {\n-        last_match_fw: Option<(usize, usize)>,\n-        last_match_bw: Option<(usize, usize)>,\n-        searcher: TwoWaySearcher,\n-    }\n+    TwoWay(TwoWaySearcher),\n }\n \n #[derive(Clone, Debug)]\n@@ -576,11 +572,9 @@ impl<'a, 'b> StrSearcher<'a, 'b> {\n             StrSearcher {\n                 haystack: haystack,\n                 needle: needle,\n-                searcher: StrSearcherImpl::TwoWay {\n-                    last_match_fw: None,\n-                    last_match_bw: None,\n-                    searcher: TwoWaySearcher::new(needle.as_bytes(), haystack.len())\n-                },\n+                searcher: StrSearcherImpl::TwoWay(\n+                    TwoWaySearcher::new(needle.as_bytes(), haystack.len())\n+                ),\n             }\n         }\n     }\n@@ -606,39 +600,55 @@ unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b> {\n                     }\n                 }\n             }\n-            StrSearcherImpl::TwoWay { ref mut last_match_fw, ref mut searcher, .. } => {\n+            StrSearcherImpl::TwoWay(ref mut searcher) => {\n                 // TwoWaySearcher produces valid *Match* indices that split at char boundaries\n                 // as long as it does correct matching and that haystack and needle are\n                 // valid UTF-8\n-                // *Rejects* fall on the same indices (the intervals between matches)\n-                // so they are always on character boundaries.\n-                if let Some((a, b)) = last_match_fw.take() {\n-                    return SearchStep::Match(a, b);\n+                // *Rejects* from the algorithm can fall on any indices, but we will walk them\n+                // manually to the next character boundary, so that they are utf-8 safe.\n+                if searcher.position == self.haystack.len() {\n+                    return SearchStep::Done;\n                 }\n-                let last_pos = searcher.position;\n                 let is_long = searcher.memory == usize::MAX;\n-                let next_match = searcher.next(self.haystack.as_bytes(),\n-                                               self.needle.as_bytes(),\n-                                               is_long);\n-                match next_match {\n-                    None => if last_pos != self.haystack.len() {\n-                        SearchStep::Reject(last_pos, self.haystack.len())\n-                    } else {\n-                        SearchStep::Done\n-                    },\n-                    Some((a, b)) => {\n-                        if a == last_pos {\n-                            SearchStep::Match(a, b)\n-                        } else {\n-                            *last_match_fw = Some((a, b));\n-                            SearchStep::Reject(last_pos, a)\n+                match searcher.next::<RejectAndMatch>(self.haystack.as_bytes(),\n+                                                      self.needle.as_bytes(),\n+                                                      is_long)\n+                {\n+                    SearchStep::Reject(a, mut b) => {\n+                        // skip to next char boundary\n+                        while !self.haystack.is_char_boundary(b) {\n+                            b += 1;\n                         }\n+                        searcher.position = cmp::max(b, searcher.position);\n+                        SearchStep::Reject(a, b)\n                     }\n+                    otherwise => otherwise,\n                 }\n             }\n         }\n     }\n \n+    #[inline]\n+    fn next_match(&mut self) -> Option<(usize, usize)> {\n+        match self.searcher {\n+            StrSearcherImpl::Empty(..) => {\n+                loop {\n+                    match self.next() {\n+                        SearchStep::Match(a, b) => return Some((a, b)),\n+                        SearchStep::Done => return None,\n+                        SearchStep::Reject(..) => { }\n+                    }\n+                }\n+            }\n+            StrSearcherImpl::TwoWay(ref mut searcher) => {\n+                let is_long = searcher.memory == usize::MAX;\n+                searcher.next::<MatchOnly>(self.haystack.as_bytes(),\n+                                           self.needle.as_bytes(),\n+                                           is_long)\n+            }\n+        }\n+    }\n+\n }\n unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> {\n     #[inline]\n@@ -657,31 +667,45 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> {\n                     }\n                 }\n             }\n-            StrSearcherImpl::TwoWay { ref mut last_match_bw, ref mut searcher, .. } => {\n-                if let Some((a, b)) = last_match_bw.take() {\n-                    return SearchStep::Match(a, b);\n+            StrSearcherImpl::TwoWay(ref mut searcher) => {\n+                if searcher.end == 0 {\n+                    return SearchStep::Done;\n                 }\n-                let last_end = searcher.end;\n-                let next_match = searcher.next_back(self.haystack.as_bytes(),\n-                                                    self.needle.as_bytes());\n-                match next_match {\n-                    None => if last_end != 0 {\n-                        SearchStep::Reject(0, last_end)\n-                    } else {\n-                        SearchStep::Done\n-                    },\n-                    Some((a, b)) => {\n-                        if b == last_end {\n-                            SearchStep::Match(a, b)\n-                        } else {\n-                            *last_match_bw = Some((a, b));\n-                            SearchStep::Reject(b, last_end)\n+                match searcher.next_back::<RejectAndMatch>(self.haystack.as_bytes(),\n+                                                           self.needle.as_bytes())\n+                {\n+                    SearchStep::Reject(mut a, b) => {\n+                        // skip to next char boundary\n+                        while !self.haystack.is_char_boundary(a) {\n+                            a -= 1;\n                         }\n+                        searcher.end = cmp::min(a, searcher.end);\n+                        SearchStep::Reject(a, b)\n                     }\n+                    otherwise => otherwise,\n                 }\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn next_match_back(&mut self) -> Option<(usize, usize)> {\n+        match self.searcher {\n+            StrSearcherImpl::Empty(..) => {\n+                loop {\n+                    match self.next_back() {\n+                        SearchStep::Match(a, b) => return Some((a, b)),\n+                        SearchStep::Done => return None,\n+                        SearchStep::Reject(..) => { }\n+                    }\n+                }\n+            }\n+            StrSearcherImpl::TwoWay(ref mut searcher) => {\n+                searcher.next_back::<MatchOnly>(self.haystack.as_bytes(),\n+                                                self.needle.as_bytes())\n+            }\n+        }\n+    }\n }\n \n /// The internal state of an iterator that searches for matches of a substring\n@@ -831,14 +855,21 @@ impl TwoWaySearcher {\n     // How far we can jump when we encounter a mismatch is all based on the fact\n     // that (u, v) is a critical factorization for the needle.\n     #[inline]\n-    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n-            -> Option<(usize, usize)> {\n+    fn next<S>(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n+        -> S::Output\n+        where S: TwoWayStrategy\n+    {\n         // `next()` uses `self.position` as its cursor\n+        let old_pos = self.position;\n         'search: loop {\n             // Check that we have room to search in\n-            if self.position + needle.len() > haystack.len() {\n+            if needle.len() > haystack.len() - self.position {\n                 self.position = haystack.len();\n-                return None;\n+                return S::rejecting(old_pos, self.position);\n+            }\n+\n+            if S::use_early_reject() && old_pos != self.position {\n+                return S::rejecting(old_pos, self.position);\n             }\n \n             // Quickly skip by large portions unrelated to our substring\n@@ -884,7 +915,7 @@ impl TwoWaySearcher {\n                 self.memory = 0; // set to needle.len() - self.period for overlapping matches\n             }\n \n-            return Some((match_pos, match_pos + needle.len()));\n+            return S::matching(match_pos, match_pos + needle.len());\n         }\n     }\n \n@@ -902,14 +933,22 @@ impl TwoWaySearcher {\n     // a reversed haystack with a reversed needle, and the above paragraph shows\n     // that the precomputed parameters can be left alone.\n     #[inline]\n-    fn next_back(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(usize, usize)> {\n+    fn next_back<S>(&mut self, haystack: &[u8], needle: &[u8])\n+        -> S::Output\n+        where S: TwoWayStrategy\n+    {\n         // `next_back()` uses `self.end` as its cursor -- so that `next()` and `next_back()`\n         // are independent.\n+        let old_end = self.end;\n         'search: loop {\n             // Check that we have room to search in\n             if needle.len() > self.end {\n                 self.end = 0;\n-                return None;\n+                return S::rejecting(0, old_end);\n+            }\n+\n+            if S::use_early_reject() && old_end != self.end {\n+                return S::rejecting(self.end, old_end);\n             }\n \n             // Quickly skip by large portions unrelated to our substring\n@@ -939,7 +978,7 @@ impl TwoWaySearcher {\n             // Note: sub self.period instead of needle.len() to have overlapping matches\n             self.end -= needle.len();\n \n-            return Some((match_pos, match_pos + needle.len()));\n+            return S::matching(match_pos, match_pos + needle.len());\n         }\n     }\n \n@@ -987,3 +1026,40 @@ impl TwoWaySearcher {\n         (left.wrapping_add(1), period)\n     }\n }\n+\n+// TwoWayStrategy allows the algorithm to either skip non-matches as quickly\n+// as possible, or to work in a mode where it emits Rejects relatively quickly.\n+trait TwoWayStrategy {\n+    type Output;\n+    fn use_early_reject() -> bool;\n+    fn rejecting(usize, usize) -> Self::Output;\n+    fn matching(usize, usize) -> Self::Output;\n+}\n+\n+/// Skip to match intervals as quickly as possible\n+enum MatchOnly { }\n+\n+impl TwoWayStrategy for MatchOnly {\n+    type Output = Option<(usize, usize)>;\n+\n+    #[inline]\n+    fn use_early_reject() -> bool { false }\n+    #[inline]\n+    fn rejecting(_a: usize, _b: usize) -> Self::Output { None }\n+    #[inline]\n+    fn matching(a: usize, b: usize) -> Self::Output { Some((a, b)) }\n+}\n+\n+/// Emit Rejects regularly\n+enum RejectAndMatch { }\n+\n+impl TwoWayStrategy for RejectAndMatch {\n+    type Output = SearchStep;\n+\n+    #[inline]\n+    fn use_early_reject() -> bool { true }\n+    #[inline]\n+    fn rejecting(a: usize, b: usize) -> Self::Output { SearchStep::Reject(a, b) }\n+    #[inline]\n+    fn matching(a: usize, b: usize) -> Self::Output { SearchStep::Match(a, b) }\n+}"}]}