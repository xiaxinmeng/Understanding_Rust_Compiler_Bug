{"sha": "e09e45041b5cab9d849b554824c6683de6372e41", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwOWU0NTA0MWI1Y2FiOWQ4NDliNTU0ODI0YzY2ODNkZTYzNzJlNDE=", "commit": {"author": {"name": "Sebastian Dr\u00f6ge", "email": "sebastian@centricular.com", "date": "2018-09-24T19:43:06Z"}, "committer": {"name": "Sebastian Dr\u00f6ge", "email": "sebastian@centricular.com", "date": "2018-09-24T19:43:06Z"}, "message": "Rename slice::exact_chunks() to slice::chunks_exact()\n\nSee https://github.com/rust-lang/rust/issues/47115#issuecomment-403090815\nand https://github.com/rust-lang/rust/issues/47115#issuecomment-424053547", "tree": {"sha": "679312b6a8193f610e4d8e84c15c05298353c4f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/679312b6a8193f610e4d8e84c15c05298353c4f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e09e45041b5cab9d849b554824c6683de6372e41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e09e45041b5cab9d849b554824c6683de6372e41", "html_url": "https://github.com/rust-lang/rust/commit/e09e45041b5cab9d849b554824c6683de6372e41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e09e45041b5cab9d849b554824c6683de6372e41/comments", "author": {"login": "sdroege", "id": 301846, "node_id": "MDQ6VXNlcjMwMTg0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/301846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sdroege", "html_url": "https://github.com/sdroege", "followers_url": "https://api.github.com/users/sdroege/followers", "following_url": "https://api.github.com/users/sdroege/following{/other_user}", "gists_url": "https://api.github.com/users/sdroege/gists{/gist_id}", "starred_url": "https://api.github.com/users/sdroege/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sdroege/subscriptions", "organizations_url": "https://api.github.com/users/sdroege/orgs", "repos_url": "https://api.github.com/users/sdroege/repos", "events_url": "https://api.github.com/users/sdroege/events{/privacy}", "received_events_url": "https://api.github.com/users/sdroege/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sdroege", "id": 301846, "node_id": "MDQ6VXNlcjMwMTg0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/301846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sdroege", "html_url": "https://github.com/sdroege", "followers_url": "https://api.github.com/users/sdroege/followers", "following_url": "https://api.github.com/users/sdroege/following{/other_user}", "gists_url": "https://api.github.com/users/sdroege/gists{/gist_id}", "starred_url": "https://api.github.com/users/sdroege/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sdroege/subscriptions", "organizations_url": "https://api.github.com/users/sdroege/orgs", "repos_url": "https://api.github.com/users/sdroege/repos", "events_url": "https://api.github.com/users/sdroege/events{/privacy}", "received_events_url": "https://api.github.com/users/sdroege/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a072d1bca6282d1d2fbec103d12393527eb5a868", "url": "https://api.github.com/repos/rust-lang/rust/commits/a072d1bca6282d1d2fbec103d12393527eb5a868", "html_url": "https://github.com/rust-lang/rust/commit/a072d1bca6282d1d2fbec103d12393527eb5a868"}], "stats": {"total": 154, "additions": 77, "deletions": 77}, "files": [{"sha": "63ab5043ec51b61b668bf0b86df5d4db071309f5", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e09e45041b5cab9d849b554824c6683de6372e41/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09e45041b5cab9d849b554824c6683de6372e41/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=e09e45041b5cab9d849b554824c6683de6372e41", "patch": "@@ -116,7 +116,7 @@\n #![feature(unsize)]\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]\n-#![feature(exact_chunks)]\n+#![feature(chunks_exact)]\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n #![feature(maybe_uninit)]"}, {"sha": "22c15fd8a519f8ddfd7d03dcf19c6fc41f62e9e6", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e09e45041b5cab9d849b554824c6683de6372e41/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09e45041b5cab9d849b554824c6683de6372e41/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=e09e45041b5cab9d849b554824c6683de6372e41", "patch": "@@ -123,7 +123,7 @@ pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n pub use core::slice::{from_ref, from_mut};\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n pub use core::slice::SliceIndex;\n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n pub use core::slice::{ExactChunks, ExactChunksMut};\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "6ff39227555fe179872fd8597071228679b73885", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e09e45041b5cab9d849b554824c6683de6372e41/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09e45041b5cab9d849b554824c6683de6372e41/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=e09e45041b5cab9d849b554824c6683de6372e41", "patch": "@@ -20,7 +20,7 @@\n #![feature(str_escape)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n-#![feature(exact_chunks)]\n+#![feature(chunks_exact)]\n #![feature(repeat_generic_slice)]\n \n extern crate alloc_system;"}, {"sha": "c214c59618d3eb06d07849902fa1f23af16ca051", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e09e45041b5cab9d849b554824c6683de6372e41/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09e45041b5cab9d849b554824c6683de6372e41/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=e09e45041b5cab9d849b554824c6683de6372e41", "patch": "@@ -975,27 +975,27 @@ fn test_chunksator_0() {\n }\n \n #[test]\n-fn test_exact_chunksator() {\n+fn test_chunks_exactator() {\n     let v = &[1, 2, 3, 4, 5];\n \n-    assert_eq!(v.exact_chunks(2).len(), 2);\n+    assert_eq!(v.chunks_exact(2).len(), 2);\n \n     let chunks: &[&[_]] = &[&[1, 2], &[3, 4]];\n-    assert_eq!(v.exact_chunks(2).collect::<Vec<_>>(), chunks);\n+    assert_eq!(v.chunks_exact(2).collect::<Vec<_>>(), chunks);\n     let chunks: &[&[_]] = &[&[1, 2, 3]];\n-    assert_eq!(v.exact_chunks(3).collect::<Vec<_>>(), chunks);\n+    assert_eq!(v.chunks_exact(3).collect::<Vec<_>>(), chunks);\n     let chunks: &[&[_]] = &[];\n-    assert_eq!(v.exact_chunks(6).collect::<Vec<_>>(), chunks);\n+    assert_eq!(v.chunks_exact(6).collect::<Vec<_>>(), chunks);\n \n     let chunks: &[&[_]] = &[&[3, 4], &[1, 2]];\n-    assert_eq!(v.exact_chunks(2).rev().collect::<Vec<_>>(), chunks);\n+    assert_eq!(v.chunks_exact(2).rev().collect::<Vec<_>>(), chunks);\n }\n \n #[test]\n #[should_panic]\n-fn test_exact_chunksator_0() {\n+fn test_chunks_exactator_0() {\n     let v = &[1, 2, 3, 4];\n-    let _it = v.exact_chunks(0);\n+    let _it = v.chunks_exact(0);\n }\n \n #[test]\n@@ -1235,10 +1235,10 @@ fn test_mut_chunks_0() {\n }\n \n #[test]\n-fn test_mut_exact_chunks() {\n+fn test_mut_chunks_exact() {\n     let mut v = [0, 1, 2, 3, 4, 5, 6];\n-    assert_eq!(v.exact_chunks_mut(2).len(), 3);\n-    for (i, chunk) in v.exact_chunks_mut(3).enumerate() {\n+    assert_eq!(v.chunks_exact_mut(2).len(), 3);\n+    for (i, chunk) in v.chunks_exact_mut(3).enumerate() {\n         for x in chunk {\n             *x = i as u8;\n         }\n@@ -1248,9 +1248,9 @@ fn test_mut_exact_chunks() {\n }\n \n #[test]\n-fn test_mut_exact_chunks_rev() {\n+fn test_mut_chunks_exact_rev() {\n     let mut v = [0, 1, 2, 3, 4, 5, 6];\n-    for (i, chunk) in v.exact_chunks_mut(3).rev().enumerate() {\n+    for (i, chunk) in v.chunks_exact_mut(3).rev().enumerate() {\n         for x in chunk {\n             *x = i as u8;\n         }\n@@ -1261,9 +1261,9 @@ fn test_mut_exact_chunks_rev() {\n \n #[test]\n #[should_panic]\n-fn test_mut_exact_chunks_0() {\n+fn test_mut_chunks_exact_0() {\n     let mut v = [1, 2, 3, 4];\n-    let _it = v.exact_chunks_mut(0);\n+    let _it = v.chunks_exact_mut(0);\n }\n \n #[test]"}, {"sha": "68cefe4b6a8a73fe41891bdab12181f6a6555ce0", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e09e45041b5cab9d849b554824c6683de6372e41/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09e45041b5cab9d849b554824c6683de6372e41/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=e09e45041b5cab9d849b554824c6683de6372e41", "patch": "@@ -624,7 +624,7 @@ impl<T> [T] {\n     /// not divide the length of the slice, then the last chunk will\n     /// not have length `chunk_size`.\n     ///\n-    /// See [`exact_chunks`] for a variant of this iterator that returns chunks\n+    /// See [`chunks_exact`] for a variant of this iterator that returns chunks\n     /// of always exactly `chunk_size` elements.\n     ///\n     /// # Panics\n@@ -642,7 +642,7 @@ impl<T> [T] {\n     /// assert!(iter.next().is_none());\n     /// ```\n     ///\n-    /// [`exact_chunks`]: #method.exact_chunks\n+    /// [`chunks_exact`]: #method.chunks_exact\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n@@ -655,7 +655,7 @@ impl<T> [T] {\n     /// not divide the length of the slice, then the last chunk will not\n     /// have length `chunk_size`.\n     ///\n-    /// See [`exact_chunks_mut`] for a variant of this iterator that returns chunks\n+    /// See [`chunks_exact_mut`] for a variant of this iterator that returns chunks\n     /// of always exactly `chunk_size` elements.\n     ///\n     /// # Panics\n@@ -677,7 +677,7 @@ impl<T> [T] {\n     /// assert_eq!(v, &[1, 1, 2, 2, 3]);\n     /// ```\n     ///\n-    /// [`exact_chunks_mut`]: #method.exact_chunks_mut\n+    /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n@@ -702,19 +702,19 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(exact_chunks)]\n+    /// #![feature(chunks_exact)]\n     ///\n     /// let slice = ['l', 'o', 'r', 'e', 'm'];\n-    /// let mut iter = slice.exact_chunks(2);\n+    /// let mut iter = slice.chunks_exact(2);\n     /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n     /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n     /// assert!(iter.next().is_none());\n     /// ```\n     ///\n     /// [`chunks`]: #method.chunks\n-    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    #[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n     #[inline]\n-    pub fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n+    pub fn chunks_exact(&self, chunk_size: usize) -> ExactChunks<T> {\n         assert!(chunk_size != 0);\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n@@ -739,12 +739,12 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(exact_chunks)]\n+    /// #![feature(chunks_exact)]\n     ///\n     /// let v = &mut [0, 0, 0, 0, 0];\n     /// let mut count = 1;\n     ///\n-    /// for chunk in v.exact_chunks_mut(2) {\n+    /// for chunk in v.chunks_exact_mut(2) {\n     ///     for elem in chunk.iter_mut() {\n     ///         *elem += count;\n     ///     }\n@@ -754,9 +754,9 @@ impl<T> [T] {\n     /// ```\n     ///\n     /// [`chunks_mut`]: #method.chunks_mut\n-    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    #[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n     #[inline]\n-    pub fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n+    pub fn chunks_exact_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n         assert!(chunk_size != 0);\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n@@ -3657,20 +3657,20 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n /// up to `chunk_size-1` elements will be omitted but can be retrieved from\n /// the [`remainder`] function from the iterator.\n ///\n-/// This struct is created by the [`exact_chunks`] method on [slices].\n+/// This struct is created by the [`chunks_exact`] method on [slices].\n ///\n-/// [`exact_chunks`]: ../../std/primitive.slice.html#method.exact_chunks\n+/// [`chunks_exact`]: ../../std/primitive.slice.html#method.chunks_exact\n /// [`remainder`]: ../../std/slice/struct.ExactChunks.html#method.remainder\n /// [slices]: ../../std/primitive.slice.html\n #[derive(Debug)]\n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n pub struct ExactChunks<'a, T:'a> {\n     v: &'a [T],\n     rem: &'a [T],\n     chunk_size: usize\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n impl<'a, T> ExactChunks<'a, T> {\n     /// Return the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n@@ -3681,7 +3681,7 @@ impl<'a, T> ExactChunks<'a, T> {\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n impl<'a, T> Clone for ExactChunks<'a, T> {\n     fn clone(&self) -> ExactChunks<'a, T> {\n         ExactChunks {\n@@ -3692,7 +3692,7 @@ impl<'a, T> Clone for ExactChunks<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n impl<'a, T> Iterator for ExactChunks<'a, T> {\n     type Item = &'a [T];\n \n@@ -3737,7 +3737,7 @@ impl<'a, T> Iterator for ExactChunks<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n impl<'a, T> DoubleEndedIterator for ExactChunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -3751,7 +3751,7 @@ impl<'a, T> DoubleEndedIterator for ExactChunks<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n impl<'a, T> ExactSizeIterator for ExactChunks<'a, T> {\n     fn is_empty(&self) -> bool {\n         self.v.is_empty()\n@@ -3761,7 +3761,7 @@ impl<'a, T> ExactSizeIterator for ExactChunks<'a, T> {\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, T> TrustedLen for ExactChunks<'a, T> {}\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n impl<'a, T> FusedIterator for ExactChunks<'a, T> {}\n \n #[doc(hidden)]\n@@ -3780,20 +3780,20 @@ unsafe impl<'a, T> TrustedRandomAccess for ExactChunks<'a, T> {\n /// `chunk_size-1` elements will be omitted but can be retrieved from the\n /// [`into_remainder`] function from the iterator.\n ///\n-/// This struct is created by the [`exact_chunks_mut`] method on [slices].\n+/// This struct is created by the [`chunks_exact_mut`] method on [slices].\n ///\n-/// [`exact_chunks_mut`]: ../../std/primitive.slice.html#method.exact_chunks_mut\n+/// [`chunks_exact_mut`]: ../../std/primitive.slice.html#method.chunks_exact_mut\n /// [`into_remainder`]: ../../std/slice/struct.ExactChunksMut.html#method.into_remainder\n /// [slices]: ../../std/primitive.slice.html\n #[derive(Debug)]\n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n pub struct ExactChunksMut<'a, T:'a> {\n     v: &'a mut [T],\n     rem: &'a mut [T],\n     chunk_size: usize\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n impl<'a, T> ExactChunksMut<'a, T> {\n     /// Return the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n@@ -3803,7 +3803,7 @@ impl<'a, T> ExactChunksMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n impl<'a, T> Iterator for ExactChunksMut<'a, T> {\n     type Item = &'a mut [T];\n \n@@ -3850,7 +3850,7 @@ impl<'a, T> Iterator for ExactChunksMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n impl<'a, T> DoubleEndedIterator for ExactChunksMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n@@ -3866,7 +3866,7 @@ impl<'a, T> DoubleEndedIterator for ExactChunksMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n impl<'a, T> ExactSizeIterator for ExactChunksMut<'a, T> {\n     fn is_empty(&self) -> bool {\n         self.v.is_empty()\n@@ -3876,7 +3876,7 @@ impl<'a, T> ExactSizeIterator for ExactChunksMut<'a, T> {\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, T> TrustedLen for ExactChunksMut<'a, T> {}\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n impl<'a, T> FusedIterator for ExactChunksMut<'a, T> {}\n \n #[doc(hidden)]"}, {"sha": "97e5a5cee39d8691ac638a2217941e43f5e05b6f", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e09e45041b5cab9d849b554824c6683de6372e41/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09e45041b5cab9d849b554824c6683de6372e41/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=e09e45041b5cab9d849b554824c6683de6372e41", "patch": "@@ -33,7 +33,7 @@\n #![feature(trusted_len)]\n #![feature(try_from)]\n #![feature(try_trait)]\n-#![feature(exact_chunks)]\n+#![feature(chunks_exact)]\n #![feature(align_offset)]\n #![feature(reverse_bits)]\n #![feature(inner_deref)]"}, {"sha": "b82ffb60b8955d8d0371032890de0ef5db36ae0e", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e09e45041b5cab9d849b554824c6683de6372e41/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09e45041b5cab9d849b554824c6683de6372e41/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=e09e45041b5cab9d849b554824c6683de6372e41", "patch": "@@ -221,115 +221,115 @@ fn test_chunks_mut_zip() {\n }\n \n #[test]\n-fn test_exact_chunks_count() {\n+fn test_chunks_exact_count() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n-    let c = v.exact_chunks(3);\n+    let c = v.chunks_exact(3);\n     assert_eq!(c.count(), 2);\n \n     let v2: &[i32] = &[0, 1, 2, 3, 4];\n-    let c2 = v2.exact_chunks(2);\n+    let c2 = v2.chunks_exact(2);\n     assert_eq!(c2.count(), 2);\n \n     let v3: &[i32] = &[];\n-    let c3 = v3.exact_chunks(2);\n+    let c3 = v3.chunks_exact(2);\n     assert_eq!(c3.count(), 0);\n }\n \n #[test]\n-fn test_exact_chunks_nth() {\n+fn test_chunks_exact_nth() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n-    let mut c = v.exact_chunks(2);\n+    let mut c = v.chunks_exact(2);\n     assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n     assert_eq!(c.next().unwrap(), &[4, 5]);\n \n     let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n-    let mut c2 = v2.exact_chunks(3);\n+    let mut c2 = v2.chunks_exact(3);\n     assert_eq!(c2.nth(1).unwrap(), &[3, 4, 5]);\n     assert_eq!(c2.next(), None);\n }\n \n #[test]\n-fn test_exact_chunks_last() {\n+fn test_chunks_exact_last() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n-    let c = v.exact_chunks(2);\n+    let c = v.chunks_exact(2);\n     assert_eq!(c.last().unwrap(), &[4, 5]);\n \n     let v2: &[i32] = &[0, 1, 2, 3, 4];\n-    let c2 = v2.exact_chunks(2);\n+    let c2 = v2.chunks_exact(2);\n     assert_eq!(c2.last().unwrap(), &[2, 3]);\n }\n \n #[test]\n-fn test_exact_chunks_remainder() {\n+fn test_chunks_exact_remainder() {\n     let v: &[i32] = &[0, 1, 2, 3, 4];\n-    let c = v.exact_chunks(2);\n+    let c = v.chunks_exact(2);\n     assert_eq!(c.remainder(), &[4]);\n }\n \n #[test]\n-fn test_exact_chunks_zip() {\n+fn test_chunks_exact_zip() {\n     let v1: &[i32] = &[0, 1, 2, 3, 4];\n     let v2: &[i32] = &[6, 7, 8, 9, 10];\n \n-    let res = v1.exact_chunks(2)\n-        .zip(v2.exact_chunks(2))\n+    let res = v1.chunks_exact(2)\n+        .zip(v2.chunks_exact(2))\n         .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n         .collect::<Vec<_>>();\n     assert_eq!(res, vec![14, 22]);\n }\n \n #[test]\n-fn test_exact_chunks_mut_count() {\n+fn test_chunks_exact_mut_count() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n-    let c = v.exact_chunks_mut(3);\n+    let c = v.chunks_exact_mut(3);\n     assert_eq!(c.count(), 2);\n \n     let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n-    let c2 = v2.exact_chunks_mut(2);\n+    let c2 = v2.chunks_exact_mut(2);\n     assert_eq!(c2.count(), 2);\n \n     let v3: &mut [i32] = &mut [];\n-    let c3 = v3.exact_chunks_mut(2);\n+    let c3 = v3.chunks_exact_mut(2);\n     assert_eq!(c3.count(), 0);\n }\n \n #[test]\n-fn test_exact_chunks_mut_nth() {\n+fn test_chunks_exact_mut_nth() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n-    let mut c = v.exact_chunks_mut(2);\n+    let mut c = v.chunks_exact_mut(2);\n     assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n     assert_eq!(c.next().unwrap(), &[4, 5]);\n \n     let v2: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n-    let mut c2 = v2.exact_chunks_mut(3);\n+    let mut c2 = v2.chunks_exact_mut(3);\n     assert_eq!(c2.nth(1).unwrap(), &[3, 4, 5]);\n     assert_eq!(c2.next(), None);\n }\n \n #[test]\n-fn test_exact_chunks_mut_last() {\n+fn test_chunks_exact_mut_last() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n-    let c = v.exact_chunks_mut(2);\n+    let c = v.chunks_exact_mut(2);\n     assert_eq!(c.last().unwrap(), &[4, 5]);\n \n     let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n-    let c2 = v2.exact_chunks_mut(2);\n+    let c2 = v2.chunks_exact_mut(2);\n     assert_eq!(c2.last().unwrap(), &[2, 3]);\n }\n \n #[test]\n-fn test_exact_chunks_mut_remainder() {\n+fn test_chunks_exact_mut_remainder() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4];\n-    let c = v.exact_chunks_mut(2);\n+    let c = v.chunks_exact_mut(2);\n     assert_eq!(c.into_remainder(), &[4]);\n }\n \n #[test]\n-fn test_exact_chunks_mut_zip() {\n+fn test_chunks_exact_mut_zip() {\n     let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n     let v2: &[i32] = &[6, 7, 8, 9, 10];\n \n-    for (a, b) in v1.exact_chunks_mut(2).zip(v2.exact_chunks(2)) {\n+    for (a, b) in v1.chunks_exact_mut(2).zip(v2.chunks_exact(2)) {\n         let sum = b.iter().sum::<i32>();\n         for v in a {\n             *v += sum;"}]}