{"sha": "b023fcca3267fff93d91d559d3096e2defbc39fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMjNmY2NhMzI2N2ZmZjkzZDkxZDU1OWQzMDk2ZTJkZWZiYzM5ZmU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-11T19:21:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-12T18:05:28Z"}, "message": "move checking for unsized target type into `cast`\n\nIt is odd to have this logic strewn about.  This also means that all\ncalls to `type_is_known_to_be_sized` are encapsulated in the\ncast code, in case we want to update that logic.", "tree": {"sha": "53a974842642862b54fc0a62d5361cd7d0cf40fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53a974842642862b54fc0a62d5361cd7d0cf40fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b023fcca3267fff93d91d559d3096e2defbc39fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b023fcca3267fff93d91d559d3096e2defbc39fe", "html_url": "https://github.com/rust-lang/rust/commit/b023fcca3267fff93d91d559d3096e2defbc39fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b023fcca3267fff93d91d559d3096e2defbc39fe/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4e0e6bbf5835afc69ab5df383097a1d7b8293c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4e0e6bbf5835afc69ab5df383097a1d7b8293c5", "html_url": "https://github.com/rust-lang/rust/commit/a4e0e6bbf5835afc69ab5df383097a1d7b8293c5"}], "stats": {"total": 202, "additions": 104, "deletions": 98}, "files": [{"sha": "1765f5dc2f207a9dd328df21d218a7fe14a5ad54", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 96, "deletions": 25, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/b023fcca3267fff93d91d559d3096e2defbc39fe/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b023fcca3267fff93d91d559d3096e2defbc39fe/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=b023fcca3267fff93d91d559d3096e2defbc39fe", "patch": "@@ -45,19 +45,21 @@ use super::structurally_resolved_type;\n \n use lint;\n use hir::def_id::DefId;\n+use rustc::hir;\n+use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::cast::{CastKind, CastTy};\n-use syntax::codemap::Span;\n-use rustc::hir;\n use syntax::ast;\n-\n+use syntax::codemap::Span;\n+use util::common::ErrorReported;\n \n /// Reifies a cast check to be checked once we have full type information for\n /// a function context.\n pub struct CastCheck<'tcx> {\n     expr: &'tcx hir::Expr,\n     expr_ty: Ty<'tcx>,\n     cast_ty: Ty<'tcx>,\n+    cast_span: Span,\n     span: Span,\n }\n \n@@ -111,37 +113,35 @@ enum CastError {\n }\n \n impl<'tcx> CastCheck<'tcx> {\n-    pub fn new(expr: &'tcx hir::Expr, expr_ty: Ty<'tcx>, cast_ty: Ty<'tcx>, span: Span)\n-               -> CastCheck<'tcx> {\n-        CastCheck {\n+    pub fn new<'a>(fcx: &FnCtxt<'a, 'tcx>,\n+                   expr: &'tcx hir::Expr,\n+                   expr_ty: Ty<'tcx>,\n+                   cast_ty: Ty<'tcx>,\n+                   cast_span: Span,\n+                   span: Span)\n+                   -> Result<CastCheck<'tcx>, ErrorReported> {\n+        let check = CastCheck {\n             expr: expr,\n             expr_ty: expr_ty,\n             cast_ty: cast_ty,\n+            cast_span: cast_span,\n             span: span,\n+        };\n+\n+        // For better error messages, we try to check whether the\n+        // target type is known to be sized now (we will also check\n+        // later, once inference is more complete done).\n+        if !fcx.type_is_known_to_be_sized(cast_ty, span) {\n+            check.report_cast_to_unsized_type(fcx);\n+            return Err(ErrorReported);\n         }\n+\n+        Ok(check)\n     }\n \n     fn report_cast_error<'a>(&self,\n                              fcx: &FnCtxt<'a, 'tcx>,\n                              e: CastError) {\n-        // As a heuristic, don't report errors if there are unresolved\n-        // inference variables floating around AND we've already\n-        // reported some errors in this fn. It happens often that those\n-        // inference variables are unresolved precisely *because* of\n-        // the errors we've already reported. See #31997.\n-        //\n-        // Note: it's kind of annoying that we need this. Fallback is\n-        // modified to push all unresolved inference variables to\n-        // ty-err, but it's STILL possible to see fallback for\n-        // integral/float variables, because those cannot be unified\n-        // with ty-error.\n-        if\n-            fcx.infcx().is_tainted_by_errors() &&\n-            (self.cast_ty.has_infer_types() || self.expr_ty.has_infer_types())\n-        {\n-            return;\n-        }\n-\n         match e {\n             CastError::NeedViaPtr |\n             CastError::NeedViaThinPtr |\n@@ -205,6 +205,61 @@ impl<'tcx> CastCheck<'tcx> {\n         }\n     }\n \n+    fn report_cast_to_unsized_type<'a>(&self,\n+                                       fcx: &FnCtxt<'a, 'tcx>) {\n+        if\n+            self.cast_ty.references_error() ||\n+            self.expr_ty.references_error()\n+        {\n+            return;\n+        }\n+\n+        let tstr = fcx.infcx().ty_to_string(self.cast_ty);\n+        let mut err = fcx.type_error_struct(self.span, |actual| {\n+            format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n+        }, self.expr_ty, None);\n+        match self.expr_ty.sty {\n+            ty::TyRef(_, ty::TypeAndMut { mutbl: mt, .. }) => {\n+                let mtstr = match mt {\n+                    hir::MutMutable => \"mut \",\n+                    hir::MutImmutable => \"\"\n+                };\n+                if self.cast_ty.is_trait() {\n+                    match fcx.tcx().sess.codemap().span_to_snippet(self.cast_span) {\n+                        Ok(s) => {\n+                            err.span_suggestion(self.cast_span,\n+                                                \"try casting to a reference instead:\",\n+                                                format!(\"&{}{}\", mtstr, s));\n+                        },\n+                        Err(_) =>\n+                            span_help!(err, self.cast_span,\n+                                       \"did you mean `&{}{}`?\", mtstr, tstr),\n+                    }\n+                } else {\n+                    span_help!(err, self.span,\n+                               \"consider using an implicit coercion to `&{}{}` instead\",\n+                               mtstr, tstr);\n+                }\n+            }\n+            ty::TyBox(..) => {\n+                match fcx.tcx().sess.codemap().span_to_snippet(self.cast_span) {\n+                    Ok(s) => {\n+                        err.span_suggestion(self.cast_span,\n+                                            \"try casting to a `Box` instead:\",\n+                                            format!(\"Box<{}>\", s));\n+                    },\n+                    Err(_) =>\n+                        span_help!(err, self.cast_span, \"did you mean `Box<{}>`?\", tstr),\n+                }\n+            }\n+            _ => {\n+                span_help!(err, self.expr.span,\n+                           \"consider using a box or reference as appropriate\");\n+            }\n+        }\n+        err.emit();\n+    }\n+\n     fn trivial_cast_lint<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) {\n         let t_cast = self.cast_ty;\n         let t_expr = self.expr_ty;\n@@ -237,7 +292,9 @@ impl<'tcx> CastCheck<'tcx> {\n         debug!(\"check_cast({}, {:?} as {:?})\", self.expr.id, self.expr_ty,\n                self.cast_ty);\n \n-        if self.expr_ty.references_error() || self.cast_ty.references_error() {\n+        if !fcx.type_is_known_to_be_sized(self.cast_ty, self.span) {\n+            self.report_cast_to_unsized_type(fcx);\n+        } else if self.expr_ty.references_error() || self.cast_ty.references_error() {\n             // No sense in giving duplicate error messages\n         } else if self.try_coercion_cast(fcx) {\n             self.trivial_cast_lint(fcx);\n@@ -422,3 +479,17 @@ impl<'tcx> CastCheck<'tcx> {\n     }\n \n }\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    fn type_is_known_to_be_sized(&self,\n+                                 ty: Ty<'tcx>,\n+                                 span: Span)\n+                                 -> bool\n+    {\n+        traits::type_known_to_meet_builtin_bound(self.infcx(),\n+                                                 ty,\n+                                                 ty::BoundSized,\n+                                                 span)\n+    }\n+}\n+"}, {"sha": "16d6aca07b5359ce9b732e665c2d044141fd9395", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 73, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b023fcca3267fff93d91d559d3096e2defbc39fe/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b023fcca3267fff93d91d559d3096e2defbc39fe/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b023fcca3267fff93d91d559d3096e2defbc39fe", "patch": "@@ -1076,64 +1076,6 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                         span: Span,\n-                                         t_span: Span,\n-                                         e_span: Span,\n-                                         t_cast: Ty<'tcx>,\n-                                         t_expr: Ty<'tcx>,\n-                                         id: ast::NodeId) {\n-    if t_cast.references_error() || t_expr.references_error() {\n-        return;\n-    }\n-    let tstr = fcx.infcx().ty_to_string(t_cast);\n-    let mut err = fcx.type_error_struct(span, |actual| {\n-        format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n-    }, t_expr, None);\n-    match t_expr.sty {\n-        ty::TyRef(_, ty::TypeAndMut { mutbl: mt, .. }) => {\n-            let mtstr = match mt {\n-                hir::MutMutable => \"mut \",\n-                hir::MutImmutable => \"\"\n-            };\n-            if t_cast.is_trait() {\n-                match fcx.tcx().sess.codemap().span_to_snippet(t_span) {\n-                    Ok(s) => {\n-                        err.span_suggestion(t_span,\n-                                            \"try casting to a reference instead:\",\n-                                            format!(\"&{}{}\", mtstr, s));\n-                    },\n-                    Err(_) =>\n-                        span_help!(err, t_span,\n-                                   \"did you mean `&{}{}`?\", mtstr, tstr),\n-                }\n-            } else {\n-                span_help!(err, span,\n-                           \"consider using an implicit coercion to `&{}{}` instead\",\n-                           mtstr, tstr);\n-            }\n-        }\n-        ty::TyBox(..) => {\n-            match fcx.tcx().sess.codemap().span_to_snippet(t_span) {\n-                Ok(s) => {\n-                    err.span_suggestion(t_span,\n-                                        \"try casting to a `Box` instead:\",\n-                                        format!(\"Box<{}>\", s));\n-                },\n-                Err(_) =>\n-                    span_help!(err, t_span, \"did you mean `Box<{}>`?\", tstr),\n-            }\n-        }\n-        _ => {\n-            span_help!(err, e_span,\n-                       \"consider using a box or reference as appropriate\");\n-        }\n-    }\n-    err.emit();\n-    fcx.write_error(id);\n-}\n-\n-\n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &TyCtxt<'tcx> { self.ccx.tcx }\n \n@@ -1528,17 +1470,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.require_type_is_sized(self.expr_ty(expr), expr.span, code);\n     }\n \n-    pub fn type_is_known_to_be_sized(&self,\n-                                     ty: Ty<'tcx>,\n-                                     span: Span)\n-                                     -> bool\n-    {\n-        traits::type_known_to_meet_builtin_bound(self.infcx(),\n-                                                 ty,\n-                                                 ty::BoundSized,\n-                                                 span)\n-    }\n-\n     pub fn register_builtin_bound(&self,\n                                   ty: Ty<'tcx>,\n                                   builtin_bound: ty::BuiltinBound,\n@@ -3595,17 +3526,21 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // Eagerly check for some obvious errors.\n         if t_expr.references_error() || t_cast.references_error() {\n             fcx.write_error(id);\n-        } else if !fcx.type_is_known_to_be_sized(t_cast, expr.span) {\n-            report_cast_to_unsized_type(fcx, expr.span, t.span, e.span, t_cast, t_expr, id);\n         } else {\n             // Write a type for the whole expression, assuming everything is going\n             // to work out Ok.\n             fcx.write_ty(id, t_cast);\n \n             // Defer other checks until we're done type checking.\n             let mut deferred_cast_checks = fcx.inh.deferred_cast_checks.borrow_mut();\n-            let cast_check = cast::CastCheck::new(e, t_expr, t_cast, expr.span);\n-            deferred_cast_checks.push(cast_check);\n+            match cast::CastCheck::new(fcx, e, t_expr, t_cast, t.span, expr.span) {\n+                Ok(cast_check) => {\n+                    deferred_cast_checks.push(cast_check);\n+                }\n+                Err(ErrorReported) => {\n+                    fcx.write_error(id);\n+                }\n+            }\n         }\n       }\n       hir::ExprType(ref e, ref t) => {"}]}