{"sha": "1bc7f8a4c66d389376e0e4e523070ca4c0186b6d", "node_id": "C_kwDOAAsO6NoAKDFiYzdmOGE0YzY2ZDM4OTM3NmUwZTRlNTIzMDcwY2E0YzAxODZiNmQ", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-05-14T15:05:44Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-05-14T15:05:44Z"}, "message": "Support `#[macro_use(name, ...)]`", "tree": {"sha": "a43ecb5b6e96f76b81e342104ba4043b37cd54ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a43ecb5b6e96f76b81e342104ba4043b37cd54ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bc7f8a4c66d389376e0e4e523070ca4c0186b6d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmRg+MgACgkQ4laYqTBY\nYXFV2A//cD2N1xncwsu7uXDwMsk1MhBZZGb5Gtdn6cBbXd1Tf+6dPF7YBr1DelED\nB5ESJjDguPMh1hTIaVIGiqTQQYZAWyNVjgSx4Y7hMEFlYVNlaOUWBCV4VIFd5jhm\nZSYV13JfNCAQxG9xffsTcndEsybyf29ir/k/i4OrpsJxZ1N6e8QqrIthjiHHZom0\nK/x572zCHuEGrIZZdQTp4zSi3iK39HQNUVefpJmF7KCSMe0+8zKu0MT/5EVejSX7\nT+bUrfJZO+JhFVtypu5QZjmj5NtiZqpmGR+HPbv9uERRu77V4xpgDJLxQnAX0Al8\nLszqjubj7EXuNlieLYffJSUcAHqAeJnqnSoxYTCEhXcWhljCiYl3EP2dC+G9Skbn\n89zUe1TFIDY6c8trKrCrRE3MJet0bLsBwCkSpVy3rKRHgwXPs2gmvEK96jdi0T29\n+3Wfm8qXfXzldhMii28N3P6vTEgQFnczG4LC8tob/pHCmV0B8m0xSVemwMFtEh5E\n2MR1QL4jIvUbOJB1//mcHF8/f321gqJEYWPcTuoxbtL3DkjFoisR7h00CLl3XTbQ\n8oz9LOLgGYAs8J6pR0PiXHVM89dAh+YPN7HZUy+r9gBuWfCo2a2IiPGVFziqrnwd\nDXL7MRiC28t0xE4LULken+d1Ou/r0Hgsht3Y38dtxtOXB7AhweY=\n=8odE\n-----END PGP SIGNATURE-----", "payload": "tree a43ecb5b6e96f76b81e342104ba4043b37cd54ef\nparent cbd14e98403dc5e19f19fdf913808656d81a0516\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1684076744 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1684076744 +0900\n\nSupport `#[macro_use(name, ...)]`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bc7f8a4c66d389376e0e4e523070ca4c0186b6d", "html_url": "https://github.com/rust-lang/rust/commit/1bc7f8a4c66d389376e0e4e523070ca4c0186b6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bc7f8a4c66d389376e0e4e523070ca4c0186b6d/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbd14e98403dc5e19f19fdf913808656d81a0516", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbd14e98403dc5e19f19fdf913808656d81a0516", "html_url": "https://github.com/rust-lang/rust/commit/cbd14e98403dc5e19f19fdf913808656d81a0516"}], "stats": {"total": 180, "additions": 134, "deletions": 46}, "files": [{"sha": "a47ee85da10ae2255d7a7d5446d39d68b9f8c8d5", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 68, "deletions": 46, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/1bc7f8a4c66d389376e0e4e523070ca4c0186b6d/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bc7f8a4c66d389376e0e4e523070ca4c0186b6d/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=1bc7f8a4c66d389376e0e4e523070ca4c0186b6d", "patch": "@@ -35,8 +35,8 @@ use crate::{\n     derive_macro_as_call_id,\n     item_scope::{ImportType, PerNsGlobImports},\n     item_tree::{\n-        self, Fields, FileItemTreeId, ImportKind, ItemTree, ItemTreeId, ItemTreeNode, MacroCall,\n-        MacroDef, MacroRules, Mod, ModItem, ModKind, TreeId,\n+        self, ExternCrate, Fields, FileItemTreeId, ImportKind, ItemTree, ItemTreeId, ItemTreeNode,\n+        MacroCall, MacroDef, MacroRules, Mod, ModItem, ModKind, TreeId,\n     },\n     macro_call_as_call_id, macro_id_to_def_id,\n     nameres::{\n@@ -712,41 +712,28 @@ impl DefCollector<'_> {\n         );\n     }\n \n-    /// Import macros from `#[macro_use] extern crate`.\n-    // FIXME: Support `#[macro_rules(macro_name, ...)]`.\n-    fn import_macros_from_extern_crate(\n-        &mut self,\n-        current_module_id: LocalModuleId,\n-        extern_crate: &item_tree::ExternCrate,\n-    ) {\n-        tracing::debug!(\n-            \"importing macros from extern crate: {:?} ({:?})\",\n-            extern_crate,\n-            self.def_map.edition,\n-        );\n-\n-        if let Some(m) = self.resolve_extern_crate(&extern_crate.name) {\n-            if m == self.def_map.module_id(current_module_id) {\n-                cov_mark::hit!(ignore_macro_use_extern_crate_self);\n-                return;\n-            }\n-\n-            cov_mark::hit!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-            self.import_all_macros_exported(m.krate);\n-        }\n-    }\n-\n-    /// Import all exported macros from another crate\n+    /// Import exported macros from another crate. `names`, if `Some(_)`, specifies the name of\n+    /// macros to be imported. Otherwise this method imports all exported macros.\n     ///\n     /// Exported macros are just all macros in the root module scope.\n     /// Note that it contains not only all `#[macro_export]` macros, but also all aliases\n     /// created by `use` in the root module, ignoring the visibility of `use`.\n-    fn import_all_macros_exported(&mut self, krate: CrateId) {\n+    fn import_macros_from_extern_crate(&mut self, krate: CrateId, names: Option<Vec<Name>>) {\n         let def_map = self.db.crate_def_map(krate);\n-        for (name, def) in def_map[def_map.root].scope.macros() {\n-            // `#[macro_use]` brings macros into macro_use prelude. Yes, even non-`macro_rules!`\n-            // macros.\n-            self.def_map.macro_use_prelude.insert(name.clone(), def);\n+        // `#[macro_use]` brings macros into macro_use prelude. Yes, even non-`macro_rules!`\n+        // macros.\n+        let root_scope = &def_map[def_map.root].scope;\n+        if let Some(names) = names {\n+            for name in names {\n+                // FIXME: Report diagnostic on 404.\n+                if let Some(def) = root_scope.get(&name).take_macros() {\n+                    self.def_map.macro_use_prelude.insert(name, def);\n+                }\n+            }\n+        } else {\n+            for (name, def) in root_scope.macros() {\n+                self.def_map.macro_use_prelude.insert(name.clone(), def);\n+            }\n         }\n     }\n \n@@ -1537,7 +1524,7 @@ impl ModCollector<'_, '_> {\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n             if prelude_module.krate != krate && is_crate_root {\n                 cov_mark::hit!(prelude_is_macro_use);\n-                self.def_collector.import_all_macros_exported(prelude_module.krate);\n+                self.def_collector.import_macros_from_extern_crate(prelude_module.krate, None);\n             }\n         }\n \n@@ -1547,21 +1534,10 @@ impl ModCollector<'_, '_> {\n         //\n         // If we're not at the crate root, `macro_use`d extern crates are an error so let's just\n         // ignore them.\n-        // FIXME: Support `#[macro_rules(macro_name, ...)]`.\n         if is_crate_root {\n             for &item in items {\n-                let ModItem::ExternCrate(id) = item else { continue; };\n-                let attrs = self.item_tree.attrs(self.def_collector.db, krate, item.into());\n-                if attrs.cfg().map_or(true, |cfg| self.is_cfg_enabled(&cfg)) {\n-                    let import = &self.item_tree[id];\n-                    let attrs = self.item_tree.attrs(\n-                        self.def_collector.db,\n-                        krate,\n-                        ModItem::from(id).into(),\n-                    );\n-                    if attrs.by_key(\"macro_use\").exists() {\n-                        self.def_collector.import_macros_from_extern_crate(self.module_id, import);\n-                    }\n+                if let ModItem::ExternCrate(id) = item {\n+                    self.process_macro_use_extern_crate(id);\n                 }\n             }\n         }\n@@ -1788,6 +1764,52 @@ impl ModCollector<'_, '_> {\n         }\n     }\n \n+    fn process_macro_use_extern_crate(&mut self, extern_crate: FileItemTreeId<ExternCrate>) {\n+        let db = self.def_collector.db;\n+        let attrs = self.item_tree.attrs(\n+            db,\n+            self.def_collector.def_map.krate,\n+            ModItem::from(extern_crate).into(),\n+        );\n+        if let Some(cfg) = attrs.cfg() {\n+            if !self.is_cfg_enabled(&cfg) {\n+                return;\n+            }\n+        }\n+\n+        let target_crate =\n+            match self.def_collector.resolve_extern_crate(&self.item_tree[extern_crate].name) {\n+                Some(m) => {\n+                    if m == self.def_collector.def_map.module_id(self.module_id) {\n+                        cov_mark::hit!(ignore_macro_use_extern_crate_self);\n+                        return;\n+                    }\n+                    m.krate\n+                }\n+                None => return,\n+            };\n+\n+        cov_mark::hit!(macro_rules_from_other_crates_are_visible_with_macro_use);\n+\n+        let mut single_imports = Vec::new();\n+        let hygiene = Hygiene::new_unhygienic();\n+        for attr in attrs.by_key(\"macro_use\").attrs() {\n+            let Some(paths) = attr.parse_path_comma_token_tree(db.upcast(), &hygiene) else {\n+                // `#[macro_use]` (without any paths) found, forget collected names and just import\n+                // all visible macros.\n+                self.def_collector.import_macros_from_extern_crate(target_crate, None);\n+                return;\n+            };\n+            for path in paths {\n+                if let Some(name) = path.as_ident() {\n+                    single_imports.push(name.clone());\n+                }\n+            }\n+        }\n+\n+        self.def_collector.import_macros_from_extern_crate(target_crate, Some(single_imports));\n+    }\n+\n     fn collect_module(&mut self, module_id: FileItemTreeId<Mod>, attrs: &Attrs) {\n         let path_attr = attrs.by_key(\"path\").string_value();\n         let is_macro_use = attrs.by_key(\"macro_use\").exists();"}, {"sha": "56059f7cb3bb28b51224b1b78151172f7f2a8ceb", "filename": "crates/hir-def/src/nameres/tests/macros.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1bc7f8a4c66d389376e0e4e523070ca4c0186b6d/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bc7f8a4c66d389376e0e4e523070ca4c0186b6d/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=1bc7f8a4c66d389376e0e4e523070ca4c0186b6d", "patch": "@@ -259,6 +259,72 @@ mod priv_mod {\n     );\n }\n \n+#[test]\n+fn macro_use_filter() {\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:empty,multiple,all\n+#[macro_use()]\n+extern crate empty;\n+\n+foo_not_imported!();\n+\n+#[macro_use(bar1)]\n+#[macro_use()]\n+#[macro_use(bar2, bar3)]\n+extern crate multiple;\n+\n+bar1!();\n+bar2!();\n+bar3!();\n+bar_not_imported!();\n+\n+#[macro_use(baz1)]\n+#[macro_use]\n+#[macro_use(baz2)]\n+extern crate all;\n+\n+baz1!();\n+baz2!();\n+baz3!();\n+\n+//- /empty.rs crate:empty\n+#[macro_export]\n+macro_rules! foo_not_imported { () => { struct NotOkFoo; } }\n+\n+//- /multiple.rs crate:multiple\n+#[macro_export]\n+macro_rules! bar1 { () => { struct OkBar1; } }\n+#[macro_export]\n+macro_rules! bar2 { () => { struct OkBar2; } }\n+#[macro_export]\n+macro_rules! bar3 { () => { struct OkBar3; } }\n+#[macro_export]\n+macro_rules! bar_not_imported { () => { struct NotOkBar; } }\n+\n+//- /all.rs crate:all\n+#[macro_export]\n+macro_rules! baz1 { () => { struct OkBaz1; } }\n+#[macro_export]\n+macro_rules! baz2 { () => { struct OkBaz2; } }\n+#[macro_export]\n+macro_rules! baz3 { () => { struct OkBaz3; } }\n+\"#,\n+        expect![[r#\"\n+            crate\n+            OkBar1: t v\n+            OkBar2: t v\n+            OkBar3: t v\n+            OkBaz1: t v\n+            OkBaz2: t v\n+            OkBaz3: t v\n+            all: t\n+            empty: t\n+            multiple: t\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn prelude_is_macro_use() {\n     cov_mark::check!(prelude_is_macro_use);"}]}