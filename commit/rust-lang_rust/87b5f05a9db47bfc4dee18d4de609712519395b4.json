{"sha": "87b5f05a9db47bfc4dee18d4de609712519395b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YjVmMDVhOWRiNDdiZmM0ZGVlMThkNGRlNjA5NzEyNTE5Mzk1YjQ=", "commit": {"author": {"name": "Viktor Dahl", "email": "pazaconyoman@gmail.com", "date": "2012-10-24T16:21:57Z"}, "committer": {"name": "Viktor Dahl", "email": "pazaconyoman@gmail.com", "date": "2012-10-24T16:44:37Z"}, "message": "Cleaned up formatting and fixed bug in rev_binop", "tree": {"sha": "3a9e6e393a7099a40bbc551ff714553dd1285f8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a9e6e393a7099a40bbc551ff714553dd1285f8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87b5f05a9db47bfc4dee18d4de609712519395b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87b5f05a9db47bfc4dee18d4de609712519395b4", "html_url": "https://github.com/rust-lang/rust/commit/87b5f05a9db47bfc4dee18d4de609712519395b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87b5f05a9db47bfc4dee18d4de609712519395b4/comments", "author": {"login": "veddan", "id": 307180, "node_id": "MDQ6VXNlcjMwNzE4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/307180?v=4", "gravatar_id": "", "url": "https://api.github.com/users/veddan", "html_url": "https://github.com/veddan", "followers_url": "https://api.github.com/users/veddan/followers", "following_url": "https://api.github.com/users/veddan/following{/other_user}", "gists_url": "https://api.github.com/users/veddan/gists{/gist_id}", "starred_url": "https://api.github.com/users/veddan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/veddan/subscriptions", "organizations_url": "https://api.github.com/users/veddan/orgs", "repos_url": "https://api.github.com/users/veddan/repos", "events_url": "https://api.github.com/users/veddan/events{/privacy}", "received_events_url": "https://api.github.com/users/veddan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "veddan", "id": 307180, "node_id": "MDQ6VXNlcjMwNzE4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/307180?v=4", "gravatar_id": "", "url": "https://api.github.com/users/veddan", "html_url": "https://github.com/veddan", "followers_url": "https://api.github.com/users/veddan/followers", "following_url": "https://api.github.com/users/veddan/following{/other_user}", "gists_url": "https://api.github.com/users/veddan/gists{/gist_id}", "starred_url": "https://api.github.com/users/veddan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/veddan/subscriptions", "organizations_url": "https://api.github.com/users/veddan/orgs", "repos_url": "https://api.github.com/users/veddan/repos", "events_url": "https://api.github.com/users/veddan/events{/privacy}", "received_events_url": "https://api.github.com/users/veddan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d915294c962a0ec6cecca21e0547fb8f1d1360f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d915294c962a0ec6cecca21e0547fb8f1d1360f", "html_url": "https://github.com/rust-lang/rust/commit/9d915294c962a0ec6cecca21e0547fb8f1d1360f"}], "stats": {"total": 224, "additions": 119, "deletions": 105}, "files": [{"sha": "192b2924cb14df25fbfbf09bde985e956e0ffdab", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 119, "deletions": 105, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/87b5f05a9db47bfc4dee18d4de609712519395b4/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b5f05a9db47bfc4dee18d4de609712519395b4/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=87b5f05a9db47bfc4dee18d4de609712519395b4", "patch": "@@ -54,7 +54,7 @@ enum lint {\n     deprecated_pattern,\n     non_camel_case_types,\n     structural_records,\n-\ttype_limits,\n+    type_limits,\n \n     managed_heap_memory,\n     owned_heap_memory,\n@@ -187,10 +187,10 @@ fn get_lint_dict() -> lint_dict {\n            desc: ~\"allow legacy modes\",\n            default: forbid}),\n \n-\t\t(~\"type_limits\",\n-\t\t @{lint: type_limits,\n-\t\t   desc: ~\"comparisons made useless by limits of the types involved\",\n-\t\t   default: warn})\n+        (~\"type_limits\",\n+         @{lint: type_limits,\n+           desc: ~\"comparisons made useless by limits of the types involved\",\n+           default: warn})\n \n         /* FIXME(#3266)--make liveness warnings lintable\n         (~\"unused_variable\",\n@@ -403,7 +403,7 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n     check_item_heap(cx, i);\n     check_item_structural_records(cx, i);\n     check_item_deprecated_modes(cx, i);\n-\tcheck_item_type_limits(cx, i);\n+    check_item_type_limits(cx, i);\n }\n \n // Take a visitor, and modify it so that it will not proceed past subitems.\n@@ -438,105 +438,119 @@ fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n }\n \n fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n-\tpure fn is_valid<T: cmp::Ord>(binop: ast::binop, v: T, min: T, max: T) -> bool {\n-\t\tmatch binop {\n-\t\t\tast::lt => v <= max,\n-\t\t\tast::le => v < max,\n-\t\t\tast::gt => v >= min,\n-\t\t\tast::ge => v > min,\n-\t\t\tast::eq | ast::ne => v >= min && v <= max,\n-\t\t\t_ => fail\n-\t\t}\n-\t}\n-\n-\tpure fn rev_binop(binop: ast::binop) -> ast::binop {\n-\t\tmatch binop {\n-\t\t\tast::lt => ast::ge,\n-\t\t\tast::le => ast::gt,\n-\t\t\tast::gt => ast::le,\n-\t\t\tast::ge => ast::lt,\n-\t\t\t_ => binop\n-\t\t}\n-\t}\n-\n-\tfn check_limits(cx: ty::ctxt, binop: ast::binop, l: &ast::expr,\n-\t\t\t\t\tr: &ast::expr) -> bool {\n-\t\tlet (lit, expr, swap) = match (l.node, r.node) {\n-\t\t\t(ast::expr_lit(_), _) => (l, r, true),\n-\t\t\t(_, ast::expr_lit(_)) => (r, l, false),\n-\t\t\t_ => return true\n-\t\t};\n-\t\t// Normalize the binop so that the literal is always on the RHS in\n-\t\t// the comparison\n-\t\tlet norm_binop = if (swap) {\n-\t\t\trev_binop(binop)\n-\t\t} else {\n-\t\t\tbinop\n-\t\t};\n-\t\tmatch ty::get(ty::expr_ty(cx, @*expr)).sty {\n-\t\t\tty::ty_int(int_ty) => {\n-\t\t\t\tlet (min, max): (i64, i64) = match int_ty {\n-\t\t\t\t\tast::ty_i =>\t(int::min_value as i64,\tint::max_value as i64),\n-\t\t\t\t\tast::ty_char =>\t(u32::min_value as i64,\tu32::max_value as i64),\n-\t\t\t\t\tast::ty_i8 =>\t(i8::min_value  as i64,\ti8::max_value  as i64),\n-\t\t\t\t\tast::ty_i16 =>\t(i16::min_value as i64,\ti16::max_value as i64),\n-\t\t\t\t\tast::ty_i32 =>\t(i32::min_value as i64,\ti32::max_value as i64),\n-\t\t\t\t\tast::ty_i64 =>\t(i64::min_value, \t\ti64::max_value)\n-\t\t\t\t};\n-\t\t\t\tlet lit_val: i64 = match lit.node {\n-\t\t\t\t\tast::expr_lit(@li) => match li.node {\n-\t\t\t\t\t\tast::lit_int(v, _) => v,\n-\t\t\t\t\t\tast::lit_uint(v, _) => v as i64,\n-\t\t\t\t\t\tast::lit_int_unsuffixed(v) => v,\n-\t\t\t\t\t\t_ => return true\n-\t\t\t\t\t},\n-\t\t\t\t\t_ => fail\n-\t\t\t\t};\n-\t\t\t\tis_valid(norm_binop, lit_val, min, max)\n-\t\t\t}\n-\t\t\tty::ty_uint(uint_ty) => {\n-\t\t\t\tlet (min, max): (u64, u64) = match uint_ty {\n-\t\t\t\t\tast::ty_u =>\t(uint::min_value as u64, uint::max_value as u64),\n-\t\t\t\t\tast::ty_u8 =>\t(u8::min_value   as u64, u8::max_value   as u64),\n-\t\t\t\t\tast::ty_u16 =>\t(u16::min_value  as u64, u16::max_value  as u64),\n-\t\t\t\t\tast::ty_u32 =>\t(u32::min_value  as u64, u32::max_value  as u64),\n-\t\t\t\t\tast::ty_u64 =>\t(u64::min_value, \t\t u64::max_value)\n-\t\t\t\t};\n-\t\t\t\tlet lit_val: u64 = match lit.node {\n-\t\t\t\t\tast::expr_lit(@li) => match li.node {\n-\t\t\t\t\t\tast::lit_int(v, _) => v as u64,\n-\t\t\t\t\t\tast::lit_uint(v, _) => v,\n-\t\t\t\t\t\tast::lit_int_unsuffixed(v) => v as u64,\n-\t\t\t\t\t\t_ => return true\n-\t\t\t\t\t},\n-\t\t\t\t\t_ => fail\n-\t\t\t\t};\n-\t\t\t\tis_valid(norm_binop, lit_val, min, max)\n-\t\t\t}\n-\t\t\t_ => true\n-\t\t}\n-\t}\n-\n-\tlet visit = item_stopping_visitor(visit::mk_simple_visitor(@{\n-\t\tvisit_expr: fn@(e: @ast::expr) {\n-\t\t\tmatch e.node {\n-\t\t\t\tast::expr_binary(binop, @l, @r) => {\n-\t\t\t\t\tmatch binop {\n-\t\t\t\t\t\tast::eq | ast::lt | ast::le | ast::ne | ast::ge | ast::gt => {\n-\t\t\t\t\t\t\tif !check_limits(cx, binop, &l, &r) {\n-\t\t\t\t\t\t\t\tcx.sess.span_lint(type_limits, e.id, it.id, e.span,\n-\t\t\t\t\t\t\t\t\t~\"comparison is useless due to type limits\");\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\t_ => ()\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\t_ => ()\n-\t\t\t}\n-\t\t},\n-\t\t.. *visit::default_simple_visitor()\n-\t}));\n-\tvisit::visit_item(it, (), visit);\n+    pure fn is_valid<T: cmp::Ord>(binop: ast::binop, v: T,\n+            min: T, max: T) -> bool {\n+        match binop {\n+            ast::lt => v <= max,\n+            ast::le => v < max,\n+            ast::gt => v >= min,\n+            ast::ge => v > min,\n+            ast::eq | ast::ne => v >= min && v <= max,\n+            _ => fail\n+        }\n+    }\n+\n+    pure fn rev_binop(binop: ast::binop) -> ast::binop {\n+        match binop {\n+            ast::lt => ast::gt,\n+            ast::le => ast::ge,\n+            ast::gt => ast::lt,\n+            ast::ge => ast::le,\n+            _ => binop\n+        }\n+    }\n+\n+    pure fn int_ty_range(int_ty: ast::int_ty) -> (i64, i64) {\n+        match int_ty {\n+            ast::ty_i =>    (int::min_value as i64, int::max_value as i64),\n+            ast::ty_char => (u32::min_value as i64, u32::max_value as i64),\n+            ast::ty_i8 =>   (i8::min_value  as i64, i8::max_value  as i64),\n+            ast::ty_i16 =>  (i16::min_value as i64, i16::max_value as i64),\n+            ast::ty_i32 =>  (i32::min_value as i64, i32::max_value as i64),\n+            ast::ty_i64 =>  (i64::min_value,        i64::max_value)\n+        }\n+    }\n+\n+    pure fn uint_ty_range(uint_ty: ast::uint_ty) -> (u64, u64) {\n+        match uint_ty {\n+            ast::ty_u =>   (uint::min_value as u64, uint::max_value as u64),\n+            ast::ty_u8 =>  (u8::min_value   as u64, u8::max_value   as u64),\n+            ast::ty_u16 => (u16::min_value  as u64, u16::max_value  as u64),\n+            ast::ty_u32 => (u32::min_value  as u64, u32::max_value  as u64),\n+            ast::ty_u64 => (u64::min_value,         u64::max_value)\n+        }\n+    }\n+\n+    fn check_limits(cx: ty::ctxt, binop: ast::binop, l: &ast::expr,\n+                    r: &ast::expr) -> bool {\n+        let (lit, expr, swap) = match (l.node, r.node) {\n+            (ast::expr_lit(_), _) => (l, r, true),\n+            (_, ast::expr_lit(_)) => (r, l, false),\n+            _ => return true\n+        };\n+        // Normalize the binop so that the literal is always on the RHS in\n+        // the comparison\n+        let norm_binop = if (swap) {\n+            rev_binop(binop)\n+        } else {\n+            binop\n+        };\n+        match ty::get(ty::expr_ty(cx, @*expr)).sty {\n+            ty::ty_int(int_ty) => {\n+                let (min, max) = int_ty_range(int_ty);\n+                let lit_val: i64 = match lit.node {\n+                    ast::expr_lit(@li) => match li.node {\n+                        ast::lit_int(v, _) => v,\n+                        ast::lit_uint(v, _) => v as i64,\n+                        ast::lit_int_unsuffixed(v) => v,\n+                        _ => return true\n+                    },\n+                    _ => fail\n+                };\n+                is_valid(norm_binop, lit_val, min, max)\n+            }\n+            ty::ty_uint(uint_ty) => {\n+                let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n+                let lit_val: u64 = match lit.node {\n+                    ast::expr_lit(@li) => match li.node {\n+                        ast::lit_int(v, _) => v as u64,\n+                        ast::lit_uint(v, _) => v,\n+                        ast::lit_int_unsuffixed(v) => v as u64,\n+                        _ => return true\n+                    },\n+                    _ => fail\n+                };\n+                is_valid(norm_binop, lit_val, min, max)\n+            }\n+            _ => true\n+        }\n+    }\n+\n+    pure fn is_comparison(binop: ast::binop) -> bool {\n+        match binop {\n+            ast::eq | ast::lt | ast::le |\n+            ast::ne | ast::ge | ast::gt => true,\n+            _ => false\n+        }\n+    }\n+\n+    let visit = item_stopping_visitor(visit::mk_simple_visitor(@{\n+        visit_expr: fn@(e: @ast::expr) {\n+            match e.node {\n+                ast::expr_binary(binop, @l, @r) => {\n+                    if is_comparison(binop)\n+                       && !check_limits(cx, binop, &l, &r) {\n+                        cx.sess.span_lint(\n+                            type_limits, e.id, it.id, e.span,\n+                            ~\"comparison is useless due to type limits\");\n+                    }\n+                }\n+                _ => ()\n+            }\n+        },\n+        .. *visit::default_simple_visitor()\n+    }));\n+    visit::visit_item(it, (), visit);\n }\n \n fn check_item_structural_records(cx: ty::ctxt, it: @ast::item) {"}]}