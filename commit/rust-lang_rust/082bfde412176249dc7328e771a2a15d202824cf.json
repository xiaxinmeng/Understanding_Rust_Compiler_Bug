{"sha": "082bfde412176249dc7328e771a2a15d202824cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MmJmZGU0MTIxNzYyNDlkYzczMjhlNzcxYTJhMTVkMjAyODI0Y2Y=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-11T03:46:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-22T07:31:42Z"}, "message": "Fallout of std::str stabilization", "tree": {"sha": "4df3816d6ffea2f52bf5fa51fe385806ed529ba7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4df3816d6ffea2f52bf5fa51fe385806ed529ba7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/082bfde412176249dc7328e771a2a15d202824cf", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/082bfde412176249dc7328e771a2a15d202824cf", "html_url": "https://github.com/rust-lang/rust/commit/082bfde412176249dc7328e771a2a15d202824cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/082bfde412176249dc7328e771a2a15d202824cf/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4908017d59da8694b9ceaf743baf1163c1e19086", "url": "https://api.github.com/repos/rust-lang/rust/commits/4908017d59da8694b9ceaf743baf1163c1e19086", "html_url": "https://github.com/rust-lang/rust/commit/4908017d59da8694b9ceaf743baf1163c1e19086"}], "stats": {"total": 4371, "additions": 2142, "deletions": 2229}, "files": [{"sha": "bdbfbfd7c89d60a9e1933b94c312ebc362ede8d2", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -152,7 +152,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n             matches.opt_str(\"ratchet-metrics\").map(|s| Path::new(s)),\n         ratchet_noise_percent:\n             matches.opt_str(\"ratchet-noise-percent\")\n-                   .and_then(|s| from_str::<f64>(s.as_slice())),\n+                   .and_then(|s| s.as_slice().parse::<f64>()),\n         runtool: matches.opt_str(\"runtool\"),\n         host_rustcflags: matches.opt_str(\"host-rustcflags\"),\n         target_rustcflags: matches.opt_str(\"target-rustcflags\"),\n@@ -190,9 +190,7 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"filter: {}\",\n                     opt_str(&config.filter\n                                    .as_ref()\n-                                   .map(|re| {\n-                                       re.to_string().into_string()\n-                                   }))));\n+                                   .map(|re| re.to_string()))));\n     logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n     logv(c, format!(\"host-rustcflags: {}\",\n                     opt_str(&config.host_rustcflags)));"}, {"sha": "27be6c6d8356889e700203280c56e285e476364f", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -351,8 +351,8 @@ pub fn gdb_version_to_int(version_string: &str) -> int {\n         panic!(\"{}\", error_string);\n     }\n \n-    let major: int = from_str(components[0]).expect(error_string);\n-    let minor: int = from_str(components[1]).expect(error_string);\n+    let major: int = components[0].parse().expect(error_string);\n+    let minor: int = components[1].parse().expect(error_string);\n \n     return major * 1000 + minor;\n }\n@@ -362,6 +362,6 @@ pub fn lldb_version_to_int(version_string: &str) -> int {\n         \"Encountered LLDB version string with unexpected format: {}\",\n         version_string);\n     let error_string = error_string.as_slice();\n-    let major: int = from_str(version_string).expect(error_string);\n+    let major: int = version_string.parse().expect(error_string);\n     return major;\n }"}, {"sha": "bf72250c4705af70e5e43d64cf8eafb9f4e8e917", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -1361,7 +1361,7 @@ fn split_maybe_args(argstr: &Option<String>) -> Vec<String> {\n             s.as_slice()\n              .split(' ')\n              .filter_map(|s| {\n-                 if s.is_whitespace() {\n+                 if s.chars().all(|c| c.is_whitespace()) {\n                      None\n                  } else {\n                      Some(s.to_string())"}, {"sha": "3963ce6b85d3fd1b10e53b4df4b7d2a4cf386ccb", "filename": "src/doc/guide.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -2257,10 +2257,10 @@ a function for that:\n let input = io::stdin().read_line()\n                        .ok()\n                        .expect(\"Failed to read line\");\n-let input_num: Option<uint> = from_str(input.as_slice());\n+let input_num: Option<uint> = input.parse();\n ```\n \n-The `from_str` function takes in a `&str` value and converts it into something.\n+The `parse` function takes in a `&str` value and converts it into something.\n We tell it what kind of something with a type hint. Remember our type hint with\n `random()`? It looked like this:\n \n@@ -2279,8 +2279,8 @@ In this case, we say `x` is a `uint` explicitly, so Rust is able to properly\n tell `random()` what to generate. In a similar fashion, both of these work:\n \n ```{rust,ignore}\n-let input_num = from_str::<uint>(\"5\");       // input_num: Option<uint>\n-let input_num: Option<uint> = from_str(\"5\"); // input_num: Option<uint>\n+let input_num = \"5\".parse::<uint>();         // input_num: Option<uint>\n+let input_num: Option<uint> = \"5\".parse();   // input_num: Option<uint>\n ```\n \n Anyway, with us now converting our input to a number, our code looks like this:\n@@ -2301,7 +2301,7 @@ fn main() {\n     let input = io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<uint> = from_str(input.as_slice());\n+    let input_num: Option<uint> = input.parse();\n \n     println!(\"You guessed: {}\", input_num);\n \n@@ -2350,7 +2350,7 @@ fn main() {\n     let input = io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<uint> = from_str(input.as_slice());\n+    let input_num: Option<uint> = input.parse();\n \n     let num = match input_num {\n         Some(num) => num,\n@@ -2395,7 +2395,7 @@ Uh, what? But we did!\n \n ... actually, we didn't. See, when you get a line of input from `stdin()`,\n you get all the input. Including the `\\n` character from you pressing Enter.\n-Therefore, `from_str()` sees the string `\"5\\n\"` and says \"nope, that's not a\n+Therefore, `parse()` sees the string `\"5\\n\"` and says \"nope, that's not a\n number; there's non-number stuff in there!\" Luckily for us, `&str`s have an easy\n method we can use defined on them: `trim()`. One small modification, and our\n code looks like this:\n@@ -2416,7 +2416,7 @@ fn main() {\n     let input = io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<uint> = from_str(input.as_slice().trim());\n+    let input_num: Option<uint> = input.trim().parse();\n \n     let num = match input_num {\n         Some(num) => num,\n@@ -2491,7 +2491,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+        let input_num: Option<uint> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -2566,7 +2566,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+        let input_num: Option<uint> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -2621,7 +2621,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+        let input_num: Option<uint> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -2697,7 +2697,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+        let input_num: Option<uint> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,"}, {"sha": "97184d534983c48fc16ffc7489448da7d221447a", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -3177,7 +3177,7 @@ Some examples of call expressions:\n # fn add(x: int, y: int) -> int { 0 }\n \n let x: int = add(1, 2);\n-let pi: Option<f32> = from_str(\"3.14\");\n+let pi: Option<f32> = \"3.14\".parse();\n ```\n \n ### Lambda expressions"}, {"sha": "363d30abd0347b02eef24cd234b3abb6a1c08dc7", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -121,15 +121,15 @@ mod prelude {\n     // in core and collections (may differ).\n     pub use slice::{PartialEqSliceExt, OrdSliceExt};\n     pub use slice::{AsSlice, SliceExt};\n-    pub use str::{from_str, Str, StrPrelude};\n+    pub use str::{from_str, Str};\n \n     // from other crates.\n     pub use alloc::boxed::Box;\n     pub use unicode::char::UnicodeChar;\n \n     // from collections.\n     pub use slice::{CloneSliceExt, VectorVector};\n-    pub use str::{IntoMaybeOwned, UnicodeStrPrelude, StrAllocating, StrVector};\n+    pub use str::{IntoMaybeOwned, StrVector};\n     pub use string::{String, ToString};\n     pub use vec::Vec;\n }"}, {"sha": "5feae5e558edfd3baf28197a1b29ad16628792cb", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 76, "deletions": 47, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -55,25 +55,31 @@ use self::MaybeOwned::*;\n use self::RecompositionState::*;\n use self::DecompositionType::*;\n \n-use core::prelude::*;\n-\n use core::borrow::{BorrowFrom, Cow, ToOwned};\n-use core::cmp::{mod, Equiv, PartialEq, Eq, PartialOrd, Ord, Ordering};\n+use core::char::Char;\n+use core::clone::Clone;\n+use core::cmp::{Equiv, PartialEq, Eq, PartialOrd, Ord, Ordering};\n+use core::cmp;\n use core::default::Default;\n use core::fmt;\n use core::hash;\n use core::iter::AdditiveIterator;\n use core::iter::{mod, range, Iterator, IteratorExt};\n+use core::kinds::Sized;\n+use core::ops;\n+use core::option::Option::{mod, Some, None};\n+use core::slice::AsSlice;\n use core::str as core_str;\n use unicode::str::{UnicodeStr, Utf16Encoder};\n \n use ring_buf::RingBuf;\n-use string::{String, ToString};\n+use slice::SliceExt;\n+use string::String;\n use unicode;\n use vec::Vec;\n \n pub use core::str::{from_utf8, CharEq, Chars, CharIndices};\n-pub use core::str::{Bytes, CharSplits};\n+pub use core::str::{Bytes, CharSplits, is_utf8};\n pub use core::str::{CharSplitsN, Lines, LinesAny, MatchIndices, StrSplits};\n pub use core::str::{CharRange};\n pub use core::str::{FromStr, from_str, Utf8Error};\n@@ -408,6 +414,7 @@ impl<'a> Iterator<u16> for Utf16Units<'a> {\n /// # Examples\n ///\n /// ```rust\n+/// # #![allow(deprecated)]\n /// use std::str;\n /// let string = \"orange\";\n /// let new_string = str::replace(string, \"or\", \"str\");\n@@ -441,7 +448,7 @@ Section: MaybeOwned\n /// A string type that can hold either a `String` or a `&str`.\n /// This can be useful as an optimization when an allocation is sometimes\n /// needed but not always.\n-#[deprecated = \"use stding::string::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n pub enum MaybeOwned<'a> {\n     /// A borrowed string.\n     Slice(&'a str),\n@@ -650,7 +657,11 @@ impl BorrowFrom<String> for str {\n \n #[unstable = \"trait is unstable\"]\n impl ToOwned<String> for str {\n-    fn to_owned(&self) -> String { self.to_string() }\n+    fn to_owned(&self) -> String {\n+        unsafe {\n+            String::from_utf8_unchecked(self.as_bytes().to_owned())\n+        }\n+    }\n }\n \n /// Unsafe string operations.\n@@ -673,7 +684,7 @@ Section: Trait implementations\n */\n \n /// Any string that can be represented as a slice.\n-pub trait StrExt for Sized?: Slice<uint, str> {\n+pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     /// Escapes each char in `s` with `char::escape_default`.\n     #[unstable = \"return type may change to be an iterator\"]\n     fn escape_default(&self) -> String {\n@@ -724,7 +735,7 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     }\n \n     /// Given a string, makes a new string with repeated copies of it.\n-    #[deprecated = \"user repeat(self).take(n).collect() instead\"]\n+    #[deprecated = \"use repeat(self).take(n).collect() instead\"]\n     fn repeat(&self, nn: uint) -> String {\n         iter::repeat(self[]).take(nn).collect()\n     }\n@@ -766,7 +777,7 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// Returns an iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n     #[inline]\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n             iter: self[].chars(),\n@@ -779,7 +790,7 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// Returns an iterator over the string in Unicode Normalization Form KD\n     /// (compatibility decomposition).\n     #[inline]\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n             iter: self[].chars(),\n@@ -792,7 +803,7 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// An Iterator over the string in Unicode Normalization Form C\n     /// (canonical decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfc_chars<'a>(&'a self) -> Recompositions<'a> {\n         Recompositions {\n             iter: self.nfd_chars(),\n@@ -806,7 +817,7 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// An Iterator over the string in Unicode Normalization Form KC\n     /// (compatibility decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfkc_chars<'a>(&'a self) -> Recompositions<'a> {\n         Recompositions {\n             iter: self.nfkd_chars(),\n@@ -891,7 +902,7 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|&: c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n@@ -915,7 +926,7 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a little lambda\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_numeric()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |&: c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n@@ -950,7 +961,7 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').rev().collect();\n     /// assert_eq!(v, vec![\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).rev().collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|&: c: char| c.is_numeric()).rev().collect();\n     /// assert_eq!(v, vec![\"ghi\", \"def\", \"abc\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n@@ -971,7 +982,7 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n     /// assert_eq!(v, vec![\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_numeric()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |&: c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n@@ -1071,10 +1082,11 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![allow(deprecated)]\n     /// // composed forms of `\u00f6` and `\u00e9`\n     /// let c = \"L\u00f6we \u8001\u864e L\u00e9opard\"; // German, Simplified Chinese, French\n     /// // decomposed forms of `\u00f6` and `\u00e9`\n-    /// let d = \"Lo\\u0308we \u8001\u864e Le\\u0301opard\";\n+    /// let d = \"Lo\\u{0308}we \u8001\u864e Le\\u{0301}opard\";\n     ///\n     /// assert_eq!(c.char_len(), 15);\n     /// assert_eq!(d.char_len(), 17);\n@@ -1225,10 +1237,10 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\")\n+    /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\");\n     /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_chars(x), \"foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_numeric()), \"foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_chars(x), \"foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_chars(|&: c: char| c.is_numeric()), \"foo1bar\");\n     /// ```\n     #[unstable = \"awaiting pattern/matcher stabilization\"]\n     fn trim_chars<C: CharEq>(&self, to_trim: C) -> &str {\n@@ -1244,10 +1256,10 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\")\n+    /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\");\n     /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_left_chars(x), \"foo1bar12\")\n-    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_numeric()), \"foo1bar123\")\n+    /// assert_eq!(\"12foo1bar12\".trim_left_chars(x), \"foo1bar12\");\n+    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|&: c: char| c.is_numeric()), \"foo1bar123\");\n     /// ```\n     #[unstable = \"awaiting pattern/matcher stabilization\"]\n     fn trim_left_chars<C: CharEq>(&self, to_trim: C) -> &str {\n@@ -1263,10 +1275,10 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\")\n+    /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\");\n     /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_right_chars(x), \"12foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_numeric()), \"123foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_right_chars(x), \"12foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|&: c: char| c.is_numeric()), \"123foo1bar\");\n     /// ```\n     #[unstable = \"awaiting pattern/matcher stabilization\"]\n     fn trim_right_chars<C: CharEq>(&self, to_trim: C) -> &str {\n@@ -1434,7 +1446,7 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// assert_eq!(s.find('\u00e9'), Some(14));\n     ///\n     /// // the first space\n-    /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n+    /// assert_eq!(s.find(|&: c: char| c.is_whitespace()), Some(5));\n     ///\n     /// // neither are found\n     /// let x: &[_] = &['1', '2'];\n@@ -1462,7 +1474,7 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// assert_eq!(s.rfind('\u00e9'), Some(14));\n     ///\n     /// // the second space\n-    /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n+    /// assert_eq!(s.rfind(|&: c: char| c.is_whitespace()), Some(12));\n     ///\n     /// // searches for an occurrence of either `1` or `2`, but neither are found\n     /// let x: &[_] = &['1', '2'];\n@@ -1609,8 +1621,8 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let gr1 = \"a\\u0310e\\u0301o\\u0308\\u0332\".graphemes(true).collect::<Vec<&str>>();\n-    /// let b: &[_] = &[\"a\\u0310\", \"e\\u0301\", \"o\\u0308\\u0332\"];\n+    /// let gr1 = \"a\\u{310}e\\u{301}o\\u{308}\\u{332}\".graphemes(true).collect::<Vec<&str>>();\n+    /// let b: &[_] = &[\"a\\u{310}\", \"e\\u{301}\", \"o\\u{308}\\u{332}\"];\n     /// assert_eq!(gr1.as_slice(), b);\n     /// let gr2 = \"a\\r\\nb\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\".graphemes(true).collect::<Vec<&str>>();\n     /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n@@ -1659,6 +1671,7 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![allow(deprecated)]\n     /// assert!(\" \\t\\n\".is_whitespace());\n     /// assert!(\"\".is_whitespace());\n     ///\n@@ -1677,6 +1690,7 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![allow(deprecated)]\n     /// assert!(\"L\u00f6we\u8001\u864eL\u00e9opard123\".is_alphanumeric());\n     /// assert!(\"\".is_alphanumeric());\n     ///\n@@ -1718,25 +1732,39 @@ pub trait StrExt for Sized?: Slice<uint, str> {\n     fn trim_right(&self) -> &str {\n         UnicodeStr::trim_right(self[])\n     }\n+\n+    /// Deprecated, call `.to_owned()` instead from the `std::borrow::ToOwned`\n+    /// trait.\n+    #[deprecated = \"call `.to_owned()` on `std::borrow::ToOwned` instead\"]\n+    fn into_string(&self) -> String {\n+        self[].to_owned()\n+    }\n }\n \n impl StrExt for str {}\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n-    use core::default::Default;\n-    use core::iter::AdditiveIterator;\n-    use super::{eq_slice, from_utf8, is_utf8, is_utf16, raw};\n-    use super::truncate_utf16_at_nul;\n+    use std::iter::AdditiveIterator;\n+    use std::iter::range;\n+    use std::default::Default;\n+    use std::char::Char;\n+    use std::clone::Clone;\n+    use std::cmp::{Ord, PartialOrd, Equiv};\n+    use std::cmp::Ordering::{Equal, Greater, Less};\n+    use std::option::Option::{mod, Some, None};\n+    use std::result::Result::{Ok, Err};\n+    use std::ptr::RawPtr;\n+    use std::iter::{Iterator, IteratorExt, DoubleEndedIteratorExt};\n+\n+    use super::*;\n     use super::MaybeOwned::{Owned, Slice};\n+    use std::slice::{AsSlice, SliceExt};\n+    use string::{String, ToString};\n+    use vec::Vec;\n+    use slice::CloneSliceExt;\n \n-    #[test]\n-    fn test_eq_slice() {\n-        assert!((eq_slice(\"foobar\".slice(0, 3), \"foo\")));\n-        assert!((eq_slice(\"barfoo\".slice(3, 6), \"foo\")));\n-        assert!((!eq_slice(\"foo1\", \"foo2\")));\n-    }\n+    use unicode::char::UnicodeChar;\n \n     #[test]\n     fn test_le() {\n@@ -2267,6 +2295,7 @@ mod tests {\n \n     #[test]\n     fn test_is_utf16() {\n+        use unicode::str::is_utf16;\n         macro_rules! pos ( ($($e:expr),*) => { { $(assert!(is_utf16($e));)* } });\n \n         // non-surrogates\n@@ -3229,13 +3258,13 @@ mod tests {\n     #[test]\n     fn test_str_from_utf8() {\n         let xs = b\"hello\";\n-        assert_eq!(from_utf8(xs), Some(\"hello\"));\n+        assert_eq!(from_utf8(xs), Ok(\"hello\"));\n \n         let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n-        assert_eq!(from_utf8(xs), Some(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+        assert_eq!(from_utf8(xs), Ok(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n         let xs = b\"hello\\xFF\";\n-        assert_eq!(from_utf8(xs), None);\n+        assert_eq!(from_utf8(xs), Err(Utf8Error::TooShort));\n     }\n \n     #[test]\n@@ -3284,8 +3313,8 @@ mod tests {\n \n     #[test]\n     fn test_maybe_owned_into_string() {\n-        assert_eq!(Slice(\"abcde\").into_string(), String::from_str(\"abcde\"));\n-        assert_eq!(Owned(String::from_str(\"abcde\")).into_string(),\n+        assert_eq!(Slice(\"abcde\").to_string(), String::from_str(\"abcde\"));\n+        assert_eq!(Owned(String::from_str(\"abcde\")).to_string(),\n                    String::from_str(\"abcde\"));\n     }\n "}, {"sha": "6c2659b13f7207b8e6206b26c5169deb801ccdb8", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -26,7 +26,7 @@ use unicode::str as unicode_str;\n use unicode::str::Utf16Item;\n \n use slice::CloneSliceExt;\n-use str::{mod, CharRange, FromStr, StrExt, Owned, Utf8Error};\n+use str::{mod, CharRange, FromStr, Utf8Error};\n use vec::{DerefVec, Vec, as_vec};\n \n /// A growable string stored as a UTF-8 encoded buffer.\n@@ -94,13 +94,16 @@ impl String {\n     /// # Examples\n     ///\n     /// ```rust\n+    /// # #![allow(deprecated)]\n+    /// use std::str::Utf8Error;\n+    ///\n     /// let hello_vec = vec![104, 101, 108, 108, 111];\n     /// let s = String::from_utf8(hello_vec);\n     /// assert_eq!(s, Ok(\"hello\".to_string()));\n     ///\n     /// let invalid_vec = vec![240, 144, 128];\n     /// let s = String::from_utf8(invalid_vec);\n-    /// assert_eq!(s, Err(vec![240, 144, 128]));\n+    /// assert_eq!(s, Err((vec![240, 144, 128], Utf8Error::TooShort)));\n     /// ```\n     #[inline]\n     #[unstable = \"error type may change\"]\n@@ -833,15 +836,15 @@ impl Default for String {\n #[experimental = \"waiting on Show stabilization\"]\n impl fmt::Show for String {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        (*self).fmt(f)\n+        (**self).fmt(f)\n     }\n }\n \n #[experimental = \"waiting on Hash stabilization\"]\n impl<H: hash::Writer> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n-        (*self).hash(hasher)\n+        (**self).hash(hasher)\n     }\n }\n \n@@ -1026,6 +1029,7 @@ mod tests {\n     use prelude::*;\n     use test::Bencher;\n \n+    use str::{StrExt, Utf8Error};\n     use str;\n     use super::as_string;\n \n@@ -1044,14 +1048,16 @@ mod tests {\n     #[test]\n     fn test_from_utf8() {\n         let xs = b\"hello\".to_vec();\n-        assert_eq!(String::from_utf8(xs), Ok(String::from_str(\"hello\")));\n+        assert_eq!(String::from_utf8(xs),\n+                   Ok(String::from_str(\"hello\")));\n \n         let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes().to_vec();\n-        assert_eq!(String::from_utf8(xs), Ok(String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\")));\n+        assert_eq!(String::from_utf8(xs),\n+                   Ok(String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\")));\n \n         let xs = b\"hello\\xFF\".to_vec();\n         assert_eq!(String::from_utf8(xs),\n-                   Err(b\"hello\\xFF\".to_vec()));\n+                   Err((b\"hello\\xFF\".to_vec(), Utf8Error::TooShort)));\n     }\n \n     #[test]\n@@ -1141,7 +1147,7 @@ mod tests {\n             let s_as_utf16 = s.utf16_units().collect::<Vec<u16>>();\n             let u_as_string = String::from_utf16(u.as_slice()).unwrap();\n \n-            assert!(str::is_utf16(u.as_slice()));\n+            assert!(::unicode::str::is_utf16(u.as_slice()));\n             assert_eq!(s_as_utf16, u);\n \n             assert_eq!(u_as_string, s);"}, {"sha": "d831a57893bd77754980a174b6ff9d9452e507c4", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -718,15 +718,15 @@ impl<T: Default> Option<T> {\n     /// # Example\n     ///\n     /// Convert a string to an integer, turning poorly-formed strings\n-    /// into 0 (the default value for integers). `from_str` converts\n+    /// into 0 (the default value for integers). `parse` converts\n     /// a string to any other type that implements `FromStr`, returning\n     /// `None` on error.\n     ///\n     /// ```\n     /// let good_year_from_input = \"1909\";\n     /// let bad_year_from_input = \"190blarg\";\n-    /// let good_year = from_str(good_year_from_input).unwrap_or_default();\n-    /// let bad_year = from_str(bad_year_from_input).unwrap_or_default();\n+    /// let good_year = good_year_from_input.parse().unwrap_or_default();\n+    /// let bad_year = bad_year_from_input.parse().unwrap_or_default();\n     ///\n     /// assert_eq!(1909i, good_year);\n     /// assert_eq!(0i, bad_year);"}, {"sha": "8014b4dc89d70e10faf55286c45e1bc71885e157", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -458,7 +458,7 @@ impl<T, E> Result<T, E> {\n     ///     let line: IoResult<String> = buffer.read_line();\n     ///     // Convert the string line to a number using `map` and `from_str`\n     ///     let val: IoResult<int> = line.map(|line| {\n-    ///         from_str::<int>(line.as_slice().trim_right()).unwrap_or(0)\n+    ///         line.as_slice().trim_right().parse::<int>().unwrap_or(0)\n     ///     });\n     ///     // Add the value if there were no errors, otherwise add 0\n     ///     sum += val.ok().unwrap_or(0);"}, {"sha": "bfccc1e3f735634e06543d5fe4271565d0f8001b", "filename": "src/libcore/str.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -18,14 +18,13 @@\n \n use self::Searcher::{Naive, TwoWay, TwoWayLong};\n \n-use char::{mod, Char};\n use clone::Clone;\n use cmp::{mod, Eq};\n use default::Default;\n use iter::range;\n use iter::{DoubleEndedIteratorExt, ExactSizeIterator};\n use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n-use kinds::{Copy, Sized};\n+use kinds::Sized;\n use mem;\n use num::Int;\n use ops::{Fn, FnMut};\n@@ -60,9 +59,9 @@ impl FromStr for bool {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// assert_eq!(from_str::<bool>(\"true\"), Some(true));\n-    /// assert_eq!(from_str::<bool>(\"false\"), Some(false));\n-    /// assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n+    /// assert_eq!(\"true\".parse(), Some(true));\n+    /// assert_eq!(\"false\".parse(), Some(false));\n+    /// assert_eq!(\"not even a boolean\".parse::<bool>(), None);\n     /// ```\n     #[inline]\n     fn from_str(s: &str) -> Option<bool> {\n@@ -79,6 +78,7 @@ Section: Creating a string\n */\n \n /// Errors which can occur when attempting to interpret a byte slice as a `str`.\n+#[deriving(Copy, Eq, PartialEq, Clone)]\n pub enum Utf8Error {\n     /// An invalid byte was detected at the byte offset given.\n     ///\n@@ -334,6 +334,7 @@ impl<'a> DoubleEndedIterator<(uint, char)> for CharIndices<'a> {\n /// External iterator for a string's bytes.\n /// Use with the `std::iter` module.\n #[stable]\n+#[deriving(Clone)]\n pub struct Bytes<'a> {\n     inner: Map<&'a u8, u8, slice::Items<'a, u8>, BytesFn>,\n }\n@@ -946,24 +947,7 @@ pub fn is_utf8(v: &[u8]) -> bool {\n     run_utf8_validation_iterator(&mut v.iter()).is_ok()\n }\n \n-/// Return a slice of `v` ending at (and not including) the first NUL\n-/// (0).\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::str;\n-///\n-/// // \"abcd\"\n-/// let mut v = ['a' as u16, 'b' as u16, 'c' as u16, 'd' as u16];\n-/// // no NULs so no change\n-/// assert_eq!(str::truncate_utf16_at_nul(&v), v.as_slice());\n-///\n-/// // \"ab\\0d\"\n-/// v[2] = 0;\n-/// let b: &[_] = &['a' as u16, 'b' as u16];\n-/// assert_eq!(str::truncate_utf16_at_nul(&v), b);\n-/// ```\n+/// Deprecated function\n #[deprecated = \"this function will be removed\"]\n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     match v.iter().position(|c| *c == 0) {\n@@ -1595,6 +1579,8 @@ impl<'a> Default for &'a str {\n impl<'a> Iterator<&'a str> for Lines<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n impl<'a> DoubleEndedIterator<&'a str> for Lines<'a> {\n     #[inline]\n@@ -1603,6 +1589,8 @@ impl<'a> DoubleEndedIterator<&'a str> for Lines<'a> {\n impl<'a> Iterator<&'a str> for LinesAny<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n impl<'a> DoubleEndedIterator<&'a str> for LinesAny<'a> {\n     #[inline]\n@@ -1611,6 +1599,8 @@ impl<'a> DoubleEndedIterator<&'a str> for LinesAny<'a> {\n impl<'a> Iterator<u8> for Bytes<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<u8> { self.inner.next() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n impl<'a> DoubleEndedIterator<u8> for Bytes<'a> {\n     #[inline]"}, {"sha": "44029ebb7fa0f95e0121f99e8664230b3aac6d40", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -13,6 +13,7 @@\n extern crate core;\n extern crate test;\n extern crate libc;\n+extern crate unicode;\n \n mod any;\n mod atomic;"}, {"sha": "63d6e14a4a6b88165b72589aa0158a184777fe2b", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -117,7 +117,7 @@ fn test_rev_split_char_iterator_no_trailing() {\n \n #[test]\n fn test_utf16_code_units() {\n-    use core::str::Utf16Encoder;\n+    use unicode::str::Utf16Encoder;\n     assert_eq!(Utf16Encoder::new(vec!['\u00e9', '\\U0001F4A9'].into_iter()).collect::<Vec<u16>>(),\n                vec![0xE9, 0xD83D, 0xDCA9])\n }"}, {"sha": "c284fb7c9e338b9e561b49d64eb1ca2eabfde6f8", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -23,7 +23,8 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(macro_rules, globs)]\n+#![feature(macro_rules, globs, slicing_syntax)]\n+\n pub use self::Piece::*;\n pub use self::Position::*;\n pub use self::Alignment::*;\n@@ -136,7 +137,7 @@ pub enum Count<'a> {\n /// necessary there's probably lots of room for improvement performance-wise.\n pub struct Parser<'a> {\n     input: &'a str,\n-    cur: str::CharOffsets<'a>,\n+    cur: str::CharIndices<'a>,\n     /// Error messages accumulated during parsing\n     pub errors: Vec<string::String>,\n }\n@@ -208,13 +209,11 @@ impl<'a> Parser<'a> {\n                 self.cur.next();\n             }\n             Some((_, other)) => {\n-                self.err(format!(\"expected `{}`, found `{}`\",\n-                                 c,\n-                                 other).as_slice());\n+                self.err(format!(\"expected `{}`, found `{}`\", c, other)[]);\n             }\n             None => {\n                 self.err(format!(\"expected `{}` but string was terminated\",\n-                                 c).as_slice());\n+                                 c)[]);\n             }\n         }\n     }\n@@ -237,12 +236,12 @@ impl<'a> Parser<'a> {\n             // we may not consume the character, so clone the iterator\n             match self.cur.clone().next() {\n                 Some((pos, '}')) | Some((pos, '{')) => {\n-                    return self.input.slice(start, pos);\n+                    return self.input[start..pos];\n                 }\n                 Some(..) => { self.cur.next(); }\n                 None => {\n                     self.cur.next();\n-                    return self.input.slice(start, self.input.len());\n+                    return self.input[start..self.input.len()];\n                 }\n             }\n         }\n@@ -282,7 +281,7 @@ impl<'a> Parser<'a> {\n             flags: 0,\n             precision: CountImplied,\n             width: CountImplied,\n-            ty: self.input.slice(0, 0),\n+            ty: self.input[0..0],\n         };\n         if !self.consume(':') { return spec }\n \n@@ -391,7 +390,7 @@ impl<'a> Parser<'a> {\n                 self.cur.next();\n                 pos\n             }\n-            Some(..) | None => { return self.input.slice(0, 0); }\n+            Some(..) | None => { return self.input[0..0]; }\n         };\n         let mut end;\n         loop {\n@@ -403,7 +402,7 @@ impl<'a> Parser<'a> {\n                 None => { end = self.input.len(); break }\n             }\n         }\n-        self.input.slice(start, end)\n+        self.input[start..end]\n     }\n \n     /// Optionally parses an integer at the current position. This doesn't deal"}, {"sha": "0426f269376216340c144e3b255bca04b35ae11a", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -85,7 +85,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(globs, phase)]\n+#![feature(globs, phase, slicing_syntax)]\n #![feature(unboxed_closures)]\n #![deny(missing_docs)]\n \n@@ -101,9 +101,8 @@ use self::Whitespace::*;\n use self::LengthLimit::*;\n \n use std::fmt;\n-use std::result::Result::{Err, Ok};\n+use std::iter::repeat;\n use std::result;\n-use std::string::String;\n \n /// Name of an option. Either a string or a single char.\n #[deriving(Clone, PartialEq, Eq)]\n@@ -282,7 +281,7 @@ impl OptGroup {\n \n impl Matches {\n     fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n-        match find_opt(self.opts.as_slice(), Name::from_str(nm)) {\n+        match find_opt(self.opts[], Name::from_str(nm)) {\n             Some(id) => self.vals[id].clone(),\n             None => panic!(\"No option '{}' defined\", nm)\n         }\n@@ -310,8 +309,7 @@ impl Matches {\n     /// Returns true if any of several options were matched.\n     pub fn opts_present(&self, names: &[String]) -> bool {\n         for nm in names.iter() {\n-            match find_opt(self.opts.as_slice(),\n-                           Name::from_str(nm.as_slice())) {\n+            match find_opt(self.opts.as_slice(), Name::from_str(nm[])) {\n                 Some(id) if !self.vals[id].is_empty() => return true,\n                 _ => (),\n             };\n@@ -322,7 +320,7 @@ impl Matches {\n     /// Returns the string argument supplied to one of several matching options or `None`.\n     pub fn opts_str(&self, names: &[String]) -> Option<String> {\n         for nm in names.iter() {\n-            match self.opt_val(nm.as_slice()) {\n+            match self.opt_val(nm[]) {\n                 Some(Val(ref s)) => return Some(s.clone()),\n                 _ => ()\n             }\n@@ -587,7 +585,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     while i < l {\n         let cur = args[i].clone();\n         let curlen = cur.len();\n-        if !is_arg(cur.as_slice()) {\n+        if !is_arg(cur[]) {\n             free.push(cur);\n         } else if cur == \"--\" {\n             let mut j = i + 1;\n@@ -597,7 +595,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n             let mut names;\n             let mut i_arg = None;\n             if cur.as_bytes()[1] == b'-' {\n-                let tail = cur.slice(2, curlen);\n+                let tail = cur[2..curlen];\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n                     names = vec!(Long(tail.to_string()));\n@@ -633,7 +631,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     };\n \n                     if arg_follows && range.next < curlen {\n-                        i_arg = Some(cur.slice(range.next, curlen).to_string());\n+                        i_arg = Some(cur[range.next..curlen].to_string());\n                         break;\n                     }\n \n@@ -660,7 +658,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                             .push(Val((i_arg.clone())\n                             .unwrap()));\n                     } else if name_pos < names.len() || i + 1 == l ||\n-                            is_arg(args[i + 1].as_slice()) {\n+                            is_arg(args[i + 1][]) {\n                         vals[optid].push(Given);\n                     } else {\n                         i += 1;\n@@ -702,7 +700,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n /// Derive a usage message from a set of long options.\n pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n-    let desc_sep = format!(\"\\n{}\", \" \".repeat(24));\n+    let desc_sep = format!(\"\\n{}\", repeat(\" \").take(24).collect::<String>());\n \n     let rows = opts.iter().map(|optref| {\n         let OptGroup{short_name,\n@@ -712,14 +710,14 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n                      hasarg,\n                      ..} = (*optref).clone();\n \n-        let mut row = \" \".repeat(4);\n+        let mut row = repeat(\" \").take(4).collect::<String>();\n \n         // short option\n         match short_name.len() {\n             0 => {}\n             1 => {\n                 row.push('-');\n-                row.push_str(short_name.as_slice());\n+                row.push_str(short_name[]);\n                 row.push(' ');\n             }\n             _ => panic!(\"the short name should only be 1 ascii char long\"),\n@@ -730,31 +728,31 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             0 => {}\n             _ => {\n                 row.push_str(\"--\");\n-                row.push_str(long_name.as_slice());\n+                row.push_str(long_name[]);\n                 row.push(' ');\n             }\n         }\n \n         // arg\n         match hasarg {\n             No => {}\n-            Yes => row.push_str(hint.as_slice()),\n+            Yes => row.push_str(hint[]),\n             Maybe => {\n                 row.push('[');\n-                row.push_str(hint.as_slice());\n+                row.push_str(hint[]);\n                 row.push(']');\n             }\n         }\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // here we just need to indent the start of the description\n-        let rowlen = row.char_len();\n+        let rowlen = row.chars().count();\n         if rowlen < 24 {\n             for _ in range(0, 24 - rowlen) {\n                 row.push(' ');\n             }\n         } else {\n-            row.push_str(desc_sep.as_slice())\n+            row.push_str(desc_sep[]);\n         }\n \n         // Normalize desc to contain words separated by one space character\n@@ -766,16 +764,14 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // FIXME: #5516 should be graphemes not codepoints\n         let mut desc_rows = Vec::new();\n-        each_split_within(desc_normalized_whitespace.as_slice(),\n-                          54,\n-                          |substr| {\n+        each_split_within(desc_normalized_whitespace[], 54, |substr| {\n             desc_rows.push(substr.to_string());\n             true\n         });\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // wrapped description\n-        row.push_str(desc_rows.connect(desc_sep.as_slice()).as_slice());\n+        row.push_str(desc_rows.connect(desc_sep[])[]);\n \n         row\n     });\n@@ -794,18 +790,18 @@ fn format_option(opt: &OptGroup) -> String {\n     // Use short_name is possible, but fallback to long_name.\n     if opt.short_name.len() > 0 {\n         line.push('-');\n-        line.push_str(opt.short_name.as_slice());\n+        line.push_str(opt.short_name[]);\n     } else {\n         line.push_str(\"--\");\n-        line.push_str(opt.long_name.as_slice());\n+        line.push_str(opt.long_name[]);\n     }\n \n     if opt.hasarg != No {\n         line.push(' ');\n         if opt.hasarg == Maybe {\n             line.push('[');\n         }\n-        line.push_str(opt.hint.as_slice());\n+        line.push_str(opt.hint[]);\n         if opt.hasarg == Maybe {\n             line.push(']');\n         }\n@@ -827,8 +823,7 @@ pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n     line.push_str(opts.iter()\n                       .map(format_option)\n                       .collect::<Vec<String>>()\n-                      .connect(\" \")\n-                      .as_slice());\n+                      .connect(\" \")[]);\n     line\n }\n \n@@ -891,9 +886,9 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n             (B, Cr, UnderLim) => { B }\n             (B, Cr, OverLim)  if (i - last_start + 1) > lim\n                             => panic!(\"word starting with {} longer than limit!\",\n-                                    ss.slice(last_start, i + 1)),\n+                                    ss[last_start..i + 1]),\n             (B, Cr, OverLim)  => {\n-                *cont = it(ss.slice(slice_start, last_end));\n+                *cont = it(ss[slice_start..last_end]);\n                 slice_start = last_start;\n                 B\n             }\n@@ -903,7 +898,7 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n             }\n             (B, Ws, OverLim)  => {\n                 last_end = i;\n-                *cont = it(ss.slice(slice_start, last_end));\n+                *cont = it(ss[slice_start..last_end]);\n                 A\n             }\n \n@@ -912,14 +907,14 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n                 B\n             }\n             (C, Cr, OverLim)  => {\n-                *cont = it(ss.slice(slice_start, last_end));\n+                *cont = it(ss[slice_start..last_end]);\n                 slice_start = i;\n                 last_start = i;\n                 last_end = i;\n                 B\n             }\n             (C, Ws, OverLim)  => {\n-                *cont = it(ss.slice(slice_start, last_end));\n+                *cont = it(ss[slice_start..last_end]);\n                 A\n             }\n             (C, Ws, UnderLim) => {"}, {"sha": "ce3df1090bd58c756f1336604d2a1bca0930e577", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -448,8 +448,8 @@ impl<'a> LabelText<'a> {\n     /// Renders text as string suitable for a label in a .dot file.\n     pub fn escape(&self) -> String {\n         match self {\n-            &LabelStr(ref s) => (&**s).escape_default(),\n-            &EscStr(ref s) => LabelText::escape_str(s.as_slice()),\n+            &LabelStr(ref s) => s.escape_default(),\n+            &EscStr(ref s) => LabelText::escape_str(s[]),\n         }\n     }\n \n@@ -475,10 +475,10 @@ impl<'a> LabelText<'a> {\n \n     /// Puts `suffix` on a line below this label, with a blank line separator.\n     pub fn suffix_line(self, suffix: LabelText) -> LabelText<'static> {\n-        let mut prefix = self.pre_escaped_content().into_string();\n+        let mut prefix = self.pre_escaped_content().into_owned();\n         let suffix = suffix.pre_escaped_content();\n         prefix.push_str(r\"\\n\\n\");\n-        prefix.push_str(suffix.as_slice());\n+        prefix.push_str(suffix[]);\n         EscStr(prefix.into_cow())\n     }\n }\n@@ -671,7 +671,7 @@ mod tests {\n \n     impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraph {\n         fn graph_id(&'a self) -> Id<'a> {\n-            Id::new(self.name.as_slice()).unwrap()\n+            Id::new(self.name[]).unwrap()\n         }\n         fn node_id(&'a self, n: &Node) -> Id<'a> {\n             id_name(n)\n@@ -735,7 +735,7 @@ mod tests {\n     fn test_input(g: LabelledGraph) -> IoResult<String> {\n         let mut writer = Vec::new();\n         render(&g, &mut writer).unwrap();\n-        (&mut writer.as_slice()).read_to_string()\n+        (&mut writer[]).read_to_string()\n     }\n \n     // All of the tests use raw-strings as the format for the expected outputs,\n@@ -847,7 +847,7 @@ r#\"digraph hasse_diagram {\n                  edge(1, 3, \";\"),    edge(2, 3, \";\"   )));\n \n         render(&g, &mut writer).unwrap();\n-        let r = (&mut writer.as_slice()).read_to_string();\n+        let r = (&mut writer[]).read_to_string();\n \n         assert_eq!(r.unwrap(),\n r#\"digraph syntax_tree {"}, {"sha": "2b25a64affee313ad36a9904e5818ae49e423826", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -23,7 +23,7 @@ pub static LOG_LEVEL_NAMES: [&'static str, ..4] = [\"ERROR\", \"WARN\", \"INFO\",\n \n /// Parse an individual log level that is either a number or a symbolic log level\n fn parse_log_level(level: &str) -> Option<u32> {\n-    from_str::<u32>(level).or_else(|| {\n+    level.parse::<u32>().or_else(|| {\n         let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n         pos.map(|p| p as u32 + 1)\n     }).map(|p| cmp::min(p, ::MAX_LOG_LEVEL))"}, {"sha": "bc655c219f32cd812b10d049b8530728b5cb6dcd", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -164,7 +164,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(macro_rules, unboxed_closures)]\n+#![feature(macro_rules, unboxed_closures, slicing_syntax)]\n #![deny(missing_docs)]\n \n extern crate regex;\n@@ -280,7 +280,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n     match unsafe { FILTER.as_ref() } {\n-        Some(filter) if !filter.is_match(args.to_string().as_slice()) => return,\n+        Some(filter) if !filter.is_match(args.to_string()[]) => return,\n         _ => {}\n     }\n \n@@ -375,7 +375,7 @@ fn enabled(level: u32,\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {\n         match directive.name {\n-            Some(ref name) if !module.starts_with(name.as_slice()) => {},\n+            Some(ref name) if !module.starts_with(name[]) => {},\n             Some(..) | None => {\n                 return level <= directive.level\n             }\n@@ -390,7 +390,7 @@ fn enabled(level: u32,\n /// `Once` primitive (and this function is called from that primitive).\n fn init() {\n     let (mut directives, filter) = match os::getenv(\"RUST_LOG\") {\n-        Some(spec) => directive::parse_logging_spec(spec.as_slice()),\n+        Some(spec) => directive::parse_logging_spec(spec[]),\n         None => (Vec::new(), None),\n     };\n "}, {"sha": "0cd8df73c37ce6af7718692bd9df7e19a2d8a056", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -286,7 +286,7 @@ impl<'a> Parser<'a> {\n             true => Ok(()),\n             false => {\n                 self.err(format!(\"Expected {} but got EOF.\",\n-                                 expected).as_slice())\n+                                 expected)[])\n             }\n         }\n     }\n@@ -295,10 +295,10 @@ impl<'a> Parser<'a> {\n         match self.next_char() {\n             true if self.cur() == expected => Ok(()),\n             true => self.err(format!(\"Expected '{}' but got '{}'.\",\n-                                     expected, self.cur()).as_slice()),\n+                                     expected, self.cur())[]),\n             false => {\n                 self.err(format!(\"Expected '{}' but got EOF.\",\n-                                 expected).as_slice())\n+                                 expected)[])\n             }\n         }\n     }\n@@ -443,14 +443,14 @@ impl<'a> Parser<'a> {\n                         Literal(c3, _) => c2 = c3, // allow literal escapes below\n                         ast =>\n                             return self.err(format!(\"Expected a literal, but got {}.\",\n-                                                    ast).as_slice()),\n+                                                    ast)[]),\n                     }\n                 }\n                 if c2 < c {\n                     return self.err(format!(\"Invalid character class \\\n                                              range '{}-{}'\",\n                                             c,\n-                                            c2).as_slice())\n+                                            c2)[])\n                 }\n                 ranges.push((c, self.cur()))\n             } else {\n@@ -488,7 +488,7 @@ impl<'a> Parser<'a> {\n                 FLAG_EMPTY\n             };\n         let name = self.slice(name_start, closer - 1);\n-        match find_class(ASCII_CLASSES, name.as_slice()) {\n+        match find_class(ASCII_CLASSES, name[]) {\n             None => None,\n             Some(ranges) => {\n                 self.chari = closer;\n@@ -513,7 +513,7 @@ impl<'a> Parser<'a> {\n                     return self.err(format!(\"No closing brace for counted \\\n                                              repetition starting at position \\\n                                              {}.\",\n-                                            start).as_slice())\n+                                            start)[])\n                 }\n             };\n         self.chari = closer;\n@@ -524,7 +524,7 @@ impl<'a> Parser<'a> {\n         // Parse the min and max values from the regex.\n         let (mut min, mut max): (uint, Option<uint>);\n         if !inner.contains(\",\") {\n-            min = try!(self.parse_uint(inner.as_slice()));\n+            min = try!(self.parse_uint(inner[]));\n             max = Some(min);\n         } else {\n             let pieces: Vec<&str> = inner.splitn(1, ',').collect();\n@@ -546,19 +546,19 @@ impl<'a> Parser<'a> {\n         if min > MAX_REPEAT {\n             return self.err(format!(\n                 \"{} exceeds maximum allowed repetitions ({})\",\n-                min, MAX_REPEAT).as_slice());\n+                min, MAX_REPEAT)[]);\n         }\n         if max.is_some() {\n             let m = max.unwrap();\n             if m > MAX_REPEAT {\n                 return self.err(format!(\n                     \"{} exceeds maximum allowed repetitions ({})\",\n-                    m, MAX_REPEAT).as_slice());\n+                    m, MAX_REPEAT)[]);\n             }\n             if m < min {\n                 return self.err(format!(\n                     \"Max repetitions ({}) cannot be smaller than min \\\n-                     repetitions ({}).\", m, min).as_slice());\n+                     repetitions ({}).\", m, min)[]);\n             }\n         }\n \n@@ -622,8 +622,7 @@ impl<'a> Parser<'a> {\n                 Ok(AstClass(ranges, flags))\n             }\n             _ => {\n-                self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\",\n-                                 c).as_slice())\n+                self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\", c)[])\n             }\n         }\n     }\n@@ -643,7 +642,7 @@ impl<'a> Parser<'a> {\n                     Some(i) => i,\n                     None => return self.err(format!(\n                         \"Missing '}}' for unclosed '{{' at position {}\",\n-                        self.chari).as_slice()),\n+                        self.chari)[]),\n                 };\n             if closer - self.chari + 1 == 0 {\n                 return self.err(\"No Unicode class name found.\")\n@@ -657,10 +656,10 @@ impl<'a> Parser<'a> {\n             name = self.slice(self.chari + 1, self.chari + 2);\n             self.chari += 1;\n         }\n-        match find_class(UNICODE_CLASSES, name.as_slice()) {\n+        match find_class(UNICODE_CLASSES, name[]) {\n             None => {\n                 return self.err(format!(\"Could not find Unicode class '{}'\",\n-                                        name).as_slice())\n+                                        name)[])\n             }\n             Some(ranges) => {\n                 Ok(AstClass(ranges, negated | (self.flags & FLAG_NOCASE)))\n@@ -683,11 +682,11 @@ impl<'a> Parser<'a> {\n             }\n         }\n         let s = self.slice(start, end);\n-        match num::from_str_radix::<u32>(s.as_slice(), 8) {\n+        match num::from_str_radix::<u32>(s[], 8) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => {\n                 self.err(format!(\"Could not parse '{}' as octal number.\",\n-                                 s).as_slice())\n+                                 s)[])\n             }\n         }\n     }\n@@ -705,12 +704,12 @@ impl<'a> Parser<'a> {\n                 None => {\n                     return self.err(format!(\"Missing '}}' for unclosed \\\n                                              '{{' at position {}\",\n-                                            start).as_slice())\n+                                            start)[])\n                 }\n                 Some(i) => i,\n             };\n         self.chari = closer;\n-        self.parse_hex_digits(self.slice(start, closer).as_slice())\n+        self.parse_hex_digits(self.slice(start, closer)[])\n     }\n \n     // Parses a two-digit hex number.\n@@ -730,8 +729,7 @@ impl<'a> Parser<'a> {\n         match num::from_str_radix::<u32>(s, 16) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => {\n-                self.err(format!(\"Could not parse '{}' as hex number.\",\n-                                 s).as_slice())\n+                self.err(format!(\"Could not parse '{}' as hex number.\", s)[])\n             }\n         }\n     }\n@@ -757,7 +755,7 @@ impl<'a> Parser<'a> {\n         }\n         if self.names.contains(&name) {\n             return self.err(format!(\"Duplicate capture group name '{}'.\",\n-                                    name).as_slice())\n+                                    name)[])\n         }\n         self.names.push(name.clone());\n         self.chari = closer;\n@@ -791,7 +789,7 @@ impl<'a> Parser<'a> {\n                     if sign < 0 {\n                         return self.err(format!(\n                             \"Cannot negate flags twice in '{}'.\",\n-                            self.slice(start, self.chari + 1)).as_slice())\n+                            self.slice(start, self.chari + 1))[])\n                     }\n                     sign = -1;\n                     saw_flag = false;\n@@ -802,7 +800,7 @@ impl<'a> Parser<'a> {\n                         if !saw_flag {\n                             return self.err(format!(\n                                 \"A valid flag does not follow negation in '{}'\",\n-                                self.slice(start, self.chari + 1)).as_slice())\n+                                self.slice(start, self.chari + 1))[])\n                         }\n                         flags = flags ^ flags;\n                     }\n@@ -814,7 +812,7 @@ impl<'a> Parser<'a> {\n                     return Ok(())\n                 }\n                 _ => return self.err(format!(\n-                    \"Unrecognized flag '{}'.\", self.cur()).as_slice()),\n+                    \"Unrecognized flag '{}'.\", self.cur())[]),\n             }\n         }\n     }\n@@ -908,11 +906,11 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_uint(&self, s: &str) -> Result<uint, Error> {\n-        match from_str::<uint>(s) {\n+        match s.parse::<uint>() {\n             Some(i) => Ok(i),\n             None => {\n                 self.err(format!(\"Expected an unsigned integer but got '{}'.\",\n-                                 s).as_slice())\n+                                 s)[])\n             }\n         }\n     }\n@@ -922,8 +920,7 @@ impl<'a> Parser<'a> {\n             Some(c) => Ok(c),\n             None => {\n                 self.err(format!(\"Could not decode '{}' to unicode \\\n-                                  character.\",\n-                                 n).as_slice())\n+                                  character.\", n)[])\n             }\n         }\n     }"}, {"sha": "4e23e92c77ead1e1300344985dc95580c80ebe0f", "filename": "src/libregex/re.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -417,7 +417,7 @@ impl Regex {\n     /// # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n     /// # fn main() {\n     /// let re = regex!(\"[^01]+\");\n-    /// assert_eq!(re.replace(\"1078910\", \"\").as_slice(), \"1010\");\n+    /// assert_eq!(re.replace(\"1078910\", \"\"), \"1010\");\n     /// # }\n     /// ```\n     ///\n@@ -435,7 +435,7 @@ impl Regex {\n     /// let result = re.replace(\"Springsteen, Bruce\", |&: caps: &Captures| {\n     ///     format!(\"{} {}\", caps.at(2).unwrap_or(\"\"), caps.at(1).unwrap_or(\"\"))\n     /// });\n-    /// assert_eq!(result.as_slice(), \"Bruce Springsteen\");\n+    /// assert_eq!(result, \"Bruce Springsteen\");\n     /// # }\n     /// ```\n     ///\n@@ -450,7 +450,7 @@ impl Regex {\n     /// # fn main() {\n     /// let re = regex!(r\"(?P<last>[^,\\s]+),\\s+(?P<first>\\S+)\");\n     /// let result = re.replace(\"Springsteen, Bruce\", \"$first $last\");\n-    /// assert_eq!(result.as_slice(), \"Bruce Springsteen\");\n+    /// assert_eq!(result, \"Bruce Springsteen\");\n     /// # }\n     /// ```\n     ///\n@@ -469,7 +469,7 @@ impl Regex {\n     ///\n     /// let re = regex!(r\"(?P<last>[^,\\s]+),\\s+(\\S+)\");\n     /// let result = re.replace(\"Springsteen, Bruce\", NoExpand(\"$2 $last\"));\n-    /// assert_eq!(result.as_slice(), \"$2 $last\");\n+    /// assert_eq!(result, \"$2 $last\");\n     /// # }\n     /// ```\n     pub fn replace<R: Replacer>(&self, text: &str, rep: R) -> String {\n@@ -505,19 +505,19 @@ impl Regex {\n             }\n \n             let (s, e) = cap.pos(0).unwrap(); // captures only reports matches\n-            new.push_str(text.slice(last_match, s));\n-            new.push_str(rep.reg_replace(&cap).as_slice());\n+            new.push_str(text[last_match..s]);\n+            new.push_str(rep.reg_replace(&cap)[]);\n             last_match = e;\n         }\n-        new.push_str(text.slice(last_match, text.len()));\n+        new.push_str(text[last_match..text.len()]);\n         return new;\n     }\n \n     /// Returns the original string of this regex.\n     pub fn as_str<'a>(&'a self) -> &'a str {\n         match *self {\n-            Dynamic(ExDynamic { ref original, .. }) => original.as_slice(),\n-            Native(ExNative { ref original, .. }) => original.as_slice(),\n+            Dynamic(ExDynamic { ref original, .. }) => original[],\n+            Native(ExNative { ref original, .. }) => original[],\n         }\n     }\n \n@@ -608,13 +608,13 @@ impl<'r, 't> Iterator<&'t str> for RegexSplits<'r, 't> {\n                 if self.last >= text.len() {\n                     None\n                 } else {\n-                    let s = text.slice(self.last, text.len());\n+                    let s = text[self.last..text.len()];\n                     self.last = text.len();\n                     Some(s)\n                 }\n             }\n             Some((s, e)) => {\n-                let matched = text.slice(self.last, s);\n+                let matched = text[self.last..s];\n                 self.last = e;\n                 Some(matched)\n             }\n@@ -642,7 +642,7 @@ impl<'r, 't> Iterator<&'t str> for RegexSplitsN<'r, 't> {\n         } else {\n             self.cur += 1;\n             if self.cur >= self.limit {\n-                Some(text.slice(self.splits.last, text.len()))\n+                Some(text[self.splits.last..text.len()])\n             } else {\n                 self.splits.next()\n             }\n@@ -769,13 +769,13 @@ impl<'t> Captures<'t> {\n             let pre = refs.at(1).unwrap_or(\"\");\n             let name = refs.at(2).unwrap_or(\"\");\n             format!(\"{}{}\", pre,\n-                    match from_str::<uint>(name.as_slice()) {\n+                    match name.parse::<uint>() {\n                 None => self.name(name).unwrap_or(\"\").to_string(),\n                 Some(i) => self.at(i).unwrap_or(\"\").to_string(),\n             })\n         });\n         let re = Regex::new(r\"\\$\\$\").unwrap();\n-        re.replace_all(text.as_slice(), NoExpand(\"$\"))\n+        re.replace_all(text[], NoExpand(\"$\"))\n     }\n \n     /// Returns the number of captured groups."}, {"sha": "0fd69ea25bc0d1361edec3b515047fa2ee3a3294", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -250,10 +250,12 @@ impl LintPass for TypeLimits {\n                         let (min, max) = float_ty_range(t);\n                         let lit_val: f64 = match lit.node {\n                             ast::LitFloat(ref v, _) |\n-                            ast::LitFloatUnsuffixed(ref v) => match from_str(v.get()) {\n-                                Some(f) => f,\n-                                None => return\n-                            },\n+                            ast::LitFloatUnsuffixed(ref v) => {\n+                                match v.parse() {\n+                                    Some(f) => f,\n+                                    None => return\n+                                }\n+                            }\n                             _ => panic!()\n                         };\n                         if lit_val < min || lit_val > max {\n@@ -507,7 +509,7 @@ impl BoxPointers {\n         if n_uniq > 0 {\n             let s = ty_to_string(cx.tcx, ty);\n             let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(BOX_POINTERS, span, m.as_slice());\n+            cx.span_lint(BOX_POINTERS, span, m[]);\n         }\n     }\n }\n@@ -587,7 +589,7 @@ impl LintPass for RawPointerDeriving {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        if !attr::contains_name(item.attrs.as_slice(), \"automatically_derived\") {\n+        if !attr::contains_name(item.attrs[], \"automatically_derived\") {\n             return\n         }\n         let did = match item.node {\n@@ -766,11 +768,11 @@ impl LintPass for UnusedResults {\n             ty::ty_enum(did, _) => {\n                 if ast_util::is_local(did) {\n                     if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n-                        warned |= check_must_use(cx, it.attrs.as_slice(), s.span);\n+                        warned |= check_must_use(cx, it.attrs[], s.span);\n                     }\n                 } else {\n                     csearch::get_item_attrs(&cx.sess().cstore, did, |attrs| {\n-                        warned |= check_must_use(cx, attrs.as_slice(), s.span);\n+                        warned |= check_must_use(cx, attrs[], s.span);\n                     });\n                 }\n             }\n@@ -792,7 +794,7 @@ impl LintPass for UnusedResults {\n                             msg.push_str(s.get());\n                         }\n                     }\n-                    cx.span_lint(UNUSED_MUST_USE, sp, msg.as_slice());\n+                    cx.span_lint(UNUSED_MUST_USE, sp, msg[]);\n                     return true;\n                 }\n             }\n@@ -838,7 +840,7 @@ impl NonCamelCaseTypes {\n             } else {\n                 format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n             };\n-            cx.span_lint(NON_CAMEL_CASE_TYPES, span, m.as_slice());\n+            cx.span_lint(NON_CAMEL_CASE_TYPES, span, m[]);\n         }\n     }\n }\n@@ -978,7 +980,7 @@ impl NonSnakeCase {\n         if !is_snake_case(ident) {\n             cx.span_lint(NON_SNAKE_CASE, span,\n                 format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                        sort, s, to_snake_case(s.get())).as_slice());\n+                        sort, s, to_snake_case(s.get()))[]);\n         }\n     }\n }\n@@ -1065,7 +1067,7 @@ impl LintPass for NonUpperCaseGlobals {\n                         format!(\"static constant `{}` should have an uppercase name \\\n                                  such as `{}`\",\n                                 s.get(), s.get().chars().map(|c| c.to_uppercase())\n-                                .collect::<String>().as_slice()).as_slice());\n+                                .collect::<String>()[])[]);\n                 }\n             }\n             _ => {}\n@@ -1082,7 +1084,7 @@ impl LintPass for NonUpperCaseGlobals {\n                         format!(\"static constant in pattern `{}` should have an uppercase \\\n                                  name such as `{}`\",\n                                 s.get(), s.get().chars().map(|c| c.to_uppercase())\n-                                    .collect::<String>().as_slice()).as_slice());\n+                                    .collect::<String>()[])[]);\n                 }\n             }\n             _ => {}\n@@ -1107,7 +1109,7 @@ impl UnusedParens {\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS, value.span,\n                              format!(\"unnecessary parentheses around {}\",\n-                                     msg).as_slice())\n+                                     msg)[])\n             }\n         }\n \n@@ -1209,7 +1211,7 @@ impl LintPass for UnusedImportBraces {\n                                     let m = format!(\"braces around {} is unnecessary\",\n                                                     token::get_ident(*name).get());\n                                     cx.span_lint(UNUSED_IMPORT_BRACES, view_item.span,\n-                                                 m.as_slice());\n+                                                 m[]);\n                                 },\n                                 _ => ()\n                             }\n@@ -1248,7 +1250,7 @@ impl LintPass for NonShorthandFieldPatterns {\n                     if ident.node.as_str() == fieldpat.node.ident.as_str() {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n                                      format!(\"the `{}:` in this pattern is redundant and can \\\n-                                              be removed\", ident.node.as_str()).as_slice())\n+                                              be removed\", ident.node.as_str())[])\n                     }\n                 }\n             }\n@@ -1352,7 +1354,7 @@ impl LintPass for UnusedMut {\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         if let ast::ExprMatch(_, ref arms, _) = e.node {\n             for a in arms.iter() {\n-                self.check_unused_mut_pat(cx, a.pats.as_slice())\n+                self.check_unused_mut_pat(cx, a.pats[])\n             }\n         }\n     }\n@@ -1473,7 +1475,7 @@ impl MissingDoc {\n         });\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS, sp,\n-                format!(\"missing documentation for {}\", desc).as_slice());\n+                format!(\"missing documentation for {}\", desc)[]);\n         }\n     }\n }\n@@ -1487,7 +1489,7 @@ impl LintPass for MissingDoc {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n-                Some(l) => attr::contains_name(l.as_slice(), \"hidden\"),\n+                Some(l) => attr::contains_name(l[], \"hidden\"),\n             }\n         });\n         self.doc_hidden_stack.push(doc_hidden);\n@@ -1509,7 +1511,7 @@ impl LintPass for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n-        self.check_missing_docs_attrs(cx, None, krate.attrs.as_slice(),\n+        self.check_missing_docs_attrs(cx, None, krate.attrs[],\n                                      krate.span, \"crate\");\n     }\n \n@@ -1523,7 +1525,7 @@ impl LintPass for MissingDoc {\n             ast::ItemTy(..) => \"a type alias\",\n             _ => return\n         };\n-        self.check_missing_docs_attrs(cx, Some(it.id), it.attrs.as_slice(),\n+        self.check_missing_docs_attrs(cx, Some(it.id), it.attrs[],\n                                      it.span, desc);\n     }\n \n@@ -1536,13 +1538,13 @@ impl LintPass for MissingDoc {\n \n             // Otherwise, doc according to privacy. This will also check\n             // doc for default methods defined on traits.\n-            self.check_missing_docs_attrs(cx, Some(m.id), m.attrs.as_slice(),\n+            self.check_missing_docs_attrs(cx, Some(m.id), m.attrs[],\n                                           m.span, \"a method\");\n         }\n     }\n \n     fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n-        self.check_missing_docs_attrs(cx, Some(tm.id), tm.attrs.as_slice(),\n+        self.check_missing_docs_attrs(cx, Some(tm.id), tm.attrs[],\n                                      tm.span, \"a type method\");\n     }\n \n@@ -1552,14 +1554,14 @@ impl LintPass for MissingDoc {\n                 let cur_struct_def = *self.struct_def_stack.last()\n                     .expect(\"empty struct_def_stack\");\n                 self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n-                                              sf.node.attrs.as_slice(), sf.span,\n+                                              sf.node.attrs[], sf.span,\n                                               \"a struct field\")\n             }\n         }\n     }\n \n     fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n-        self.check_missing_docs_attrs(cx, Some(v.node.id), v.node.attrs.as_slice(),\n+        self.check_missing_docs_attrs(cx, Some(v.node.id), v.node.attrs[],\n                                      v.span, \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;\n@@ -1675,7 +1677,7 @@ impl Stability {\n             _ => format!(\"use of {} item\", label)\n         };\n \n-        cx.span_lint(lint, span, msg.as_slice());\n+        cx.span_lint(lint, span, msg[]);\n     }\n \n     fn is_internal(&self, cx: &Context, span: Span) -> bool {"}, {"sha": "ffae485364a8625bbc9d3d22cffda256b3aac743", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -104,7 +104,7 @@ impl LintStore {\n     }\n \n     pub fn get_lints<'t>(&'t self) -> &'t [(&'static Lint, bool)] {\n-        self.lints.as_slice()\n+        self.lints[]\n     }\n \n     pub fn get_lint_groups<'t>(&'t self) -> Vec<(&'static str, Vec<LintId>, bool)> {\n@@ -124,11 +124,11 @@ impl LintStore {\n                 match (sess, from_plugin) {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n                     // Use early_error when handling -W help with no crate.\n-                    (None, _) => early_error(msg.as_slice()),\n-                    (Some(sess), false) => sess.bug(msg.as_slice()),\n+                    (None, _) => early_error(msg[]),\n+                    (Some(sess), false) => sess.bug(msg[]),\n \n                     // A duplicate name from a plugin is a user error.\n-                    (Some(sess), true)  => sess.err(msg.as_slice()),\n+                    (Some(sess), true)  => sess.err(msg[]),\n                 }\n             }\n \n@@ -149,11 +149,11 @@ impl LintStore {\n             match (sess, from_plugin) {\n                 // We load builtin lints first, so a duplicate is a compiler bug.\n                 // Use early_error when handling -W help with no crate.\n-                (None, _) => early_error(msg.as_slice()),\n-                (Some(sess), false) => sess.bug(msg.as_slice()),\n+                (None, _) => early_error(msg[]),\n+                (Some(sess), false) => sess.bug(msg[]),\n \n                 // A duplicate name from a plugin is a user error.\n-                (Some(sess), true)  => sess.err(msg.as_slice()),\n+                (Some(sess), true)  => sess.err(msg[]),\n             }\n         }\n     }\n@@ -260,8 +260,8 @@ impl LintStore {\n                 let warning = format!(\"lint {} has been renamed to {}\",\n                                       lint_name, new_name);\n                 match span {\n-                    Some(span) => sess.span_warn(span, warning.as_slice()),\n-                    None => sess.warn(warning.as_slice()),\n+                    Some(span) => sess.span_warn(span, warning[]),\n+                    None => sess.warn(warning[]),\n                 };\n                 Some(lint_id)\n             }\n@@ -271,21 +271,21 @@ impl LintStore {\n \n     pub fn process_command_line(&mut self, sess: &Session) {\n         for &(ref lint_name, level) in sess.opts.lint_opts.iter() {\n-            match self.find_lint(lint_name.as_slice(), sess, None) {\n+            match self.find_lint(lint_name[], sess, None) {\n                 Some(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n                 None => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n                                                  .collect::<FnvHashMap<&'static str,\n                                                                        Vec<LintId>>>()\n-                                                 .get(lint_name.as_slice()) {\n+                                                 .get(lint_name[]) {\n                         Some(v) => {\n                             v.iter()\n                              .map(|lint_id: &LintId|\n                                      self.set_level(*lint_id, (level, CommandLine)))\n                              .collect::<Vec<()>>();\n                         }\n                         None => sess.err(format!(\"unknown {} flag: {}\",\n-                                                 level.as_str(), lint_name).as_slice()),\n+                                                 level.as_str(), lint_name)[]),\n                     }\n                 }\n             }\n@@ -396,10 +396,10 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n     if level == Forbid { level = Deny; }\n \n     match (level, span) {\n-        (Warn, Some(sp)) => sess.span_warn(sp, msg.as_slice()),\n-        (Warn, None)     => sess.warn(msg.as_slice()),\n-        (Deny, Some(sp)) => sess.span_err(sp, msg.as_slice()),\n-        (Deny, None)     => sess.err(msg.as_slice()),\n+        (Warn, Some(sp)) => sess.span_warn(sp, msg[]),\n+        (Warn, None)     => sess.warn(msg[]),\n+        (Deny, Some(sp)) => sess.span_err(sp, msg[]),\n+        (Deny, None)     => sess.err(msg[]),\n         _ => sess.bug(\"impossible level in raw_emit_lint\"),\n     }\n \n@@ -492,7 +492,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                                 None => {\n                                     self.span_lint(builtin::UNKNOWN_LINTS, span,\n                                                format!(\"unknown `{}` attribute: `{}`\",\n-                                                       level.as_str(), lint_name).as_slice());\n+                                                       level.as_str(), lint_name)[]);\n                                     continue;\n                                 }\n                             }\n@@ -508,7 +508,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                     self.tcx.sess.span_err(span,\n                                            format!(\"{}({}) overruled by outer forbid({})\",\n                                                    level.as_str(), lint_name,\n-                                                   lint_name).as_slice());\n+                                                   lint_name)[]);\n                 } else if now != level {\n                     let src = self.lints.get_level_source(lint_id).1;\n                     self.level_stack.push((lint_id, (now, src)));\n@@ -543,22 +543,22 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     fn visit_item(&mut self, it: &ast::Item) {\n-        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n+        self.with_lint_attrs(it.attrs[], |cx| {\n             run_lints!(cx, check_item, it);\n             cx.visit_ids(|v| v.visit_item(it));\n             visit::walk_item(cx, it);\n         })\n     }\n \n     fn visit_foreign_item(&mut self, it: &ast::ForeignItem) {\n-        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n+        self.with_lint_attrs(it.attrs[], |cx| {\n             run_lints!(cx, check_foreign_item, it);\n             visit::walk_foreign_item(cx, it);\n         })\n     }\n \n     fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        self.with_lint_attrs(i.attrs.as_slice(), |cx| {\n+        self.with_lint_attrs(i.attrs[], |cx| {\n             run_lints!(cx, check_view_item, i);\n             cx.visit_ids(|v| v.visit_view_item(i));\n             visit::walk_view_item(cx, i);\n@@ -584,7 +584,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n                 body: &'v ast::Block, span: Span, id: ast::NodeId) {\n         match fk {\n             visit::FkMethod(_, _, m) => {\n-                self.with_lint_attrs(m.attrs.as_slice(), |cx| {\n+                self.with_lint_attrs(m.attrs[], |cx| {\n                     run_lints!(cx, check_fn, fk, decl, body, span, id);\n                     cx.visit_ids(|v| {\n                         v.visit_fn(fk, decl, body, span, id);\n@@ -600,7 +600,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_ty_method(&mut self, t: &ast::TypeMethod) {\n-        self.with_lint_attrs(t.attrs.as_slice(), |cx| {\n+        self.with_lint_attrs(t.attrs[], |cx| {\n             run_lints!(cx, check_ty_method, t);\n             visit::walk_ty_method(cx, t);\n         })\n@@ -617,14 +617,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_struct_field(&mut self, s: &ast::StructField) {\n-        self.with_lint_attrs(s.node.attrs.as_slice(), |cx| {\n+        self.with_lint_attrs(s.node.attrs[], |cx| {\n             run_lints!(cx, check_struct_field, s);\n             visit::walk_struct_field(cx, s);\n         })\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n-        self.with_lint_attrs(v.node.attrs.as_slice(), |cx| {\n+        self.with_lint_attrs(v.node.attrs[], |cx| {\n             run_lints!(cx, check_variant, v, g);\n             visit::walk_variant(cx, v, g);\n             run_lints!(cx, check_variant_post, v, g);\n@@ -718,7 +718,7 @@ impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n             None => {}\n             Some(lints) => {\n                 for (lint_id, span, msg) in lints.into_iter() {\n-                    self.span_lint(lint_id.lint, span, msg.as_slice())\n+                    self.span_lint(lint_id.lint, span, msg[])\n                 }\n             }\n         }\n@@ -764,7 +764,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n     let mut cx = Context::new(tcx, krate, exported_items);\n \n     // Visit the whole crate.\n-    cx.with_lint_attrs(krate.attrs.as_slice(), |cx| {\n+    cx.with_lint_attrs(krate.attrs[], |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n             v.visited_outermost = true;\n@@ -784,7 +784,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n         for &(lint, span, ref msg) in v.iter() {\n             tcx.sess.span_bug(span,\n                               format!(\"unprocessed lint {} at {}: {}\",\n-                                      lint.as_str(), tcx.map.node_to_string(*id), *msg).as_slice())\n+                                      lint.as_str(), tcx.map.node_to_string(*id), *msg)[])\n         }\n     }\n "}, {"sha": "98b57511957f605000ce7a9caa0ae569ec469d19", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -95,11 +95,11 @@ fn warn_if_multiple_versions(diag: &SpanHandler, cstore: &CStore) {\n     for (name, dupes) in map.into_iter() {\n         if dupes.len() == 1 { continue }\n         diag.handler().warn(\n-            format!(\"using multiple versions of crate `{}`\", name).as_slice());\n+            format!(\"using multiple versions of crate `{}`\", name)[]);\n         for dupe in dupes.into_iter() {\n             let data = cstore.get_crate_data(dupe);\n             diag.span_note(data.span, \"used here\");\n-            loader::note_crate_name(diag, data.name().as_slice());\n+            loader::note_crate_name(diag, data.name()[]);\n         }\n     }\n }\n@@ -117,7 +117,7 @@ fn should_link(i: &ast::ViewItem) -> bool {\n     i.attrs.iter().all(|attr| {\n         attr.name().get() != \"phase\" ||\n             attr.meta_item_list().map_or(false, |phases| {\n-                attr::contains_name(phases.as_slice(), \"link\")\n+                attr::contains_name(phases[], \"link\")\n             })\n     })\n }\n@@ -131,8 +131,8 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n         Some(info) => {\n             let (cnum, _, _) = resolve_crate(e,\n                                              &None,\n-                                             info.ident.as_slice(),\n-                                             info.name.as_slice(),\n+                                             info.ident[],\n+                                             info.name[],\n                                              None,\n                                              i.span);\n             e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n@@ -157,7 +157,7 @@ fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n             let name = match *path_opt {\n                 Some((ref path_str, _)) => {\n                     let name = path_str.get().to_string();\n-                    validate_crate_name(Some(e.sess), name.as_slice(),\n+                    validate_crate_name(Some(e.sess), name[],\n                                         Some(i.span));\n                     name\n                 }\n@@ -188,7 +188,7 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     for c in s.chars() {\n         if c.is_alphanumeric() { continue }\n         if c == '_' || c == '-' { continue }\n-        err(format!(\"invalid character `{}` in crate name: `{}`\", c, s).as_slice());\n+        err(format!(\"invalid character `{}` in crate name: `{}`\", c, s)[]);\n     }\n     match sess {\n         Some(sess) => sess.abort_if_errors(),\n@@ -246,7 +246,7 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                                 } else {\n                                     e.sess.span_err(m.span,\n                                         format!(\"unknown kind: `{}`\",\n-                                                k).as_slice());\n+                                                k)[]);\n                                     cstore::NativeUnknown\n                                 }\n                             }\n@@ -327,7 +327,7 @@ fn existing_match(e: &Env, name: &str,\n         match e.sess.opts.externs.get(name) {\n             Some(locs) => {\n                 let found = locs.iter().any(|l| {\n-                    let l = fs::realpath(&Path::new(l.as_slice())).ok();\n+                    let l = fs::realpath(&Path::new(l[])).ok();\n                     l == source.dylib || l == source.rlib\n                 });\n                 if found {\n@@ -405,7 +405,7 @@ fn resolve_crate<'a>(e: &mut Env,\n                 crate_name: name,\n                 hash: hash.map(|a| &*a),\n                 filesearch: e.sess.target_filesearch(),\n-                triple: e.sess.opts.target_triple.as_slice(),\n+                triple: e.sess.opts.target_triple[],\n                 root: root,\n                 rejected_via_hash: vec!(),\n                 rejected_via_triple: vec!(),\n@@ -431,8 +431,8 @@ fn resolve_crate_deps(e: &mut Env,\n     decoder::get_crate_deps(cdata).iter().map(|dep| {\n         debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n         let (local_cnum, _, _) = resolve_crate(e, root,\n-                                               dep.name.as_slice(),\n-                                               dep.name.as_slice(),\n+                                               dep.name[],\n+                                               dep.name[],\n                                                Some(&dep.hash),\n                                                span);\n         (dep.cnum, local_cnum)\n@@ -455,14 +455,14 @@ impl<'a> PluginMetadataReader<'a> {\n \n     pub fn read_plugin_metadata(&mut self, krate: &ast::ViewItem) -> PluginMetadata {\n         let info = extract_crate_info(&self.env, krate).unwrap();\n-        let target_triple = self.env.sess.opts.target_triple.as_slice();\n+        let target_triple = self.env.sess.opts.target_triple[];\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n         let mut load_ctxt = loader::Context {\n             sess: self.env.sess,\n             span: krate.span,\n-            ident: info.ident.as_slice(),\n-            crate_name: info.name.as_slice(),\n+            ident: info.ident[],\n+            crate_name: info.name[],\n             hash: None,\n             filesearch: self.env.sess.host_filesearch(),\n             triple: config::host_triple(),\n@@ -483,7 +483,7 @@ impl<'a> PluginMetadataReader<'a> {\n                     let message = format!(\"crate `{}` contains a plugin_registrar fn but \\\n                                   only a version for triple `{}` could be found (need {})\",\n                                   info.ident, target_triple, config::host_triple());\n-                    self.env.sess.span_err(krate.span, message.as_slice());\n+                    self.env.sess.span_err(krate.span, message[]);\n                     // need to abort now because the syntax expansion\n                     // code will shortly attempt to load and execute\n                     // code from the found library.\n@@ -502,7 +502,7 @@ impl<'a> PluginMetadataReader<'a> {\n             let message = format!(\"plugin crate `{}` only found in rlib format, \\\n                                    but must be available in dylib format\",\n                                   info.ident);\n-            self.env.sess.span_err(krate.span, message.as_slice());\n+            self.env.sess.span_err(krate.span, message[]);\n             // No need to abort because the loading code will just ignore this\n             // empty dylib.\n         }\n@@ -511,11 +511,11 @@ impl<'a> PluginMetadataReader<'a> {\n             macros: macros,\n             registrar_symbol: registrar,\n         };\n-        if should_link && existing_match(&self.env, info.name.as_slice(),\n+        if should_link && existing_match(&self.env, info.name[],\n                                          None).is_none() {\n             // register crate now to avoid double-reading metadata\n-            register_crate(&mut self.env, &None, info.ident.as_slice(),\n-                           info.name.as_slice(), krate.span, library);\n+            register_crate(&mut self.env, &None, info.ident[],\n+                           info.name[], krate.span, library);\n         }\n         pc\n     }"}, {"sha": "13342bf82cfea7bf7128989ea282b5621d095467", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -95,7 +95,7 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    let mut r = vec![ast_map::PathMod(token::intern(cdata.name.as_slice()))];\n+    let mut r = vec![ast_map::PathMod(token::intern(cdata.name[]))];\n     r.push_all(path.as_slice());\n     r\n }"}, {"sha": "b869501237c3a8e1b8ddb9b63be221d79e2032a4", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -221,7 +221,7 @@ fn each_reexport<F>(d: rbml::Doc, f: F) -> bool where\n fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n     reader::maybe_get_doc(d, tag_disr_val).and_then(|val_doc| {\n         reader::with_doc_data(val_doc, |data| {\n-            str::from_utf8(data).and_then(from_str)\n+            str::from_utf8(data).ok().and_then(|s| s.parse())\n         })\n     })\n }\n@@ -1160,7 +1160,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n         let name = docstr(depdoc, tag_crate_dep_crate_name);\n-        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash).as_slice());\n+        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash)[]);\n         deps.push(CrateDep {\n             cnum: crate_num,\n             name: name,\n@@ -1345,7 +1345,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n         if spec.len() == 0 { continue }\n         let cnum = spec.split(':').nth(0).unwrap();\n         let link = spec.split(':').nth(1).unwrap();\n-        let cnum = from_str(cnum).unwrap();\n+        let cnum = cnum.parse().unwrap();\n         let cnum = match cdata.cnum_map.get(&cnum) {\n             Some(&n) => n,\n             None => panic!(\"didn't find a crate in the cnum_map\")"}, {"sha": "6782b3a74813e668e9aa680018ca9f1fd1753ec6", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -95,7 +95,7 @@ fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Ident) {\n }\n \n pub fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_str(tag_def_id, def_to_string(id).as_slice());\n+    rbml_w.wr_tagged_str(tag_def_id, def_to_string(id)[]);\n }\n \n #[deriving(Clone)]\n@@ -154,7 +154,7 @@ fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n     rbml_w.end_tag();\n \n     rbml_w.start_tag(tag_mod_child);\n-    rbml_w.wr_str(s.as_slice());\n+    rbml_w.wr_str(s[]);\n     rbml_w.end_tag();\n }\n \n@@ -264,7 +264,7 @@ fn encode_symbol(ecx: &EncodeContext,\n         }\n         None => {\n             ecx.diag.handler().bug(\n-                format!(\"encode_symbol: id not found {}\", id).as_slice());\n+                format!(\"encode_symbol: id not found {}\", id)[]);\n         }\n     }\n     rbml_w.end_tag();\n@@ -332,8 +332,8 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_name(rbml_w, variant.node.name.name);\n         encode_parent_item(rbml_w, local_def(id));\n         encode_visibility(rbml_w, variant.node.vis);\n-        encode_attributes(rbml_w, variant.node.attrs.as_slice());\n-        encode_repr_attrs(rbml_w, ecx, variant.node.attrs.as_slice());\n+        encode_attributes(rbml_w, variant.node.attrs[]);\n+        encode_repr_attrs(rbml_w, ecx, variant.node.attrs[]);\n \n         let stab = stability::lookup(ecx.tcx, ast_util::local_def(variant.node.id));\n         encode_stability(rbml_w, stab);\n@@ -344,9 +344,9 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n                 let idx = encode_info_for_struct(ecx,\n                                                  rbml_w,\n-                                                 fields.as_slice(),\n+                                                 fields[],\n                                                  index);\n-                encode_struct_fields(rbml_w, fields.as_slice(), def_id);\n+                encode_struct_fields(rbml_w, fields[], def_id);\n                 encode_index(rbml_w, idx, write_i64);\n             }\n         }\n@@ -386,12 +386,12 @@ fn encode_reexported_static_method(rbml_w: &mut Encoder,\n             exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n     rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    rbml_w.wr_str(def_to_string(method_def_id).as_slice());\n+    rbml_w.wr_str(def_to_string(method_def_id)[]);\n     rbml_w.end_tag();\n     rbml_w.start_tag(tag_items_data_item_reexport_name);\n     rbml_w.wr_str(format!(\"{}::{}\",\n                           exp.name,\n-                          token::get_name(method_name)).as_slice());\n+                          token::get_name(method_name))[]);\n     rbml_w.end_tag();\n     rbml_w.end_tag();\n }\n@@ -529,7 +529,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                        id);\n                 rbml_w.start_tag(tag_items_data_item_reexport);\n                 rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                rbml_w.wr_str(def_to_string(exp.def_id).as_slice());\n+                rbml_w.wr_str(def_to_string(exp.def_id)[]);\n                 rbml_w.end_tag();\n                 rbml_w.start_tag(tag_items_data_item_reexport_name);\n                 rbml_w.wr_str(exp.name.as_str());\n@@ -562,13 +562,13 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     // Encode info about all the module children.\n     for item in md.items.iter() {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n+        rbml_w.wr_str(def_to_string(local_def(item.id))[]);\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(def_to_string(local_def(\n-                        auxiliary_node_id)).as_slice());\n+                        auxiliary_node_id))[]);\n             rbml_w.end_tag();\n             true\n         });\n@@ -580,7 +580,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                    did, ecx.tcx.map.node_to_string(did));\n \n             rbml_w.start_tag(tag_mod_impl);\n-            rbml_w.wr_str(def_to_string(local_def(did)).as_slice());\n+            rbml_w.wr_str(def_to_string(local_def(did))[]);\n             rbml_w.end_tag();\n         }\n     }\n@@ -615,7 +615,7 @@ fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n         ast::Public => 'y',\n         ast::Inherited => 'i',\n     };\n-    rbml_w.wr_str(ch.to_string().as_slice());\n+    rbml_w.wr_str(ch.to_string()[]);\n     rbml_w.end_tag();\n }\n \n@@ -627,7 +627,7 @@ fn encode_unboxed_closure_kind(rbml_w: &mut Encoder,\n         ty::FnMutUnboxedClosureKind => 'm',\n         ty::FnOnceUnboxedClosureKind => 'o',\n     };\n-    rbml_w.wr_str(ch.to_string().as_slice());\n+    rbml_w.wr_str(ch.to_string()[]);\n     rbml_w.end_tag();\n }\n \n@@ -788,7 +788,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n \n         rbml_w.wr_tagged_str(tag_region_param_def_def_id,\n-                             def_to_string(param.def_id).as_slice());\n+                             def_to_string(param.def_id)[]);\n \n         rbml_w.wr_tagged_u64(tag_region_param_def_space,\n                              param.space.to_uint() as u64);\n@@ -864,9 +864,9 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n     match ast_item_opt {\n         Some(&ast::MethodImplItem(ref ast_method)) => {\n-            encode_attributes(rbml_w, ast_method.attrs.as_slice());\n+            encode_attributes(rbml_w, ast_method.attrs[]);\n             let any_types = !pty.generics.types.is_empty();\n-            if any_types || is_default_impl || should_inline(ast_method.attrs.as_slice()) {\n+            if any_types || is_default_impl || should_inline(ast_method.attrs[]) {\n                 encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n                                                                ast_item_opt.unwrap()));\n             }\n@@ -909,7 +909,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     match typedef_opt {\n         None => {}\n         Some(typedef) => {\n-            encode_attributes(rbml_w, typedef.attrs.as_slice());\n+            encode_attributes(rbml_w, typedef.attrs[]);\n             encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx,\n                                                          typedef.id));\n         }\n@@ -1043,7 +1043,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n-        encode_attributes(rbml_w, item.attrs.as_slice());\n+        encode_attributes(rbml_w, item.attrs[]);\n         rbml_w.end_tag();\n       }\n       ast::ItemConst(_, _) => {\n@@ -1069,8 +1069,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n-        encode_attributes(rbml_w, item.attrs.as_slice());\n-        if tps_len > 0u || should_inline(item.attrs.as_slice()) {\n+        encode_attributes(rbml_w, item.attrs[]);\n+        if tps_len > 0u || should_inline(item.attrs[]) {\n             encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         }\n         if tps_len == 0 {\n@@ -1086,7 +1086,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_info_for_mod(ecx,\n                             rbml_w,\n                             m,\n-                            item.attrs.as_slice(),\n+                            item.attrs[],\n                             item.id,\n                             path,\n                             item.ident,\n@@ -1103,7 +1103,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode all the items in this module.\n         for foreign_item in fm.items.iter() {\n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(local_def(foreign_item.id)).as_slice());\n+            rbml_w.wr_str(def_to_string(local_def(foreign_item.id))[]);\n             rbml_w.end_tag();\n         }\n         encode_visibility(rbml_w, vis);\n@@ -1131,8 +1131,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.as_slice());\n-        encode_repr_attrs(rbml_w, ecx, item.attrs.as_slice());\n+        encode_attributes(rbml_w, item.attrs[]);\n+        encode_repr_attrs(rbml_w, ecx, item.attrs[]);\n         for v in (*enum_definition).variants.iter() {\n             encode_variant_id(rbml_w, local_def(v.node.id));\n         }\n@@ -1149,7 +1149,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_enum_variant_info(ecx,\n                                  rbml_w,\n                                  item.id,\n-                                 (*enum_definition).variants.as_slice(),\n+                                 (*enum_definition).variants[],\n                                  index);\n       }\n       ast::ItemStruct(ref struct_def, _) => {\n@@ -1161,7 +1161,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            class itself */\n         let idx = encode_info_for_struct(ecx,\n                                          rbml_w,\n-                                         fields.as_slice(),\n+                                         fields[],\n                                          index);\n \n         /* Index the class*/\n@@ -1175,16 +1175,16 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.as_slice());\n+        encode_attributes(rbml_w, item.attrs[]);\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n         encode_visibility(rbml_w, vis);\n-        encode_repr_attrs(rbml_w, ecx, item.attrs.as_slice());\n+        encode_repr_attrs(rbml_w, ecx, item.attrs[]);\n \n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(rbml_w, fields.as_slice(), def_id);\n+        encode_struct_fields(rbml_w, fields[], def_id);\n \n         encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n \n@@ -1216,7 +1216,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(rbml_w, 'i');\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.as_slice());\n+        encode_attributes(rbml_w, item.attrs[]);\n         encode_unsafety(rbml_w, unsafety);\n         match ty.node {\n             ast::TyPath(ref path, _) if path.segments\n@@ -1319,7 +1319,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_generics(rbml_w, ecx, &trait_def.generics, tag_item_generics);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.as_slice());\n+        encode_attributes(rbml_w, item.attrs[]);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         for &method_def_id in ty::trait_item_def_ids(tcx, def_id).iter() {\n@@ -1337,7 +1337,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             rbml_w.end_tag();\n \n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(method_def_id.def_id()).as_slice());\n+            rbml_w.wr_str(def_to_string(method_def_id.def_id())[]);\n             rbml_w.end_tag();\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1422,14 +1422,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             };\n             match trait_item {\n                 &ast::RequiredMethod(ref m) => {\n-                    encode_attributes(rbml_w, m.attrs.as_slice());\n+                    encode_attributes(rbml_w, m.attrs[]);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'r');\n                     encode_method_argument_names(rbml_w, &*m.decl);\n                 }\n \n                 &ast::ProvidedMethod(ref m) => {\n-                    encode_attributes(rbml_w, m.attrs.as_slice());\n+                    encode_attributes(rbml_w, m.attrs[]);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'p');\n                     encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n@@ -1438,7 +1438,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                 &ast::TypeTraitItem(ref associated_type) => {\n                     encode_attributes(rbml_w,\n-                                      associated_type.attrs.as_slice());\n+                                      associated_type.attrs[]);\n                     encode_item_sort(rbml_w, 't');\n                 }\n             }\n@@ -1802,7 +1802,7 @@ fn encode_macro_def(ecx: &EncodeContext,\n     let def = ecx.tcx.sess.codemap().span_to_snippet(*span)\n         .expect(\"Unable to find source for macro\");\n     rbml_w.start_tag(tag_macro_def);\n-    rbml_w.wr_str(def.as_slice());\n+    rbml_w.wr_str(def[]);\n     rbml_w.end_tag();\n }\n \n@@ -1849,7 +1849,7 @@ fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &ast::Crate) {\n         fn visit_struct_field(&mut self, field: &ast::StructField) {\n             self.rbml_w.start_tag(tag_struct_field);\n             self.rbml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n-            encode_attributes(self.rbml_w, field.node.attrs.as_slice());\n+            encode_attributes(self.rbml_w, field.node.attrs[]);\n             self.rbml_w.end_tag();\n         }\n     }\n@@ -1921,13 +1921,13 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in krate.module.items.iter() {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n+        rbml_w.wr_str(def_to_string(local_def(item.id))[]);\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(def_to_string(local_def(\n-                        auxiliary_node_id)).as_slice());\n+                        auxiliary_node_id))[]);\n             rbml_w.end_tag();\n             true\n         });\n@@ -2096,17 +2096,17 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n \n     let mut rbml_w = writer::Encoder::new(wr);\n \n-    encode_crate_name(&mut rbml_w, ecx.link_meta.crate_name.as_slice());\n+    encode_crate_name(&mut rbml_w, ecx.link_meta.crate_name[]);\n     encode_crate_triple(&mut rbml_w,\n                         tcx.sess\n                            .opts\n                            .target_triple\n-                           .as_slice());\n+                           []);\n     encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);\n     encode_dylib_dependency_formats(&mut rbml_w, &ecx);\n \n     let mut i = rbml_w.writer.tell().unwrap();\n-    encode_attributes(&mut rbml_w, krate.attrs.as_slice());\n+    encode_attributes(&mut rbml_w, krate.attrs[]);\n     stats.attr_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     i = rbml_w.writer.tell().unwrap();"}, {"sha": "5f554eb9c1e5c0dc577490f68704a11816d3356d", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -316,14 +316,14 @@ impl<'a> Context<'a> {\n             &Some(ref r) => format!(\"{} which `{}` depends on\",\n                                     message, r.ident)\n         };\n-        self.sess.span_err(self.span, message.as_slice());\n+        self.sess.span_err(self.span, message[]);\n \n         if self.rejected_via_triple.len() > 0 {\n             let mismatches = self.rejected_via_triple.iter();\n             for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     format!(\"crate `{}`, path #{}, triple {}: {}\",\n-                            self.ident, i+1, got, path.display()).as_slice());\n+                            self.ident, i+1, got, path.display())[]);\n             }\n         }\n         if self.rejected_via_hash.len() > 0 {\n@@ -333,15 +333,15 @@ impl<'a> Context<'a> {\n             for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     format!(\"crate `{}` path {}{}: {}\",\n-                            self.ident, \"#\", i+1, path.display()).as_slice());\n+                            self.ident, \"#\", i+1, path.display())[]);\n             }\n             match self.root {\n                 &None => {}\n                 &Some(ref r) => {\n                     for (i, path) in r.paths().iter().enumerate() {\n                         self.sess.fileline_note(self.span,\n                             format!(\"crate `{}` path #{}: {}\",\n-                                    r.ident, i+1, path.display()).as_slice());\n+                                    r.ident, i+1, path.display())[]);\n                     }\n                 }\n             }\n@@ -387,7 +387,7 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            let (hash, rlib) = if file.starts_with(rlib_prefix.as_slice()) &&\n+            let (hash, rlib) = if file.starts_with(rlib_prefix[]) &&\n                     file.ends_with(\".rlib\") {\n                 (file.slice(rlib_prefix.len(), file.len() - \".rlib\".len()),\n                  true)\n@@ -448,26 +448,26 @@ impl<'a> Context<'a> {\n             _ => {\n                 self.sess.span_err(self.span,\n                     format!(\"multiple matching crates for `{}`\",\n-                            self.crate_name).as_slice());\n+                            self.crate_name)[]);\n                 self.sess.note(\"candidates:\");\n                 for lib in libraries.iter() {\n                     match lib.dylib {\n                         Some(ref p) => {\n                             self.sess.note(format!(\"path: {}\",\n-                                                   p.display()).as_slice());\n+                                                   p.display())[]);\n                         }\n                         None => {}\n                     }\n                     match lib.rlib {\n                         Some(ref p) => {\n                             self.sess.note(format!(\"path: {}\",\n-                                                   p.display()).as_slice());\n+                                                   p.display())[]);\n                         }\n                         None => {}\n                     }\n                     let data = lib.metadata.as_slice();\n                     let name = decoder::get_crate_name(data);\n-                    note_crate_name(self.sess.diagnostic(), name.as_slice());\n+                    note_crate_name(self.sess.diagnostic(), name[]);\n                 }\n                 None\n             }\n@@ -521,19 +521,19 @@ impl<'a> Context<'a> {\n                                    format!(\"multiple {} candidates for `{}` \\\n                                             found\",\n                                            flavor,\n-                                           self.crate_name).as_slice());\n+                                           self.crate_name)[]);\n                 self.sess.span_note(self.span,\n                                     format!(r\"candidate #1: {}\",\n                                             ret.as_ref().unwrap()\n-                                               .display()).as_slice());\n+                                               .display())[]);\n                 error = 1;\n                 ret = None;\n             }\n             if error > 0 {\n                 error += 1;\n                 self.sess.span_note(self.span,\n                                     format!(r\"candidate #{}: {}\", error,\n-                                            lib.display()).as_slice());\n+                                            lib.display())[]);\n                 continue\n             }\n             *slot = Some(metadata);\n@@ -608,30 +608,30 @@ impl<'a> Context<'a> {\n         let mut rlibs = HashSet::new();\n         let mut dylibs = HashSet::new();\n         {\n-            let mut locs = locs.iter().map(|l| Path::new(l.as_slice())).filter(|loc| {\n+            let mut locs = locs.iter().map(|l| Path::new(l[])).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(format!(\"extern location for {} does not exist: {}\",\n-                                     self.crate_name, loc.display()).as_slice());\n+                                     self.crate_name, loc.display())[]);\n                     return false;\n                 }\n                 let file = match loc.filename_str() {\n                     Some(file) => file,\n                     None => {\n                         sess.err(format!(\"extern location for {} is not a file: {}\",\n-                                         self.crate_name, loc.display()).as_slice());\n+                                         self.crate_name, loc.display())[]);\n                         return false;\n                     }\n                 };\n                 if file.starts_with(\"lib\") && file.ends_with(\".rlib\") {\n                     return true\n                 } else {\n                     let (ref prefix, ref suffix) = dylibname;\n-                    if file.starts_with(prefix.as_slice()) && file.ends_with(suffix.as_slice()) {\n+                    if file.starts_with(prefix[]) && file.ends_with(suffix[]) {\n                         return true\n                     }\n                 }\n                 sess.err(format!(\"extern location for {} is of an unknown type: {}\",\n-                                 self.crate_name, loc.display()).as_slice());\n+                                 self.crate_name, loc.display())[]);\n                 false\n             });\n \n@@ -664,7 +664,7 @@ impl<'a> Context<'a> {\n }\n \n pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n-    diag.handler().note(format!(\"crate name: {}\", name).as_slice());\n+    diag.handler().note(format!(\"crate name: {}\", name)[]);\n }\n \n impl ArchiveMetadata {"}, {"sha": "7683506f0f4a9e75d1131c44706161fced556392", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -233,7 +233,7 @@ fn parse_trait_store(st: &mut PState, conv: conv_did) -> ty::TraitStore {\n         '&' => ty::RegionTraitStore(parse_region(st, conv), parse_mutability(st)),\n         c => {\n             st.tcx.sess.bug(format!(\"parse_trait_store(): bad input '{}'\",\n-                                    c).as_slice())\n+                                    c)[])\n         }\n     }\n }\n@@ -287,7 +287,7 @@ fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::BoundRegion {\n         }\n         '[' => {\n             let def = parse_def(st, RegionParameter, |x,y| conv(x,y));\n-            let ident = token::str_to_ident(parse_str(st, ']').as_slice());\n+            let ident = token::str_to_ident(parse_str(st, ']')[]);\n             ty::BrNamed(def, ident.name)\n         }\n         'f' => {\n@@ -318,7 +318,7 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n         assert_eq!(next(st), '|');\n         let index = parse_uint(st);\n         assert_eq!(next(st), '|');\n-        let nm = token::str_to_ident(parse_str(st, ']').as_slice());\n+        let nm = token::str_to_ident(parse_str(st, ']')[]);\n         ty::ReEarlyBound(node_id, space, index, nm.name)\n       }\n       'f' => {\n@@ -560,7 +560,7 @@ fn parse_abi_set(st: &mut PState) -> abi::Abi {\n     assert_eq!(next(st), '[');\n     scan(st, |c| c == ']', |bytes| {\n         let abi_str = str::from_utf8(bytes).unwrap();\n-        abi::lookup(abi_str.as_slice()).expect(abi_str)\n+        abi::lookup(abi_str[]).expect(abi_str)\n     })\n }\n \n@@ -639,12 +639,12 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     let crate_part = buf[0u..colon_idx];\n     let def_part = buf[colon_idx + 1u..len];\n \n-    let crate_num = match str::from_utf8(crate_part).and_then(from_str::<uint>) {\n+    let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| s.parse::<uint>()) {\n        Some(cn) => cn as ast::CrateNum,\n        None => panic!(\"internal error: parse_def_id: crate number expected, found {}\",\n                      crate_part)\n     };\n-    let def_num = match str::from_utf8(def_part).and_then(from_str::<uint>) {\n+    let def_num = match str::from_utf8(def_part).ok().and_then(|s| s.parse::<uint>()) {\n        Some(dn) => dn as ast::NodeId,\n        None => panic!(\"internal error: parse_def_id: id expected, found {}\",\n                      def_part)"}, {"sha": "060e2f67faf988a0c6266b86f0fdca155ca8e43d", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -48,7 +48,7 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n                 None => {\n                     tcx.sess.span_bug(ast_ty.span,\n                                       format!(\"unbound path {}\",\n-                                              path.repr(tcx)).as_slice())\n+                                              path.repr(tcx))[])\n                 }\n                 Some(&d) => d\n             };"}, {"sha": "ce86d6805b26ff2bbe593fbabbdde9350cb898a5", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -132,7 +132,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n             // Do an Option dance to use the path after it is moved below.\n             let s = ast_map::path_to_string(ast_map::Values(path.iter()));\n             path_as_str = Some(s);\n-            path_as_str.as_ref().map(|x| x.as_slice())\n+            path_as_str.as_ref().map(|x| x[])\n         });\n         let mut ast_dsr = reader::Decoder::new(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n@@ -1876,7 +1876,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n             None => {\n                 dcx.tcx.sess.bug(\n                     format!(\"unknown tag found in side tables: {:x}\",\n-                            tag).as_slice());\n+                            tag)[]);\n             }\n             Some(value) => {\n                 let val_doc = entry_doc.get(c::tag_table_val as uint);\n@@ -1961,7 +1961,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     _ => {\n                         dcx.tcx.sess.bug(\n                             format!(\"unknown tag found in side tables: {:x}\",\n-                                    tag).as_slice());\n+                                    tag)[]);\n                     }\n                 }\n             }"}, {"sha": "2d50757782dbd3419c0d97276837c615ed22adf3", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -362,7 +362,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let mut cond_exit = discr_exit;\n                 for arm in arms.iter() {\n                     cond_exit = self.add_dummy_node(&[cond_exit]);        // 2\n-                    let pats_exit = self.pats_any(arm.pats.as_slice(),\n+                    let pats_exit = self.pats_any(arm.pats[],\n                                                   cond_exit);            // 3\n                     let guard_exit = self.opt_expr(&arm.guard,\n                                                    pats_exit);           // 4\n@@ -617,14 +617,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n                             format!(\"no loop scope for id {}\",\n-                                    loop_id).as_slice());\n+                                    loop_id)[]);\n                     }\n \n                     r => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n                             format!(\"bad entry `{}` in def_map for label\",\n-                                    r).as_slice());\n+                                    r)[]);\n                     }\n                 }\n             }"}, {"sha": "13bd22a67c410dc2da59f07d217198f41037e568", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -50,7 +50,7 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n }\n \n impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(self.name.as_slice()).unwrap() }\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(self.name[]).unwrap() }\n \n     fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n         dot::Id::new(format!(\"N{}\", i.node_id())).unwrap()\n@@ -83,8 +83,7 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n             let s = self.ast_map.node_to_string(node_id);\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n-            label.push_str(format!(\"exiting scope_{} {}\", i,\n-                                   s.as_slice()).as_slice());\n+            label.push_str(format!(\"exiting scope_{} {}\", i, s[])[]);\n         }\n         dot::EscStr(label.into_cow())\n     }"}, {"sha": "5a08d7c179d1cc238466f96fb534182a8ea0ebb7", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -74,13 +74,11 @@ impl<'a> CheckLoopVisitor<'a> {\n             Loop => {}\n             Closure => {\n                 self.sess.span_err(span,\n-                                   format!(\"`{}` inside of a closure\",\n-                                           name).as_slice());\n+                                   format!(\"`{}` inside of a closure\", name)[]);\n             }\n             Normal => {\n                 self.sess.span_err(span,\n-                                   format!(\"`{}` outside of loop\",\n-                                           name).as_slice());\n+                                   format!(\"`{}` outside of loop\", name)[]);\n             }\n         }\n     }"}, {"sha": "da1bd09ceffddcbffc99c71daf513ad76bda9f2c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -162,7 +162,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 // First, check legality of move bindings.\n                 check_legality_of_move_bindings(cx,\n                                                 arm.guard.is_some(),\n-                                                arm.pats.as_slice());\n+                                                arm.pats[]);\n \n                 // Second, if there is a guard on each arm, make sure it isn't\n                 // assigning or borrowing anything mutably.\n@@ -199,7 +199,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n             }\n \n             // Fourth, check for unreachable arms.\n-            check_arms(cx, inlined_arms.as_slice(), source);\n+            check_arms(cx, inlined_arms[], source);\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n@@ -231,7 +231,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                     pat.span,\n                     format!(\"refutable pattern in `for` loop binding: \\\n                             `{}` not covered\",\n-                            pat_to_string(uncovered_pat)).as_slice());\n+                            pat_to_string(uncovered_pat))[]);\n             });\n \n             // Check legality of move bindings.\n@@ -304,7 +304,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n         for pat in pats.iter() {\n             let v = vec![&**pat];\n \n-            match is_useful(cx, &seen, v.as_slice(), LeaveOutWitness) {\n+            match is_useful(cx, &seen, v[], LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n                         ast::MatchSource::IfLetDesugar { .. } => {\n@@ -356,7 +356,7 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n     match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n-            let witness = match pats.as_slice() {\n+            let witness = match pats[] {\n                 [ref witness] => &**witness,\n                 [] => DUMMY_WILD_PAT,\n                 _ => unreachable!()\n@@ -610,7 +610,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n                         UsefulWithWitness(pats) => UsefulWithWitness({\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n-                                let pat_slice = pats.as_slice();\n+                                let pat_slice = pats[];\n                                 let subpats = Vec::from_fn(arity, |i| {\n                                     pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n                                 });\n@@ -657,10 +657,10 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n                          witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, r.as_slice(), &ctor, 0u, arity)\n+        specialize(cx, r[], &ctor, 0u, arity)\n     }).collect());\n     match specialize(cx, v, &ctor, 0u, arity) {\n-        Some(v) => is_useful(cx, &matrix, v.as_slice(), witness),\n+        Some(v) => is_useful(cx, &matrix, v[], witness),\n         None => NotUseful\n     }\n }\n@@ -1047,7 +1047,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                             format!(\"binding pattern {} is not an \\\n                                      identifier: {}\",\n                                     p.id,\n-                                    p.node).as_slice());\n+                                    p.node)[]);\n                     }\n                 }\n             }"}, {"sha": "6ff34d625005f19807b91fc95e36869ad43d9eeb", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n         };\n \n         self.tcx.sess.span_err(e.span, format!(\"mutable statics are not allowed \\\n-                                                to have {}\", suffix).as_slice());\n+                                                to have {}\", suffix)[]);\n     }\n \n     fn check_static_type(&self, e: &ast::Expr) {\n@@ -168,7 +168,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n             ty::ty_enum(did, _) if ty::has_dtor(self.tcx, did) => {\n                 self.tcx.sess.span_err(e.span,\n                                        format!(\"{} are not allowed to have \\\n-                                                destructors\", self.msg()).as_slice())\n+                                                destructors\", self.msg())[])\n             }\n             _ => {}\n         }\n@@ -232,7 +232,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n                         let msg = \"constants cannot refer to other statics, \\\n                                    insert an intermediate constant \\\n                                    instead\";\n-                        self.tcx.sess.span_err(e.span, msg.as_slice());\n+                        self.tcx.sess.span_err(e.span, msg[]);\n                     }\n                     _ => {}\n                 }"}, {"sha": "c36b4aa7f231e741c9135470c919429d6259b5b6", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n                           _ => {\n                             self.sess.span_err(e.span,\n                               format!(\"expected item, found {}\",\n-                                      self.ast_map.node_to_string(def_id.node)).as_slice());\n+                                      self.ast_map.node_to_string(def_id.node))[]);\n                             return;\n                           },\n                         }"}, {"sha": "5b89912dd03fcadec6cd0f130a82ad7dc44bf1d7", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -117,7 +117,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n-                    variant_expr(variants.as_slice(), variant_def.node)\n+                    variant_expr(variants[], variant_def.node)\n                 }\n                 _ => None\n             },\n@@ -138,7 +138,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n                     // NOTE this doesn't do the right thing, it compares inlined\n                     // NodeId's to the original variant_def's NodeId, but they\n                     // come from different crates, so they will likely never match.\n-                    variant_expr(variants.as_slice(), variant_def.node).map(|e| e.id)\n+                    variant_expr(variants[], variant_def.node).map(|e| e.id)\n                 }\n                 _ => None\n             },\n@@ -364,7 +364,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n         Ok(r) => r,\n-        Err(s) => tcx.sess.span_fatal(e.span, s.as_slice())\n+        Err(s) => tcx.sess.span_fatal(e.span, s[])\n     }\n }\n \n@@ -603,7 +603,7 @@ pub fn lit_to_const(lit: &ast::Lit) -> const_val {\n         ast::LitInt(n, ast::UnsignedIntLit(_)) => const_uint(n),\n         ast::LitFloat(ref n, _) |\n         ast::LitFloatUnsuffixed(ref n) => {\n-            const_float(from_str::<f64>(n.get()).unwrap() as f64)\n+            const_float(n.get().parse::<f64>().unwrap() as f64)\n         }\n         ast::LitBool(b) => const_bool(b)\n     }"}, {"sha": "a2d417ca345d8830312762bbffcf30f09d92b83b", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -311,7 +311,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let mut t = on_entry.to_vec();\n                 self.apply_gen_kill(cfgidx, t.as_mut_slice());\n                 temp_bits = t;\n-                temp_bits.as_slice()\n+                temp_bits[]\n             }\n         };\n         debug!(\"{} each_bit_for_node({}, cfgidx={}) bits={}\",\n@@ -420,7 +420,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let bits = self.kills.slice_mut(start, end);\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n-                bits.clone_from_slice(orig_kills.as_slice());\n+                bits.clone_from_slice(orig_kills[]);\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={} bits={} [after]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n             }\n@@ -553,7 +553,7 @@ fn bits_to_string(words: &[uint]) -> String {\n         let mut v = word;\n         for _ in range(0u, uint::BYTES) {\n             result.push(sep);\n-            result.push_str(format!(\"{:02x}\", v & 0xFF).as_slice());\n+            result.push_str(format!(\"{:02x}\", v & 0xFF)[]);\n             v >>= 8;\n             sep = '-';\n         }"}, {"sha": "6b56ece28bdb2e30968a38e13bbfffc17c316621", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -118,7 +118,7 @@ fn calculate_type(sess: &session::Session,\n                 let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n                 if src.rlib.is_some() { return }\n                 sess.err(format!(\"dependency `{}` not found in rlib format\",\n-                                 data.name).as_slice());\n+                                 data.name)[]);\n             });\n             return Vec::new();\n         }\n@@ -197,7 +197,7 @@ fn calculate_type(sess: &session::Session,\n                                  match kind {\n                                      cstore::RequireStatic => \"rlib\",\n                                      cstore::RequireDynamic => \"dylib\",\n-                                 }).as_slice());\n+                                 })[]);\n             }\n         }\n     }\n@@ -222,7 +222,7 @@ fn add_library(sess: &session::Session,\n                 let data = sess.cstore.get_crate_data(cnum);\n                 sess.err(format!(\"cannot satisfy dependencies so `{}` only \\\n                                   shows up once\",\n-                                 data.name).as_slice());\n+                                 data.name)[]);\n                 sess.help(\"having upstream crates all available in one format \\\n                            will likely make this go away\");\n             }"}, {"sha": "4ee0064b0e6a195091c9ae210af5c2f647924922", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -678,7 +678,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         self.tcx().sess.span_bug(\n                             callee.span,\n                             format!(\"unexpected callee type {}\",\n-                                    callee_ty.repr(self.tcx())).as_slice())\n+                                    callee_ty.repr(self.tcx()))[])\n                     }\n                 };\n                 match overloaded_call_type {\n@@ -869,7 +869,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,\n                                 format!(\"bad overloaded deref type {}\",\n-                                    method_ty.repr(self.tcx())).as_slice())\n+                                    method_ty.repr(self.tcx()))[])\n                     };\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.delegate.borrow(expr.id, expr.span, cmt,\n@@ -1186,7 +1186,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // pattern.\n \n                             let msg = format!(\"Pattern has unexpected type: {}\", def);\n-                            tcx.sess.span_bug(pat.span, msg.as_slice())\n+                            tcx.sess.span_bug(pat.span, msg[])\n                         }\n \n                         Some(def) => {\n@@ -1195,7 +1195,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // should not resolve.\n \n                             let msg = format!(\"Pattern has unexpected def: {}\", def);\n-                            tcx.sess.span_bug(pat.span, msg.as_slice())\n+                            tcx.sess.span_bug(pat.span, msg[])\n                         }\n                     }\n                 }"}, {"sha": "11ab44ba09ff5d44ed1d09b811e886e17e0147a9", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -141,7 +141,7 @@ pub trait Combine<'tcx> {\n                             for _ in a_regions.iter() {\n                                 invariance.push(ty::Invariant);\n                             }\n-                            invariance.as_slice()\n+                            invariance[]\n                         }\n                     };\n \n@@ -411,7 +411,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n             format!(\"{}: bot and var types should have been handled ({},{})\",\n                     this.tag(),\n                     a.repr(this.infcx().tcx),\n-                    b.repr(this.infcx().tcx)).as_slice());\n+                    b.repr(this.infcx().tcx))[]);\n       }\n \n       (&ty::ty_err, _) | (_, &ty::ty_err) => {"}, {"sha": "0ea3d415ec5cea47b77dc39092d16a8222b09cb9", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -199,9 +199,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                 ref trace_origins,\n                                 ref same_regions) => {\n                     if !same_regions.is_empty() {\n-                        self.report_processed_errors(var_origins.as_slice(),\n-                                                     trace_origins.as_slice(),\n-                                                     same_regions.as_slice());\n+                        self.report_processed_errors(var_origins[],\n+                                                     trace_origins[],\n+                                                     same_regions[]);\n                     }\n                 }\n             }\n@@ -374,7 +374,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             format!(\"{}: {} ({})\",\n                  message_root_str,\n                  expected_found_str,\n-                 ty::type_err_to_str(self.tcx, terr)).as_slice());\n+                 ty::type_err_to_str(self.tcx, terr))[]);\n \n         match trace.origin {\n             infer::MatchExpressionArm(_, arm_span) =>\n@@ -438,13 +438,13 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     format!(\n                         \"the parameter type `{}` may not live long enough\",\n-                        param_ty.user_string(self.tcx)).as_slice());\n+                        param_ty.user_string(self.tcx))[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound `{}: {}`...\",\n                         param_ty.user_string(self.tcx),\n-                        sub.user_string(self.tcx)).as_slice());\n+                        sub.user_string(self.tcx))[]);\n             }\n \n             ty::ReStatic => {\n@@ -453,12 +453,12 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     format!(\n                         \"the parameter type `{}` may not live long enough\",\n-                        param_ty.user_string(self.tcx)).as_slice());\n+                        param_ty.user_string(self.tcx))[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound `{}: 'static`...\",\n-                        param_ty.user_string(self.tcx)).as_slice());\n+                        param_ty.user_string(self.tcx))[]);\n             }\n \n             _ => {\n@@ -467,16 +467,16 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     format!(\n                         \"the parameter type `{}` may not live long enough\",\n-                        param_ty.user_string(self.tcx)).as_slice());\n+                        param_ty.user_string(self.tcx))[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound to `{}`\",\n-                        param_ty.user_string(self.tcx)).as_slice());\n+                        param_ty.user_string(self.tcx))[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     format!(\"the parameter type `{}` must be valid for \",\n-                            param_ty.user_string(self.tcx)).as_slice(),\n+                            param_ty.user_string(self.tcx))[],\n                     sub,\n                     \"...\");\n             }\n@@ -518,7 +518,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string()).as_slice());\n+                                .to_string())[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"...the borrowed pointer is valid for \",\n@@ -530,7 +530,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string()).as_slice(),\n+                                .to_string())[],\n                     sup,\n                     \"\");\n             }\n@@ -576,7 +576,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             outlive the enclosing closure\",\n                             ty::local_var_name_str(self.tcx,\n                                                    id).get()\n-                                                      .to_string()).as_slice());\n+                                                      .to_string())[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"captured variable is valid for \",\n@@ -618,7 +618,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"the type `{}` does not fulfill the \\\n                              required lifetime\",\n-                            self.ty_to_string(ty)).as_slice());\n+                            self.ty_to_string(ty))[]);\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -644,7 +644,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"the type `{}` (provided as the value of \\\n                              a type parameter) is not valid at this point\",\n-                            self.ty_to_string(ty)).as_slice());\n+                            self.ty_to_string(ty))[]);\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -710,7 +710,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"type of expression contains references \\\n                              that are not valid during the expression: `{}`\",\n-                            self.ty_to_string(t)).as_slice());\n+                            self.ty_to_string(t))[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"type is only valid for \",\n@@ -732,7 +732,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"in type `{}`, reference has a longer lifetime \\\n                              than the data it references\",\n-                            self.ty_to_string(ty)).as_slice());\n+                            self.ty_to_string(ty))[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"the pointer is valid for \",\n@@ -857,7 +857,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         let (fn_decl, generics, unsafety, ident, expl_self, span)\n                                     = node_inner.expect(\"expect item fn\");\n         let taken = lifetimes_in_scope(self.tcx, scope_id);\n-        let life_giver = LifeGiver::with_taken(taken.as_slice());\n+        let life_giver = LifeGiver::with_taken(taken[]);\n         let rebuilder = Rebuilder::new(self.tcx, fn_decl, expl_self,\n                                        generics, same_regions, &life_giver);\n         let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n@@ -933,7 +933,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             }\n             expl_self_opt = self.rebuild_expl_self(expl_self_opt, lifetime,\n                                                    &anon_nums, &region_names);\n-            inputs = self.rebuild_args_ty(inputs.as_slice(), lifetime,\n+            inputs = self.rebuild_args_ty(inputs[], lifetime,\n                                           &anon_nums, &region_names);\n             output = self.rebuild_output(&output, lifetime, &anon_nums, &region_names);\n             ty_params = self.rebuild_ty_params(ty_params, lifetime,\n@@ -968,7 +968,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 names.push(lt_name);\n             }\n             names.sort();\n-            let name = token::str_to_ident(names[0].as_slice()).name;\n+            let name = token::str_to_ident(names[0][]).name;\n             return (name_to_dummy_lifetime(name), Kept);\n         }\n         return (self.life_giver.give_lifetime(), Fresh);\n@@ -1219,7 +1219,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                 .sess\n                                 .fatal(format!(\n                                         \"unbound path {}\",\n-                                        pprust::path_to_string(path)).as_slice())\n+                                        pprust::path_to_string(path))[])\n                         }\n                         Some(&d) => d\n                     };\n@@ -1417,7 +1417,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                                               opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n-        self.tcx.sess.span_help(span, msg.as_slice());\n+        self.tcx.sess.span_help(span, msg[]);\n     }\n \n     fn report_inference_failure(&self,\n@@ -1455,7 +1455,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             var_origin.span(),\n             format!(\"cannot infer an appropriate lifetime{} \\\n                     due to conflicting requirements\",\n-                    var_description).as_slice());\n+                    var_description)[]);\n     }\n \n     fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n@@ -1500,7 +1500,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n                             format!(\"...so that {} ({})\",\n-                                    desc, values_str).as_slice());\n+                                    desc, values_str)[]);\n                     }\n                     None => {\n                         // Really should avoid printing this error at\n@@ -1509,7 +1509,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         // doing right now. - nmatsakis\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n-                            format!(\"...so that {}\", desc).as_slice());\n+                            format!(\"...so that {}\", desc)[]);\n                     }\n                 }\n             }\n@@ -1526,7 +1526,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         \"...so that closure can access `{}`\",\n                         ty::local_var_name_str(self.tcx, upvar_id.var_id)\n                             .get()\n-                            .to_string()).as_slice())\n+                            .to_string())[])\n             }\n             infer::InfStackClosure(span) => {\n                 self.tcx.sess.span_note(\n@@ -1551,7 +1551,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                             does not outlive the enclosing closure\",\n                             ty::local_var_name_str(\n                                 self.tcx,\n-                                id).get().to_string()).as_slice());\n+                                id).get().to_string())[]);\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note(\n@@ -1595,7 +1595,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"...so type `{}` of expression is valid during the \\\n                              expression\",\n-                            self.ty_to_string(t)).as_slice());\n+                            self.ty_to_string(t))[]);\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 self.tcx.sess.span_note(\n@@ -1607,28 +1607,28 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"...so that the reference type `{}` \\\n                              does not outlive the data it points at\",\n-                            self.ty_to_string(ty)).as_slice());\n+                            self.ty_to_string(ty))[]);\n             }\n             infer::RelateParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     format!(\"...so that the type `{}` \\\n                              will meet the declared lifetime bounds\",\n-                            self.ty_to_string(t)).as_slice());\n+                            self.ty_to_string(t))[]);\n             }\n             infer::RelateDefaultParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     format!(\"...so that type parameter \\\n                              instantiated with `{}`, \\\n                              will meet its declared lifetime bounds\",\n-                            self.ty_to_string(t)).as_slice());\n+                            self.ty_to_string(t))[]);\n             }\n             infer::RelateRegionParamBound(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     format!(\"...so that the declared lifetime parameter bounds \\\n-                                are satisfied\").as_slice());\n+                                are satisfied\")[]);\n             }\n         }\n     }\n@@ -1677,15 +1677,15 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n         Some(node) => match node {\n             ast_map::NodeItem(item) => match item.node {\n                 ast::ItemFn(_, _, _, ref gen, _) => {\n-                    taken.push_all(gen.lifetimes.as_slice());\n+                    taken.push_all(gen.lifetimes[]);\n                     None\n                 },\n                 _ => None\n             },\n             ast_map::NodeImplItem(ii) => {\n                 match *ii {\n                     ast::MethodImplItem(ref m) => {\n-                        taken.push_all(m.pe_generics().lifetimes.as_slice());\n+                        taken.push_all(m.pe_generics().lifetimes[]);\n                         Some(m.id)\n                     }\n                     ast::TypeImplItem(_) => None,\n@@ -1744,10 +1744,10 @@ impl LifeGiver {\n         let mut lifetime;\n         loop {\n             let mut s = String::from_str(\"'\");\n-            s.push_str(num_to_string(self.counter.get()).as_slice());\n+            s.push_str(num_to_string(self.counter.get())[]);\n             if !self.taken.contains(&s) {\n                 lifetime = name_to_dummy_lifetime(\n-                                    token::str_to_ident(s.as_slice()).name);\n+                                    token::str_to_ident(s[]).name);\n                 self.generated.borrow_mut().push(lifetime);\n                 break;\n             }"}, {"sha": "2a19f37e7d41514c27792fa87a1aed1886ce23c5", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -189,7 +189,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                 span,\n                 format!(\"region {} is not associated with \\\n                          any bound region from A!\",\n-                        r0).as_slice())\n+                        r0)[])\n         }\n     }\n \n@@ -339,7 +339,7 @@ fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n             r => {\n                 combiner.infcx().tcx.sess.span_bug(\n                     combiner.trace().origin.span(),\n-                    format!(\"found non-region-vid: {}\", r).as_slice());\n+                    format!(\"found non-region-vid: {}\", r)[]);\n             }\n         }).collect()\n }"}, {"sha": "6d031c8650756affc1734265ebc7eb85f4393214", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -992,7 +992,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                 self.tcx.sess.span_err(sp, format!(\"{}{}\",\n                     mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n-                    error_str).as_slice());\n+                    error_str)[]);\n \n                 for err in err.iter() {\n                     ty::note_and_explain_type_err(self.tcx, *err)"}, {"sha": "0ca1a593ce7fe55491440554e9e7d8d0789e3317", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -60,7 +60,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     }\n \n     let requested_node : Option<ast::NodeId> =\n-        os::getenv(\"RUST_REGION_GRAPH_NODE\").and_then(|s|from_str(s.as_slice()));\n+        os::getenv(\"RUST_REGION_GRAPH_NODE\").and_then(|s| s.parse());\n \n     if requested_node.is_some() && requested_node != Some(subject_node) {\n         return;"}, {"sha": "661f7e56429ee63d4922a59ded88b8dbcf84dd90", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -464,7 +464,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 origin.span(),\n                 format!(\"cannot relate bound region: {} <= {}\",\n                         sub.repr(self.tcx),\n-                        sup.repr(self.tcx)).as_slice());\n+                        sup.repr(self.tcx))[]);\n           }\n           (_, ReStatic) => {\n             // all regions are subregions of static, so we can ignore this\n@@ -724,7 +724,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             self.tcx.sess.bug(\n                 format!(\"cannot relate bound region: LUB({}, {})\",\n                         a.repr(self.tcx),\n-                        b.repr(self.tcx)).as_slice());\n+                        b.repr(self.tcx))[]);\n           }\n \n           (ReStatic, _) | (_, ReStatic) => {\n@@ -741,7 +741,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 format!(\"lub_concrete_regions invoked with \\\n                          non-concrete regions: {}, {}\",\n                         a,\n-                        b).as_slice());\n+                        b)[]);\n           }\n \n           (ReFree(ref fr), ReScope(s_id)) |\n@@ -824,7 +824,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n               self.tcx.sess.bug(\n                   format!(\"cannot relate bound region: GLB({}, {})\",\n                           a.repr(self.tcx),\n-                          b.repr(self.tcx)).as_slice());\n+                          b.repr(self.tcx))[]);\n             }\n \n             (ReStatic, r) | (r, ReStatic) => {\n@@ -844,7 +844,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     format!(\"glb_concrete_regions invoked with \\\n                              non-concrete regions: {}, {}\",\n                             a,\n-                            b).as_slice());\n+                            b)[]);\n             }\n \n             (ReFree(ref fr), ReScope(s_id)) |\n@@ -965,7 +965,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.expansion(var_data.as_mut_slice());\n         self.contraction(var_data.as_mut_slice());\n         let values =\n-            self.extract_values_and_collect_conflicts(var_data.as_slice(),\n+            self.extract_values_and_collect_conflicts(var_data[],\n                                                       errors);\n         self.collect_concrete_region_errors(&values, errors);\n         values\n@@ -1403,7 +1403,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     for var {}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n                     lower_bounds.repr(self.tcx),\n-                    upper_bounds.repr(self.tcx)).as_slice());\n+                    upper_bounds.repr(self.tcx))[]);\n     }\n \n     fn collect_error_for_contracting_node(\n@@ -1447,7 +1447,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             format!(\"collect_error_for_contracting_node() could not find error \\\n                      for var {}, upper_bounds={}\",\n                     node_idx,\n-                    upper_bounds.repr(self.tcx)).as_slice());\n+                    upper_bounds.repr(self.tcx))[]);\n     }\n \n     fn collect_concrete_regions(&self,"}, {"sha": "798daf8d5410b1634cd591d7892f45052ed7a049", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -323,7 +323,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             self.tcx\n                 .sess\n                 .span_bug(span, format!(\"no variable registered for id {}\",\n-                                        node_id).as_slice());\n+                                        node_id)[]);\n           }\n         }\n     }\n@@ -594,7 +594,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.ir.tcx.sess.span_bug(\n                 span,\n                 format!(\"no live node registered for node {}\",\n-                        node_id).as_slice());\n+                        node_id)[]);\n           }\n         }\n     }\n@@ -1129,7 +1129,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           // Uninteresting cases: just propagate in rev exec order\n \n           ast::ExprVec(ref exprs) => {\n-            self.propagate_through_exprs(exprs.as_slice(), succ)\n+            self.propagate_through_exprs(exprs[], succ)\n           }\n \n           ast::ExprRepeat(ref element, ref count) => {\n@@ -1154,7 +1154,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            let succ = self.propagate_through_exprs(args.as_slice(), succ);\n+            let succ = self.propagate_through_exprs(args[], succ);\n             self.propagate_through_expr(&**f, succ)\n           }\n \n@@ -1167,11 +1167,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            self.propagate_through_exprs(args.as_slice(), succ)\n+            self.propagate_through_exprs(args[], succ)\n           }\n \n           ast::ExprTup(ref exprs) => {\n-            self.propagate_through_exprs(exprs.as_slice(), succ)\n+            self.propagate_through_exprs(exprs[], succ)\n           }\n \n           ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {"}, {"sha": "1c2ceea77163de22fd3843afc414cdefd35a4f99", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -238,7 +238,7 @@ pub fn deref_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> deref_kind {\n       None => {\n         tcx.sess.bug(\n             format!(\"deref_kind() invoked on non-derefable type {}\",\n-                    ty_to_string(tcx, t)).as_slice());\n+                    ty_to_string(tcx, t))[]);\n       }\n     }\n }\n@@ -635,7 +635,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                           span,\n                           format!(\"Upvar of non-closure {} - {}\",\n                                   fn_node_id,\n-                                  ty.repr(self.tcx())).as_slice());\n+                                  ty.repr(self.tcx()))[]);\n                   }\n               }\n           }\n@@ -917,7 +917,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 self.tcx().sess.span_bug(\n                     node.span(),\n                     format!(\"Explicit deref of non-derefable type: {}\",\n-                            base_cmt.ty.repr(self.tcx())).as_slice());\n+                            base_cmt.ty.repr(self.tcx()))[]);\n             }\n         }\n     }\n@@ -996,7 +996,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         self.tcx().sess.span_bug(\n                             elt.span(),\n                             format!(\"Explicit index of non-index type `{}`\",\n-                                    base_cmt.ty.repr(self.tcx())).as_slice());\n+                                    base_cmt.ty.repr(self.tcx()))[]);\n                     }\n                 }\n             }"}, {"sha": "6f63ae166fe417e7c798572b636f22edd6dbfd69", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -615,10 +615,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         match result {\n             None => true,\n             Some((span, msg, note)) => {\n-                self.tcx.sess.span_err(span, msg.as_slice());\n+                self.tcx.sess.span_err(span, msg[]);\n                 match note {\n                     Some((span, msg)) => {\n-                        self.tcx.sess.span_note(span, msg.as_slice())\n+                        self.tcx.sess.span_note(span, msg[])\n                     }\n                     None => {},\n                 }\n@@ -720,7 +720,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             UnnamedField(idx) => format!(\"field #{} of {} is private\",\n                                          idx + 1, struct_desc),\n         };\n-        self.tcx.sess.span_err(span, msg.as_slice());\n+        self.tcx.sess.span_err(span, msg[]);\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n@@ -742,7 +742,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                              method_id,\n                                              None,\n                                              format!(\"method `{}`\",\n-                                                     string).as_slice()));\n+                                                     string)[]));\n     }\n \n     // Checks that a path is in scope.\n@@ -759,9 +759,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 self.ensure_public(span,\n                                    def,\n                                    Some(origdid),\n-                                   format!(\"{} `{}`\",\n-                                           tyname,\n-                                           name).as_slice())\n+                                   format!(\"{} `{}`\", tyname, name)[])\n             };\n \n             match self.last_private_map[path_id] {"}, {"sha": "4d83075480bcc0877dda9a089efeb2a46c6fa19c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -50,7 +50,7 @@ fn generics_require_inlining(generics: &ast::Generics) -> bool {\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n fn item_might_be_inlined(item: &ast::Item) -> bool {\n-    if attributes_specify_inlining(item.attrs.as_slice()) {\n+    if attributes_specify_inlining(item.attrs[]) {\n         return true\n     }\n \n@@ -65,7 +65,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n \n fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n-    if attributes_specify_inlining(method.attrs.as_slice()) ||\n+    if attributes_specify_inlining(method.attrs[]) ||\n         generics_require_inlining(method.pe_generics()) {\n         return true\n     }\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     ast::MethodImplItem(ref method) => {\n                         if generics_require_inlining(method.pe_generics()) ||\n                                 attributes_specify_inlining(\n-                                    method.attrs.as_slice()) {\n+                                    method.attrs[]) {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n@@ -249,7 +249,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 None => {\n                     self.tcx.sess.bug(format!(\"found unmapped ID in worklist: \\\n                                                {}\",\n-                                              search_item).as_slice())\n+                                              search_item)[])\n                 }\n             }\n         }\n@@ -341,7 +341,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     .bug(format!(\"found unexpected thingy in worklist: {}\",\n                                  self.tcx\n                                      .map\n-                                     .node_to_string(search_item)).as_slice())\n+                                     .node_to_string(search_item))[])\n             }\n         }\n     }"}, {"sha": "bc9dc6b399d49b0e8c707dac5d96b75436f2a11d", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -409,7 +409,7 @@ impl<'a> LifetimeContext<'a> {\n         self.sess.span_err(\n             lifetime_ref.span,\n             format!(\"use of undeclared lifetime name `{}`\",\n-                    token::get_name(lifetime_ref.name)).as_slice());\n+                    token::get_name(lifetime_ref.name))[]);\n     }\n \n     fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<ast::LifetimeDef>) {\n@@ -423,7 +423,7 @@ impl<'a> LifetimeContext<'a> {\n                         lifetime.lifetime.span,\n                         format!(\"illegal lifetime parameter name: `{}`\",\n                                 token::get_name(lifetime.lifetime.name))\n-                            .as_slice());\n+                            []);\n                 }\n             }\n \n@@ -437,7 +437,7 @@ impl<'a> LifetimeContext<'a> {\n                         format!(\"lifetime name `{}` declared twice in \\\n                                 the same scope\",\n                                 token::get_name(lifetime_j.lifetime.name))\n-                            .as_slice());\n+                            []);\n                 }\n             }\n "}, {"sha": "a5e8e4695afda17a1379327a89b49e1ce963be8d", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -620,7 +620,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                                      (space={}, index={})\",\n                                     region_name.as_str(),\n                                     self.root_ty.repr(self.tcx()),\n-                                    space, i).as_slice());\n+                                    space, i)[]);\n                             }\n                         }\n                 }\n@@ -677,7 +677,7 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n                             p.space,\n                             p.idx,\n                             self.root_ty.repr(self.tcx()),\n-                            self.substs.repr(self.tcx())).as_slice());\n+                            self.substs.repr(self.tcx()))[]);\n             }\n         };\n "}, {"sha": "d48685ce27d89fe6c92d87a4cc8b63c372b59574", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -154,7 +154,7 @@ pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::ty_err => {\n             tcx.sess.bug(\n                 format!(\"ty_is_local invoked on unexpected type: {}\",\n-                        ty.repr(tcx)).as_slice())\n+                        ty.repr(tcx))[])\n         }\n     }\n }"}, {"sha": "2b42849a87b6324b2ad7f57f9b02fa4b10385d56", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -709,7 +709,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let all_bounds =\n             util::transitive_bounds(\n-                self.tcx(), caller_trait_refs.as_slice());\n+                self.tcx(), caller_trait_refs[]);\n \n         let matching_bounds =\n             all_bounds.filter(\n@@ -762,7 +762,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     format!(\"No entry for unboxed closure: {}\",\n-                            closure_def_id.repr(self.tcx())).as_slice());\n+                            closure_def_id.repr(self.tcx()))[]);\n             }\n         };\n \n@@ -1281,7 +1281,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     format!(\n                         \"asked to assemble builtin bounds of unexpected type: {}\",\n-                        self_ty.repr(self.tcx())).as_slice());\n+                        self_ty.repr(self.tcx()))[]);\n             }\n         };\n \n@@ -1436,7 +1436,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     format!(\"builtin bound for {} was ambig\",\n-                            obligation.repr(self.tcx())).as_slice());\n+                            obligation.repr(self.tcx()))[]);\n             }\n         }\n     }\n@@ -1554,7 +1554,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     format!(\"Fn pointer candidate for inappropriate self type: {}\",\n-                            self_ty.repr(self.tcx())).as_slice());\n+                            self_ty.repr(self.tcx()))[]);\n             }\n         };\n \n@@ -1595,7 +1595,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     format!(\"No entry for unboxed closure: {}\",\n-                            closure_def_id.repr(self.tcx())).as_slice());\n+                            closure_def_id.repr(self.tcx()))[]);\n             }\n         };\n \n@@ -1692,8 +1692,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     format!(\"Impl {} was matchable against {} but now is not\",\n                             impl_def_id.repr(self.tcx()),\n-                            obligation.repr(self.tcx()))\n-                        .as_slice());\n+                            obligation.repr(self.tcx()))[]);\n             }\n         }\n     }"}, {"sha": "edaf2f167216065edca7d6eda971599e2c6eadef", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -1891,7 +1891,7 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n             _ => {\n                 cx.sess.bug(format!(\"ParameterEnvironment::from_item(): \\\n                                      `{}` is not an item\",\n-                                    cx.map.node_to_string(id)).as_slice())\n+                                    cx.map.node_to_string(id))[])\n             }\n         }\n     }\n@@ -1960,7 +1960,7 @@ impl UnboxedClosureKind {\n         };\n         match result {\n             Ok(trait_did) => trait_did,\n-            Err(err) => cx.sess.fatal(err.as_slice()),\n+            Err(err) => cx.sess.fatal(err[]),\n         }\n     }\n }\n@@ -2596,7 +2596,7 @@ pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         ty_str => mk_mach_uint(ast::TyU8),\n         ty_open(ty) => sequence_element_type(cx, ty),\n         _ => cx.sess.bug(format!(\"sequence_element_type called on non-sequence value: {}\",\n-                                 ty_to_string(cx, ty)).as_slice()),\n+                                 ty_to_string(cx, ty))[]),\n     }\n }\n \n@@ -2972,7 +2972,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             ty_struct(did, ref substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(flds.as_slice(),\n+                    TypeContents::union(flds[],\n                                         |f| tc_mt(cx, f.mt, cache));\n \n                 if !lookup_repr_hints(cx, did).contains(&attr::ReprExtern) {\n@@ -2989,21 +2989,21 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 // FIXME(#14449): `borrowed_contents` below assumes `&mut`\n                 // unboxed closure.\n                 let upvars = unboxed_closure_upvars(cx, did, substs);\n-                TypeContents::union(upvars.as_slice(),\n+                TypeContents::union(upvars[],\n                                     |f| tc_ty(cx, f.ty, cache)) |\n                     borrowed_contents(r, MutMutable)\n             }\n \n             ty_tup(ref tys) => {\n-                TypeContents::union(tys.as_slice(),\n+                TypeContents::union(tys[],\n                                     |ty| tc_ty(cx, *ty, cache))\n             }\n \n             ty_enum(did, ref substs) => {\n                 let variants = substd_enum_variants(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(variants.as_slice(), |variant| {\n-                        TypeContents::union(variant.args.as_slice(),\n+                    TypeContents::union(variants[], |variant| {\n+                        TypeContents::union(variant.args[],\n                                             |arg_ty| {\n                             tc_ty(cx, *arg_ty, cache)\n                         })\n@@ -3068,7 +3068,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 kind_bounds_to_contents(\n                     cx,\n                     tp_def.bounds.builtin_bounds,\n-                    tp_def.bounds.trait_bounds.as_slice())\n+                    tp_def.bounds.trait_bounds[])\n             }\n \n             ty_infer(_) => {\n@@ -3658,7 +3658,7 @@ pub fn close_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_open(ty) => mk_rptr(cx, ReStatic, mt {ty: ty, mutbl:ast::MutImmutable}),\n         _ => cx.sess.bug(format!(\"Trying to close a non-open type {}\",\n-                                 ty_to_string(cx, ty)).as_slice())\n+                                 ty_to_string(cx, ty))[])\n     }\n }\n \n@@ -3759,7 +3759,7 @@ pub fn node_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n         Some(ty) => ty.clone(),\n         None => cx.sess.bug(\n             format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n-                    cx.map.node_to_string(id)).as_slice())\n+                    cx.map.node_to_string(id))[])\n     }\n }\n \n@@ -3772,7 +3772,7 @@ pub fn node_id_to_type<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n        Some(ty) => ty,\n        None => cx.sess.bug(\n            format!(\"node_id_to_type: no type for node `{}`\",\n-                   cx.map.node_to_string(id)).as_slice())\n+                   cx.map.node_to_string(id))[])\n     }\n }\n \n@@ -3865,7 +3865,7 @@ pub fn ty_region(tcx: &ctxt,\n             tcx.sess.span_bug(\n                 span,\n                 format!(\"ty_region() invoked on an inappropriate ty: {}\",\n-                        s).as_slice());\n+                        s)[]);\n         }\n     }\n }\n@@ -3926,11 +3926,11 @@ pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n         Some(f) => {\n             cx.sess.bug(format!(\"Node id {} is not an expr: {}\",\n                                 id,\n-                                f).as_slice());\n+                                f)[]);\n         }\n         None => {\n             cx.sess.bug(format!(\"Node id {} is not present \\\n-                                in the node map\", id).as_slice());\n+                                in the node map\", id)[]);\n         }\n     }\n }\n@@ -3946,14 +3946,14 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n                     cx.sess.bug(\n                         format!(\"Variable id {} maps to {}, not local\",\n                                 id,\n-                                pat).as_slice());\n+                                pat)[]);\n                 }\n             }\n         }\n         r => {\n             cx.sess.bug(format!(\"Variable id {} maps to {}, not local\",\n                                 id,\n-                                r).as_slice());\n+                                r)[]);\n         }\n     }\n }\n@@ -3996,7 +3996,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                             cx.sess.bug(\n                                 format!(\"add_env adjustment on non-bare-fn: \\\n                                          {}\",\n-                                        b).as_slice());\n+                                        b)[]);\n                         }\n                     }\n                 }\n@@ -4024,7 +4024,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                                                 {}\",\n                                                 i,\n                                                 ty_to_string(cx, adjusted_ty))\n-                                                          .as_slice());\n+                                                          []);\n                                 }\n                             }\n                         }\n@@ -4087,7 +4087,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n             }\n             _ => cx.sess.span_bug(span,\n                                   format!(\"UnsizeLength with bad sty: {}\",\n-                                          ty_to_string(cx, ty)).as_slice())\n+                                          ty_to_string(cx, ty))[])\n         },\n         &UnsizeStruct(box ref k, tp_index) => match ty.sty {\n             ty_struct(did, ref substs) => {\n@@ -4099,7 +4099,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n             }\n             _ => cx.sess.span_bug(span,\n                                   format!(\"UnsizeStruct with bad sty: {}\",\n-                                          ty_to_string(cx, ty)).as_slice())\n+                                          ty_to_string(cx, ty))[])\n         },\n         &UnsizeVtable(TyTrait { ref principal, bounds }, _) => {\n             mk_trait(cx, (*principal).clone(), bounds)\n@@ -4112,7 +4112,7 @@ pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n         Some(&def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, format!(\n-                \"no def-map entry for expr {}\", expr.id).as_slice());\n+                \"no def-map entry for expr {}\", expr.id)[]);\n         }\n     }\n }\n@@ -4206,7 +4206,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                         expr.span,\n                         format!(\"uncategorized def for expr {}: {}\",\n                                 expr.id,\n-                                def).as_slice());\n+                                def)[]);\n                 }\n             }\n         }\n@@ -4331,7 +4331,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n         token::get_name(name),\n         fields.iter()\n               .map(|f| token::get_name(f.name).get().to_string())\n-              .collect::<Vec<String>>()).as_slice());\n+              .collect::<Vec<String>>())[]);\n }\n \n pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n@@ -4565,7 +4565,7 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                 match item.node {\n                     ItemTrait(_, _, _, _, ref ms) => {\n                         let (_, p) =\n-                            ast_util::split_trait_methods(ms.as_slice());\n+                            ast_util::split_trait_methods(ms[]);\n                         p.iter()\n                          .map(|m| {\n                             match impl_or_trait_item(\n@@ -4584,14 +4584,14 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                     _ => {\n                         cx.sess.bug(format!(\"provided_trait_methods: `{}` is \\\n                                              not a trait\",\n-                                            id).as_slice())\n+                                            id)[])\n                     }\n                 }\n             }\n             _ => {\n                 cx.sess.bug(format!(\"provided_trait_methods: `{}` is not a \\\n                                      trait\",\n-                                    id).as_slice())\n+                                    id)[])\n             }\n         }\n     } else {\n@@ -4827,7 +4827,7 @@ impl<'tcx> VariantInfo<'tcx> {\n             },\n             ast::StructVariantKind(ref struct_def) => {\n \n-                let fields: &[StructField] = struct_def.fields.as_slice();\n+                let fields: &[StructField] = struct_def.fields[];\n \n                 assert!(fields.len() > 0);\n \n@@ -4978,7 +4978,7 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                                 cx.sess\n                                                   .span_err(e.span,\n                                                             format!(\"expected constant: {}\",\n-                                                                    *err).as_slice());\n+                                                                    *err)[]);\n                                             }\n                                         },\n                                     None => {}\n@@ -5258,7 +5258,7 @@ pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n             _ => {\n                 cx.sess.bug(\n                     format!(\"ID not mapped to struct fields: {}\",\n-                            cx.map.node_to_string(did.node)).as_slice());\n+                            cx.map.node_to_string(did.node))[]);\n             }\n         }\n     } else {\n@@ -5291,7 +5291,7 @@ pub fn struct_fields<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId, substs: &Substs<'tc\n pub fn tup_fields<'tcx>(v: &[Ty<'tcx>]) -> Vec<field<'tcx>> {\n     v.iter().enumerate().map(|(i, &f)| {\n        field {\n-            name: token::intern(i.to_string().as_slice()),\n+            name: token::intern(i.to_string()[]),\n             mt: mt {\n                 ty: f,\n                 mutbl: MutImmutable\n@@ -5470,7 +5470,7 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n             };\n             tcx.sess.span_err(count_expr.span, format!(\n                 \"expected positive integer for repeat count, found {}\",\n-                found).as_slice());\n+                found)[]);\n         }\n         Err(_) => {\n             let found = match count_expr.node {\n@@ -5485,7 +5485,7 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n             };\n             tcx.sess.span_err(count_expr.span, format!(\n                 \"expected constant integer for repeat count, found {}\",\n-                found).as_slice());\n+                found)[]);\n         }\n     }\n     0\n@@ -6244,7 +6244,7 @@ pub fn with_freevars<T, F>(tcx: &ty::ctxt, fid: ast::NodeId, f: F) -> T where\n {\n     match tcx.freevars.borrow().get(&fid) {\n         None => f(&[]),\n-        Some(d) => f(d.as_slice())\n+        Some(d) => f(d[])\n     }\n }\n "}, {"sha": "a2e334543206cc68ea6ed35e75639b9f3f64e246", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -141,17 +141,17 @@ impl<'a> PluginLoader<'a> {\n             // this is fatal: there are almost certainly macros we need\n             // inside this crate, so continue would spew \"macro undefined\"\n             // errors\n-            Err(err) => self.sess.span_fatal(vi.span, err.as_slice())\n+            Err(err) => self.sess.span_fatal(vi.span, err[])\n         };\n \n         unsafe {\n             let registrar =\n-                match lib.symbol(symbol.as_slice()) {\n+                match lib.symbol(symbol[]) {\n                     Ok(registrar) => {\n                         mem::transmute::<*mut u8,PluginRegistrarFun>(registrar)\n                     }\n                     // again fatal if we can't register macros\n-                    Err(err) => self.sess.span_fatal(vi.span, err.as_slice())\n+                    Err(err) => self.sess.span_fatal(vi.span, err[])\n                 };\n \n             self.plugins.registrars.push(registrar);"}, {"sha": "335b74890631e9dd7f854fbf6ec5fee224a4aeba", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -555,17 +555,17 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n                 match (value, opt_type_desc) {\n                     (Some(..), None) => {\n                         early_error(format!(\"codegen option `{}` takes no \\\n-                                             value\", key).as_slice())\n+                                             value\", key)[])\n                     }\n                     (None, Some(type_desc)) => {\n                         early_error(format!(\"codegen option `{0}` requires \\\n                                              {1} (-C {0}=<value>)\",\n-                                            key, type_desc).as_slice())\n+                                            key, type_desc)[])\n                     }\n                     (Some(value), Some(type_desc)) => {\n                         early_error(format!(\"incorrect value `{}` for codegen \\\n                                              option `{}` - {} was expected\",\n-                                             value, key, type_desc).as_slice())\n+                                             value, key, type_desc)[])\n                     }\n                     (None, None) => unreachable!()\n                 }\n@@ -575,7 +575,7 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n         }\n         if !found {\n             early_error(format!(\"unknown codegen option: `{}`\",\n-                                key).as_slice());\n+                                key)[]);\n         }\n     }\n     return cg;\n@@ -588,10 +588,10 @@ pub fn default_lib_output() -> CrateType {\n pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     use syntax::parse::token::intern_and_get_ident as intern;\n \n-    let end = sess.target.target.target_endian.as_slice();\n-    let arch = sess.target.target.arch.as_slice();\n-    let wordsz = sess.target.target.target_word_size.as_slice();\n-    let os = sess.target.target.target_os.as_slice();\n+    let end = sess.target.target.target_endian[];\n+    let arch = sess.target.target.arch[];\n+    let wordsz = sess.target.target.target_word_size[];\n+    let os = sess.target.target.target_os[];\n \n     let fam = match sess.target.target.options.is_like_windows {\n         true  => InternedString::new(\"windows\"),\n@@ -627,23 +627,23 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n         append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n     }\n     let mut v = user_cfg.into_iter().collect::<Vec<_>>();\n-    v.push_all(default_cfg.as_slice());\n+    v.push_all(default_cfg[]);\n     v\n }\n \n pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n-    let target = match Target::search(opts.target_triple.as_slice()) {\n+    let target = match Target::search(opts.target_triple[]) {\n         Ok(t) => t,\n         Err(e) => {\n-            sp.handler().fatal((format!(\"Error loading target specification: {}\", e)).as_slice());\n+            sp.handler().fatal((format!(\"Error loading target specification: {}\", e))[]);\n     }\n     };\n \n-    let (int_type, uint_type) = match target.target_word_size.as_slice() {\n+    let (int_type, uint_type) = match target.target_word_size[] {\n         \"32\" => (ast::TyI32, ast::TyU32),\n         \"64\" => (ast::TyI64, ast::TyU64),\n         w    => sp.handler().fatal((format!(\"target specification was invalid: unrecognized \\\n-                                            target-word-size {}\", w)).as_slice())\n+                                            target-word-size {}\", w))[])\n     };\n \n     Config {\n@@ -756,7 +756,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n     let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n-        .unwrap_or_else(|e| early_error(e.as_slice()));\n+        .unwrap_or_else(|e| early_error(e[]));\n \n     let mut lint_opts = vec!();\n     let mut describe_lints = false;\n@@ -766,7 +766,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             if lint_name == \"help\" {\n                 describe_lints = true;\n             } else {\n-                lint_opts.push((lint_name.replace(\"-\", \"_\").into_string(), level));\n+                lint_opts.push((lint_name.replace(\"-\", \"_\"), level));\n             }\n         }\n     }\n@@ -784,7 +784,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         }\n         if this_bit == 0 {\n             early_error(format!(\"unknown debug flag: {}\",\n-                                *debug_flag).as_slice())\n+                                *debug_flag)[])\n         }\n         debugging_opts |= this_bit;\n     }\n@@ -829,7 +829,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                     \"dep-info\" => OutputTypeDepInfo,\n                     _ => {\n                         early_error(format!(\"unknown emission type: `{}`\",\n-                                            part).as_slice())\n+                                            part)[])\n                     }\n                 };\n                 output_types.push(output_type)\n@@ -868,7 +868,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                 Some(arg) => {\n                     early_error(format!(\"optimization level needs to be \\\n                                          between 0-3 (instead was `{}`)\",\n-                                        arg).as_slice());\n+                                        arg)[]);\n                 }\n             }\n         } else {\n@@ -906,7 +906,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             Some(arg) => {\n                 early_error(format!(\"debug info level needs to be between \\\n                                      0-2 (instead was `{}`)\",\n-                                    arg).as_slice());\n+                                    arg)[]);\n             }\n         }\n     } else {\n@@ -923,7 +923,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     };\n \n     let addl_lib_search_paths = matches.opt_strs(\"L\").iter().map(|s| {\n-        Path::new(s.as_slice())\n+        Path::new(s[])\n     }).collect();\n \n     let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n@@ -937,7 +937,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             (_, s) => {\n                 early_error(format!(\"unknown library kind `{}`, expected \\\n                                      one of dylib, framework, or static\",\n-                                    s).as_slice());\n+                                    s)[]);\n             }\n         };\n         (name.to_string(), kind)\n@@ -982,7 +982,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         //             --debuginfo\");\n     }\n \n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| s.as_slice()) {\n+    let color = match matches.opt_str(\"color\").as_ref().map(|s| s[]) {\n         Some(\"auto\")   => Auto,\n         Some(\"always\") => Always,\n         Some(\"never\")  => Never,\n@@ -992,7 +992,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         Some(arg) => {\n             early_error(format!(\"argument for --color must be auto, always \\\n                                  or never (instead was `{}`)\",\n-                                arg).as_slice())\n+                                arg)[])\n         }\n     };\n \n@@ -1093,15 +1093,15 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            &match getopts(&[\"--test\".to_string()], optgroups().as_slice()) {\n+            &match getopts(&[\"--test\".to_string()], optgroups()[]) {\n               Ok(m) => m,\n               Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n         let registry = diagnostics::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None, registry);\n         let cfg = build_configuration(&sess);\n-        assert!((attr::contains_name(cfg.as_slice(), \"test\")));\n+        assert!((attr::contains_name(cfg[], \"test\")));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n@@ -1110,7 +1110,7 @@ mod test {\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             &match getopts(&[\"--test\".to_string(), \"--cfg=test\".to_string()],\n-                           optgroups().as_slice()) {\n+                           optgroups()[]) {\n               Ok(m) => m,\n               Err(f) => {\n                 panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n@@ -1130,7 +1130,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string()\n-            ], optgroups().as_slice()).unwrap();\n+            ], optgroups()[]).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1141,7 +1141,7 @@ mod test {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string(),\n                 \"-Dwarnings\".to_string()\n-            ], optgroups().as_slice()).unwrap();\n+            ], optgroups()[]).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1151,7 +1151,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Adead_code\".to_string()\n-            ], optgroups().as_slice()).unwrap();\n+            ], optgroups()[]).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);"}, {"sha": "37bdd1673e9ca3cb69b439e8bd8dffda0544603c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -172,7 +172,7 @@ impl Session {\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp,\n-                      format!(\"impossible case reached: {}\", msg).as_slice());\n+                      format!(\"impossible case reached: {}\", msg)[]);\n     }\n     pub fn verbose(&self) -> bool { self.debugging_opt(config::VERBOSE) }\n     pub fn time_passes(&self) -> bool { self.debugging_opt(config::TIME_PASSES) }\n@@ -211,7 +211,7 @@ impl Session {\n     }\n     pub fn target_filesearch<'a>(&'a self) -> filesearch::FileSearch<'a> {\n         filesearch::FileSearch::new(self.sysroot(),\n-                                    self.opts.target_triple.as_slice(),\n+                                    self.opts.target_triple[],\n                                     &self.opts.addl_lib_search_paths)\n     }\n     pub fn host_filesearch<'a>(&'a self) -> filesearch::FileSearch<'a> {"}, {"sha": "e1448364a9e05a7c36028d5dbe0bfdbdaa8ea646", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -14,6 +14,7 @@ use std::cell::{RefCell, Cell};\n use std::collections::HashMap;\n use std::fmt::Show;\n use std::hash::{Hash, Hasher};\n+use std::iter::repeat;\n use std::time::Duration;\n \n use syntax::ast;\n@@ -48,7 +49,7 @@ pub fn time<T, U, F>(do_it: bool, what: &str, u: U, f: F) -> T where\n     };\n     let rv = rv.unwrap();\n \n-    println!(\"{}time: {}.{:03} \\t{}\", \"  \".repeat(old),\n+    println!(\"{}time: {}.{:03} \\t{}\", repeat(\"  \").take(old).collect::<String>(),\n              dur.num_seconds(), dur.num_milliseconds() % 1000, what);\n     DEPTH.with(|slot| slot.set(old));\n "}, {"sha": "5f61c04d3668588953c4e6148d1a05a5da1d244d", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -55,12 +55,12 @@ pub fn note_and_explain_region(cx: &ctxt,\n       (ref str, Some(span)) => {\n         cx.sess.span_note(\n             span,\n-            format!(\"{}{}{}\", prefix, *str, suffix).as_slice());\n+            format!(\"{}{}{}\", prefix, *str, suffix)[]);\n         Some(span)\n       }\n       (ref str, None) => {\n         cx.sess.note(\n-            format!(\"{}{}{}\", prefix, *str, suffix).as_slice());\n+            format!(\"{}{}{}\", prefix, *str, suffix)[]);\n         None\n       }\n     }\n@@ -269,7 +269,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         };\n \n         if abi != abi::Rust {\n-            s.push_str(format!(\"extern {} \", abi.to_string()).as_slice());\n+            s.push_str(format!(\"extern {} \", abi.to_string())[]);\n         };\n \n         s.push_str(\"fn\");\n@@ -293,7 +293,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         match cty.store {\n             ty::UniqTraitStore => {}\n             ty::RegionTraitStore(region, _) => {\n-                s.push_str(region_to_string(cx, \"\", true, region).as_slice());\n+                s.push_str(region_to_string(cx, \"\", true, region)[]);\n             }\n         }\n \n@@ -312,15 +312,15 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 assert_eq!(cty.onceness, ast::Once);\n                 s.push_str(\"proc\");\n                 push_sig_to_string(cx, &mut s, '(', ')', &cty.sig,\n-                                   bounds_str.as_slice());\n+                                   bounds_str[]);\n             }\n             ty::RegionTraitStore(..) => {\n                 match cty.onceness {\n                     ast::Many => {}\n                     ast::Once => s.push_str(\"once \")\n                 }\n                 push_sig_to_string(cx, &mut s, '|', '|', &cty.sig,\n-                                   bounds_str.as_slice());\n+                                   bounds_str[]);\n             }\n         }\n \n@@ -353,7 +353,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             ty::FnConverging(t) => {\n                 if !ty::type_is_nil(t) {\n                    s.push_str(\" -> \");\n-                   s.push_str(ty_to_string(cx, t).as_slice());\n+                   s.push_str(ty_to_string(cx, t)[]);\n                 }\n             }\n             ty::FnDiverging => {\n@@ -390,7 +390,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_rptr(r, ref tm) => {\n             let mut buf = region_ptr_to_string(cx, r);\n-            buf.push_str(mt_to_string(cx, tm).as_slice());\n+            buf.push_str(mt_to_string(cx, tm)[]);\n             buf\n         }\n         ty_open(typ) =>\n@@ -400,7 +400,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 .iter()\n                 .map(|elem| ty_to_string(cx, *elem))\n                 .collect::<Vec<_>>();\n-            match strs.as_slice() {\n+            match strs[] {\n                 [ref string] => format!(\"({},)\", string),\n                 strs => format!(\"({})\", strs.connect(\", \"))\n             }\n@@ -551,7 +551,7 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n pub fn ty_to_short_str<'tcx>(cx: &ctxt<'tcx>, typ: Ty<'tcx>) -> String {\n     let mut s = typ.repr(cx).to_string();\n     if s.len() >= 32u {\n-        s = s.slice(0u, 32u).to_string();\n+        s = s[0u..32u].to_string();\n     }\n     return s;\n }\n@@ -616,15 +616,15 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for [T] {\n \n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for OwnedSlice<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, self.as_slice())\n+        repr_vec(tcx, self[])\n     }\n }\n \n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Vec<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, self.as_slice())\n+        repr_vec(tcx, self[])\n     }\n }\n "}, {"sha": "0bd4265e487a64f25fa19a7d2f022879e7481fae", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -53,7 +53,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n           args: &str, cwd: Option<&Path>,\n           paths: &[&Path]) -> ProcessOutput {\n     let ar = match *maybe_ar_prog {\n-        Some(ref ar) => ar.as_slice(),\n+        Some(ref ar) => ar[],\n         None => \"ar\"\n     };\n     let mut cmd = Command::new(ar);\n@@ -75,22 +75,22 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n             if !o.status.success() {\n                 handler.err(format!(\"{} failed with: {}\",\n                                  cmd,\n-                                 o.status).as_slice());\n+                                 o.status)[]);\n                 handler.note(format!(\"stdout ---\\n{}\",\n                                   str::from_utf8(o.output\n-                                                  .as_slice()).unwrap())\n-                          .as_slice());\n+                                                  []).unwrap())\n+                          []);\n                 handler.note(format!(\"stderr ---\\n{}\",\n                                   str::from_utf8(o.error\n-                                                  .as_slice()).unwrap())\n-                          .as_slice());\n+                                                  []).unwrap())\n+                          []);\n                 handler.abort_if_errors();\n             }\n             o\n         },\n         Err(e) => {\n-            handler.err(format!(\"could not exec `{}`: {}\", ar.as_slice(),\n-                             e).as_slice());\n+            handler.err(format!(\"could not exec `{}`: {}\", ar[],\n+                             e)[]);\n             handler.abort_if_errors();\n             panic!(\"rustc::back::archive::run_ar() should not reach this point\");\n         }\n@@ -106,16 +106,16 @@ pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n \n     for path in search_paths.iter() {\n         debug!(\"looking for {} inside {}\", name, path.display());\n-        let test = path.join(oslibname.as_slice());\n+        let test = path.join(oslibname[]);\n         if test.exists() { return test }\n         if oslibname != unixlibname {\n-            let test = path.join(unixlibname.as_slice());\n+            let test = path.join(unixlibname[]);\n             if test.exists() { return test }\n         }\n     }\n     handler.fatal(format!(\"could not find native static library `{}`, \\\n                            perhaps an -L flag is missing?\",\n-                          name).as_slice());\n+                          name)[]);\n }\n \n impl<'a> Archive<'a> {\n@@ -147,7 +147,7 @@ impl<'a> Archive<'a> {\n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<String> {\n         let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, &[&self.dst]);\n-        let output = str::from_utf8(output.output.as_slice()).unwrap();\n+        let output = str::from_utf8(output.output[]).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n         output.lines_any().map(|s| s.to_string()).collect()\n@@ -179,9 +179,9 @@ impl<'a> ArchiveBuilder<'a> {\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) -> io::IoResult<()> {\n         let location = find_library(name,\n-                                    self.archive.slib_prefix.as_slice(),\n-                                    self.archive.slib_suffix.as_slice(),\n-                                    self.archive.lib_search_paths.as_slice(),\n+                                    self.archive.slib_prefix[],\n+                                    self.archive.slib_suffix[],\n+                                    self.archive.lib_search_paths[],\n                                     self.archive.handler);\n         self.add_archive(&location, name, |_| false)\n     }\n@@ -197,12 +197,12 @@ impl<'a> ArchiveBuilder<'a> {\n         // as simple comparison is not enough - there\n         // might be also an extra name suffix\n         let obj_start = format!(\"{}\", name);\n-        let obj_start = obj_start.as_slice();\n+        let obj_start = obj_start[];\n         // Ignoring all bytecode files, no matter of\n         // name\n         let bc_ext = \".bytecode.deflate\";\n \n-        self.add_archive(rlib, name.as_slice(), |fname: &str| {\n+        self.add_archive(rlib, name[], |fname: &str| {\n             let skip_obj = lto && fname.starts_with(obj_start)\n                 && fname.ends_with(\".o\");\n             skip_obj || fname.ends_with(bc_ext) || fname == METADATA_FILENAME\n@@ -239,7 +239,7 @@ impl<'a> ArchiveBuilder<'a> {\n             // allow running `ar s file.a` to update symbols only.\n             if self.should_update_symbols {\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"s\", Some(self.work_dir.path()), args.as_slice());\n+                       \"s\", Some(self.work_dir.path()), args[]);\n             }\n             return self.archive;\n         }\n@@ -259,7 +259,7 @@ impl<'a> ArchiveBuilder<'a> {\n                 // Add the archive members seen so far, without updating the\n                 // symbol table (`S`).\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"cruS\", Some(self.work_dir.path()), args.as_slice());\n+                       \"cruS\", Some(self.work_dir.path()), args[]);\n \n                 args.clear();\n                 args.push(&abs_dst);\n@@ -274,7 +274,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // necessary.\n         let flags = if self.should_update_symbols { \"crus\" } else { \"cruS\" };\n         run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-               flags, Some(self.work_dir.path()), args.as_slice());\n+               flags, Some(self.work_dir.path()), args[]);\n \n         self.archive\n     }\n@@ -316,7 +316,7 @@ impl<'a> ArchiveBuilder<'a> {\n             } else {\n                 filename\n             };\n-            let new_filename = self.work_dir.path().join(filename.as_slice());\n+            let new_filename = self.work_dir.path().join(filename[]);\n             try!(fs::rename(file, &new_filename));\n             self.members.push(Path::new(filename));\n         }"}, {"sha": "1056ac928e687e7f996c9c5830c3225bb4144c8e", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -44,15 +44,15 @@ pub fn get_rpath_flags<F, G>(config: RPathConfig<F, G>) -> Vec<String> where\n         l.map(|p| p.clone())\n     }).collect::<Vec<_>>();\n \n-    let rpaths = get_rpaths(config, libs.as_slice());\n-    flags.push_all(rpaths_to_flags(rpaths.as_slice()).as_slice());\n+    let rpaths = get_rpaths(config, libs[]);\n+    flags.push_all(rpaths_to_flags(rpaths[])[]);\n     flags\n }\n \n fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     let mut ret = Vec::new();\n     for rpath in rpaths.iter() {\n-        ret.push(format!(\"-Wl,-rpath,{}\", (*rpath).as_slice()));\n+        ret.push(format!(\"-Wl,-rpath,{}\", (*rpath)[]));\n     }\n     return ret;\n }\n@@ -82,14 +82,14 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n         }\n     }\n \n-    log_rpaths(\"relative\", rel_rpaths.as_slice());\n-    log_rpaths(\"fallback\", fallback_rpaths.as_slice());\n+    log_rpaths(\"relative\", rel_rpaths[]);\n+    log_rpaths(\"fallback\", fallback_rpaths[]);\n \n     let mut rpaths = rel_rpaths;\n-    rpaths.push_all(fallback_rpaths.as_slice());\n+    rpaths.push_all(fallback_rpaths[]);\n \n     // Remove duplicates\n-    let rpaths = minimize_rpaths(rpaths.as_slice());\n+    let rpaths = minimize_rpaths(rpaths[]);\n     return rpaths;\n }\n \n@@ -140,7 +140,7 @@ fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n     let mut set = HashSet::new();\n     let mut minimized = Vec::new();\n     for rpath in rpaths.iter() {\n-        if set.insert(rpath.as_slice()) {\n+        if set.insert(rpath[]) {\n             minimized.push(rpath.clone());\n         }\n     }"}, {"sha": "d40c9ee8af6af75564b5b83efd2a3bdc61da1f83", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -65,7 +65,7 @@ impl Svh {\n     }\n \n     pub fn as_str<'a>(&'a self) -> &'a str {\n-        self.hash.as_slice()\n+        self.hash[]\n     }\n \n     pub fn calculate(metadata: &Vec<String>, krate: &ast::Crate) -> Svh {\n@@ -358,7 +358,7 @@ mod svh_visitor {\n             fn macro_name(macro: &Mac) -> token::InternedString {\n                 match &macro.node {\n                     &MacInvocTT(ref path, ref _tts, ref _stx_ctxt) => {\n-                        let s = path.segments.as_slice();\n+                        let s = path.segments[];\n                         assert_eq!(s.len(), 1);\n                         content(s[0].identifier)\n                     }"}, {"sha": "99a25bebf40ab4999fd95c84a204cd86314b32be", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -224,7 +224,7 @@ impl Target {\n                 Some(val) => val,\n                 None =>\n                     handler.fatal((format!(\"Field {} in target specification is required\", name))\n-                                  .as_slice())\n+                                  [])\n             }\n         };\n \n@@ -365,7 +365,7 @@ impl Target {\n \n         let target_path = os::getenv(\"RUST_TARGET_PATH\").unwrap_or(String::new());\n \n-        let paths = os::split_paths(target_path.as_slice());\n+        let paths = os::split_paths(target_path[]);\n         // FIXME 16351: add a sane default search path?\n \n         for dir in paths.iter() {"}, {"sha": "568bb023b68a28f9aae4a60ad84d5ac24c3be447", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -469,23 +469,23 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         new_loan.span,\n                         format!(\"cannot borrow `{}`{} as mutable \\\n                                 more than once at a time\",\n-                                nl, new_loan_msg).as_slice())\n+                                nl, new_loan_msg)[])\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         format!(\"closure requires unique access to `{}` \\\n                                 but {} is already borrowed{}\",\n-                                nl, ol_pronoun, old_loan_msg).as_slice());\n+                                nl, ol_pronoun, old_loan_msg)[]);\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         format!(\"cannot borrow `{}`{} as {} because \\\n                                 previous closure requires unique access\",\n-                                nl, new_loan_msg, new_loan.kind.to_user_str()).as_slice());\n+                                nl, new_loan_msg, new_loan.kind.to_user_str())[]);\n                 }\n \n                 (_, _) => {\n@@ -498,7 +498,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                 new_loan.kind.to_user_str(),\n                                 ol_pronoun,\n                                 old_loan.kind.to_user_str(),\n-                                old_loan_msg).as_slice());\n+                                old_loan_msg)[]);\n                 }\n             }\n \n@@ -507,7 +507,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     self.bccx.span_note(\n                         span,\n                         format!(\"borrow occurs due to use of `{}` in closure\",\n-                                nl).as_slice());\n+                                nl)[]);\n                 }\n                 _ => { }\n             }\n@@ -556,7 +556,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             self.bccx.span_note(\n                 old_loan.span,\n-                format!(\"{}; {}\", borrow_summary, rule_summary).as_slice());\n+                format!(\"{}; {}\", borrow_summary, rule_summary)[]);\n \n             let old_loan_span = self.tcx().map.span(old_loan.kill_scope.node_id());\n             self.bccx.span_end_note(old_loan_span,\n@@ -626,13 +626,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 self.bccx.span_err(\n                     span,\n                     format!(\"cannot use `{}` because it was mutably borrowed\",\n-                            self.bccx.loan_path_to_string(copy_path).as_slice())\n-                    .as_slice());\n+                            self.bccx.loan_path_to_string(copy_path)[])\n+                    []);\n                 self.bccx.span_note(\n                     loan_span,\n                     format!(\"borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_string(&*loan_path).as_slice())\n-                    .as_slice());\n+                            self.bccx.loan_path_to_string(&*loan_path)[])\n+                    []);\n             }\n         }\n     }\n@@ -651,20 +651,20 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 let err_message = match move_kind {\n                     move_data::Captured =>\n                         format!(\"cannot move `{}` into closure because it is borrowed\",\n-                                self.bccx.loan_path_to_string(move_path).as_slice()),\n+                                self.bccx.loan_path_to_string(move_path)[]),\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat =>\n                         format!(\"cannot move out of `{}` because it is borrowed\",\n-                                self.bccx.loan_path_to_string(move_path).as_slice())\n+                                self.bccx.loan_path_to_string(move_path)[])\n                 };\n \n-                self.bccx.span_err(span, err_message.as_slice());\n+                self.bccx.span_err(span, err_message[]);\n                 self.bccx.span_note(\n                     loan_span,\n                     format!(\"borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_string(&*loan_path).as_slice())\n-                    .as_slice());\n+                            self.bccx.loan_path_to_string(&*loan_path)[])\n+                    []);\n             }\n         }\n     }\n@@ -814,7 +814,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     self.bccx.span_err(\n                         assignment_span,\n                         format!(\"cannot assign to {}\",\n-                                self.bccx.cmt_to_string(&*assignee_cmt)).as_slice());\n+                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n                     self.bccx.span_help(\n                         self.tcx().map.span(upvar_id.closure_expr_id),\n                         \"consider changing this closure to take self by mutable reference\");\n@@ -823,7 +823,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         assignment_span,\n                         format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt)).as_slice());\n+                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n                 }\n             }\n             _ => match opt_loan_path(&assignee_cmt) {\n@@ -833,14 +833,14 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         format!(\"cannot assign to {} {} `{}`\",\n                                 assignee_cmt.mutbl.to_user_str(),\n                                 self.bccx.cmt_to_string(&*assignee_cmt),\n-                                self.bccx.loan_path_to_string(&*lp)).as_slice());\n+                                self.bccx.loan_path_to_string(&*lp))[]);\n                 }\n                 None => {\n                     self.bccx.span_err(\n                         assignment_span,\n                         format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt)).as_slice());\n+                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n                 }\n             }\n         }\n@@ -960,10 +960,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         self.bccx.span_err(\n             span,\n             format!(\"cannot assign to `{}` because it is borrowed\",\n-                    self.bccx.loan_path_to_string(loan_path)).as_slice());\n+                    self.bccx.loan_path_to_string(loan_path))[]);\n         self.bccx.span_note(\n             loan.span,\n             format!(\"borrow of `{}` occurs here\",\n-                    self.bccx.loan_path_to_string(loan_path)).as_slice());\n+                    self.bccx.loan_path_to_string(loan_path))[]);\n     }\n }"}, {"sha": "dbbc52cf36235970cb80ea153ff5848f245441cd", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -124,12 +124,12 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         let attrs : &[ast::Attribute];\n         attrs = match tcx.map.find(id) {\n             Some(ast_map::NodeItem(ref item)) =>\n-                item.attrs.as_slice(),\n+                item.attrs[],\n             Some(ast_map::NodeImplItem(&ast::MethodImplItem(ref m))) =>\n-                m.attrs.as_slice(),\n+                m.attrs[],\n             Some(ast_map::NodeTraitItem(&ast::ProvidedMethod(ref m))) =>\n-                m.attrs.as_slice(),\n-            _ => [].as_slice(),\n+                m.attrs[],\n+            _ => [][],\n         };\n \n         let span_err =\n@@ -145,7 +145,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, mpi) in vec_rc.iter().enumerate() {\n             let render = || this.path_loan_path(*mpi).user_string(tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).as_slice());\n+                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render())[]);\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n@@ -157,7 +157,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, f) in vec_rc.iter().enumerate() {\n             let render = || f.loan_path_user_string(this, tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).as_slice());\n+                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render())[]);\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n@@ -199,11 +199,11 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     // First, filter out duplicates\n     moved.sort();\n     moved.dedup();\n-    debug!(\"fragments 1 moved: {}\", path_lps(moved.as_slice()));\n+    debug!(\"fragments 1 moved: {}\", path_lps(moved[]));\n \n     assigned.sort();\n     assigned.dedup();\n-    debug!(\"fragments 1 assigned: {}\", path_lps(assigned.as_slice()));\n+    debug!(\"fragments 1 assigned: {}\", path_lps(assigned[]));\n \n     // Second, build parents from the moved and assigned.\n     for m in moved.iter() {\n@@ -223,14 +223,14 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     parents.sort();\n     parents.dedup();\n-    debug!(\"fragments 2 parents: {}\", path_lps(parents.as_slice()));\n+    debug!(\"fragments 2 parents: {}\", path_lps(parents[]));\n \n     // Third, filter the moved and assigned fragments down to just the non-parents\n-    moved.retain(|f| non_member(*f, parents.as_slice()));\n-    debug!(\"fragments 3 moved: {}\", path_lps(moved.as_slice()));\n+    moved.retain(|f| non_member(*f, parents[]));\n+    debug!(\"fragments 3 moved: {}\", path_lps(moved[]));\n \n-    assigned.retain(|f| non_member(*f, parents.as_slice()));\n-    debug!(\"fragments 3 assigned: {}\", path_lps(assigned.as_slice()));\n+    assigned.retain(|f| non_member(*f, parents[]));\n+    debug!(\"fragments 3 assigned: {}\", path_lps(assigned[]));\n \n     // Fourth, build the leftover from the moved, assigned, and parents.\n     for m in moved.iter() {\n@@ -248,16 +248,16 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     unmoved.sort();\n     unmoved.dedup();\n-    debug!(\"fragments 4 unmoved: {}\", frag_lps(unmoved.as_slice()));\n+    debug!(\"fragments 4 unmoved: {}\", frag_lps(unmoved[]));\n \n     // Fifth, filter the leftover fragments down to its core.\n     unmoved.retain(|f| match *f {\n         AllButOneFrom(_) => true,\n-        Just(mpi) => non_member(mpi, parents.as_slice()) &&\n-            non_member(mpi, moved.as_slice()) &&\n-            non_member(mpi, assigned.as_slice())\n+        Just(mpi) => non_member(mpi, parents[]) &&\n+            non_member(mpi, moved[]) &&\n+            non_member(mpi, assigned[])\n     });\n-    debug!(\"fragments 5 unmoved: {}\", frag_lps(unmoved.as_slice()));\n+    debug!(\"fragments 5 unmoved: {}\", frag_lps(unmoved[]));\n \n     // Swap contents back in.\n     fragments.unmoved_fragments = unmoved;\n@@ -434,7 +434,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             let msg = format!(\"type {} ({}) is not fragmentable\",\n                               parent_ty.repr(tcx), sty_and_variant_info);\n             let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n-            tcx.sess.opt_span_bug(opt_span, msg.as_slice())\n+            tcx.sess.opt_span_bug(opt_span, msg[])\n         }\n     }\n }"}, {"sha": "d7f50ccc6ba3ca19ae18f0d8e21fefd60883209b", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -310,7 +310,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n                             format!(\"invalid borrow lifetime: {}\",\n-                                    loan_region).as_slice());\n+                                    loan_region)[]);\n                     }\n                 };\n                 debug!(\"loan_scope = {}\", loan_scope);"}, {"sha": "73b345a70af4665484821ace157ff4a331d9ab08", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -120,7 +120,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             bccx.span_err(\n                 move_from.span,\n                 format!(\"cannot move out of {}\",\n-                        bccx.cmt_to_string(&*move_from)).as_slice());\n+                        bccx.cmt_to_string(&*move_from))[]);\n         }\n \n         mc::cat_downcast(ref b, _) |\n@@ -132,7 +132,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                         move_from.span,\n                         format!(\"cannot move out of type `{}`, \\\n                                  which defines the `Drop` trait\",\n-                                b.ty.user_string(bccx.tcx)).as_slice());\n+                                b.ty.user_string(bccx.tcx))[]);\n                 },\n                 _ => panic!(\"this path should not cause illegal move\")\n             }\n@@ -155,10 +155,10 @@ fn note_move_destination(bccx: &BorrowckCtxt,\n             format!(\"to prevent the move, \\\n                      use `ref {0}` or `ref mut {0}` to capture value by \\\n                      reference\",\n-                    pat_name).as_slice());\n+                    pat_name)[]);\n     } else {\n         bccx.span_note(move_to_span,\n                        format!(\"and here (use `ref {0}` or `ref mut {0}`)\",\n-                               pat_name).as_slice());\n+                               pat_name)[]);\n     }\n }"}, {"sha": "a13001b796850f02947a3de8b312314f22a0cb9c", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -146,7 +146,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     check_loans::check_loans(this,\n                              &loan_dfcx,\n                              flowed_moves,\n-                             all_loans.as_slice(),\n+                             all_loans[],\n                              id,\n                              decl,\n                              body);\n@@ -527,7 +527,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn report(&self, err: BckError<'tcx>) {\n         self.span_err(\n             err.span,\n-            self.bckerr_to_string(&err).as_slice());\n+            self.bckerr_to_string(&err)[]);\n         self.note_and_explain_bckerr(err);\n     }\n \n@@ -549,7 +549,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     use_span,\n                     format!(\"{} of possibly uninitialized variable: `{}`\",\n                             verb,\n-                            self.loan_path_to_string(lp)).as_slice());\n+                            self.loan_path_to_string(lp))[]);\n                 (self.loan_path_to_string(moved_lp),\n                  String::new())\n             }\n@@ -591,7 +591,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     format!(\"{} of {}moved value: `{}`\",\n                             verb,\n                             msg,\n-                            nl).as_slice());\n+                            nl)[]);\n                 (ol, moved_lp_msg)\n             }\n         };\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         self.tcx.sess.bug(format!(\"MoveExpr({}) maps to \\\n                                                    {}, not Expr\",\n                                                   the_move.id,\n-                                                  r).as_slice())\n+                                                  r)[])\n                     }\n                 };\n                 let (suggestion, _) = move_suggestion(self.tcx, param_env, expr_ty,\n@@ -621,7 +621,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion).as_slice());\n+                            suggestion)[]);\n             }\n \n             move_data::MovePat => {\n@@ -632,7 +632,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                              which is moved by default\",\n                             ol,\n                             moved_lp_msg,\n-                            pat_ty.user_string(self.tcx)).as_slice());\n+                            pat_ty.user_string(self.tcx))[]);\n                 self.tcx.sess.span_help(span,\n                     \"use `ref` to override\");\n             }\n@@ -648,7 +648,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         self.tcx.sess.bug(format!(\"Captured({}) maps to \\\n                                                    {}, not Expr\",\n                                                   the_move.id,\n-                                                  r).as_slice())\n+                                                  r)[])\n                     }\n                 };\n                 let (suggestion, help) = move_suggestion(self.tcx,\n@@ -663,7 +663,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion).as_slice());\n+                            suggestion)[]);\n                 self.tcx.sess.span_help(expr_span, help);\n             }\n         }\n@@ -696,7 +696,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err(\n             span,\n             format!(\"re-assignment of immutable variable `{}`\",\n-                    self.loan_path_to_string(lp)).as_slice());\n+                    self.loan_path_to_string(lp))[]);\n         self.tcx.sess.span_note(assign.span, \"prior assignment occurs here\");\n     }\n \n@@ -822,25 +822,25 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     format!(\"{} in an aliasable location\",\n-                             prefix).as_slice());\n+                             prefix)[]);\n             }\n             mc::AliasableClosure(id) => {\n                 self.tcx.sess.span_err(span,\n                                        format!(\"{} in a captured outer \\\n-                                               variable in an `Fn` closure\", prefix).as_slice());\n+                                               variable in an `Fn` closure\", prefix)[]);\n                 span_help!(self.tcx.sess, self.tcx.map.span(id),\n                            \"consider changing this closure to take self by mutable reference\");\n             }\n             mc::AliasableStatic(..) |\n             mc::AliasableStaticMut(..) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a static location\", prefix).as_slice());\n+                    format!(\"{} in a static location\", prefix)[]);\n             }\n             mc::AliasableBorrowed => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a `&` reference\", prefix).as_slice());\n+                    format!(\"{} in a `&` reference\", prefix)[]);\n             }\n         }\n \n@@ -908,12 +908,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 note_and_explain_region(\n                     self.tcx,\n                     format!(\"{} would have to be valid for \",\n-                            descr).as_slice(),\n+                            descr)[],\n                     loan_scope,\n                     \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"...but {} is only valid for \", descr).as_slice(),\n+                    format!(\"...but {} is only valid for \", descr)[],\n                     ptr_scope,\n                     \"\");\n             }\n@@ -933,7 +933,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_loan_path_to_string(&**lp_base, out);\n                 out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(ty::item_path_str(self.tcx, variant_def_id).as_slice());\n+                out.push_str(ty::item_path_str(self.tcx, variant_def_id)[]);\n                 out.push(')');\n             }\n \n@@ -947,7 +947,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push('.');\n-                        out.push_str(idx.to_string().as_slice());\n+                        out.push_str(idx.to_string()[]);\n                     }\n                 }\n             }\n@@ -979,7 +979,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 out.push(':');\n-                out.push_str(ty::item_path_str(self.tcx, variant_def_id).as_slice());\n+                out.push_str(ty::item_path_str(self.tcx, variant_def_id)[]);\n                 out.push(')');\n             }\n "}, {"sha": "e2813c8e9882ad112e55896fafd6d3357d3ec902", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n             if seen_one { sets.push_str(\" \"); } else { seen_one = true; }\n             sets.push_str(variant.short_name());\n             sets.push_str(\": \");\n-            sets.push_str(self.dataflow_for_variant(e, n, variant).as_slice());\n+            sets.push_str(self.dataflow_for_variant(e, n, variant)[]);\n         }\n         sets\n     }\n@@ -88,7 +88,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n                 set.push_str(\", \");\n             }\n             let loan_str = self.borrowck_ctxt.loan_path_to_string(&*lp);\n-            set.push_str(loan_str.as_slice());\n+            set.push_str(loan_str[]);\n             saw_some = true;\n             true\n         });"}, {"sha": "20bb9c2f4fd1cd5f6445e7b79a2d6348444382cf", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -58,12 +58,12 @@ pub fn compile_input(sess: Session,\n             let outputs = build_output_filenames(input,\n                                                  outdir,\n                                                  output,\n-                                                 krate.attrs.as_slice(),\n+                                                 krate.attrs[],\n                                                  &sess);\n-            let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(),\n+            let id = link::find_crate_name(Some(&sess), krate.attrs[],\n                                            input);\n             let expanded_crate\n-                = match phase_2_configure_and_expand(&sess, krate, id.as_slice(),\n+                = match phase_2_configure_and_expand(&sess, krate, id[],\n                                                      addl_plugins) {\n                     None => return,\n                     Some(k) => k\n@@ -75,7 +75,7 @@ pub fn compile_input(sess: Session,\n         let mut forest = ast_map::Forest::new(expanded_crate);\n         let ast_map = assign_node_ids_and_map(&sess, &mut forest);\n \n-        write_out_deps(&sess, input, &outputs, id.as_slice());\n+        write_out_deps(&sess, input, &outputs, id[]);\n \n         if stop_after_phase_2(&sess) { return; }\n \n@@ -163,9 +163,9 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let time_passes = sess.time_passes();\n \n     *sess.crate_types.borrow_mut() =\n-        collect_crate_types(sess, krate.attrs.as_slice());\n+        collect_crate_types(sess, krate.attrs[]);\n     *sess.crate_metadata.borrow_mut() =\n-        collect_crate_metadata(sess, krate.attrs.as_slice());\n+        collect_crate_metadata(sess, krate.attrs[]);\n \n     time(time_passes, \"gated feature checking\", (), |_| {\n         let (features, unknown_features) =\n@@ -257,8 +257,8 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             if cfg!(windows) {\n                 _old_path = os::getenv(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch().get_dylib_search_paths();\n-                new_path.extend(os::split_paths(_old_path.as_slice()).into_iter());\n-                os::setenv(\"PATH\", os::join_paths(new_path.as_slice()).unwrap());\n+                new_path.extend(os::split_paths(_old_path[]).into_iter());\n+                os::setenv(\"PATH\", os::join_paths(new_path[]).unwrap());\n             }\n             let cfg = syntax::ext::expand::ExpansionConfig {\n                 crate_name: crate_name.to_string(),\n@@ -503,7 +503,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             write::run_passes(sess,\n                               trans,\n-                              sess.opts.output_types.as_slice(),\n+                              sess.opts.output_types[],\n                               outputs));\n     }\n \n@@ -517,14 +517,14 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     let old_path = os::getenv(\"PATH\").unwrap_or_else(||String::new());\n     let mut new_path = sess.host_filesearch().get_tools_search_paths();\n-    new_path.extend(os::split_paths(old_path.as_slice()).into_iter());\n-    os::setenv(\"PATH\", os::join_paths(new_path.as_slice()).unwrap());\n+    new_path.extend(os::split_paths(old_path[]).into_iter());\n+    os::setenv(\"PATH\", os::join_paths(new_path[]).unwrap());\n \n     time(sess.time_passes(), \"linking\", (), |_|\n          link::link_binary(sess,\n                            trans,\n                            outputs,\n-                           trans.link.crate_name.as_slice()));\n+                           trans.link.crate_name[]));\n \n     os::setenv(\"PATH\", old_path);\n }\n@@ -613,7 +613,7 @@ fn write_out_deps(sess: &Session,\n         // write Makefile-compatible dependency rules\n         let files: Vec<String> = sess.codemap().files.borrow()\n                                    .iter().filter(|fmap| fmap.is_real_file())\n-                                   .map(|fmap| escape_dep_filename(fmap.name.as_slice()))\n+                                   .map(|fmap| escape_dep_filename(fmap.name[]))\n                                    .collect();\n         let mut file = try!(io::File::create(&deps_filename));\n         for path in out_filenames.iter() {\n@@ -627,7 +627,7 @@ fn write_out_deps(sess: &Session,\n         Ok(()) => {}\n         Err(e) => {\n             sess.fatal(format!(\"error writing dependencies to `{}`: {}\",\n-                               deps_filename.display(), e).as_slice());\n+                               deps_filename.display(), e)[]);\n         }\n     }\n }\n@@ -698,7 +698,7 @@ pub fn collect_crate_types(session: &Session,\n         if !res {\n             session.warn(format!(\"dropping unsupported crate type `{}` \\\n                                    for target `{}`\",\n-                                 *crate_type, session.opts.target_triple).as_slice());\n+                                 *crate_type, session.opts.target_triple)[]);\n         }\n \n         res"}, {"sha": "1fb90d7860e42029603a07a6b97fb58c25dd2775", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -55,6 +55,7 @@ use rustc::DIAGNOSTICS;\n \n use std::any::AnyRefExt;\n use std::io;\n+use std::iter::repeat;\n use std::os;\n use std::thread;\n \n@@ -88,12 +89,12 @@ fn run_compiler(args: &[String]) {\n     let descriptions = diagnostics::registry::Registry::new(&DIAGNOSTICS);\n     match matches.opt_str(\"explain\") {\n         Some(ref code) => {\n-            match descriptions.find_description(code.as_slice()) {\n+            match descriptions.find_description(code[]) {\n                 Some(ref description) => {\n                     println!(\"{}\", description);\n                 }\n                 None => {\n-                    early_error(format!(\"no extended information for {}\", code).as_slice());\n+                    early_error(format!(\"no extended information for {}\", code)[]);\n                 }\n             }\n             return;\n@@ -119,7 +120,7 @@ fn run_compiler(args: &[String]) {\n             early_error(\"no input filename given\");\n         }\n         1u => {\n-            let ifile = matches.free[0].as_slice();\n+            let ifile = matches.free[0][];\n             if ifile == \"-\" {\n                 let contents = io::stdin().read_to_end().unwrap();\n                 let src = String::from_utf8(contents).unwrap();\n@@ -138,7 +139,7 @@ fn run_compiler(args: &[String]) {\n     }\n \n     let pretty = matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-        pretty::parse_pretty(&sess, a.as_slice())\n+        pretty::parse_pretty(&sess, a[])\n     });\n     match pretty.into_iter().next() {\n         Some((ppm, opt_uii)) => {\n@@ -261,7 +262,8 @@ Available lint options:\n         .map(|&s| s.name.width(true))\n         .max().unwrap_or(0);\n     let padded = |x: &str| {\n-        let mut s = \" \".repeat(max_name_len - x.char_len());\n+        let mut s = repeat(\" \").take(max_name_len - x.chars().count())\n+                               .collect::<String>();\n         s.push_str(x);\n         s\n     };\n@@ -274,7 +276,7 @@ Available lint options:\n         for lint in lints.into_iter() {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n             println!(\"    {}  {:7.7}  {}\",\n-                     padded(name.as_slice()), lint.default_level.as_str(), lint.desc);\n+                     padded(name[]), lint.default_level.as_str(), lint.desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -287,7 +289,8 @@ Available lint options:\n         .map(|&(s, _)| s.width(true))\n         .max().unwrap_or(0);\n     let padded = |x: &str| {\n-        let mut s = \" \".repeat(max_name_len - x.char_len());\n+        let mut s = repeat(\" \").take(max_name_len - x.chars().count())\n+                               .collect::<String>();\n         s.push_str(x);\n         s\n     };\n@@ -303,7 +306,7 @@ Available lint options:\n             let desc = to.into_iter().map(|x| x.as_str().replace(\"_\", \"-\"))\n                          .collect::<Vec<String>>().connect(\", \");\n             println!(\"    {}  {}\",\n-                     padded(name.as_slice()), desc);\n+                     padded(name[]), desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -367,10 +370,10 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     }\n \n     let matches =\n-        match getopts::getopts(args.as_slice(), config::optgroups().as_slice()) {\n+        match getopts::getopts(args[], config::optgroups()[]) {\n             Ok(m) => m,\n             Err(f) => {\n-                early_error(f.to_string().as_slice());\n+                early_error(f.to_string()[]);\n             }\n         };\n \n@@ -518,16 +521,15 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n                     \"run with `RUST_BACKTRACE=1` for a backtrace\".to_string(),\n                 ];\n                 for note in xs.iter() {\n-                    emitter.emit(None, note.as_slice(), None, diagnostic::Note)\n+                    emitter.emit(None, note[], None, diagnostic::Note)\n                 }\n \n                 match r.read_to_string() {\n                     Ok(s) => println!(\"{}\", s),\n                     Err(e) => {\n                         emitter.emit(None,\n                                      format!(\"failed to read internal \\\n-                                              stderr: {}\",\n-                                             e).as_slice(),\n+                                              stderr: {}\", e)[],\n                                      None,\n                                      diagnostic::Error)\n                     }"}, {"sha": "4b10ca92e705e7d532d6d319a5a39abc73b73b9f", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -71,10 +71,10 @@ pub fn parse_pretty(sess: &Session, name: &str) -> (PpMode, Option<UserIdentifie\n             sess.fatal(format!(\n                 \"argument to `pretty` must be one of `normal`, \\\n                  `expanded`, `flowgraph=<nodeid>`, `typed`, `identified`, \\\n-                 or `expanded,identified`; got {}\", name).as_slice());\n+                 or `expanded,identified`; got {}\", name)[]);\n         }\n     };\n-    let opt_second = opt_second.and_then::<UserIdentifiedItem, _>(from_str);\n+    let opt_second = opt_second.and_then(|s| s.parse::<UserIdentifiedItem>());\n     (first, opt_second)\n }\n \n@@ -276,7 +276,7 @@ impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n                 try!(pp::word(&mut s.s,\n                               ppaux::ty_to_string(\n                                   tcx,\n-                                  ty::expr_ty(tcx, expr)).as_slice()));\n+                                  ty::expr_ty(tcx, expr))[]));\n                 s.pclose()\n             }\n             _ => Ok(())\n@@ -311,7 +311,7 @@ pub enum UserIdentifiedItem {\n \n impl FromStr for UserIdentifiedItem {\n     fn from_str(s: &str) -> Option<UserIdentifiedItem> {\n-        from_str(s).map(ItemViaNode).or_else(|| {\n+        s.parse().map(ItemViaNode).or_else(|| {\n             let v : Vec<_> = s.split_str(\"::\")\n                 .map(|x|x.to_string())\n                 .collect();\n@@ -322,7 +322,7 @@ impl FromStr for UserIdentifiedItem {\n \n enum NodesMatchingUII<'a, 'ast: 'a> {\n     NodesMatchingDirect(option::IntoIter<ast::NodeId>),\n-    NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, 'ast, String>),\n+    NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, 'ast>),\n }\n \n impl<'a, 'ast> Iterator<ast::NodeId> for NodesMatchingUII<'a, 'ast> {\n@@ -348,7 +348,7 @@ impl UserIdentifiedItem {\n             ItemViaNode(node_id) =>\n                 NodesMatchingDirect(Some(node_id).into_iter()),\n             ItemViaPath(ref parts) =>\n-                NodesMatchingSuffix(map.nodes_matching_suffix(parts.as_slice())),\n+                NodesMatchingSuffix(map.nodes_matching_suffix(parts[])),\n         }\n     }\n \n@@ -360,7 +360,7 @@ impl UserIdentifiedItem {\n                         user_option,\n                         self.reconstructed_input(),\n                         is_wrong_because);\n-            sess.fatal(message.as_slice())\n+            sess.fatal(message[])\n         };\n \n         let mut saw_node = ast::DUMMY_NODE_ID;\n@@ -414,12 +414,12 @@ pub fn pretty_print_input(sess: Session,\n                           opt_uii: Option<UserIdentifiedItem>,\n                           ofile: Option<Path>) {\n     let krate = driver::phase_1_parse_input(&sess, cfg, input);\n-    let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(), input);\n+    let id = link::find_crate_name(Some(&sess), krate.attrs[], input);\n \n     let is_expanded = needs_expansion(&ppm);\n     let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n     let krate = if compute_ast_map {\n-        match driver::phase_2_configure_and_expand(&sess, krate, id.as_slice(), None) {\n+        match driver::phase_2_configure_and_expand(&sess, krate, id[], None) {\n             None => return,\n             Some(k) => k\n         }\n@@ -438,7 +438,7 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src_name = driver::source_name(input);\n-    let src = sess.codemap().get_filemap(src_name.as_slice())\n+    let src = sess.codemap().get_filemap(src_name[])\n                             .src.as_bytes().to_vec();\n     let mut rdr = MemReader::new(src);\n \n@@ -499,15 +499,15 @@ pub fn pretty_print_input(sess: Session,\n             debug!(\"pretty printing flow graph for {}\", opt_uii);\n             let uii = opt_uii.unwrap_or_else(|| {\n                 sess.fatal(format!(\"`pretty flowgraph=..` needs NodeId (int) or\n-                                     unique path suffix (b::c::d)\").as_slice())\n+                                     unique path suffix (b::c::d)\")[])\n \n             });\n             let ast_map = ast_map.expect(\"--pretty flowgraph missing ast_map\");\n             let nodeid = uii.to_one_node_id(\"--pretty\", &sess, &ast_map);\n \n             let node = ast_map.find(nodeid).unwrap_or_else(|| {\n                 sess.fatal(format!(\"--pretty flowgraph couldn't find id: {}\",\n-                                   nodeid).as_slice())\n+                                   nodeid)[])\n             });\n \n             let code = blocks::Code::from_node(node);\n@@ -526,8 +526,8 @@ pub fn pretty_print_input(sess: Session,\n                     // point to what was found, if there's an\n                     // accessible span.\n                     match ast_map.opt_span(nodeid) {\n-                        Some(sp) => sess.span_fatal(sp, message.as_slice()),\n-                        None => sess.fatal(message.as_slice())\n+                        Some(sp) => sess.span_fatal(sp, message[]),\n+                        None => sess.fatal(message[])\n                     }\n                 }\n             }\n@@ -587,7 +587,7 @@ fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,\n             let m = \"graphviz::render failed\";\n             io::IoError {\n                 detail: Some(match orig_detail {\n-                    None => m.into_string(),\n+                    None => m.to_string(),\n                     Some(d) => format!(\"{}: {}\", m, d)\n                 }),\n                 ..ioerr"}, {"sha": "bf9e9294307ef241aa7e45c432d3ea3fd211afdb", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -97,8 +97,8 @@ use std::mem::replace;\n use std::rc::{Rc, Weak};\n use std::uint;\n \n-// Definition mapping\n-pub type DefMap = RefCell<NodeMap<Def>>;\n+mod check_unused;\n+mod record_exports;\n \n #[deriving(Copy)]\n struct BindingInfo {\n@@ -1119,14 +1119,14 @@ impl<'a> Resolver<'a> {\n                     self.resolve_error(sp,\n                         format!(\"duplicate definition of {} `{}`\",\n                              namespace_error_to_string(duplicate_type),\n-                             token::get_name(name)).as_slice());\n+                             token::get_name(name))[]);\n                     {\n                         let r = child.span_for_namespace(ns);\n                         for sp in r.iter() {\n                             self.session.span_note(*sp,\n                                  format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_string(duplicate_type),\n-                                      token::get_name(name)).as_slice());\n+                                      token::get_name(name))[]);\n                         }\n                     }\n                 }\n@@ -2147,7 +2147,7 @@ impl<'a> Resolver<'a> {\n                 debug!(\"(building import directive) building import \\\n                         directive: {}::{}\",\n                        self.names_to_string(module_.imports.borrow().last().unwrap()\n-                                                 .module_path.as_slice()),\n+                                                 .module_path[]),\n                        token::get_name(target));\n \n                 let mut import_resolutions = module_.import_resolutions\n@@ -2265,10 +2265,10 @@ impl<'a> Resolver<'a> {\n                     let msg = format!(\"unresolved import `{}`{}\",\n                                       self.import_path_to_string(\n                                           import_directive.module_path\n-                                                          .as_slice(),\n+                                                          [],\n                                           import_directive.subclass),\n                                       help);\n-                    self.resolve_error(span, msg.as_slice());\n+                    self.resolve_error(span, msg[]);\n                 }\n                 Indeterminate => break, // Bail out. We'll come around next time.\n                 Success(()) => () // Good. Continue.\n@@ -2298,7 +2298,7 @@ impl<'a> Resolver<'a> {\n                                         .iter()\n                                         .map(|seg| seg.identifier.name)\n                                         .collect();\n-        self.names_to_string(names.as_slice())\n+        self.names_to_string(names[])\n     }\n \n     fn import_directive_subclass_to_string(&mut self,\n@@ -2340,7 +2340,7 @@ impl<'a> Resolver<'a> {\n \n         debug!(\"(resolving import for module) resolving import `{}::...` in \\\n                 `{}`\",\n-               self.names_to_string(module_path.as_slice()),\n+               self.names_to_string(module_path[]),\n                self.module_to_string(&*module_));\n \n         // First, resolve the module path for the directive, if necessary.\n@@ -2349,7 +2349,7 @@ impl<'a> Resolver<'a> {\n             Some((self.graph_root.get_module(), LastMod(AllPublic)))\n         } else {\n             match self.resolve_module_path(module_.clone(),\n-                                           module_path.as_slice(),\n+                                           module_path[],\n                                            DontUseLexicalScope,\n                                            import_directive.span,\n                                            ImportSearch) {\n@@ -2941,7 +2941,7 @@ impl<'a> Resolver<'a> {\n                                     ValueNS => \"value\",\n                                   },\n                                   token::get_name(name).get());\n-                self.session.span_err(import_span, msg.as_slice());\n+                self.session.span_err(import_span, msg[]);\n             }\n             Some(_) | None => {}\n         }\n@@ -2956,7 +2956,7 @@ impl<'a> Resolver<'a> {\n         if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n                               token::get_name(name));\n-            self.session.span_err(import_span, msg.as_slice());\n+            self.session.span_err(import_span, msg[]);\n         }\n     }\n \n@@ -2981,7 +2981,7 @@ impl<'a> Resolver<'a> {\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, msg.as_slice());\n+                    self.session.span_err(import_span, msg[]);\n                 }\n                 Some(_) | None => {}\n             }\n@@ -3003,7 +3003,7 @@ impl<'a> Resolver<'a> {\n                     let msg = format!(\"import `{}` conflicts with value \\\n                                        in this module\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, msg.as_slice());\n+                    self.session.span_err(import_span, msg[]);\n                     if let Some(span) = value.value_span {\n                         self.session.span_note(span,\n                                                \"conflicting value here\");\n@@ -3021,7 +3021,7 @@ impl<'a> Resolver<'a> {\n                             let msg = format!(\"import `{}` conflicts with type in \\\n                                                this module\",\n                                               token::get_name(name).get());\n-                            self.session.span_err(import_span, msg.as_slice());\n+                            self.session.span_err(import_span, msg[]);\n                             if let Some(span) = ty.type_span {\n                                 self.session.span_note(span,\n                                                        \"note conflicting type here\")\n@@ -3034,7 +3034,7 @@ impl<'a> Resolver<'a> {\n                                         let msg = format!(\"inherent implementations \\\n                                                            are only allowed on types \\\n                                                            defined in the current module\");\n-                                        self.session.span_err(span, msg.as_slice());\n+                                        self.session.span_err(span, msg[]);\n                                         self.session.span_note(import_span,\n                                                                \"import from other module here\")\n                                     }\n@@ -3043,7 +3043,7 @@ impl<'a> Resolver<'a> {\n                                     let msg = format!(\"import `{}` conflicts with existing \\\n                                                        submodule\",\n                                                       token::get_name(name).get());\n-                                    self.session.span_err(import_span, msg.as_slice());\n+                                    self.session.span_err(import_span, msg[]);\n                                     if let Some(span) = ty.type_span {\n                                         self.session.span_note(span,\n                                                                \"note conflicting module here\")\n@@ -3073,7 +3073,7 @@ impl<'a> Resolver<'a> {\n                 .span_err(span,\n                           format!(\"an external crate named `{}` has already \\\n                                    been imported into this module\",\n-                                  token::get_name(name).get()).as_slice());\n+                                  token::get_name(name).get())[]);\n         }\n     }\n \n@@ -3092,7 +3092,7 @@ impl<'a> Resolver<'a> {\n                           format!(\"the name `{}` conflicts with an external \\\n                                    crate that has been imported into this \\\n                                    module\",\n-                                  token::get_name(name).get()).as_slice());\n+                                  token::get_name(name).get())[]);\n         }\n     }\n \n@@ -3140,7 +3140,7 @@ impl<'a> Resolver<'a> {\n                     let segment_name = token::get_name(name);\n                     let module_name = self.module_to_string(&*search_module);\n                     let mut span = span;\n-                    let msg = if \"???\" == module_name.as_slice() {\n+                    let msg = if \"???\" == module_name[] {\n                         span.hi = span.lo + Pos::from_uint(segment_name.get().len());\n \n                         match search_parent_externals(name,\n@@ -3253,14 +3253,14 @@ impl<'a> Resolver<'a> {\n         match module_prefix_result {\n             Failed(None) => {\n                 let mpath = self.names_to_string(module_path);\n-                let mpath = mpath.as_slice();\n+                let mpath = mpath[];\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n                         let msg = format!(\"Could not find `{}` in `{}`\",\n                                             // idx +- 1 to account for the\n                                             // colons on either side\n-                                            mpath.slice_from(idx + 1),\n-                                            mpath.slice_to(idx - 1));\n+                                            mpath[idx + 1..],\n+                                            mpath[0..idx - 1]);\n                         return Failed(Some((span, msg)));\n                     },\n                     None => {\n@@ -3431,7 +3431,7 @@ impl<'a> Resolver<'a> {\n                                               true) {\n                 Failed(Some((span, msg))) =>\n                     self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                     msg)),\n+                                                     msg)[]),\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n                     // We couldn't see through the higher scope because of an\n@@ -3686,8 +3686,8 @@ impl<'a> Resolver<'a> {\n                                    \"unresolved import\");\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n-                                  sn.slice(0, sn.len()));\n-                self.resolve_error((*imports)[index].span, err.as_slice());\n+                                  sn);\n+                self.resolve_error((*imports)[index].span, err[]);\n             }\n         }\n \n@@ -3779,7 +3779,7 @@ impl<'a> Resolver<'a> {\n         match def_like {\n             DlDef(d @ DefUpvar(..)) => {\n                 self.session.span_bug(span,\n-                    format!(\"unexpected {} in bindings\", d).as_slice())\n+                    format!(\"unexpected {} in bindings\", d)[])\n             }\n             DlDef(d @ DefLocal(_)) => {\n                 let node_id = d.def_id().node;\n@@ -3995,7 +3995,7 @@ impl<'a> Resolver<'a> {\n                                             generics,\n                                             implemented_traits,\n                                             &**self_type,\n-                                            impl_items.as_slice());\n+                                            impl_items[]);\n             }\n \n             ItemTrait(_, ref generics, ref unbound, ref bounds, ref trait_items) => {\n@@ -4080,7 +4080,7 @@ impl<'a> Resolver<'a> {\n             ItemStruct(ref struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n                                     generics,\n-                                    struct_def.fields.as_slice());\n+                                    struct_def.fields[]);\n             }\n \n             ItemMod(ref module_) => {\n@@ -4153,7 +4153,7 @@ impl<'a> Resolver<'a> {\n                                                     parameter in this type \\\n                                                     parameter list\",\n                                                    token::get_name(\n-                                                       name)).as_slice())\n+                                                       name))[])\n                     }\n                     seen_bindings.insert(name);\n \n@@ -4330,7 +4330,7 @@ impl<'a> Resolver<'a> {\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n-                self.resolve_error(trait_reference.path.span, msg.as_slice());\n+                self.resolve_error(trait_reference.path.span, msg[]);\n             }\n             Some(def) => {\n                 match def {\n@@ -4342,14 +4342,14 @@ impl<'a> Resolver<'a> {\n                         self.resolve_error(trait_reference.path.span,\n                                            format!(\"`{}` is not a trait\",\n                                                    self.path_names_to_string(\n-                                                       &trait_reference.path)));\n+                                                       &trait_reference.path))[]);\n \n                         // If it's a typedef, give a note\n                         if let DefTy(..) = def {\n                             self.session.span_note(\n                                 trait_reference.path.span,\n                                 format!(\"`type` aliases cannot be used for traits\")\n-                                    .as_slice());\n+                                    []);\n                         }\n                     }\n                 }\n@@ -4546,7 +4546,7 @@ impl<'a> Resolver<'a> {\n                 self.resolve_error(span,\n                                     format!(\"method `{}` is not a member of trait `{}`\",\n                                             token::get_name(name),\n-                                            path_str).as_slice());\n+                                            path_str)[]);\n             }\n         }\n     }\n@@ -4613,7 +4613,7 @@ impl<'a> Resolver<'a> {\n                         format!(\"variable `{}` from pattern #1 is \\\n                                   not bound in pattern #{}\",\n                                 token::get_name(key),\n-                                i + 1).as_slice());\n+                                i + 1)[]);\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n@@ -4622,7 +4622,7 @@ impl<'a> Resolver<'a> {\n                             format!(\"variable `{}` is bound with different \\\n                                       mode in pattern #{} than in pattern #1\",\n                                     token::get_name(key),\n-                                    i + 1).as_slice());\n+                                    i + 1)[]);\n                     }\n                   }\n                 }\n@@ -4635,7 +4635,7 @@ impl<'a> Resolver<'a> {\n                         format!(\"variable `{}` from pattern {}{} is \\\n                                   not bound in pattern {}1\",\n                                 token::get_name(key),\n-                                \"#\", i + 1, \"#\").as_slice());\n+                                \"#\", i + 1, \"#\")[]);\n                 }\n             }\n         }\n@@ -4752,7 +4752,7 @@ impl<'a> Resolver<'a> {\n                     None => {\n                         let msg = format!(\"use of undeclared type name `{}`\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(ty.span, msg.as_slice());\n+                        self.resolve_error(ty.span, msg[]);\n                     }\n                 }\n             }\n@@ -4832,7 +4832,7 @@ impl<'a> Resolver<'a> {\n                                 format!(\"declaration of `{}` shadows an enum \\\n                                          variant or unit-like struct in \\\n                                          scope\",\n-                                        token::get_name(renamed)).as_slice());\n+                                        token::get_name(renamed))[]);\n                         }\n                         FoundConst(ref def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n@@ -4884,7 +4884,7 @@ impl<'a> Resolver<'a> {\n                                                             list\",\n                                                            token::get_ident(\n                                                                ident))\n-                                                   .as_slice())\n+                                                   [])\n                             } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n@@ -4893,7 +4893,7 @@ impl<'a> Resolver<'a> {\n                                     format!(\"identifier `{}` is bound \\\n                                              more than once in the same \\\n                                              pattern\",\n-                                            token::get_ident(ident)).as_slice());\n+                                            token::get_ident(ident))[]);\n                             }\n                             // Else, not bound in the same pattern: do\n                             // nothing.\n@@ -4922,7 +4922,7 @@ impl<'a> Resolver<'a> {\n                                         path.segments\n                                             .last()\n                                             .unwrap()\n-                                            .identifier)).as_slice());\n+                                            .identifier))[]);\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n@@ -4931,7 +4931,7 @@ impl<'a> Resolver<'a> {\n                                         path.segments\n                                             .last()\n                                             .unwrap()\n-                                            .identifier)).as_slice());\n+                                            .identifier))[]);\n                         }\n                     }\n \n@@ -4962,7 +4962,7 @@ impl<'a> Resolver<'a> {\n                                     def: {}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n                                               self.path_names_to_string(path));\n-                            self.resolve_error(path.span, msg.as_slice());\n+                            self.resolve_error(path.span, msg[]);\n                         }\n                     }\n                 }\n@@ -5024,7 +5024,7 @@ impl<'a> Resolver<'a> {\n                 match err {\n                     Some((span, msg)) => {\n                         self.resolve_error(span, format!(\"failed to resolve: {}\",\n-                                                         msg));\n+                                                         msg)[]);\n                     }\n                     None => ()\n                 }\n@@ -5220,7 +5220,7 @@ impl<'a> Resolver<'a> {\n         let last_private;\n         let module = self.current_module.clone();\n         match self.resolve_module_path(module,\n-                                       module_path.as_slice(),\n+                                       module_path[],\n                                        UseLexicalScope,\n                                        path.span,\n                                        PathSearch) {\n@@ -5235,7 +5235,7 @@ impl<'a> Resolver<'a> {\n                 };\n \n                 self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                 msg.as_slice()));\n+                                                 msg)[]);\n                 return None;\n             }\n             Indeterminate => panic!(\"indeterminate unexpected\"),\n@@ -5278,7 +5278,7 @@ impl<'a> Resolver<'a> {\n         let containing_module;\n         let last_private;\n         match self.resolve_module_path_from_root(root_module,\n-                                                 module_path.as_slice(),\n+                                                 module_path[],\n                                                  0,\n                                                  path.span,\n                                                  PathSearch,\n@@ -5288,13 +5288,13 @@ impl<'a> Resolver<'a> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared module `::{}`\",\n-                                          self.names_to_string(module_path.as_slice()));\n+                                          self.names_to_string(module_path[]));\n                         (path.span, msg)\n                     }\n                 };\n \n                 self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                 msg.as_slice()));\n+                                                 msg)[]);\n                 return None;\n             }\n \n@@ -5335,7 +5335,7 @@ impl<'a> Resolver<'a> {\n             }\n             TypeNS => {\n                 let name = ident.name;\n-                self.search_ribs(self.type_ribs.as_slice(), name, span)\n+                self.search_ribs(self.type_ribs[], name, span)\n             }\n         };\n \n@@ -5389,7 +5389,8 @@ impl<'a> Resolver<'a> {\n             Failed(err) => {\n                 match err {\n                     Some((span, msg)) =>\n-                        self.resolve_error(span, format!(\"failed to resolve. {}\", msg)),\n+                        self.resolve_error(span, format!(\"failed to resolve. {}\",\n+                                                         msg)[]),\n                     None => ()\n                 }\n \n@@ -5409,9 +5410,9 @@ impl<'a> Resolver<'a> {\n         rs\n     }\n \n-    fn resolve_error<T: Str>(&self, span: Span, s: T) {\n+    fn resolve_error(&self, span: Span, s: &str) {\n         if self.emit_errors {\n-            self.session.span_err(span, s.as_slice());\n+            self.session.span_err(span, s);\n         }\n     }\n \n@@ -5446,7 +5447,7 @@ impl<'a> Resolver<'a> {\n                 }\n             } else {\n                 match this.resolve_module_path(root,\n-                                                name_path.as_slice(),\n+                                                name_path[],\n                                                 UseLexicalScope,\n                                                 span,\n                                                 PathSearch) {\n@@ -5484,7 +5485,7 @@ impl<'a> Resolver<'a> {\n         let name_path = path.segments.iter().map(|seg| seg.identifier.name).collect::<Vec<_>>();\n \n         // Look for a method in the current self type's impl module.\n-        match get_module(self, path.span, name_path.as_slice()) {\n+        match get_module(self, path.span, name_path[]) {\n             Some(module) => match module.children.borrow().get(&name) {\n                 Some(binding) => {\n                     let p_str = self.path_names_to_string(&path);\n@@ -5695,7 +5696,7 @@ impl<'a> Resolver<'a> {\n                                 def: {}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(path.span, msg.as_slice());\n+                        self.resolve_error(path.span, msg[]);\n                     }\n                 }\n \n@@ -5751,13 +5752,13 @@ impl<'a> Resolver<'a> {\n \n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 let renamed = mtwt::resolve(label);\n-                match self.search_ribs(self.label_ribs.as_slice(),\n+                match self.search_ribs(self.label_ribs[],\n                                        renamed, expr.span) {\n                     None => {\n                         self.resolve_error(\n                             expr.span,\n                             format!(\"use of undeclared label `{}`\",\n-                                    token::get_ident(label)).as_slice())\n+                                    token::get_ident(label))[])\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n@@ -5893,7 +5894,7 @@ impl<'a> Resolver<'a> {\n                                   then {}\",\n                                  node_id,\n                                  *entry.get(),\n-                                 def).as_slice());\n+                                 def)[]);\n             },\n             Vacant(entry) => { entry.set(def); },\n         }\n@@ -5909,7 +5910,7 @@ impl<'a> Resolver<'a> {\n                 self.resolve_error(pat.span,\n                                    format!(\"cannot use `ref` binding mode \\\n                                             with {}\",\n-                                           descr).as_slice());\n+                                           descr)[]);\n             }\n         }\n     }\n@@ -5945,8 +5946,7 @@ impl<'a> Resolver<'a> {\n             return \"???\".to_string();\n         }\n         self.names_to_string(names.into_iter().rev()\n-                                  .collect::<Vec<ast::Name>>()\n-                                  .as_slice())\n+                                  .collect::<Vec<ast::Name>>()[])\n     }\n \n     #[allow(dead_code)]   // useful for debugging"}, {"sha": "ec61d3a69537c73d2549be3e9c3997501804993a", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -126,7 +126,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n     let validate = |s: String, span: Option<Span>| {\n-        creader::validate_crate_name(sess, s.as_slice(), span);\n+        creader::validate_crate_name(sess, s[], span);\n         s\n     };\n \n@@ -144,7 +144,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);\n-                    sess.span_err(attr.span, msg.as_slice());\n+                    sess.span_err(attr.span, msg[]);\n                 }\n             }\n             return validate(s.clone(), None);\n@@ -190,17 +190,17 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // to be independent of one another in the crate.\n \n     symbol_hasher.reset();\n-    symbol_hasher.input_str(link_meta.crate_name.as_slice());\n+    symbol_hasher.input_str(link_meta.crate_name[]);\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(link_meta.crate_hash.as_str());\n     for meta in tcx.sess.crate_metadata.borrow().iter() {\n-        symbol_hasher.input_str(meta.as_slice());\n+        symbol_hasher.input_str(meta[]);\n     }\n     symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input_str(encoder::encoded_ty(tcx, t).as_slice());\n+    symbol_hasher.input_str(encoder::encoded_ty(tcx, t)[]);\n     // Prefix with 'h' so that it never blends into adjacent digits\n     let mut hash = String::from_str(\"h\");\n-    hash.push_str(truncated_hash_result(symbol_hasher).as_slice());\n+    hash.push_str(truncated_hash_result(symbol_hasher)[]);\n     hash\n }\n \n@@ -249,7 +249,7 @@ pub fn sanitize(s: &str) -> String {\n                 let mut tstr = String::new();\n                 for c in c.escape_unicode() { tstr.push(c) }\n                 result.push('$');\n-                result.push_str(tstr.slice_from(1));\n+                result.push_str(tstr[1..]);\n             }\n         }\n     }\n@@ -258,7 +258,7 @@ pub fn sanitize(s: &str) -> String {\n     if result.len() > 0u &&\n         result.as_bytes()[0] != '_' as u8 &&\n         ! (result.as_bytes()[0] as char).is_xid_start() {\n-        return format!(\"_{}\", result.as_slice());\n+        return format!(\"_{}\", result[]);\n     }\n \n     return result;\n@@ -284,12 +284,12 @@ pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n \n     fn push(n: &mut String, s: &str) {\n         let sani = sanitize(s);\n-        n.push_str(format!(\"{}{}\", sani.len(), sani).as_slice());\n+        n.push_str(format!(\"{}{}\", sani.len(), sani)[]);\n     }\n \n     // First, connect each component with <len, name> pairs.\n     for e in path {\n-        push(&mut n, token::get_name(e.name()).get().as_slice())\n+        push(&mut n, token::get_name(e.name()).get()[])\n     }\n \n     match hash {\n@@ -327,17 +327,17 @@ pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathEl\n     hash.push(EXTRA_CHARS.as_bytes()[extra2] as char);\n     hash.push(EXTRA_CHARS.as_bytes()[extra3] as char);\n \n-    exported_name(path, hash.as_slice())\n+    exported_name(path, hash[])\n }\n \n pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                       t: Ty<'tcx>,\n                                                       name: &str) -> String {\n     let s = ppaux::ty_to_string(ccx.tcx(), t);\n-    let path = [PathName(token::intern(s.as_slice())),\n+    let path = [PathName(token::intern(s[])),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n-    mangle(ast_map::Values(path.iter()), Some(hash.as_slice()))\n+    mangle(ast_map::Values(path.iter()), Some(hash[]))\n }\n \n pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> String {\n@@ -357,7 +357,7 @@ pub fn remove(sess: &Session, path: &Path) {\n         Err(e) => {\n             sess.err(format!(\"failed to remove {}: {}\",\n                              path.display(),\n-                             e).as_slice());\n+                             e)[]);\n         }\n     }\n }\n@@ -372,7 +372,7 @@ pub fn link_binary(sess: &Session,\n     for &crate_type in sess.crate_types.borrow().iter() {\n         if invalid_output_for_target(sess, crate_type) {\n             sess.bug(format!(\"invalid output type `{}` for target os `{}`\",\n-                             crate_type, sess.opts.target_triple).as_slice());\n+                             crate_type, sess.opts.target_triple)[]);\n         }\n         let out_file = link_binary_output(sess, trans, crate_type, outputs,\n                                           crate_name);\n@@ -437,8 +437,8 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n         }\n         config::CrateTypeDylib => {\n-            let (prefix, suffix) = (sess.target.target.options.dll_prefix.as_slice(),\n-                                    sess.target.target.options.dll_suffix.as_slice());\n+            let (prefix, suffix) = (sess.target.target.options.dll_prefix[],\n+                                    sess.target.target.options.dll_suffix[]);\n             out_filename.with_filename(format!(\"{}{}{}\",\n                                                prefix,\n                                                libname,\n@@ -448,7 +448,7 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.a\", libname))\n         }\n         config::CrateTypeExecutable => {\n-            let suffix = sess.target.target.options.exe_suffix.as_slice();\n+            let suffix = sess.target.target.options.exe_suffix[];\n             out_filename.with_filename(format!(\"{}{}\", libname, suffix))\n         }\n     }\n@@ -477,12 +477,12 @@ fn link_binary_output(sess: &Session,\n     if !out_is_writeable {\n         sess.fatal(format!(\"output file {} is not writeable -- check its \\\n                             permissions.\",\n-                           out_filename.display()).as_slice());\n+                           out_filename.display())[]);\n     }\n     else if !obj_is_writeable {\n         sess.fatal(format!(\"object file {} is not writeable -- check its \\\n                             permissions.\",\n-                           obj_filename.display()).as_slice());\n+                           obj_filename.display())[]);\n     }\n \n     match crate_type {\n@@ -507,7 +507,7 @@ fn archive_search_paths(sess: &Session) -> Vec<Path> {\n     let mut rustpath = filesearch::rust_path();\n     rustpath.push(sess.target_filesearch().get_lib_path());\n     let mut search: Vec<Path> = sess.opts.addl_lib_search_paths.borrow().clone();\n-    search.push_all(rustpath.as_slice());\n+    search.push_all(rustpath[]);\n     return search;\n }\n \n@@ -536,7 +536,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {\n             cstore::NativeStatic => {\n-                ab.add_native_library(l.as_slice()).unwrap();\n+                ab.add_native_library(l[]).unwrap();\n             }\n             cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n@@ -584,12 +584,12 @@ fn link_rlib<'a>(sess: &'a Session,\n             let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n             let metadata = tmpdir.path().join(METADATA_FILENAME);\n             match fs::File::create(&metadata).write(trans.metadata\n-                                                         .as_slice()) {\n+                                                         []) {\n                 Ok(..) => {}\n                 Err(e) => {\n                     sess.err(format!(\"failed to write {}: {}\",\n                                      metadata.display(),\n-                                     e).as_slice());\n+                                     e)[]);\n                     sess.abort_if_errors();\n                 }\n             }\n@@ -605,27 +605,27 @@ fn link_rlib<'a>(sess: &'a Session,\n                 // extension to it. This is to work around a bug in LLDB that\n                 // would cause it to crash if the name of a file in an archive\n                 // was exactly 16 bytes.\n-                let bc_filename = obj_filename.with_extension(format!(\"{}.bc\", i).as_slice());\n+                let bc_filename = obj_filename.with_extension(format!(\"{}.bc\", i)[]);\n                 let bc_deflated_filename = obj_filename.with_extension(\n-                    format!(\"{}.bytecode.deflate\", i).as_slice());\n+                    format!(\"{}.bytecode.deflate\", i)[]);\n \n                 let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n                     Ok(buffer) => buffer,\n                     Err(e) => sess.fatal(format!(\"failed to read bytecode: {}\",\n-                                                 e).as_slice())\n+                                                 e)[])\n                 };\n \n-                let bc_data_deflated = match flate::deflate_bytes(bc_data.as_slice()) {\n+                let bc_data_deflated = match flate::deflate_bytes(bc_data[]) {\n                     Some(compressed) => compressed,\n                     None => sess.fatal(format!(\"failed to compress bytecode from {}\",\n-                                               bc_filename.display()).as_slice())\n+                                               bc_filename.display())[])\n                 };\n \n                 let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n                     Ok(file) => file,\n                     Err(e) => {\n                         sess.fatal(format!(\"failed to create compressed bytecode \\\n-                                            file: {}\", e).as_slice())\n+                                            file: {}\", e)[])\n                     }\n                 };\n \n@@ -634,7 +634,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                     Ok(()) => {}\n                     Err(e) => {\n                         sess.err(format!(\"failed to write compressed bytecode: \\\n-                                          {}\", e).as_slice());\n+                                          {}\", e)[]);\n                         sess.abort_if_errors()\n                     }\n                 };\n@@ -674,7 +674,7 @@ fn write_rlib_bytecode_object_v1<T: Writer>(writer: &mut T,\n     try! { writer.write(RLIB_BYTECODE_OBJECT_MAGIC) };\n     try! { writer.write_le_u32(1) };\n     try! { writer.write_le_u64(bc_data_deflated_size) };\n-    try! { writer.write(bc_data_deflated.as_slice()) };\n+    try! { writer.write(bc_data_deflated[]) };\n \n     let number_of_bytes_written_so_far =\n         RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id\n@@ -725,11 +725,11 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n                 sess.err(format!(\"could not find rlib for: `{}`\",\n-                                 name).as_slice());\n+                                 name)[]);\n                 continue\n             }\n         };\n-        ab.add_rlib(&p, name.as_slice(), sess.lto()).unwrap();\n+        ab.add_rlib(&p, name[], sess.lto()).unwrap();\n \n         let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         all_native_libs.extend(native_libs.into_iter());\n@@ -751,7 +751,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n             cstore::NativeUnknown => \"library\",\n             cstore::NativeFramework => \"framework\",\n         };\n-        sess.note(format!(\"{}: {}\", name, *lib).as_slice());\n+        sess.note(format!(\"{}: {}\", name, *lib)[]);\n     }\n }\n \n@@ -765,12 +765,12 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n \n     // The invocations of cc share some flags across platforms\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(pname.as_slice());\n+    let mut cmd = Command::new(pname[]);\n \n-    cmd.args(sess.target.target.options.pre_link_args.as_slice());\n+    cmd.args(sess.target.target.options.pre_link_args[]);\n     link_args(&mut cmd, sess, dylib, tmpdir.path(),\n               trans, obj_filename, out_filename);\n-    cmd.args(sess.target.target.options.post_link_args.as_slice());\n+    cmd.args(sess.target.target.options.post_link_args[]);\n     if !sess.target.target.options.no_compiler_rt {\n         cmd.arg(\"-lcompiler-rt\");\n     }\n@@ -790,11 +790,11 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n             if !prog.status.success() {\n                 sess.err(format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status).as_slice());\n-                sess.note(format!(\"{}\", &cmd).as_slice());\n+                                 prog.status)[]);\n+                sess.note(format!(\"{}\", &cmd)[]);\n                 let mut output = prog.error.clone();\n-                output.push_all(prog.output.as_slice());\n-                sess.note(str::from_utf8(output.as_slice()).unwrap());\n+                output.push_all(prog.output[]);\n+                sess.note(str::from_utf8(output[]).unwrap());\n                 sess.abort_if_errors();\n             }\n             debug!(\"linker stderr:\\n{}\", String::from_utf8(prog.error).unwrap());\n@@ -803,7 +803,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         Err(e) => {\n             sess.err(format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e).as_slice());\n+                             e)[]);\n             sess.abort_if_errors();\n         }\n     }\n@@ -815,7 +815,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         match Command::new(\"dsymutil\").arg(out_filename).output() {\n             Ok(..) => {}\n             Err(e) => {\n-                sess.err(format!(\"failed to run dsymutil: {}\", e).as_slice());\n+                sess.err(format!(\"failed to run dsymutil: {}\", e)[]);\n                 sess.abort_if_errors();\n             }\n         }\n@@ -864,7 +864,7 @@ fn link_args(cmd: &mut Command,\n \n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(morestack.as_vec());\n-            cmd.arg(v.as_slice());\n+            cmd.arg(v[]);\n         } else {\n             cmd.args(&[\"-Wl,--whole-archive\", \"-lmorestack\", \"-Wl,--no-whole-archive\"]);\n         }\n@@ -989,7 +989,7 @@ fn link_args(cmd: &mut Command,\n             if sess.opts.cg.rpath {\n                 let mut v = \"-Wl,-install_name,@rpath/\".as_bytes().to_vec();\n                 v.push_all(out_filename.filename().unwrap());\n-                cmd.arg(v.as_slice());\n+                cmd.arg(v[]);\n             }\n         } else {\n             cmd.arg(\"-shared\");\n@@ -1001,7 +1001,7 @@ fn link_args(cmd: &mut Command,\n     // addl_lib_search_paths\n     if sess.opts.cg.rpath {\n         let sysroot = sess.sysroot();\n-        let target_triple = sess.opts.target_triple.as_slice();\n+        let target_triple = sess.opts.target_triple[];\n         let get_install_prefix_lib_path = |:| {\n             let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n             let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n@@ -1018,14 +1018,14 @@ fn link_args(cmd: &mut Command,\n             get_install_prefix_lib_path: get_install_prefix_lib_path,\n             realpath: ::util::fs::realpath\n         };\n-        cmd.args(rpath::get_rpath_flags(rpath_config).as_slice());\n+        cmd.args(rpath::get_rpath_flags(rpath_config)[]);\n     }\n \n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n     let empty = Vec::new();\n-    cmd.args(sess.opts.cg.link_args.as_ref().unwrap_or(&empty).as_slice());\n-    cmd.args(used_link_args.as_slice());\n+    cmd.args(sess.opts.cg.link_args.as_ref().unwrap_or(&empty)[]);\n+    cmd.args(used_link_args[]);\n }\n \n // # Native library linking\n@@ -1083,14 +1083,14 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n         } else {\n             // -force_load is the OSX equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n-            let lib = archive::find_library(l.as_slice(),\n-                                            sess.target.target.options.staticlib_prefix.as_slice(),\n-                                            sess.target.target.options.staticlib_suffix.as_slice(),\n-                                            search_path.as_slice(),\n+            let lib = archive::find_library(l[],\n+                                            sess.target.target.options.staticlib_prefix[],\n+                                            sess.target.target.options.staticlib_suffix[],\n+                                            search_path[],\n                                             &sess.diagnostic().handler);\n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(lib.as_vec());\n-            cmd.arg(v.as_slice());\n+            cmd.arg(v[]);\n         }\n     }\n     if takes_hints {\n@@ -1103,7 +1103,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n                 cmd.arg(format!(\"-l{}\", l));\n             }\n             cstore::NativeFramework => {\n-                cmd.arg(\"-framework\").arg(l.as_slice());\n+                cmd.arg(\"-framework\").arg(l[]);\n             }\n             cstore::NativeStatic => unreachable!(),\n         }\n@@ -1184,9 +1184,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // against the archive.\n         if sess.lto() {\n             let name = cratepath.filename_str().unwrap();\n-            let name = name.slice(3, name.len() - 5); // chop off lib/.rlib\n+            let name = name[3..name.len() - 5]; // chop off lib/.rlib\n             time(sess.time_passes(),\n-                 format!(\"altering {}.rlib\", name).as_slice(),\n+                 format!(\"altering {}.rlib\", name)[],\n                  (), |()| {\n                 let dst = tmpdir.join(cratepath.filename().unwrap());\n                 match fs::copy(&cratepath, &dst) {\n@@ -1195,7 +1195,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                         sess.err(format!(\"failed to copy {} to {}: {}\",\n                                          cratepath.display(),\n                                          dst.display(),\n-                                         e).as_slice());\n+                                         e)[]);\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1207,7 +1207,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     Err(e) => {\n                         sess.err(format!(\"failed to chmod {} when preparing \\\n                                           for LTO: {}\", dst.display(),\n-                                         e).as_slice());\n+                                         e)[]);\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1221,9 +1221,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     maybe_ar_prog: sess.opts.cg.ar.clone()\n                 };\n                 let mut archive = Archive::open(config);\n-                archive.remove_file(format!(\"{}.o\", name).as_slice());\n+                archive.remove_file(format!(\"{}.o\", name)[]);\n                 let files = archive.files();\n-                if files.iter().any(|s| s.as_slice().ends_with(\".o\")) {\n+                if files.iter().any(|s| s[].ends_with(\".o\")) {\n                     cmd.arg(dst);\n                 }\n             });\n@@ -1245,7 +1245,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n \n         let mut v = \"-l\".as_bytes().to_vec();\n         v.push_all(unlib(&sess.target, cratepath.filestem().unwrap()));\n-        cmd.arg(v.as_slice());\n+        cmd.arg(v[]);\n     }\n }\n \n@@ -1287,7 +1287,7 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n                 }\n                 cstore::NativeFramework => {\n                     cmd.arg(\"-framework\");\n-                    cmd.arg(lib.as_slice());\n+                    cmd.arg(lib[]);\n                 }\n                 cstore::NativeStatic => {\n                     sess.bug(\"statics shouldn't be propagated\");"}, {"sha": "1271330897e737fa5171e8334ae6dafbc0c3203d", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -53,29 +53,29 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             Some(p) => p,\n             None => {\n                 sess.fatal(format!(\"could not find rlib for: `{}`\",\n-                                   name).as_slice());\n+                                   name)[]);\n             }\n         };\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let file = path.filename_str().unwrap();\n-        let file = file.slice(3, file.len() - 5); // chop off lib/.rlib\n+        let file = file[3..file.len() - 5]; // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n         for i in iter::count(0u, 1) {\n             let bc_encoded = time(sess.time_passes(),\n-                                  format!(\"check for {}.{}.bytecode.deflate\", name, i).as_slice(),\n+                                  format!(\"check for {}.{}.bytecode.deflate\", name, i)[],\n                                   (),\n                                   |_| {\n                                       archive.read(format!(\"{}.{}.bytecode.deflate\",\n-                                                           file, i).as_slice())\n+                                                           file, i)[])\n                                   });\n             let bc_encoded = match bc_encoded {\n                 Some(data) => data,\n                 None => {\n                     if i == 0 {\n                         // No bitcode was found at all.\n                         sess.fatal(format!(\"missing compressed bytecode in {}\",\n-                                           path.display()).as_slice());\n+                                           path.display())[]);\n                     }\n                     // No more bitcode files to read.\n                     break;\n@@ -98,12 +98,12 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                             Some(inflated) => inflated,\n                             None => {\n                                 sess.fatal(format!(\"failed to decompress bc of `{}`\",\n-                                                   name).as_slice())\n+                                                   name)[])\n                             }\n                         }\n                     } else {\n                         sess.fatal(format!(\"Unsupported bytecode format version {}\",\n-                                           version).as_slice())\n+                                           version)[])\n                     }\n                 })\n             } else {\n@@ -114,7 +114,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                         Some(bc) => bc,\n                         None => {\n                             sess.fatal(format!(\"failed to decompress bc of `{}`\",\n-                                               name).as_slice())\n+                                               name)[])\n                         }\n                     }\n                 })\n@@ -123,15 +123,15 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             let ptr = bc_decoded.as_slice().as_ptr();\n             debug!(\"linking {}, part {}\", name, i);\n             time(sess.time_passes(),\n-                 format!(\"ll link {}.{}\", name, i).as_slice(),\n+                 format!(\"ll link {}.{}\", name, i)[],\n                  (),\n                  |()| unsafe {\n                 if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                         ptr as *const libc::c_char,\n                                                         bc_decoded.len() as libc::size_t) {\n                     write::llvm_err(sess.diagnostic().handler(),\n                                     format!(\"failed to load bc of `{}`\",\n-                                            name.as_slice()));\n+                                            name[]));\n                 }\n             });\n         }"}, {"sha": "5be66d4292097dc62556aa8df0244a9ef5d51bad", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -46,13 +46,13 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n-            handler.fatal(msg.as_slice());\n+            handler.fatal(msg[]);\n         } else {\n             let err = CString::new(cstr, true);\n             let err = String::from_utf8_lossy(err.as_bytes());\n             handler.fatal(format!(\"{}: {}\",\n-                                  msg.as_slice(),\n-                                  err.as_slice()).as_slice());\n+                                  msg[],\n+                                  err[])[]);\n         }\n     }\n }\n@@ -103,13 +103,13 @@ impl SharedEmitter {\n             match diag.code {\n                 Some(ref code) => {\n                     handler.emit_with_code(None,\n-                                           diag.msg.as_slice(),\n-                                           code.as_slice(),\n+                                           diag.msg[],\n+                                           code[],\n                                            diag.lvl);\n                 },\n                 None => {\n                     handler.emit(None,\n-                                 diag.msg.as_slice(),\n+                                 diag.msg[],\n                                  diag.lvl);\n                 },\n             }\n@@ -164,8 +164,8 @@ fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n \n fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let reloc_model_arg = match sess.opts.cg.relocation_model {\n-        Some(ref s) => s.as_slice(),\n-        None => sess.target.target.options.relocation_model.as_slice()\n+        Some(ref s) => s[],\n+        None => sess.target.target.options.relocation_model[]\n     };\n     let reloc_model = match reloc_model_arg {\n         \"pic\" => llvm::RelocPIC,\n@@ -176,7 +176,7 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n             sess.err(format!(\"{} is not a valid relocation mode\",\n                              sess.opts\n                                  .cg\n-                                 .relocation_model).as_slice());\n+                                 .relocation_model)[]);\n             sess.abort_if_errors();\n             unreachable!();\n         }\n@@ -197,8 +197,8 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let fdata_sections = ffunction_sections;\n \n     let code_model_arg = match sess.opts.cg.code_model {\n-        Some(ref s) => s.as_slice(),\n-        None => sess.target.target.options.code_model.as_slice()\n+        Some(ref s) => s[],\n+        None => sess.target.target.options.code_model[]\n     };\n \n     let code_model = match code_model_arg {\n@@ -211,19 +211,19 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n             sess.err(format!(\"{} is not a valid code model\",\n                              sess.opts\n                                  .cg\n-                                 .code_model).as_slice());\n+                                 .code_model)[]);\n             sess.abort_if_errors();\n             unreachable!();\n         }\n     };\n \n-    let triple = sess.target.target.llvm_target.as_slice();\n+    let triple = sess.target.target.llvm_target[];\n \n     let tm = unsafe {\n         triple.with_c_str(|t| {\n             let cpu = match sess.opts.cg.target_cpu {\n-                Some(ref s) => s.as_slice(),\n-                None => sess.target.target.options.cpu.as_slice()\n+                Some(ref s) => s[],\n+                None => sess.target.target.options.cpu[]\n             };\n             cpu.with_c_str(|cpu| {\n                 target_feature(sess).with_c_str(|features| {\n@@ -350,13 +350,13 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n     match cgcx.lto_ctxt {\n         Some((sess, _)) => {\n             sess.codemap().with_expn_info(ExpnId::from_llvm_cookie(cookie), |info| match info {\n-                Some(ei) => sess.span_err(ei.call_site, msg.as_slice()),\n-                None     => sess.err(msg.as_slice()),\n+                Some(ei) => sess.span_err(ei.call_site, msg[]),\n+                None     => sess.err(msg[]),\n             });\n         }\n \n         None => {\n-            cgcx.handler.err(msg.as_slice());\n+            cgcx.handler.err(msg[]);\n             cgcx.handler.note(\"build without -C codegen-units for more exact errors\");\n         }\n     }\n@@ -380,8 +380,8 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n                 cgcx.handler.note(format!(\"optimization {} for {} at {}: {}\",\n                                           opt.kind.describe(),\n                                           pass_name,\n-                                          if loc.is_empty() { \"[unknown]\" } else { loc.as_slice() },\n-                                          llvm::twine_to_string(opt.message)).as_slice());\n+                                          if loc.is_empty() { \"[unknown]\" } else { loc[] },\n+                                          llvm::twine_to_string(opt.message))[]);\n             }\n         }\n \n@@ -413,7 +413,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n     if config.emit_no_opt_bc {\n         let ext = format!(\"{}.no-opt.bc\", name_extra);\n-        output_names.with_extension(ext.as_slice()).with_c_str(|buf| {\n+        output_names.with_extension(ext[]).with_c_str(|buf| {\n             llvm::LLVMWriteBitcodeToFile(llmod, buf);\n         })\n     }\n@@ -445,7 +445,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                 pass.with_c_str(|s| {\n                     if !llvm::LLVMRustAddPass(mpm, s) {\n                         cgcx.handler.warn(format!(\"unknown pass {}, ignoring\",\n-                                                  *pass).as_slice());\n+                                                  *pass)[]);\n                     }\n                 })\n             }\n@@ -467,7 +467,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n                     if config.emit_lto_bc {\n                         let name = format!(\"{}.lto.bc\", name_extra);\n-                        output_names.with_extension(name.as_slice()).with_c_str(|buf| {\n+                        output_names.with_extension(name[]).with_c_str(|buf| {\n                             llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                         })\n                     }\n@@ -501,30 +501,30 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n     if config.emit_bc {\n         let ext = format!(\"{}.bc\", name_extra);\n-        output_names.with_extension(ext.as_slice()).with_c_str(|buf| {\n+        output_names.with_extension(ext[]).with_c_str(|buf| {\n             llvm::LLVMWriteBitcodeToFile(llmod, buf);\n         })\n     }\n \n     time(config.time_passes, \"codegen passes\", (), |()| {\n         if config.emit_ir {\n             let ext = format!(\"{}.ll\", name_extra);\n-            output_names.with_extension(ext.as_slice()).with_c_str(|output| {\n+            output_names.with_extension(ext[]).with_c_str(|output| {\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     llvm::LLVMRustPrintModule(cpm, llmod, output);\n                 })\n             })\n         }\n \n         if config.emit_asm {\n-            let path = output_names.with_extension(format!(\"{}.s\", name_extra).as_slice());\n+            let path = output_names.with_extension(format!(\"{}.s\", name_extra)[]);\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::AssemblyFileType);\n             });\n         }\n \n         if config.emit_obj {\n-            let path = output_names.with_extension(format!(\"{}.o\", name_extra).as_slice());\n+            let path = output_names.with_extension(format!(\"{}.o\", name_extra)[]);\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::ObjectFileType);\n             });\n@@ -638,7 +638,7 @@ pub fn run_passes(sess: &Session,\n \n     // Process the work items, optionally using worker threads.\n     if sess.opts.cg.codegen_units == 1 {\n-        run_work_singlethreaded(sess, trans.reachable.as_slice(), work_items);\n+        run_work_singlethreaded(sess, trans.reachable[], work_items);\n     } else {\n         run_work_multithreaded(sess, work_items, sess.opts.cg.codegen_units);\n     }\n@@ -666,7 +666,7 @@ pub fn run_passes(sess: &Session,\n                 // 2) Multiple codegen units, with `-o some_name`.  We have\n                 //    no good solution for this case, so warn the user.\n                 sess.warn(format!(\"ignoring -o because multiple .{} files were produced\",\n-                                  ext).as_slice());\n+                                  ext)[]);\n             } else {\n                 // 3) Multiple codegen units, but no `-o some_name`.  We\n                 //    just leave the `foo.0.x` files in place.\n@@ -699,20 +699,20 @@ pub fn run_passes(sess: &Session,\n             };\n \n         let pname = get_cc_prog(sess);\n-        let mut cmd = Command::new(pname.as_slice());\n+        let mut cmd = Command::new(pname[]);\n \n-        cmd.args(sess.target.target.options.pre_link_args.as_slice());\n+        cmd.args(sess.target.target.options.pre_link_args[]);\n         cmd.arg(\"-nostdlib\");\n \n         for index in range(0, trans.modules.len()) {\n-            cmd.arg(crate_output.with_extension(format!(\"{}.o\", index).as_slice()));\n+            cmd.arg(crate_output.with_extension(format!(\"{}.o\", index)[]));\n         }\n \n         cmd.arg(\"-r\")\n            .arg(\"-o\")\n            .arg(windows_output_path.as_ref().unwrap_or(output_path));\n \n-        cmd.args(sess.target.target.options.post_link_args.as_slice());\n+        cmd.args(sess.target.target.options.post_link_args[]);\n \n         if (sess.opts.debugging_opts & config::PRINT_LINK_ARGS) != 0 {\n             println!(\"{}\", &cmd);\n@@ -725,14 +725,14 @@ pub fn run_passes(sess: &Session,\n             Ok(status) => {\n                 if !status.success() {\n                     sess.err(format!(\"linking of {} with `{}` failed\",\n-                                     output_path.display(), cmd).as_slice());\n+                                     output_path.display(), cmd)[]);\n                     sess.abort_if_errors();\n                 }\n             },\n             Err(e) => {\n                 sess.err(format!(\"could not exec the linker `{}`: {}\",\n                                  pname,\n-                                 e).as_slice());\n+                                 e)[]);\n                 sess.abort_if_errors();\n             },\n         }\n@@ -817,12 +817,12 @@ pub fn run_passes(sess: &Session,\n         for i in range(0, trans.modules.len()) {\n             if modules_config.emit_obj {\n                 let ext = format!(\"{}.o\", i);\n-                remove(sess, &crate_output.with_extension(ext.as_slice()));\n+                remove(sess, &crate_output.with_extension(ext[]));\n             }\n \n             if modules_config.emit_bc && !keep_numbered_bitcode {\n                 let ext = format!(\"{}.bc\", i);\n-                remove(sess, &crate_output.with_extension(ext.as_slice()));\n+                remove(sess, &crate_output.with_extension(ext[]));\n             }\n         }\n \n@@ -948,7 +948,7 @@ fn run_work_multithreaded(sess: &Session,\n \n pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(pname.as_slice());\n+    let mut cmd = Command::new(pname[]);\n \n     cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(config::OutputTypeObject))\n                            .arg(outputs.temp_path(config::OutputTypeAssembly));\n@@ -959,18 +959,18 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n             if !prog.status.success() {\n                 sess.err(format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status).as_slice());\n-                sess.note(format!(\"{}\", &cmd).as_slice());\n+                                 prog.status)[]);\n+                sess.note(format!(\"{}\", &cmd)[]);\n                 let mut note = prog.error.clone();\n-                note.push_all(prog.output.as_slice());\n-                sess.note(str::from_utf8(note.as_slice()).unwrap());\n+                note.push_all(prog.output[]);\n+                sess.note(str::from_utf8(note[]).unwrap());\n                 sess.abort_if_errors();\n             }\n         },\n         Err(e) => {\n             sess.err(format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e).as_slice());\n+                             e)[]);\n             sess.abort_if_errors();\n         }\n     }\n@@ -1003,7 +1003,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n \n         for arg in sess.opts.cg.llvm_args.iter() {\n-            add((*arg).as_slice());\n+            add((*arg)[]);\n         }\n     }\n "}, {"sha": "0183aa8c2aabb16b3abb6ee61faf9fbe51e6c64c", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -94,7 +94,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         // dump info about all the external crates referenced from this crate\n         self.sess.cstore.iter_crate_data(|n, cmd| {\n-            self.fmt.external_crate_str(krate.span, cmd.name.as_slice(), n);\n+            self.fmt.external_crate_str(krate.span, cmd.name[], n);\n         });\n         self.fmt.recorder.record(\"end_external_crates\\n\");\n     }\n@@ -143,7 +143,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname.as_slice(),\n+                                     qualname[],\n                                      self.cur_scope);\n         }\n     }\n@@ -161,7 +161,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname.as_slice(),\n+                                     qualname[],\n                                      self.cur_scope);\n         }\n     }\n@@ -180,7 +180,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let (ref span, ref qualname) = sub_paths[len-2];\n         self.fmt.sub_type_ref_str(path.span,\n                                   *span,\n-                                  qualname.as_slice());\n+                                  qualname[]);\n \n         // write the other sub-paths\n         if len <= 2 {\n@@ -190,7 +190,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname.as_slice(),\n+                                     qualname[],\n                                      self.cur_scope);\n         }\n     }\n@@ -199,7 +199,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n         if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n             self.sess.bug(format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                  ref_id).as_slice());\n+                                  ref_id)[]);\n         }\n         let def = (*self.analysis.ty_cx.def_map.borrow())[ref_id];\n         match def {\n@@ -212,7 +212,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let def_map = self.analysis.ty_cx.def_map.borrow();\n         if !def_map.contains_key(&ref_id) {\n             self.sess.span_bug(span, format!(\"def_map has no key for {} in lookup_def_kind\",\n-                                             ref_id).as_slice());\n+                                             ref_id)[]);\n         }\n         let def = (*def_map)[ref_id];\n         match def {\n@@ -241,7 +241,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefMethod(..) |\n             def::DefPrimTy(_) => {\n                 self.sess.span_bug(span, format!(\"lookup_def_kind for unexpected item: {}\",\n-                                                 def).as_slice());\n+                                                 def)[]);\n             },\n         }\n     }\n@@ -262,8 +262,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                     span_utils.span_for_last_ident(p.span),\n                                     id,\n                                     qualname,\n-                                    path_to_string(p).as_slice(),\n-                                    typ.as_slice());\n+                                    path_to_string(p)[],\n+                                    typ[]);\n             }\n             self.collected_paths.clear();\n         }\n@@ -285,14 +285,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     match item.node {\n                         ast::ItemImpl(_, _, _, ref ty, _) => {\n                             let mut result = String::from_str(\"<\");\n-                            result.push_str(ty_to_string(&**ty).as_slice());\n+                            result.push_str(ty_to_string(&**ty)[]);\n \n                             match ty::trait_of_item(&self.analysis.ty_cx,\n                                                     ast_util::local_def(method.id)) {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n-                                        ty::item_path_str(&self.analysis.ty_cx, def_id).as_slice());\n+                                        ty::item_path_str(&self.analysis.ty_cx, def_id)[]);\n                                 },\n                                 None => {}\n                             }\n@@ -302,7 +302,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         _ => {\n                             self.sess.span_bug(method.span,\n                                                format!(\"Container {} for method {} not an impl?\",\n-                                                       impl_id.node, method.id).as_slice());\n+                                                       impl_id.node, method.id)[]);\n                         },\n                     }\n                 },\n@@ -312,7 +312,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                impl_id.node,\n                                                method.id,\n                                                self.analysis.ty_cx.map.get(impl_id.node)\n-                                              ).as_slice());\n+                                              )[]);\n                 },\n             },\n             None => match ty::trait_of_item(&self.analysis.ty_cx,\n@@ -328,20 +328,20 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         _ => {\n                             self.sess.span_bug(method.span,\n                                                format!(\"Could not find container {} for method {}\",\n-                                                       def_id.node, method.id).as_slice());\n+                                                       def_id.node, method.id)[]);\n                         }\n                     }\n                 },\n                 None => {\n                     self.sess.span_bug(method.span,\n                                        format!(\"Could not find container for method {}\",\n-                                               method.id).as_slice());\n+                                               method.id)[]);\n                 },\n             },\n         };\n \n         qualname.push_str(get_ident(method.pe_ident()).get());\n-        let qualname = qualname.as_slice();\n+        let qualname = qualname[];\n \n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n@@ -430,13 +430,13 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n                                                          field.node.id,\n-                                                         name.get().as_slice(),\n-                                                         qualname.as_slice(),\n-                                                         typ.as_slice(),\n+                                                         name.get()[],\n+                                                         qualname[],\n+                                                         typ[],\n                                                          scope_id),\n                     None => self.sess.span_bug(field.span,\n                                                format!(\"Could not find sub-span for field {}\",\n-                                                       qualname).as_slice()),\n+                                                       qualname)[]),\n                 }\n             },\n             _ => (),\n@@ -463,7 +463,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.fmt.typedef_str(full_span,\n                                  Some(*param_ss),\n                                  param.id,\n-                                 name.as_slice(),\n+                                 name[],\n                                  \"\");\n         }\n         self.visit_generics(generics);\n@@ -480,10 +480,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.fn_str(item.span,\n                         sub_span,\n                         item.id,\n-                        qualname.as_slice(),\n+                        qualname[],\n                         self.cur_scope);\n \n-        self.process_formals(&decl.inputs, qualname.as_slice());\n+        self.process_formals(&decl.inputs, qualname[]);\n \n         // walk arg and return types\n         for arg in decl.inputs.iter() {\n@@ -497,7 +497,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // walk the body\n         self.nest(item.id, |v| v.visit_block(&*body));\n \n-        self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n+        self.process_generic_params(ty_params, item.span, qualname[], item.id);\n     }\n \n     fn process_static(&mut self,\n@@ -519,9 +519,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             get_ident(item.ident).get(),\n-                            qualname.as_slice(),\n-                            value.as_slice(),\n-                            ty_to_string(&*typ).as_slice(),\n+                            qualname[],\n+                            value[],\n+                            ty_to_string(&*typ)[],\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -542,9 +542,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             get_ident(item.ident).get(),\n-                            qualname.as_slice(),\n+                            qualname[],\n                             \"\",\n-                            ty_to_string(&*typ).as_slice(),\n+                            ty_to_string(&*typ)[],\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -568,17 +568,17 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             ctor_id,\n-                            qualname.as_slice(),\n+                            qualname[],\n                             self.cur_scope,\n-                            val.as_slice());\n+                            val[]);\n \n         // fields\n         for field in def.fields.iter() {\n-            self.process_struct_field_def(field, qualname.as_slice(), item.id);\n+            self.process_struct_field_def(field, qualname[], item.id);\n             self.visit_ty(&*field.node.ty);\n         }\n \n-        self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n+        self.process_generic_params(ty_params, item.span, qualname[], item.id);\n     }\n \n     fn process_enum(&mut self,\n@@ -591,12 +591,12 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             Some(sub_span) => self.fmt.enum_str(item.span,\n                                                 Some(sub_span),\n                                                 item.id,\n-                                                enum_name.as_slice(),\n+                                                enum_name[],\n                                                 self.cur_scope,\n-                                                val.as_slice()),\n+                                                val[]),\n             None => self.sess.span_bug(item.span,\n                                        format!(\"Could not find subspan for enum {}\",\n-                                               enum_name).as_slice()),\n+                                               enum_name)[]),\n         }\n         for variant in enum_definition.variants.iter() {\n             let name = get_ident(variant.node.name);\n@@ -612,9 +612,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                self.span.span_for_first_ident(variant.span),\n                                                variant.node.id,\n                                                name,\n-                                               qualname.as_slice(),\n-                                               enum_name.as_slice(),\n-                                               val.as_slice(),\n+                                               qualname[],\n+                                               enum_name[],\n+                                               val[],\n                                                item.id);\n                     for arg in args.iter() {\n                         self.visit_ty(&*arg.ty);\n@@ -630,20 +630,20 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         self.span.span_for_first_ident(variant.span),\n                         variant.node.id,\n                         ctor_id,\n-                        qualname.as_slice(),\n-                        enum_name.as_slice(),\n-                        val.as_slice(),\n+                        qualname[],\n+                        enum_name[],\n+                        val[],\n                         item.id);\n \n                     for field in struct_def.fields.iter() {\n-                        self.process_struct_field_def(field, enum_name.as_slice(), variant.node.id);\n+                        self.process_struct_field_def(field, enum_name[], variant.node.id);\n                         self.visit_ty(&*field.node.ty);\n                     }\n                 }\n             }\n         }\n \n-        self.process_generic_params(ty_params, item.span, enum_name.as_slice(), item.id);\n+        self.process_generic_params(ty_params, item.span, enum_name[], item.id);\n     }\n \n     fn process_impl(&mut self,\n@@ -703,9 +703,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.trait_str(item.span,\n                            sub_span,\n                            item.id,\n-                           qualname.as_slice(),\n+                           qualname[],\n                            self.cur_scope,\n-                           val.as_slice());\n+                           val[]);\n \n         // super-traits\n         for super_bound in trait_refs.iter() {\n@@ -737,7 +737,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n \n         // walk generics and methods\n-        self.process_generic_params(generics, item.span, qualname.as_slice(), item.id);\n+        self.process_generic_params(generics, item.span, qualname[], item.id);\n         for method in methods.iter() {\n             self.visit_trait_item(method)\n         }\n@@ -755,9 +755,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.mod_str(item.span,\n                          sub_span,\n                          item.id,\n-                         qualname.as_slice(),\n+                         qualname[],\n                          self.cur_scope,\n-                         filename.as_slice());\n+                         filename[]);\n \n         self.nest(item.id, |v| visit::walk_mod(v, m));\n     }\n@@ -773,7 +773,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         if !def_map.contains_key(&ex.id) {\n             self.sess.span_bug(ex.span,\n                                format!(\"def_map has no key for {} in visit_expr\",\n-                                       ex.id).as_slice());\n+                                       ex.id)[]);\n         }\n         let def = &(*def_map)[ex.id];\n         let sub_span = self.span.span_for_last_ident(ex.span);\n@@ -840,7 +840,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                              self.cur_scope),\n             _ => self.sess.span_bug(ex.span,\n                                     format!(\"Unexpected def kind while looking up path in '{}'\",\n-                                            self.span.snippet(ex.span)).as_slice()),\n+                                            self.span.snippet(ex.span))[]),\n         }\n         // modules or types in the path prefix\n         match *def {\n@@ -961,7 +961,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                self.cur_scope);\n \n         // walk receiver and args\n-        visit::walk_exprs(self, args.as_slice());\n+        visit::walk_exprs(self, args[]);\n     }\n \n     fn process_pat(&mut self, p:&ast::Pat) {\n@@ -978,7 +978,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     None => {\n                         self.sess.span_bug(p.span,\n                                            format!(\"Could not find struct_def for `{}`\",\n-                                                   self.span.snippet(p.span)).as_slice());\n+                                                   self.span.snippet(p.span))[]);\n                     }\n                 };\n                 for &Spanned { node: ref field, span } in fields.iter() {\n@@ -1062,11 +1062,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.fmt.typedef_str(item.span,\n                                      sub_span,\n                                      item.id,\n-                                     qualname.as_slice(),\n-                                     value.as_slice());\n+                                     qualname[],\n+                                     value[]);\n \n                 self.visit_ty(&**ty);\n-                self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n+                self.process_generic_params(ty_params, item.span, qualname[], item.id);\n             },\n             ast::ItemMac(_) => (),\n             _ => visit::walk_item(self, item),\n@@ -1123,12 +1123,12 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     None => {\n                         self.sess.span_bug(method_type.span,\n                                            format!(\"Could not find trait for method {}\",\n-                                                   method_type.id).as_slice());\n+                                                   method_type.id)[]);\n                     },\n                 };\n \n                 qualname.push_str(get_ident(method_type.ident).get());\n-                let qualname = qualname.as_slice();\n+                let qualname = qualname[];\n \n                 let sub_span = self.span.sub_span_after_keyword(method_type.span, keywords::Fn);\n                 self.fmt.method_decl_str(method_type.span,\n@@ -1243,7 +1243,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                           id,\n                                           cnum,\n                                           name,\n-                                          s.as_slice(),\n+                                          s[],\n                                           self.cur_scope);\n             },\n         }\n@@ -1349,8 +1349,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 }\n \n                 let mut id = String::from_str(\"$\");\n-                id.push_str(ex.id.to_string().as_slice());\n-                self.process_formals(&decl.inputs, id.as_slice());\n+                id.push_str(ex.id.to_string()[]);\n+                self.process_formals(&decl.inputs, id[]);\n \n                 // walk arg and return types\n                 for arg in decl.inputs.iter() {\n@@ -1393,7 +1393,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         // process collected paths\n         for &(id, ref p, ref immut, ref_kind) in self.collected_paths.iter() {\n             let value = if *immut {\n-                self.span.snippet(p.span).into_string()\n+                self.span.snippet(p.span).to_string()\n             } else {\n                 \"<mutable>\".to_string()\n             };\n@@ -1402,15 +1402,15 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n                                    format!(\"def_map has no key for {} in visit_arm\",\n-                                           id).as_slice());\n+                                           id)[]);\n             }\n             let def = &(*def_map)[id];\n             match *def {\n                 def::DefLocal(id)  => self.fmt.variable_str(p.span,\n                                                             sub_span,\n                                                             id,\n-                                                            path_to_string(p).as_slice(),\n-                                                            value.as_slice(),\n+                                                            path_to_string(p)[],\n+                                                            value[],\n                                                             \"\"),\n                 def::DefVariant(_,id,_) => self.fmt.ref_str(ref_kind,\n                                                             p.span,\n@@ -1462,9 +1462,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             self.fmt.variable_str(p.span,\n                                   sub_span,\n                                   id,\n-                                  path_to_string(p).as_slice(),\n-                                  value.as_slice(),\n-                                  typ.as_slice());\n+                                  path_to_string(p)[],\n+                                  value[],\n+                                  typ[]);\n         }\n         self.collected_paths.clear();\n \n@@ -1482,7 +1482,7 @@ pub fn process_crate(sess: &Session,\n         return;\n     }\n \n-    let cratename = match attr::find_crate_name(krate.attrs.as_slice()) {\n+    let cratename = match attr::find_crate_name(krate.attrs[]) {\n         Some(name) => name.get().to_string(),\n         None => {\n             info!(\"Could not find crate name, using 'unknown_crate'\");\n@@ -1503,7 +1503,7 @@ pub fn process_crate(sess: &Session,\n \n     match fs::mkdir_recursive(&root_path, io::USER_RWX) {\n         Err(e) => sess.err(format!(\"Could not create directory {}: {}\",\n-                           root_path.display(), e).as_slice()),\n+                           root_path.display(), e)[]),\n         _ => (),\n     }\n \n@@ -1520,7 +1520,7 @@ pub fn process_crate(sess: &Session,\n         Ok(f) => box f,\n         Err(e) => {\n             let disp = root_path.display();\n-            sess.fatal(format!(\"Could not open {}: {}\", disp, e).as_slice());\n+            sess.fatal(format!(\"Could not open {}: {}\", disp, e)[]);\n         }\n     };\n     root_path.pop();\n@@ -1546,7 +1546,7 @@ pub fn process_crate(sess: &Session,\n         cur_scope: 0\n     };\n \n-    visitor.dump_crate_info(cratename.as_slice(), krate);\n+    visitor.dump_crate_info(cratename[], krate);\n \n     visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "08670864ade9386dfb3e8b9a9d9f80124b9112f9", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -41,7 +41,7 @@ impl Recorder {\n         assert!(self.dump_spans);\n         let result = format!(\"span,kind,{},{},text,\\\"{}\\\"\\n\",\n                              kind, su.extent_str(span), escape(su.snippet(span)));\n-        self.record(result.as_slice());\n+        self.record(result[]);\n     }\n }\n \n@@ -158,15 +158,15 @@ impl<'a> FmtStrs<'a> {\n         if values.len() != fields.len() {\n             self.span.sess.span_bug(span, format!(\n                 \"Mismatch between length of fields for '{}', expected '{}', found '{}'\",\n-                kind, fields.len(), values.len()).as_slice());\n+                kind, fields.len(), values.len())[]);\n         }\n \n         let values = values.iter().map(|s| {\n             // Never take more than 1020 chars\n             if s.len() > 1020 {\n-                s.slice_to(1020)\n+                s[..1020]\n             } else {\n-                s.as_slice()\n+                s[]\n             }\n         });\n \n@@ -182,7 +182,7 @@ impl<'a> FmtStrs<'a> {\n             }\n         )));\n         Some(strs.fold(String::new(), |mut s, ss| {\n-            s.push_str(ss.as_slice());\n+            s.push_str(ss[]);\n             s\n         }))\n     }\n@@ -196,7 +196,7 @@ impl<'a> FmtStrs<'a> {\n         if needs_span {\n             self.span.sess.span_bug(span, format!(\n                 \"Called record_without_span for '{}' which does requires a span\",\n-                label).as_slice());\n+                label)[]);\n         }\n         assert!(!dump_spans);\n \n@@ -210,9 +210,9 @@ impl<'a> FmtStrs<'a> {\n         };\n \n         let mut result = String::from_str(label);\n-        result.push_str(values_str.as_slice());\n+        result.push_str(values_str[]);\n         result.push_str(\"\\n\");\n-        self.recorder.record(result.as_slice());\n+        self.recorder.record(result[]);\n     }\n \n     pub fn record_with_span(&mut self,\n@@ -235,15 +235,15 @@ impl<'a> FmtStrs<'a> {\n         if !needs_span {\n             self.span.sess.span_bug(span,\n                                     format!(\"Called record_with_span for '{}' \\\n-                                             which does not require a span\", label).as_slice());\n+                                             which does not require a span\", label)[]);\n         }\n \n         let values_str = match self.make_values_str(label, fields, values, span) {\n             Some(vs) => vs,\n             None => return,\n         };\n         let result = format!(\"{},{}{}\\n\", label, self.span.extent_str(sub_span), values_str);\n-        self.recorder.record(result.as_slice());\n+        self.recorder.record(result[]);\n     }\n \n     pub fn check_and_record(&mut self,\n@@ -273,7 +273,7 @@ impl<'a> FmtStrs<'a> {\n         // variable def's node id\n         let mut qualname = String::from_str(name);\n         qualname.push_str(\"$\");\n-        qualname.push_str(id.to_string().as_slice());\n+        qualname.push_str(id.to_string()[]);\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,"}, {"sha": "a92d3c06e64fba5f6263bf33e8fdedb1c3b8fe01", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -218,7 +218,7 @@ impl<'a> SpanUtils<'a> {\n             let loc = self.sess.codemap().lookup_char_pos(span.lo);\n             self.sess.span_bug(span,\n                 format!(\"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                        self.snippet(span), loc.file.name, loc.line).as_slice());\n+                        self.snippet(span), loc.file.name, loc.line)[]);\n         }\n         if result.is_none() && prev.tok.is_ident() && bracket_count == 0 {\n             return self.make_sub_span(span, Some(prev.sp));\n@@ -244,7 +244,7 @@ impl<'a> SpanUtils<'a> {\n                     let loc = self.sess.codemap().lookup_char_pos(span.lo);\n                     self.sess.span_bug(span, format!(\n                         \"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                         self.snippet(span), loc.file.name, loc.line).as_slice());\n+                         self.snippet(span), loc.file.name, loc.line)[]);\n                 }\n                 return result\n             }"}, {"sha": "33fd14a441b8a955e27b5b013fbb048389bcb25c", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -427,7 +427,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n-        e(br.pats.as_slice()).map(|pats| {\n+        e(br.pats[]).map(|pats| {\n             let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n@@ -548,7 +548,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n         param_env: param_env,\n     };\n     enter_match(bcx, dm, m, col, val, |pats|\n-        check_match::specialize(&mcx, pats.as_slice(), &ctor, col, variant_size)\n+        check_match::specialize(&mcx, pats[], &ctor, col, variant_size)\n     )\n }\n \n@@ -790,7 +790,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         let did = langcall(cx,\n                            None,\n                            format!(\"comparison of `{}`\",\n-                                   cx.ty_to_string(rhs_t)).as_slice(),\n+                                   cx.ty_to_string(rhs_t))[],\n                            StrEqFnLangItem);\n         callee::trans_lang_call(cx, did, &[lhs, rhs], None)\n     }\n@@ -943,7 +943,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if has_nested_bindings(m, col) {\n                 let expanded = expand_nested_bindings(bcx, m, col, val);\n                 compile_submatch_continue(bcx,\n-                                          expanded.as_slice(),\n+                                          expanded[],\n                                           vals,\n                                           chk,\n                                           col,\n@@ -1035,8 +1035,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                         field_vals.len())\n             );\n             let mut vals = field_vals;\n-            vals.push_all(vals_left.as_slice());\n-            compile_submatch(bcx, pats.as_slice(), vals.as_slice(), chk, has_genuine_default);\n+            vals.push_all(vals_left[]);\n+            compile_submatch(bcx, pats[], vals[], chk, has_genuine_default);\n             return;\n         }\n         _ => ()\n@@ -1189,10 +1189,10 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n         let mut opt_vals = unpacked;\n-        opt_vals.push_all(vals_left.as_slice());\n+        opt_vals.push_all(vals_left[]);\n         compile_submatch(opt_cx,\n-                         opt_ms.as_slice(),\n-                         opt_vals.as_slice(),\n+                         opt_ms[],\n+                         opt_vals[],\n                          branch_chk.as_ref().unwrap_or(chk),\n                          has_genuine_default);\n     }\n@@ -1211,8 +1211,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n             _ => {\n                 compile_submatch(else_cx,\n-                                 defaults.as_slice(),\n-                                 vals_left.as_slice(),\n+                                 defaults[],\n+                                 vals_left[],\n                                  chk,\n                                  has_genuine_default);\n             }\n@@ -1333,21 +1333,21 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n                                  \"__llmatch\");\n                 trmode = TrByCopy(alloca_no_lifetime(bcx,\n                                          llvariable_ty,\n-                                         bcx.ident(ident).as_slice()));\n+                                         bcx.ident(ident)[]));\n             }\n             ast::BindByValue(_) => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n-                                 bcx.ident(ident).as_slice());\n+                                 bcx.ident(ident)[]);\n                 trmode = TrByMove;\n             }\n             ast::BindByRef(_) => {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty,\n-                                 bcx.ident(ident).as_slice());\n+                                 bcx.ident(ident)[]);\n                 trmode = TrByRef;\n             }\n         };\n@@ -1415,7 +1415,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         && arm.pats.last().unwrap().node == ast::PatWild(ast::PatWildSingle)\n     });\n \n-    compile_submatch(bcx, matches.as_slice(), &[discr_datum.val], &chk, has_default);\n+    compile_submatch(bcx, matches[], &[discr_datum.val], &chk, has_default);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in arm_datas.iter() {\n@@ -1429,7 +1429,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         arm_cxs.push(bcx);\n     }\n \n-    bcx = scope_cx.fcx.join_blocks(match_id, arm_cxs.as_slice());\n+    bcx = scope_cx.fcx.join_blocks(match_id, arm_cxs[]);\n     return bcx;\n }\n \n@@ -1581,7 +1581,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     let var_ty = node_id_type(bcx, p_id);\n \n     // Allocate memory on stack for the binding.\n-    let llval = alloc_ty(bcx, var_ty, bcx.ident(*ident).as_slice());\n+    let llval = alloc_ty(bcx, var_ty, bcx.ident(*ident)[]);\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n@@ -1619,7 +1619,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     if bcx.sess().asm_comments() {\n         add_comment(bcx, format!(\"bind_irrefutable_pat(pat={})\",\n-                                 pat.repr(bcx.tcx())).as_slice());\n+                                 pat.repr(bcx.tcx()))[]);\n     }\n \n     let _indenter = indenter();"}, {"sha": "9794611dd8471185ab858b1adde587942436f99d", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -156,7 +156,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      t: Ty<'tcx>) -> Repr<'tcx> {\n     match t.sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, elems.as_slice(), false, t), false)\n+            Univariant(mk_struct(cx, elems[], false, t), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n@@ -167,16 +167,16 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n             if dtor { ftys.push(ty::mk_bool()); }\n \n-            Univariant(mk_struct(cx, ftys.as_slice(), packed, t), dtor)\n+            Univariant(mk_struct(cx, ftys[], packed, t), dtor)\n         }\n         ty::ty_unboxed_closure(def_id, _, ref substs) => {\n             let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs);\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            Univariant(mk_struct(cx, upvar_types.as_slice(), false, t), false)\n+            Univariant(mk_struct(cx, upvar_types[], false, t), false)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n-            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id).as_slice().get(0)\n+            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id)[].get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n@@ -186,7 +186,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n                 let ftys = if dtor { vec!(ty::mk_bool()) } else { vec!() };\n-                return Univariant(mk_struct(cx, ftys.as_slice(), false, t),\n+                return Univariant(mk_struct(cx, ftys[], false, t),\n                                   dtor);\n             }\n \n@@ -209,7 +209,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 cx.sess().bug(format!(\"non-C-like enum {} with specified \\\n                                       discriminants\",\n                                       ty::item_path_str(cx.tcx(),\n-                                                        def_id)).as_slice());\n+                                                        def_id))[]);\n             }\n \n             if cases.len() == 1 {\n@@ -218,7 +218,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 assert_eq!(hint, attr::ReprAny);\n                 let mut ftys = cases[0].tys.clone();\n                 if dtor { ftys.push(ty::mk_bool()); }\n-                return Univariant(mk_struct(cx, ftys.as_slice(), false, t),\n+                return Univariant(mk_struct(cx, ftys[], false, t),\n                                   dtor);\n             }\n \n@@ -227,7 +227,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let mut discr = 0;\n                 while discr < 2 {\n                     if cases[1 - discr].is_zerolen(cx, t) {\n-                        let st = mk_struct(cx, cases[discr].tys.as_slice(),\n+                        let st = mk_struct(cx, cases[discr].tys[],\n                                            false, t);\n                         match cases[discr].find_ptr(cx) {\n                             Some(ThinPointer(_)) if st.fields.len() == 1 => {\n@@ -260,17 +260,17 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(ity));\n-                ftys.push_all(c.tys.as_slice());\n+                ftys.push_all(c.tys[]);\n                 if dtor { ftys.push(ty::mk_bool()); }\n-                mk_struct(cx, ftys.as_slice(), false, t)\n+                mk_struct(cx, ftys[], false, t)\n             }).collect();\n \n-            ensure_enum_fits_in_address_space(cx, ity, fields.as_slice(), t);\n+            ensure_enum_fits_in_address_space(cx, ity, fields[], t);\n \n             General(ity, fields, dtor)\n         }\n         _ => cx.sess().bug(format!(\"adt::represent_type called on non-ADT type: {}\",\n-                           ty_to_string(cx.tcx(), t)).as_slice())\n+                           ty_to_string(cx.tcx(), t))[])\n     }\n }\n \n@@ -290,7 +290,7 @@ pub enum PointerField {\n impl<'tcx> Case<'tcx> {\n     fn is_zerolen<'a>(&self, cx: &CrateContext<'a, 'tcx>, scapegoat: Ty<'tcx>)\n                       -> bool {\n-        mk_struct(cx, self.tys.as_slice(), false, scapegoat).size == 0\n+        mk_struct(cx, self.tys[], false, scapegoat).size == 0\n     }\n \n     fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<PointerField> {\n@@ -352,9 +352,9 @@ fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     };\n \n-    ensure_struct_fits_in_address_space(cx, lltys.as_slice(), packed, scapegoat);\n+    ensure_struct_fits_in_address_space(cx, lltys[], packed, scapegoat);\n \n-    let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n+    let llty_rec = Type::struct_(cx, lltys[], packed);\n     Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec),\n         align: machine::llalign_of_min(cx, llty_rec),\n@@ -403,7 +403,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             return ity;\n         }\n         attr::ReprExtern => {\n-            attempts = match cx.sess().target.target.arch.as_slice() {\n+            attempts = match cx.sess().target.target.arch[] {\n                 // WARNING: the ARM EABI has two variants; the one corresponding to `at_least_32`\n                 // appears to be used on Linux and NetBSD, but some systems may use the variant\n                 // corresponding to `choose_shortest`.  However, we don't run on those yet...?\n@@ -530,7 +530,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     match *r {\n         CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n-            llty.set_struct_body(struct_llfields(cx, st, false, false).as_slice(),\n+            llty.set_struct_body(struct_llfields(cx, st, false, false)[],\n                                  st.packed)\n     }\n }\n@@ -546,7 +546,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, struct_llfields(cx, st, sizing, dst).as_slice(),\n+                    Type::struct_(cx, struct_llfields(cx, st, sizing, dst)[],\n                                   st.packed)\n                 }\n                 Some(name) => { assert_eq!(sizing, false); Type::named_struct(cx, name) }\n@@ -565,7 +565,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // of the size.\n             //\n             // FIXME #10604: this breaks when vector types are present.\n-            let (size, align) = union_size_and_align(sts.as_slice());\n+            let (size, align) = union_size_and_align(sts[]);\n             let align_s = align as u64;\n             let discr_ty = ll_inttype(cx, ity);\n             let discr_size = machine::llsize_of_alloc(cx, discr_ty);\n@@ -586,10 +586,10 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                            Type::array(&discr_ty, align_s / discr_size - 1),\n                            pad_ty);\n             match name {\n-                None => Type::struct_(cx, fields.as_slice(), false),\n+                None => Type::struct_(cx, fields[], false),\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(fields.as_slice(), false);\n+                    llty.set_struct_body(fields[], false);\n                     llty\n                 }\n             }\n@@ -847,7 +847,7 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n     let val = if needs_cast {\n         let ccx = bcx.ccx();\n         let fields = st.fields.iter().map(|&ty| type_of::type_of(ccx, ty)).collect::<Vec<_>>();\n-        let real_ty = Type::struct_(ccx, fields.as_slice(), st.packed);\n+        let real_ty = Type::struct_(ccx, fields[], st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n         val\n@@ -879,14 +879,14 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n             for (discr, case) in cases.iter().enumerate() {\n                 let mut variant_cx = fcx.new_temp_block(\n-                    format!(\"enum-variant-iter-{}\", discr.to_string()).as_slice()\n+                    format!(\"enum-variant-iter-{}\", discr.to_string())[]\n                 );\n                 let rhs_val = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n                 AddCase(llswitch, rhs_val, variant_cx.llbb);\n \n                 let fields = case.fields.iter().map(|&ty|\n                     type_of::type_of(bcx.ccx(), ty)).collect::<Vec<_>>();\n-                let real_ty = Type::struct_(ccx, fields.as_slice(), case.packed);\n+                let real_ty = Type::struct_(ccx, fields[], case.packed);\n                 let variant_value = PointerCast(variant_cx, value, real_ty.ptr_to());\n \n                 variant_cx = f(variant_cx, case, variant_value);\n@@ -961,14 +961,14 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n             let mut f = vec![lldiscr];\n             f.push_all(vals);\n-            let mut contents = build_const_struct(ccx, case, f.as_slice());\n+            let mut contents = build_const_struct(ccx, case, f[]);\n             contents.push_all(&[padding(ccx, max_sz - case.size)]);\n-            C_struct(ccx, contents.as_slice(), false)\n+            C_struct(ccx, contents[], false)\n         }\n         Univariant(ref st, _dro) => {\n             assert!(discr == 0);\n             let contents = build_const_struct(ccx, st, vals);\n-            C_struct(ccx, contents.as_slice(), st.packed)\n+            C_struct(ccx, contents[], st.packed)\n         }\n         RawNullablePointer { nndiscr, nnty, .. } => {\n             if discr == nndiscr {\n@@ -982,7 +982,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             if discr == nndiscr {\n                 C_struct(ccx, build_const_struct(ccx,\n                                                  nonnull,\n-                                                 vals).as_slice(),\n+                                                 vals)[],\n                          false)\n             } else {\n                 let vals = nonnull.fields.iter().map(|&ty| {\n@@ -992,7 +992,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n                 }).collect::<Vec<ValueRef>>();\n                 C_struct(ccx, build_const_struct(ccx,\n                                                  nonnull,\n-                                                 vals.as_slice()).as_slice(),\n+                                                 vals[])[],\n                          false)\n             }\n         }"}, {"sha": "b8bee1000824dc4f6031a9abd6d0d35504d0cff8", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -72,7 +72,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                     callee::DontAutorefArg)\n         })\n     }).collect::<Vec<_>>();\n-    inputs.push_all(ext_inputs.as_slice());\n+    inputs.push_all(ext_inputs[]);\n \n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n@@ -92,18 +92,18 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         if !clobbers.is_empty() {\n             clobbers.push(',');\n         }\n-        clobbers.push_str(more_clobbers.as_slice());\n+        clobbers.push_str(more_clobbers[]);\n     }\n \n     // Add the clobbers to our constraints list\n     if clobbers.len() != 0 && constraints.len() != 0 {\n         constraints.push(',');\n-        constraints.push_str(clobbers.as_slice());\n+        constraints.push_str(clobbers[]);\n     } else {\n-        constraints.push_str(clobbers.as_slice());\n+        constraints.push_str(clobbers[]);\n     }\n \n-    debug!(\"Asm Constraints: {}\", constraints.as_slice());\n+    debug!(\"Asm Constraints: {}\", constraints[]);\n \n     let num_outputs = outputs.len();\n \n@@ -113,7 +113,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     } else if num_outputs == 1 {\n         output_types[0]\n     } else {\n-        Type::struct_(bcx.ccx(), output_types.as_slice(), false)\n+        Type::struct_(bcx.ccx(), output_types[], false)\n     };\n \n     let dialect = match ia.dialect {\n@@ -126,7 +126,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n             InlineAsmCall(bcx,\n                           a,\n                           c,\n-                          inputs.as_slice(),\n+                          inputs[],\n                           output_type,\n                           ia.volatile,\n                           ia.alignstack,"}, {"sha": "a18d403bd9540d3a4b9fba88c054ee146e2fa9b3", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -249,7 +249,7 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n     let f = decl_rust_fn(ccx, fn_ty, name);\n \n     csearch::get_item_attrs(&ccx.sess().cstore, did, |attrs| {\n-        set_llvm_fn_attrs(ccx, attrs.as_slice(), f)\n+        set_llvm_fn_attrs(ccx, attrs[], f)\n     });\n \n     ccx.externs().borrow_mut().insert(name.to_string(), f);\n@@ -302,7 +302,7 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => panic!(\"expected closure or fn\")\n     };\n \n-    let llfty = type_of_rust_fn(ccx, env, inputs.as_slice(), output, abi);\n+    let llfty = type_of_rust_fn(ccx, env, inputs[], output, abi);\n     debug!(\"decl_rust_fn(input count={},type={})\",\n            inputs.len(),\n            ccx.tn().type_to_string(llfty));\n@@ -369,7 +369,7 @@ fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         Err(s) => {\n             bcx.sess().fatal(format!(\"allocation of `{}` {}\",\n                                      bcx.ty_to_string(info_ty),\n-                                     s).as_slice());\n+                                     s)[]);\n         }\n     }\n }\n@@ -510,7 +510,7 @@ pub fn unset_split_stack(f: ValueRef) {\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n     if ccx.all_llvm_symbols().borrow().contains(&sym) {\n-        ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym).as_slice());\n+        ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym)[]);\n     }\n     ccx.all_llvm_symbols().borrow_mut().insert(sym);\n }\n@@ -546,7 +546,7 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      ty::mk_nil(ccx.tcx()));\n         get_extern_fn(ccx,\n                       &mut *ccx.externs().borrow_mut(),\n-                      name.as_slice(),\n+                      name[],\n                       llvm::CCallConv,\n                       llty,\n                       dtor_ty)\n@@ -796,8 +796,8 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                       let variant_cx =\n                           fcx.new_temp_block(\n                               format!(\"enum-iter-variant-{}\",\n-                                      variant.disr_val.to_string().as_slice())\n-                                     .as_slice());\n+                                      variant.disr_val.to_string()[])\n+                                     []);\n                       match adt::trans_case(cx, &*repr, variant.disr_val) {\n                           _match::SingleResult(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n@@ -822,7 +822,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n       }\n       _ => {\n           cx.sess().unimpl(format!(\"type in iter_structural_ty: {}\",\n-                                   ty_to_string(cx.tcx(), t)).as_slice())\n+                                   ty_to_string(cx.tcx(), t))[])\n       }\n     }\n     return cx;\n@@ -904,7 +904,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n         }\n         _ => {\n             cx.sess().bug(format!(\"fail-if-zero on unexpected type: {}\",\n-                                  ty_to_string(cx.tcx(), rhs_t)).as_slice());\n+                                  ty_to_string(cx.tcx(), rhs_t))[]);\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n@@ -958,19 +958,19 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(ref fn_ty) => {\n             match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n                 Rust | RustCall => {\n-                    get_extern_rust_fn(ccx, t, name.as_slice(), did)\n+                    get_extern_rust_fn(ccx, t, name[], did)\n                 }\n                 RustIntrinsic => {\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n                 _ => {\n                     foreign::register_foreign_item_fn(ccx, fn_ty.abi, t,\n-                                                      name.as_slice())\n+                                                      name[])\n                 }\n             }\n         }\n         ty::ty_closure(_) => {\n-            get_extern_rust_fn(ccx, t, name.as_slice(), did)\n+            get_extern_rust_fn(ccx, t, name[], did)\n         }\n         _ => {\n             get_extern_const(ccx, did, t)\n@@ -1024,7 +1024,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         let llresult = Invoke(bcx,\n                               llfn,\n-                              llargs.as_slice(),\n+                              llargs[],\n                               normal_bcx.llbb,\n                               landing_pad,\n                               Some(attributes));\n@@ -1040,7 +1040,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             None => debuginfo::clear_source_location(bcx.fcx)\n         };\n \n-        let llresult = Call(bcx, llfn, llargs.as_slice(), Some(attributes));\n+        let llresult = Call(bcx, llfn, llargs[], Some(attributes));\n         return (llresult, bcx);\n     }\n }\n@@ -1157,7 +1157,7 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n-    let key = match ccx.sess().target.target.target_word_size.as_slice() {\n+    let key = match ccx.sess().target.target.target_word_size[] {\n         \"32\" => \"llvm.memcpy.p0i8.p0i8.i32\",\n         \"64\" => \"llvm.memcpy.p0i8.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memcpy: {}\", tws),\n@@ -1204,7 +1204,7 @@ fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n \n     let llty = type_of::type_of(ccx, ty);\n \n-    let intrinsic_key = match ccx.sess().target.target.target_word_size.as_slice() {\n+    let intrinsic_key = match ccx.sess().target.target.target_word_size[] {\n         \"32\" => \"llvm.memset.p0i8.i32\",\n         \"64\" => \"llvm.memset.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memset: {}\", tws),\n@@ -1691,7 +1691,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                                                          \"argtuple\",\n                                                          arg_scope_id));\n     let untupled_arg_types = match monomorphized_arg_types[0].sty {\n-        ty::ty_tup(ref types) => types.as_slice(),\n+        ty::ty_tup(ref types) => types[],\n         _ => {\n             bcx.tcx().sess.span_bug(args[0].pat.span,\n                                     \"first arg to `rust-call` ABI function \\\n@@ -1879,29 +1879,29 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let arg_datums = if abi != RustCall {\n         create_datums_for_fn_args(&fcx,\n-                                  monomorphized_arg_types.as_slice())\n+                                  monomorphized_arg_types[])\n     } else {\n         create_datums_for_fn_args_under_call_abi(\n             bcx,\n             arg_scope,\n-            monomorphized_arg_types.as_slice())\n+            monomorphized_arg_types[])\n     };\n \n     bcx = match closure_env.kind {\n         closure::NotClosure | closure::BoxedClosure(..) => {\n             copy_args_to_allocas(&fcx,\n                                  arg_scope,\n                                  bcx,\n-                                 decl.inputs.as_slice(),\n+                                 decl.inputs[],\n                                  arg_datums)\n         }\n         closure::UnboxedClosure(..) => {\n             copy_unboxed_closure_args_to_allocas(\n                 bcx,\n                 arg_scope,\n-                decl.inputs.as_slice(),\n+                decl.inputs[],\n                 arg_datums,\n-                monomorphized_arg_types.as_slice())\n+                monomorphized_arg_types[])\n         }\n     };\n \n@@ -2018,7 +2018,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n-                     ctor_ty.repr(tcx)).as_slice())\n+                     ctor_ty.repr(tcx))[])\n     };\n \n     // Get location to store the result. If the user does not care about\n@@ -2041,7 +2041,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 bcx = expr::trans_adt(bcx,\n                                       result_ty,\n                                       disr,\n-                                      fields.as_slice(),\n+                                      fields[],\n                                       None,\n                                       expr::SaveIn(llresult),\n                                       call_info);\n@@ -2090,7 +2090,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n-                    ty_to_string(ccx.tcx(), ctor_ty)).as_slice())\n+                    ty_to_string(ccx.tcx(), ctor_ty))[])\n     };\n \n     let arena = TypedArena::new();\n@@ -2102,7 +2102,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n-    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.as_slice());\n+    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys[]);\n \n     if !type_is_zero_size(fcx.ccx, result_ty.unwrap()) {\n         let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n@@ -2166,7 +2166,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n                             lvlsrc, Some(sp),\n                             format!(\"enum variant is more than three times larger \\\n                                      ({} bytes) than the next largest (ignoring padding)\",\n-                                    largest).as_slice());\n+                                    largest)[]);\n \n         ccx.sess().span_note(enum_def.variants[largest_index].span,\n                              \"this variant is the largest\");\n@@ -2284,7 +2284,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     match item.node {\n       ast::ItemFn(ref decl, _fn_style, abi, ref generics, ref body) => {\n         if !generics.is_type_parameterized() {\n-            let trans_everywhere = attr::requests_inline(item.attrs.as_slice());\n+            let trans_everywhere = attr::requests_inline(item.attrs[]);\n             // Ignore `trans_everywhere` for cross-crate inlined items\n             // (`from_external`).  `trans_item` will be called once for each\n             // compilation unit that references the item, so it will still get\n@@ -2295,7 +2295,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                     foreign::trans_rust_fn_with_foreign_abi(ccx,\n                                                             &**decl,\n                                                             &**body,\n-                                                            item.attrs.as_slice(),\n+                                                            item.attrs[],\n                                                             llfn,\n                                                             &Substs::trans_empty(),\n                                                             item.id,\n@@ -2307,7 +2307,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                              llfn,\n                              &Substs::trans_empty(),\n                              item.id,\n-                             item.attrs.as_slice());\n+                             item.attrs[]);\n                 }\n                 update_linkage(ccx,\n                                llfn,\n@@ -2324,7 +2324,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n       ast::ItemImpl(_, ref generics, _, _, ref impl_items) => {\n         meth::trans_impl(ccx,\n                          item.ident,\n-                         impl_items.as_slice(),\n+                         impl_items[],\n                          generics,\n                          item.id);\n       }\n@@ -2350,7 +2350,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n \n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n-          if attr::contains_name(item.attrs.as_slice(), \"static_assert\") {\n+          if attr::contains_name(item.attrs[], \"static_assert\") {\n               if m == ast::MutMutable {\n                   ccx.sess().span_fatal(expr.span,\n                                         \"cannot have static_assert on a mutable \\\n@@ -2427,7 +2427,7 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => panic!(\"expected bare rust fn\")\n     };\n \n-    let llfn = decl_rust_fn(ccx, node_type, sym.as_slice());\n+    let llfn = decl_rust_fn(ccx, node_type, sym[]);\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -2472,7 +2472,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n \n             match fn_sig.0.inputs[1].sty {\n                 ty::ty_tup(ref t_in) => {\n-                    inputs.push_all(t_in.as_slice());\n+                    inputs.push_all(t_in[]);\n                     inputs\n                 }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n@@ -2607,7 +2607,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n                           llfty: Type) -> ValueRef {\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n-    let llfn = decl_fn(ccx, sym.as_slice(), cc, llfty, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+    let llfn = decl_fn(ccx, sym[], cc, llfty, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -2659,7 +2659,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n-                    Err(s) => { ccx.sess().fatal(s.as_slice()); }\n+                    Err(s) => { ccx.sess().fatal(s[]); }\n                 };\n                 let start_fn = if start_def_id.krate == ast::LOCAL_CRATE {\n                     get_item_val(ccx, start_def_id.node)\n@@ -2750,7 +2750,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n-            let sym = || exported_name(ccx, id, ty, i.attrs.as_slice());\n+            let sym = || exported_name(ccx, id, ty, i.attrs[]);\n \n             let v = match i.node {\n                 ast::ItemStatic(_, _, ref expr) => {\n@@ -2773,16 +2773,16 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         } else {\n                             llvm::LLVMTypeOf(v)\n                         };\n-                        if contains_null(sym.as_slice()) {\n+                        if contains_null(sym[]) {\n                             ccx.sess().fatal(\n                                 format!(\"Illegal null byte in export_name \\\n-                                         value: `{}`\", sym).as_slice());\n+                                         value: `{}`\", sym)[]);\n                         }\n                         let g = sym.with_c_str(|buf| {\n                             llvm::LLVMAddGlobal(ccx.llmod(), llty, buf)\n                         });\n \n-                        if attr::contains_name(i.attrs.as_slice(),\n+                        if attr::contains_name(i.attrs[],\n                                                \"thread_local\") {\n                             llvm::set_thread_local(g, true);\n                         }\n@@ -2807,19 +2807,19 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                                                    sym,\n                                                                    i.id)\n                     };\n-                    set_llvm_fn_attrs(ccx, i.attrs.as_slice(), llfn);\n+                    set_llvm_fn_attrs(ccx, i.attrs[], llfn);\n                     llfn\n                 }\n \n                 _ => panic!(\"get_item_val: weird result in table\")\n             };\n \n-            match attr::first_attr_value_str_by_name(i.attrs.as_slice(),\n+            match attr::first_attr_value_str_by_name(i.attrs[],\n                                                      \"link_section\") {\n                 Some(sect) => {\n                     if contains_null(sect.get()) {\n                         ccx.sess().fatal(format!(\"Illegal null byte in link_section value: `{}`\",\n-                                                 sect.get()).as_slice());\n+                                                 sect.get())[]);\n                     }\n                     unsafe {\n                         sect.get().with_c_str(|buf| {\n@@ -2863,7 +2863,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     let abi = ccx.tcx().map.get_foreign_abi(id);\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n                     let name = foreign::link_name(&*ni);\n-                    foreign::register_foreign_item_fn(ccx, abi, ty, name.get().as_slice())\n+                    foreign::register_foreign_item_fn(ccx, abi, ty, name.get()[])\n                 }\n                 ast::ForeignItemStatic(..) => {\n                     foreign::register_static(ccx, &*ni)\n@@ -2886,7 +2886,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n-                                    enm.attrs.as_slice());\n+                                    enm.attrs[]);\n \n             llfn = match enm.node {\n                 ast::ItemEnum(_, _) => {\n@@ -2914,7 +2914,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                     id,\n                                     ty,\n                                     struct_item.attrs\n-                                               .as_slice());\n+                                               []);\n             let llfn = register_fn(ccx, struct_item.span,\n                                    sym, ctor_id, ty);\n             set_inline_hint(llfn);\n@@ -2923,7 +2923,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n         ref variant => {\n             ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {}\",\n-                                   variant).as_slice())\n+                                   variant)[])\n         }\n     };\n \n@@ -2944,10 +2944,10 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n                    m: &ast::Method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx(), id);\n \n-    let sym = exported_name(ccx, id, mty, m.attrs.as_slice());\n+    let sym = exported_name(ccx, id, mty, m.attrs[]);\n \n     let llfn = register_fn(ccx, m.span, sym, id, mty);\n-    set_llvm_fn_attrs(ccx, m.attrs.as_slice(), llfn);\n+    set_llvm_fn_attrs(ccx, m.attrs[], llfn);\n     llfn\n }\n \n@@ -2986,7 +2986,7 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n         Some(compressed) => compressed,\n         None => cx.sess().fatal(\"failed to compress metadata\"),\n     }.as_slice());\n-    let llmeta = C_bytes_in_context(cx.metadata_llcx(), compressed.as_slice());\n+    let llmeta = C_bytes_in_context(cx.metadata_llcx(), compressed[]);\n     let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\",\n                        cx.link_meta().crate_name,\n@@ -3114,7 +3114,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     let link_meta = link::build_link_meta(&tcx.sess, krate, name);\n \n     let codegen_units = tcx.sess.opts.cg.codegen_units;\n-    let shared_ccx = SharedCrateContext::new(link_meta.crate_name.as_slice(),\n+    let shared_ccx = SharedCrateContext::new(link_meta.crate_name[],\n                                              codegen_units,\n                                              tcx,\n                                              export_map,\n@@ -3216,7 +3216,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         llmod: shared_ccx.metadata_llmod(),\n     };\n     let formats = shared_ccx.tcx().dependency_formats.borrow().clone();\n-    let no_builtins = attr::contains_name(krate.attrs.as_slice(), \"no_builtins\");\n+    let no_builtins = attr::contains_name(krate.attrs[], \"no_builtins\");\n \n     let translation = CrateTranslation {\n         modules: modules,"}, {"sha": "1b9c9d221b909b0f5a28ea8b731d5f8b6bfde7ee", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -555,7 +555,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         } else {\n             let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");\n-            self.inbounds_gep(base, v.as_slice())\n+            self.inbounds_gep(base, v[])\n         }\n     }\n \n@@ -763,8 +763,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let s = format!(\"{} ({})\",\n                             text,\n                             self.ccx.sess().codemap().span_to_string(sp));\n-            debug!(\"{}\", s.as_slice());\n-            self.add_comment(s.as_slice());\n+            debug!(\"{}\", s[]);\n+            self.add_comment(s[]);\n         }\n     }\n \n@@ -801,7 +801,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {}\", self.ccx.tn().type_to_string(output));\n-        let fty = Type::func(argtys.as_slice(), &output);\n+        let fty = Type::func(argtys[], &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n                 fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);"}, {"sha": "9ea158fbe2101c70a74b14665daa55898887022e", "filename": "src/librustc_trans/trans/cabi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -107,7 +107,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    match ccx.sess().target.target.arch.as_slice() {\n+    match ccx.sess().target.target.arch[] {\n         \"x86\" => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n         \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {\n             cabi_x86_win64::compute_abi_info(ccx, atys, rty, ret_def)\n@@ -117,6 +117,6 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         \"arm\" => cabi_arm::compute_abi_info(ccx, atys, rty, ret_def),\n         \"mips\" => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n         a => ccx.sess().fatal((format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n-                              .as_slice()),\n+                              []),\n     }\n }"}, {"sha": "ec3a81afaa0eff9d9404221cc828db7265fa44fb", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -122,7 +122,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                     expr.span,\n                     format!(\"type of callee is neither bare-fn nor closure: \\\n                              {}\",\n-                            bcx.ty_to_string(datum.ty)).as_slice());\n+                            bcx.ty_to_string(datum.ty))[]);\n             }\n         }\n     }\n@@ -208,7 +208,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     format!(\"cannot translate def {} \\\n-                             to a callable thing!\", def).as_slice());\n+                             to a callable thing!\", def)[]);\n             }\n         }\n     }\n@@ -288,7 +288,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n             _ => {\n                 tcx.sess.bug(format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                                           bare_fn_ty.repr(tcx)).as_slice());\n+                                           bare_fn_ty.repr(tcx))[]);\n             }\n         };\n     let tuple_input_ty = ty::mk_tup(tcx, input_tys.to_vec());\n@@ -310,7 +310,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn =\n         decl_internal_rust_fn(ccx,\n                               tuple_fn_ty,\n-                              function_name.as_slice());\n+                              function_name[]);\n \n     //\n     let block_arena = TypedArena::new();\n@@ -345,7 +345,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                            None,\n                            bare_fn_ty,\n                            |bcx, _| Callee { bcx: bcx, data: Fn(llfnpointer) },\n-                           ArgVals(llargs.as_slice()),\n+                           ArgVals(llargs[]),\n                            dest).bcx;\n \n     finish_fn(&fcx, bcx, output_ty);\n@@ -813,7 +813,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n         bcx = foreign::trans_native_call(bcx, callee_ty,\n                                          llfn, opt_llretslot.unwrap(),\n-                                         llargs.as_slice(), arg_tys);\n+                                         llargs[], arg_tys);\n     }\n \n     fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_cleanup_scope);"}, {"sha": "c1bb21c496adfe97ecc2ce9cdce16fe9ea541b24", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -404,7 +404,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n         self.ccx.sess().bug(\n             format!(\"no cleanup scope {} found\",\n-                    self.ccx.tcx().map.node_to_string(cleanup_scope)).as_slice());\n+                    self.ccx.tcx().map.node_to_string(cleanup_scope))[]);\n     }\n \n     /// Schedules a cleanup to occur in the top-most scope, which must be a temporary scope.\n@@ -586,7 +586,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                     LoopExit(id, _) => {\n                         self.ccx.sess().bug(format!(\n                                 \"cannot exit from scope {}, \\\n-                                not in scope\", id).as_slice());\n+                                not in scope\", id)[]);\n                     }\n                 }\n             }\n@@ -655,7 +655,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 let name = scope.block_name(\"clean\");\n                 debug!(\"generating cleanups for {}\", name);\n                 let bcx_in = self.new_block(label.is_unwind(),\n-                                            name.as_slice(),\n+                                            name[],\n                                             None);\n                 let mut bcx_out = bcx_in;\n                 for cleanup in scope.cleanups.iter().rev() {\n@@ -702,7 +702,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 Some(llbb) => { return llbb; }\n                 None => {\n                     let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.new_block(true, name.as_slice(), None);\n+                    pad_bcx = self.new_block(true, name[], None);\n                     last_scope.cached_landing_pad = Some(pad_bcx.llbb);\n                 }\n             }\n@@ -1020,7 +1020,7 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n         }\n         None => {\n             tcx.sess.bug(format!(\"no temporary scope available for expr {}\",\n-                                 id).as_slice())\n+                                 id)[])\n         }\n     }\n }"}, {"sha": "8e56ef3c6f39664f95acf9d895ab6ac50cba48cc", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -177,7 +177,7 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     // compute the type of the closure\n-    let cdata_ty = mk_closure_tys(tcx, bound_values.as_slice());\n+    let cdata_ty = mk_closure_tys(tcx, bound_values[]);\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n@@ -206,7 +206,7 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         if ccx.sess().asm_comments() {\n             add_comment(bcx, format!(\"Copy {} into closure\",\n-                                     bv.to_string(ccx)).as_slice());\n+                                     bv.to_string(ccx))[]);\n         }\n \n         let bound_data = GEPi(bcx, llbox, &[0u, abi::BOX_FIELD_BODY, i]);\n@@ -444,7 +444,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let s = tcx.map.with_path(id, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n-    let llfn = decl_internal_rust_fn(ccx, fty, s.as_slice());\n+    let llfn = decl_internal_rust_fn(ccx, fty, s[]);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -468,7 +468,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   &[],\n                   ty::ty_fn_ret(fty),\n                   ty::ty_fn_abi(fty),\n-                  ClosureEnv::new(freevars.as_slice(),\n+                  ClosureEnv::new(freevars[],\n                                   BoxedClosure(cdata_ty, store)));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n     bcx\n@@ -514,7 +514,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'blk, 'tcx>(bcx: Block<'blk,\n         mangle_internal_name_by_path_and_seq(path, \"unboxed_closure\")\n     });\n \n-    let llfn = decl_internal_rust_fn(ccx, function_type, symbol.as_slice());\n+    let llfn = decl_internal_rust_fn(ccx, function_type, symbol[]);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -563,7 +563,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                   &[],\n                   ty::ty_fn_ret(function_type),\n                   ty::ty_fn_abi(function_type),\n-                  ClosureEnv::new(freevars.as_slice(),\n+                  ClosureEnv::new(freevars[],\n                                   UnboxedClosure(freevar_mode)));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n@@ -614,7 +614,7 @@ pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\\n                                     expected a statically resolved fn, got \\\n                                     {}\",\n-                                    def).as_slice());\n+                                    def)[]);\n         }\n     };\n \n@@ -632,17 +632,17 @@ pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => {\n             ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\\n                                     expected a closure ty, got {}\",\n-                                    closure_ty.repr(tcx)).as_slice());\n+                                    closure_ty.repr(tcx))[]);\n         }\n     };\n \n     let name = ty::with_path(tcx, def_id, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"as_closure\")\n     });\n     let llfn = if is_local {\n-        decl_internal_rust_fn(ccx, closure_ty, name.as_slice())\n+        decl_internal_rust_fn(ccx, closure_ty, name[])\n     } else {\n-        decl_rust_fn(ccx, closure_ty, name.as_slice())\n+        decl_rust_fn(ccx, closure_ty, name[])\n     };\n \n     ccx.closure_bare_wrapper_cache().borrow_mut().insert(fn_ptr, llfn);\n@@ -663,7 +663,7 @@ pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let args = create_datums_for_fn_args(&fcx,\n                                          ty::ty_fn_args(closure_ty)\n-                                            .as_slice());\n+                                            []);\n     let mut llargs = Vec::new();\n     match fcx.llretslotptr.get() {\n         Some(llretptr) => {"}, {"sha": "9a3e39ff10b310772e004ca0d1065c14d6cfa2ff", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -117,7 +117,7 @@ pub fn gensym_name(name: &str) -> PathElem {\n     let num = token::gensym(name).uint();\n     // use one colon which will get translated to a period by the mangler, and\n     // we're guaranteed that `num` is globally unique for this crate.\n-    PathName(token::gensym(format!(\"{}:{}\", name, num).as_slice()))\n+    PathName(token::gensym(format!(\"{}:{}\", name, num)[]))\n }\n \n #[deriving(Copy)]\n@@ -436,7 +436,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n             Some(v) => v.clone(),\n             None => {\n                 self.tcx().sess.bug(format!(\n-                    \"no def associated with node id {}\", nid).as_slice());\n+                    \"no def associated with node id {}\", nid)[]);\n             }\n         }\n     }\n@@ -817,7 +817,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 span,\n                 format!(\"Encountered error `{}` selecting `{}` during trans\",\n                         e.repr(tcx),\n-                        trait_ref.repr(tcx)).as_slice())\n+                        trait_ref.repr(tcx))[])\n         }\n     };\n \n@@ -844,7 +844,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     span,\n                     format!(\"Encountered errors `{}` fulfilling `{}` during trans\",\n                             errors.repr(tcx),\n-                            trait_ref.repr(tcx)).as_slice());\n+                            trait_ref.repr(tcx))[]);\n             }\n         }\n     }\n@@ -892,7 +892,7 @@ pub fn node_id_substs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             format!(\"type parameters for node {} include inference types: \\\n                      {}\",\n                     node,\n-                    substs.repr(bcx.tcx())).as_slice());\n+                    substs.repr(bcx.tcx()))[]);\n     }\n \n     let substs = substs.erase_regions();\n@@ -909,8 +909,8 @@ pub fn langcall(bcx: Block,\n         Err(s) => {\n             let msg = format!(\"{} {}\", msg, s);\n             match span {\n-                Some(span) => bcx.tcx().sess.span_fatal(span, msg.as_slice()),\n-                None => bcx.tcx().sess.fatal(msg.as_slice()),\n+                Some(span) => bcx.tcx().sess.span_fatal(span, msg[]),\n+                None => bcx.tcx().sess.fatal(msg[]),\n             }\n         }\n     }"}, {"sha": "4f7d0f8fe754f141c1d950d512a193f9e2fec87e", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -54,7 +54,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n                 _ => cx.sess().span_bug(lit.span,\n                         format!(\"integer literal has type {} (expected int \\\n                                  or uint)\",\n-                                ty_to_string(cx.tcx(), lit_int_ty)).as_slice())\n+                                ty_to_string(cx.tcx(), lit_int_ty))[])\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n@@ -74,7 +74,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         }\n         ast::LitBool(b) => C_bool(cx, b),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n-        ast::LitBinary(ref data) => C_binary_slice(cx, data.as_slice()),\n+        ast::LitBinary(ref data) => C_binary_slice(cx, data[]),\n     }\n }\n \n@@ -95,9 +95,9 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n                       .collect::<Vec<_>>();\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-        C_struct(cx, vs.as_slice(), false)\n+        C_struct(cx, vs[], false)\n     } else {\n-        C_array(llunitty, vs.as_slice())\n+        C_array(llunitty, vs[])\n     };\n     (v, llunitty)\n }\n@@ -152,13 +152,13 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef,\n                 }\n                 _ => {\n                     cx.sess().bug(format!(\"unexpected dereferenceable type {}\",\n-                                          ty_to_string(cx.tcx(), t)).as_slice())\n+                                          ty_to_string(cx.tcx(), t))[])\n                 }\n             }\n         }\n         None => {\n             cx.sess().bug(format!(\"cannot dereference const of type {}\",\n-                                  ty_to_string(cx.tcx(), t)).as_slice())\n+                                  ty_to_string(cx.tcx(), t))[])\n         }\n     }\n }\n@@ -203,7 +203,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n                     cx.sess()\n                       .span_bug(e.span,\n                                 format!(\"unexpected static function: {}\",\n-                                        store).as_slice())\n+                                        store)[])\n                 }\n                 ty::AdjustDerefRef(ref adj) => {\n                     let mut ty = ety;\n@@ -264,15 +264,15 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n                                         }\n                                         _ => cx.sess().span_bug(e.span,\n                                             format!(\"unimplemented type in const unsize: {}\",\n-                                                    ty_to_string(cx.tcx(), ty)).as_slice())\n+                                                    ty_to_string(cx.tcx(), ty))[])\n                                     }\n                                 }\n                                 _ => {\n                                     cx.sess()\n                                       .span_bug(e.span,\n                                                 format!(\"unimplemented const \\\n                                                          autoref {}\",\n-                                                        autoref).as_slice())\n+                                                        autoref)[])\n                                 }\n                             }\n                         }\n@@ -293,7 +293,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n         }\n         cx.sess().bug(format!(\"const {} of type {} has size {} instead of {}\",\n                          e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety),\n-                         csize, tsize).as_slice());\n+                         csize, tsize)[]);\n     }\n     (llconst, ety_adjusted)\n }\n@@ -443,7 +443,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                       _ => cx.sess().span_bug(base.span,\n                                               format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt)).as_slice())\n+                                                      ty_to_string(cx.tcx(), bt))[])\n                   },\n                   ty::ty_rptr(_, mt) => match mt.ty.sty {\n                       ty::ty_vec(_, Some(u)) => {\n@@ -452,12 +452,12 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                       _ => cx.sess().span_bug(base.span,\n                                               format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt)).as_slice())\n+                                                      ty_to_string(cx.tcx(), bt))[])\n                   },\n                   _ => cx.sess().span_bug(base.span,\n                                           format!(\"index-expr base must be a vector \\\n                                                    or string type, found {}\",\n-                                                  ty_to_string(cx.tcx(), bt)).as_slice())\n+                                                  ty_to_string(cx.tcx(), bt))[])\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n@@ -558,8 +558,8 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n           ast::ExprTup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n-              let vals = map_list(es.as_slice());\n-              adt::trans_const(cx, &*repr, 0, vals.as_slice())\n+              let vals = map_list(es[]);\n+              adt::trans_const(cx, &*repr, 0, vals[])\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n@@ -590,7 +590,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                           }\n                       }\n                   }).collect::<Vec<_>>();\n-                  adt::trans_const(cx, &*repr, discr, cs.as_slice())\n+                  adt::trans_const(cx, &*repr, discr, cs[])\n               })\n           }\n           ast::ExprVec(ref es) => {\n@@ -607,9 +607,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n             };\n             let vs = Vec::from_elem(n, const_expr(cx, &**elem).0);\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-                C_struct(cx, vs.as_slice(), false)\n+                C_struct(cx, vs[], false)\n             } else {\n-                C_array(llunitty, vs.as_slice())\n+                C_array(llunitty, vs[])\n             }\n           }\n           ast::ExprPath(ref pth) => {\n@@ -655,20 +655,20 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   Some(def::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n-                      let arg_vals = map_list(args.as_slice());\n-                      adt::trans_const(cx, &*repr, 0, arg_vals.as_slice())\n+                      let arg_vals = map_list(args[]);\n+                      adt::trans_const(cx, &*repr, 0, arg_vals[])\n                   }\n                   Some(def::DefVariant(enum_did, variant_did, _)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                            enum_did,\n                                                            variant_did);\n-                      let arg_vals = map_list(args.as_slice());\n+                      let arg_vals = map_list(args[]);\n                       adt::trans_const(cx,\n                                        &*repr,\n                                        vinfo.disr_val,\n-                                       arg_vals.as_slice())\n+                                       arg_vals[])\n                   }\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }"}, {"sha": "2c71dd831fbcb8f44a937e6622e3a91cfa206011", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -284,7 +284,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             // such as a function name in the module.\n             // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n             let llmod_id = format!(\"{}.{}.rs\", crate_name, i);\n-            let local_ccx = LocalCrateContext::new(&shared_ccx, llmod_id.as_slice());\n+            let local_ccx = LocalCrateContext::new(&shared_ccx, llmod_id[]);\n             shared_ccx.local_ccxs.push(local_ccx);\n         }\n \n@@ -374,7 +374,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                                           .target\n                                           .target\n                                           .data_layout\n-                                          .as_slice());\n+                                          []);\n \n             let dbg_cx = if shared.tcx.sess.opts.debuginfo != NoDebugInfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod))\n@@ -726,7 +726,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn report_overbig_object(&self, obj: Ty<'tcx>) -> ! {\n         self.sess().fatal(\n             format!(\"the type `{}` is too big for the current architecture\",\n-                    obj.repr(self.tcx())).as_slice())\n+                    obj.repr(self.tcx()))[])\n     }\n }\n "}, {"sha": "3b24ded6717cc9612ea4ab97aecae1d04acfc9c7", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -48,7 +48,7 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     debug!(\"trans_stmt({})\", s.repr(cx.tcx()));\n \n     if cx.sess().asm_comments() {\n-        add_span_comment(cx, s.span, s.repr(cx.tcx()).as_slice());\n+        add_span_comment(cx, s.span, s.repr(cx.tcx())[]);\n     }\n \n     let mut bcx = cx;\n@@ -188,7 +188,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     let name = format!(\"then-block-{}-\", thn.id);\n-    let then_bcx_in = bcx.fcx.new_id_block(name.as_slice(), thn.id);\n+    let then_bcx_in = bcx.fcx.new_id_block(name[], thn.id);\n     let then_bcx_out = trans_block(then_bcx_in, &*thn, dest);\n     trans::debuginfo::clear_source_location(bcx.fcx);\n \n@@ -437,7 +437,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n                     bcx.tcx().sess.bug(format!(\"{} in def-map for label\",\n-                                               r).as_slice())\n+                                               r)[])\n                 }\n             }\n         }\n@@ -501,7 +501,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let v_str = C_str_slice(ccx, fail_str);\n     let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n-    let filename = token::intern_and_get_ident(loc.file.name.as_slice());\n+    let filename = token::intern_and_get_ident(loc.file.name[]);\n     let filename = C_str_slice(ccx, filename);\n     let line = C_uint(ccx, loc.line);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n@@ -510,7 +510,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let did = langcall(bcx, Some(sp), \"\", PanicFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n-                                      args.as_slice(),\n+                                      args[],\n                                       Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;\n@@ -526,7 +526,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Extract the file/line from the span\n     let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n-    let filename = token::intern_and_get_ident(loc.file.name.as_slice());\n+    let filename = token::intern_and_get_ident(loc.file.name[]);\n \n     // Invoke the lang item\n     let filename = C_str_slice(ccx,  filename);\n@@ -537,7 +537,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let did = langcall(bcx, Some(sp), \"\", PanicBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n-                                      args.as_slice(),\n+                                      args[],\n                                       Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;"}, {"sha": "9ab4e92b51131af4fe028edf4952cccecee848e8", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -463,7 +463,7 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n             }\n             _ => bcx.tcx().sess.bug(\n                 format!(\"Unexpected unsized type in get_element: {}\",\n-                        bcx.ty_to_string(self.ty)).as_slice())\n+                        bcx.ty_to_string(self.ty))[])\n         };\n         Datum {\n             val: val,"}, {"sha": "2545de34ed8870812a6dc40697ba9a52ec85fb06", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -284,7 +284,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                        metadata: DIType) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n             cx.sess().bug(format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n-                                   ppaux::ty_to_string(cx.tcx(), type_)).as_slice());\n+                                   ppaux::ty_to_string(cx.tcx(), type_))[]);\n         }\n     }\n \n@@ -297,7 +297,7 @@ impl<'tcx> TypeMap<'tcx> {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n             let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n             cx.sess().bug(format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n-                                  unique_type_id_str.as_slice()).as_slice());\n+                                  unique_type_id_str[])[]);\n         }\n     }\n \n@@ -378,14 +378,14 @@ impl<'tcx> TypeMap<'tcx> {\n                         self.get_unique_type_id_of_type(cx, component_type);\n                     let component_type_id =\n                         self.get_unique_type_id_as_string(component_type_id);\n-                    unique_type_id.push_str(component_type_id.as_slice());\n+                    unique_type_id.push_str(component_type_id[]);\n                 }\n             },\n             ty::ty_uniq(inner_type) => {\n                 unique_type_id.push('~');\n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.as_slice());\n+                unique_type_id.push_str(inner_type_id[]);\n             },\n             ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n                 unique_type_id.push('*');\n@@ -395,7 +395,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.as_slice());\n+                unique_type_id.push_str(inner_type_id[]);\n             },\n             ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n                 unique_type_id.push('&');\n@@ -405,12 +405,12 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.as_slice());\n+                unique_type_id.push_str(inner_type_id[]);\n             },\n             ty::ty_vec(inner_type, optional_length) => {\n                 match optional_length {\n                     Some(len) => {\n-                        unique_type_id.push_str(format!(\"[{}]\", len).as_slice());\n+                        unique_type_id.push_str(format!(\"[{}]\", len)[]);\n                     }\n                     None => {\n                         unique_type_id.push_str(\"[]\");\n@@ -419,7 +419,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.as_slice());\n+                unique_type_id.push_str(inner_type_id[]);\n             },\n             ty::ty_trait(ref trait_data) => {\n                 unique_type_id.push_str(\"trait \");\n@@ -444,7 +444,7 @@ impl<'tcx> TypeMap<'tcx> {\n                         self.get_unique_type_id_of_type(cx, parameter_type);\n                     let parameter_type_id =\n                         self.get_unique_type_id_as_string(parameter_type_id);\n-                    unique_type_id.push_str(parameter_type_id.as_slice());\n+                    unique_type_id.push_str(parameter_type_id[]);\n                     unique_type_id.push(',');\n                 }\n \n@@ -457,7 +457,7 @@ impl<'tcx> TypeMap<'tcx> {\n                     ty::FnConverging(ret_ty) => {\n                         let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                         let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                        unique_type_id.push_str(return_type_id.as_slice());\n+                        unique_type_id.push_str(return_type_id[]);\n                     }\n                     ty::FnDiverging => {\n                         unique_type_id.push_str(\"!\");\n@@ -478,8 +478,8 @@ impl<'tcx> TypeMap<'tcx> {\n             },\n             _ => {\n                 cx.sess().bug(format!(\"get_unique_type_id_of_type() - unexpected type: {}, {}\",\n-                                      ppaux::ty_to_string(cx.tcx(), type_).as_slice(),\n-                                      type_.sty).as_slice())\n+                                      ppaux::ty_to_string(cx.tcx(), type_)[],\n+                                      type_.sty)[])\n             }\n         };\n \n@@ -522,7 +522,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n             output.push_str(crate_hash.as_str());\n             output.push_str(\"/\");\n-            output.push_str(format!(\"{:x}\", def_id.node).as_slice());\n+            output.push_str(format!(\"{:x}\", def_id.node)[]);\n \n             // Maybe check that there is no self type here.\n \n@@ -535,7 +535,7 @@ impl<'tcx> TypeMap<'tcx> {\n                         type_map.get_unique_type_id_of_type(cx, type_parameter);\n                     let param_type_id =\n                         type_map.get_unique_type_id_as_string(param_type_id);\n-                    output.push_str(param_type_id.as_slice());\n+                    output.push_str(param_type_id[]);\n                     output.push(',');\n                 }\n \n@@ -577,7 +577,7 @@ impl<'tcx> TypeMap<'tcx> {\n                 self.get_unique_type_id_of_type(cx, parameter_type);\n             let parameter_type_id =\n                 self.get_unique_type_id_as_string(parameter_type_id);\n-            unique_type_id.push_str(parameter_type_id.as_slice());\n+            unique_type_id.push_str(parameter_type_id[]);\n             unique_type_id.push(',');\n         }\n \n@@ -591,7 +591,7 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::FnConverging(ret_ty) => {\n                 let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                 let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                unique_type_id.push_str(return_type_id.as_slice());\n+                unique_type_id.push_str(return_type_id[]);\n             }\n             ty::FnDiverging => {\n                 unique_type_id.push_str(\"!\");\n@@ -622,7 +622,7 @@ impl<'tcx> TypeMap<'tcx> {\n         let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n         let enum_variant_type_id = format!(\"{}::{}\",\n                                            self.get_unique_type_id_as_string(enum_type_id)\n-                                               .as_slice(),\n+                                               [],\n                                            variant_name);\n         let interner_key = self.unique_id_interner.intern(Rc::new(enum_variant_type_id));\n         UniqueTypeId(interner_key)\n@@ -793,19 +793,19 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                          create_global_var_metadata() -\n                                          Captured var-id refers to \\\n                                          unexpected ast_item variant: {}\",\n-                                        var_item).as_slice())\n+                                        var_item)[])\n                 }\n             }\n         },\n         _ => cx.sess().bug(format!(\"debuginfo::create_global_var_metadata() \\\n                                     - Captured var-id refers to unexpected \\\n                                     ast_map variant: {}\",\n-                                   var_item).as_slice())\n+                                   var_item)[])\n     };\n \n     let (file_metadata, line_number) = if span != codemap::DUMMY_SP {\n         let loc = span_start(cx, span);\n-        (file_metadata(cx, loc.file.name.as_slice()), loc.line as c_uint)\n+        (file_metadata(cx, loc.file.name[]), loc.line as c_uint)\n     } else {\n         (UNKNOWN_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n     };\n@@ -816,7 +816,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n     let var_name = token::get_ident(ident).get().to_string();\n     let linkage_name =\n-        namespace_node.mangled_name_of_contained_item(var_name.as_slice());\n+        namespace_node.mangled_name_of_contained_item(var_name[]);\n     let var_scope = namespace_node.scope;\n \n     var_name.with_c_str(|var_name| {\n@@ -857,7 +857,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n             None => {\n                 bcx.sess().span_bug(span,\n                     format!(\"no entry in lllocals table for {}\",\n-                            node_id).as_slice());\n+                            node_id)[]);\n             }\n         };\n \n@@ -911,7 +911,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 \"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n                                  ast_map variant: {}\",\n-                                 ast_item).as_slice());\n+                                 ast_item)[]);\n                 }\n             }\n         }\n@@ -921,7 +921,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         format!(\"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n                                  ast_map variant: {}\",\n-                                ast_item).as_slice());\n+                                ast_item)[]);\n         }\n     };\n \n@@ -1028,7 +1028,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             None => {\n                 bcx.sess().span_bug(span,\n                     format!(\"no entry in lllocals table for {}\",\n-                            node_id).as_slice());\n+                            node_id)[]);\n             }\n         };\n \n@@ -1286,7 +1286,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match expr.node {\n                 ast::ExprClosure(_, _, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n-                    let name = token::str_to_ident(name.as_slice());\n+                    let name = token::str_to_ident(name[]);\n                     (name, &**fn_decl,\n                         // This is not quite right. It should actually inherit\n                         // the generics of the enclosing function.\n@@ -1318,7 +1318,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     cx.sess()\n                       .bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {}\",\n-                                    fnitem).as_slice())\n+                                    fnitem)[])\n                 }\n             }\n         }\n@@ -1329,7 +1329,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {}\",\n-                                   fnitem).as_slice())\n+                                   fnitem)[])\n     };\n \n     // This can be the case for functions inlined from another crate\n@@ -1338,7 +1338,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n+    let file_metadata = file_metadata(cx, loc.file.name[]);\n \n     let function_type_metadata = unsafe {\n         let fn_signature = get_function_signature(cx,\n@@ -1365,7 +1365,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (linkage_name, containing_scope) = if has_path {\n         let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id));\n         let linkage_name = namespace_node.mangled_name_of_contained_item(\n-            function_name.as_slice());\n+            function_name[]);\n         let containing_scope = namespace_node.scope;\n         (linkage_name, containing_scope)\n     } else {\n@@ -1451,7 +1451,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n         }\n \n-        return create_DIArray(DIB(cx), signature.as_slice());\n+        return create_DIArray(DIB(cx), signature[]);\n     }\n \n     fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -1484,7 +1484,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 actual_self_type,\n                 true);\n \n-            name_to_append_suffix_to.push_str(actual_self_type_name.as_slice());\n+            name_to_append_suffix_to.push_str(actual_self_type_name[]);\n \n             if generics.is_type_parameterized() {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1524,7 +1524,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,\n                                                                true);\n-            name_to_append_suffix_to.push_str(actual_type_name.as_slice());\n+            name_to_append_suffix_to.push_str(actual_type_name[]);\n \n             if index != generics.ty_params.len() - 1 {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1552,7 +1552,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         name_to_append_suffix_to.push('>');\n \n-        return create_DIArray(DIB(cx), template_params.as_slice());\n+        return create_DIArray(DIB(cx), template_params[]);\n     }\n }\n \n@@ -1650,7 +1650,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let cx: &CrateContext = bcx.ccx();\n \n     let filename = span_start(cx, span).file.name.clone();\n-    let file_metadata = file_metadata(cx, filename.as_slice());\n+    let file_metadata = file_metadata(cx, filename[]);\n \n     let name = token::get_ident(variable_ident);\n     let loc = span_start(cx, span);\n@@ -1737,7 +1737,7 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n     let work_dir = cx.sess().working_dir.as_str().unwrap();\n     let file_name =\n         if full_path.starts_with(work_dir) {\n-            full_path.slice(work_dir.len() + 1u, full_path.len())\n+            full_path[work_dir.len() + 1u..full_path.len()]\n         } else {\n             full_path\n         };\n@@ -1771,7 +1771,7 @@ fn scope_metadata(fcx: &FunctionContext,\n \n             fcx.ccx.sess().span_bug(error_reporting_span,\n                 format!(\"debuginfo: Could not find scope info for node {}\",\n-                        node).as_slice());\n+                        node)[]);\n         }\n     }\n }\n@@ -1971,7 +1971,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                         cx.sess().bug(format!(\"Forward declaration of potentially recursive type \\\n                                               '{}' was not found in TypeMap!\",\n                                               ppaux::ty_to_string(cx.tcx(), unfinished_type))\n-                                      .as_slice());\n+                                      []);\n                     }\n                 }\n \n@@ -1983,7 +1983,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                 set_members_of_composite_type(cx,\n                                               metadata_stub,\n                                               llvm_type,\n-                                              member_descriptions.as_slice());\n+                                              member_descriptions[]);\n                 return MetadataCreationResult::new(metadata_stub, true);\n             }\n         }\n@@ -2055,7 +2055,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n-                                                  struct_name.as_slice(),\n+                                                  struct_name[],\n                                                   unique_type_id,\n                                                   containing_scope);\n \n@@ -2116,7 +2116,7 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         unique_type_id,\n         create_struct_stub(cx,\n                            tuple_llvm_type,\n-                           tuple_name.as_slice(),\n+                           tuple_name[],\n                            unique_type_id,\n                            UNKNOWN_SCOPE_METADATA),\n         tuple_llvm_type,\n@@ -2176,7 +2176,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         set_members_of_composite_type(cx,\n                                                       variant_type_metadata,\n                                                       variant_llvm_type,\n-                                                      member_descriptions.as_slice());\n+                                                      member_descriptions[]);\n                         MemberDescription {\n                             name: \"\".to_string(),\n                             llvm_type: variant_llvm_type,\n@@ -2209,7 +2209,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     set_members_of_composite_type(cx,\n                                                   variant_type_metadata,\n                                                   variant_llvm_type,\n-                                                  member_descriptions.as_slice());\n+                                                  member_descriptions[]);\n                     vec![\n                         MemberDescription {\n                             name: \"\".to_string(),\n@@ -2309,7 +2309,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 set_members_of_composite_type(cx,\n                                               variant_type_metadata,\n                                               variant_llvm_type,\n-                                              variant_member_descriptions.as_slice());\n+                                              variant_member_descriptions[]);\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n@@ -2388,7 +2388,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     .iter()\n                                     .map(|&t| type_of::type_of(cx, t))\n                                     .collect::<Vec<_>>()\n-                                    .as_slice(),\n+                                    [],\n                       struct_def.packed);\n     // Could do some consistency checks here: size, align, field count, discr type\n \n@@ -2412,7 +2412,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         Some(ref names) => {\n             names.iter()\n                  .map(|ident| {\n-                     token::get_ident(*ident).get().to_string().into_string()\n+                     token::get_ident(*ident).get().to_string()\n                  }).collect()\n         }\n         None => variant_info.args.iter().map(|_| \"\".to_string()).collect()\n@@ -2455,7 +2455,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n     let loc = span_start(cx, definition_span);\n-    let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n+    let file_metadata = file_metadata(cx, loc.file.name[]);\n \n     let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n \n@@ -2502,7 +2502,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             UNKNOWN_LINE_NUMBER,\n                             bytes_to_bits(discriminant_size),\n                             bytes_to_bits(discriminant_align),\n-                            create_DIArray(DIB(cx), enumerators_metadata.as_slice()),\n+                            create_DIArray(DIB(cx), enumerators_metadata[]),\n                             discriminant_base_type_metadata)\n                     }\n                 });\n@@ -2644,7 +2644,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                                         Please use a rustc built with anewer \\\n                                         version of LLVM.\",\n                                        llvm_version_major,\n-                                       llvm_version_minor).as_slice());\n+                                       llvm_version_minor)[]);\n             } else {\n                 cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n                                Already completed forward declaration re-encountered.\");\n@@ -2683,7 +2683,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         .collect();\n \n     unsafe {\n-        let type_array = create_DIArray(DIB(cx), member_metadata.as_slice());\n+        let type_array = create_DIArray(DIB(cx), member_metadata[]);\n         llvm::LLVMDICompositeTypeSetTypeArray(composite_type_metadata, type_array);\n     }\n }\n@@ -2784,7 +2784,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let member_llvm_types = slice_llvm_type.field_types();\n     assert!(slice_layout_is_correct(cx,\n-                                    member_llvm_types.as_slice(),\n+                                    member_llvm_types[],\n                                     element_type));\n     let member_descriptions = [\n         MemberDescription {\n@@ -2806,11 +2806,11 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     assert!(member_descriptions.len() == member_llvm_types.len());\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n+    let file_metadata = file_metadata(cx, loc.file.name[]);\n \n     let metadata = composite_type_metadata(cx,\n                                            slice_llvm_type,\n-                                           slice_type_name.as_slice(),\n+                                           slice_type_name[],\n                                            unique_type_id,\n                                            &member_descriptions,\n                                            UNKNOWN_SCOPE_METADATA,\n@@ -2856,7 +2856,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             llvm::LLVMDIBuilderCreateSubroutineType(\n                 DIB(cx),\n                 UNKNOWN_FILE_METADATA,\n-                create_DIArray(DIB(cx), signature_metadata.as_slice()))\n+                create_DIArray(DIB(cx), signature_metadata[]))\n         },\n         false);\n }\n@@ -2882,7 +2882,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(format!(\"debuginfo: Unexpected trait-object type in \\\n                                    trait_pointer_metadata(): {}\",\n-                                   pp_type_name.as_slice()).as_slice());\n+                                   pp_type_name[])[]);\n         }\n     };\n \n@@ -2896,7 +2896,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     composite_type_metadata(cx,\n                             trait_llvm_type,\n-                            trait_type_name.as_slice(),\n+                            trait_type_name[],\n                             unique_type_id,\n                             &[],\n                             containing_scope,\n@@ -3019,13 +3019,13 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_tup(ref elements) => {\n             prepare_tuple_metadata(cx,\n                                    t,\n-                                   elements.as_slice(),\n+                                   elements[],\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n         _ => {\n             cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {}\",\n-                                  sty).as_slice())\n+                                  sty)[])\n         }\n     };\n \n@@ -3043,9 +3043,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                  type id '{}' to already be in \\\n                                                  the debuginfo::TypeMap but it \\\n                                                  was not. (Ty = {})\",\n-                                                unique_type_id_str.as_slice(),\n+                                                unique_type_id_str[],\n                                                 ppaux::ty_to_string(cx.tcx(), t));\n-                    cx.sess().span_bug(usage_site_span, error_message.as_slice());\n+                    cx.sess().span_bug(usage_site_span, error_message[]);\n                 }\n             };\n \n@@ -3058,9 +3058,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                      UniqueTypeId maps in \\\n                                                      debuginfo::TypeMap. \\\n                                                      UniqueTypeId={}, Ty={}\",\n-                            unique_type_id_str.as_slice(),\n+                            unique_type_id_str[],\n                             ppaux::ty_to_string(cx.tcx(), t));\n-                        cx.sess().span_bug(usage_site_span, error_message.as_slice());\n+                        cx.sess().span_bug(usage_site_span, error_message[]);\n                     }\n                 }\n                 None => {\n@@ -3266,7 +3266,7 @@ fn create_scope_map(cx: &CrateContext,\n     {\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n-        let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n+        let file_metadata = file_metadata(cx, loc.file.name[]);\n         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n         let scope_metadata = unsafe {\n@@ -3391,7 +3391,7 @@ fn create_scope_map(cx: &CrateContext,\n                         let file_metadata = file_metadata(cx,\n                                                           loc.file\n                                                              .name\n-                                                             .as_slice());\n+                                                             []);\n                         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                         let scope_metadata = unsafe {\n@@ -3925,7 +3925,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_open(_) |\n         ty::ty_param(_) => {\n             cx.sess().bug(format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)).as_slice());\n+                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t))[]);\n         }\n     }\n \n@@ -4008,21 +4008,21 @@ impl NamespaceTreeNode {\n                 None => {}\n             }\n             let string = token::get_name(node.name);\n-            output.push_str(format!(\"{}\", string.get().len()).as_slice());\n+            output.push_str(format!(\"{}\", string.get().len())[]);\n             output.push_str(string.get());\n         }\n \n         let mut name = String::from_str(\"_ZN\");\n         fill_nested(self, &mut name);\n-        name.push_str(format!(\"{}\", item_name.len()).as_slice());\n+        name.push_str(format!(\"{}\", item_name.len())[]);\n         name.push_str(item_name);\n         name.push('E');\n         name\n     }\n }\n \n fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n-    cx.link_meta().crate_name.as_slice()\n+    cx.link_meta().crate_name[]\n }\n \n fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n@@ -4099,7 +4099,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n             None => {\n                 cx.sess().bug(format!(\"debuginfo::namespace_for_item(): \\\n                                        path too short for {}\",\n-                                      def_id).as_slice());\n+                                      def_id)[]);\n             }\n         }\n     })"}, {"sha": "36f23f4a0cadccad8e70703486866d8602e7d004", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -311,7 +311,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     unsized_info(bcx, k, id, ty_substs[tp_index], |t| t)\n                 }\n                 _ => bcx.sess().bug(format!(\"UnsizeStruct with bad sty: {}\",\n-                                          bcx.ty_to_string(unadjusted_ty)).as_slice())\n+                                          bcx.ty_to_string(unadjusted_ty))[])\n             },\n             &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n                 let substs = principal.substs().with_self_ty(unadjusted_ty).erase_regions();\n@@ -442,7 +442,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let unboxed_ty = match datum_ty.sty {\n             ty::ty_uniq(t) => t,\n             _ => bcx.sess().bug(format!(\"Expected ty_uniq, found {}\",\n-                                        bcx.ty_to_string(datum_ty)).as_slice())\n+                                        bcx.ty_to_string(datum_ty))[])\n         };\n         let result_ty = ty::mk_uniq(tcx, ty::unsize_ty(tcx, unboxed_ty, k, expr.span));\n \n@@ -660,7 +660,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 expr.span,\n                 format!(\"trans_rvalue_datum_unadjusted reached \\\n                          fall-through case: {}\",\n-                        expr.node).as_slice());\n+                        expr.node)[]);\n         }\n     }\n }\n@@ -1007,7 +1007,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 expr.span,\n                 format!(\"trans_rvalue_stmt_unadjusted reached \\\n                          fall-through case: {}\",\n-                        expr.node).as_slice());\n+                        expr.node)[]);\n         }\n     }\n }\n@@ -1033,14 +1033,14 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             controlflow::trans_if(bcx, expr.id, &**cond, &**thn, els.as_ref().map(|e| &**e), dest)\n         }\n         ast::ExprMatch(ref discr, ref arms, _) => {\n-            _match::trans_match(bcx, expr, &**discr, arms.as_slice(), dest)\n+            _match::trans_match(bcx, expr, &**discr, arms[], dest)\n         }\n         ast::ExprBlock(ref blk) => {\n             controlflow::trans_block(bcx, &**blk, dest)\n         }\n         ast::ExprStruct(_, ref fields, ref base) => {\n             trans_struct(bcx,\n-                         fields.as_slice(),\n+                         fields[],\n                          base.as_ref().map(|e| &**e),\n                          expr.span,\n                          expr.id,\n@@ -1052,7 +1052,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_adt(bcx,\n                       expr_ty(bcx, expr),\n                       0,\n-                      numbered_fields.as_slice(),\n+                      numbered_fields[],\n                       None,\n                       dest,\n                       Some(NodeInfo { id: expr.id, span: expr.span }))\n@@ -1096,21 +1096,21 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 trans_overloaded_call(bcx,\n                                       expr,\n                                       &**f,\n-                                      args.as_slice(),\n+                                      args[],\n                                       Some(dest))\n             } else {\n                 callee::trans_call(bcx,\n                                    expr,\n                                    &**f,\n-                                   callee::ArgExprs(args.as_slice()),\n+                                   callee::ArgExprs(args[]),\n                                    dest)\n             }\n         }\n         ast::ExprMethodCall(_, _, ref args) => {\n             callee::trans_method_call(bcx,\n                                       expr,\n                                       &*args[0],\n-                                      callee::ArgExprs(args.as_slice()),\n+                                      callee::ArgExprs(args[]),\n                                       dest)\n         }\n         ast::ExprBinary(op, ref lhs, ref rhs) => {\n@@ -1159,7 +1159,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 expr.span,\n                 format!(\"trans_rvalue_dps_unadjusted reached fall-through \\\n                          case: {}\",\n-                        expr.node).as_slice());\n+                        expr.node)[]);\n         }\n     }\n }\n@@ -1207,7 +1207,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n                 \"Non-DPS def {} referened by {}\",\n-                def, bcx.node_id_to_string(ref_expr.id)).as_slice());\n+                def, bcx.node_id_to_string(ref_expr.id))[]);\n         }\n     }\n }\n@@ -1234,7 +1234,7 @@ fn trans_def_fn_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n                     \"trans_def_fn_unadjusted invoked on: {} for {}\",\n                     def,\n-                    ref_expr.repr(bcx.tcx())).as_slice());\n+                    ref_expr.repr(bcx.tcx()))[]);\n         }\n     };\n \n@@ -1257,7 +1257,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 None => {\n                     bcx.sess().bug(format!(\n                         \"trans_local_var: no llval for upvar {} found\",\n-                        nid).as_slice());\n+                        nid)[]);\n                 }\n             }\n         }\n@@ -1267,7 +1267,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 None => {\n                     bcx.sess().bug(format!(\n                         \"trans_local_var: no datum for local/arg {} found\",\n-                        nid).as_slice());\n+                        nid)[]);\n                 }\n             };\n             debug!(\"take_local(nid={}, v={}, ty={})\",\n@@ -1277,7 +1277,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.sess().unimpl(format!(\n                 \"unsupported def type in trans_local_var: {}\",\n-                def).as_slice());\n+                def)[]);\n         }\n     }\n }\n@@ -1294,11 +1294,11 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n {\n     match ty.sty {\n         ty::ty_struct(did, ref substs) => {\n-            op(0, struct_fields(tcx, did, substs).as_slice())\n+            op(0, struct_fields(tcx, did, substs)[])\n         }\n \n         ty::ty_tup(ref v) => {\n-            op(0, tup_fields(v.as_slice()).as_slice())\n+            op(0, tup_fields(v[])[])\n         }\n \n         ty::ty_enum(_, ref substs) => {\n@@ -1308,7 +1308,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                     tcx.sess.bug(format!(\n                         \"cannot get field types from the enum type {} \\\n                          without a node ID\",\n-                        ty.repr(tcx)).as_slice());\n+                        ty.repr(tcx))[]);\n                 }\n                 Some(node_id) => {\n                     let def = tcx.def_map.borrow()[node_id].clone();\n@@ -1319,7 +1319,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                             op(variant_info.disr_val,\n                                struct_fields(tcx,\n                                              variant_id,\n-                                             substs).as_slice())\n+                                             substs)[])\n                         }\n                         _ => {\n                             tcx.sess.bug(\"resolve didn't map this expr to a \\\n@@ -1333,7 +1333,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n         _ => {\n             tcx.sess.bug(format!(\n                 \"cannot get field types from the type {}\",\n-                ty.repr(tcx)).as_slice());\n+                ty.repr(tcx))[]);\n         }\n     }\n }\n@@ -1388,7 +1388,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         trans_adt(bcx,\n                   ty,\n                   discr,\n-                  numbered_fields.as_slice(),\n+                  numbered_fields[],\n                   optbase,\n                   dest,\n                   Some(NodeInfo { id: expr_id, span: expr_span }))\n@@ -2025,7 +2025,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                             t_in.repr(bcx.tcx()),\n                                             k_in,\n                                             t_out.repr(bcx.tcx()),\n-                                            k_out).as_slice())\n+                                            k_out)[])\n                 }\n             }\n         }\n@@ -2034,7 +2034,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     t_in.repr(bcx.tcx()),\n                                     k_in,\n                                     t_out.repr(bcx.tcx()),\n-                                    k_out).as_slice())\n+                                    k_out)[])\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }\n@@ -2196,7 +2196,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 format!(\"deref invoked on expr of illegal type {}\",\n-                        datum.ty.repr(bcx.tcx())).as_slice());\n+                        datum.ty.repr(bcx.tcx()))[]);\n         }\n     };\n "}, {"sha": "d7e3476a470fb544a1b3c0e55b78594ece43b719", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -106,7 +106,7 @@ pub fn register_static(ccx: &CrateContext,\n     let llty = type_of::type_of(ccx, ty);\n \n     let ident = link_name(foreign_item);\n-    match attr::first_attr_value_str_by_name(foreign_item.attrs.as_slice(),\n+    match attr::first_attr_value_str_by_name(foreign_item.attrs[],\n                                              \"linkage\") {\n         // If this is a static with a linkage specified, then we need to handle\n         // it a little specially. The typesystem prevents things like &T and\n@@ -231,13 +231,13 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ty::ty_bare_fn(ref fn_ty) => (fn_ty.abi, fn_ty.sig.clone()),\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n-    let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys.as_slice());\n+    let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys[]);\n     let fn_type = cabi::compute_abi_info(ccx,\n-                                         llsig.llarg_tys.as_slice(),\n+                                         llsig.llarg_tys[],\n                                          llsig.llret_ty,\n                                          llsig.ret_def);\n \n-    let arg_tys: &[cabi::ArgType] = fn_type.arg_tys.as_slice();\n+    let arg_tys: &[cabi::ArgType] = fn_type.arg_tys[];\n \n     let mut llargs_foreign = Vec::new();\n \n@@ -363,7 +363,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let llforeign_retval = CallWithConv(bcx,\n                                         llfn,\n-                                        llargs_foreign.as_slice(),\n+                                        llargs_foreign[],\n                                         cc,\n                                         Some(attrs));\n \n@@ -433,7 +433,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n                 abi => {\n                     let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n                     register_foreign_item_fn(ccx, abi, ty,\n-                                             lname.get().as_slice());\n+                                             lname.get()[]);\n                     // Unlike for other items, we shouldn't call\n                     // `base::update_linkage` here.  Foreign items have\n                     // special linkage requirements, which are handled\n@@ -563,15 +563,15 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 ccx.sess().bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n                                         expected a bare fn ty\",\n                                        ccx.tcx().map.path_to_string(id),\n-                                       t.repr(tcx)).as_slice());\n+                                       t.repr(tcx))[]);\n             }\n         };\n \n         debug!(\"build_rust_fn: path={} id={} t={}\",\n                ccx.tcx().map.path_to_string(id),\n                id, t.repr(tcx));\n \n-        let llfn = base::decl_internal_rust_fn(ccx, t, ps.as_slice());\n+        let llfn = base::decl_internal_rust_fn(ccx, t, ps[]);\n         base::set_llvm_fn_attrs(ccx, attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, param_substs, id, &[]);\n         llfn\n@@ -744,7 +744,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"calling llrustfn = {}, t = {}\",\n                ccx.tn().val_to_string(llrustfn), t.repr(ccx.tcx()));\n         let attributes = base::get_fn_llvm_attributes(ccx, t);\n-        let llrust_ret_val = builder.call(llrustfn, llrust_args.as_slice(), Some(attributes));\n+        let llrust_ret_val = builder.call(llrustfn, llrust_args[], Some(attributes));\n \n         // Get the return value where the foreign fn expects it.\n         let llforeign_ret_ty = match tys.fn_ty.ret_ty.cast {\n@@ -811,9 +811,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n // the massive simplifications that have occurred.\n \n pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n-    match attr::first_attr_value_str_by_name(i.attrs.as_slice(), \"link_name\") {\n+    match attr::first_attr_value_str_by_name(i.attrs[], \"link_name\") {\n         Some(ln) => ln.clone(),\n-        None => match weak_lang_items::link_name(i.attrs.as_slice()) {\n+        None => match weak_lang_items::link_name(i.attrs[]) {\n             Some(name) => name,\n             None => token::get_ident(i.ident),\n         }\n@@ -854,7 +854,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     };\n     let llsig = foreign_signature(ccx, &fn_sig, fn_sig.0.inputs.as_slice());\n     let fn_ty = cabi::compute_abi_info(ccx,\n-                                       llsig.llarg_tys.as_slice(),\n+                                       llsig.llarg_tys[],\n                                        llsig.llret_ty,\n                                        llsig.ret_def);\n     debug!(\"foreign_types_for_fn_ty(\\\n@@ -863,9 +863,9 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n            ty.repr(ccx.tcx()),\n-           ccx.tn().types_to_str(llsig.llarg_tys.as_slice()),\n+           ccx.tn().types_to_str(llsig.llarg_tys[]),\n            ccx.tn().type_to_string(llsig.llret_ty),\n-           ccx.tn().types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>().as_slice()),\n+           ccx.tn().types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>()[]),\n            ccx.tn().type_to_string(fn_ty.ret_ty.ty),\n            llsig.ret_def);\n \n@@ -915,7 +915,7 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n     if tys.fn_sig.0.variadic {\n         Type::variadic_func(llargument_tys.as_slice(), &llreturn_ty)\n     } else {\n-        Type::func(llargument_tys.as_slice(), &llreturn_ty)\n+        Type::func(llargument_tys[], &llreturn_ty)\n     }\n }\n "}, {"sha": "c1089ea3ad10d042f059d9344bb95239f36bc6a3", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -160,7 +160,7 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n \n     let (glue, new_sym) = match ccx.available_drop_glues().borrow().get(&t) {\n         Some(old_sym) => {\n-            let glue = decl_cdecl_fn(ccx, old_sym.as_slice(), llfnty, ty::mk_nil(ccx.tcx()));\n+            let glue = decl_cdecl_fn(ccx, old_sym[], llfnty, ty::mk_nil(ccx.tcx()));\n             (glue, None)\n         },\n         None => {\n@@ -231,7 +231,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             f.sig.0.inputs[0]\n         }\n         _ => bcx.sess().bug(format!(\"Expected function type, found {}\",\n-                                    bcx.ty_to_string(fty)).as_slice())\n+                                    bcx.ty_to_string(fty))[])\n     };\n \n     let (struct_data, info) = if ty::type_is_sized(bcx.tcx(), t) {\n@@ -350,7 +350,7 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n             (Mul(bcx, info, C_uint(bcx.ccx(), unit_size)), C_uint(bcx.ccx(), 8u))\n         }\n         _ => bcx.sess().bug(format!(\"Unexpected unsized type, found {}\",\n-                                    bcx.ty_to_string(t)).as_slice())\n+                                    bcx.ty_to_string(t))[])\n     }\n }\n \n@@ -422,7 +422,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                         bcx.sess().warn(format!(\"Ignoring drop flag in destructor for {}\\\n                                                  because the struct is unsized. See issue\\\n                                                  #16758\",\n-                                                bcx.ty_to_string(t)).as_slice());\n+                                                bcx.ty_to_string(t))[]);\n                         trans_struct_drop(bcx, t, v0, dtor, did, substs)\n                     }\n                 }\n@@ -504,7 +504,7 @@ pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     note_unique_llvm_symbol(ccx, name);\n \n     let ty_name = token::intern_and_get_ident(\n-        ppaux::ty_to_string(ccx.tcx(), t).as_slice());\n+        ppaux::ty_to_string(ccx.tcx(), t)[]);\n     let ty_name = C_str_slice(ccx, ty_name);\n \n     debug!(\"--- declare_tydesc {}\", ppaux::ty_to_string(ccx.tcx(), t));\n@@ -523,8 +523,8 @@ fn declare_generic_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n     let fn_nm = mangle_internal_name_by_type_and_seq(\n         ccx,\n         t,\n-        format!(\"glue_{}\", name).as_slice());\n-    let llfn = decl_cdecl_fn(ccx, fn_nm.as_slice(), llfnty, ty::mk_nil(ccx.tcx()));\n+        format!(\"glue_{}\", name)[]);\n+    let llfn = decl_cdecl_fn(ccx, fn_nm[], llfnty, ty::mk_nil(ccx.tcx()));\n     note_unique_llvm_symbol(ccx, fn_nm.clone());\n     return (fn_nm, llfn);\n }"}, {"sha": "cc506e409c56e1184f36daf9603dfd34e1884a65", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -118,7 +118,7 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n                             \"\"\n                         } else {\n                             \"s\"\n-                        }).as_slice());\n+                        })[]);\n         }\n         if ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.to) ||\n            ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.from) {"}, {"sha": "25b8cefa68f2f7bed2f0353ecff61830df84c7f0", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -77,7 +77,7 @@ pub fn trans_impl(ccx: &CrateContext,\n         match *impl_item {\n             ast::MethodImplItem(ref method) => {\n                 if method.pe_generics().ty_params.len() == 0u {\n-                    let trans_everywhere = attr::requests_inline(method.attrs.as_slice());\n+                    let trans_everywhere = attr::requests_inline(method.attrs[]);\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, method.id);\n                         trans_fn(ccx,\n@@ -293,7 +293,7 @@ pub fn trans_static_method_callee(bcx: Block,\n         _ => {\n             bcx.tcx().sess.bug(\n                 format!(\"static call to invalid vtable: {}\",\n-                        vtbl.repr(bcx.tcx())).as_slice());\n+                        vtbl.repr(bcx.tcx()))[]);\n         }\n     }\n }\n@@ -375,7 +375,7 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         traits::VtableParam(..) => {\n             bcx.sess().bug(\n                 format!(\"resolved vtable bad vtable {} in trans\",\n-                        vtable.repr(bcx.tcx())).as_slice());\n+                        vtable.repr(bcx.tcx()))[]);\n         }\n     }\n }\n@@ -566,7 +566,7 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx.sess().bug(\n                     format!(\"resolved vtable for {} to bad vtable {} in trans\",\n                             trait_ref.repr(bcx.tcx()),\n-                            vtable.repr(bcx.tcx())).as_slice());\n+                            vtable.repr(bcx.tcx()))[]);\n             }\n         }\n     });\n@@ -598,7 +598,7 @@ pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n     let components: Vec<_> = head.into_iter().chain(ptrs).collect();\n \n     unsafe {\n-        let tbl = C_struct(ccx, components.as_slice(), false);\n+        let tbl = C_struct(ccx, components[], false);\n         let sym = token::gensym(\"vtable\");\n         let vt_gvar = format!(\"vtable{}\", sym.uint()).with_c_str(|buf| {\n             llvm::LLVMAddGlobal(ccx.llmod(), val_ty(tbl).to_ref(), buf)"}, {"sha": "2a6aff56513a16acf6f87b538c393f252b8e228d", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -122,7 +122,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         hash = format!(\"h{}\", state.result());\n         ccx.tcx().map.with_path(fn_id.node, |path| {\n-            exported_name(path, hash.as_slice())\n+            exported_name(path, hash[])\n         })\n     };\n \n@@ -132,9 +132,9 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mut hash_id = Some(hash_id);\n     let mk_lldecl = |abi: abi::Abi| {\n         let lldecl = if abi != abi::Rust {\n-            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, s.as_slice())\n+            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, s[])\n         } else {\n-            decl_internal_rust_fn(ccx, mono_ty, s.as_slice())\n+            decl_internal_rust_fn(ccx, mono_ty, s[])\n         };\n \n         ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n@@ -168,12 +168,12 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   ..\n               } => {\n                   let d = mk_lldecl(abi);\n-                  let needs_body = setup_lldecl(d, i.attrs.as_slice());\n+                  let needs_body = setup_lldecl(d, i.attrs[]);\n                   if needs_body {\n                       if abi != abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n                               ccx, &**decl, &**body, &[], d, psubsts, fn_id.node,\n-                              Some(hash.as_slice()));\n+                              Some(hash[]));\n                       } else {\n                           trans_fn(ccx, &**decl, &**body, d, psubsts, fn_id.node, &[]);\n                       }\n@@ -197,7 +197,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     trans_enum_variant(ccx,\n                                        parent,\n                                        &*v,\n-                                       args.as_slice(),\n+                                       args[],\n                                        this_tv.disr_val,\n                                        psubsts,\n                                        d);\n@@ -211,7 +211,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             match *ii {\n                 ast::MethodImplItem(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, mth.attrs.as_slice());\n+                    let needs_body = setup_lldecl(d, mth.attrs[]);\n                     if needs_body {\n                         trans_fn(ccx,\n                                  mth.pe_fn_decl(),\n@@ -232,7 +232,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             match *method {\n                 ast::ProvidedMethod(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, mth.attrs.as_slice());\n+                    let needs_body = setup_lldecl(d, mth.attrs[]);\n                     if needs_body {\n                         trans_fn(ccx, mth.pe_fn_decl(), mth.pe_body(), d,\n                                  psubsts, mth.id, &[]);\n@@ -241,15 +241,15 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 }\n                 _ => {\n                     ccx.sess().bug(format!(\"can't monomorphize a {}\",\n-                                           map_node).as_slice())\n+                                           map_node)[])\n                 }\n             }\n         }\n         ast_map::NodeStructCtor(struct_def) => {\n             let d = mk_lldecl(abi::Rust);\n             set_inline_hint(d);\n             base::trans_tuple_struct(ccx,\n-                                     struct_def.fields.as_slice(),\n+                                     struct_def.fields[],\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n                                                                 didn't have a ctor id\"),\n                                      psubsts,\n@@ -267,7 +267,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast_map::NodePat(..) |\n         ast_map::NodeLocal(..) => {\n             ccx.sess().bug(format!(\"can't monomorphize a {}\",\n-                                   map_node).as_slice())\n+                                   map_node)[])\n         }\n     };\n "}, {"sha": "45a2a343066c46e5aca02906e2f3473eb14b8a3d", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -102,7 +102,7 @@ impl Type {\n     }\n \n     pub fn int(ccx: &CrateContext) -> Type {\n-        match ccx.tcx().sess.target.target.target_word_size.as_slice() {\n+        match ccx.tcx().sess.target.target.target_word_size[] {\n             \"32\" => Type::i32(ccx),\n             \"64\" => Type::i64(ccx),\n             tws => panic!(\"Unsupported target word size for int: {}\", tws),"}, {"sha": "2ef0006814a12036cc78014ffd01205ed03d92b2", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -137,7 +137,7 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let input_tys = inputs.iter().map(|&arg_ty| type_of_explicit_arg(cx, arg_ty));\n     atys.extend(input_tys);\n \n-    Type::func(atys.as_slice(), &lloutputtype)\n+    Type::func(atys[], &lloutputtype)\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n@@ -187,7 +187,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     let llsizingty = match t.sty {\n         _ if !ty::lltype_is_sized(cx.tcx(), t) => {\n             cx.sess().bug(format!(\"trying to take the sizing type of {}, an unsized type\",\n-                                  ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n+                                  ppaux::ty_to_string(cx.tcx(), t))[])\n         }\n \n         ty::ty_bool => Type::bool(cx),\n@@ -241,7 +241,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n \n         ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n             cx.sess().bug(format!(\"fictitious type {} in sizing_type_of()\",\n-                                  ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n+                                  ppaux::ty_to_string(cx.tcx(), t))[])\n         }\n         ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => panic!(\"unreachable\")\n     };\n@@ -318,7 +318,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           let repr = adt::represent_type(cx, t);\n           let tps = substs.types.get_slice(subst::TypeSpace);\n           let name = llvm_type_name(cx, an_enum, did, tps);\n-          adt::incomplete_type_of(cx, &*repr, name.as_slice())\n+          adt::incomplete_type_of(cx, &*repr, name[])\n       }\n       ty::ty_unboxed_closure(did, _, ref substs) => {\n           // Only create the named struct, but don't fill it in. We\n@@ -329,7 +329,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           // contents of the VecPerParamSpace to to construct the llvm\n           // name\n           let name = llvm_type_name(cx, an_unboxed_closure, did, substs.types.as_slice());\n-          adt::incomplete_type_of(cx, &*repr, name.as_slice())\n+          adt::incomplete_type_of(cx, &*repr, name[])\n       }\n \n       ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n@@ -389,7 +389,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n               let repr = adt::represent_type(cx, t);\n               let tps = substs.types.get_slice(subst::TypeSpace);\n               let name = llvm_type_name(cx, a_struct, did, tps);\n-              adt::incomplete_type_of(cx, &*repr, name.as_slice())\n+              adt::incomplete_type_of(cx, &*repr, name[])\n           }\n       }\n \n@@ -408,7 +408,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           }\n           ty::ty_trait(..) => Type::opaque_trait(cx),\n           _ => cx.sess().bug(format!(\"ty_open with sized type: {}\",\n-                                     ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n+                                     ppaux::ty_to_string(cx.tcx(), t))[])\n       },\n \n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),"}, {"sha": "8e7452f30d38b32bb71cc206ec87c592eda6bd1d", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -168,7 +168,7 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                     format!(\"`{}`\", name)\n                                 } else {\n                                     format!(\"one of `{}`'s {} elided lifetimes\", name, n)\n-                                }.as_slice());\n+                                }[]);\n \n                                 if len == 2 && i == 0 {\n                                     m.push_str(\" or \");\n@@ -323,7 +323,7 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n                                    format!(\"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            required_ty_param_count,\n-                                           supplied_ty_param_count).as_slice());\n+                                           supplied_ty_param_count)[]);\n     } else if supplied_ty_param_count > formal_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at most\"\n@@ -334,7 +334,7 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n                                    format!(\"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            formal_ty_param_count,\n-                                           supplied_ty_param_count).as_slice());\n+                                           supplied_ty_param_count)[]);\n     }\n \n     if supplied_ty_param_count > required_ty_param_count\n@@ -723,7 +723,7 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                         .sess\n                         .span_bug(ast_ty.span,\n                                   format!(\"unbound path {}\",\n-                                          path.repr(this.tcx())).as_slice())\n+                                          path.repr(this.tcx()))[])\n                 }\n                 Some(&d) => d\n             };\n@@ -920,10 +920,10 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n-                match ast_ty_to_trait_ref(this, rscope, &**ty, bounds.as_slice()) {\n+                match ast_ty_to_trait_ref(this, rscope, &**ty, bounds[]) {\n                     Ok(trait_ref) => {\n                         trait_ref_to_object_type(this, rscope, ast_ty.span,\n-                                                 trait_ref, bounds.as_slice())\n+                                                 trait_ref, bounds[])\n                     }\n                     Err(ErrorReported) => {\n                         ty::mk_err()\n@@ -977,15 +977,15 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 ty::mk_closure(tcx, fn_decl)\n             }\n             ast::TyPolyTraitRef(ref bounds) => {\n-                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds.as_slice())\n+                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds[])\n             }\n             ast::TyPath(ref path, id) => {\n                 let a_def = match tcx.def_map.borrow().get(&id) {\n                     None => {\n                         tcx.sess\n                            .span_bug(ast_ty.span,\n                                      format!(\"unbound path {}\",\n-                                             path.repr(tcx)).as_slice())\n+                                             path.repr(tcx))[])\n                     }\n                     Some(&d) => d\n                 };\n@@ -1019,7 +1019,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     def::DefMod(id) => {\n                         tcx.sess.span_fatal(ast_ty.span,\n                             format!(\"found module name used as a type: {}\",\n-                                    tcx.map.node_to_string(id.node)).as_slice());\n+                                    tcx.map.node_to_string(id.node))[]);\n                     }\n                     def::DefPrimTy(_) => {\n                         panic!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n@@ -1038,7 +1038,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                           .last()\n                                                           .unwrap()\n                                                           .identifier)\n-                                                  .get()).as_slice());\n+                                                  .get())[]);\n                         ty::mk_err()\n                     }\n                     def::DefAssociatedPath(typ, assoc_ident) => {\n@@ -1084,7 +1084,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                         tcx.sess.span_fatal(ast_ty.span,\n                                             format!(\"found value name used \\\n                                                      as a type: {}\",\n-                                                    a_def).as_slice());\n+                                                    a_def)[]);\n                     }\n                 }\n             }\n@@ -1112,7 +1112,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                             ast_ty.span,\n                             format!(\"expected constant expr for array \\\n                                      length: {}\",\n-                                    *r).as_slice());\n+                                    *r)[]);\n                     }\n                 }\n             }\n@@ -1235,7 +1235,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n     let input_params = if self_ty.is_some() {\n         decl.inputs.slice_from(1)\n     } else {\n-        decl.inputs.as_slice()\n+        decl.inputs[]\n     };\n     let input_tys = input_params.iter().map(|a| ty_of_arg(this, &rb, a, None));\n     let input_pats: Vec<String> = input_params.iter()\n@@ -1502,7 +1502,7 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n         this.tcx().sess.span_err(\n             b.trait_ref.path.span,\n             format!(\"only the builtin traits can be used \\\n-                     as closure or object bounds\").as_slice());\n+                     as closure or object bounds\")[]);\n     }\n \n     let region_bound = compute_region_bound(this,\n@@ -1572,7 +1572,7 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n         tcx.sess.span_err(\n             span,\n             format!(\"ambiguous lifetime bound, \\\n-                     explicit lifetime bound required\").as_slice());\n+                     explicit lifetime bound required\")[]);\n     }\n     return Some(r);\n }\n@@ -1598,7 +1598,7 @@ fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n                 None => {\n                     this.tcx().sess.span_err(\n                         span,\n-                        format!(\"explicit lifetime bound required\").as_slice());\n+                        format!(\"explicit lifetime bound required\")[]);\n                     ty::ReStatic\n                 }\n             }"}, {"sha": "74e690bf68f399b23d606694cf91bfc91bf3567a", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -269,7 +269,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                 span,\n                                 format!(\n                                     \"trait method is &self but first arg is: {}\",\n-                                    transformed_self_ty.repr(fcx.tcx())).as_slice());\n+                                    transformed_self_ty.repr(fcx.tcx()))[]);\n                         }\n                     }\n                 }\n@@ -279,7 +279,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                         span,\n                         format!(\n                             \"unexpected explicit self type in operator method: {}\",\n-                            method_ty.explicit_self).as_slice());\n+                            method_ty.explicit_self)[]);\n                 }\n             }\n         }\n@@ -333,7 +333,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if is_field {\n                 cx.sess.span_note(span,\n                     format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                            function stored in the `{0}` field\", method_ustring).as_slice());\n+                            function stored in the `{0}` field\", method_ustring)[]);\n             }\n \n             if static_sources.len() > 0 {"}, {"sha": "961b664e404caeed7a5940a0a203eb8e045ff4ff", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -557,7 +557,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     self.tcx().sess.span_bug(\n                         self.span,\n                         format!(\"No entry for unboxed closure: {}\",\n-                                closure_def_id.repr(self.tcx())).as_slice());\n+                                closure_def_id.repr(self.tcx()))[]);\n                 }\n             };\n "}, {"sha": "6b7ca399ad212892347d5be5dcf68f8a6261732c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -518,7 +518,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     // The free region references will be bound the node_id of the body block.\n     let fn_sig = liberate_late_bound_regions(tcx, CodeExtent::from_node_id(body.id), fn_sig);\n \n-    let arg_tys = fn_sig.inputs.as_slice();\n+    let arg_tys = fn_sig.inputs[];\n     let ret_ty = fn_sig.output;\n \n     debug!(\"check_fn(arg_tys={}, ret_ty={}, fn_id={})\",\n@@ -616,7 +616,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n       ast::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n-                            enum_definition.variants.as_slice(),\n+                            enum_definition.variants[],\n                             it.id);\n       }\n       ast::ItemFn(ref decl, _, _, _, ref body) => {\n@@ -915,7 +915,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                         but not in the trait\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &impl_m.explicit_self)).as_slice());\n+                            &impl_m.explicit_self))[]);\n             return;\n         }\n         (_, &ty::StaticExplicitSelfCategory) => {\n@@ -925,7 +925,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                         but not in the impl\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &trait_m.explicit_self)).as_slice());\n+                            &trait_m.explicit_self))[]);\n             return;\n         }\n         _ => {\n@@ -1229,7 +1229,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 span,\n                 format!(\"lifetime parameters or bounds on method `{}` do \\\n                          not match the trait declaration\",\n-                        token::get_name(impl_m.name)).as_slice());\n+                        token::get_name(impl_m.name))[]);\n             return false;\n         }\n \n@@ -1281,7 +1281,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                          from its counterpart `{}` \\\n                          declared in the trait\",\n                         impl_param.name.user_string(tcx),\n-                        trait_param.name.user_string(tcx)).as_slice());\n+                        trait_param.name.user_string(tcx))[]);\n                 true\n             } else {\n                 false\n@@ -1291,14 +1291,14 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 tcx.sess.span_note(\n                     span,\n                     format!(\"the impl is missing the following bounds: `{}`\",\n-                            missing.user_string(tcx)).as_slice());\n+                            missing.user_string(tcx))[]);\n             }\n \n             if extra.len() != 0 {\n                 tcx.sess.span_note(\n                     span,\n                     format!(\"the impl has the following extra bounds: `{}`\",\n-                            extra.user_string(tcx)).as_slice());\n+                            extra.user_string(tcx))[]);\n             }\n \n             if err {\n@@ -1557,7 +1557,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     span,\n                     format!(\"no type for local variable {}\",\n-                            nid).as_slice());\n+                            nid)[]);\n             }\n         }\n     }\n@@ -1805,7 +1805,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(format!(\"no type for expr in fcx {}\",\n-                                            self.tag()).as_slice());\n+                                            self.tag())[]);\n             }\n         }\n     }\n@@ -1835,7 +1835,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx().sess.bug(\n                     format!(\"no type for node {}: {} in fcx {}\",\n                             id, self.tcx().map.node_to_string(id),\n-                            self.tag()).as_slice());\n+                            self.tag())[]);\n             }\n         }\n     }\n@@ -2392,7 +2392,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Ok(trait_did) => trait_did,\n         Err(ref err_string) => {\n             fcx.tcx().sess.span_err(iterator_expr.span,\n-                                    err_string.as_slice());\n+                                    err_string[]);\n             return ty::mk_err()\n         }\n     };\n@@ -2419,7 +2419,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                         format!(\"`for` loop expression has type `{}` which does \\\n                                                 not implement the `Iterator` trait; \\\n                                                 maybe try .iter()\",\n-                                                ty_string).as_slice());\n+                                                ty_string)[]);\n             }\n             ty::mk_err()\n         }\n@@ -2457,7 +2457,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                             format!(\"`next` method of the `Iterator` \\\n                                                     trait has an unexpected type `{}`\",\n                                                     fcx.infcx().ty_to_string(return_type))\n-                                            .as_slice());\n+                                            []);\n                     ty::mk_err()\n                 }\n             }\n@@ -2484,7 +2484,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         check_argument_types(fcx,\n                              sp,\n-                             err_inputs.as_slice(),\n+                             err_inputs[],\n                              callee_expr,\n                              args_no_rcvr,\n                              autoref_args,\n@@ -2941,7 +2941,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         // Call the generic checker.\n         check_argument_types(fcx,\n                              call_expr.span,\n-                             fn_sig.inputs.as_slice(),\n+                             fn_sig.inputs[],\n                              f,\n                              args,\n                              AutorefArgs::No,\n@@ -3306,7 +3306,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::ty_struct(base_id, ref substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n-                        lookup_field_ty(tcx, base_id, fields.as_slice(),\n+                        lookup_field_ty(tcx, base_id, fields[],\n                                         field.node.name, &(*substs))\n                     }\n                     _ => None\n@@ -3369,7 +3369,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         if tuple_like {\n                             debug!(\"tuple struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                             let fields = ty::lookup_struct_fields(tcx, base_id);\n-                            lookup_tup_field_ty(tcx, base_id, fields.as_slice(),\n+                            lookup_tup_field_ty(tcx, base_id, fields[],\n                                                 idx.node, &(*substs))\n                         } else {\n                             None\n@@ -3522,7 +3522,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        class_id,\n                                        id,\n                                        struct_substs,\n-                                       class_fields.as_slice(),\n+                                       class_fields[],\n                                        fields,\n                                        base_expr.is_none());\n         if ty::type_is_error(fcx.node_ty(id)) {\n@@ -3564,7 +3564,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        variant_id,\n                                        id,\n                                        substitutions,\n-                                       variant_fields.as_slice(),\n+                                       variant_fields[],\n                                        fields,\n                                        true);\n         fcx.write_ty(id, enum_type);\n@@ -3936,8 +3936,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           let f_ty = fcx.expr_ty(&**f);\n \n           let args: Vec<_> = args.iter().map(|x| x).collect();\n-          if !try_overloaded_call(fcx, expr, &**f, f_ty, args.as_slice()) {\n-              check_call(fcx, expr, &**f, args.as_slice());\n+          if !try_overloaded_call(fcx, expr, &**f, f_ty, args[]) {\n+              check_call(fcx, expr, &**f, args[]);\n               let args_err = args.iter().fold(false,\n                  |rest_err, a| {\n                      // is this not working?\n@@ -3949,7 +3949,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           }\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n-        check_method_call(fcx, expr, ident, args.as_slice(), tps.as_slice(), lvalue_pref);\n+        check_method_call(fcx, expr, ident, args[], tps[], lvalue_pref);\n         let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n         let  args_err = arg_tys.fold(false,\n              |rest_err, a| {\n@@ -4074,7 +4074,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let struct_id = match def {\n             Some(def::DefVariant(enum_id, variant_id, true)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n-                                          variant_id, fields.as_slice());\n+                                          variant_id, fields[]);\n                 enum_id\n             }\n             Some(def::DefTrait(def_id)) => {\n@@ -4083,7 +4083,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     pprust::path_to_string(path));\n                 check_struct_fields_on_error(fcx,\n                                              id,\n-                                             fields.as_slice(),\n+                                             fields[],\n                                              base_expr);\n                 def_id\n             },\n@@ -4096,7 +4096,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                  id,\n                                                  expr.span,\n                                                  struct_did,\n-                                                 fields.as_slice(),\n+                                                 fields[],\n                                                  base_expr.as_ref().map(|e| &**e));\n                     }\n                     _ => {\n@@ -4105,7 +4105,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             pprust::path_to_string(path));\n                         check_struct_fields_on_error(fcx,\n                                                      id,\n-                                                     fields.as_slice(),\n+                                                     fields[],\n                                                      base_expr);\n                     }\n                 }\n@@ -4146,7 +4146,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                          fcx.infcx()\n                                             .ty_to_string(\n                                                 actual_structure_type),\n-                                         type_error_description).as_slice());\n+                                         type_error_description)[]);\n                     ty::note_and_explain_type_err(tcx, &type_error);\n                 }\n             }\n@@ -4755,7 +4755,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     }\n \n     let hint = *ty::lookup_repr_hints(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n-                    .as_slice().get(0).unwrap_or(&attr::ReprAny);\n+                    [].get(0).unwrap_or(&attr::ReprAny);\n \n     if hint != attr::ReprAny && vs.len() <= 1 {\n         if vs.len() == 1 {\n@@ -5438,7 +5438,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n                   Ok(t) => t,\n-                  Err(s) => { tcx.sess.span_fatal(it.span, s.as_slice()); }\n+                  Err(s) => { tcx.sess.span_fatal(it.span, s[]); }\n               };\n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n                   ty: tydesc_ty,\n@@ -5454,7 +5454,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                                 ty::mk_struct(ccx.tcx, did,\n                                               subst::Substs::empty())),\n                     Err(msg) => {\n-                        tcx.sess.span_fatal(it.span, msg.as_slice());\n+                        tcx.sess.span_fatal(it.span, msg[]);\n                     }\n                 }\n             },"}, {"sha": "22502c0dd1a1f6b836eb90008e05df5934c98ec8", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -251,7 +251,7 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n         }\n         _ => {\n             tcx.sess.bug(format!(\"unexpected def in region_of_def: {}\",\n-                                 def).as_slice())\n+                                 def)[])\n         }\n     }\n }\n@@ -345,13 +345,13 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             Some(f) => f,\n             None => {\n                 self.tcx().sess.bug(\n-                    format!(\"No fn-sig entry for id={}\", id).as_slice());\n+                    format!(\"No fn-sig entry for id={}\", id)[]);\n             }\n         };\n \n         let len = self.region_param_pairs.len();\n-        self.relate_free_regions(fn_sig.as_slice(), body.id);\n-        link_fn_args(self, CodeExtent::from_node_id(body.id), fn_decl.inputs.as_slice());\n+        self.relate_free_regions(fn_sig[], body.id);\n+        link_fn_args(self, CodeExtent::from_node_id(body.id), fn_decl.inputs[]);\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n         self.region_param_pairs.truncate(len);\n@@ -738,7 +738,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         }\n \n         ast::ExprMatch(ref discr, ref arms, _) => {\n-            link_match(rcx, &**discr, arms.as_slice());\n+            link_match(rcx, &**discr, arms[]);\n \n             visit::walk_expr(rcx, expr);\n         }\n@@ -1186,7 +1186,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                     ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                     _ => rcx.tcx().sess.span_bug(deref_expr.span,\n                             format!(\"bad overloaded deref type {}\",\n-                                    method.ty.repr(rcx.tcx())).as_slice())\n+                                    method.ty.repr(rcx.tcx()))[])\n                 };\n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx);\n@@ -1560,7 +1560,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                         span,\n                         format!(\"Illegal upvar id: {}\",\n                                 upvar_id.repr(\n-                                    rcx.tcx())).as_slice());\n+                                    rcx.tcx()))[]);\n                 }\n             }\n         }"}, {"sha": "eaf638e388e3505d330d71f390acafab409cd2ec", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n             ty::ty_open(_) => {\n                 self.tcx.sess.bug(\n                     format!(\"Unexpected type encountered while doing wf check: {}\",\n-                            ty.repr(self.tcx)).as_slice());\n+                            ty.repr(self.tcx))[]);\n             }\n         }\n     }"}, {"sha": "e23bf46b564b37dba9296a5b87cce0aab9edc3cf", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -77,15 +77,15 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 source_expr.span,\n                 format!(\"can only cast an boxed pointer \\\n                          to a boxed object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty)).as_slice());\n+                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n         }\n \n         (_, &ty::ty_rptr(..)) => {\n             fcx.ccx.tcx.sess.span_err(\n                 source_expr.span,\n                 format!(\"can only cast a &-pointer \\\n                          to an &-object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty)).as_slice());\n+                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n         }\n \n         _ => {\n@@ -164,7 +164,7 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n             trait_name);\n \n         for msg in errors {\n-            tcx.sess.note(msg.as_slice());\n+            tcx.sess.note(msg[]);\n         }\n     }\n \n@@ -455,7 +455,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     format!(\n                         \"unable to infer enough type information about `{}`; type annotations \\\n                          required\",\n-                        self_ty.user_string(fcx.tcx())).as_slice());\n+                        self_ty.user_string(fcx.tcx()))[]);\n             } else {\n                 fcx.tcx().sess.span_err(\n                     obligation.cause.span,\n@@ -464,7 +464,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                          locate the impl of the trait `{}` for \\\n                          the type `{}`; type annotations required\",\n                         trait_ref.user_string(fcx.tcx()),\n-                        self_ty.user_string(fcx.tcx())).as_slice());\n+                        self_ty.user_string(fcx.tcx()))[]);\n                 note_obligation_cause(fcx, obligation);\n             }\n         }\n@@ -477,7 +477,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                  cannot locate the impl of the trait `{}` for \\\n                  the type `{}`\",\n                 trait_ref.user_string(fcx.tcx()),\n-                self_ty.user_string(fcx.tcx())).as_slice());\n+                self_ty.user_string(fcx.tcx()))[]);\n     }\n }\n "}, {"sha": "c08eeb6e13eea56eed4e91941bc707e6883f64b9", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -488,15 +488,15 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                  format!(\"the trait `Copy` may not be \\\n                                           implemented for this type; field \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name)).as_slice())\n+                                         token::get_name(name))[])\n                 }\n                 Err(ty::VariantDoesNotImplementCopy(name)) => {\n                     tcx.sess\n                        .span_err(span,\n                                  format!(\"the trait `Copy` may not be \\\n                                           implemented for this type; variant \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name)).as_slice())\n+                                         token::get_name(name))[])\n                 }\n                 Err(ty::TypeIsStructural) => {\n                     tcx.sess"}, {"sha": "22c9a2e7b3292c4e63c2bf2b83540d46ab51d94d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -171,7 +171,7 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n             x => {\n                 self.tcx.sess.bug(format!(\"unexpected sort of node \\\n                                            in get_item_ty(): {}\",\n-                                          x).as_slice());\n+                                          x)[]);\n             }\n         }\n     }\n@@ -217,7 +217,7 @@ pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n                 let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, &*va.ty)).collect();\n-                ty::mk_ctor_fn(tcx, input_tys.as_slice(), enum_ty)\n+                ty::mk_ctor_fn(tcx, input_tys[], enum_ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n@@ -270,7 +270,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     ccx,\n                                     trait_id,\n                                     &trait_def.generics,\n-                                    trait_items.as_slice(),\n+                                    trait_items[],\n                                     &m.id,\n                                     &m.ident.name,\n                                     &m.explicit_self,\n@@ -284,7 +284,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     ccx,\n                                     trait_id,\n                                     &trait_def.generics,\n-                                    trait_items.as_slice(),\n+                                    trait_items[],\n                                     &m.id,\n                                     &m.pe_ident().name,\n                                     m.pe_explicit_self(),\n@@ -379,7 +379,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let tmcx = TraitMethodCtxt {\n                 ccx: ccx,\n                 trait_id: local_def(trait_id),\n-                trait_items: trait_items.as_slice(),\n+                trait_items: trait_items[],\n                 method_generics: &ty_generics,\n             };\n             let trait_self_ty = ty::mk_self_type(tmcx.tcx(),\n@@ -1040,7 +1040,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             write_ty_to_tcx(tcx, it.id, pty.ty);\n             get_enum_variant_types(ccx,\n                                    pty.ty,\n-                                   enum_definition.variants.as_slice(),\n+                                   enum_definition.variants[],\n                                    generics);\n         },\n         ast::ItemImpl(_,\n@@ -1086,7 +1086,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                                             ast_trait_ref.ref_id).def_id())\n                     }\n                 },\n-                impl_items: impl_items.as_slice(),\n+                impl_items: impl_items[],\n                 impl_generics: &ty_generics,\n             };\n \n@@ -1184,7 +1184,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                                                          local_def(it.id));\n             let convert_method_context =\n                 TraitConvertMethodContext(local_def(it.id),\n-                                          trait_methods.as_slice());\n+                                          trait_methods[]);\n             convert_methods(ccx,\n                             convert_method_context,\n                             TraitContainer(local_def(it.id)),\n@@ -1279,7 +1279,7 @@ pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         |field| (*tcx.tcache.borrow())[\n                             local_def(field.node.id)].ty).collect();\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n-                                                inputs.as_slice(),\n+                                                inputs[],\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id),\n@@ -1320,7 +1320,7 @@ fn get_trait_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n         _ => {\n             ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n-                                     trait_id.node).as_slice())\n+                                     trait_id.node)[])\n         }\n     }\n }\n@@ -1345,7 +1345,7 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ref s => {\n             tcx.sess.span_bug(\n                 it.span,\n-                format!(\"trait_def_of_item invoked on {}\", s).as_slice());\n+                format!(\"trait_def_of_item invoked on {}\", s)[]);\n         }\n     };\n \n@@ -1585,8 +1585,8 @@ fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                           -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n                 subst::TypeSpace,\n-                generics.lifetimes.as_slice(),\n-                generics.ty_params.as_slice(),\n+                generics.lifetimes[],\n+                generics.ty_params[],\n                 ty::Generics::empty(),\n                 &generics.where_clause,\n                 create_type_parameters_for_associated_types)\n@@ -1602,8 +1602,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let mut generics =\n         ty_generics(ccx,\n                     subst::TypeSpace,\n-                    ast_generics.lifetimes.as_slice(),\n-                    ast_generics.ty_params.as_slice(),\n+                    ast_generics.lifetimes[],\n+                    ast_generics.ty_params[],\n                     ty::Generics::empty(),\n                     &ast_generics.where_clause,\n                     DontCreateTypeParametersForAssociatedTypes);\n@@ -1672,8 +1672,8 @@ fn ty_generics_for_fn_or_method<'tcx,AC>(\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n     ty_generics(this,\n                 subst::FnSpace,\n-                early_lifetimes.as_slice(),\n-                generics.ty_params.as_slice(),\n+                early_lifetimes[],\n+                generics.ty_params[],\n                 base_generics,\n                 &generics.where_clause,\n                 create_type_parameters_for_associated_types)\n@@ -1701,7 +1701,7 @@ fn add_unsized_bound<'tcx,AC>(this: &AC,\n                                                        a default. \\\n                                                        Only `Sized?` is \\\n                                                        supported\",\n-                                                      desc).as_slice());\n+                                                      desc)[]);\n                     ty::try_add_builtin_trait(this.tcx(),\n                                               kind_id,\n                                               bounds);\n@@ -1973,7 +1973,7 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n     let bounds = compute_bounds(this,\n                                 param.ident.name,\n                                 param_ty,\n-                                param.bounds.as_slice(),\n+                                param.bounds[],\n                                 &param.unbound,\n                                 param.span);\n     let default = match param.default {\n@@ -2054,7 +2054,7 @@ fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n         ty::each_bound_trait_and_supertraits(\n             tcx,\n-            param_bounds.trait_bounds.as_slice(),\n+            param_bounds.trait_bounds[],\n             |trait_ref| {\n                 let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id());\n                 if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {"}, {"sha": "5a8f58274cceaae6a237d510377875ceec6ab8ee", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -196,7 +196,7 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n                               format!(\"{}: {}\",\n                                       msg(),\n                                       ty::type_err_to_str(tcx,\n-                                                          terr)).as_slice());\n+                                                          terr))[]);\n             ty::note_and_explain_type_err(tcx, terr);\n             false\n         }\n@@ -245,7 +245,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                               format!(\"main has a non-function type: found \\\n                                        `{}`\",\n                                       ppaux::ty_to_string(tcx,\n-                                                       main_t)).as_slice());\n+                                                       main_t))[]);\n         }\n     }\n }\n@@ -296,8 +296,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             tcx.sess.span_bug(start_span,\n                               format!(\"start has a non-function type: found \\\n                                        `{}`\",\n-                                      ppaux::ty_to_string(tcx,\n-                                                       start_t)).as_slice());\n+                                      ppaux::ty_to_string(tcx, start_t))[]);\n         }\n     }\n }"}, {"sha": "754294a3b8e41427ddca3d24411006194bba9cb0", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -556,7 +556,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             None => {\n                 self.tcx().sess.bug(format!(\n                         \"no inferred index entry for {}\",\n-                        self.tcx().map.node_to_string(param_id)).as_slice());\n+                        self.tcx().map.node_to_string(param_id))[]);\n             }\n         }\n     }\n@@ -834,7 +834,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.tcx().sess.bug(\n                     format!(\"unexpected type encountered in \\\n                             variance inference: {}\",\n-                            ty.repr(self.tcx())).as_slice());\n+                            ty.repr(self.tcx()))[]);\n             }\n         }\n     }\n@@ -911,7 +911,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     .sess\n                     .bug(format!(\"unexpected region encountered in variance \\\n                                   inference: {}\",\n-                                 region.repr(self.tcx())).as_slice());\n+                                 region.repr(self.tcx()))[]);\n             }\n         }\n     }\n@@ -1046,7 +1046,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             // attribute and report an error with various results if found.\n             if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n                 let found = item_variances.repr(tcx);\n-                tcx.sess.span_err(tcx.map.span(item_id), found.as_slice());\n+                tcx.sess.span_err(tcx.map.span(item_id), found[]);\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()"}, {"sha": "25a20e5998bd8ff8a6d80bd9219c07ba229af60e", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -36,7 +36,7 @@ impl ExternalHtml {\n pub fn load_string(input: &Path) -> io::IoResult<Option<String>> {\n     let mut f = try!(io::File::open(input));\n     let d = try!(f.read_to_end());\n-    Ok(str::from_utf8(d.as_slice()).map(|s| s.to_string()))\n+    Ok(str::from_utf8(d.as_slice()).map(|s| s.to_string()).ok())\n }\n \n macro_rules! load_or_return {"}, {"sha": "a2d5530692c11cbe5171e1502716d8e057b04cd1", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -16,7 +16,7 @@\n //! them in the future to instead emit any format desired.\n \n use std::fmt;\n-use std::string::String;\n+use std::iter::repeat;\n \n use syntax::ast;\n use syntax::ast_util;\n@@ -198,12 +198,12 @@ fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, p: &clean::Path,\n     path(w, p, print_all,\n         |cache, loc| {\n             if ast_util::is_local(did) || cache.inlined.contains(&did) {\n-                Some((\"../\".repeat(loc.len())).to_string())\n+                Some(repeat(\"../\").take(loc.len()).collect::<String>())\n             } else {\n                 match cache.extern_locations[did.krate] {\n                     render::Remote(ref s) => Some(s.to_string()),\n                     render::Local => {\n-                        Some((\"../\".repeat(loc.len())).to_string())\n+                        Some(repeat(\"../\").take(loc.len()).collect::<String>())\n                     }\n                     render::Unknown => None,\n                 }\n@@ -324,7 +324,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n             let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n             let len = if len == 0 {0} else {len - 1};\n             try!(write!(f, \"<a href='{}primitive.{}.html'>\",\n-                        \"../\".repeat(len),\n+                        repeat(\"../\").take(len).collect::<String>(),\n                         prim.to_url_str()));\n             needs_termination = true;\n         }\n@@ -337,7 +337,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n                 render::Remote(ref s) => Some(s.to_string()),\n                 render::Local => {\n                     let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n-                    Some(\"../\".repeat(len))\n+                    Some(repeat(\"../\").take(len).collect::<String>())\n                 }\n                 render::Unknown => None,\n             };"}, {"sha": "c936f6a0819d2c797dc959e66a156a49015aeea1", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -34,7 +34,7 @@ pub fn highlight(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n          class,\n          id,\n          &mut out).unwrap();\n-    String::from_utf8_lossy(out[]).into_string()\n+    String::from_utf8_lossy(out[]).into_owned()\n }\n \n /// Exhausts the `lexer` writing the output into `out`."}, {"sha": "dc31cfae99cb41a99fefcf0cd5e9335bfc5cb230", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -42,8 +42,8 @@ use std::fmt;\n use std::io::fs::PathExtensions;\n use std::io::{fs, File, BufferedWriter, BufferedReader};\n use std::io;\n+use std::iter::repeat;\n use std::str;\n-use std::string::String;\n use std::sync::Arc;\n \n use externalfiles::ExternalHtml;\n@@ -1186,7 +1186,8 @@ impl Context {\n                                     &Sidebar{ cx: cx, item: it },\n                                     &Item{ cx: cx, item: it }));\n             } else {\n-                let mut url = \"../\".repeat(cx.current.len());\n+                let mut url = repeat(\"../\").take(cx.current.len())\n+                                           .collect::<String>();\n                 match cache().paths.get(&it.def_id) {\n                     Some(&(ref names, _)) => {\n                         for name in names[..names.len() - 1].iter() {\n@@ -1382,7 +1383,8 @@ impl<'a> fmt::Show for Item<'a> {\n             let amt = if self.ismodule() { cur.len() - 1 } else { cur.len() };\n             for (i, component) in cur.iter().enumerate().take(amt) {\n                 try!(write!(fmt, \"<a href='{}index.html'>{}</a>::<wbr>\",\n-                            \"../\".repeat(cur.len() - i - 1),\n+                            repeat(\"../\").take(cur.len() - i - 1)\n+                                         .collect::<String>(),\n                             component.as_slice()));\n             }\n         }"}, {"sha": "9a67b479106eed4fa762736e9cd986299219b4ed", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -319,7 +319,7 @@ pub fn unindent(s: &str) -> String {\n         let ignore_previous_indents =\n             saw_first_line &&\n             !saw_second_line &&\n-            !line.is_whitespace();\n+            !line.chars().all(|c| c.is_whitespace());\n \n         let min_indent = if ignore_previous_indents {\n             uint::MAX\n@@ -331,7 +331,7 @@ pub fn unindent(s: &str) -> String {\n             saw_second_line = true;\n         }\n \n-        if line.is_whitespace() {\n+        if line.chars().all(|c| c.is_whitespace()) {\n             min_indent\n         } else {\n             saw_first_line = true;\n@@ -353,7 +353,7 @@ pub fn unindent(s: &str) -> String {\n     if lines.len() >= 1 {\n         let mut unindented = vec![ lines[0].trim().to_string() ];\n         unindented.push_all(lines.tail().iter().map(|&line| {\n-            if line.is_whitespace() {\n+            if line.chars().all(|c| c.is_whitespace()) {\n                 line.to_string()\n             } else {\n                 assert!(line.len() >= min_indent);"}, {"sha": "c4f071994dc9cd4747bd0426026003d301058b2a", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 96, "deletions": 96, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -202,10 +202,11 @@ use std::collections::{HashMap, BTreeMap};\n use std::{char, f64, fmt, io, num, str};\n use std::mem::{swap, transmute};\n use std::num::{Float, FPNaN, FPInfinite, Int};\n-use std::str::{FromStr, ScalarValue};\n+use std::str::{FromStr};\n use std::string;\n-use std::vec::Vec;\n use std::ops;\n+use unicode::str as unicode_str;\n+use unicode::str::Utf16Item;\n \n use Encodable;\n \n@@ -1001,7 +1002,7 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_string<'a>(&'a self) -> Option<&'a str> {\n         match *self {\n-            Json::String(ref s) => Some(s.as_slice()),\n+            Json::String(ref s) => Some(s[]),\n             _ => None\n         }\n     }\n@@ -1585,8 +1586,8 @@ impl<T: Iterator<char>> Parser<T> {\n                             }\n \n                             let buf = [n1, try!(self.decode_hex_escape())];\n-                            match str::utf16_items(buf.as_slice()).next() {\n-                                Some(ScalarValue(c)) => res.push(c),\n+                            match unicode_str::utf16_items(&buf).next() {\n+                                Some(Utf16Item::ScalarValue(c)) => res.push(c),\n                                 _ => return self.error(LoneLeadingSurrogateInHexEscape),\n                             }\n                         }\n@@ -1934,7 +1935,7 @@ pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, BuilderError> {\n         Ok(c)  => c,\n         Err(e) => return Err(io_error_to_error(e))\n     };\n-    let s = match str::from_utf8(contents.as_slice()) {\n+    let s = match str::from_utf8(contents.as_slice()).ok() {\n         Some(s) => s,\n         _       => return Err(SyntaxError(NotUtf8, 0, 0))\n     };\n@@ -1970,7 +1971,7 @@ macro_rules! expect {\n     ($e:expr, Null) => ({\n         match $e {\n             Json::Null => Ok(()),\n-            other => Err(ExpectedError(\"Null\".into_string(),\n+            other => Err(ExpectedError(\"Null\".to_string(),\n                                        format!(\"{}\", other)))\n         }\n     });\n@@ -1991,20 +1992,20 @@ macro_rules! read_primitive {\n             match self.pop() {\n                 Json::I64(f) => match num::cast(f) {\n                     Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".into_string(), format!(\"{}\", f))),\n+                    None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n                 },\n                 Json::U64(f) => match num::cast(f) {\n                     Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".into_string(), format!(\"{}\", f))),\n+                    None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n                 },\n-                Json::F64(f) => Err(ExpectedError(\"Integer\".into_string(), format!(\"{}\", f))),\n+                Json::F64(f) => Err(ExpectedError(\"Integer\".to_string(), format!(\"{}\", f))),\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n                 Json::String(s) => match std::str::from_str(s.as_slice()) {\n                     Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".into_string(), s)),\n+                    None => Err(ExpectedError(\"Number\".to_string(), s)),\n                 },\n-                value => Err(ExpectedError(\"Number\".into_string(), format!(\"{}\", value))),\n+                value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value))),\n             }\n         }\n     }\n@@ -2036,13 +2037,13 @@ impl ::Decoder<DecoderError> for Decoder {\n             Json::String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n-                match std::str::from_str(s.as_slice()) {\n+                match s.parse() {\n                     Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".into_string(), s)),\n+                    None => Err(ExpectedError(\"Number\".to_string(), s)),\n                 }\n             },\n             Json::Null => Ok(f64::NAN),\n-            value => Err(ExpectedError(\"Number\".into_string(), format!(\"{}\", value)))\n+            value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value)))\n         }\n     }\n \n@@ -2060,7 +2061,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                 _ => ()\n             }\n         }\n-        Err(ExpectedError(\"single character string\".into_string(), format!(\"{}\", s)))\n+        Err(ExpectedError(\"single character string\".to_string(), format!(\"{}\", s)))\n     }\n \n     fn read_str(&mut self) -> DecodeResult<string::String> {\n@@ -2080,36 +2081,35 @@ impl ::Decoder<DecoderError> for Decoder {\n         let name = match self.pop() {\n             Json::String(s) => s,\n             Json::Object(mut o) => {\n-                let n = match o.remove(&\"variant\".into_string()) {\n+                let n = match o.remove(&\"variant\".to_string()) {\n                     Some(Json::String(s)) => s,\n                     Some(val) => {\n-                        return Err(ExpectedError(\"String\".into_string(), format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"String\".to_string(), format!(\"{}\", val)))\n                     }\n                     None => {\n-                        return Err(MissingFieldError(\"variant\".into_string()))\n+                        return Err(MissingFieldError(\"variant\".to_string()))\n                     }\n                 };\n-                match o.remove(&\"fields\".into_string()) {\n+                match o.remove(&\"fields\".to_string()) {\n                     Some(Json::Array(l)) => {\n                         for field in l.into_iter().rev() {\n                             self.stack.push(field);\n                         }\n                     },\n                     Some(val) => {\n-                        return Err(ExpectedError(\"Array\".into_string(), format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"Array\".to_string(), format!(\"{}\", val)))\n                     }\n                     None => {\n-                        return Err(MissingFieldError(\"fields\".into_string()))\n+                        return Err(MissingFieldError(\"fields\".to_string()))\n                     }\n                 }\n                 n\n             }\n             json => {\n-                return Err(ExpectedError(\"String or Object\".into_string(), format!(\"{}\", json)))\n+                return Err(ExpectedError(\"String or Object\".to_string(), format!(\"{}\", json)))\n             }\n         };\n-        let idx = match names.iter()\n-                             .position(|n| str::eq_slice(*n, name.as_slice())) {\n+        let idx = match names.iter().position(|n| *n == name[]) {\n             Some(idx) => idx,\n             None => return Err(UnknownVariantError(name))\n         };\n@@ -2319,7 +2319,7 @@ impl ToJson for bool {\n }\n \n impl ToJson for str {\n-    fn to_json(&self) -> Json { Json::String(self.into_string()) }\n+    fn to_json(&self) -> Json { Json::String(self.to_string()) }\n }\n \n impl ToJson for string::String {\n@@ -2450,9 +2450,9 @@ mod tests {\n     #[test]\n     fn test_decode_option_malformed() {\n         check_err::<OptionData>(\"{ \\\"opt\\\": [] }\",\n-                                ExpectedError(\"Number\".into_string(), \"[]\".into_string()));\n+                                ExpectedError(\"Number\".to_string(), \"[]\".to_string()));\n         check_err::<OptionData>(\"{ \\\"opt\\\": false }\",\n-                                ExpectedError(\"Number\".into_string(), \"false\".into_string()));\n+                                ExpectedError(\"Number\".to_string(), \"false\".to_string()));\n     }\n \n     #[deriving(PartialEq, Encodable, Decodable, Show)]\n@@ -2538,11 +2538,11 @@ mod tests {\n \n     #[test]\n     fn test_write_str() {\n-        assert_eq!(String(\"\".into_string()).to_string(), \"\\\"\\\"\");\n-        assert_eq!(String(\"\".into_string()).to_pretty_str(), \"\\\"\\\"\");\n+        assert_eq!(String(\"\".to_string()).to_string(), \"\\\"\\\"\");\n+        assert_eq!(String(\"\".to_string()).to_pretty_str(), \"\\\"\\\"\");\n \n-        assert_eq!(String(\"homura\".into_string()).to_string(), \"\\\"homura\\\"\");\n-        assert_eq!(String(\"madoka\".into_string()).to_pretty_str(), \"\\\"madoka\\\"\");\n+        assert_eq!(String(\"homura\".to_string()).to_string(), \"\\\"homura\\\"\");\n+        assert_eq!(String(\"madoka\".to_string()).to_pretty_str(), \"\\\"madoka\\\"\");\n     }\n \n     #[test]\n@@ -2571,7 +2571,7 @@ mod tests {\n         let long_test_array = Array(vec![\n             Boolean(false),\n             Null,\n-            Array(vec![String(\"foo\\nbar\".into_string()), F64(3.5)])]);\n+            Array(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n \n         assert_eq!(long_test_array.to_string(),\n             \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n@@ -2596,22 +2596,22 @@ mod tests {\n \n         assert_eq!(\n             mk_object(&[\n-                (\"a\".into_string(), Boolean(true))\n+                (\"a\".to_string(), Boolean(true))\n             ]).to_string(),\n             \"{\\\"a\\\":true}\"\n         );\n         assert_eq!(\n-            mk_object(&[(\"a\".into_string(), Boolean(true))]).to_pretty_str(),\n+            mk_object(&[(\"a\".to_string(), Boolean(true))]).to_pretty_str(),\n             \"\\\n             {\\n  \\\n                 \\\"a\\\": true\\n\\\n             }\"\n         );\n \n         let complex_obj = mk_object(&[\n-                (\"b\".into_string(), Array(vec![\n-                    mk_object(&[(\"c\".into_string(), String(\"\\x0c\\r\".into_string()))]),\n-                    mk_object(&[(\"d\".into_string(), String(\"\".into_string()))])\n+                (\"b\".to_string(), Array(vec![\n+                    mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n+                    mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n                 ]))\n             ]);\n \n@@ -2640,10 +2640,10 @@ mod tests {\n         );\n \n         let a = mk_object(&[\n-            (\"a\".into_string(), Boolean(true)),\n-            (\"b\".into_string(), Array(vec![\n-                mk_object(&[(\"c\".into_string(), String(\"\\x0c\\r\".into_string()))]),\n-                mk_object(&[(\"d\".into_string(), String(\"\".into_string()))])\n+            (\"a\".to_string(), Boolean(true)),\n+            (\"b\".to_string(), Array(vec![\n+                mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n+                mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n             ]))\n         ]);\n \n@@ -2678,7 +2678,7 @@ mod tests {\n             \"\\\"Dog\\\"\"\n         );\n \n-        let animal = Frog(\"Henry\".into_string(), 349);\n+        let animal = Frog(\"Henry\".to_string(), 349);\n         assert_eq!(\n             with_str_writer(|writer| {\n                 let mut encoder = Encoder::new(writer);\n@@ -2731,7 +2731,7 @@ mod tests {\n     fn test_write_char() {\n         check_encoder_for_simple!('a', \"\\\"a\\\"\");\n         check_encoder_for_simple!('\\t', \"\\\"\\\\t\\\"\");\n-        check_encoder_for_simple!('\\u{00a0}', \"\\\"\\u{00a0}\\\"\");\n+        check_encoder_for_simple!('\\u{a0}', \"\\\"\\u{a0}\\\"\");\n         check_encoder_for_simple!('\\u{abcd}', \"\\\"\\u{abcd}\\\"\");\n         check_encoder_for_simple!('\\u{10ffff}', \"\\\"\\u{10ffff}\\\"\");\n     }\n@@ -2839,24 +2839,24 @@ mod tests {\n         assert_eq!(v, i64::MAX);\n \n         let res: DecodeResult<i64> = super::decode(\"765.25252\");\n-        assert_eq!(res, Err(ExpectedError(\"Integer\".into_string(), \"765.25252\".into_string())));\n+        assert_eq!(res, Err(ExpectedError(\"Integer\".to_string(), \"765.25252\".to_string())));\n     }\n \n     #[test]\n     fn test_read_str() {\n         assert_eq!(from_str(\"\\\"\"),    Err(SyntaxError(EOFWhileParsingString, 1, 2)));\n         assert_eq!(from_str(\"\\\"lol\"), Err(SyntaxError(EOFWhileParsingString, 1, 5)));\n \n-        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".into_string())));\n-        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".into_string())));\n-        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".into_string())));\n-        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".into_string())));\n-        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".into_string())));\n-        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".into_string())));\n-        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".into_string())));\n-        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".into_string())));\n-        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u{12ab}\".into_string())));\n-        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\u{AB12}\".into_string())));\n+        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_string())));\n+        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_string())));\n+        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u{12ab}\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\u{AB12}\".to_string())));\n     }\n \n     #[test]\n@@ -2922,7 +2922,7 @@ mod tests {\n         assert_eq!(t, (1u, 2, 3));\n \n         let t: (uint, string::String) = super::decode(\"[1, \\\"two\\\"]\").unwrap();\n-        assert_eq!(t, (1u, \"two\".into_string()));\n+        assert_eq!(t, (1u, \"two\".to_string()));\n     }\n \n     #[test]\n@@ -2952,22 +2952,22 @@ mod tests {\n \n         assert_eq!(from_str(\"{}\").unwrap(), mk_object(&[]));\n         assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n-                  mk_object(&[(\"a\".into_string(), U64(3))]));\n+                  mk_object(&[(\"a\".to_string(), U64(3))]));\n \n         assert_eq!(from_str(\n                       \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n                   mk_object(&[\n-                      (\"a\".into_string(), Null),\n-                      (\"b\".into_string(), Boolean(true))]));\n+                      (\"a\".to_string(), Null),\n+                      (\"b\".to_string(), Boolean(true))]));\n         assert_eq!(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n                   mk_object(&[\n-                      (\"a\".into_string(), Null),\n-                      (\"b\".into_string(), Boolean(true))]));\n+                      (\"a\".to_string(), Null),\n+                      (\"b\".to_string(), Boolean(true))]));\n         assert_eq!(from_str(\n                       \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n                   mk_object(&[\n-                      (\"a\".into_string(), F64(1.0)),\n-                      (\"b\".into_string(), Array(vec![Boolean(true)]))\n+                      (\"a\".to_string(), F64(1.0)),\n+                      (\"b\".to_string(), Array(vec![Boolean(true)]))\n                   ]));\n         assert_eq!(from_str(\n                       \"{\\\n@@ -2979,12 +2979,12 @@ mod tests {\n                           ]\\\n                       }\").unwrap(),\n                   mk_object(&[\n-                      (\"a\".into_string(), F64(1.0)),\n-                      (\"b\".into_string(), Array(vec![\n+                      (\"a\".to_string(), F64(1.0)),\n+                      (\"b\".to_string(), Array(vec![\n                           Boolean(true),\n-                          String(\"foo\\nbar\".into_string()),\n+                          String(\"foo\\nbar\".to_string()),\n                           mk_object(&[\n-                              (\"c\".into_string(), mk_object(&[(\"d\".into_string(), Null)]))\n+                              (\"c\".to_string(), mk_object(&[(\"d\".to_string(), Null)]))\n                           ])\n                       ]))\n                   ]));\n@@ -3003,7 +3003,7 @@ mod tests {\n             v,\n             Outer {\n                 inner: vec![\n-                    Inner { a: (), b: 2, c: vec![\"abc\".into_string(), \"xyz\".into_string()] }\n+                    Inner { a: (), b: 2, c: vec![\"abc\".to_string(), \"xyz\".to_string()] }\n                 ]\n             }\n         );\n@@ -3029,7 +3029,7 @@ mod tests {\n         assert_eq!(value, None);\n \n         let value: Option<string::String> = super::decode(\"\\\"jodhpurs\\\"\").unwrap();\n-        assert_eq!(value, Some(\"jodhpurs\".into_string()));\n+        assert_eq!(value, Some(\"jodhpurs\".to_string()));\n     }\n \n     #[test]\n@@ -3039,7 +3039,7 @@ mod tests {\n \n         let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n         let value: Animal = super::decode(s).unwrap();\n-        assert_eq!(value, Frog(\"Henry\".into_string(), 349));\n+        assert_eq!(value, Frog(\"Henry\".to_string(), 349));\n     }\n \n     #[test]\n@@ -3048,8 +3048,8 @@ mod tests {\n                   \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n         let mut map: BTreeMap<string::String, Animal> = super::decode(s).unwrap();\n \n-        assert_eq!(map.remove(&\"a\".into_string()), Some(Dog));\n-        assert_eq!(map.remove(&\"b\".into_string()), Some(Frog(\"Henry\".into_string(), 349)));\n+        assert_eq!(map.remove(&\"a\".to_string()), Some(Dog));\n+        assert_eq!(map.remove(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n     }\n \n     #[test]\n@@ -3089,30 +3089,30 @@ mod tests {\n     }\n     #[test]\n     fn test_decode_errors_struct() {\n-        check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".into_string(), \"[]\".into_string()));\n+        check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_string(), \"[]\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Number\".into_string(), \"true\".into_string()));\n+                                  ExpectedError(\"Number\".to_string(), \"true\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Boolean\".into_string(), \"[]\".into_string()));\n+                                  ExpectedError(\"Boolean\".to_string(), \"[]\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n-                                  ExpectedError(\"String\".into_string(), \"{}\".into_string()));\n+                                  ExpectedError(\"String\".to_string(), \"{}\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n-                                  ExpectedError(\"Array\".into_string(), \"null\".into_string()));\n+                                  ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n-                                  MissingFieldError(\"w\".into_string()));\n+                                  MissingFieldError(\"w\".to_string()));\n     }\n     #[test]\n     fn test_decode_errors_enum() {\n         check_err::<DecodeEnum>(\"{}\",\n-                                MissingFieldError(\"variant\".into_string()));\n+                                MissingFieldError(\"variant\".to_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": 1}\",\n-                                ExpectedError(\"String\".into_string(), \"1\".into_string()));\n+                                ExpectedError(\"String\".to_string(), \"1\".to_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n-                                MissingFieldError(\"fields\".into_string()));\n+                                MissingFieldError(\"fields\".to_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n-                                ExpectedError(\"Array\".into_string(), \"null\".into_string()));\n+                                ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n-                                UnknownVariantError(\"C\".into_string()));\n+                                UnknownVariantError(\"C\".to_string()));\n     }\n \n     #[test]\n@@ -3325,15 +3325,15 @@ mod tests {\n \n         let mut tree = BTreeMap::new();\n \n-        tree.insert(\"hello\".into_string(), String(\"guten tag\".into_string()));\n-        tree.insert(\"goodbye\".into_string(), String(\"sayonara\".into_string()));\n+        tree.insert(\"hello\".to_string(), String(\"guten tag\".to_string()));\n+        tree.insert(\"goodbye\".to_string(), String(\"sayonara\".to_string()));\n \n         let json = Array(\n             // The following layout below should look a lot like\n             // the pretty-printed JSON (indent * x)\n             vec!\n             ( // 0x\n-                String(\"greetings\".into_string()), // 1x\n+                String(\"greetings\".to_string()), // 1x\n                 Object(tree), // 1x + 2x + 2x + 1x\n             ) // 0x\n             // End JSON array (7 lines)\n@@ -3397,7 +3397,7 @@ mod tests {\n         };\n         let mut decoder = Decoder::new(json_obj);\n         let result: Result<HashMap<uint, bool>, DecoderError> = Decodable::decode(&mut decoder);\n-        assert_eq!(result, Err(ExpectedError(\"Number\".into_string(), \"a\".into_string())));\n+        assert_eq!(result, Err(ExpectedError(\"Number\".to_string(), \"a\".to_string())));\n     }\n \n     fn assert_stream_equal(src: &str,\n@@ -3424,7 +3424,7 @@ mod tests {\n             r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2, 3, 4, 5], \"idents\":[null,true,false]}\"#,\n             vec![\n                 (ObjectStart,             vec![]),\n-                  (StringValue(\"bar\".into_string()),   vec![Key(\"foo\")]),\n+                  (StringValue(\"bar\".to_string()),   vec![Key(\"foo\")]),\n                   (ArrayStart,            vec![Key(\"array\")]),\n                     (U64Value(0),         vec![Key(\"array\"), Index(0)]),\n                     (U64Value(1),         vec![Key(\"array\"), Index(1)]),\n@@ -3515,7 +3515,7 @@ mod tests {\n                   (F64Value(1.0),               vec![Key(\"a\")]),\n                   (ArrayStart,                  vec![Key(\"b\")]),\n                     (BooleanValue(true),        vec![Key(\"b\"), Index(0)]),\n-                    (StringValue(\"foo\\nbar\".into_string()),  vec![Key(\"b\"), Index(1)]),\n+                    (StringValue(\"foo\\nbar\".to_string()),  vec![Key(\"b\"), Index(1)]),\n                     (ObjectStart,               vec![Key(\"b\"), Index(2)]),\n                       (ObjectStart,             vec![Key(\"b\"), Index(2), Key(\"c\")]),\n                         (NullValue,             vec![Key(\"b\"), Index(2), Key(\"c\"), Key(\"d\")]),\n@@ -3648,7 +3648,7 @@ mod tests {\n         assert!(stack.last_is_index());\n         assert!(stack.get(0) == Index(1));\n \n-        stack.push_key(\"foo\".into_string());\n+        stack.push_key(\"foo\".to_string());\n \n         assert!(stack.len() == 2);\n         assert!(stack.is_equal_to(&[Index(1), Key(\"foo\")]));\n@@ -3660,7 +3660,7 @@ mod tests {\n         assert!(stack.get(0) == Index(1));\n         assert!(stack.get(1) == Key(\"foo\"));\n \n-        stack.push_key(\"bar\".into_string());\n+        stack.push_key(\"bar\".to_string());\n \n         assert!(stack.len() == 3);\n         assert!(stack.is_equal_to(&[Index(1), Key(\"foo\"), Key(\"bar\")]));\n@@ -3721,8 +3721,8 @@ mod tests {\n         assert_eq!(f64::NAN.to_json(), Null);\n         assert_eq!(true.to_json(), Boolean(true));\n         assert_eq!(false.to_json(), Boolean(false));\n-        assert_eq!(\"abc\".to_json(), String(\"abc\".into_string()));\n-        assert_eq!(\"abc\".into_string().to_json(), String(\"abc\".into_string()));\n+        assert_eq!(\"abc\".to_json(), String(\"abc\".to_string()));\n+        assert_eq!(\"abc\".to_string().to_json(), String(\"abc\".to_string()));\n         assert_eq!((1u, 2u).to_json(), array2);\n         assert_eq!((1u, 2u, 3u).to_json(), array3);\n         assert_eq!([1u, 2].to_json(), array2);\n@@ -3734,8 +3734,8 @@ mod tests {\n         tree_map.insert(\"b\".into_string(), 2);\n         assert_eq!(tree_map.to_json(), object);\n         let mut hash_map = HashMap::new();\n-        hash_map.insert(\"a\".into_string(), 1u);\n-        hash_map.insert(\"b\".into_string(), 2);\n+        hash_map.insert(\"a\".to_string(), 1u);\n+        hash_map.insert(\"b\".to_string(), 2);\n         assert_eq!(hash_map.to_json(), object);\n         assert_eq!(Some(15i).to_json(), I64(15));\n         assert_eq!(Some(15u).to_json(), U64(15));\n@@ -3778,7 +3778,7 @@ mod tests {\n     }\n \n     fn big_json() -> string::String {\n-        let mut src = \"[\\n\".into_string();\n+        let mut src = \"[\\n\".to_string();\n         for _ in range(0i, 500) {\n             src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\\n                             [1,2,3]},\"#);"}, {"sha": "fdbc5051f728de646619ccfe0eaeabb64597260e", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -32,6 +32,7 @@ extern crate test;\n \n #[phase(plugin, link)]\n extern crate log;\n+extern crate unicode;\n \n extern crate collections;\n "}, {"sha": "558f9e603e15989fd8ccbd1607761883ffe6d235", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -308,13 +308,13 @@ impl<E, S:Encoder<E>> Encodable<S, E> for str {\n \n impl<E, S:Encoder<E>> Encodable<S, E> for String {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_str(self.as_slice())\n+        s.emit_str(self[])\n     }\n }\n \n impl<E, D:Decoder<E>> Decodable<D, E> for String {\n     fn decode(d: &mut D) -> Result<String, E> {\n-        Ok(String::from_str(try!(d.read_str()).as_slice()))\n+        d.read_str()\n     }\n }\n "}, {"sha": "2c49beca98de60aafdc6e3b5a73d4304ca25a172", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -23,7 +23,7 @@ use ops::FnMut;\n use option::Option;\n use option::Option::{Some, None};\n use slice::{SliceExt, AsSlice};\n-use str::{Str, StrPrelude};\n+use str::{Str, StrExt};\n use string::{String, IntoString};\n use vec::Vec;\n "}, {"sha": "fb44961017fcdf4d753f710e90a732424603beca", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -228,7 +228,7 @@ impl CString {\n     #[inline]\n     pub fn as_str<'a>(&'a self) -> Option<&'a str> {\n         let buf = self.as_bytes_no_nul();\n-        str::from_utf8(buf)\n+        str::from_utf8(buf).ok()\n     }\n \n     /// Return a CString iterator."}, {"sha": "368abe7cb1244a55bf818df512377a80fe69fa35", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -280,7 +280,7 @@ pub mod dl {\n     use result::Result;\n     use result::Result::{Ok, Err};\n     use slice::SliceExt;\n-    use str::StrPrelude;\n+    use str::StrExt;\n     use str;\n     use string::String;\n     use vec::Vec;"}, {"sha": "7010eae6dba0dba03e285e707d6232fc07451661", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -41,7 +41,7 @@ pub fn on_fail(obj: &(Any+Send), file: &'static str, line: uint) {\n     let msg = match obj.downcast_ref::<&'static str>() {\n         Some(s) => *s,\n         None => match obj.downcast_ref::<String>() {\n-            Some(s) => s.as_slice(),\n+            Some(s) => s[],\n             None => \"Box<Any>\",\n         }\n     };"}, {"sha": "233ad78109382d1275fd47742254d9e480b81a1b", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -242,10 +242,11 @@ use result::Result;\n use result::Result::{Ok, Err};\n use sys;\n use slice::SliceExt;\n-use str::StrPrelude;\n+use str::StrExt;\n use str;\n use string::String;\n use uint;\n+use unicode;\n use unicode::char::UnicodeChar;\n use vec::Vec;\n \n@@ -1505,7 +1506,7 @@ pub trait Buffer: Reader {\n     /// valid utf-8 encoded codepoint as the next few bytes in the stream.\n     fn read_char(&mut self) -> IoResult<char> {\n         let first_byte = try!(self.read_byte());\n-        let width = str::utf8_char_width(first_byte);\n+        let width = unicode::str::utf8_char_width(first_byte);\n         if width == 1 { return Ok(first_byte as char) }\n         if width == 0 { return Err(standard_error(InvalidInput)) } // not utf8\n         let mut buf = [first_byte, 0, 0, 0];\n@@ -1519,7 +1520,7 @@ pub trait Buffer: Reader {\n                 }\n             }\n         }\n-        match str::from_utf8(buf[..width]) {\n+        match str::from_utf8(buf[..width]).ok() {\n             Some(s) => Ok(s.char_at(0)),\n             None => Err(standard_error(InvalidInput))\n         }"}, {"sha": "89a649d55bdc4ec50e0dbe55d887be6039317c88", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -25,8 +25,8 @@ use ops::FnOnce;\n use option::Option;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n-use str::{FromStr, StrPrelude};\n use slice::{CloneSliceExt, SliceExt};\n+use str::{FromStr, StrExt};\n use vec::Vec;\n \n pub type Port = u16;"}, {"sha": "4a0a393642439c0d6a726d338065d8108cc7ba03", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -1082,7 +1082,7 @@ mod tests {\n \n         let prog = env_cmd().env_set_all(new_env.as_slice()).spawn().unwrap();\n         let result = prog.wait_with_output().unwrap();\n-        let output = String::from_utf8_lossy(result.output.as_slice()).into_string();\n+        let output = String::from_utf8_lossy(result.output.as_slice()).to_string();\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n@@ -1092,7 +1092,7 @@ mod tests {\n     fn test_add_to_env() {\n         let prog = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").spawn().unwrap();\n         let result = prog.wait_with_output().unwrap();\n-        let output = String::from_utf8_lossy(result.output.as_slice()).into_string();\n+        let output = String::from_utf8_lossy(result.output.as_slice()).to_string();\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);"}, {"sha": "1c5ceaf24506f0ae07ffc35bb78b5a7f04b2543c", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -43,7 +43,7 @@ use ops::{Deref, DerefMut, FnOnce};\n use result::Result::{Ok, Err};\n use rt;\n use slice::SliceExt;\n-use str::StrPrelude;\n+use str::StrExt;\n use string::String;\n use sys::{fs, tty};\n use sync::{Arc, Mutex, MutexGuard, Once, ONCE_INIT};"}, {"sha": "d6331f3c718ac4c9d7b1aeaa1ba04893f593eb19", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -20,7 +20,7 @@ use char::{mod, Char};\n use num::{mod, Int, Float, FPNaN, FPInfinite, ToPrimitive};\n use ops::FnMut;\n use slice::{SliceExt, CloneSliceExt};\n-use str::StrPrelude;\n+use str::StrExt;\n use string::String;\n use vec::Vec;\n "}, {"sha": "ceb9a4102f6353c385743e0a68f40b1650aa2566", "filename": "src/libstd/os.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -52,7 +52,7 @@ use result::Result;\n use result::Result::{Err, Ok};\n use slice::{AsSlice, SliceExt};\n use slice::CloneSliceExt;\n-use str::{Str, StrPrelude, StrAllocating};\n+use str::{Str, StrExt};\n use string::{String, ToString};\n use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use vec::Vec;\n@@ -134,8 +134,8 @@ fn with_env_lock<T, F>(f: F) -> T where\n /// ```\n pub fn env() -> Vec<(String,String)> {\n     env_as_bytes().into_iter().map(|(k,v)| {\n-        let k = String::from_utf8_lossy(k.as_slice()).into_string();\n-        let v = String::from_utf8_lossy(v.as_slice()).into_string();\n+        let k = String::from_utf8_lossy(k.as_slice()).into_owned();\n+        let v = String::from_utf8_lossy(v.as_slice()).into_owned();\n         (k,v)\n     }).collect()\n }\n@@ -185,7 +185,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n /// }\n /// ```\n pub fn getenv(n: &str) -> Option<String> {\n-    getenv_as_bytes(n).map(|v| String::from_utf8_lossy(v.as_slice()).into_string())\n+    getenv_as_bytes(n).map(|v| String::from_utf8_lossy(v.as_slice()).into_owned())\n }\n \n #[cfg(unix)]\n@@ -707,7 +707,7 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n fn real_args() -> Vec<String> {\n     real_args_as_bytes().into_iter()\n                         .map(|v| {\n-                            String::from_utf8_lossy(v.as_slice()).into_string()\n+                            String::from_utf8_lossy(v.as_slice()).into_owned()\n                         }).collect()\n }\n \n@@ -729,7 +729,7 @@ fn real_args() -> Vec<String> {\n         // Push it onto the list.\n         let ptr = ptr as *const u16;\n         let buf = slice::from_raw_buf(&ptr, len);\n-        let opt_s = String::from_utf16(os_imp::truncate_utf16_at_nul(buf));\n+        let opt_s = String::from_utf16(sys::os::truncate_utf16_at_nul(buf));\n         opt_s.expect(\"CommandLineToArgvW returned invalid UTF-16\")\n     });\n "}, {"sha": "30f3f56bc1c10be7fd520fc9e175f5fbadf5f45b", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -69,7 +69,7 @@ use iter::IteratorExt;\n use option::Option;\n use option::Option::{None, Some};\n use str;\n-use str::{CowString, MaybeOwned, Str, StrPrelude};\n+use str::{CowString, MaybeOwned, Str, StrExt};\n use string::String;\n use slice::{AsSlice, CloneSliceExt};\n use slice::{PartialEqSliceExt, SliceExt};\n@@ -197,7 +197,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// ```\n     #[inline]\n     fn as_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8(self.as_vec())\n+        str::from_utf8(self.as_vec()).ok()\n     }\n \n     /// Returns the path as a byte vector\n@@ -293,7 +293,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// ```\n     #[inline]\n     fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8(self.dirname())\n+        str::from_utf8(self.dirname()).ok()\n     }\n \n     /// Returns the file component of `self`, as a byte vector.\n@@ -327,7 +327,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// ```\n     #[inline]\n     fn filename_str<'a>(&'a self) -> Option<&'a str> {\n-        self.filename().and_then(str::from_utf8)\n+        self.filename().and_then(|s| str::from_utf8(s).ok())\n     }\n \n     /// Returns the stem of the filename of `self`, as a byte vector.\n@@ -373,7 +373,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// ```\n     #[inline]\n     fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n-        self.filestem().and_then(str::from_utf8)\n+        self.filestem().and_then(|s| str::from_utf8(s).ok())\n     }\n \n     /// Returns the extension of the filename of `self`, as an optional byte vector.\n@@ -420,7 +420,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// ```\n     #[inline]\n     fn extension_str<'a>(&'a self) -> Option<&'a str> {\n-        self.extension().and_then(str::from_utf8)\n+        self.extension().and_then(|s| str::from_utf8(s).ok())\n     }\n \n     /// Replaces the filename portion of the path with the given byte vector or string.\n@@ -793,7 +793,7 @@ pub trait BytesContainer for Sized? {\n     /// Returns the receiver interpreted as a utf-8 string, if possible\n     #[inline]\n     fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8(self.container_as_bytes())\n+        str::from_utf8(self.container_as_bytes()).ok()\n     }\n     /// Returns whether .container_as_str() is guaranteed to not fail\n     // FIXME (#8888): Remove unused arg once ::<for T> works\n@@ -870,7 +870,7 @@ impl BytesContainer for String {\n     }\n     #[inline]\n     fn container_as_str(&self) -> Option<&str> {\n-        Some(self.as_slice())\n+        Some(self[])\n     }\n     #[inline]\n     fn is_str(_: Option<&String>) -> bool { true }\n@@ -886,7 +886,7 @@ impl BytesContainer for [u8] {\n impl BytesContainer for Vec<u8> {\n     #[inline]\n     fn container_as_bytes(&self) -> &[u8] {\n-        self.as_slice()\n+        self[]\n     }\n }\n \n@@ -897,6 +897,7 @@ impl BytesContainer for CString {\n     }\n }\n \n+#[allow(deprecated)]\n impl<'a> BytesContainer for str::MaybeOwned<'a> {\n     #[inline]\n     fn container_as_bytes<'b>(&'b self) -> &'b [u8] {"}, {"sha": "a514837492af00e54bc87e18f0f93ba74fc05457", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -401,7 +401,10 @@ impl Path {\n     /// Returns an iterator that yields each component of the path as Option<&str>.\n     /// See components() for details.\n     pub fn str_components<'a>(&'a self) -> StrComponents<'a> {\n-        self.components().map(str::from_utf8)\n+        fn from_utf8(s: &[u8]) -> Option<&str> {\n+            str::from_utf8(s).ok()\n+        }\n+        self.components().map(from_utf8)\n     }\n }\n "}, {"sha": "277c675c22d65fa812ce36d10742baf8b695077a", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 70, "deletions": 74, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -25,9 +25,9 @@ use iter::{Iterator, IteratorExt, Map};\n use mem;\n use option::Option;\n use option::Option::{Some, None};\n-use slice::{AsSlice, SliceExt};\n-use str::{CharSplits, FromStr, Str, StrAllocating, StrVector, StrPrelude};\n-use string::String;\n+use slice::SliceExt;\n+use str::{CharSplits, FromStr, StrVector, StrExt};\n+use string::{String, ToString};\n use unicode::char::UnicodeChar;\n use vec::Vec;\n \n@@ -187,30 +187,30 @@ impl GenericPathUnsafe for Path {\n                 s.push_str(\"..\");\n                 s.push(SEP);\n                 s.push_str(filename);\n-                self.update_normalized(s);\n+                self.update_normalized(s[]);\n             }\n             None => {\n                 self.update_normalized(filename);\n             }\n-            Some((_,idxa,end)) if self.repr.slice(idxa,end) == \"..\" => {\n+            Some((_,idxa,end)) if self.repr[idxa..end] == \"..\" => {\n                 let mut s = String::with_capacity(end + 1 + filename.len());\n-                s.push_str(self.repr.slice_to(end));\n+                s.push_str(self.repr[0..end]);\n                 s.push(SEP);\n                 s.push_str(filename);\n-                self.update_normalized(s);\n+                self.update_normalized(s[]);\n             }\n             Some((idxb,idxa,_)) if self.prefix == Some(DiskPrefix) && idxa == self.prefix_len() => {\n                 let mut s = String::with_capacity(idxb + filename.len());\n-                s.push_str(self.repr.slice_to(idxb));\n+                s.push_str(self.repr[0..idxb]);\n                 s.push_str(filename);\n-                self.update_normalized(s);\n+                self.update_normalized(s[]);\n             }\n             Some((idxb,_,_)) => {\n                 let mut s = String::with_capacity(idxb + 1 + filename.len());\n-                s.push_str(self.repr.slice_to(idxb));\n+                s.push_str(self.repr[0..idxb]);\n                 s.push(SEP);\n                 s.push_str(filename);\n-                self.update_normalized(s);\n+                self.update_normalized(s[]);\n             }\n         }\n     }\n@@ -229,12 +229,12 @@ impl GenericPathUnsafe for Path {\n         let path = path.container_as_str().unwrap();\n         fn is_vol_abs(path: &str, prefix: Option<PathPrefix>) -> bool {\n             // assume prefix is Some(DiskPrefix)\n-            let rest = path.slice_from(prefix_len(prefix));\n+            let rest = path[prefix_len(prefix)..];\n             !rest.is_empty() && rest.as_bytes()[0].is_ascii() && is_sep(rest.as_bytes()[0] as char)\n         }\n         fn shares_volume(me: &Path, path: &str) -> bool {\n             // path is assumed to have a prefix of Some(DiskPrefix)\n-            let repr = me.repr.as_slice();\n+            let repr = me.repr[];\n             match me.prefix {\n                 Some(DiskPrefix) => {\n                     repr.as_bytes()[0] == path.as_bytes()[0].to_ascii().to_uppercase().as_byte()\n@@ -266,7 +266,7 @@ impl GenericPathUnsafe for Path {\n                         else { None };\n             let pathlen = path_.as_ref().map_or(path.len(), |p| p.len());\n             let mut s = String::with_capacity(me.repr.len() + 1 + pathlen);\n-            s.push_str(me.repr.as_slice());\n+            s.push_str(me.repr[]);\n             let plen = me.prefix_len();\n             // if me is \"C:\" we don't want to add a path separator\n             match me.prefix {\n@@ -278,17 +278,17 @@ impl GenericPathUnsafe for Path {\n             }\n             match path_ {\n                 None => s.push_str(path),\n-                Some(p) => s.push_str(p.as_slice())\n+                Some(p) => s.push_str(p[]),\n             };\n-            me.update_normalized(s)\n+            me.update_normalized(s[])\n         }\n \n         if !path.is_empty() {\n             let prefix = parse_prefix(path);\n             match prefix {\n                 Some(DiskPrefix) if !is_vol_abs(path, prefix) && shares_volume(self, path) => {\n                     // cwd-relative path, self is on the same volume\n-                    append_path(self, path.slice_from(prefix_len(prefix)));\n+                    append_path(self, path[prefix_len(prefix)..]);\n                 }\n                 Some(_) => {\n                     // absolute path, or cwd-relative and self is not same volume\n@@ -334,7 +334,7 @@ impl GenericPath for Path {\n     /// Always returns a `Some` value.\n     #[inline]\n     fn as_str<'a>(&'a self) -> Option<&'a str> {\n-        Some(self.repr.as_slice())\n+        Some(self.repr[])\n     }\n \n     #[inline]\n@@ -356,21 +356,17 @@ impl GenericPath for Path {\n     /// Always returns a `Some` value.\n     fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n         Some(match self.sepidx_or_prefix_len() {\n-            None if \"..\" == self.repr => self.repr.as_slice(),\n+            None if \"..\" == self.repr => self.repr[],\n             None => \".\",\n-            Some((_,idxa,end)) if self.repr.slice(idxa, end) == \"..\" => {\n-                self.repr.as_slice()\n-            }\n-            Some((idxb,_,end)) if self.repr.slice(idxb, end) == \"\\\\\" => {\n-                self.repr.as_slice()\n-            }\n-            Some((0,idxa,_)) => self.repr.slice_to(idxa),\n+            Some((_,idxa,end)) if self.repr[idxa..end] == \"..\" => self.repr[],\n+            Some((idxb,_,end)) if self.repr[idxb..end] == \"\\\\\" => self.repr[],\n+            Some((0,idxa,_)) => self.repr[0..idxa],\n             Some((idxb,idxa,_)) => {\n                 match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) if idxb == self.prefix_len() => {\n-                        self.repr.slice_to(idxa)\n+                        self.repr[0..idxa]\n                     }\n-                    _ => self.repr.slice_to(idxb)\n+                    _ => self.repr[0..idxb]\n                 }\n             }\n         })\n@@ -384,13 +380,13 @@ impl GenericPath for Path {\n     /// See `GenericPath::filename_str` for info.\n     /// Always returns a `Some` value if `filename` returns a `Some` value.\n     fn filename_str<'a>(&'a self) -> Option<&'a str> {\n-        let repr = self.repr.as_slice();\n+        let repr = self.repr[];\n         match self.sepidx_or_prefix_len() {\n             None if \".\" == repr || \"..\" == repr => None,\n             None => Some(repr),\n-            Some((_,idxa,end)) if repr.slice(idxa, end) == \"..\" => None,\n+            Some((_,idxa,end)) if repr[idxa..end] == \"..\" => None,\n             Some((_,idxa,end)) if idxa == end => None,\n-            Some((_,idxa,end)) => Some(repr.slice(idxa, end))\n+            Some((_,idxa,end)) => Some(repr[idxa..end])\n         }\n     }\n \n@@ -422,7 +418,7 @@ impl GenericPath for Path {\n                 true\n             }\n             Some((idxb,idxa,end)) if idxb == idxa && idxb == end => false,\n-            Some((idxb,_,end)) if self.repr.slice(idxb, end) == \"\\\\\" => false,\n+            Some((idxb,_,end)) if self.repr[idxb..end] == \"\\\\\" => false,\n             Some((idxb,idxa,_)) => {\n                 let trunc = match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) | None => {\n@@ -442,15 +438,15 @@ impl GenericPath for Path {\n         if self.prefix.is_some() {\n             Some(Path::new(match self.prefix {\n                 Some(DiskPrefix) if self.is_absolute() => {\n-                    self.repr.slice_to(self.prefix_len()+1)\n+                    self.repr[0..self.prefix_len()+1]\n                 }\n                 Some(VerbatimDiskPrefix) => {\n-                    self.repr.slice_to(self.prefix_len()+1)\n+                    self.repr[0..self.prefix_len()+1]\n                 }\n-                _ => self.repr.slice_to(self.prefix_len())\n+                _ => self.repr[0..self.prefix_len()]\n             }))\n         } else if is_vol_relative(self) {\n-            Some(Path::new(self.repr.slice_to(1)))\n+            Some(Path::new(self.repr[0..1]))\n         } else {\n             None\n         }\n@@ -469,7 +465,7 @@ impl GenericPath for Path {\n     fn is_absolute(&self) -> bool {\n         match self.prefix {\n             Some(DiskPrefix) => {\n-                let rest = self.repr.slice_from(self.prefix_len());\n+                let rest = self.repr[self.prefix_len()..];\n                 rest.len() > 0 && rest.as_bytes()[0] == SEP_BYTE\n             }\n             Some(_) => true,\n@@ -644,15 +640,15 @@ impl Path {\n     /// Does not distinguish between absolute and cwd-relative paths, e.g.\n     /// C:\\foo and C:foo.\n     pub fn str_components<'a>(&'a self) -> StrComponents<'a> {\n-        let repr = self.repr.as_slice();\n+        let repr = self.repr[];\n         let s = match self.prefix {\n             Some(_) => {\n                 let plen = self.prefix_len();\n                 if repr.len() > plen && repr.as_bytes()[plen] == SEP_BYTE {\n-                    repr.slice_from(plen+1)\n-                } else { repr.slice_from(plen) }\n+                    repr[plen+1..]\n+                } else { repr[plen..] }\n             }\n-            None if repr.as_bytes()[0] == SEP_BYTE => repr.slice_from(1),\n+            None if repr.as_bytes()[0] == SEP_BYTE => repr[1..],\n             None => repr\n         };\n         let ret = s.split_terminator(SEP).map(Some);\n@@ -670,8 +666,8 @@ impl Path {\n     }\n \n     fn equiv_prefix(&self, other: &Path) -> bool {\n-        let s_repr = self.repr.as_slice();\n-        let o_repr = other.repr.as_slice();\n+        let s_repr = self.repr[];\n+        let o_repr = other.repr[];\n         match (self.prefix, other.prefix) {\n             (Some(DiskPrefix), Some(VerbatimDiskPrefix)) => {\n                 self.is_absolute() &&\n@@ -688,28 +684,28 @@ impl Path {\n                     o_repr.as_bytes()[4].to_ascii().to_lowercase()\n             }\n             (Some(UNCPrefix(_,_)), Some(VerbatimUNCPrefix(_,_))) => {\n-                s_repr.slice(2, self.prefix_len()) == o_repr.slice(8, other.prefix_len())\n+                s_repr[2..self.prefix_len()] == o_repr[8..other.prefix_len()]\n             }\n             (Some(VerbatimUNCPrefix(_,_)), Some(UNCPrefix(_,_))) => {\n-                s_repr.slice(8, self.prefix_len()) == o_repr.slice(2, other.prefix_len())\n+                s_repr[8..self.prefix_len()] == o_repr[2..other.prefix_len()]\n             }\n             (None, None) => true,\n             (a, b) if a == b => {\n-                s_repr.slice_to(self.prefix_len()) == o_repr.slice_to(other.prefix_len())\n+                s_repr[0..self.prefix_len()] == o_repr[0..other.prefix_len()]\n             }\n             _ => false\n         }\n     }\n \n-    fn normalize_<S: StrAllocating>(s: S) -> (Option<PathPrefix>, String) {\n+    fn normalize_(s: &str) -> (Option<PathPrefix>, String) {\n         // make borrowck happy\n         let (prefix, val) = {\n-            let prefix = parse_prefix(s.as_slice());\n-            let path = Path::normalize__(s.as_slice(), prefix);\n+            let prefix = parse_prefix(s);\n+            let path = Path::normalize__(s, prefix);\n             (prefix, path)\n         };\n         (prefix, match val {\n-            None => s.into_string(),\n+            None => s.to_string(),\n             Some(val) => val\n         })\n     }\n@@ -749,7 +745,7 @@ impl Path {\n                         match prefix.unwrap() {\n                             DiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n-                                let mut s = String::from_str(s.slice_to(len));\n+                                let mut s = String::from_str(s[0..len]);\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n                                     v[0] = (*v)[0].to_ascii().to_uppercase().as_byte();\n@@ -764,7 +760,7 @@ impl Path {\n                             }\n                             VerbatimDiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n-                                let mut s = String::from_str(s.slice_to(len));\n+                                let mut s = String::from_str(s[0..len]);\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n                                     v[4] = (*v)[4].to_ascii().to_uppercase().as_byte();\n@@ -774,14 +770,14 @@ impl Path {\n                             _ => {\n                                 let plen = prefix_len(prefix);\n                                 if s.len() > plen {\n-                                    Some(String::from_str(s.slice_to(plen)))\n+                                    Some(String::from_str(s[0..plen]))\n                                 } else { None }\n                             }\n                         }\n                     } else if is_abs && comps.is_empty() {\n                         Some(String::from_char(1, SEP))\n                     } else {\n-                        let prefix_ = s.slice_to(prefix_len(prefix));\n+                        let prefix_ = s[0..prefix_len(prefix)];\n                         let n = prefix_.len() +\n                                 if is_abs { comps.len() } else { comps.len() - 1} +\n                                 comps.iter().map(|v| v.len()).sum();\n@@ -793,16 +789,16 @@ impl Path {\n                                 s.push(':');\n                             }\n                             Some(VerbatimDiskPrefix) => {\n-                                s.push_str(prefix_.slice_to(4));\n+                                s.push_str(prefix_[0..4]);\n                                 s.push(prefix_.as_bytes()[4].to_ascii()\n                                                    .to_uppercase().as_char());\n-                                s.push_str(prefix_.slice_from(5));\n+                                s.push_str(prefix_[5..]);\n                             }\n                             Some(UNCPrefix(a,b)) => {\n                                 s.push_str(\"\\\\\\\\\");\n-                                s.push_str(prefix_.slice(2, a+2));\n+                                s.push_str(prefix_[2..a+2]);\n                                 s.push(SEP);\n-                                s.push_str(prefix_.slice(3+a, 3+a+b));\n+                                s.push_str(prefix_[3+a..3+a+b]);\n                             }\n                             Some(_) => s.push_str(prefix_),\n                             None => ()\n@@ -827,8 +823,8 @@ impl Path {\n \n     fn update_sepidx(&mut self) {\n         let s = if self.has_nonsemantic_trailing_slash() {\n-                    self.repr.slice_to(self.repr.len()-1)\n-                } else { self.repr.as_slice() };\n+                    self.repr[0..self.repr.len()-1]\n+                } else { self.repr[] };\n         let idx = s.rfind(if !prefix_is_verbatim(self.prefix) { is_sep }\n                           else { is_sep_verbatim });\n         let prefixlen = self.prefix_len();\n@@ -860,8 +856,8 @@ impl Path {\n             self.repr.as_bytes()[self.repr.len()-1] == SEP_BYTE\n     }\n \n-    fn update_normalized<S: Str>(&mut self, s: S) {\n-        let (prefix, path) = Path::normalize_(s.as_slice());\n+    fn update_normalized(&mut self, s: &str) {\n+        let (prefix, path) = Path::normalize_(s);\n         self.repr = path;\n         self.prefix = prefix;\n         self.update_sepidx();\n@@ -903,17 +899,17 @@ pub fn is_verbatim(path: &Path) -> bool {\n /// non-verbatim, the non-verbatim version is returned.\n /// Otherwise, None is returned.\n pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n-    let repr = path.repr.as_slice();\n+    let repr = path.repr[];\n     let new_path = match path.prefix {\n         Some(VerbatimPrefix(_)) | Some(DeviceNSPrefix(_)) => return None,\n         Some(UNCPrefix(_,_)) | Some(DiskPrefix) | None => return Some(path.clone()),\n         Some(VerbatimDiskPrefix) => {\n             // \\\\?\\D:\\\n-            Path::new(repr.slice_from(4))\n+            Path::new(repr[4..])\n         }\n         Some(VerbatimUNCPrefix(_,_)) => {\n             // \\\\?\\UNC\\server\\share\n-            Path::new(format!(r\"\\{}\", repr.slice_from(7)))\n+            Path::new(format!(r\"\\{}\", repr[7..]))\n         }\n     };\n     if new_path.prefix.is_none() {\n@@ -922,8 +918,8 @@ pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n         return None;\n     }\n     // now ensure normalization didn't change anything\n-    if repr.slice_from(path.prefix_len()) ==\n-        new_path.repr.slice_from(new_path.prefix_len()) {\n+    if repr[path.prefix_len()..] ==\n+        new_path.repr[new_path.prefix_len()..] {\n         Some(new_path)\n     } else {\n         None\n@@ -988,13 +984,13 @@ pub enum PathPrefix {\n fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n     if path.starts_with(\"\\\\\\\\\") {\n         // \\\\\n-        path = path.slice_from(2);\n+        path = path[2..];\n         if path.starts_with(\"?\\\\\") {\n             // \\\\?\\\n-            path = path.slice_from(2);\n+            path = path[2..];\n             if path.starts_with(\"UNC\\\\\") {\n                 // \\\\?\\UNC\\server\\share\n-                path = path.slice_from(4);\n+                path = path[4..];\n                 let (idx_a, idx_b) = match parse_two_comps(path, is_sep_verbatim) {\n                     Some(x) => x,\n                     None => (path.len(), 0)\n@@ -1015,7 +1011,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n             }\n         } else if path.starts_with(\".\\\\\") {\n             // \\\\.\\path\n-            path = path.slice_from(2);\n+            path = path[2..];\n             let idx = path.find('\\\\').unwrap_or(path.len());\n             return Some(DeviceNSPrefix(idx));\n         }\n@@ -1040,7 +1036,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n             None => return None,\n             Some(x) => x\n         };\n-        path = path.slice_from(idx_a+1);\n+        path = path[idx_a+1..];\n         let idx_b = path.find(f).unwrap_or(path.len());\n         Some((idx_a, idx_b))\n     }\n@@ -1050,8 +1046,8 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool, Option<Vec<&'a str>>) {\n     let f = if !prefix_is_verbatim(prefix) { is_sep } else { is_sep_verbatim };\n     let is_abs = s.len() > prefix_len(prefix) && f(s.char_at(prefix_len(prefix)));\n-    let s_ = s.slice_from(prefix_len(prefix));\n-    let s_ = if is_abs { s_.slice_from(1) } else { s_ };\n+    let s_ = s[prefix_len(prefix)..];\n+    let s_ = if is_abs { s_[1..] } else { s_ };\n \n     if is_abs && s_.is_empty() {\n         return (is_abs, match prefix {"}, {"sha": "49b888d17f47f64f661cd0ec8264e514118c3c34", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -79,11 +79,11 @@\n #[doc(no_inline)] pub use result::Result;\n #[doc(no_inline)] pub use result::Result::{Ok, Err};\n #[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek, BufferPrelude};\n-#[doc(no_inline)] pub use str::{Str, StrVector, StrPrelude};\n-#[doc(no_inline)] pub use str::{StrAllocating, UnicodeStrPrelude};\n #[doc(no_inline)] pub use core::prelude::{Tuple1, Tuple2, Tuple3, Tuple4};\n #[doc(no_inline)] pub use core::prelude::{Tuple5, Tuple6, Tuple7, Tuple8};\n #[doc(no_inline)] pub use core::prelude::{Tuple9, Tuple10, Tuple11, Tuple12};\n+#[doc(no_inline)] pub use str::{Str, StrVector};\n+#[doc(no_inline)] pub use str::StrExt;\n #[doc(no_inline)] pub use slice::AsSlice;\n #[doc(no_inline)] pub use slice::{VectorVector, PartialEqSliceExt};\n #[doc(no_inline)] pub use slice::{CloneSliceExt, OrdSliceExt, SliceExt};"}, {"sha": "775e9bb526f7cbc84a300e47b4385b386e6d1654", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -12,7 +12,8 @@\n \n #![allow(non_camel_case_types)]\n \n-use option::Option::{Some, None};\n+use prelude::*;\n+\n use os;\n use sync::atomic;\n "}, {"sha": "d64336569c6e9e98eac3453279a6cf965af66c19", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -91,7 +91,7 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n         // created. Note that this isn't necessary in general for new threads,\n         // but we just do this to name the main thread and to give it correct\n         // info about the stack bounds.\n-        let thread: Thread = NewThread::new(Some(\"<main>\".into_string()));\n+        let thread: Thread = NewThread::new(Some(\"<main>\".to_string()));\n         thread_info::set((my_stack_bottom, my_stack_top),\n                          sys::thread::guard::main(),\n                          thread);"}, {"sha": "eb15a7ba378e0e48d857b1f2fce5162071f62a2c", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -512,7 +512,7 @@ pub fn begin_unwind_fmt(msg: &fmt::Arguments, file_line: &(&'static str, uint))\n     let mut v = Vec::new();\n     let _ = write!(&mut VecWriter { v: &mut v }, \"{}\", msg);\n \n-    let msg = box String::from_utf8_lossy(v.as_slice()).into_string();\n+    let msg = box String::from_utf8_lossy(v.as_slice()).into_owned();\n     begin_unwind_inner(msg, file_line)\n }\n "}, {"sha": "d8cd8455deb5cfdf39b052d91b0e8b13423fc181", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -10,16 +10,16 @@\n //\n // ignore-lexer-test FIXME #15677\n \n-use core::prelude::*;\n+use prelude::*;\n \n-use core::cmp;\n-use core::fmt;\n-use core::intrinsics;\n-use core::slice;\n-use core::str;\n-\n-use libc::{mod, uintptr_t};\n+use cmp;\n+use fmt;\n+use intrinsics;\n+use libc::uintptr_t;\n+use libc;\n use os;\n+use slice;\n+use str;\n use sync::atomic;\n \n /// Dynamically inquire about whether we're running under V.\n@@ -52,7 +52,7 @@ pub fn min_stack() -> uint {\n         0 => {}\n         n => return n - 1,\n     }\n-    let amt = os::getenv(\"RUST_MIN_STACK\").and_then(|s| from_str(s.as_slice()));\n+    let amt = os::getenv(\"RUST_MIN_STACK\").and_then(|s| s.parse());\n     let amt = amt.unwrap_or(2 * 1024 * 1024);\n     // 0 is our sentinel value, so ensure that we'll never see 0 after\n     // initialization has run\n@@ -65,7 +65,7 @@ pub fn min_stack() -> uint {\n pub fn default_sched_threads() -> uint {\n     match os::getenv(\"RUST_THREADS\") {\n         Some(nstr) => {\n-            let opt_n: Option<uint> = from_str(nstr.as_slice());\n+            let opt_n: Option<uint> = nstr.parse();\n             match opt_n {\n                 Some(n) if n > 0 => n,\n                 _ => panic!(\"`RUST_THREADS` is `{}`, should be a positive integer\", nstr)\n@@ -113,9 +113,8 @@ impl fmt::FormatWriter for Stdio {\n }\n \n pub fn dumb_print(args: &fmt::Arguments) {\n-    use fmt::FormatWriter;\n     let mut w = Stderr;\n-    let _ = w.write_fmt(args);\n+    let _ = write!(&mut w, \"{}\", args);\n }\n \n pub fn abort(args: &fmt::Arguments) -> ! {"}, {"sha": "1d646eb06b16774f2fd00705972f2e7cef663d86", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -8,12 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use io::{IoResult, Writer};\n-use iter::{Iterator, IteratorExt};\n-use option::Option::{Some, None};\n-use result::Result::{Ok, Err};\n-use str::{StrPrelude, from_str};\n-use unicode::char::UnicodeChar;\n+use prelude::*;\n+\n+use io::IoResult;\n \n #[cfg(target_word_size = \"64\")] pub const HEX_WIDTH: uint = 18;\n #[cfg(target_word_size = \"32\")] pub const HEX_WIDTH: uint = 10;\n@@ -85,7 +82,7 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n             while rest.char_at(0).is_numeric() {\n                 rest = rest.slice_from(1);\n             }\n-            let i: uint = from_str(inner.slice_to(inner.len() - rest.len())).unwrap();\n+            let i: uint = inner.slice_to(inner.len() - rest.len()).parse().unwrap();\n             inner = rest.slice_from(i);\n             rest = rest.slice_to(i);\n             while rest.len() > 0 {"}, {"sha": "42c8f7705e1fcdf2fbcdce5c43ad091486d2ece2", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -32,7 +32,7 @@ use path::Path;\n use result::Result::{Ok, Err};\n use sync::{StaticMutex, MUTEX_INIT};\n use slice::SliceExt;\n-use str::StrPrelude;\n+use str::StrExt;\n use dynamic_lib::DynamicLibrary;\n \n use sys_common::backtrace::*;"}, {"sha": "15eddd569beec82d9d6171a1977283997d3b203c", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -23,6 +23,7 @@ use io;\n \n use prelude::*;\n use sys;\n+use sys::os;\n use sys_common::{keep_going, eof, mkerr_libc};\n \n use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n@@ -262,7 +263,7 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n             let mut more_files = 1 as libc::BOOL;\n             while more_files != 0 {\n                 {\n-                    let filename = str::truncate_utf16_at_nul(&wfd.cFileName);\n+                    let filename = os::truncate_utf16_at_nul(&wfd.cFileName);\n                     match String::from_utf16(filename) {\n                         Some(filename) => paths.push(Path::new(filename)),\n                         None => {"}, {"sha": "e007b46b261b485819cfe17ed5da4413ae472e00", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -168,7 +168,7 @@ pub fn getcwd() -> IoResult<Path> {\n         }\n     }\n \n-    match String::from_utf16(::str::truncate_utf16_at_nul(&buf)) {\n+    match String::from_utf16(truncate_utf16_at_nul(&buf)) {\n         Some(ref cwd) => Ok(Path::new(cwd)),\n         None => Err(IoError {\n             kind: OtherIoError,\n@@ -279,7 +279,7 @@ pub fn load_self() -> Option<Vec<u8>> {\n     unsafe {\n         fill_utf16_buf_and_decode(|buf, sz| {\n             libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n-        }).map(|s| s.into_string().into_bytes())\n+        }).map(|s| s.to_string().into_bytes())\n     }\n }\n "}, {"sha": "0c2c76077dd5458595987f6b4c7736307110919e", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -122,7 +122,7 @@ impl Process {\n \n         use mem;\n         use iter::{Iterator, IteratorExt};\n-        use str::StrPrelude;\n+        use str::StrExt;\n \n         if cfg.gid().is_some() || cfg.uid().is_some() {\n             return Err(IoError {"}, {"sha": "f793de5bb57ef9f735ea28fe6d989ec9be725bc4", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -111,7 +111,7 @@ impl TTY {\n     }\n \n     pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let utf16 = match from_utf8(buf) {\n+        let utf16 = match from_utf8(buf).ok() {\n             Some(utf8) => {\n                 utf8.utf16_units().collect::<Vec<u16>>()\n             }"}, {"sha": "3eea5b27f1956a45a7b12050c9c8751b452b14ac", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -189,7 +189,7 @@ impl<S: Encoder<E>, E> Encodable<S, E> for Ident {\n \n impl<D:Decoder<E>, E> Decodable<D, E> for Ident {\n     fn decode(d: &mut D) -> Result<Ident, E> {\n-        Ok(str_to_ident(try!(d.read_str()).as_slice()))\n+        Ok(str_to_ident(try!(d.read_str())[]))\n     }\n }\n "}, {"sha": "e3eeb453c26ba9c354c0a34b3a24f66d889a8c3e", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -95,7 +95,7 @@ pub fn path_to_string<PI: Iterator<PathElem>>(path: PI) -> String {\n         if !s.is_empty() {\n             s.push_str(\"::\");\n         }\n-        s.push_str(e.as_slice());\n+        s.push_str(e[]);\n         s\n     }).to_string()\n }\n@@ -472,20 +472,20 @@ impl<'ast> Map<'ast> {\n         F: FnOnce(Option<&[Attribute]>) -> T,\n     {\n         let attrs = match self.get(id) {\n-            NodeItem(i) => Some(i.attrs.as_slice()),\n-            NodeForeignItem(fi) => Some(fi.attrs.as_slice()),\n+            NodeItem(i) => Some(i.attrs[]),\n+            NodeForeignItem(fi) => Some(fi.attrs[]),\n             NodeTraitItem(ref tm) => match **tm {\n-                RequiredMethod(ref type_m) => Some(type_m.attrs.as_slice()),\n-                ProvidedMethod(ref m) => Some(m.attrs.as_slice()),\n-                TypeTraitItem(ref typ) => Some(typ.attrs.as_slice()),\n+                RequiredMethod(ref type_m) => Some(type_m.attrs[]),\n+                ProvidedMethod(ref m) => Some(m.attrs[]),\n+                TypeTraitItem(ref typ) => Some(typ.attrs[]),\n             },\n             NodeImplItem(ref ii) => {\n                 match **ii {\n-                    MethodImplItem(ref m) => Some(m.attrs.as_slice()),\n-                    TypeImplItem(ref t) => Some(t.attrs.as_slice()),\n+                    MethodImplItem(ref m) => Some(m.attrs[]),\n+                    TypeImplItem(ref t) => Some(t.attrs[]),\n                 }\n             }\n-            NodeVariant(ref v) => Some(v.node.attrs.as_slice()),\n+            NodeVariant(ref v) => Some(v.node.attrs[]),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n             // FIXME(eddyb) make this work again (requires access to the map).\n@@ -504,8 +504,8 @@ impl<'ast> Map<'ast> {\n     /// the iterator will produce node id's for items with paths\n     /// such as `foo::bar::quux`, `bar::quux`, `other::bar::quux`, and\n     /// any other such items it can find in the map.\n-    pub fn nodes_matching_suffix<'a, S:Str>(&'a self, parts: &'a [S])\n-                                 -> NodesMatchingSuffix<'a, 'ast, S> {\n+    pub fn nodes_matching_suffix<'a>(&'a self, parts: &'a [String])\n+                                 -> NodesMatchingSuffix<'a, 'ast> {\n         NodesMatchingSuffix {\n             map: self,\n             item_name: parts.last().unwrap(),\n@@ -565,14 +565,14 @@ impl<'ast> Map<'ast> {\n     }\n }\n \n-pub struct NodesMatchingSuffix<'a, 'ast:'a, S:'a> {\n+pub struct NodesMatchingSuffix<'a, 'ast:'a> {\n     map: &'a Map<'ast>,\n-    item_name: &'a S,\n-    in_which: &'a [S],\n+    item_name: &'a String,\n+    in_which: &'a [String],\n     idx: NodeId,\n }\n \n-impl<'a, 'ast, S:Str> NodesMatchingSuffix<'a, 'ast, S> {\n+impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n     /// Returns true only if some suffix of the module path for parent\n     /// matches `self.in_which`.\n     ///\n@@ -586,7 +586,7 @@ impl<'a, 'ast, S:Str> NodesMatchingSuffix<'a, 'ast, S> {\n                 None => return false,\n                 Some((node_id, name)) => (node_id, name),\n             };\n-            if part.as_slice() != mod_name.as_str() {\n+            if part[] != mod_name.as_str() {\n                 return false;\n             }\n             cursor = self.map.get_parent(mod_id);\n@@ -624,12 +624,12 @@ impl<'a, 'ast, S:Str> NodesMatchingSuffix<'a, 'ast, S> {\n     // We are looking at some node `n` with a given name and parent\n     // id; do their names match what I am seeking?\n     fn matches_names(&self, parent_of_n: NodeId, name: Name) -> bool {\n-        name.as_str() == self.item_name.as_slice() &&\n+        name.as_str() == self.item_name[] &&\n             self.suffix_matches(parent_of_n)\n     }\n }\n \n-impl<'a, 'ast, S:Str> Iterator<NodeId> for NodesMatchingSuffix<'a, 'ast, S> {\n+impl<'a, 'ast> Iterator<NodeId> for NodesMatchingSuffix<'a, 'ast> {\n     fn next(&mut self) -> Option<NodeId> {\n         loop {\n             let idx = self.idx;\n@@ -1037,7 +1037,7 @@ impl<'a> NodePrinter for pprust::State<'a> {\n \n fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n     let id_str = format!(\" (id={})\", id);\n-    let id_str = if include_id { id_str.as_slice() } else { \"\" };\n+    let id_str = if include_id { id_str[] } else { \"\" };\n \n     match map.find(id) {\n         Some(NodeItem(item)) => {"}, {"sha": "5727866d6ec3ef0ee953272d916e156abb765a66", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -238,11 +238,11 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     match *trait_ref {\n         Some(ref trait_ref) => {\n             pretty.push('.');\n-            pretty.push_str(pprust::path_to_string(&trait_ref.path).as_slice());\n+            pretty.push_str(pprust::path_to_string(&trait_ref.path)[]);\n         }\n         None => {}\n     }\n-    token::gensym_ident(pretty.as_slice())\n+    token::gensym_ident(pretty[])\n }\n \n pub fn trait_method_to_ty_method(method: &Method) -> TypeMethod {\n@@ -700,7 +700,7 @@ pub fn pat_is_ident(pat: P<ast::Pat>) -> bool {\n pub fn path_name_eq(a : &ast::Path, b : &ast::Path) -> bool {\n     (a.span == b.span)\n     && (a.global == b.global)\n-    && (segments_name_eq(a.segments.as_slice(), b.segments.as_slice()))\n+    && (segments_name_eq(a.segments[], b.segments[]))\n }\n \n // are two arrays of segments equal when compared unhygienically?\n@@ -788,13 +788,13 @@ mod test {\n     #[test] fn idents_name_eq_test() {\n         assert!(segments_name_eq(\n             [Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice(),\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[],\n             [Ident{name:Name(3),ctxt:104}, Ident{name:Name(78),ctxt:182}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice()));\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[]));\n         assert!(!segments_name_eq(\n             [Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice(),\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[],\n             [Ident{name:Name(3),ctxt:104}, Ident{name:Name(77),ctxt:182}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice()));\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[]));\n     }\n }"}, {"sha": "b1158917b72f98b21444b776993df8fa86167444", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -97,7 +97,7 @@ impl AttrMetaMethods for MetaItem {\n \n     fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n         match self.node {\n-            MetaList(_, ref l) => Some(l.as_slice()),\n+            MetaList(_, ref l) => Some(l[]),\n             _ => None\n         }\n     }\n@@ -136,7 +136,7 @@ impl AttributeMethods for Attribute {\n             let meta = mk_name_value_item_str(\n                 InternedString::new(\"doc\"),\n                 token::intern_and_get_ident(strip_doc_comment_decoration(\n-                        comment.get()).as_slice()));\n+                        comment.get())[]));\n             if self.node.style == ast::AttrOuter {\n                 f(&mk_attr_outer(self.node.id, meta))\n             } else {\n@@ -296,9 +296,9 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n             }\n             MetaList(ref n, ref items) if *n == \"inline\" => {\n                 mark_used(attr);\n-                if contains_name(items.as_slice(), \"always\") {\n+                if contains_name(items[], \"always\") {\n                     InlineAlways\n-                } else if contains_name(items.as_slice(), \"never\") {\n+                } else if contains_name(items[], \"never\") {\n                     InlineNever\n                 } else {\n                     InlineHint\n@@ -332,7 +332,7 @@ pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::Me\n             !cfg_matches(diagnostic, cfgs, &*mis[0])\n         }\n         ast::MetaList(ref pred, _) => {\n-            diagnostic.span_err(cfg.span, format!(\"invalid predicate `{}`\", pred).as_slice());\n+            diagnostic.span_err(cfg.span, format!(\"invalid predicate `{}`\", pred)[]);\n             false\n         },\n         ast::MetaWord(_) | ast::MetaNameValue(..) => contains(cfgs, cfg),\n@@ -396,8 +396,7 @@ pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n \n         if !set.insert(name.clone()) {\n             diagnostic.span_fatal(meta.span,\n-                                  format!(\"duplicate meta item `{}`\",\n-                                          name).as_slice());\n+                                  format!(\"duplicate meta item `{}`\", name)[]);\n         }\n     }\n }"}, {"sha": "060e1d3f9957092273eda187714f07d852c3629b", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -291,9 +291,9 @@ impl FileMap {\n         lines.get(line_number).map(|&line| {\n             let begin: BytePos = line - self.start_pos;\n             let begin = begin.to_uint();\n-            let slice = self.src.slice_from(begin);\n+            let slice = self.src[begin..];\n             match slice.find('\\n') {\n-                Some(e) => slice.slice_to(e),\n+                Some(e) => slice[0..e],\n                 None => slice\n             }.to_string()\n         })\n@@ -338,9 +338,9 @@ impl CodeMap {\n         // FIXME #12884: no efficient/safe way to remove from the start of a string\n         // and reuse the allocation.\n         let mut src = if src.starts_with(\"\\u{feff}\") {\n-            String::from_str(src.slice_from(3))\n+            String::from_str(src[3..])\n         } else {\n-            String::from_str(src.as_slice())\n+            String::from_str(src[])\n         };\n \n         // Append '\\n' in case it's not already there.\n@@ -427,8 +427,8 @@ impl CodeMap {\n         if begin.fm.start_pos != end.fm.start_pos {\n             None\n         } else {\n-            Some(begin.fm.src.slice(begin.pos.to_uint(),\n-                                    end.pos.to_uint()).to_string())\n+            Some(begin.fm.src[begin.pos.to_uint()..\n+                              end.pos.to_uint()].to_string())\n         }\n     }\n "}, {"sha": "88dfdf6e2d8f6b85c4eb05835139b98567a2ef2e", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -123,7 +123,7 @@ impl SpanHandler {\n         panic!(ExplicitBug);\n     }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n-        self.span_bug(sp, format!(\"unimplemented {}\", msg).as_slice());\n+        self.span_bug(sp, format!(\"unimplemented {}\", msg)[]);\n     }\n     pub fn handler<'a>(&'a self) -> &'a Handler {\n         &self.handler\n@@ -166,7 +166,7 @@ impl Handler {\n                         self.err_count.get());\n           }\n         }\n-        self.fatal(s.as_slice());\n+        self.fatal(s[]);\n     }\n     pub fn warn(&self, msg: &str) {\n         self.emit.borrow_mut().emit(None, msg, None, Warning);\n@@ -182,7 +182,7 @@ impl Handler {\n         panic!(ExplicitBug);\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n-        self.bug(format!(\"unimplemented {}\", msg).as_slice());\n+        self.bug(format!(\"unimplemented {}\", msg)[]);\n     }\n     pub fn emit(&self,\n                 cmsp: Option<(&codemap::CodeMap, Span)>,\n@@ -277,7 +277,7 @@ fn print_maybe_styled(w: &mut EmitterWriter,\n             // to be miscolored. We assume this is rare enough that we don't\n             // have to worry about it.\n             if msg.ends_with(\"\\n\") {\n-                try!(t.write_str(msg.slice_to(msg.len()-1)));\n+                try!(t.write_str(msg[0..msg.len()-1]));\n                 try!(t.reset());\n                 try!(t.write_str(\"\\n\"));\n             } else {\n@@ -299,16 +299,16 @@ fn print_diagnostic(dst: &mut EmitterWriter, topic: &str, lvl: Level,\n     }\n \n     try!(print_maybe_styled(dst,\n-                            format!(\"{}: \", lvl.to_string()).as_slice(),\n+                            format!(\"{}: \", lvl.to_string())[],\n                             term::attr::ForegroundColor(lvl.color())));\n     try!(print_maybe_styled(dst,\n-                            format!(\"{}\", msg).as_slice(),\n+                            format!(\"{}\", msg)[],\n                             term::attr::Bold));\n \n     match code {\n         Some(code) => {\n             let style = term::attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n-            try!(print_maybe_styled(dst, format!(\" [{}]\", code.clone()).as_slice(), style));\n+            try!(print_maybe_styled(dst, format!(\" [{}]\", code.clone())[], style));\n         }\n         None => ()\n     }\n@@ -398,12 +398,12 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         // the span)\n         let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n         let ses = cm.span_to_string(span_end);\n-        try!(print_diagnostic(dst, ses.as_slice(), lvl, msg, code));\n+        try!(print_diagnostic(dst, ses[], lvl, msg, code));\n         if rsp.is_full_span() {\n             try!(custom_highlight_lines(dst, cm, sp, lvl, lines));\n         }\n     } else {\n-        try!(print_diagnostic(dst, ss.as_slice(), lvl, msg, code));\n+        try!(print_diagnostic(dst, ss[], lvl, msg, code));\n         if rsp.is_full_span() {\n             try!(highlight_lines(dst, cm, sp, lvl, lines));\n         }\n@@ -413,9 +413,9 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         Some(code) =>\n             match dst.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n                 Some(_) => {\n-                    try!(print_diagnostic(dst, ss.as_slice(), Help,\n+                    try!(print_diagnostic(dst, ss[], Help,\n                                           format!(\"pass `--explain {}` to see a detailed \\\n-                                                   explanation\", code).as_slice(), None));\n+                                                   explanation\", code)[], None));\n                 }\n                 None => ()\n             },\n@@ -432,7 +432,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     let fm = &*lines.file;\n \n     let mut elided = false;\n-    let mut display_lines = lines.lines.as_slice();\n+    let mut display_lines = lines.lines[];\n     if display_lines.len() > MAX_LINES {\n         display_lines = display_lines[0u..MAX_LINES];\n         elided = true;\n@@ -494,7 +494,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n             }\n         }\n         try!(print_maybe_styled(err,\n-                                format!(\"{}\\n\", s).as_slice(),\n+                                format!(\"{}\\n\", s)[],\n                                 term::attr::ForegroundColor(lvl.color())));\n     }\n     Ok(())\n@@ -514,7 +514,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n                           -> io::IoResult<()> {\n     let fm = &*lines.file;\n \n-    let lines = lines.lines.as_slice();\n+    let lines = lines.lines[];\n     if lines.len() > MAX_LINES {\n         if let Some(line) = fm.get_line(lines[0]) {\n             try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n@@ -545,7 +545,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n     s.push('^');\n     s.push('\\n');\n     print_maybe_styled(w,\n-                       s.as_slice(),\n+                       s[],\n                        term::attr::ForegroundColor(lvl.color()))\n }\n \n@@ -560,12 +560,12 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n                 codemap::MacroAttribute => (\"#[\", \"]\"),\n                 codemap::MacroBang => (\"\", \"!\")\n             };\n-            try!(print_diagnostic(w, ss.as_slice(), Note,\n+            try!(print_diagnostic(w, ss[], Note,\n                                   format!(\"in expansion of {}{}{}\", pre,\n                                           ei.callee.name,\n-                                          post).as_slice(), None));\n+                                          post)[], None));\n             let ss = cm.span_to_string(ei.call_site);\n-            try!(print_diagnostic(w, ss.as_slice(), Note, \"expansion site\", None));\n+            try!(print_diagnostic(w, ss[], Note, \"expansion site\", None));\n             Ok(Some(ei.call_site))\n         }\n         None => Ok(None)\n@@ -578,6 +578,6 @@ pub fn expect<T, M>(diag: &SpanHandler, opt: Option<T>, msg: M) -> T where\n {\n     match opt {\n         Some(t) => t,\n-        None => diag.handler().bug(msg().as_slice()),\n+        None => diag.handler().bug(msg()[]),\n     }\n }"}, {"sha": "90fc28014e64f83101d1827d5f5547e60d1f1511", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -58,7 +58,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n             Some(previous_span) => {\n                 ecx.span_warn(span, format!(\n                     \"diagnostic code {} already used\", token::get_ident(code).get()\n-                ).as_slice());\n+                )[]);\n                 ecx.span_note(previous_span, \"previous invocation\");\n             },\n             None => ()\n@@ -87,12 +87,12 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n         if diagnostics.insert(code.name, description).is_some() {\n             ecx.span_err(span, format!(\n                 \"diagnostic code {} already registered\", token::get_ident(*code).get()\n-            ).as_slice());\n+            )[]);\n         }\n     });\n     let sym = Ident::new(token::gensym((\n         \"__register_diagnostic_\".to_string() + token::get_ident(*code).get()\n-    ).as_slice()));\n+    )[]));\n     MacItems::new(vec![quote_item!(ecx, mod $sym {}).unwrap()].into_iter())\n }\n "}, {"sha": "b77b822a6b2a150ab9db1c84c5790b52e46bc825", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -100,8 +100,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                         Some(('=', _)) => None,\n                         Some(('+', operand)) => {\n                             Some(token::intern_and_get_ident(format!(\n-                                        \"={}\",\n-                                        operand).as_slice()))\n+                                        \"={}\", operand)[]))\n                         }\n                         _ => {\n                             cx.span_err(span, \"output operand constraint lacks '=' or '+'\");"}, {"sha": "62fe718b522bc500cfce3d846dc4cf254753744d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -549,7 +549,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n     pub fn mod_path(&self) -> Vec<ast::Ident> {\n         let mut v = Vec::new();\n-        v.push(token::str_to_ident(self.ecfg.crate_name.as_slice()));\n+        v.push(token::str_to_ident(self.ecfg.crate_name[]));\n         v.extend(self.mod_path.iter().map(|a| *a));\n         return v;\n     }\n@@ -558,7 +558,7 @@ impl<'a> ExtCtxt<'a> {\n         if self.recursion_count > self.ecfg.recursion_limit {\n             self.span_fatal(ei.call_site,\n                             format!(\"recursion limit reached while expanding the macro `{}`\",\n-                                    ei.callee.name).as_slice());\n+                                    ei.callee.name)[]);\n         }\n \n         let mut call_site = ei.call_site;\n@@ -669,7 +669,7 @@ pub fn check_zero_tts(cx: &ExtCtxt,\n                       tts: &[ast::TokenTree],\n                       name: &str) {\n     if tts.len() != 0 {\n-        cx.span_err(sp, format!(\"{} takes no arguments\", name).as_slice());\n+        cx.span_err(sp, format!(\"{} takes no arguments\", name)[]);\n     }\n }\n \n@@ -682,12 +682,12 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n                                -> Option<String> {\n     let mut p = cx.new_parser_from_tts(tts);\n     if p.token == token::Eof {\n-        cx.span_err(sp, format!(\"{} takes 1 argument\", name).as_slice());\n+        cx.span_err(sp, format!(\"{} takes 1 argument\", name)[]);\n         return None\n     }\n     let ret = cx.expander().fold_expr(p.parse_expr());\n     if p.token != token::Eof {\n-        cx.span_err(sp, format!(\"{} takes 1 argument\", name).as_slice());\n+        cx.span_err(sp, format!(\"{} takes 1 argument\", name)[]);\n     }\n     expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| {\n         s.get().to_string()"}, {"sha": "77165168746b7251d6ca834f16c3017ac6dc50b7", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -712,8 +712,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         let expr_file = self.expr_str(span,\n                                       token::intern_and_get_ident(loc.file\n-                                                                  .name\n-                                                                  .as_slice()));\n+                                                                  .name[]));\n         let expr_line = self.expr_uint(span, loc.line);\n         let expr_file_line_tuple = self.expr_tuple(span, vec!(expr_file, expr_line));\n         let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);"}, {"sha": "03dd08fdf7fe43f35d81d5221df75fa60bb0dcdc", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -40,14 +40,14 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                     ast::LitInt(i, ast::UnsignedIntLit(_)) |\n                     ast::LitInt(i, ast::SignedIntLit(_, ast::Plus)) |\n                     ast::LitInt(i, ast::UnsuffixedIntLit(ast::Plus)) => {\n-                        accumulator.push_str(format!(\"{}\", i).as_slice());\n+                        accumulator.push_str(format!(\"{}\", i)[]);\n                     }\n                     ast::LitInt(i, ast::SignedIntLit(_, ast::Minus)) |\n                     ast::LitInt(i, ast::UnsuffixedIntLit(ast::Minus)) => {\n-                        accumulator.push_str(format!(\"-{}\", i).as_slice());\n+                        accumulator.push_str(format!(\"-{}\", i)[]);\n                     }\n                     ast::LitBool(b) => {\n-                        accumulator.push_str(format!(\"{}\", b).as_slice());\n+                        accumulator.push_str(format!(\"{}\", b)[]);\n                     }\n                     ast::LitByte(..) |\n                     ast::LitBinary(..) => {\n@@ -62,5 +62,5 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n     }\n     base::MacExpr::new(cx.expr_str(\n             sp,\n-            token::intern_and_get_ident(accumulator.as_slice())))\n+            token::intern_and_get_ident(accumulator[])))\n }"}, {"sha": "2cf60d30a1b25a16b563cea975011038633176d0", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -40,7 +40,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n             }\n         }\n     }\n-    let res = str_to_ident(res_str.as_slice());\n+    let res = str_to_ident(res_str[]);\n \n     let e = P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,"}, {"sha": "c27a27fce6a908bc671d8695f8bbd78678a6856c", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -31,8 +31,7 @@ pub fn expand_deriving_bound<F>(cx: &mut ExtCtxt,\n                 ref tname => {\n                     cx.span_bug(span,\n                                 format!(\"expected built-in trait name but \\\n-                                         found {}\",\n-                                        *tname).as_slice())\n+                                         found {}\", *tname)[])\n                 }\n             }\n         },"}, {"sha": "eedec6f37c840f11343dc2f92c8f7da5195c7774", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -80,13 +80,11 @@ fn cs_clone(\n         EnumNonMatchingCollapsed (..) => {\n             cx.span_bug(trait_span,\n                         format!(\"non-matching enum variants in \\\n-                                 `deriving({})`\",\n-                                name).as_slice())\n+                                 `deriving({})`\", name)[])\n         }\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span,\n-                        format!(\"static method in `deriving({})`\",\n-                                name).as_slice())\n+                        format!(\"static method in `deriving({})`\", name)[])\n         }\n     }\n \n@@ -103,8 +101,7 @@ fn cs_clone(\n                 None => {\n                     cx.span_bug(trait_span,\n                                 format!(\"unnamed field in normal struct in \\\n-                                         `deriving({})`\",\n-                                        name).as_slice())\n+                                         `deriving({})`\", name)[])\n                 }\n             };\n             cx.field_imm(field.span, ident, subcall(field))"}, {"sha": "a4c70ebbc8efeebf4a157e81b8c92998e74ab9a4", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -174,7 +174,7 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n                 let fields = fields.iter().enumerate().map(|(i, &span)| {\n                     getarg(cx, span,\n                            token::intern_and_get_ident(format!(\"_field{}\",\n-                                                               i).as_slice()),\n+                                                               i)[]),\n                            i)\n                 }).collect();\n "}, {"sha": "aac515ed81ace1646958380a52627753ef0e7c83", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -162,8 +162,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                 let name = match name {\n                     Some(id) => token::get_ident(id),\n                     None => {\n-                        token::intern_and_get_ident(format!(\"_field{}\",\n-                                                            i).as_slice())\n+                        token::intern_and_get_ident(format!(\"_field{}\", i)[])\n                     }\n                 };\n                 let enc = cx.expr_method_call(span, self_.clone(),"}, {"sha": "a2b5c0b9e9623e4d5d3b3850975f6ef422910e55", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -514,15 +514,15 @@ impl<'a> TraitDef<'a> {\n                     self,\n                     struct_def,\n                     type_ident,\n-                    self_args.as_slice(),\n-                    nonself_args.as_slice())\n+                    self_args[],\n+                    nonself_args[])\n             } else {\n                 method_def.expand_struct_method_body(cx,\n                                                      self,\n                                                      struct_def,\n                                                      type_ident,\n-                                                     self_args.as_slice(),\n-                                                     nonself_args.as_slice())\n+                                                     self_args[],\n+                                                     nonself_args[])\n             };\n \n             method_def.create_method(cx,\n@@ -554,15 +554,15 @@ impl<'a> TraitDef<'a> {\n                     self,\n                     enum_def,\n                     type_ident,\n-                    self_args.as_slice(),\n-                    nonself_args.as_slice())\n+                    self_args[],\n+                    nonself_args[])\n             } else {\n                 method_def.expand_enum_method_body(cx,\n                                                    self,\n                                                    enum_def,\n                                                    type_ident,\n                                                    self_args,\n-                                                   nonself_args.as_slice())\n+                                                   nonself_args[])\n             };\n \n             method_def.create_method(cx,\n@@ -649,7 +649,7 @@ impl<'a> MethodDef<'a> {\n \n         for (i, ty) in self.args.iter().enumerate() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = cx.ident_of(format!(\"__arg_{}\", i).as_slice());\n+            let ident = cx.ident_of(format!(\"__arg_{}\", i)[]);\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -756,7 +756,7 @@ impl<'a> MethodDef<'a> {\n                                              struct_path,\n                                              struct_def,\n                                              format!(\"__self_{}\",\n-                                                     i).as_slice(),\n+                                                     i)[],\n                                              ast::MutImmutable);\n             patterns.push(pat);\n             raw_fields.push(ident_expr);\n@@ -912,22 +912,22 @@ impl<'a> MethodDef<'a> {\n             .collect::<Vec<String>>();\n \n         let self_arg_idents = self_arg_names.iter()\n-            .map(|name|cx.ident_of(name.as_slice()))\n+            .map(|name|cx.ident_of(name[]))\n             .collect::<Vec<ast::Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n         // a series of let statements mapping each self_arg to a uint\n         // corresponding to its variant index.\n         let vi_idents: Vec<ast::Ident> = self_arg_names.iter()\n-            .map(|name| { let vi_suffix = format!(\"{}_vi\", name.as_slice());\n-                          cx.ident_of(vi_suffix.as_slice()) })\n+            .map(|name| { let vi_suffix = format!(\"{}_vi\", name[]);\n+                          cx.ident_of(vi_suffix[]) })\n             .collect::<Vec<ast::Ident>>();\n \n         // Builds, via callback to call_substructure_method, the\n         // delegated expression that handles the catch-all case,\n         // using `__variants_tuple` to drive logic if necessary.\n         let catch_all_substructure = EnumNonMatchingCollapsed(\n-            self_arg_idents, variants.as_slice(), vi_idents.as_slice());\n+            self_arg_idents, variants[], vi_idents[]);\n \n         // These arms are of the form:\n         // (Variant1, Variant1, ...) => Body1\n@@ -949,12 +949,12 @@ impl<'a> MethodDef<'a> {\n                 let mut subpats = Vec::with_capacity(self_arg_names.len());\n                 let mut self_pats_idents = Vec::with_capacity(self_arg_names.len() - 1);\n                 let first_self_pat_idents = {\n-                    let (p, idents) = mk_self_pat(cx, self_arg_names[0].as_slice());\n+                    let (p, idents) = mk_self_pat(cx, self_arg_names[0][]);\n                     subpats.push(p);\n                     idents\n                 };\n                 for self_arg_name in self_arg_names.tail().iter() {\n-                    let (p, idents) = mk_self_pat(cx, self_arg_name.as_slice());\n+                    let (p, idents) = mk_self_pat(cx, self_arg_name[]);\n                     subpats.push(p);\n                     self_pats_idents.push(idents);\n                 }\n@@ -1010,7 +1010,7 @@ impl<'a> MethodDef<'a> {\n                                                 &**variant,\n                                                 field_tuples);\n                 let arm_expr = self.call_substructure_method(\n-                    cx, trait_, type_ident, self_args.as_slice(), nonself_args,\n+                    cx, trait_, type_ident, self_args[], nonself_args,\n                     &substructure);\n \n                 cx.arm(sp, vec![single_pat], arm_expr)\n@@ -1063,7 +1063,7 @@ impl<'a> MethodDef<'a> {\n             }\n \n             let arm_expr = self.call_substructure_method(\n-                cx, trait_, type_ident, self_args.as_slice(), nonself_args,\n+                cx, trait_, type_ident, self_args[], nonself_args,\n                 &catch_all_substructure);\n \n             // Builds the expression:\n@@ -1267,7 +1267,7 @@ impl<'a> TraitDef<'a> {\n                     cx.span_bug(sp, \"a struct with named and unnamed fields in `deriving`\");\n                 }\n             };\n-            let ident = cx.ident_of(format!(\"{}_{}\", prefix, i).as_slice());\n+            let ident = cx.ident_of(format!(\"{}_{}\", prefix, i)[]);\n             paths.push(codemap::Spanned{span: sp, node: ident});\n             let val = cx.expr(\n                 sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp,ident)))));\n@@ -1313,7 +1313,7 @@ impl<'a> TraitDef<'a> {\n                 let mut ident_expr = Vec::new();\n                 for (i, va) in variant_args.iter().enumerate() {\n                     let sp = self.set_expn_info(cx, va.ty.span);\n-                    let ident = cx.ident_of(format!(\"{}_{}\", prefix, i).as_slice());\n+                    let ident = cx.ident_of(format!(\"{}_{}\", prefix, i)[]);\n                     let path1 = codemap::Spanned{span: sp, node: ident};\n                     paths.push(path1);\n                     let expr_path = cx.expr_path(cx.path_ident(sp, ident));\n@@ -1356,20 +1356,20 @@ pub fn cs_fold<F>(use_foldl: bool,\n                       field.span,\n                       old,\n                       field.self_.clone(),\n-                      field.other.as_slice())\n+                      field.other[])\n                 })\n             } else {\n                 all_fields.iter().rev().fold(base, |old, field| {\n                     f(cx,\n                       field.span,\n                       old,\n                       field.self_.clone(),\n-                      field.other.as_slice())\n+                      field.other[])\n                 })\n             }\n         },\n         EnumNonMatchingCollapsed(ref all_args, _, tuple) =>\n-            enum_nonmatch_f(cx, trait_span, (all_args.as_slice(), tuple),\n+            enum_nonmatch_f(cx, trait_span, (all_args[], tuple),\n                             substructure.nonself_args),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `deriving`\")\n@@ -1409,7 +1409,7 @@ pub fn cs_same_method<F>(f: F,\n             f(cx, trait_span, called)\n         },\n         EnumNonMatchingCollapsed(ref all_self_args, _, tuple) =>\n-            enum_nonmatch_f(cx, trait_span, (all_self_args.as_slice(), tuple),\n+            enum_nonmatch_f(cx, trait_span, (all_self_args[], tuple),\n                             substructure.nonself_args),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `deriving`\")"}, {"sha": "4a9076b07b5ef2fa50280504baff88d777e37721", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -115,7 +115,7 @@ pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n                                 cx.span_err(titem.span,\n                                             format!(\"unknown `deriving` \\\n                                                      trait: `{}`\",\n-                                                    *tname).as_slice());\n+                                                    *tname)[]);\n                             }\n                         };\n                     }"}, {"sha": "19b45a1e6100718ea121012ed61af0fd2e0f6a0f", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -127,7 +127,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     let formatter = substr.nonself_args[0].clone();\n \n     let meth = cx.ident_of(\"write_fmt\");\n-    let s = token::intern_and_get_ident(format_string.as_slice());\n+    let s = token::intern_and_get_ident(format_string[]);\n     let format_string = cx.expr_str(span, s);\n \n     // phew, not our responsibility any more!"}, {"sha": "9fedc4a158e1569f5d5403cf05fd4e270dfe26ed", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -30,7 +30,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n         Some(v) => v\n     };\n \n-    let e = match os::getenv(var.as_slice()) {\n+    let e = match os::getenv(var[]) {\n       None => {\n           cx.expr_path(cx.path_all(sp,\n                                    true,\n@@ -56,7 +56,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n                                    cx.ident_of(\"Some\")),\n                               vec!(cx.expr_str(sp,\n                                                token::intern_and_get_ident(\n-                                          s.as_slice()))))\n+                                          s[]))))\n       }\n     };\n     MacExpr::new(e)\n@@ -83,7 +83,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         None => {\n             token::intern_and_get_ident(format!(\"environment variable `{}` \\\n                                                  not defined\",\n-                                                var).as_slice())\n+                                                var)[])\n         }\n         Some(second) => {\n             match expr_to_string(cx, second, \"expected string literal\") {\n@@ -106,7 +106,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             cx.span_err(sp, msg.get());\n             cx.expr_uint(sp, 0)\n         }\n-        Some(s) => cx.expr_str(sp, token::intern_and_get_ident(s.as_slice()))\n+        Some(s) => cx.expr_str(sp, token::intern_and_get_ident(s[]))\n     };\n     MacExpr::new(e)\n }"}, {"sha": "f2b6f6bfe16b05e7e46d74e7d48854866c894cda", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -293,7 +293,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                     fld.cx.span_err(\n                         pth.span,\n                         format!(\"macro undefined: '{}!'\",\n-                                extnamestr.get()).as_slice());\n+                                extnamestr.get())[]);\n \n                     // let compilation continue\n                     None\n@@ -309,7 +309,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                                 },\n                             });\n                         let fm = fresh_mark();\n-                        let marked_before = mark_tts(tts.as_slice(), fm);\n+                        let marked_before = mark_tts(tts[], fm);\n \n                         // The span that we pass to the expanders we want to\n                         // be the root of the call stack. That's the most\n@@ -320,7 +320,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                         let opt_parsed = {\n                             let expanded = expandfun.expand(fld.cx,\n                                                             mac_span,\n-                                                            marked_before.as_slice());\n+                                                            marked_before[]);\n                             parse_thunk(expanded)\n                         };\n                         let parsed = match opt_parsed {\n@@ -329,8 +329,8 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                                 fld.cx.span_err(\n                                     pth.span,\n                                     format!(\"non-expression macro in expression position: {}\",\n-                                            extnamestr.get().as_slice()\n-                                            ).as_slice());\n+                                            extnamestr.get()[]\n+                                            )[]);\n                                 return None;\n                             }\n                         };\n@@ -340,7 +340,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                         fld.cx.span_err(\n                             pth.span,\n                             format!(\"'{}' is not a tt-style macro\",\n-                                    extnamestr.get()).as_slice());\n+                                    extnamestr.get())[]);\n                         None\n                     }\n                 }\n@@ -445,7 +445,7 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n             if valid_ident {\n                 fld.cx.mod_push(it.ident);\n             }\n-            let macro_escape = contains_macro_escape(new_attrs.as_slice());\n+            let macro_escape = contains_macro_escape(new_attrs[]);\n             let result = with_exts_frame!(fld.cx.syntax_env,\n                                           macro_escape,\n                                           noop_fold_item(it, fld));\n@@ -553,7 +553,7 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n             None => {\n                 fld.cx.span_err(path_span,\n                                 format!(\"macro undefined: '{}!'\",\n-                                        extnamestr).as_slice());\n+                                        extnamestr)[]);\n                 // let compilation continue\n                 return SmallVector::zero();\n             }\n@@ -566,7 +566,7 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n                                       format!(\"macro {}! expects no ident argument, \\\n                                         given '{}'\",\n                                       extnamestr,\n-                                      token::get_ident(it.ident)).as_slice());\n+                                      token::get_ident(it.ident))[]);\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n@@ -578,14 +578,14 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n                         }\n                     });\n                     // mark before expansion:\n-                    let marked_before = mark_tts(tts.as_slice(), fm);\n-                    expander.expand(fld.cx, it.span, marked_before.as_slice())\n+                    let marked_before = mark_tts(tts[], fm);\n+                    expander.expand(fld.cx, it.span, marked_before[])\n                 }\n                 IdentTT(ref expander, span) => {\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n                                         format!(\"macro {}! expects an ident argument\",\n-                                                extnamestr.get()).as_slice());\n+                                                extnamestr.get())[]);\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n@@ -597,14 +597,14 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n                         }\n                     });\n                     // mark before expansion:\n-                    let marked_tts = mark_tts(tts.as_slice(), fm);\n+                    let marked_tts = mark_tts(tts[], fm);\n                     expander.expand(fld.cx, it.span, it.ident, marked_tts)\n                 }\n                 LetSyntaxTT(ref expander, span) => {\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n                                         format!(\"macro {}! expects an ident argument\",\n-                                                extnamestr.get()).as_slice());\n+                                                extnamestr.get())[]);\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n@@ -621,7 +621,7 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n                 _ => {\n                     fld.cx.span_err(it.span,\n                                     format!(\"{}! is not legal in item position\",\n-                                            extnamestr.get()).as_slice());\n+                                            extnamestr.get())[]);\n                     return SmallVector::zero();\n                 }\n             }\n@@ -639,8 +639,8 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n             // result of expanding a LetSyntaxTT, and thus doesn't\n             // need to be marked. Not that it could be marked anyway.\n             // create issue to recommend refactoring here?\n-            fld.cx.syntax_env.insert(intern(name.as_slice()), ext);\n-            if attr::contains_name(it.attrs.as_slice(), \"macro_export\") {\n+            fld.cx.syntax_env.insert(intern(name[]), ext);\n+            if attr::contains_name(it.attrs[], \"macro_export\") {\n                 fld.cx.exported_macros.push(it);\n             }\n             SmallVector::zero()\n@@ -654,7 +654,7 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n         Right(None) => {\n             fld.cx.span_err(path_span,\n                             format!(\"non-item macro in item position: {}\",\n-                                    extnamestr.get()).as_slice());\n+                                    extnamestr.get())[]);\n             return SmallVector::zero();\n         }\n     };\n@@ -903,7 +903,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n             None => {\n                 fld.cx.span_err(pth.span,\n                                 format!(\"macro undefined: '{}!'\",\n-                                        extnamestr).as_slice());\n+                                        extnamestr)[]);\n                 // let compilation continue\n                 return DummyResult::raw_pat(span);\n             }\n@@ -920,19 +920,19 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                     });\n \n                     let fm = fresh_mark();\n-                    let marked_before = mark_tts(tts.as_slice(), fm);\n+                    let marked_before = mark_tts(tts[], fm);\n                     let mac_span = fld.cx.original_span();\n                     let expanded = match expander.expand(fld.cx,\n                                         mac_span,\n-                                        marked_before.as_slice()).make_pat() {\n+                                        marked_before[]).make_pat() {\n                         Some(e) => e,\n                         None => {\n                             fld.cx.span_err(\n                                 pth.span,\n                                 format!(\n                                     \"non-pattern macro in pattern position: {}\",\n                                     extnamestr.get()\n-                                ).as_slice()\n+                                )[]\n                             );\n                             return DummyResult::raw_pat(span);\n                         }\n@@ -944,7 +944,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                 _ => {\n                     fld.cx.span_err(span,\n                                     format!(\"{}! is not legal in pattern position\",\n-                                            extnamestr.get()).as_slice());\n+                                            extnamestr.get())[]);\n                     return DummyResult::raw_pat(span);\n                 }\n             }\n@@ -1192,8 +1192,7 @@ pub fn expand_crate(parse_sess: &parse::ParseSess,\n     let mut expander = MacroExpander::new(&mut cx);\n \n     for ExportedMacros { crate_name, macros } in imported_macros.into_iter() {\n-        let name = format!(\"<{} macros>\", token::get_ident(crate_name))\n-            .into_string();\n+        let name = format!(\"<{} macros>\", token::get_ident(crate_name));\n \n         for source in macros.into_iter() {\n             let item = parse::parse_item_from_source_str(name.clone(),\n@@ -1238,7 +1237,7 @@ impl Folder for Marker {\n             node: match node {\n                 MacInvocTT(path, tts, ctxt) => {\n                     MacInvocTT(self.fold_path(path),\n-                               self.fold_tts(tts.as_slice()),\n+                               self.fold_tts(tts[]),\n                                mtwt::apply_mark(self.mark, ctxt))\n                 }\n             },\n@@ -1415,9 +1414,9 @@ mod test {\n         let attr2 = make_dummy_attr (\"bar\");\n         let escape_attr = make_dummy_attr (\"macro_escape\");\n         let attrs1 = vec!(attr1.clone(), escape_attr, attr2.clone());\n-        assert_eq!(contains_macro_escape(attrs1.as_slice()),true);\n+        assert_eq!(contains_macro_escape(attrs1[]),true);\n         let attrs2 = vec!(attr1,attr2);\n-        assert_eq!(contains_macro_escape(attrs2.as_slice()),false);\n+        assert_eq!(contains_macro_escape(attrs2[]),false);\n     }\n \n     // make a MetaWord outer attribute with the given name\n@@ -1729,7 +1728,7 @@ foo_module!();\n                 let string = ident.get();\n                 \"xx\" == string\n             }).collect();\n-        let cxbinds: &[&ast::Ident] = cxbinds.as_slice();\n+        let cxbinds: &[&ast::Ident] = cxbinds[];\n         let cxbind = match cxbinds {\n             [b] => b,\n             _ => panic!(\"expected just one binding for ext_cx\")"}, {"sha": "aad4045f00a521edd45912f06f467e8d4dbd12a3", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -136,7 +136,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n                 _ => {\n                     ecx.span_err(p.span,\n                                  format!(\"expected ident for named argument, found `{}`\",\n-                                         p.this_token_to_string()).as_slice());\n+                                         p.this_token_to_string())[]);\n                     return (invocation, None);\n                 }\n             };\n@@ -149,7 +149,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n                 Some(prev) => {\n                     ecx.span_err(e.span,\n                                  format!(\"duplicate argument named `{}`\",\n-                                         name).as_slice());\n+                                         name)[]);\n                     ecx.parse_sess.span_diagnostic.span_note(prev.span, \"previously here\");\n                     continue\n                 }\n@@ -240,7 +240,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     let msg = format!(\"invalid reference to argument `{}` ({})\",\n                                       arg, self.describe_num_args());\n \n-                    self.ecx.span_err(self.fmtsp, msg.as_slice());\n+                    self.ecx.span_err(self.fmtsp, msg[]);\n                     return;\n                 }\n                 {\n@@ -260,7 +260,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     Some(e) => e.span,\n                     None => {\n                         let msg = format!(\"there is no argument named `{}`\", name);\n-                        self.ecx.span_err(self.fmtsp, msg.as_slice());\n+                        self.ecx.span_err(self.fmtsp, msg[]);\n                         return;\n                     }\n                 };\n@@ -303,19 +303,19 @@ impl<'a, 'b> Context<'a, 'b> {\n                                   format!(\"argument redeclared with type `{}` when \\\n                                            it was previously `{}`\",\n                                           *ty,\n-                                          *cur).as_slice());\n+                                          *cur)[]);\n             }\n             (&Known(ref cur), _) => {\n                 self.ecx.span_err(sp,\n                                   format!(\"argument used to format with `{}` was \\\n                                            attempted to not be used for formatting\",\n-                                           *cur).as_slice());\n+                                           *cur)[]);\n             }\n             (_, &Known(ref ty)) => {\n                 self.ecx.span_err(sp,\n                                   format!(\"argument previously used as a format \\\n                                            argument attempted to be used as `{}`\",\n-                                           *ty).as_slice());\n+                                           *ty)[]);\n             }\n             (_, _) => {\n                 self.ecx.span_err(sp, \"argument declared with multiple formats\");\n@@ -380,7 +380,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Translate the accumulated string literals to a literal expression\n     fn trans_literal_string(&mut self) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n-        let s = token::intern_and_get_ident(self.literal.as_slice());\n+        let s = token::intern_and_get_ident(self.literal[]);\n         self.literal.clear();\n         self.ecx.expr_str(sp, s)\n     }\n@@ -552,7 +552,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 None => continue // error already generated\n             };\n \n-            let name = self.ecx.ident_of(format!(\"__arg{}\", i).as_slice());\n+            let name = self.ecx.ident_of(format!(\"__arg{}\", i)[]);\n             pats.push(self.ecx.pat_ident(e.span, name));\n             locals.push(Context::format_arg(self.ecx, e.span, arg_ty,\n                                             self.ecx.expr_ident(e.span, name)));\n@@ -569,7 +569,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             };\n \n             let lname = self.ecx.ident_of(format!(\"__arg{}\",\n-                                                  *name).as_slice());\n+                                                  *name)[]);\n             pats.push(self.ecx.pat_ident(e.span, lname));\n             names[self.name_positions[*name]] =\n                 Some(Context::format_arg(self.ecx, e.span, arg_ty,\n@@ -652,7 +652,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                   -> P<ast::Expr> {\n         let trait_ = match *ty {\n             Known(ref tyname) => {\n-                match tyname.as_slice() {\n+                match tyname[] {\n                     \"\"  => \"Show\",\n                     \"?\" => \"Show\",\n                     \"e\" => \"LowerExp\",\n@@ -665,7 +665,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     _ => {\n                         ecx.span_err(sp,\n                                      format!(\"unknown format trait `{}`\",\n-                                             *tyname).as_slice());\n+                                             *tyname)[]);\n                         \"Dummy\"\n                     }\n                 }\n@@ -760,8 +760,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     match parser.errors.remove(0) {\n         Some(error) => {\n             cx.ecx.span_err(cx.fmtsp,\n-                            format!(\"invalid format string: {}\",\n-                                    error).as_slice());\n+                            format!(\"invalid format string: {}\", error)[]);\n             return DummyResult::raw_expr(sp);\n         }\n         None => {}"}, {"sha": "368d4fa84476fd08c0ec41cf4adad404c9462430", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -474,7 +474,7 @@ pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n }\n \n fn ids_ext(strs: Vec<String> ) -> Vec<ast::Ident> {\n-    strs.iter().map(|str| str_to_ident((*str).as_slice())).collect()\n+    strs.iter().map(|str| str_to_ident((*str)[])).collect()\n }\n \n fn id_ext(str: &str) -> ast::Ident {\n@@ -676,7 +676,7 @@ fn mk_tt(cx: &ExtCtxt, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n             for i in range(0, tt.len()) {\n                 seq.push(tt.get_tt(i));\n             }\n-            mk_tts(cx, seq.as_slice())\n+            mk_tts(cx, seq[])\n         }\n         ast::TtToken(sp, ref tok) => {\n             let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n@@ -765,7 +765,7 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let stmt_let_tt = cx.stmt_let(sp, true, id_ext(\"tt\"), cx.expr_vec_ng(sp));\n \n     let mut vector = vec!(stmt_let_sp, stmt_let_tt);\n-    vector.extend(mk_tts(cx, tts.as_slice()).into_iter());\n+    vector.extend(mk_tts(cx, tts[]).into_iter());\n     let block = cx.expr_block(\n         cx.block_all(sp,\n                      Vec::new(),"}, {"sha": "7c2c5c1530c99df30006dce8bd849c3adc166fac", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -57,15 +57,15 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let topmost = cx.original_span_in_file();\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n-    let filename = token::intern_and_get_ident(loc.file.name.as_slice());\n+    let filename = token::intern_and_get_ident(loc.file.name[]);\n     base::MacExpr::new(cx.expr_str(topmost, filename))\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                         -> Box<base::MacResult+'static> {\n     let s = pprust::tts_to_string(tts);\n     base::MacExpr::new(cx.expr_str(sp,\n-                                   token::intern_and_get_ident(s.as_slice())))\n+                                   token::intern_and_get_ident(s[])))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n@@ -78,7 +78,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                    .connect(\"::\");\n     base::MacExpr::new(cx.expr_str(\n             sp,\n-            token::intern_and_get_ident(string.as_slice())))\n+            token::intern_and_get_ident(string[])))\n }\n \n /// include! : parse the given file as an expr\n@@ -137,7 +137,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             cx.span_err(sp,\n                         format!(\"couldn't read {}: {}\",\n                                 file.display(),\n-                                e).as_slice());\n+                                e)[]);\n             return DummyResult::expr(sp);\n         }\n         Ok(bytes) => bytes,\n@@ -147,15 +147,15 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             // Add this input file to the code map to make it available as\n             // dependency information\n             let filename = file.display().to_string();\n-            let interned = token::intern_and_get_ident(src.as_slice());\n+            let interned = token::intern_and_get_ident(src[]);\n             cx.codemap().new_filemap(filename, src);\n \n             base::MacExpr::new(cx.expr_str(sp, interned))\n         }\n         Err(_) => {\n             cx.span_err(sp,\n                         format!(\"{} wasn't a utf-8 file\",\n-                                file.display()).as_slice());\n+                                file.display())[]);\n             return DummyResult::expr(sp);\n         }\n     }\n@@ -171,9 +171,7 @@ pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     match File::open(&file).read_to_end() {\n         Err(e) => {\n             cx.span_err(sp,\n-                        format!(\"couldn't read {}: {}\",\n-                                file.display(),\n-                                e).as_slice());\n+                        format!(\"couldn't read {}: {}\", file.display(), e)[]);\n             return DummyResult::expr(sp);\n         }\n         Ok(bytes) => {"}, {"sha": "73ef18b8449e0ee1f31641154e9eeb8d2f96c8aa", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -153,7 +153,7 @@ pub fn count_names(ms: &[TokenTree]) -> uint {\n                 seq.num_captures\n             }\n             &TtDelimited(_, ref delim) => {\n-                count_names(delim.tts.as_slice())\n+                count_names(delim.tts[])\n             }\n             &TtToken(_, MatchNt(..)) => {\n                 1\n@@ -165,7 +165,7 @@ pub fn count_names(ms: &[TokenTree]) -> uint {\n \n pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: BytePos)\n                            -> Box<MatcherPos> {\n-    let match_idx_hi = count_names(ms.as_slice());\n+    let match_idx_hi = count_names(ms[]);\n     let matches = Vec::from_fn(match_idx_hi, |_i| Vec::new());\n     box MatcherPos {\n         stack: vec![],\n@@ -229,7 +229,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                         p_s.span_diagnostic\n                            .span_fatal(sp,\n                                        format!(\"duplicated bind name: {}\",\n-                                               string.get()).as_slice())\n+                                               string.get())[])\n                     }\n                 }\n             }\n@@ -254,13 +254,13 @@ pub fn parse_or_else(sess: &ParseSess,\n                      rdr: TtReader,\n                      ms: Vec<TokenTree> )\n                      -> HashMap<Ident, Rc<NamedMatch>> {\n-    match parse(sess, cfg, rdr, ms.as_slice()) {\n+    match parse(sess, cfg, rdr, ms[]) {\n         Success(m) => m,\n         Failure(sp, str) => {\n-            sess.span_diagnostic.span_fatal(sp, str.as_slice())\n+            sess.span_diagnostic.span_fatal(sp, str[])\n         }\n         Error(sp, str) => {\n-            sess.span_diagnostic.span_fatal(sp, str.as_slice())\n+            sess.span_diagnostic.span_fatal(sp, str[])\n         }\n     }\n }\n@@ -416,7 +416,7 @@ pub fn parse(sess: &ParseSess,\n                         }\n                     }\n                     TtToken(sp, SubstNt(..)) => {\n-                        return Error(sp, \"Cannot transcribe in macro LHS\".into_string())\n+                        return Error(sp, \"Cannot transcribe in macro LHS\".to_string())\n                     }\n                     seq @ TtDelimited(..) | seq @ TtToken(_, DocComment(..)) => {\n                         let lower_elts = mem::replace(&mut ei.top_elts, Tt(seq));\n@@ -446,7 +446,7 @@ pub fn parse(sess: &ParseSess,\n                 for dv in eof_eis[0].matches.iter_mut() {\n                     v.push(dv.pop().unwrap());\n                 }\n-                return Success(nameize(sess, ms, v.as_slice()));\n+                return Success(nameize(sess, ms, v[]));\n             } else if eof_eis.len() > 1u {\n                 return Error(sp, \"ambiguity: multiple successful parses\".to_string());\n             } else {\n@@ -521,7 +521,7 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n         _ => {\n             let token_str = pprust::token_to_string(&p.token);\n             p.fatal((format!(\"expected ident, found {}\",\n-                             token_str.as_slice())).as_slice())\n+                             token_str[]))[])\n         }\n       },\n       \"path\" => {\n@@ -535,8 +535,7 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n         res\n       }\n       _ => {\n-          p.fatal(format!(\"unsupported builtin nonterminal parser: {}\",\n-                          name).as_slice())\n+          p.fatal(format!(\"unsupported builtin nonterminal parser: {}\", name)[])\n       }\n     }\n }"}, {"sha": "08014dc13383f99d822b815a781ffe55bdccf5c6", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -52,7 +52,7 @@ impl<'a> ParserAnyMacro<'a> {\n                                following\",\n                               token_str);\n             let span = parser.span;\n-            parser.span_err(span, msg.as_slice());\n+            parser.span_err(span, msg[]);\n         }\n     }\n }\n@@ -124,8 +124,8 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n                           sp,\n                           self.name,\n                           arg,\n-                          self.lhses.as_slice(),\n-                          self.rhses.as_slice())\n+                          self.lhses[],\n+                          self.rhses[])\n     }\n }\n \n@@ -160,7 +160,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n         match **lhs {\n           MatchedNonterminal(NtTT(ref lhs_tt)) => {\n             let lhs_tt = match **lhs_tt {\n-                TtDelimited(_, ref delim) => delim.tts.as_slice(),\n+                TtDelimited(_, ref delim) => delim.tts[],\n                 _ => cx.span_fatal(sp, \"malformed macro lhs\")\n             };\n             // `None` is because we're not interpolating\n@@ -198,13 +198,13 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 best_fail_spot = sp;\n                 best_fail_msg = (*msg).clone();\n               },\n-              Error(sp, ref msg) => cx.span_fatal(sp, msg.as_slice())\n+              Error(sp, ref msg) => cx.span_fatal(sp, msg[])\n             }\n           }\n           _ => cx.bug(\"non-matcher found in parsed lhses\")\n         }\n     }\n-    cx.span_fatal(best_fail_spot, best_fail_msg.as_slice());\n+    cx.span_fatal(best_fail_spot, best_fail_msg[]);\n }\n \n // Note that macro-by-example's input is also matched against a token tree:"}, {"sha": "deed0b78e87e47665d5cad104cd476f7f424eab1", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -223,7 +223,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                     }\n                     LisContradiction(ref msg) => {\n                         // FIXME #2887 blame macro invoker instead\n-                        r.sp_diag.span_fatal(sp.clone(), msg.as_slice());\n+                        r.sp_diag.span_fatal(sp.clone(), msg[]);\n                     }\n                     LisConstraint(len, _) => {\n                         if len == 0 {\n@@ -280,7 +280,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                                 r.sp_diag.span_fatal(\n                                     r.cur_span, /* blame the macro writer */\n                                     format!(\"variable '{}' is still repeating at this depth\",\n-                                            token::get_ident(ident)).as_slice());\n+                                            token::get_ident(ident))[]);\n                             }\n                         }\n                     }"}, {"sha": "d53a4b0e8d1c1143d866bc32fb50fabf6f1b4eb6", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -133,7 +133,7 @@ impl<'a> Context<'a> {\n             self.span_handler.span_err(span, explain);\n             self.span_handler.span_help(span, format!(\"add #![feature({})] to the \\\n                                                        crate attributes to enable\",\n-                                                      feature).as_slice());\n+                                                      feature)[]);\n         }\n     }\n \n@@ -187,7 +187,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n         }\n         match i.node {\n             ast::ItemForeignMod(ref foreign_module) => {\n-                if attr::contains_name(i.attrs.as_slice(), \"link_args\") {\n+                if attr::contains_name(i.attrs[], \"link_args\") {\n                     self.gate_feature(\"link_args\", i.span,\n                                       \"the `link_args` attribute is not portable \\\n                                        across platforms, it is recommended to \\\n@@ -201,14 +201,14 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n             }\n \n             ast::ItemFn(..) => {\n-                if attr::contains_name(i.attrs.as_slice(), \"plugin_registrar\") {\n+                if attr::contains_name(i.attrs[], \"plugin_registrar\") {\n                     self.gate_feature(\"plugin_registrar\", i.span,\n                                       \"compiler plugins are experimental and possibly buggy\");\n                 }\n             }\n \n             ast::ItemStruct(..) => {\n-                if attr::contains_name(i.attrs.as_slice(), \"simd\") {\n+                if attr::contains_name(i.attrs[], \"simd\") {\n                     self.gate_feature(\"simd\", i.span,\n                                       \"SIMD types are experimental and possibly buggy\");\n                 }\n@@ -285,7 +285,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n-        if attr::contains_name(i.attrs.as_slice(), \"linkage\") {\n+        if attr::contains_name(i.attrs[], \"linkage\") {\n             self.gate_feature(\"linkage\", i.span,\n                               \"the `linkage` attribute is experimental \\\n                                and not portable across platforms\")"}, {"sha": "41693d9d47a51d0cdd67ca2c692daffeadfb1708", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -92,8 +92,7 @@ impl<'a> ParserAttr for Parser<'a> {\n             }\n             _ => {\n                 let token_str = self.this_token_to_string();\n-                self.fatal(format!(\"expected `#`, found `{}`\",\n-                                   token_str).as_slice());\n+                self.fatal(format!(\"expected `#`, found `{}`\", token_str)[]);\n             }\n         };\n "}, {"sha": "b8da8365f7e236a979af9dd199e995bb433d00c4", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -82,7 +82,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         while j > i && lines[j - 1].trim().is_empty() {\n             j -= 1;\n         }\n-        return lines.slice(i, j).iter().map(|x| (*x).clone()).collect();\n+        return lines[i..j].iter().map(|x| (*x).clone()).collect();\n     }\n \n     /// remove a \"[ \\t]*\\*\" block from each line, if possible\n@@ -116,7 +116,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n \n         if can_trim {\n             lines.iter().map(|line| {\n-                line.slice(i + 1, line.len()).to_string()\n+                line[i + 1..line.len()].to_string()\n             }).collect()\n         } else {\n             lines\n@@ -127,12 +127,12 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n     static ONLINERS: &'static [&'static str] = &[\"///!\", \"///\", \"//!\", \"//\"];\n     for prefix in ONLINERS.iter() {\n         if comment.starts_with(*prefix) {\n-            return comment.slice_from(prefix.len()).to_string();\n+            return comment[prefix.len()..].to_string();\n         }\n     }\n \n     if comment.starts_with(\"/*\") {\n-        let lines = comment.slice(3u, comment.len() - 2u)\n+        let lines = comment[3u..comment.len() - 2u]\n             .lines_any()\n             .map(|s| s.to_string())\n             .collect::<Vec<String> >();\n@@ -187,7 +187,7 @@ fn read_line_comments(rdr: &mut StringReader, code_to_the_left: bool,\n         let line = rdr.read_one_line_comment();\n         debug!(\"{}\", line);\n         // Doc comments are not put in comments.\n-        if is_doc_comment(line.as_slice()) {\n+        if is_doc_comment(line[]) {\n             break;\n         }\n         lines.push(line);\n@@ -224,10 +224,10 @@ fn all_whitespace(s: &str, col: CharPos) -> Option<uint> {\n fn trim_whitespace_prefix_and_push_line(lines: &mut Vec<String> ,\n                                         s: String, col: CharPos) {\n     let len = s.len();\n-    let s1 = match all_whitespace(s.as_slice(), col) {\n+    let s1 = match all_whitespace(s[], col) {\n         Some(col) => {\n             if col < len {\n-                s.slice(col, len).to_string()\n+                s[col..len].to_string()\n             } else {\n                 \"\".to_string()\n             }\n@@ -261,7 +261,7 @@ fn read_block_comment(rdr: &mut StringReader,\n             rdr.bump();\n             rdr.bump();\n         }\n-        if is_block_doc_comment(curr_line.as_slice()) {\n+        if is_block_doc_comment(curr_line[]) {\n             return\n         }\n         assert!(!curr_line.contains_char('\\n'));"}, {"sha": "13d020f6ae31b3cede3ef09e87d4daa58cfa152d", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -194,7 +194,7 @@ impl<'a> StringReader<'a> {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n         for c in c.escape_default() { m.push(c) }\n-        self.fatal_span_(from_pos, to_pos, m.as_slice());\n+        self.fatal_span_(from_pos, to_pos, m[]);\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n@@ -203,7 +203,7 @@ impl<'a> StringReader<'a> {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n         for c in c.escape_default() { m.push(c) }\n-        self.err_span_(from_pos, to_pos, m.as_slice());\n+        self.err_span_(from_pos, to_pos, m[]);\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending the\n@@ -212,8 +212,8 @@ impl<'a> StringReader<'a> {\n         m.push_str(\": \");\n         let from = self.byte_offset(from_pos).to_uint();\n         let to = self.byte_offset(to_pos).to_uint();\n-        m.push_str(self.filemap.src.as_slice().slice(from, to));\n-        self.fatal_span_(from_pos, to_pos, m.as_slice());\n+        m.push_str(self.filemap.src[from..to]);\n+        self.fatal_span_(from_pos, to_pos, m[]);\n     }\n \n     /// Advance peek_tok and peek_span to refer to the next token, and\n@@ -299,7 +299,7 @@ impl<'a> StringReader<'a> {\n             while i < s.len() {\n                 let str::CharRange { ch, next } = s.char_range_at(i);\n                 if ch == '\\r' {\n-                    if j < i { buf.push_str(s.slice(j, i)); }\n+                    if j < i { buf.push_str(s[j..i]); }\n                     j = next;\n                     if next >= s.len() || s.char_at(next) != '\\n' {\n                         let pos = start + BytePos(i as u32);\n@@ -309,7 +309,7 @@ impl<'a> StringReader<'a> {\n                 }\n                 i = next;\n             }\n-            if j < s.len() { buf.push_str(s.slice_from(j)); }\n+            if j < s.len() { buf.push_str(s[j..]); }\n             buf\n         }\n     }\n@@ -358,7 +358,7 @@ impl<'a> StringReader<'a> {\n \n     pub fn nextnextch(&self) -> Option<char> {\n         let offset = self.byte_offset(self.pos).to_uint();\n-        let s = self.filemap.deref().src.as_slice();\n+        let s = self.filemap.deref().src[];\n         if offset >= s.len() { return None }\n         let str::CharRange { next, .. } = s.char_range_at(offset);\n         if next < s.len() {\n@@ -554,7 +554,7 @@ impl<'a> StringReader<'a> {\n                     self.translate_crlf(start_bpos, string,\n                                         \"bare CR not allowed in block doc-comment\")\n                 } else { string.into_cow() };\n-                token::DocComment(token::intern(string.as_slice()))\n+                token::DocComment(token::intern(string[]))\n             } else {\n                 token::Comment\n             };\n@@ -1108,7 +1108,7 @@ impl<'a> StringReader<'a> {\n                 // expansion purposes. See #12512 for the gory details of why\n                 // this is necessary.\n                 let ident = self.with_str_from(start, |lifetime_name| {\n-                    str_to_ident(format!(\"'{}\", lifetime_name).as_slice())\n+                    str_to_ident(format!(\"'{}\", lifetime_name)[])\n                 });\n \n                 // Conjure up a \"keyword checking ident\" to make sure that"}, {"sha": "8cefb111fd1fcc1249fbb9a5f1a79467e7839279", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -251,17 +251,17 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n         Err(e) => {\n             err(format!(\"couldn't read {}: {}\",\n                         path.display(),\n-                        e).as_slice());\n+                        e)[]);\n             unreachable!()\n         }\n     };\n-    match str::from_utf8(bytes.as_slice()) {\n+    match str::from_utf8(bytes[]).ok() {\n         Some(s) => {\n             return string_to_filemap(sess, s.to_string(),\n                                      path.as_str().unwrap().to_string())\n         }\n         None => {\n-            err(format!(\"{} is not UTF-8 encoded\", path.display()).as_slice())\n+            err(format!(\"{} is not UTF-8 encoded\", path.display())[])\n         }\n     }\n     unreachable!()\n@@ -391,21 +391,21 @@ pub fn char_lit(lit: &str) -> (char, int) {\n     }\n \n     let msg = format!(\"lexer should have rejected a bad character escape {}\", lit);\n-    let msg2 = msg.as_slice();\n+    let msg2 = msg[];\n \n     fn esc(len: uint, lit: &str) -> Option<(char, int)> {\n-        num::from_str_radix(lit.slice(2, len), 16)\n+        num::from_str_radix(lit[2..len], 16)\n         .and_then(char::from_u32)\n         .map(|x| (x, len as int))\n     }\n \n     let unicode_escape: || -> Option<(char, int)> = ||\n         if lit.as_bytes()[2] == b'{' {\n             let idx = lit.find('}').expect(msg2);\n-            let subslice = lit.slice(3, idx);\n+            let subslice = lit[3..idx];\n             num::from_str_radix(subslice, 16)\n                 .and_then(char::from_u32)\n-                .map(|x| (x, subslice.char_len() as int + 4))\n+                .map(|x| (x, subslice.chars().count() as int + 4))\n         } else {\n             esc(6, lit)\n         };\n@@ -429,7 +429,7 @@ pub fn str_lit(lit: &str) -> String {\n     let error = |i| format!(\"lexer should have rejected {} at {}\", lit, i);\n \n     /// Eat everything up to a non-whitespace\n-    fn eat<'a>(it: &mut iter::Peekable<(uint, char), str::CharOffsets<'a>>) {\n+    fn eat<'a>(it: &mut iter::Peekable<(uint, char), str::CharIndices<'a>>) {\n         loop {\n             match it.peek().map(|x| x.1) {\n                 Some(' ') | Some('\\n') | Some('\\r') | Some('\\t') => {\n@@ -464,7 +464,7 @@ pub fn str_lit(lit: &str) -> String {\n                             eat(&mut chars);\n                         } else {\n                             // otherwise, a normal escape\n-                            let (c, n) = char_lit(lit.slice_from(i));\n+                            let (c, n) = char_lit(lit[i..]);\n                             for _ in range(0, n - 1) { // we don't need to move past the first \\\n                                 chars.next();\n                             }\n@@ -527,7 +527,7 @@ pub fn raw_str_lit(lit: &str) -> String {\n fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n     s.len() > 1 &&\n         first_chars.contains(&s.char_at(0)) &&\n-        s.slice_from(1).chars().all(|c| '0' <= c && c <= '9')\n+        s[1..].chars().all(|c| '0' <= c && c <= '9')\n }\n \n fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n@@ -540,7 +540,7 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n             if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n                 // if it looks like a width, lets try to be helpful.\n                 sd.span_err(sp, &*format!(\"illegal width `{}` for float literal, \\\n-                                          valid widths are 32 and 64\", suf.slice_from(1)));\n+                                          valid widths are 32 and 64\", suf[1..]));\n             } else {\n                 sd.span_err(sp, &*format!(\"illegal suffix `{}` for float literal, \\\n                                           valid suffixes are `f32` and `f64`\", suf));\n@@ -576,7 +576,7 @@ pub fn byte_lit(lit: &str) -> (u8, uint) {\n             b'\\'' => b'\\'',\n             b'0' => b'\\0',\n             _ => {\n-                match ::std::num::from_str_radix::<u64>(lit.slice(2, 4), 16) {\n+                match ::std::num::from_str_radix::<u64>(lit[2..4], 16) {\n                     Some(c) =>\n                         if c > 0xFF {\n                             panic!(err(2))\n@@ -626,7 +626,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n                     }\n                     _ => {\n                         // otherwise, a normal escape\n-                        let (c, n) = byte_lit(lit.slice_from(i));\n+                        let (c, n) = byte_lit(lit[i..]);\n                         // we don't need to move past the first \\\n                         for _ in range(0, n - 1) {\n                             chars.next();\n@@ -655,7 +655,7 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     // s can only be ascii, byte indexing is fine\n \n     let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n-    let mut s = s2.as_slice();\n+    let mut s = s2[];\n \n     debug!(\"integer_lit: {}, {}\", s, suffix);\n \n@@ -688,7 +688,7 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     }\n \n     if base != 10 {\n-        s = s.slice_from(2);\n+        s = s[2..];\n     }\n \n     if let Some(suf) = suffix {\n@@ -710,7 +710,7 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n                 if looks_like_width_suffix(&['i', 'u'], suf) {\n                     sd.span_err(sp, &*format!(\"illegal width `{}` for integer literal; \\\n                                               valid widths are 8, 16, 32 and 64\",\n-                                              suf.slice_from(1)));\n+                                              suf[1..]));\n                 } else {\n                     sd.span_err(sp, &*format!(\"illegal suffix `{}` for numeric literal\", suf));\n                 }\n@@ -808,27 +808,27 @@ mod test {\n     #[test]\n     fn string_to_tts_macro () {\n         let tts = string_to_tts(\"macro_rules! zip (($a)=>($a))\".to_string());\n-        let tts: &[ast::TokenTree] = tts.as_slice();\n+        let tts: &[ast::TokenTree] = tts[];\n         match tts {\n             [ast::TtToken(_, token::Ident(name_macro_rules, token::Plain)),\n              ast::TtToken(_, token::Not),\n              ast::TtToken(_, token::Ident(name_zip, token::Plain)),\n              ast::TtDelimited(_, ref macro_delimed)]\n             if name_macro_rules.as_str() == \"macro_rules\"\n             && name_zip.as_str() == \"zip\" => {\n-                match macro_delimed.tts.as_slice() {\n+                match macro_delimed.tts[] {\n                     [ast::TtDelimited(_, ref first_delimed),\n                      ast::TtToken(_, token::FatArrow),\n                      ast::TtDelimited(_, ref second_delimed)]\n                     if macro_delimed.delim == token::Paren => {\n-                        match first_delimed.tts.as_slice() {\n+                        match first_delimed.tts[] {\n                             [ast::TtToken(_, token::Dollar),\n                              ast::TtToken(_, token::Ident(name, token::Plain))]\n                             if first_delimed.delim == token::Paren\n                             && name.as_str() == \"a\" => {},\n                             _ => panic!(\"value 3: {}\", **first_delimed),\n                         }\n-                        match second_delimed.tts.as_slice() {\n+                        match second_delimed.tts[] {\n                             [ast::TtToken(_, token::Dollar),\n                              ast::TtToken(_, token::Ident(name, token::Plain))]\n                             if second_delimed.delim == token::Paren\n@@ -1106,24 +1106,24 @@ mod test {\n         let use_s = \"use foo::bar::baz;\";\n         let vitem = string_to_view_item(use_s.to_string());\n         let vitem_s = view_item_to_string(&vitem);\n-        assert_eq!(vitem_s.as_slice(), use_s);\n+        assert_eq!(vitem_s[], use_s);\n \n         let use_s = \"use foo::bar as baz;\";\n         let vitem = string_to_view_item(use_s.to_string());\n         let vitem_s = view_item_to_string(&vitem);\n-        assert_eq!(vitem_s.as_slice(), use_s);\n+        assert_eq!(vitem_s[], use_s);\n     }\n \n     #[test] fn parse_extern_crate() {\n         let ex_s = \"extern crate foo;\";\n         let vitem = string_to_view_item(ex_s.to_string());\n         let vitem_s = view_item_to_string(&vitem);\n-        assert_eq!(vitem_s.as_slice(), ex_s);\n+        assert_eq!(vitem_s[], ex_s);\n \n         let ex_s = \"extern crate \\\"foo\\\" as bar;\";\n         let vitem = string_to_view_item(ex_s.to_string());\n         let vitem_s = view_item_to_string(&vitem);\n-        assert_eq!(vitem_s.as_slice(), ex_s);\n+        assert_eq!(vitem_s[], ex_s);\n     }\n \n     fn get_spans_of_pat_idents(src: &str) -> Vec<Span> {\n@@ -1161,9 +1161,9 @@ mod test {\n         for &src in srcs.iter() {\n             let spans = get_spans_of_pat_idents(src);\n             let Span{lo:lo,hi:hi,..} = spans[0];\n-            assert!(\"self\" == src.slice(lo.to_uint(), hi.to_uint()),\n+            assert!(\"self\" == src[lo.to_uint()..hi.to_uint()],\n                     \"\\\"{}\\\" != \\\"self\\\". src=\\\"{}\\\"\",\n-                    src.slice(lo.to_uint(), hi.to_uint()), src)\n+                    src[lo.to_uint()..hi.to_uint()], src)\n         }\n     }\n \n@@ -1202,7 +1202,7 @@ mod test {\n         let docs = item.attrs.iter().filter(|a| a.name().get() == \"doc\")\n                     .map(|a| a.value_str().unwrap().get().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n-        assert_eq!(docs.as_slice(), b);\n+        assert_eq!(docs[], b);\n \n         let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name, source, Vec::new(), &sess).unwrap();"}, {"sha": "e3c831c09bac5cc315858a4da3837e31aec55883", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -113,13 +113,13 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n               kind_str: &str,\n               desc: &str) {\n         self.span_err(sp,\n-                      format!(\"obsolete syntax: {}\", kind_str).as_slice());\n+                      format!(\"obsolete syntax: {}\", kind_str)[]);\n \n         if !self.obsolete_set.contains(&kind) {\n             self.sess\n                 .span_diagnostic\n                 .handler()\n-                .note(format!(\"{}\", desc).as_slice());\n+                .note(format!(\"{}\", desc)[]);\n             self.obsolete_set.insert(kind);\n         }\n     }"}, {"sha": "7e53b28a09c067246335c356e50c0d0471977ce1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -319,7 +319,7 @@ impl TokenType {\n     fn to_string(&self) -> String {\n         match *self {\n             TokenType::Token(ref t) => format!(\"`{}`\", Parser::token_to_string(t)),\n-            TokenType::Operator => \"an operator\".into_string(),\n+            TokenType::Operator => \"an operator\".to_string(),\n         }\n     }\n }\n@@ -384,12 +384,12 @@ impl<'a> Parser<'a> {\n         let token_str = Parser::token_to_string(t);\n         let last_span = self.last_span;\n         self.span_fatal(last_span, format!(\"unexpected token: `{}`\",\n-                                                token_str).as_slice());\n+                                                token_str)[]);\n     }\n \n     pub fn unexpected(&mut self) -> ! {\n         let this_token = self.this_token_to_string();\n-        self.fatal(format!(\"unexpected token: `{}`\", this_token).as_slice());\n+        self.fatal(format!(\"unexpected token: `{}`\", this_token)[]);\n     }\n \n     /// Expect and consume the token t. Signal an error if\n@@ -403,7 +403,7 @@ impl<'a> Parser<'a> {\n                 let this_token_str = self.this_token_to_string();\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    token_str,\n-                                   this_token_str).as_slice())\n+                                   this_token_str)[])\n             }\n         } else {\n             self.expect_one_of(slice::ref_slice(t), &[]);\n@@ -420,7 +420,7 @@ impl<'a> Parser<'a> {\n             let mut i = tokens.iter();\n             // This might be a sign we need a connect method on Iterator.\n             let b = i.next()\n-                     .map_or(\"\".into_string(), |t| t.to_string());\n+                     .map_or(\"\".to_string(), |t| t.to_string());\n             i.enumerate().fold(b, |mut b, (i, ref a)| {\n                 if tokens.len() > 2 && i == tokens.len() - 2 {\n                     b.push_str(\", or \");\n@@ -444,7 +444,7 @@ impl<'a> Parser<'a> {\n             expected.push_all(&*self.expected_tokens);\n             expected.sort_by(|a, b| a.to_string().cmp(&b.to_string()));\n             expected.dedup();\n-            let expect = tokens_to_string(expected.as_slice());\n+            let expect = tokens_to_string(expected[]);\n             let actual = self.this_token_to_string();\n             self.fatal(\n                 (if expected.len() != 1 {\n@@ -455,7 +455,7 @@ impl<'a> Parser<'a> {\n                     (format!(\"expected {}, found `{}`\",\n                              expect,\n                              actual))\n-                }).as_slice()\n+                })[]\n             )\n         }\n     }\n@@ -488,7 +488,7 @@ impl<'a> Parser<'a> {\n             // might be unit-struct construction; check for recoverableinput error.\n             let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n             expected.push_all(inedible);\n-            self.check_for_erroneous_unit_struct_expecting(expected.as_slice());\n+            self.check_for_erroneous_unit_struct_expecting(expected[]);\n         }\n         self.expect_one_of(edible, inedible)\n     }\n@@ -505,9 +505,9 @@ impl<'a> Parser<'a> {\n                .as_ref()\n                .map_or(false, |t| t.is_ident() || t.is_path()) {\n             let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n-            expected.push_all(inedible.as_slice());\n+            expected.push_all(inedible[]);\n             self.check_for_erroneous_unit_struct_expecting(\n-                expected.as_slice());\n+                expected[]);\n         }\n         self.expect_one_of(edible, inedible)\n     }\n@@ -530,7 +530,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 let token_str = self.this_token_to_string();\n                 self.fatal((format!(\"expected ident, found `{}`\",\n-                                    token_str)).as_slice())\n+                                    token_str))[])\n             }\n         }\n     }\n@@ -584,7 +584,7 @@ impl<'a> Parser<'a> {\n             let id_interned_str = token::get_name(kw.to_name());\n             let token_str = self.this_token_to_string();\n             self.fatal(format!(\"expected `{}`, found `{}`\",\n-                               id_interned_str, token_str).as_slice())\n+                               id_interned_str, token_str)[])\n         }\n     }\n \n@@ -595,7 +595,7 @@ impl<'a> Parser<'a> {\n             let span = self.span;\n             self.span_err(span,\n                           format!(\"expected identifier, found keyword `{}`\",\n-                                  token_str).as_slice());\n+                                  token_str)[]);\n         }\n     }\n \n@@ -604,7 +604,7 @@ impl<'a> Parser<'a> {\n         if self.token.is_reserved_keyword() {\n             let token_str = self.this_token_to_string();\n             self.fatal(format!(\"`{}` is a reserved keyword\",\n-                               token_str).as_slice())\n+                               token_str)[])\n         }\n     }\n \n@@ -624,7 +624,7 @@ impl<'a> Parser<'a> {\n                     Parser::token_to_string(&token::BinOp(token::And));\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    found_token,\n-                                   token_str).as_slice())\n+                                   token_str)[])\n             }\n         }\n     }\n@@ -645,7 +645,7 @@ impl<'a> Parser<'a> {\n                     Parser::token_to_string(&token::BinOp(token::Or));\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    token_str,\n-                                   found_token).as_slice())\n+                                   found_token)[])\n             }\n         }\n     }\n@@ -711,7 +711,7 @@ impl<'a> Parser<'a> {\n             let token_str = Parser::token_to_string(&token::Lt);\n             self.fatal(format!(\"expected `{}`, found `{}`\",\n                                token_str,\n-                               found_token).as_slice())\n+                               found_token)[])\n         }\n     }\n \n@@ -763,7 +763,7 @@ impl<'a> Parser<'a> {\n                 let this_token_str = self.this_token_to_string();\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    gt_str,\n-                                   this_token_str).as_slice())\n+                                   this_token_str)[])\n             }\n         }\n     }\n@@ -1392,7 +1392,7 @@ impl<'a> Parser<'a> {\n                     let (inner_attrs, body) =\n                         p.parse_inner_attrs_and_block();\n                     let mut attrs = attrs;\n-                    attrs.push_all(inner_attrs.as_slice());\n+                    attrs.push_all(inner_attrs[]);\n                     ProvidedMethod(P(ast::Method {\n                         attrs: attrs,\n                         id: ast::DUMMY_NODE_ID,\n@@ -1411,7 +1411,7 @@ impl<'a> Parser<'a> {\n                   _ => {\n                       let token_str = p.this_token_to_string();\n                       p.fatal((format!(\"expected `;` or `{{`, found `{}`\",\n-                                       token_str)).as_slice())\n+                                       token_str))[])\n                   }\n                 }\n             }\n@@ -1606,7 +1606,7 @@ impl<'a> Parser<'a> {\n         } else {\n             let this_token_str = self.this_token_to_string();\n             let msg = format!(\"expected type, found `{}`\", this_token_str);\n-            self.fatal(msg.as_slice());\n+            self.fatal(msg[]);\n         };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n@@ -1753,14 +1753,14 @@ impl<'a> Parser<'a> {\n \n                     token::Str_(s) => {\n                         (true,\n-                         LitStr(token::intern_and_get_ident(parse::str_lit(s.as_str()).as_slice()),\n+                         LitStr(token::intern_and_get_ident(parse::str_lit(s.as_str())[]),\n                                 ast::CookedStr))\n                     }\n                     token::StrRaw(s, n) => {\n                         (true,\n                          LitStr(\n                             token::intern_and_get_ident(\n-                                parse::raw_str_lit(s.as_str()).as_slice()),\n+                                parse::raw_str_lit(s.as_str())[]),\n                             ast::RawStr(n)))\n                     }\n                     token::Binary(i) =>\n@@ -2004,7 +2004,7 @@ impl<'a> Parser<'a> {\n                 };\n             }\n             _ => {\n-                self.fatal(format!(\"expected a lifetime name\").as_slice());\n+                self.fatal(format!(\"expected a lifetime name\")[]);\n             }\n         }\n     }\n@@ -2042,7 +2042,7 @@ impl<'a> Parser<'a> {\n                     let msg = format!(\"expected `,` or `>` after lifetime \\\n                                       name, found `{}`\",\n                                       this_token_str);\n-                    self.fatal(msg.as_slice());\n+                    self.fatal(msg[]);\n                 }\n             }\n         }\n@@ -2517,7 +2517,7 @@ impl<'a> Parser<'a> {\n                     hi = self.span.hi;\n                     self.bump();\n \n-                    let index = from_str::<uint>(n.as_str());\n+                    let index = n.as_str().parse::<uint>();\n                     match index {\n                         Some(n) => {\n                             let id = spanned(dot, hi, n);\n@@ -2535,16 +2535,16 @@ impl<'a> Parser<'a> {\n                     let last_span = self.last_span;\n                     let fstr = n.as_str();\n                     self.span_err(last_span,\n-                                  format!(\"unexpected token: `{}`\", n.as_str()).as_slice());\n+                                  format!(\"unexpected token: `{}`\", n.as_str())[]);\n                     if fstr.chars().all(|x| \"0123456789.\".contains_char(x)) {\n-                        let float = match from_str::<f64>(fstr) {\n+                        let float = match fstr.parse::<f64>() {\n                             Some(f) => f,\n                             None => continue,\n                         };\n                         self.span_help(last_span,\n                             format!(\"try parenthesizing the first index; e.g., `(foo.{}){}`\",\n                                     float.trunc() as uint,\n-                                    float.fract().to_string()[1..]).as_slice());\n+                                    float.fract().to_string()[1..])[]);\n                     }\n                     self.abort_if_errors();\n \n@@ -2716,7 +2716,7 @@ impl<'a> Parser<'a> {\n                   };\n                   let token_str = p.this_token_to_string();\n                   p.fatal(format!(\"incorrect close delimiter: `{}`\",\n-                                  token_str).as_slice())\n+                                  token_str)[])\n               },\n               /* we ought to allow different depths of unquotation */\n               token::Dollar if p.quote_depth > 0u => {\n@@ -2734,7 +2734,7 @@ impl<'a> Parser<'a> {\n                     let seq = match seq {\n                         Spanned { node, .. } => node,\n                     };\n-                    let name_num = macro_parser::count_names(seq.as_slice());\n+                    let name_num = macro_parser::count_names(seq[]);\n                     TtSequence(mk_sp(sp.lo, p.span.hi),\n                                Rc::new(SequenceRepetition {\n                                    tts: seq,\n@@ -2885,7 +2885,7 @@ impl<'a> Parser<'a> {\n                         let this_token_to_string = self.this_token_to_string();\n                         self.span_err(span,\n                                       format!(\"expected expression, found `{}`\",\n-                                              this_token_to_string).as_slice());\n+                                              this_token_to_string)[]);\n                         let box_span = mk_sp(lo, self.last_span.hi);\n                         self.span_help(box_span,\n                                        \"perhaps you meant `box() (foo)` instead?\");\n@@ -3264,7 +3264,7 @@ impl<'a> Parser<'a> {\n                 if self.token != token::CloseDelim(token::Brace) {\n                     let token_str = self.this_token_to_string();\n                     self.fatal(format!(\"expected `{}`, found `{}`\", \"}\",\n-                                       token_str).as_slice())\n+                                       token_str)[])\n                 }\n                 etc = true;\n                 break;\n@@ -3285,7 +3285,7 @@ impl<'a> Parser<'a> {\n                     BindByRef(..) | BindByValue(MutMutable) => {\n                         let token_str = self.this_token_to_string();\n                         self.fatal(format!(\"unexpected `{}`\",\n-                                           token_str).as_slice())\n+                                           token_str)[])\n                     }\n                     _ => {}\n                 }\n@@ -3563,7 +3563,7 @@ impl<'a> Parser<'a> {\n             let span = self.span;\n             let tok_str = self.this_token_to_string();\n             self.span_fatal(span,\n-                            format!(\"expected identifier, found `{}`\", tok_str).as_slice());\n+                            format!(\"expected identifier, found `{}`\", tok_str)[]);\n         }\n         let ident = self.parse_ident();\n         let last_span = self.last_span;\n@@ -3664,7 +3664,7 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n         if self.token.is_keyword(keywords::Let) {\n-            check_expected_item(self, item_attrs.as_slice());\n+            check_expected_item(self, item_attrs[]);\n             self.expect_keyword(keywords::Let);\n             let decl = self.parse_let();\n             P(spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID)))\n@@ -3673,7 +3673,7 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(1, |t| *t == token::Not) {\n             // it's a macro invocation:\n \n-            check_expected_item(self, item_attrs.as_slice());\n+            check_expected_item(self, item_attrs[]);\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n@@ -3701,7 +3701,7 @@ impl<'a> Parser<'a> {\n                     let tok_str = self.this_token_to_string();\n                     self.fatal(format!(\"expected {}`(` or `{{`, found `{}`\",\n                                        ident_str,\n-                                       tok_str).as_slice())\n+                                       tok_str)[])\n                 },\n             };\n \n@@ -3749,7 +3749,7 @@ impl<'a> Parser<'a> {\n             }\n         } else {\n             let found_attrs = !item_attrs.is_empty();\n-            let item_err = Parser::expected_item_err(item_attrs.as_slice());\n+            let item_err = Parser::expected_item_err(item_attrs[]);\n             match self.parse_item_or_view_item(item_attrs, false) {\n                 IoviItem(i) => {\n                     let hi = i.span.hi;\n@@ -3793,7 +3793,7 @@ impl<'a> Parser<'a> {\n             let sp = self.span;\n             let tok = self.this_token_to_string();\n             self.span_fatal_help(sp,\n-                                 format!(\"expected `{{`, found `{}`\", tok).as_slice(),\n+                                 format!(\"expected `{{`, found `{}`\", tok)[],\n                                  \"place this code inside a block\");\n         }\n \n@@ -3847,13 +3847,13 @@ impl<'a> Parser<'a> {\n         while self.token != token::CloseDelim(token::Brace) {\n             // parsing items even when they're not allowed lets us give\n             // better error messages and recover more gracefully.\n-            attributes_box.push_all(self.parse_outer_attributes().as_slice());\n+            attributes_box.push_all(self.parse_outer_attributes()[]);\n             match self.token {\n                 token::Semi => {\n                     if !attributes_box.is_empty() {\n                         let last_span = self.last_span;\n                         self.span_err(last_span,\n-                                      Parser::expected_item_err(attributes_box.as_slice()));\n+                                      Parser::expected_item_err(attributes_box[]));\n                         attributes_box = Vec::new();\n                     }\n                     self.bump(); // empty\n@@ -3944,7 +3944,7 @@ impl<'a> Parser<'a> {\n         if !attributes_box.is_empty() {\n             let last_span = self.last_span;\n             self.span_err(last_span,\n-                          Parser::expected_item_err(attributes_box.as_slice()));\n+                          Parser::expected_item_err(attributes_box[]));\n         }\n \n         let hi = self.span.hi;\n@@ -4362,7 +4362,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 let token_str = self.this_token_to_string();\n                 self.fatal(format!(\"expected `self`, found `{}`\",\n-                                   token_str).as_slice())\n+                                   token_str)[])\n             }\n         }\n     }\n@@ -4516,7 +4516,7 @@ impl<'a> Parser<'a> {\n                 _ => {\n                     let token_str = self.this_token_to_string();\n                     self.fatal(format!(\"expected `,` or `)`, found `{}`\",\n-                                       token_str).as_slice())\n+                                       token_str)[])\n                 }\n             }\n             }\n@@ -4692,7 +4692,7 @@ impl<'a> Parser<'a> {\n                 let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n                 let body_span = body.span;\n                 let mut new_attrs = attrs;\n-                new_attrs.push_all(inner_attrs.as_slice());\n+                new_attrs.push_all(inner_attrs[]);\n                 (ast::MethDecl(ident,\n                                generics,\n                                abi,\n@@ -4849,7 +4849,7 @@ impl<'a> Parser<'a> {\n             if fields.len() == 0 {\n                 self.fatal(format!(\"unit-like struct definition should be \\\n                                     written as `struct {};`\",\n-                                   token::get_ident(class_name)).as_slice());\n+                                   token::get_ident(class_name))[]);\n             }\n             self.bump();\n         } else if self.check(&token::OpenDelim(token::Paren)) {\n@@ -4873,7 +4873,7 @@ impl<'a> Parser<'a> {\n             if fields.len() == 0 {\n                 self.fatal(format!(\"unit-like struct definition should be \\\n                                     written as `struct {};`\",\n-                                   token::get_ident(class_name)).as_slice());\n+                                   token::get_ident(class_name))[]);\n             }\n             self.expect(&token::Semi);\n         } else if self.eat(&token::Semi) {\n@@ -4884,7 +4884,7 @@ impl<'a> Parser<'a> {\n             let token_str = self.this_token_to_string();\n             self.fatal(format!(\"expected `{}`, `(`, or `;` after struct \\\n                                 name, found `{}`\", \"{\",\n-                               token_str).as_slice())\n+                               token_str)[])\n         }\n \n         let _ = ast::DUMMY_NODE_ID;  // FIXME: Workaround for crazy bug.\n@@ -4913,7 +4913,7 @@ impl<'a> Parser<'a> {\n                 let token_str = self.this_token_to_string();\n                 self.span_fatal_help(span,\n                                      format!(\"expected `,`, or `}}`, found `{}`\",\n-                                             token_str).as_slice(),\n+                                             token_str)[],\n                                      \"struct fields should be separated by commas\")\n             }\n         }\n@@ -4983,7 +4983,7 @@ impl<'a> Parser<'a> {\n             let mut attrs = self.parse_outer_attributes();\n             if first {\n                 let mut tmp = attrs_remaining.clone();\n-                tmp.push_all(attrs.as_slice());\n+                tmp.push_all(attrs[]);\n                 attrs = tmp;\n                 first = false;\n             }\n@@ -5000,7 +5000,7 @@ impl<'a> Parser<'a> {\n               _ => {\n                   let token_str = self.this_token_to_string();\n                   self.fatal(format!(\"expected item, found `{}`\",\n-                                     token_str).as_slice())\n+                                     token_str)[])\n               }\n             }\n         }\n@@ -5009,7 +5009,7 @@ impl<'a> Parser<'a> {\n             // We parsed attributes for the first item but didn't find it\n             let last_span = self.last_span;\n             self.span_err(last_span,\n-                          Parser::expected_item_err(attrs_remaining.as_slice()));\n+                          Parser::expected_item_err(attrs_remaining[]));\n         }\n \n         ast::Mod {\n@@ -5079,7 +5079,7 @@ impl<'a> Parser<'a> {\n                     -> (ast::Item_, Vec<ast::Attribute> ) {\n         let mut prefix = Path::new(self.sess.span_diagnostic.cm.span_to_filename(self.span));\n         prefix.pop();\n-        let mod_path = Path::new(\".\").join_many(self.mod_path_stack.as_slice());\n+        let mod_path = Path::new(\".\").join_many(self.mod_path_stack[]);\n         let dir_path = prefix.join(&mod_path);\n         let mod_string = token::get_ident(id);\n         let (file_path, owns_directory) = match ::attr::first_attr_value_str_by_name(\n@@ -5089,8 +5089,8 @@ impl<'a> Parser<'a> {\n                 let mod_name = mod_string.get().to_string();\n                 let default_path_str = format!(\"{}.rs\", mod_name);\n                 let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n-                let default_path = dir_path.join(default_path_str.as_slice());\n-                let secondary_path = dir_path.join(secondary_path_str.as_slice());\n+                let default_path = dir_path.join(default_path_str[]);\n+                let secondary_path = dir_path.join(secondary_path_str[]);\n                 let default_exists = default_path.exists();\n                 let secondary_exists = secondary_path.exists();\n \n@@ -5105,13 +5105,13 @@ impl<'a> Parser<'a> {\n                                    format!(\"maybe move this module `{0}` \\\n                                             to its own directory via \\\n                                             `{0}/mod.rs`\",\n-                                           this_module).as_slice());\n+                                           this_module)[]);\n                     if default_exists || secondary_exists {\n                         self.span_note(id_sp,\n                                        format!(\"... or maybe `use` the module \\\n                                                 `{}` instead of possibly \\\n                                                 redeclaring it\",\n-                                               mod_name).as_slice());\n+                                               mod_name)[]);\n                     }\n                     self.abort_if_errors();\n                 }\n@@ -5122,12 +5122,12 @@ impl<'a> Parser<'a> {\n                     (false, false) => {\n                         self.span_fatal_help(id_sp,\n                                              format!(\"file not found for module `{}`\",\n-                                                     mod_name).as_slice(),\n+                                                     mod_name)[],\n                                              format!(\"name the file either {} or {} inside \\\n                                                      the directory {}\",\n                                                      default_path_str,\n                                                      secondary_path_str,\n-                                                     dir_path.display()).as_slice());\n+                                                     dir_path.display())[]);\n                     }\n                     (true, true) => {\n                         self.span_fatal_help(\n@@ -5136,7 +5136,7 @@ impl<'a> Parser<'a> {\n                                      and {}\",\n                                     mod_name,\n                                     default_path_str,\n-                                    secondary_path_str).as_slice(),\n+                                    secondary_path_str)[],\n                             \"delete or rename one of them to remove the ambiguity\");\n                     }\n                 }\n@@ -5158,11 +5158,11 @@ impl<'a> Parser<'a> {\n                 let mut err = String::from_str(\"circular modules: \");\n                 let len = included_mod_stack.len();\n                 for p in included_mod_stack.slice(i, len).iter() {\n-                    err.push_str(p.display().as_cow().as_slice());\n+                    err.push_str(p.display().as_cow()[]);\n                     err.push_str(\" -> \");\n                 }\n-                err.push_str(path.display().as_cow().as_slice());\n-                self.span_fatal(id_sp, err.as_slice());\n+                err.push_str(path.display().as_cow()[]);\n+                self.span_fatal(id_sp, err[]);\n             }\n             None => ()\n         }\n@@ -5243,7 +5243,7 @@ impl<'a> Parser<'a> {\n         if !attrs_remaining.is_empty() {\n             let last_span = self.last_span;\n             self.span_err(last_span,\n-                          Parser::expected_item_err(attrs_remaining.as_slice()));\n+                          Parser::expected_item_err(attrs_remaining[]));\n         }\n         assert!(self.token == token::CloseDelim(token::Brace));\n         ast::ForeignMod {\n@@ -5284,7 +5284,7 @@ impl<'a> Parser<'a> {\n                     self.span_help(span,\n                                    format!(\"perhaps you meant to enclose the crate name `{}` in \\\n                                            a string?\",\n-                                          the_ident.as_str()).as_slice());\n+                                          the_ident.as_str())[]);\n                     None\n                 } else {\n                     None\n@@ -5310,7 +5310,7 @@ impl<'a> Parser<'a> {\n                 self.span_fatal(span,\n                                 format!(\"expected extern crate name but \\\n                                          found `{}`\",\n-                                        token_str).as_slice());\n+                                        token_str)[]);\n             }\n         };\n \n@@ -5408,7 +5408,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(start_span,\n                         format!(\"unit-like struct variant should be written \\\n                                  without braces, as `{},`\",\n-                                token::get_ident(ident)).as_slice());\n+                                token::get_ident(ident))[]);\n                 }\n                 kind = StructVariantKind(struct_def);\n             } else if self.check(&token::OpenDelim(token::Paren)) {\n@@ -5493,7 +5493,7 @@ impl<'a> Parser<'a> {\n                             format!(\"illegal ABI: expected one of [{}], \\\n                                      found `{}`\",\n                                     abi::all_names().connect(\", \"),\n-                                    the_string).as_slice());\n+                                    the_string)[]);\n                         None\n                     }\n                 }\n@@ -5555,7 +5555,7 @@ impl<'a> Parser<'a> {\n                                  format!(\"`extern mod` is obsolete, use \\\n                                           `extern crate` instead \\\n                                           to refer to external \\\n-                                          crates.\").as_slice())\n+                                          crates.\")[])\n                 }\n                 return self.parse_item_extern_crate(lo, visibility, attrs);\n             }\n@@ -5583,7 +5583,7 @@ impl<'a> Parser<'a> {\n             let token_str = self.this_token_to_string();\n             self.span_fatal(span,\n                             format!(\"expected `{}` or `fn`, found `{}`\", \"{\",\n-                                    token_str).as_slice());\n+                                    token_str)[]);\n         }\n \n         if self.eat_keyword(keywords::Virtual) {\n@@ -5696,7 +5696,7 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Mod) {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) =\n-                self.parse_item_mod(attrs.as_slice());\n+                self.parse_item_mod(attrs[]);\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,\n@@ -6031,7 +6031,7 @@ impl<'a> Parser<'a> {\n                                   macros_allowed: bool)\n                                   -> ParsedItemsAndViewItems {\n         let mut attrs = first_item_attrs;\n-        attrs.push_all(self.parse_outer_attributes().as_slice());\n+        attrs.push_all(self.parse_outer_attributes()[]);\n         // First, parse view items.\n         let mut view_items : Vec<ast::ViewItem> = Vec::new();\n         let mut items = Vec::new();\n@@ -6113,7 +6113,7 @@ impl<'a> Parser<'a> {\n                            macros_allowed: bool)\n         -> ParsedItemsAndViewItems {\n         let mut attrs = first_item_attrs;\n-        attrs.push_all(self.parse_outer_attributes().as_slice());\n+        attrs.push_all(self.parse_outer_attributes()[]);\n         let mut foreign_items = Vec::new();\n         loop {\n             match self.parse_foreign_item(attrs, macros_allowed) {"}, {"sha": "9e61eaae35269e72df35793a2c355e80f66355ca", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -454,7 +454,7 @@ macro_rules! declare_special_idents_and_keywords {(\n         $(init_vec.push($si_str);)*\n         $(init_vec.push($sk_str);)*\n         $(init_vec.push($rk_str);)*\n-        interner::StrInterner::prefill(init_vec.as_slice())\n+        interner::StrInterner::prefill(init_vec[])\n     }\n }}\n \n@@ -602,10 +602,14 @@ impl InternedString {\n \n     #[inline]\n     pub fn get<'a>(&'a self) -> &'a str {\n-        self.string.as_slice()\n+        self.string[]\n     }\n }\n \n+impl Deref<str> for InternedString {\n+    fn deref(&self) -> &str { &*self.string }\n+}\n+\n impl BytesContainer for InternedString {\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n         // FIXME #12938: This is a workaround for the incorrect signature\n@@ -620,49 +624,49 @@ impl BytesContainer for InternedString {\n \n impl fmt::Show for InternedString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.string.as_slice())\n+        write!(f, \"{}\", self.string[])\n     }\n }\n \n #[allow(deprecated)]\n impl<'a> Equiv<&'a str> for InternedString {\n     fn equiv(&self, other: & &'a str) -> bool {\n-        (*other) == self.string.as_slice()\n+        (*other) == self.string[]\n     }\n }\n \n impl<'a> PartialEq<&'a str> for InternedString {\n     #[inline(always)]\n     fn eq(&self, other: & &'a str) -> bool {\n-        PartialEq::eq(self.string.as_slice(), *other)\n+        PartialEq::eq(self.string[], *other)\n     }\n     #[inline(always)]\n     fn ne(&self, other: & &'a str) -> bool {\n-        PartialEq::ne(self.string.as_slice(), *other)\n+        PartialEq::ne(self.string[], *other)\n     }\n }\n \n impl<'a> PartialEq<InternedString > for &'a str {\n     #[inline(always)]\n     fn eq(&self, other: &InternedString) -> bool {\n-        PartialEq::eq(*self, other.string.as_slice())\n+        PartialEq::eq(*self, other.string[])\n     }\n     #[inline(always)]\n     fn ne(&self, other: &InternedString) -> bool {\n-        PartialEq::ne(*self, other.string.as_slice())\n+        PartialEq::ne(*self, other.string[])\n     }\n }\n \n impl<D:Decoder<E>, E> Decodable<D, E> for InternedString {\n     fn decode(d: &mut D) -> Result<InternedString, E> {\n         Ok(get_name(get_ident_interner().intern(\n-                    try!(d.read_str()).as_slice())))\n+                    try!(d.read_str())[])))\n     }\n }\n \n impl<S:Encoder<E>, E> Encodable<S, E> for InternedString {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_str(self.string.as_slice())\n+        s.emit_str(self.string[])\n     }\n }\n "}, {"sha": "ab0e0f9585c4ed7165ec540af6c785000ca1a7a4", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -139,12 +139,12 @@ pub fn buf_str(toks: Vec<Token>,\n         }\n         s.push_str(format!(\"{}={}\",\n                            szs[i],\n-                           tok_str(toks[i].clone())).as_slice());\n+                           tok_str(toks[i].clone()))[]);\n         i += 1u;\n         i %= n;\n     }\n     s.push(']');\n-    return s.into_string();\n+    s\n }\n \n #[deriving(Copy)]\n@@ -601,7 +601,7 @@ impl Printer {\n             assert_eq!(l, len);\n             // assert!(l <= space);\n             self.space -= len;\n-            self.print_str(s.as_slice())\n+            self.print_str(s[])\n           }\n           Eof => {\n             // Eof should never get here."}, {"sha": "0d79b7cf9257bf1018d073bd2cdfeaeb9ca07c47", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 131, "deletions": 128, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -30,6 +30,7 @@ use ptr::P;\n \n use std::{ascii, mem};\n use std::io::{mod, IoResult};\n+use std::iter;\n \n pub enum AnnNode<'a> {\n     NodeIdent(&'a ast::Ident),\n@@ -113,7 +114,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                                       out,\n                                       ann,\n                                       is_expanded);\n-    try!(s.print_mod(&krate.module, krate.attrs.as_slice()));\n+    try!(s.print_mod(&krate.module, krate.attrs[]));\n     try!(s.print_remaining_comments());\n     eof(&mut s.s)\n }\n@@ -197,56 +198,56 @@ pub fn binop_to_string(op: BinOpToken) -> &'static str {\n \n pub fn token_to_string(tok: &Token) -> String {\n     match *tok {\n-        token::Eq                   => \"=\".into_string(),\n-        token::Lt                   => \"<\".into_string(),\n-        token::Le                   => \"<=\".into_string(),\n-        token::EqEq                 => \"==\".into_string(),\n-        token::Ne                   => \"!=\".into_string(),\n-        token::Ge                   => \">=\".into_string(),\n-        token::Gt                   => \">\".into_string(),\n-        token::Not                  => \"!\".into_string(),\n-        token::Tilde                => \"~\".into_string(),\n-        token::OrOr                 => \"||\".into_string(),\n-        token::AndAnd               => \"&&\".into_string(),\n-        token::BinOp(op)            => binop_to_string(op).into_string(),\n+        token::Eq                   => \"=\".to_string(),\n+        token::Lt                   => \"<\".to_string(),\n+        token::Le                   => \"<=\".to_string(),\n+        token::EqEq                 => \"==\".to_string(),\n+        token::Ne                   => \"!=\".to_string(),\n+        token::Ge                   => \">=\".to_string(),\n+        token::Gt                   => \">\".to_string(),\n+        token::Not                  => \"!\".to_string(),\n+        token::Tilde                => \"~\".to_string(),\n+        token::OrOr                 => \"||\".to_string(),\n+        token::AndAnd               => \"&&\".to_string(),\n+        token::BinOp(op)            => binop_to_string(op).to_string(),\n         token::BinOpEq(op)          => format!(\"{}=\", binop_to_string(op)),\n \n         /* Structural symbols */\n-        token::At                   => \"@\".into_string(),\n-        token::Dot                  => \".\".into_string(),\n-        token::DotDot               => \"..\".into_string(),\n-        token::DotDotDot            => \"...\".into_string(),\n-        token::Comma                => \",\".into_string(),\n-        token::Semi                 => \";\".into_string(),\n-        token::Colon                => \":\".into_string(),\n-        token::ModSep               => \"::\".into_string(),\n-        token::RArrow               => \"->\".into_string(),\n-        token::LArrow               => \"<-\".into_string(),\n-        token::FatArrow             => \"=>\".into_string(),\n-        token::OpenDelim(token::Paren) => \"(\".into_string(),\n-        token::CloseDelim(token::Paren) => \")\".into_string(),\n-        token::OpenDelim(token::Bracket) => \"[\".into_string(),\n-        token::CloseDelim(token::Bracket) => \"]\".into_string(),\n-        token::OpenDelim(token::Brace) => \"{\".into_string(),\n-        token::CloseDelim(token::Brace) => \"}\".into_string(),\n-        token::Pound                => \"#\".into_string(),\n-        token::Dollar               => \"$\".into_string(),\n-        token::Question             => \"?\".into_string(),\n+        token::At                   => \"@\".to_string(),\n+        token::Dot                  => \".\".to_string(),\n+        token::DotDot               => \"..\".to_string(),\n+        token::DotDotDot            => \"...\".to_string(),\n+        token::Comma                => \",\".to_string(),\n+        token::Semi                 => \";\".to_string(),\n+        token::Colon                => \":\".to_string(),\n+        token::ModSep               => \"::\".to_string(),\n+        token::RArrow               => \"->\".to_string(),\n+        token::LArrow               => \"<-\".to_string(),\n+        token::FatArrow             => \"=>\".to_string(),\n+        token::OpenDelim(token::Paren) => \"(\".to_string(),\n+        token::CloseDelim(token::Paren) => \")\".to_string(),\n+        token::OpenDelim(token::Bracket) => \"[\".to_string(),\n+        token::CloseDelim(token::Bracket) => \"]\".to_string(),\n+        token::OpenDelim(token::Brace) => \"{\".to_string(),\n+        token::CloseDelim(token::Brace) => \"}\".to_string(),\n+        token::Pound                => \"#\".to_string(),\n+        token::Dollar               => \"$\".to_string(),\n+        token::Question             => \"?\".to_string(),\n \n         /* Literals */\n         token::Literal(lit, suf) => {\n             let mut out = match lit {\n                 token::Byte(b)           => format!(\"b'{}'\", b.as_str()),\n                 token::Char(c)           => format!(\"'{}'\", c.as_str()),\n-                token::Float(c)          => c.as_str().into_string(),\n-                token::Integer(c)        => c.as_str().into_string(),\n+                token::Float(c)          => c.as_str().to_string(),\n+                token::Integer(c)        => c.as_str().to_string(),\n                 token::Str_(s)           => format!(\"\\\"{}\\\"\", s.as_str()),\n                 token::StrRaw(s, n)      => format!(\"r{delim}\\\"{string}\\\"{delim}\",\n-                                                    delim=\"#\".repeat(n),\n+                                                    delim=repeat(\"#\", n),\n                                                     string=s.as_str()),\n                 token::Binary(v)         => format!(\"b\\\"{}\\\"\", v.as_str()),\n                 token::BinaryRaw(s, n)   => format!(\"br{delim}\\\"{string}\\\"{delim}\",\n-                                                    delim=\"#\".repeat(n),\n+                                                    delim=repeat(\"#\", n),\n                                                     string=s.as_str()),\n             };\n \n@@ -258,30 +259,30 @@ pub fn token_to_string(tok: &Token) -> String {\n         }\n \n         /* Name components */\n-        token::Ident(s, _)          => token::get_ident(s).get().into_string(),\n+        token::Ident(s, _)          => token::get_ident(s).get().to_string(),\n         token::Lifetime(s)          => format!(\"{}\", token::get_ident(s)),\n-        token::Underscore           => \"_\".into_string(),\n+        token::Underscore           => \"_\".to_string(),\n \n         /* Other */\n-        token::DocComment(s)        => s.as_str().into_string(),\n+        token::DocComment(s)        => s.as_str().to_string(),\n         token::SubstNt(s, _)        => format!(\"${}\", s),\n         token::MatchNt(s, t, _, _)  => format!(\"${}:{}\", s, t),\n-        token::Eof                  => \"<eof>\".into_string(),\n-        token::Whitespace           => \" \".into_string(),\n-        token::Comment              => \"/* */\".into_string(),\n+        token::Eof                  => \"<eof>\".to_string(),\n+        token::Whitespace           => \" \".to_string(),\n+        token::Comment              => \"/* */\".to_string(),\n         token::Shebang(s)           => format!(\"/* shebang: {}*/\", s.as_str()),\n \n         token::Interpolated(ref nt) => match *nt {\n             token::NtExpr(ref e)  => expr_to_string(&**e),\n             token::NtMeta(ref e)  => meta_item_to_string(&**e),\n             token::NtTy(ref e)    => ty_to_string(&**e),\n             token::NtPath(ref e)  => path_to_string(&**e),\n-            token::NtItem(..)     => \"an interpolated item\".into_string(),\n-            token::NtBlock(..)    => \"an interpolated block\".into_string(),\n-            token::NtStmt(..)     => \"an interpolated statement\".into_string(),\n-            token::NtPat(..)      => \"an interpolated pattern\".into_string(),\n-            token::NtIdent(..)    => \"an interpolated identifier\".into_string(),\n-            token::NtTT(..)       => \"an interpolated tt\".into_string(),\n+            token::NtItem(..)     => \"an interpolated item\".to_string(),\n+            token::NtBlock(..)    => \"an interpolated block\".to_string(),\n+            token::NtStmt(..)     => \"an interpolated statement\".to_string(),\n+            token::NtPat(..)      => \"an interpolated pattern\".to_string(),\n+            token::NtIdent(..)    => \"an interpolated identifier\".to_string(),\n+            token::NtTT(..)       => \"an interpolated tt\".to_string(),\n         }\n     }\n }\n@@ -577,7 +578,7 @@ impl<'a> State<'a> {\n     pub fn synth_comment(&mut self, text: String) -> IoResult<()> {\n         try!(word(&mut self.s, \"/*\"));\n         try!(space(&mut self.s));\n-        try!(word(&mut self.s, text.as_slice()));\n+        try!(word(&mut self.s, text[]));\n         try!(space(&mut self.s));\n         word(&mut self.s, \"*/\")\n     }\n@@ -682,7 +683,7 @@ impl<'a> State<'a> {\n             }\n             ast::TyTup(ref elts) => {\n                 try!(self.popen());\n-                try!(self.commasep(Inconsistent, elts.as_slice(),\n+                try!(self.commasep(Inconsistent, elts[],\n                                    |s, ty| s.print_type(&**ty)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n@@ -737,10 +738,10 @@ impl<'a> State<'a> {\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n                 try!(self.print_type(&**ty));\n-                try!(self.print_bounds(\"+\", bounds.as_slice()));\n+                try!(self.print_bounds(\"+\", bounds[]));\n             }\n             ast::TyPolyTraitRef(ref bounds) => {\n-                try!(self.print_bounds(\"\", bounds.as_slice()));\n+                try!(self.print_bounds(\"\", bounds[]));\n             }\n             ast::TyQPath(ref qpath) => {\n                 try!(word(&mut self.s, \"<\"));\n@@ -775,7 +776,7 @@ impl<'a> State<'a> {\n                               item: &ast::ForeignItem) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n-        try!(self.print_outer_attributes(item.attrs.as_slice()));\n+        try!(self.print_outer_attributes(item.attrs[]));\n         match item.node {\n             ast::ForeignItemFn(ref decl, ref generics) => {\n                 try!(self.print_fn(&**decl, None, abi::Rust, item.ident, generics,\n@@ -786,7 +787,7 @@ impl<'a> State<'a> {\n             }\n             ast::ForeignItemStatic(ref t, m) => {\n                 try!(self.head(visibility_qualified(item.vis,\n-                                                    \"static\").as_slice()));\n+                                                    \"static\")[]));\n                 if m {\n                     try!(self.word_space(\"mut\"));\n                 }\n@@ -822,12 +823,12 @@ impl<'a> State<'a> {\n     pub fn print_item(&mut self, item: &ast::Item) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n-        try!(self.print_outer_attributes(item.attrs.as_slice()));\n+        try!(self.print_outer_attributes(item.attrs[]));\n         try!(self.ann.pre(self, NodeItem(item)));\n         match item.node {\n             ast::ItemStatic(ref ty, m, ref expr) => {\n                 try!(self.head(visibility_qualified(item.vis,\n-                                                    \"static\").as_slice()));\n+                                                    \"static\")[]));\n                 if m == ast::MutMutable {\n                     try!(self.word_space(\"mut\"));\n                 }\n@@ -844,7 +845,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemConst(ref ty, ref expr) => {\n                 try!(self.head(visibility_qualified(item.vis,\n-                                                    \"const\").as_slice()));\n+                                                    \"const\")[]));\n                 try!(self.print_ident(item.ident));\n                 try!(self.word_space(\":\"));\n                 try!(self.print_type(&**ty));\n@@ -867,29 +868,29 @@ impl<'a> State<'a> {\n                     item.vis\n                 ));\n                 try!(word(&mut self.s, \" \"));\n-                try!(self.print_block_with_attrs(&**body, item.attrs.as_slice()));\n+                try!(self.print_block_with_attrs(&**body, item.attrs[]));\n             }\n             ast::ItemMod(ref _mod) => {\n                 try!(self.head(visibility_qualified(item.vis,\n-                                                    \"mod\").as_slice()));\n+                                                    \"mod\")[]));\n                 try!(self.print_ident(item.ident));\n                 try!(self.nbsp());\n                 try!(self.bopen());\n-                try!(self.print_mod(_mod, item.attrs.as_slice()));\n+                try!(self.print_mod(_mod, item.attrs[]));\n                 try!(self.bclose(item.span));\n             }\n             ast::ItemForeignMod(ref nmod) => {\n                 try!(self.head(\"extern\"));\n-                try!(self.word_nbsp(nmod.abi.to_string().as_slice()));\n+                try!(self.word_nbsp(nmod.abi.to_string()[]));\n                 try!(self.bopen());\n-                try!(self.print_foreign_mod(nmod, item.attrs.as_slice()));\n+                try!(self.print_foreign_mod(nmod, item.attrs[]));\n                 try!(self.bclose(item.span));\n             }\n             ast::ItemTy(ref ty, ref params) => {\n                 try!(self.ibox(indent_unit));\n                 try!(self.ibox(0u));\n                 try!(self.word_nbsp(visibility_qualified(item.vis,\n-                                                         \"type\").as_slice()));\n+                                                         \"type\")[]));\n                 try!(self.print_ident(item.ident));\n                 try!(self.print_generics(params));\n                 try!(self.end()); // end the inner ibox\n@@ -911,7 +912,7 @@ impl<'a> State<'a> {\n                 ));\n             }\n             ast::ItemStruct(ref struct_def, ref generics) => {\n-                try!(self.head(visibility_qualified(item.vis,\"struct\").as_slice()));\n+                try!(self.head(visibility_qualified(item.vis,\"struct\")[]));\n                 try!(self.print_struct(&**struct_def, generics, item.ident, item.span));\n             }\n \n@@ -944,7 +945,7 @@ impl<'a> State<'a> {\n \n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n-                try!(self.print_inner_attributes(item.attrs.as_slice()));\n+                try!(self.print_inner_attributes(item.attrs[]));\n                 for impl_item in impl_items.iter() {\n                     match *impl_item {\n                         ast::MethodImplItem(ref meth) => {\n@@ -970,7 +971,7 @@ impl<'a> State<'a> {\n                     try!(self.print_trait_ref(tref));\n                     try!(word(&mut self.s, \"?\"));\n                 }\n-                try!(self.print_bounds(\":\", bounds.as_slice()));\n+                try!(self.print_bounds(\":\", bounds[]));\n                 try!(self.print_where_clause(generics));\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.bopen());\n@@ -988,7 +989,7 @@ impl<'a> State<'a> {\n                 try!(self.print_ident(item.ident));\n                 try!(self.cbox(indent_unit));\n                 try!(self.popen());\n-                try!(self.print_tts(tts.as_slice()));\n+                try!(self.print_tts(tts[]));\n                 try!(self.pclose());\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end());\n@@ -1022,12 +1023,12 @@ impl<'a> State<'a> {\n                           generics: &ast::Generics, ident: ast::Ident,\n                           span: codemap::Span,\n                           visibility: ast::Visibility) -> IoResult<()> {\n-        try!(self.head(visibility_qualified(visibility, \"enum\").as_slice()));\n+        try!(self.head(visibility_qualified(visibility, \"enum\")[]));\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n         try!(self.print_where_clause(generics));\n         try!(space(&mut self.s));\n-        self.print_variants(enum_definition.variants.as_slice(), span)\n+        self.print_variants(enum_definition.variants[], span)\n     }\n \n     pub fn print_variants(&mut self,\n@@ -1037,7 +1038,7 @@ impl<'a> State<'a> {\n         for v in variants.iter() {\n             try!(self.space_if_not_bol());\n             try!(self.maybe_print_comment(v.span.lo));\n-            try!(self.print_outer_attributes(v.node.attrs.as_slice()));\n+            try!(self.print_outer_attributes(v.node.attrs[]));\n             try!(self.ibox(indent_unit));\n             try!(self.print_variant(&**v));\n             try!(word(&mut self.s, \",\"));\n@@ -1066,7 +1067,7 @@ impl<'a> State<'a> {\n             if !struct_def.fields.is_empty() {\n                 try!(self.popen());\n                 try!(self.commasep(\n-                    Inconsistent, struct_def.fields.as_slice(),\n+                    Inconsistent, struct_def.fields[],\n                     |s, field| {\n                         match field.node.kind {\n                             ast::NamedField(..) => panic!(\"unexpected named field\"),\n@@ -1094,7 +1095,7 @@ impl<'a> State<'a> {\n                     ast::NamedField(ident, visibility) => {\n                         try!(self.hardbreak_if_not_bol());\n                         try!(self.maybe_print_comment(field.span.lo));\n-                        try!(self.print_outer_attributes(field.node.attrs.as_slice()));\n+                        try!(self.print_outer_attributes(field.node.attrs[]));\n                         try!(self.print_visibility(visibility));\n                         try!(self.print_ident(ident));\n                         try!(self.word_nbsp(\":\"));\n@@ -1118,7 +1119,7 @@ impl<'a> State<'a> {\n     pub fn print_tt(&mut self, tt: &ast::TokenTree) -> IoResult<()> {\n         match *tt {\n             ast::TtToken(_, ref tk) => {\n-                try!(word(&mut self.s, token_to_string(tk).as_slice()));\n+                try!(word(&mut self.s, token_to_string(tk)[]));\n                 match *tk {\n                     parse::token::DocComment(..) => {\n                         hardbreak(&mut self.s)\n@@ -1127,11 +1128,11 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::TtDelimited(_, ref delimed) => {\n-                try!(word(&mut self.s, token_to_string(&delimed.open_token()).as_slice()));\n+                try!(word(&mut self.s, token_to_string(&delimed.open_token())[]));\n                 try!(space(&mut self.s));\n-                try!(self.print_tts(delimed.tts.as_slice()));\n+                try!(self.print_tts(delimed.tts[]));\n                 try!(space(&mut self.s));\n-                word(&mut self.s, token_to_string(&delimed.close_token()).as_slice())\n+                word(&mut self.s, token_to_string(&delimed.close_token())[])\n             },\n             ast::TtSequence(_, ref seq) => {\n                 try!(word(&mut self.s, \"$(\"));\n@@ -1141,7 +1142,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \")\"));\n                 match seq.separator {\n                     Some(ref tk) => {\n-                        try!(word(&mut self.s, token_to_string(tk).as_slice()));\n+                        try!(word(&mut self.s, token_to_string(tk)[]));\n                     }\n                     None => {},\n                 }\n@@ -1172,7 +1173,7 @@ impl<'a> State<'a> {\n                 if !args.is_empty() {\n                     try!(self.popen());\n                     try!(self.commasep(Consistent,\n-                                       args.as_slice(),\n+                                       args[],\n                                        |s, arg| s.print_type(&*arg.ty)));\n                     try!(self.pclose());\n                 }\n@@ -1196,7 +1197,7 @@ impl<'a> State<'a> {\n     pub fn print_ty_method(&mut self, m: &ast::TypeMethod) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(m.span.lo));\n-        try!(self.print_outer_attributes(m.attrs.as_slice()));\n+        try!(self.print_outer_attributes(m.attrs[]));\n         try!(self.print_ty_fn(None,\n                               None,\n                               m.unsafety,\n@@ -1228,7 +1229,7 @@ impl<'a> State<'a> {\n     pub fn print_method(&mut self, meth: &ast::Method) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(meth.span.lo));\n-        try!(self.print_outer_attributes(meth.attrs.as_slice()));\n+        try!(self.print_outer_attributes(meth.attrs[]));\n         match meth.node {\n             ast::MethDecl(ident,\n                           ref generics,\n@@ -1246,7 +1247,7 @@ impl<'a> State<'a> {\n                                    Some(&explicit_self.node),\n                                    vis));\n                 try!(word(&mut self.s, \" \"));\n-                self.print_block_with_attrs(&**body, meth.attrs.as_slice())\n+                self.print_block_with_attrs(&**body, meth.attrs[])\n             },\n             ast::MethMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n                                             ..}) => {\n@@ -1255,7 +1256,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.cbox(indent_unit));\n                 try!(self.popen());\n-                try!(self.print_tts(tts.as_slice()));\n+                try!(self.print_tts(tts[]));\n                 try!(self.pclose());\n                 try!(word(&mut self.s, \";\"));\n                 self.end()\n@@ -1522,7 +1523,7 @@ impl<'a> State<'a> {\n             ast::ExprVec(ref exprs) => {\n                 try!(self.ibox(indent_unit));\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.commasep_exprs(Inconsistent, exprs.as_slice()));\n+                try!(self.commasep_exprs(Inconsistent, exprs[]));\n                 try!(word(&mut self.s, \"]\"));\n                 try!(self.end());\n             }\n@@ -1542,7 +1543,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"{\"));\n                 try!(self.commasep_cmnt(\n                     Consistent,\n-                    fields.as_slice(),\n+                    fields[],\n                     |s, field| {\n                         try!(s.ibox(indent_unit));\n                         try!(s.print_ident(field.ident.node));\n@@ -1568,15 +1569,15 @@ impl<'a> State<'a> {\n             }\n             ast::ExprTup(ref exprs) => {\n                 try!(self.popen());\n-                try!(self.commasep_exprs(Inconsistent, exprs.as_slice()));\n+                try!(self.commasep_exprs(Inconsistent, exprs[]));\n                 if exprs.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n                 try!(self.pclose());\n             }\n             ast::ExprCall(ref func, ref args) => {\n                 try!(self.print_expr_maybe_paren(&**func));\n-                try!(self.print_call_post(args.as_slice()));\n+                try!(self.print_call_post(args[]));\n             }\n             ast::ExprMethodCall(ident, ref tys, ref args) => {\n                 let base_args = args.slice_from(1);\n@@ -1585,7 +1586,7 @@ impl<'a> State<'a> {\n                 try!(self.print_ident(ident.node));\n                 if tys.len() > 0u {\n                     try!(word(&mut self.s, \"::<\"));\n-                    try!(self.commasep(Inconsistent, tys.as_slice(),\n+                    try!(self.commasep(Inconsistent, tys[],\n                                        |s, ty| s.print_type(&**ty)));\n                     try!(word(&mut self.s, \">\"));\n                 }\n@@ -1795,11 +1796,11 @@ impl<'a> State<'a> {\n                 try!(self.print_string(a.asm.get(), a.asm_str_style));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, a.outputs.as_slice(),\n+                try!(self.commasep(Inconsistent, a.outputs[],\n                                    |s, &(ref co, ref o, is_rw)| {\n                     match co.get().slice_shift_char() {\n                         Some(('=', operand)) if is_rw => {\n-                            try!(s.print_string(format!(\"+{}\", operand).as_slice(),\n+                            try!(s.print_string(format!(\"+{}\", operand)[],\n                                                 ast::CookedStr))\n                         }\n                         _ => try!(s.print_string(co.get(), ast::CookedStr))\n@@ -1812,7 +1813,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, a.inputs.as_slice(),\n+                try!(self.commasep(Inconsistent, a.inputs[],\n                                    |s, &(ref co, ref o)| {\n                     try!(s.print_string(co.get(), ast::CookedStr));\n                     try!(s.popen());\n@@ -1823,7 +1824,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, a.clobbers.as_slice(),\n+                try!(self.commasep(Inconsistent, a.clobbers[],\n                                    |s, co| {\n                     try!(s.print_string(co.get(), ast::CookedStr));\n                     Ok(())\n@@ -1877,15 +1878,15 @@ impl<'a> State<'a> {\n     pub fn print_ident(&mut self, ident: ast::Ident) -> IoResult<()> {\n         if self.encode_idents_with_hygiene {\n             let encoded = ident.encode_with_hygiene();\n-            try!(word(&mut self.s, encoded.as_slice()))\n+            try!(word(&mut self.s, encoded[]))\n         } else {\n             try!(word(&mut self.s, token::get_ident(ident).get()))\n         }\n         self.ann.post(self, NodeIdent(&ident))\n     }\n \n     pub fn print_uint(&mut self, i: uint) -> IoResult<()> {\n-        word(&mut self.s, i.to_string().as_slice())\n+        word(&mut self.s, i.to_string()[])\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> IoResult<()> {\n@@ -1959,7 +1960,7 @@ impl<'a> State<'a> {\n                     }\n                     try!(self.commasep(\n                         Inconsistent,\n-                        data.types.as_slice(),\n+                        data.types[],\n                         |s, ty| s.print_type(&**ty)));\n                         comma = true;\n                 }\n@@ -1982,7 +1983,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"(\"));\n                 try!(self.commasep(\n                     Inconsistent,\n-                    data.inputs.as_slice(),\n+                    data.inputs[],\n                     |s, ty| s.print_type(&**ty)));\n                 try!(word(&mut self.s, \")\"));\n \n@@ -2035,7 +2036,7 @@ impl<'a> State<'a> {\n                     Some(ref args) => {\n                         if !args.is_empty() {\n                             try!(self.popen());\n-                            try!(self.commasep(Inconsistent, args.as_slice(),\n+                            try!(self.commasep(Inconsistent, args[],\n                                               |s, p| s.print_pat(&**p)));\n                             try!(self.pclose());\n                         }\n@@ -2047,7 +2048,7 @@ impl<'a> State<'a> {\n                 try!(self.nbsp());\n                 try!(self.word_space(\"{\"));\n                 try!(self.commasep_cmnt(\n-                    Consistent, fields.as_slice(),\n+                    Consistent, fields[],\n                     |s, f| {\n                         try!(s.cbox(indent_unit));\n                         if !f.node.is_shorthand {\n@@ -2068,7 +2069,7 @@ impl<'a> State<'a> {\n             ast::PatTup(ref elts) => {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent,\n-                                   elts.as_slice(),\n+                                   elts[],\n                                    |s, p| s.print_pat(&**p)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n@@ -2093,7 +2094,7 @@ impl<'a> State<'a> {\n             ast::PatVec(ref before, ref slice, ref after) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.commasep(Inconsistent,\n-                                   before.as_slice(),\n+                                   before[],\n                                    |s, p| s.print_pat(&**p)));\n                 for p in slice.iter() {\n                     if !before.is_empty() { try!(self.word_space(\",\")); }\n@@ -2107,7 +2108,7 @@ impl<'a> State<'a> {\n                     if !after.is_empty() { try!(self.word_space(\",\")); }\n                 }\n                 try!(self.commasep(Inconsistent,\n-                                   after.as_slice(),\n+                                   after[],\n                                    |s, p| s.print_pat(&**p)));\n                 try!(word(&mut self.s, \"]\"));\n             }\n@@ -2124,7 +2125,7 @@ impl<'a> State<'a> {\n         }\n         try!(self.cbox(indent_unit));\n         try!(self.ibox(0u));\n-        try!(self.print_outer_attributes(arm.attrs.as_slice()));\n+        try!(self.print_outer_attributes(arm.attrs[]));\n         let mut first = true;\n         for p in arm.pats.iter() {\n             if first {\n@@ -2224,7 +2225,7 @@ impl<'a> State<'a> {\n \n         // HACK(eddyb) ignore the separately printed self argument.\n         let args = if first {\n-            decl.inputs.as_slice()\n+            decl.inputs[]\n         } else {\n             decl.inputs.slice_from(1)\n         };\n@@ -2386,7 +2387,7 @@ impl<'a> State<'a> {\n             ints.push(i);\n         }\n \n-        try!(self.commasep(Inconsistent, ints.as_slice(), |s, &idx| {\n+        try!(self.commasep(Inconsistent, ints[], |s, &idx| {\n             if idx < generics.lifetimes.len() {\n                 let lifetime = &generics.lifetimes[idx];\n                 s.print_lifetime_def(lifetime)\n@@ -2407,7 +2408,7 @@ impl<'a> State<'a> {\n             try!(self.word_space(\"?\"));\n         }\n         try!(self.print_ident(param.ident));\n-        try!(self.print_bounds(\":\", param.bounds.as_slice()));\n+        try!(self.print_bounds(\":\", param.bounds[]));\n         match param.default {\n             Some(ref default) => {\n                 try!(space(&mut self.s));\n@@ -2483,7 +2484,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, name.get()));\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n-                                   items.as_slice(),\n+                                   items[],\n                                    |s, i| s.print_meta_item(&**i)));\n                 try!(self.pclose());\n             }\n@@ -2519,7 +2520,7 @@ impl<'a> State<'a> {\n                     try!(self.print_path(path, false));\n                     try!(word(&mut self.s, \"::{\"));\n                 }\n-                try!(self.commasep(Inconsistent, idents.as_slice(), |s, w| {\n+                try!(self.commasep(Inconsistent, idents[], |s, w| {\n                     match w.node {\n                         ast::PathListIdent { name, .. } => {\n                             s.print_ident(name)\n@@ -2537,7 +2538,7 @@ impl<'a> State<'a> {\n     pub fn print_view_item(&mut self, item: &ast::ViewItem) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n-        try!(self.print_outer_attributes(item.attrs.as_slice()));\n+        try!(self.print_outer_attributes(item.attrs[]));\n         try!(self.print_visibility(item.vis));\n         match item.node {\n             ast::ViewItemExternCrate(id, ref optional_path, _) => {\n@@ -2679,7 +2680,7 @@ impl<'a> State<'a> {\n             try!(self.pclose());\n         }\n \n-        try!(self.print_bounds(\":\", bounds.as_slice()));\n+        try!(self.print_bounds(\":\", bounds[]));\n \n         try!(self.print_fn_output(decl));\n \n@@ -2738,7 +2739,7 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(lit.span.lo));\n         match self.next_lit(lit.span.lo) {\n             Some(ref ltrl) => {\n-                return word(&mut self.s, (*ltrl).lit.as_slice());\n+                return word(&mut self.s, (*ltrl).lit[]);\n             }\n             _ => ()\n         }\n@@ -2748,35 +2749,35 @@ impl<'a> State<'a> {\n                 let mut res = String::from_str(\"b'\");\n                 ascii::escape_default(byte, |c| res.push(c as char));\n                 res.push('\\'');\n-                word(&mut self.s, res.as_slice())\n+                word(&mut self.s, res[])\n             }\n             ast::LitChar(ch) => {\n                 let mut res = String::from_str(\"'\");\n                 for c in ch.escape_default() {\n                     res.push(c);\n                 }\n                 res.push('\\'');\n-                word(&mut self.s, res.as_slice())\n+                word(&mut self.s, res[])\n             }\n             ast::LitInt(i, t) => {\n                 match t {\n                     ast::SignedIntLit(st, ast::Plus) => {\n                         word(&mut self.s,\n-                             ast_util::int_ty_to_string(st, Some(i as i64)).as_slice())\n+                             ast_util::int_ty_to_string(st, Some(i as i64))[])\n                     }\n                     ast::SignedIntLit(st, ast::Minus) => {\n                         let istr = ast_util::int_ty_to_string(st, Some(-(i as i64)));\n                         word(&mut self.s,\n-                             format!(\"-{}\", istr).as_slice())\n+                             format!(\"-{}\", istr)[])\n                     }\n                     ast::UnsignedIntLit(ut) => {\n-                        word(&mut self.s, ast_util::uint_ty_to_string(ut, Some(i)).as_slice())\n+                        word(&mut self.s, ast_util::uint_ty_to_string(ut, Some(i))[])\n                     }\n                     ast::UnsuffixedIntLit(ast::Plus) => {\n-                        word(&mut self.s, format!(\"{}\", i).as_slice())\n+                        word(&mut self.s, format!(\"{}\", i)[])\n                     }\n                     ast::UnsuffixedIntLit(ast::Minus) => {\n-                        word(&mut self.s, format!(\"-{}\", i).as_slice())\n+                        word(&mut self.s, format!(\"-{}\", i)[])\n                     }\n                 }\n             }\n@@ -2785,7 +2786,7 @@ impl<'a> State<'a> {\n                      format!(\n                          \"{}{}\",\n                          f.get(),\n-                         ast_util::float_ty_to_string(t).as_slice()).as_slice())\n+                         ast_util::float_ty_to_string(t)[])[])\n             }\n             ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, f.get()),\n             ast::LitBool(val) => {\n@@ -2797,7 +2798,7 @@ impl<'a> State<'a> {\n                     ascii::escape_default(ch as u8,\n                                           |ch| escaped.push(ch as char));\n                 }\n-                word(&mut self.s, format!(\"b\\\"{}\\\"\", escaped).as_slice())\n+                word(&mut self.s, format!(\"b\\\"{}\\\"\", escaped)[])\n             }\n         }\n     }\n@@ -2838,7 +2839,7 @@ impl<'a> State<'a> {\n             comments::Mixed => {\n                 assert_eq!(cmnt.lines.len(), 1u);\n                 try!(zerobreak(&mut self.s));\n-                try!(word(&mut self.s, cmnt.lines[0].as_slice()));\n+                try!(word(&mut self.s, cmnt.lines[0][]));\n                 zerobreak(&mut self.s)\n             }\n             comments::Isolated => {\n@@ -2847,7 +2848,7 @@ impl<'a> State<'a> {\n                     // Don't print empty lines because they will end up as trailing\n                     // whitespace\n                     if !line.is_empty() {\n-                        try!(word(&mut self.s, line.as_slice()));\n+                        try!(word(&mut self.s, line[]));\n                     }\n                     try!(hardbreak(&mut self.s));\n                 }\n@@ -2856,13 +2857,13 @@ impl<'a> State<'a> {\n             comments::Trailing => {\n                 try!(word(&mut self.s, \" \"));\n                 if cmnt.lines.len() == 1u {\n-                    try!(word(&mut self.s, cmnt.lines[0].as_slice()));\n+                    try!(word(&mut self.s, cmnt.lines[0][]));\n                     hardbreak(&mut self.s)\n                 } else {\n                     try!(self.ibox(0u));\n                     for line in cmnt.lines.iter() {\n                         if !line.is_empty() {\n-                            try!(word(&mut self.s, line.as_slice()));\n+                            try!(word(&mut self.s, line[]));\n                         }\n                         try!(hardbreak(&mut self.s));\n                     }\n@@ -2891,11 +2892,11 @@ impl<'a> State<'a> {\n             }\n             ast::RawStr(n) => {\n                 (format!(\"r{delim}\\\"{string}\\\"{delim}\",\n-                         delim=\"#\".repeat(n),\n+                         delim=repeat(\"#\", n),\n                          string=st))\n             }\n         };\n-        word(&mut self.s, st.as_slice())\n+        word(&mut self.s, st[])\n     }\n \n     pub fn next_comment(&mut self) -> Option<comments::Comment> {\n@@ -2926,7 +2927,7 @@ impl<'a> State<'a> {\n             Some(abi::Rust) => Ok(()),\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(abi.to_string().as_slice())\n+                self.word_nbsp(abi.to_string()[])\n             }\n             None => Ok(())\n         }\n@@ -2937,7 +2938,7 @@ impl<'a> State<'a> {\n         match opt_abi {\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(abi.to_string().as_slice())\n+                self.word_nbsp(abi.to_string()[])\n             }\n             None => Ok(())\n         }\n@@ -2953,7 +2954,7 @@ impl<'a> State<'a> {\n \n         if abi != abi::Rust {\n             try!(self.word_nbsp(\"extern\"));\n-            try!(self.word_nbsp(abi.to_string().as_slice()));\n+            try!(self.word_nbsp(abi.to_string()[]));\n         }\n \n         word(&mut self.s, \"fn\")\n@@ -2967,6 +2968,8 @@ impl<'a> State<'a> {\n     }\n }\n \n+fn repeat(s: &str, n: uint) -> String { iter::repeat(s).take(n).collect() }\n+\n #[cfg(test)]\n mod test {\n     use super::*;"}, {"sha": "e1c8ff5011b267bc85db0d219eaf1be9cfec05b1", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -40,7 +40,7 @@ pub fn maybe_inject_prelude(krate: ast::Crate) -> ast::Crate {\n }\n \n fn use_std(krate: &ast::Crate) -> bool {\n-    !attr::contains_name(krate.attrs.as_slice(), \"no_std\")\n+    !attr::contains_name(krate.attrs[], \"no_std\")\n }\n \n fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n@@ -56,7 +56,7 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n \n         // The name to use in `extern crate \"name\" as std;`\n         let actual_crate_name = match self.alt_std_name {\n-            Some(ref s) => token::intern_and_get_ident(s.as_slice()),\n+            Some(ref s) => token::intern_and_get_ident(s[]),\n             None => token::intern_and_get_ident(\"std\"),\n         };\n \n@@ -118,7 +118,7 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n         attr::mark_used(&no_std_attr);\n         krate.attrs.push(no_std_attr);\n \n-        if !no_prelude(krate.attrs.as_slice()) {\n+        if !no_prelude(krate.attrs[]) {\n             // only add `use std::prelude::*;` if there wasn't a\n             // `#![no_implicit_prelude]` at the crate level.\n             // fold_mod() will insert glob path.\n@@ -138,7 +138,7 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n     }\n \n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        if !no_prelude(item.attrs.as_slice()) {\n+        if !no_prelude(item.attrs[]) {\n             // only recur if there wasn't `#![no_implicit_prelude]`\n             // on this item, i.e. this means that the prelude is not\n             // implicitly imported though the whole subtree"}, {"sha": "bc7dda8c44acc598cb0532921984fb711d3ccf6a", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -73,14 +73,14 @@ pub fn modify_for_testing(sess: &ParseSess,\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n-    let should_test = attr::contains_name(krate.config.as_slice(), \"test\");\n+    let should_test = attr::contains_name(krate.config[], \"test\");\n \n     // Check for #[reexport_test_harness_main = \"some_name\"] which\n     // creates a `use some_name = __test::main;`. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n-        attr::first_attr_value_str_by_name(krate.attrs.as_slice(),\n+        attr::first_attr_value_str_by_name(krate.attrs[],\n                                            \"reexport_test_harness_main\");\n \n     if should_test {\n@@ -119,7 +119,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             self.cx.path.push(ident);\n         }\n         debug!(\"current path: {}\",\n-               ast_util::path_name_i(self.cx.path.as_slice()));\n+               ast_util::path_name_i(self.cx.path[]));\n \n         if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n             match i.node {\n@@ -277,8 +277,8 @@ fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n     config::strip_items(krate, |attrs| {\n-        !attr::contains_name(attrs.as_slice(), \"test\") &&\n-        !attr::contains_name(attrs.as_slice(), \"bench\")\n+        !attr::contains_name(attrs[], \"test\") &&\n+        !attr::contains_name(attrs[], \"bench\")\n     })\n }\n \n@@ -291,7 +291,7 @@ enum HasTestSignature {\n \n \n fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n-    let has_test_attr = attr::contains_name(i.attrs.as_slice(), \"test\");\n+    let has_test_attr = attr::contains_name(i.attrs[], \"test\");\n \n     fn has_test_signature(i: &ast::Item) -> HasTestSignature {\n         match &i.node {\n@@ -329,7 +329,7 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n }\n \n fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n-    let has_bench_attr = attr::contains_name(i.attrs.as_slice(), \"bench\");\n+    let has_bench_attr = attr::contains_name(i.attrs[], \"bench\");\n \n     fn has_test_signature(i: &ast::Item) -> bool {\n         match i.node {\n@@ -384,7 +384,7 @@ We're going to be building a module that looks more or less like:\n mod __test {\n   extern crate test (name = \"test\", vers = \"...\");\n   fn main() {\n-    test::test_main_static(::os::args().as_slice(), tests)\n+    test::test_main_static(::os::args()[], tests)\n   }\n \n   static tests : &'static [test::TestDescAndFn] = &[\n@@ -510,8 +510,8 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n }\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n-    match attr::find_crate_name(krate.attrs.as_slice()) {\n-        Some(ref s) if \"test\" == s.get().as_slice() => true,\n+    match attr::find_crate_name(krate.attrs[]) {\n+        Some(ref s) if \"test\" == s.get()[] => true,\n         _ => false\n     }\n }\n@@ -551,11 +551,11 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     // creates $name: $expr\n     let field = |name, expr| ecx.field_imm(span, ecx.ident_of(name), expr);\n \n-    debug!(\"encoding {}\", ast_util::path_name_i(path.as_slice()));\n+    debug!(\"encoding {}\", ast_util::path_name_i(path[]));\n \n     // path to the #[test] function: \"foo::bar::baz\"\n-    let path_string = ast_util::path_name_i(path.as_slice());\n-    let name_expr = ecx.expr_str(span, token::intern_and_get_ident(path_string.as_slice()));\n+    let path_string = ast_util::path_name_i(path[]);\n+    let name_expr = ecx.expr_str(span, token::intern_and_get_ident(path_string[]));\n \n     // self::test::StaticTestName($name_expr)\n     let name_expr = ecx.expr_call(span,"}, {"sha": "97eb43165833abbfb36e5b7f9922f0b928ff1237", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -95,41 +95,37 @@ pub struct RcStr {\n     string: Rc<String>,\n }\n \n+impl RcStr {\n+    pub fn new(string: &str) -> RcStr {\n+        RcStr {\n+            string: Rc::new(string.to_string()),\n+        }\n+    }\n+}\n+\n impl Eq for RcStr {}\n \n impl Ord for RcStr {\n     fn cmp(&self, other: &RcStr) -> Ordering {\n-        self.as_slice().cmp(other.as_slice())\n-    }\n-}\n-\n-impl Str for RcStr {\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a str {\n-        let s: &'a str = self.string.as_slice();\n-        s\n+        self[].cmp(other[])\n     }\n }\n \n impl fmt::Show for RcStr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use std::fmt::Show;\n-        self.as_slice().fmt(f)\n+        self[].fmt(f)\n     }\n }\n \n impl BorrowFrom<RcStr> for str {\n     fn borrow_from(owned: &RcStr) -> &str {\n-        owned.string.as_slice()\n+        owned.string[]\n     }\n }\n \n-impl RcStr {\n-    pub fn new(string: &str) -> RcStr {\n-        RcStr {\n-            string: Rc::new(string.into_string()),\n-        }\n-    }\n+impl Deref<str> for RcStr {\n+    fn deref(&self) -> &str { self.string[] }\n }\n \n /// A StrInterner differs from Interner<String> in that it accepts"}, {"sha": "d944d0362fbe50e481c57c3017b7d3120403d376", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -180,7 +180,7 @@ impl<T: Writer+Send> TerminfoTerminal<T> {\n             }\n         };\n \n-        let entry = open(term.as_slice());\n+        let entry = open(term[]);\n         if entry.is_err() {\n             if os::getenv(\"MSYSCON\").map_or(false, |s| {\n                     \"mintty.exe\" == s"}, {"sha": "395fac52d8dacedbbeb2f44d1c800291a9fcd069", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -61,13 +61,13 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n     for p in dirs_to_search.iter() {\n         if p.exists() {\n             let f = first_char.to_string();\n-            let newp = p.join_many(&[f.as_slice(), term]);\n+            let newp = p.join_many(&[f[], term]);\n             if newp.exists() {\n                 return Some(box newp);\n             }\n             // on some installations the dir is named after the hex of the char (e.g. OS X)\n             let f = format!(\"{:x}\", first_char as uint);\n-            let newp = p.join_many(&[f.as_slice(), term]);\n+            let newp = p.join_many(&[f[], term]);\n             if newp.exists() {\n                 return Some(box newp);\n             }"}, {"sha": "1870f162eceb4f5c989d20d6067c868f890b3991", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -65,6 +65,7 @@ use std::io::fs::PathExtensions;\n use std::io::stdio::StdWriter;\n use std::io::{File, ChanReader, ChanWriter};\n use std::io;\n+use std::iter::repeat;\n use std::num::{Float, FloatMath, Int};\n use std::os;\n use std::str::FromStr;\n@@ -121,7 +122,7 @@ impl TestDesc {\n     fn padded_name(&self, column_count: uint, align: NamePadding) -> String {\n         let mut name = String::from_str(self.name.as_slice());\n         let fill = column_count.saturating_sub(name.len());\n-        let mut pad = \" \".repeat(fill);\n+        let mut pad = repeat(\" \").take(fill).collect::<String>();\n         match align {\n             PadNone => name,\n             PadOnLeft => {\n@@ -426,7 +427,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n \n     let ratchet_noise_percent = matches.opt_str(\"ratchet-noise-percent\");\n     let ratchet_noise_percent =\n-        ratchet_noise_percent.map(|s| from_str::<f64>(s.as_slice()).unwrap());\n+        ratchet_noise_percent.map(|s| s.as_slice().parse::<f64>().unwrap());\n \n     let save_metrics = matches.opt_str(\"save-metrics\");\n     let save_metrics = save_metrics.map(|s| Path::new(s));\n@@ -489,7 +490,8 @@ pub fn opt_shard(maybestr: Option<String>) -> Option<(uint,uint)> {\n         None => None,\n         Some(s) => {\n             let mut it = s.split('.');\n-            match (it.next().and_then(from_str::<uint>), it.next().and_then(from_str::<uint>),\n+            match (it.next().and_then(|s| s.parse::<uint>()),\n+                   it.next().and_then(|s| s.parse::<uint>()),\n                    it.next()) {\n                 (Some(a), Some(b), None) => {\n                     if a <= 0 || a > b {"}, {"sha": "7d59e3de7b1e6cda6f1b1f712d68f6a169d2971c", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 9, "deletions": 102, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -15,22 +15,16 @@\n //! This module provides functionality to `str` that requires the Unicode methods provided by the\n //! UnicodeChar trait.\n \n+use self::GraphemeState::*;\n use core::prelude::*;\n \n use core::char;\n use core::cmp;\n-use core::iter::{DoubleEndedIterator, DoubleEndedIteratorExt};\n-use core::iter::{Filter, AdditiveIterator, Iterator, IteratorExt};\n use core::iter::{Filter, AdditiveIterator};\n-use core::kinds::Sized;\n use core::mem;\n use core::num::Int;\n-use core::option::Option::{None, Some};\n-use core::option::Option;\n-use core::slice::SliceExt;\n use core::slice;\n-use core::str::{CharSplits, StrPrelude};\n-use core::str::{CharSplits};\n+use core::str::CharSplits;\n \n use u_char::UnicodeChar;\n use tables::grapheme::GraphemeCat;\n@@ -39,106 +33,20 @@ use tables::grapheme::GraphemeCat;\n /// FIXME: This should be opaque\n #[stable]\n pub struct Words<'a> {\n-    inner: Filter<'a, &'a str, CharSplits<'a, |char|:'a -> bool>,\n-                  fn(&&str) -> bool>,\n+    inner: Filter<&'a str, CharSplits<'a, fn(char) -> bool>, fn(&&str) -> bool>,\n }\n \n /// Methods for Unicode string slices\n+#[allow(missing_docs)] // docs in libcollections\n pub trait UnicodeStr for Sized? {\n-    /// Returns an iterator over the\n-    /// [grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n-    /// of the string.\n-    ///\n-    /// If `is_extended` is true, the iterator is over the *extended grapheme clusters*;\n-    /// otherwise, the iterator is over the *legacy grapheme clusters*.\n-    /// [UAX#29](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n-    /// recommends extended grapheme cluster boundaries for general processing.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let gr1 = \"a\\u{0310}e\\u{0301}o\\u{0308}\\u{0332}\".graphemes(true).collect::<Vec<&str>>();\n-    /// let b: &[_] = &[\"a\\u{0310}\", \"e\\u{0301}\", \"o\\u{0308}\\u{0332}\"];\n-    /// assert_eq!(gr1.as_slice(), b);\n-    /// let gr2 = \"a\\r\\nb\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\".graphemes(true).collect::<Vec<&str>>();\n-    /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n-    /// assert_eq!(gr2.as_slice(), b);\n-    /// ```\n     fn graphemes<'a>(&'a self, is_extended: bool) -> Graphemes<'a>;\n-\n-    /// Returns an iterator over the grapheme clusters of self and their byte offsets.\n-    /// See `graphemes()` method for more information.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(uint, &str)>>();\n-    /// let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n-    /// assert_eq!(gr_inds.as_slice(), b);\n-    /// ```\n     fn grapheme_indices<'a>(&'a self, is_extended: bool) -> GraphemeIndices<'a>;\n-\n-    /// An iterator over the words of a string (subsequences separated\n-    /// by any sequence of whitespace). Sequences of whitespace are\n-    /// collapsed, so empty \"words\" are not included.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n-    /// let v: Vec<&str> = some_words.words().collect();\n-    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    /// ```\n-    #[stable]\n     fn words<'a>(&'a self) -> Words<'a>;\n-\n-    /// Returns true if the string contains only whitespace.\n-    ///\n-    /// Whitespace characters are determined by `char::is_whitespace`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\" \\t\\n\".is_whitespace());\n-    /// assert!(\"\".is_whitespace());\n-    ///\n-    /// assert!( !\"abc\".is_whitespace());\n-    /// ```\n     fn is_whitespace(&self) -> bool;\n-\n-    /// Returns true if the string contains only alphanumeric code\n-    /// points.\n-    ///\n-    /// Alphanumeric characters are determined by `char::is_alphanumeric`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\"L\u00f6we\u8001\u864eL\u00e9opard123\".is_alphanumeric());\n-    /// assert!(\"\".is_alphanumeric());\n-    ///\n-    /// assert!( !\" &*~\".is_alphanumeric());\n-    /// ```\n     fn is_alphanumeric(&self) -> bool;\n-\n-    /// Returns a string's displayed width in columns, treating control\n-    /// characters as zero-width.\n-    ///\n-    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n-    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n-    /// In CJK locales, `is_cjk` should be `true`, else it should be `false`.\n-    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n-    /// recommends that these characters be treated as 1 column (i.e.,\n-    /// `is_cjk` = `false`) if the locale is unknown.\n     fn width(&self, is_cjk: bool) -> uint;\n-\n-    /// Returns a string with leading and trailing whitespace removed.\n     fn trim<'a>(&'a self) -> &'a str;\n-\n-    /// Returns a string with leading whitespace removed.\n     fn trim_left<'a>(&'a self) -> &'a str;\n-\n-    /// Returns a string with trailing whitespace removed.\n     fn trim_right<'a>(&'a self) -> &'a str;\n }\n \n@@ -471,10 +379,10 @@ pub fn utf8_char_width(b: u8) -> uint {\n /// Determines if a vector of `u16` contains valid UTF-16\n pub fn is_utf16(v: &[u16]) -> bool {\n     let mut it = v.iter();\n-    macro_rules! next ( ($ret:expr) => {\n+    macro_rules! next { ($ret:expr) => {\n             match it.next() { Some(u) => *u, None => return $ret }\n         }\n-    )\n+    }\n     loop {\n         let u = next!(true);\n \n@@ -513,7 +421,7 @@ impl Utf16Item {\n     pub fn to_char_lossy(&self) -> char {\n         match *self {\n             Utf16Item::ScalarValue(c) => c,\n-            Utf16Item::LoneSurrogate(_) => '\\uFFFD'\n+            Utf16Item::LoneSurrogate(_) => '\\u{FFFD}'\n         }\n     }\n }\n@@ -568,15 +476,14 @@ impl<'a> Iterator<Utf16Item> for Utf16Items<'a> {\n /// # Example\n ///\n /// ```rust\n-/// use std::str;\n-/// use std::str::{ScalarValue, LoneSurrogate};\n+/// use unicode::str::Utf16Item::{ScalarValue, LoneSurrogate};\n ///\n /// // \ud834\udd1emus<invalid>ic<invalid>\n /// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n ///          0x0073, 0xDD1E, 0x0069, 0x0063,\n ///          0xD834];\n ///\n-/// assert_eq!(str::utf16_items(&v).collect::<Vec<_>>(),\n+/// assert_eq!(unicode::str::utf16_items(&v).collect::<Vec<_>>(),\n ///            vec![ScalarValue('\ud834\udd1e'),\n ///                 ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n ///                 LoneSurrogate(0xDD1E),"}, {"sha": "2f466d4ca8c47f59a72dc9b2e4c964955e99d8ea", "filename": "src/test/run-pass/issue-19340-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Ftest%2Frun-pass%2Fissue-19340-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Ftest%2Frun-pass%2Fissue-19340-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19340-1.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -15,7 +15,7 @@ extern crate \"issue-19340-1\" as lib;\n use lib::Homura;\n \n fn main() {\n-    let homura = Homura::Madoka { name: \"Kaname\".into_string() };\n+    let homura = Homura::Madoka { name: \"Kaname\".to_string() };\n \n     match homura {\n         Homura::Madoka { name } => (),"}, {"sha": "8300220edeaff11310fc5bedc06ec6013cfee7b6", "filename": "src/test/run-pass/issue-19340-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Ftest%2Frun-pass%2Fissue-19340-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Ftest%2Frun-pass%2Fissue-19340-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19340-2.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -17,7 +17,7 @@ enum Homura {\n \n fn main() {\n     let homura = Homura::Madoka {\n-        name: \"Akemi\".into_string(),\n+        name: \"Akemi\".to_string(),\n         age: 14,\n     };\n "}, {"sha": "7db84d518ff30bd4cbfe731009330fbcf81aa6d0", "filename": "src/test/run-pass/issue-19367.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082bfde412176249dc7328e771a2a15d202824cf/src%2Ftest%2Frun-pass%2Fissue-19367.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082bfde412176249dc7328e771a2a15d202824cf/src%2Ftest%2Frun-pass%2Fissue-19367.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19367.rs?ref=082bfde412176249dc7328e771a2a15d202824cf", "patch": "@@ -16,10 +16,10 @@ struct S {\n // on field of struct or tuple which we reassign in the match body.\n \n fn main() {\n-    let mut a = (0i, Some(\"right\".into_string()));\n+    let mut a = (0i, Some(\"right\".to_string()));\n     let b = match a.1 {\n         Some(v) => {\n-            a.1 = Some(\"wrong\".into_string());\n+            a.1 = Some(\"wrong\".to_string());\n             v\n         }\n         None => String::new()\n@@ -28,10 +28,10 @@ fn main() {\n     assert_eq!(b, \"right\");\n \n \n-    let mut s = S{ o: Some(\"right\".into_string()) };\n+    let mut s = S{ o: Some(\"right\".to_string()) };\n     let b = match s.o {\n         Some(v) => {\n-            s.o = Some(\"wrong\".into_string());\n+            s.o = Some(\"wrong\".to_string());\n             v\n         }\n         None => String::new(),"}]}