{"sha": "bafbac46f881ac3c96e61a902cb998a4ce387001", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhZmJhYzQ2Zjg4MWFjM2M5NmU2MWE5MDJjYjk5OGE0Y2UzODcwMDE=", "commit": {"author": {"name": "Kagamihime", "email": "ayatoujou@hotmail.fr", "date": "2017-12-29T22:04:21Z"}, "committer": {"name": "Kagamihime", "email": "ayatoujou@hotmail.fr", "date": "2017-12-29T22:04:21Z"}, "message": "rustfmt libarena/lib.rs", "tree": {"sha": "06b3638143da0078640ad6cbf119630533773a31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06b3638143da0078640ad6cbf119630533773a31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bafbac46f881ac3c96e61a902cb998a4ce387001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bafbac46f881ac3c96e61a902cb998a4ce387001", "html_url": "https://github.com/rust-lang/rust/commit/bafbac46f881ac3c96e61a902cb998a4ce387001", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bafbac46f881ac3c96e61a902cb998a4ce387001/comments", "author": null, "committer": null, "parents": [{"sha": "1a7a5b5e38020f68d5cf376659f9d8d2ed8cc75e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a7a5b5e38020f68d5cf376659f9d8d2ed8cc75e", "html_url": "https://github.com/rust-lang/rust/commit/1a7a5b5e38020f68d5cf376659f9d8d2ed8cc75e"}], "stats": {"total": 37, "additions": 24, "deletions": 13}, "files": [{"sha": "57a147b23feac8c298a04947283c20e8e7d8f6eb", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bafbac46f881ac3c96e61a902cb998a4ce387001/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bafbac46f881ac3c96e61a902cb998a4ce387001/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=bafbac46f881ac3c96e61a902cb998a4ce387001", "patch": "@@ -23,13 +23,11 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(no_crate_inject, attr(deny(warnings))))]\n #![deny(warnings)]\n-\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n #![feature(generic_param_attrs)]\n #![cfg_attr(test, feature(test))]\n-\n #![allow(deprecated)]\n \n extern crate alloc;\n@@ -69,7 +67,9 @@ struct TypedArenaChunk<T> {\n impl<T> TypedArenaChunk<T> {\n     #[inline]\n     unsafe fn new(capacity: usize) -> TypedArenaChunk<T> {\n-        TypedArenaChunk { storage: RawVec::with_capacity(capacity) }\n+        TypedArenaChunk {\n+            storage: RawVec::with_capacity(capacity),\n+        }\n     }\n \n     /// Destroys this arena chunk.\n@@ -132,7 +132,9 @@ impl<T> TypedArena<T> {\n \n         unsafe {\n             if mem::size_of::<T>() == 0 {\n-                self.ptr.set(intrinsics::arith_offset(self.ptr.get() as *mut u8, 1) as *mut T);\n+                self.ptr\n+                    .set(intrinsics::arith_offset(self.ptr.get() as *mut u8, 1)\n+                        as *mut T);\n                 let ptr = mem::align_of::<T>() as *mut T;\n                 // Don't drop the object. This `write` is equivalent to `forget`.\n                 ptr::write(ptr, object);\n@@ -156,7 +158,9 @@ impl<T> TypedArena<T> {\n     ///  - Zero-length slices\n     #[inline]\n     pub fn alloc_slice(&self, slice: &[T]) -> &mut [T]\n-        where T: Copy {\n+    where\n+        T: Copy,\n+    {\n         assert!(mem::size_of::<T>() != 0);\n         assert!(slice.len() != 0);\n \n@@ -320,7 +324,10 @@ impl DroplessArena {\n             let (chunk, mut new_capacity);\n             if let Some(last_chunk) = chunks.last_mut() {\n                 let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n-                if last_chunk.storage.reserve_in_place(used_bytes, needed_bytes) {\n+                if last_chunk\n+                    .storage\n+                    .reserve_in_place(used_bytes, needed_bytes)\n+                {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n@@ -356,9 +363,9 @@ impl DroplessArena {\n \n             let ptr = self.ptr.get();\n             // Set the pointer past ourselves\n-            self.ptr.set(intrinsics::arith_offset(\n-                    self.ptr.get(), mem::size_of::<T>() as isize\n-            ) as *mut u8);\n+            self.ptr.set(\n+                intrinsics::arith_offset(self.ptr.get(), mem::size_of::<T>() as isize) as *mut u8,\n+            );\n             // Write into uninitialized memory.\n             ptr::write(ptr as *mut T, object);\n             &mut *(ptr as *mut T)\n@@ -373,7 +380,9 @@ impl DroplessArena {\n     ///  - Zero-length slices\n     #[inline]\n     pub fn alloc_slice<T>(&self, slice: &[T]) -> &mut [T]\n-        where T: Copy {\n+    where\n+        T: Copy,\n+    {\n         assert!(!mem::needs_drop::<T>());\n         assert!(mem::size_of::<T>() != 0);\n         assert!(slice.len() != 0);\n@@ -389,7 +398,8 @@ impl DroplessArena {\n         unsafe {\n             let arena_slice = slice::from_raw_parts_mut(self.ptr.get() as *mut T, slice.len());\n             self.ptr.set(intrinsics::arith_offset(\n-                    self.ptr.get(), (slice.len() * mem::size_of::<T>()) as isize\n+                self.ptr.get(),\n+                (slice.len() * mem::size_of::<T>()) as isize,\n             ) as *mut u8);\n             arena_slice.copy_from_slice(slice);\n             arena_slice\n@@ -454,8 +464,9 @@ mod tests {\n \n         let arena = Wrap(TypedArena::new());\n \n-        let result =\n-            arena.alloc_outer(|| Outer { inner: arena.alloc_inner(|| Inner { value: 10 }) });\n+        let result = arena.alloc_outer(|| Outer {\n+            inner: arena.alloc_inner(|| Inner { value: 10 }),\n+        });\n \n         assert_eq!(result.inner.value, 10);\n     }"}]}