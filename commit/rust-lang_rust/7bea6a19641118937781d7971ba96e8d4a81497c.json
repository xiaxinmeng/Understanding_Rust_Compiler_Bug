{"sha": "7bea6a19641118937781d7971ba96e8d4a81497c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiZWE2YTE5NjQxMTE4OTM3NzgxZDc5NzFiYTk2ZThkNGE4MTQ5N2M=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-09-21T01:01:10Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-12-07T05:56:51Z"}, "message": "SGX target: implement command-line arguments and environment variables", "tree": {"sha": "1d1a6fa1dde98d36fcd5dbb1cda5b043a461f50f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d1a6fa1dde98d36fcd5dbb1cda5b043a461f50f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bea6a19641118937781d7971ba96e8d4a81497c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bea6a19641118937781d7971ba96e8d4a81497c", "html_url": "https://github.com/rust-lang/rust/commit/7bea6a19641118937781d7971ba96e8d4a81497c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bea6a19641118937781d7971ba96e8d4a81497c/comments", "author": null, "committer": null, "parents": [{"sha": "6650f43a3f603e32ceba884aaa92bc491972a75b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6650f43a3f603e32ceba884aaa92bc491972a75b", "html_url": "https://github.com/rust-lang/rust/commit/6650f43a3f603e32ceba884aaa92bc491972a75b"}], "stats": {"total": 95, "additions": 70, "deletions": 25}, "files": [{"sha": "8fb35d7ef98bd30974b43341488ecdcf4c72853a", "filename": "src/libstd/sys/sgx/args.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7bea6a19641118937781d7971ba96e8d4a81497c/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bea6a19641118937781d7971ba96e8d4a81497c/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs?ref=7bea6a19641118937781d7971ba96e8d4a81497c", "patch": "@@ -9,49 +9,67 @@\n // except according to those terms.\n \n use ffi::OsString;\n-use fortanix_sgx_abi::ByteBuffer;\n+use super::abi::usercalls::{copy_user_buffer, alloc, ByteBuffer};\n+use sync::atomic::{AtomicUsize, Ordering};\n+use sys::os_str::Buf;\n+use sys_common::FromInner;\n+use slice;\n \n-pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-    // See ABI\n-    let _len: usize = argc as _;\n-    let _args: *const ByteBuffer = argv as _;\n+static ARGS: AtomicUsize = AtomicUsize::new(0);\n+type ArgsStore = Vec<OsString>;\n \n-    // TODO\n+pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+    if argc != 0 {\n+        let args = alloc::User::<[ByteBuffer]>::from_raw_parts(argv as _, argc as _);\n+        let args = args.iter()\n+            .map( |a| OsString::from_inner(Buf { inner: copy_user_buffer(a) }) )\n+            .collect::<ArgsStore>();\n+        ARGS.store(Box::into_raw(Box::new(args)) as _, Ordering::Relaxed);\n+    }\n }\n \n pub unsafe fn cleanup() {\n+    let args = ARGS.swap(0, Ordering::Relaxed);\n+    if args != 0 {\n+        drop(Box::<ArgsStore>::from_raw(args as _))\n+    }\n }\n \n pub fn args() -> Args {\n-    Args\n+    let args = unsafe { (ARGS.load(Ordering::Relaxed) as *const ArgsStore).as_ref() };\n+    if let Some(args) = args {\n+        Args(args.iter())\n+    } else {\n+        Args([].iter())\n+    }\n }\n \n-pub struct Args;\n+pub struct Args(slice::Iter<'static, OsString>);\n \n impl Args {\n     pub fn inner_debug(&self) -> &[OsString] {\n-        &[]\n+        self.0.as_slice()\n     }\n }\n \n impl Iterator for Args {\n     type Item = OsString;\n     fn next(&mut self) -> Option<OsString> {\n-        None\n+        self.0.next().cloned()\n     }\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(0))\n+        self.0.size_hint()\n     }\n }\n \n impl ExactSizeIterator for Args {\n     fn len(&self) -> usize {\n-        0\n+        self.0.len()\n     }\n }\n \n impl DoubleEndedIterator for Args {\n     fn next_back(&mut self) -> Option<OsString> {\n-        None\n+        self.0.next_back().cloned()\n     }\n }"}, {"sha": "79ebafe73f966eb65d7f13d801a3af67fe2e2617", "filename": "src/libstd/sys/sgx/os.rs", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7bea6a19641118937781d7971ba96e8d4a81497c/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bea6a19641118937781d7971ba96e8d4a81497c/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs?ref=7bea6a19641118937781d7971ba96e8d4a81497c", "patch": "@@ -17,6 +17,11 @@ use io;\n use path::{self, PathBuf};\n use str;\n use sys::{unsupported, Void, sgx_ineffective, decode_error_kind};\n+use collections::HashMap;\n+use vec;\n+use sync::Mutex;\n+use sync::atomic::{AtomicUsize, Ordering};\n+use sync::Once;\n \n pub fn errno() -> i32 {\n     RESULT_SUCCESS\n@@ -78,29 +83,51 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     unsupported()\n }\n \n-pub struct Env;\n+static ENV: AtomicUsize = AtomicUsize::new(0);\n+static ENV_INIT: Once = Once::new();\n+type EnvStore = Mutex<HashMap<OsString, OsString>>;\n \n-impl Iterator for Env {\n-    type Item = (OsString, OsString);\n-    fn next(&mut self) -> Option<(OsString, OsString)> {\n-        None\n+fn get_env_store() -> Option<&'static EnvStore> {\n+    unsafe { (ENV.load(Ordering::Relaxed) as *const EnvStore).as_ref() }\n+}\n+\n+fn create_env_store() -> &'static EnvStore {\n+    ENV_INIT.call_once(|| {\n+        ENV.store(Box::into_raw(Box::new(EnvStore::default())) as _, Ordering::Relaxed)\n+    });\n+    unsafe {\n+        &*(ENV.load(Ordering::Relaxed) as *const EnvStore)\n     }\n }\n \n+pub type Env = vec::IntoIter<(OsString, OsString)>;\n+\n pub fn env() -> Env {\n-    Env\n+    let clone_to_vec = |map: &HashMap<OsString, OsString>| -> Vec<_> {\n+        map.iter().map(|(k, v)| (k.clone(), v.clone()) ).collect()\n+    };\n+\n+    get_env_store()\n+        .map(|env| clone_to_vec(&env.lock().unwrap()) )\n+        .unwrap_or_default()\n+        .into_iter()\n }\n \n-pub fn getenv(_k: &OsStr) -> io::Result<Option<OsString>> {\n-    Ok(None)\n+pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n+    Ok(get_env_store().and_then(|s| s.lock().unwrap().get(k).cloned() ))\n }\n \n-pub fn setenv(_k: &OsStr, _v: &OsStr) -> io::Result<()> {\n-    sgx_ineffective(()) // FIXME: this could trigger a panic higher up the stack\n+pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n+    let (k, v) = (k.to_owned(), v.to_owned());\n+    create_env_store().lock().unwrap().insert(k, v);\n+    Ok(())\n }\n \n-pub fn unsetenv(_k: &OsStr) -> io::Result<()> {\n-    sgx_ineffective(()) // FIXME: this could trigger a panic higher up the stack\n+pub fn unsetenv(k: &OsStr) -> io::Result<()> {\n+    if let Some(env) = get_env_store() {\n+        env.lock().unwrap().remove(k);\n+    }\n+    Ok(())\n }\n \n pub fn temp_dir() -> PathBuf {"}]}