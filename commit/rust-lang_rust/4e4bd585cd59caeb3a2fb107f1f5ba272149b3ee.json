{"sha": "4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNGJkNTg1Y2Q1OWNhZWIzYTJmYjEwN2YxZjViYTI3MjE0OWIzZWU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-06T12:57:07Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-06T16:11:30Z"}, "message": "Track all exports in exp_map\n\nThis is needed because the reachability checker needs to be able to\nfollow exports.\n\nIssue #1934", "tree": {"sha": "2935b3fd86619bcbd189b6eb7e07067a161dfebd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2935b3fd86619bcbd189b6eb7e07067a161dfebd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee", "html_url": "https://github.com/rust-lang/rust/commit/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19508c7d531910c309cd63e9ade2fe1be80ff71b", "url": "https://api.github.com/repos/rust-lang/rust/commits/19508c7d531910c309cd63e9ade2fe1be80ff71b", "html_url": "https://github.com/rust-lang/rust/commit/19508c7d531910c309cd63e9ade2fe1be80ff71b"}], "stats": {"total": 283, "additions": 151, "deletions": 132}, "files": [{"sha": "8ae7b6e359203f3b5dae502a96c7e92d7a2ae496", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee", "patch": "@@ -159,12 +159,17 @@ fn encode_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt, crate: @crate)\n \n fn encode_reexport_paths(ebml_w: ebml::writer,\n                          ecx: @encode_ctxt, &index: [entry<str>]) {\n-    ecx.ccx.exp_map.items {|path, defs|\n-        for def in *defs {\n+    let tcx = ecx.ccx.tcx;\n+    ecx.ccx.exp_map.items {|exp_id, defs|\n+        for def in defs {\n+            if !def.reexp { cont; }\n+            let path = alt check tcx.items.get(exp_id) {\n+              ast_map::node_export(_, path) { ast_map::path_to_str(*path) }\n+            };\n             index += [{val: path, pos: ebml_w.writer.tell()}];\n             ebml_w.start_tag(tag_paths_data_item);\n             encode_name(ebml_w, path);\n-            encode_def_id(ebml_w, ast_util::def_id_of_def(def));\n+            encode_def_id(ebml_w, def.id);\n             ebml_w.end_tag();\n         }\n     }"}, {"sha": "3ff8a96f287d7aa6d17979689054e4e311895cf9", "filename": "src/rustc/middle/ast_map.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee/src%2Frustc%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee/src%2Frustc%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fast_map.rs?ref=4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee", "patch": "@@ -27,6 +27,7 @@ enum ast_node {\n     node_method(@method, def_id /* impl did */, @path /* path to the impl */),\n     node_variant(variant, def_id, @path),\n     node_expr(@expr),\n+    node_export(@view_path, @path),\n     // Locals are numbered, because the alias analysis needs to know in which\n     // order they are introduced.\n     node_arg(arg, uint),\n@@ -38,14 +39,19 @@ type map = std::map::map<node_id, ast_node>;\n type ctx = {map: map, mutable path: path, mutable local_id: uint};\n type vt = visit::vt<ctx>;\n \n+fn extend(cx: ctx, elt: str) -> @path {\n+    @(cx.path + [path_name(elt)])\n+}\n+\n fn mk_ast_map_visitor() -> vt {\n     ret visit::mk_vt(@{\n         visit_item: map_item,\n         visit_native_item: map_native_item,\n         visit_expr: map_expr,\n         visit_fn: map_fn,\n         visit_local: map_local,\n-        visit_arm: map_arm\n+        visit_arm: map_arm,\n+        visit_view_item: map_view_item\n         with *visit::default_visitor()\n     });\n }\n@@ -140,20 +146,38 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n       item_enum(vs, _) {\n         for v in vs {\n             cx.map.insert(v.node.id, node_variant(\n-                v, ast_util::local_def(i.id),\n-                @(cx.path + [path_name(i.ident)])));\n+                v, ast_util::local_def(i.id), extend(cx, i.ident)));\n         }\n       }\n       _ { }\n     }\n     alt i.node {\n-      item_mod(_) | item_native_mod(_) { cx.path += [path_mod(i.ident)]; }\n+      item_mod(_) | item_native_mod(_) {\n+        cx.path += [path_mod(i.ident)];\n+      }\n       _ { cx.path += [path_name(i.ident)]; }\n     }\n     visit::visit_item(i, cx, v);\n     vec::pop(cx.path);\n }\n \n+fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n+    alt vi.node {\n+      view_item_export(vps) {\n+        for vp in vps {\n+            let (id, name) = alt vp.node {\n+              view_path_simple(nm, _, id) { (id, nm) }\n+              view_path_glob(pth, id) | view_path_list(pth, _, id) {\n+                (id, vec::last_total(*pth))\n+              }\n+            };\n+            cx.map.insert(id, node_export(vp, extend(cx, name)));\n+        }\n+      }\n+      _ {}\n+    }\n+}\n+\n fn map_native_item(i: @native_item, cx: ctx, v: vt) {\n     cx.map.insert(i.id, node_native_item(i, @cx.path));\n     visit::visit_native_item(i, cx, v);"}, {"sha": "af71d57dded066ac5bbcbf1a68fe4b729c826542", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 89, "deletions": 105, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee", "patch": "@@ -8,7 +8,7 @@ import front::attr;\n import metadata::{csearch, cstore};\n import driver::session::session;\n import util::common::*;\n-import std::map::{new_int_hash, new_str_hash};\n+import std::map::{new_int_hash, new_str_hash, mk_hashmap};\n import syntax::codemap::span;\n import syntax::visit;\n import visit::vt;\n@@ -117,16 +117,18 @@ type indexed_mod = {\n \n type def_map = hashmap<node_id, def>;\n type ext_map = hashmap<def_id, [ident]>;\n-type exp_map = hashmap<str, @mutable [def]>;\n type impl_map = hashmap<node_id, iscopes>;\n type impl_cache = hashmap<def_id, option<@[@_impl]>>;\n \n+type exp = {reexp: bool, id: def_id};\n+type exp_map = hashmap<node_id, [exp]>;\n+\n type env =\n     {cstore: cstore::cstore,\n      def_map: def_map,\n      ast_map: ast_map::map,\n      imports: hashmap<ast::node_id, import_state>,\n-     exp_map: exp_map,\n+     mutable exp_map: exp_map,\n      mod_map: hashmap<ast::node_id, @indexed_mod>,\n      block_map: hashmap<ast::node_id, [glob_imp_def]>,\n      ext_map: ext_map,\n@@ -188,7 +190,7 @@ fn create_env(sess: session, amap: ast_map::map) -> @env {\n       def_map: new_int_hash(),\n       ast_map: amap,\n       imports: new_int_hash(),\n-      exp_map: new_str_hash(),\n+      mutable exp_map: new_int_hash(),\n       mod_map: new_int_hash(),\n       block_map: new_int_hash(),\n       ext_map: new_def_hash(),\n@@ -2005,63 +2007,59 @@ fn check_exports(e: @env) {\n \n \n \n-    fn lookup_glob_any(e: @env, info: @indexed_mod, sp: span, path: str,\n-                       ident: ident) -> bool {\n-        let lookup =\n-            bind lookup_glob_in_mod(*e, info, sp, ident, _, inside);\n-        let (m, v, t) = (lookup(ns_module),\n-                         lookup(ns_val(value_or_enum)),\n-                         lookup(ns_type));\n-        let full_path = path + ident;\n-        maybe_add_reexport(e, full_path, m);\n-        maybe_add_reexport(e, full_path, v);\n-        maybe_add_reexport(e, full_path, t);\n+    fn lookup_glob_any(e: @env, info: @indexed_mod, sp: span,\n+                       ident: ident, export_id: node_id) -> bool {\n+        let m = lookup_glob_in_mod(*e, info, sp, ident, ns_module, inside);\n+        let v = lookup_glob_in_mod(*e, info, sp, ident, ns_val(value_or_enum),\n+                                   inside);\n+        let t = lookup_glob_in_mod(*e, info, sp, ident, ns_type, inside);\n+        maybe_add_reexport(e, export_id, m);\n+        maybe_add_reexport(e, export_id, v);\n+        maybe_add_reexport(e, export_id, t);\n         is_some(m) || is_some(v) || is_some(t)\n     }\n \n-    fn maybe_add_reexport(e: @env, path: str, def: option<def>) {\n-        alt def {\n-          some(def) {\n-            alt e.exp_map.find(path) {\n-              some(v) {\n-                // If there are multiple reexports of the same def\n-                // using the same path, then we only need one copy\n-                if !vec::contains(*v, def) {\n-                    *v += [def];\n-                }\n-              }\n-              none { e.exp_map.insert(path, @mutable [def]); }\n-            }\n-          }\n-          _ {}\n+\n+    fn maybe_add_reexport(e: @env, export_id: node_id, def: option<def>) {\n+        option::may(def) {|def|\n+            add_export(e, export_id, def_id_of_def(def), true);\n         }\n     }\n+    fn add_export(e: @env, export_id: node_id, target_id: def_id,\n+                  reexp: bool) {\n+        let found = alt e.exp_map.find(export_id) {\n+          some(f) { f } none { [] }\n+        };\n+        e.exp_map.insert(export_id, found + [{reexp: reexp, id: target_id}]);\n+    }\n \n     fn check_export(e: @env, ident: str, _mod: @indexed_mod,\n-                    vi: @view_item) {\n+                    export_id: node_id, vi: @view_item) {\n         let found_something = false;\n-        let full_path = _mod.path + ident;\n         if _mod.index.contains_key(ident) {\n             found_something = true;\n             let xs = _mod.index.get(ident);\n             list::iter(xs) {|x|\n                 alt x {\n                   mie_import_ident(id, _) {\n-                    alt e.imports.get(id) {\n+                    alt check e.imports.get(id) {\n                       resolved(v, t, m, _, rid, _) {\n-                        maybe_add_reexport(e, full_path, v);\n-                        maybe_add_reexport(e, full_path, t);\n-                        maybe_add_reexport(e, full_path, m);\n+                        maybe_add_reexport(e, export_id, v);\n+                        maybe_add_reexport(e, export_id, t);\n+                        maybe_add_reexport(e, export_id, m);\n                       }\n-                      _ { }\n                     }\n                   }\n+                  mie_item(@{id, _}) | mie_native_item(@{id, _}) |\n+                  mie_enum_variant(_, _, id, _) {\n+                    add_export(e, export_id, local_def(id), false);\n+                  }\n                   _ { }\n                 }\n             }\n         }\n-        found_something |= lookup_glob_any(e, _mod, vi.span,\n-                                           _mod.path, ident);\n+        found_something |= lookup_glob_any(e, _mod, vi.span, ident,\n+                                           export_id);\n         if !found_something {\n             e.sess.span_warn(vi.span,\n                              #fmt(\"exported item %s is not defined\", ident));\n@@ -2071,64 +2069,54 @@ fn check_exports(e: @env) {\n     fn check_enum_ok(e: @env, sp:span, id: ident, _mod: @indexed_mod)\n         -> node_id {\n         alt _mod.index.find(id) {\n-           none { e.sess.span_fatal(sp, #fmt(\"undefined id %s \\\n-                         in an export\", id)); }\n-           some(ms) {\n-             let maybe_id = list::find(ms) {|m|\n-                  alt m {\n-                     mie_item(an_item) {\n-                      alt an_item.node {\n-                          item_enum(_,_) { /* OK */ some(an_item.id) }\n-                          _ { none }\n-                      }\n-                     }\n-                     _ { none }\n-               }\n-             };\n-             alt maybe_id {\n-                some(an_id) { ret an_id; }\n-                _ { e.sess.span_fatal(sp, #fmt(\"%s does not refer \\\n-                          to an enumeration\", id)); }\n-             }\n-         }\n-      }\n+          none {\n+            e.sess.span_fatal(sp, #fmt(\"undefined id %s in an export\", id));\n+          }\n+          some(ms) {\n+            let maybe_id = list::find(ms) {|m|\n+                alt m {\n+                  mie_item(@{node: item_enum(_, _), id, _}) { some(id) }\n+                  _ { none }\n+                }\n+            };\n+            alt maybe_id {\n+              some(an_id) { an_id }\n+              _ { e.sess.span_fatal(sp, #fmt(\"%s does not refer \\\n+                                              to an enumeration\", id)); }\n+            }\n+          }\n+        }\n     }\n \n-    fn check_export_enum_list(e: @env, _mod: @indexed_mod,\n+    fn check_export_enum_list(e: @env, export_id: node_id, _mod: @indexed_mod,\n                               span: codemap::span, id: ast::ident,\n                               ids: [ast::path_list_ident]) {\n-        if vec::len(ids) == 0u {\n-            let _ = check_enum_ok(e, span, id, _mod);\n-        } else {\n-            let parent_id = check_enum_ok(e, span, id, _mod);\n-            for variant_id in ids {\n-                alt _mod.index.find(variant_id.node.name) {\n-                  some(ms) {\n-                    list::iter(ms) {|m|\n-                        alt m {\n-                          mie_enum_variant(_, _, actual_parent_id, _) {\n-                            if actual_parent_id != parent_id {\n-                                let msg = #fmt(\"variant %s \\\n-                                                doesn't belong to enum %s\",\n-                                               variant_id.node.name,\n-                                               id);\n-                                e.sess.span_err(span, msg);\n-                            }\n-                          }\n-                          _ {\n-                            e.sess.span_err(span,\n-                                            #fmt(\"%s is not a variant\",\n-                                                 variant_id.node.name));\n-                          }\n+        let parent_id = check_enum_ok(e, span, id, _mod);\n+        add_export(e, export_id, local_def(parent_id), false);\n+        for variant_id in ids {\n+            let found = false;\n+            alt _mod.index.find(variant_id.node.name) {\n+              some(ms) {\n+                list::iter(ms) {|m|\n+                    alt m {\n+                      mie_enum_variant(_, _, actual_parent_id, _) {\n+                        found = true;\n+                        if actual_parent_id != parent_id {\n+                            e.sess.span_err(\n+                                span, #fmt(\"variant %s doesn't belong to \\\n+                                            enum %s\",\n+                                           variant_id.node.name, id));\n                         }\n+                      }\n+                      _ {}\n                     }\n-                  }\n-                  _ {\n-                    e.sess.span_err(span,\n-                                    #fmt(\"%s is not a variant\",\n-                                         variant_id.node.name));\n-                  }\n                 }\n+              }\n+              _ {}\n+            }\n+            if !found {\n+                e.sess.span_err(span, #fmt(\"%s is not a variant\",\n+                                           variant_id.node.name));\n             }\n         }\n     }\n@@ -2141,17 +2129,17 @@ fn check_exports(e: @env) {\n             for vi in m.view_items {\n                 iter_export_paths(*vi) { |vp|\n                     alt vp.node {\n-                      ast::view_path_simple(ident, _, _) {\n-                        check_export(e, ident, _mod, vi);\n+                      ast::view_path_simple(ident, _, id) {\n+                        check_export(e, ident, _mod, id, vi);\n                       }\n-                      ast::view_path_list(path, ids, _) {\n+                      ast::view_path_list(path, ids, node_id) {\n                         let id = if vec::len(*path) == 1u {\n                             path[0]\n                         } else {\n-                            e.sess.span_fatal(vp.span,\n-                                            #fmt(\"bad export name-list\"))\n+                            e.sess.span_fatal(vp.span, \"bad export name-list\")\n                         };\n-                        check_export_enum_list(e, _mod, vp.span, id, ids);\n+                        check_export_enum_list(e, node_id, _mod, vp.span, id,\n+                                               ids);\n                       }\n                       ast::view_path_glob(_, node_id) {\n                         glob_is_re_exported.insert(node_id, ());\n@@ -2162,18 +2150,14 @@ fn check_exports(e: @env) {\n             // Now follow the export-glob links and fill in the\n             // globbed_exports and exp_map lists.\n             for glob in _mod.glob_imports {\n-                alt check glob.path.node {\n-                  ast::view_path_glob(path, node_id) {\n-                    if ! glob_is_re_exported.contains_key(node_id) {\n-                        cont;\n-                    }\n-                  }\n-                }\n+                let id = alt check glob.path.node {\n+                  ast::view_path_glob(_, node_id) { node_id }\n+                };\n+                if ! glob_is_re_exported.contains_key(id) { cont; }\n                 iter_mod(*e, glob.def,\n                          glob.path.span, outside) {|ident, def|\n-                    let full_path = _mod.path + ident;\n                     _mod.globbed_exports += [ident];\n-                    maybe_add_reexport(e, full_path, some(def));\n+                    maybe_add_reexport(e, id, some(def));\n                 }\n             }\n           }"}, {"sha": "b940b55d642177982d5a50e7a6c20d8b5aaacce6", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee", "patch": "@@ -2216,7 +2216,8 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n           }\n \n           ast_map::node_expr(_) | ast_map::node_arg(_, _) |\n-          ast_map::node_local(_) | ast_map::node_res_ctor(_) {\n+          ast_map::node_local(_) | ast_map::node_res_ctor(_) |\n+          ast_map::node_export(_, _) {\n             cx.sess.bug(#fmt[\"cannot find item_path for node %?\", node]);\n           }\n         }"}, {"sha": "ddbbf3d96d4771439dc86cc6d56de6b3a91547e5", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee", "patch": "@@ -4,6 +4,7 @@ import std::map;\n import rustc::syntax::ast;\n import rustc::syntax::ast_util;\n import rustc::util::common;\n+import rustc::middle::ast_map;\n \n export mk_pass;\n \n@@ -75,10 +76,11 @@ fn from_str_assoc_list<V:copy>(\n fn build_reexport_def_set(srv: astsrv::srv) -> def_set {\n     let assoc_list = astsrv::exec(srv) {|ctxt|\n         let def_set = common::new_def_hash();\n-        ctxt.exp_map.items {|_path, defs|\n-            for def in *defs {\n-                let def_id = ast_util::def_id_of_def(def);\n-                def_set.insert(def_id, ());\n+        ctxt.exp_map.items {|_id, defs|\n+            for def in defs {\n+                if def.reexp {\n+                    def_set.insert(def.id, ());\n+                }\n             }\n         }\n         to_assoc_list(def_set)\n@@ -154,29 +156,32 @@ fn build_reexport_path_map(srv: astsrv::srv, -def_map: def_map) -> path_map {\n         let def_map = from_def_assoc_list(def_assoc_list);\n         let path_map = map::new_str_hash();\n \n-        ctxt.exp_map.items {|path, defs|\n-\n-            let path = str::split_str(path, \"::\");\n-            let modpath = str::connect(vec::init(path), \"::\");\n-            let name = option::get(vec::last(path));\n+        ctxt.exp_map.items {|exp_id, defs|\n+            let path = alt check ctxt.ast_map.get(exp_id) {\n+              ast_map::node_export(_, path) { path }\n+            };\n+            let name = alt check vec::last_total(*path) {\n+              ast_map::path_name(nm) { nm }\n+            };\n+            let modpath = ast_map::path_to_str(vec::init(*path));\n \n             let reexportdocs = [];\n-            for def in *defs {\n-                let def_id = ast_util::def_id_of_def(def);\n-                alt def_map.find(def_id) {\n+            for def in defs {\n+                if !def.reexp { cont; }\n+                alt def_map.find(def.id) {\n                   some(itemtag) {\n                     reexportdocs += [(name, itemtag)];\n                   }\n-                  none { }\n+                  _ {}\n                 }\n             }\n \n-            if vec::is_not_empty(reexportdocs) {\n-                let prevdocs = alt path_map.find(modpath) {\n-                  some(docs) { docs }\n-                  none { [] }\n-                };\n-                let reexportdocs = prevdocs + reexportdocs;\n+            if reexportdocs.len() > 0u {\n+                option::may(path_map.find(modpath)) {|docs|\n+                    reexportdocs = docs + vec::filter(reexportdocs, {|x|\n+                        !vec::contains(docs, x)\n+                    });\n+                }\n                 path_map.insert(modpath, reexportdocs);\n                 #debug(\"path_map entry: %? - %?\",\n                        modpath, (name, reexportdocs));"}]}