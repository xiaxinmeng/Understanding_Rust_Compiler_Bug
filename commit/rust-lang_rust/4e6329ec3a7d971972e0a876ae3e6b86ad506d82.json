{"sha": "4e6329ec3a7d971972e0a876ae3e6b86ad506d82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNjMyOWVjM2E3ZDk3MTk3MmUwYTg3NmFlM2U2Yjg2YWQ1MDZkODI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-06T05:28:43Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-09T07:57:24Z"}, "message": "extract path lowering -> path.rs", "tree": {"sha": "e1ae2e59f3ee95ca8384d7354def9c8bc98eceb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1ae2e59f3ee95ca8384d7354def9c8bc98eceb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e6329ec3a7d971972e0a876ae3e6b86ad506d82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e6329ec3a7d971972e0a876ae3e6b86ad506d82", "html_url": "https://github.com/rust-lang/rust/commit/4e6329ec3a7d971972e0a876ae3e6b86ad506d82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e6329ec3a7d971972e0a876ae3e6b86ad506d82/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae6e31b1a339903a92bb03ee085924e3da425356", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae6e31b1a339903a92bb03ee085924e3da425356", "html_url": "https://github.com/rust-lang/rust/commit/ae6e31b1a339903a92bb03ee085924e3da425356"}], "stats": {"total": 829, "additions": 426, "deletions": 403}, "files": [{"sha": "3211c57f6bbb008a9c4186737c1a47b3a58ec4a5", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 3, "deletions": 401, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/4e6329ec3a7d971972e0a876ae3e6b86ad506d82/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e6329ec3a7d971972e0a876ae3e6b86ad506d82/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=4e6329ec3a7d971972e0a876ae3e6b86ad506d82", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! Lowers the AST to the HIR.\n //!\n //! Since the AST and HIR are fairly similar, this is mostly a simple procedure,\n@@ -40,15 +38,15 @@ use rustc::dep_graph::DepGraph;\n use rustc::hir::map::definitions::{DefKey, DefPathData, Definitions};\n use rustc::hir::map::Map;\n use rustc::lint;\n-use rustc::lint::builtin::{self, ELIDED_LIFETIMES_IN_PATHS};\n+use rustc::lint::builtin;\n use rustc::middle::cstore::CrateStore;\n use rustc::util::captures::Captures;\n use rustc::util::common::FN_OUTPUT_NAME;\n use rustc::{bug, span_bug};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_error_codes::*;\n-use rustc_errors::{struct_span_err, Applicability};\n+use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n use rustc_hir::def_id::{DefId, DefIdMap, DefIndex, CRATE_DEF_INDEX};\n@@ -87,6 +85,7 @@ macro_rules! arena_vec {\n mod expr;\n mod item;\n mod pat;\n+mod path;\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -1624,403 +1623,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         )\n     }\n \n-    fn lower_qpath(\n-        &mut self,\n-        id: NodeId,\n-        qself: &Option<QSelf>,\n-        p: &Path,\n-        param_mode: ParamMode,\n-        mut itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> hir::QPath<'hir> {\n-        let qself_position = qself.as_ref().map(|q| q.position);\n-        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx.reborrow()));\n-\n-        let partial_res =\n-            self.resolver.get_partial_res(id).unwrap_or_else(|| PartialRes::new(Res::Err));\n-\n-        let proj_start = p.segments.len() - partial_res.unresolved_segments();\n-        let path = self.arena.alloc(hir::Path {\n-            res: self.lower_res(partial_res.base_res()),\n-            segments: self.arena.alloc_from_iter(p.segments[..proj_start].iter().enumerate().map(\n-                |(i, segment)| {\n-                    let param_mode = match (qself_position, param_mode) {\n-                        (Some(j), ParamMode::Optional) if i < j => {\n-                            // This segment is part of the trait path in a\n-                            // qualified path - one of `a`, `b` or `Trait`\n-                            // in `<X as a::b::Trait>::T::U::method`.\n-                            ParamMode::Explicit\n-                        }\n-                        _ => param_mode,\n-                    };\n-\n-                    // Figure out if this is a type/trait segment,\n-                    // which may need lifetime elision performed.\n-                    let parent_def_id = |this: &mut Self, def_id: DefId| DefId {\n-                        krate: def_id.krate,\n-                        index: this.def_key(def_id).parent.expect(\"missing parent\"),\n-                    };\n-                    let type_def_id = match partial_res.base_res() {\n-                        Res::Def(DefKind::AssocTy, def_id) if i + 2 == proj_start => {\n-                            Some(parent_def_id(self, def_id))\n-                        }\n-                        Res::Def(DefKind::Variant, def_id) if i + 1 == proj_start => {\n-                            Some(parent_def_id(self, def_id))\n-                        }\n-                        Res::Def(DefKind::Struct, def_id)\n-                        | Res::Def(DefKind::Union, def_id)\n-                        | Res::Def(DefKind::Enum, def_id)\n-                        | Res::Def(DefKind::TyAlias, def_id)\n-                        | Res::Def(DefKind::Trait, def_id)\n-                            if i + 1 == proj_start =>\n-                        {\n-                            Some(def_id)\n-                        }\n-                        _ => None,\n-                    };\n-                    let parenthesized_generic_args = match partial_res.base_res() {\n-                        // `a::b::Trait(Args)`\n-                        Res::Def(DefKind::Trait, _) if i + 1 == proj_start => {\n-                            ParenthesizedGenericArgs::Ok\n-                        }\n-                        // `a::b::Trait(Args)::TraitItem`\n-                        Res::Def(DefKind::Method, _)\n-                        | Res::Def(DefKind::AssocConst, _)\n-                        | Res::Def(DefKind::AssocTy, _)\n-                            if i + 2 == proj_start =>\n-                        {\n-                            ParenthesizedGenericArgs::Ok\n-                        }\n-                        // Avoid duplicated errors.\n-                        Res::Err => ParenthesizedGenericArgs::Ok,\n-                        // An error\n-                        _ => ParenthesizedGenericArgs::Err,\n-                    };\n-\n-                    let num_lifetimes = type_def_id.map_or(0, |def_id| {\n-                        if let Some(&n) = self.type_def_lifetime_params.get(&def_id) {\n-                            return n;\n-                        }\n-                        assert!(!def_id.is_local());\n-                        let item_generics = self\n-                            .resolver\n-                            .cstore()\n-                            .item_generics_cloned_untracked(def_id, self.sess);\n-                        let n = item_generics.own_counts().lifetimes;\n-                        self.type_def_lifetime_params.insert(def_id, n);\n-                        n\n-                    });\n-                    self.lower_path_segment(\n-                        p.span,\n-                        segment,\n-                        param_mode,\n-                        num_lifetimes,\n-                        parenthesized_generic_args,\n-                        itctx.reborrow(),\n-                        None,\n-                    )\n-                },\n-            )),\n-            span: p.span,\n-        });\n-\n-        // Simple case, either no projections, or only fully-qualified.\n-        // E.g., `std::mem::size_of` or `<I as Iterator>::Item`.\n-        if partial_res.unresolved_segments() == 0 {\n-            return hir::QPath::Resolved(qself, path);\n-        }\n-\n-        // Create the innermost type that we're projecting from.\n-        let mut ty = if path.segments.is_empty() {\n-            // If the base path is empty that means there exists a\n-            // syntactical `Self`, e.g., `&i32` in `<&i32>::clone`.\n-            qself.expect(\"missing QSelf for <T>::...\")\n-        } else {\n-            // Otherwise, the base path is an implicit `Self` type path,\n-            // e.g., `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n-            // `<I as Iterator>::Item::default`.\n-            let new_id = self.next_id();\n-            self.arena.alloc(self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path)))\n-        };\n-\n-        // Anything after the base path are associated \"extensions\",\n-        // out of which all but the last one are associated types,\n-        // e.g., for `std::vec::Vec::<T>::IntoIter::Item::clone`:\n-        // * base path is `std::vec::Vec<T>`\n-        // * \"extensions\" are `IntoIter`, `Item` and `clone`\n-        // * type nodes are:\n-        //   1. `std::vec::Vec<T>` (created above)\n-        //   2. `<std::vec::Vec<T>>::IntoIter`\n-        //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n-        // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n-        for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n-            let segment = self.arena.alloc(self.lower_path_segment(\n-                p.span,\n-                segment,\n-                param_mode,\n-                0,\n-                ParenthesizedGenericArgs::Err,\n-                itctx.reborrow(),\n-                None,\n-            ));\n-            let qpath = hir::QPath::TypeRelative(ty, segment);\n-\n-            // It's finished, return the extension of the right node type.\n-            if i == p.segments.len() - 1 {\n-                return qpath;\n-            }\n-\n-            // Wrap the associated extension in another type node.\n-            let new_id = self.next_id();\n-            ty = self.arena.alloc(self.ty_path(new_id, p.span, qpath));\n-        }\n-\n-        // We should've returned in the for loop above.\n-        span_bug!(\n-            p.span,\n-            \"lower_qpath: no final extension segment in {}..{}\",\n-            proj_start,\n-            p.segments.len()\n-        )\n-    }\n-\n-    fn lower_path_extra(\n-        &mut self,\n-        res: Res,\n-        p: &Path,\n-        param_mode: ParamMode,\n-        explicit_owner: Option<NodeId>,\n-    ) -> &'hir hir::Path<'hir> {\n-        self.arena.alloc(hir::Path {\n-            res,\n-            segments: self.arena.alloc_from_iter(p.segments.iter().map(|segment| {\n-                self.lower_path_segment(\n-                    p.span,\n-                    segment,\n-                    param_mode,\n-                    0,\n-                    ParenthesizedGenericArgs::Err,\n-                    ImplTraitContext::disallowed(),\n-                    explicit_owner,\n-                )\n-            })),\n-            span: p.span,\n-        })\n-    }\n-\n-    fn lower_path(&mut self, id: NodeId, p: &Path, param_mode: ParamMode) -> &'hir hir::Path<'hir> {\n-        let res = self.expect_full_res(id);\n-        let res = self.lower_res(res);\n-        self.lower_path_extra(res, p, param_mode, None)\n-    }\n-\n-    fn lower_path_segment(\n-        &mut self,\n-        path_span: Span,\n-        segment: &PathSegment,\n-        param_mode: ParamMode,\n-        expected_lifetimes: usize,\n-        parenthesized_generic_args: ParenthesizedGenericArgs,\n-        itctx: ImplTraitContext<'_, 'hir>,\n-        explicit_owner: Option<NodeId>,\n-    ) -> hir::PathSegment<'hir> {\n-        let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n-            let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n-            match **generic_args {\n-                GenericArgs::AngleBracketed(ref data) => {\n-                    self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n-                }\n-                GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n-                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n-                    ParenthesizedGenericArgs::Err => {\n-                        let mut err = struct_span_err!(self.sess, data.span, E0214, \"{}\", msg);\n-                        err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n-                        if let Ok(snippet) = self.sess.source_map().span_to_snippet(data.span) {\n-                            // Do not suggest going from `Trait()` to `Trait<>`\n-                            if data.inputs.len() > 0 {\n-                                if let Some(split) = snippet.find('(') {\n-                                    let trait_name = &snippet[0..split];\n-                                    let args = &snippet[split + 1..snippet.len() - 1];\n-                                    err.span_suggestion(\n-                                        data.span,\n-                                        \"use angle brackets instead\",\n-                                        format!(\"{}<{}>\", trait_name, args),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                            }\n-                        };\n-                        err.emit();\n-                        (\n-                            self.lower_angle_bracketed_parameter_data(\n-                                &data.as_angle_bracketed_args(),\n-                                param_mode,\n-                                itctx,\n-                            )\n-                            .0,\n-                            false,\n-                        )\n-                    }\n-                },\n-            }\n-        } else {\n-            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode, itctx)\n-        };\n-\n-        let has_lifetimes = generic_args.args.iter().any(|arg| match arg {\n-            GenericArg::Lifetime(_) => true,\n-            _ => false,\n-        });\n-        let first_generic_span = generic_args\n-            .args\n-            .iter()\n-            .map(|a| a.span())\n-            .chain(generic_args.bindings.iter().map(|b| b.span))\n-            .next();\n-        if !generic_args.parenthesized && !has_lifetimes {\n-            generic_args.args = self\n-                .elided_path_lifetimes(path_span, expected_lifetimes)\n-                .map(|lt| GenericArg::Lifetime(lt))\n-                .chain(generic_args.args.into_iter())\n-                .collect();\n-            if expected_lifetimes > 0 && param_mode == ParamMode::Explicit {\n-                let anon_lt_suggestion = vec![\"'_\"; expected_lifetimes].join(\", \");\n-                let no_non_lt_args = generic_args.args.len() == expected_lifetimes;\n-                let no_bindings = generic_args.bindings.is_empty();\n-                let (incl_angl_brckt, insertion_sp, suggestion) = if no_non_lt_args && no_bindings {\n-                    // If there are no (non-implicit) generic args or associated type\n-                    // bindings, our suggestion includes the angle brackets.\n-                    (true, path_span.shrink_to_hi(), format!(\"<{}>\", anon_lt_suggestion))\n-                } else {\n-                    // Otherwise (sorry, this is kind of gross) we need to infer the\n-                    // place to splice in the `'_, ` from the generics that do exist.\n-                    let first_generic_span = first_generic_span\n-                        .expect(\"already checked that non-lifetime args or bindings exist\");\n-                    (false, first_generic_span.shrink_to_lo(), format!(\"{}, \", anon_lt_suggestion))\n-                };\n-                match self.anonymous_lifetime_mode {\n-                    // In create-parameter mode we error here because we don't want to support\n-                    // deprecated impl elision in new features like impl elision and `async fn`,\n-                    // both of which work using the `CreateParameter` mode:\n-                    //\n-                    //     impl Foo for std::cell::Ref<u32> // note lack of '_\n-                    //     async fn foo(_: std::cell::Ref<u32>) { ... }\n-                    AnonymousLifetimeMode::CreateParameter => {\n-                        let mut err = struct_span_err!(\n-                            self.sess,\n-                            path_span,\n-                            E0726,\n-                            \"implicit elided lifetime not allowed here\"\n-                        );\n-                        crate::lint::builtin::add_elided_lifetime_in_path_suggestion(\n-                            &self.sess,\n-                            &mut err,\n-                            expected_lifetimes,\n-                            path_span,\n-                            incl_angl_brckt,\n-                            insertion_sp,\n-                            suggestion,\n-                        );\n-                        err.emit();\n-                    }\n-                    AnonymousLifetimeMode::PassThrough | AnonymousLifetimeMode::ReportError => {\n-                        self.resolver.lint_buffer().buffer_lint_with_diagnostic(\n-                            ELIDED_LIFETIMES_IN_PATHS,\n-                            CRATE_NODE_ID,\n-                            path_span,\n-                            \"hidden lifetime parameters in types are deprecated\",\n-                            builtin::BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n-                                expected_lifetimes,\n-                                path_span,\n-                                incl_angl_brckt,\n-                                insertion_sp,\n-                                suggestion,\n-                            ),\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-\n-        let res = self.expect_full_res(segment.id);\n-        let id = if let Some(owner) = explicit_owner {\n-            self.lower_node_id_with_owner(segment.id, owner)\n-        } else {\n-            self.lower_node_id(segment.id)\n-        };\n-        debug!(\n-            \"lower_path_segment: ident={:?} original-id={:?} new-id={:?}\",\n-            segment.ident, segment.id, id,\n-        );\n-\n-        hir::PathSegment {\n-            ident: segment.ident,\n-            hir_id: Some(id),\n-            res: Some(self.lower_res(res)),\n-            infer_args,\n-            args: if generic_args.is_empty() {\n-                None\n-            } else {\n-                Some(self.arena.alloc(generic_args.into_generic_args(self.arena)))\n-            },\n-        }\n-    }\n-\n-    fn lower_angle_bracketed_parameter_data(\n-        &mut self,\n-        data: &AngleBracketedArgs,\n-        param_mode: ParamMode,\n-        mut itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> (GenericArgsCtor<'hir>, bool) {\n-        let &AngleBracketedArgs { ref args, ref constraints, .. } = data;\n-        let has_non_lt_args = args.iter().any(|arg| match arg {\n-            ast::GenericArg::Lifetime(_) => false,\n-            ast::GenericArg::Type(_) => true,\n-            ast::GenericArg::Const(_) => true,\n-        });\n-        (\n-            GenericArgsCtor {\n-                args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n-                bindings: self.arena.alloc_from_iter(\n-                    constraints.iter().map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow())),\n-                ),\n-                parenthesized: false,\n-            },\n-            !has_non_lt_args && param_mode == ParamMode::Optional,\n-        )\n-    }\n-\n-    fn lower_parenthesized_parameter_data(\n-        &mut self,\n-        data: &ParenthesizedArgs,\n-    ) -> (GenericArgsCtor<'hir>, bool) {\n-        // Switch to `PassThrough` mode for anonymous lifetimes; this\n-        // means that we permit things like `&Ref<T>`, where `Ref` has\n-        // a hidden lifetime parameter. This is needed for backwards\n-        // compatibility, even in contexts like an impl header where\n-        // we generally don't permit such things (see #51008).\n-        self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n-            let &ParenthesizedArgs { ref inputs, ref output, span } = data;\n-            let inputs = this.arena.alloc_from_iter(\n-                inputs.iter().map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed())),\n-            );\n-            let output_ty = match output {\n-                FunctionRetTy::Ty(ty) => this.lower_ty(&ty, ImplTraitContext::disallowed()),\n-                FunctionRetTy::Default(_) => this.arena.alloc(this.ty_tup(span, &[])),\n-            };\n-            let args = smallvec![GenericArg::Type(this.ty_tup(span, inputs))];\n-            let binding = hir::TypeBinding {\n-                hir_id: this.next_id(),\n-                ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n-                span: output_ty.span,\n-                kind: hir::TypeBindingKind::Equality { ty: output_ty },\n-            };\n-            (\n-                GenericArgsCtor { args, bindings: arena_vec![this; binding], parenthesized: true },\n-                false,\n-            )\n-        })\n-    }\n-\n     fn lower_local(&mut self, l: &Local) -> (hir::Local<'hir>, SmallVec<[NodeId; 1]>) {\n         let mut ids = SmallVec::<[NodeId; 1]>::new();\n         if self.sess.features_untracked().impl_trait_in_bindings {"}, {"sha": "cd69646d0c53ae57e9d7ec023fa53da53b8541fe", "filename": "src/librustc_ast_lowering/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e6329ec3a7d971972e0a876ae3e6b86ad506d82/src%2Flibrustc_ast_lowering%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e6329ec3a7d971972e0a876ae3e6b86ad506d82/src%2Flibrustc_ast_lowering%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpat.rs?ref=4e6329ec3a7d971972e0a876ae3e6b86ad506d82", "patch": "@@ -1,7 +1,7 @@\n use super::{ImplTraitContext, LoweringContext, ParamMode};\n \n-use rustc::hir;\n-use rustc::hir::def::Res;\n+use rustc_hir as hir;\n+use rustc_hir::def::Res;\n use rustc_span::{source_map::Spanned, Span};\n use syntax::ast::*;\n use syntax::ptr::P;"}, {"sha": "7209dbfdcc78f58327f01994522f7b2f6e3c68ea", "filename": "src/librustc_ast_lowering/path.rs", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/4e6329ec3a7d971972e0a876ae3e6b86ad506d82/src%2Flibrustc_ast_lowering%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e6329ec3a7d971972e0a876ae3e6b86ad506d82/src%2Flibrustc_ast_lowering%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpath.rs?ref=4e6329ec3a7d971972e0a876ae3e6b86ad506d82", "patch": "@@ -0,0 +1,421 @@\n+use super::{AnonymousLifetimeMode, ImplTraitContext, LoweringContext, ParamMode};\n+use super::{GenericArgsCtor, ParenthesizedGenericArgs};\n+\n+use rustc::lint::builtin::{self, ELIDED_LIFETIMES_IN_PATHS};\n+use rustc::span_bug;\n+use rustc::util::common::FN_OUTPUT_NAME;\n+use rustc_error_codes::*;\n+use rustc_errors::{struct_span_err, Applicability};\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, PartialRes, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::GenericArg;\n+use rustc_span::Span;\n+use syntax::ast::{self, *};\n+\n+use log::debug;\n+use smallvec::smallvec;\n+\n+impl<'a, 'hir> LoweringContext<'a, 'hir> {\n+    crate fn lower_qpath(\n+        &mut self,\n+        id: NodeId,\n+        qself: &Option<QSelf>,\n+        p: &Path,\n+        param_mode: ParamMode,\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::QPath<'hir> {\n+        let qself_position = qself.as_ref().map(|q| q.position);\n+        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx.reborrow()));\n+\n+        let partial_res =\n+            self.resolver.get_partial_res(id).unwrap_or_else(|| PartialRes::new(Res::Err));\n+\n+        let proj_start = p.segments.len() - partial_res.unresolved_segments();\n+        let path = self.arena.alloc(hir::Path {\n+            res: self.lower_res(partial_res.base_res()),\n+            segments: self.arena.alloc_from_iter(p.segments[..proj_start].iter().enumerate().map(\n+                |(i, segment)| {\n+                    let param_mode = match (qself_position, param_mode) {\n+                        (Some(j), ParamMode::Optional) if i < j => {\n+                            // This segment is part of the trait path in a\n+                            // qualified path - one of `a`, `b` or `Trait`\n+                            // in `<X as a::b::Trait>::T::U::method`.\n+                            ParamMode::Explicit\n+                        }\n+                        _ => param_mode,\n+                    };\n+\n+                    // Figure out if this is a type/trait segment,\n+                    // which may need lifetime elision performed.\n+                    let parent_def_id = |this: &mut Self, def_id: DefId| DefId {\n+                        krate: def_id.krate,\n+                        index: this.def_key(def_id).parent.expect(\"missing parent\"),\n+                    };\n+                    let type_def_id = match partial_res.base_res() {\n+                        Res::Def(DefKind::AssocTy, def_id) if i + 2 == proj_start => {\n+                            Some(parent_def_id(self, def_id))\n+                        }\n+                        Res::Def(DefKind::Variant, def_id) if i + 1 == proj_start => {\n+                            Some(parent_def_id(self, def_id))\n+                        }\n+                        Res::Def(DefKind::Struct, def_id)\n+                        | Res::Def(DefKind::Union, def_id)\n+                        | Res::Def(DefKind::Enum, def_id)\n+                        | Res::Def(DefKind::TyAlias, def_id)\n+                        | Res::Def(DefKind::Trait, def_id)\n+                            if i + 1 == proj_start =>\n+                        {\n+                            Some(def_id)\n+                        }\n+                        _ => None,\n+                    };\n+                    let parenthesized_generic_args = match partial_res.base_res() {\n+                        // `a::b::Trait(Args)`\n+                        Res::Def(DefKind::Trait, _) if i + 1 == proj_start => {\n+                            ParenthesizedGenericArgs::Ok\n+                        }\n+                        // `a::b::Trait(Args)::TraitItem`\n+                        Res::Def(DefKind::Method, _)\n+                        | Res::Def(DefKind::AssocConst, _)\n+                        | Res::Def(DefKind::AssocTy, _)\n+                            if i + 2 == proj_start =>\n+                        {\n+                            ParenthesizedGenericArgs::Ok\n+                        }\n+                        // Avoid duplicated errors.\n+                        Res::Err => ParenthesizedGenericArgs::Ok,\n+                        // An error\n+                        _ => ParenthesizedGenericArgs::Err,\n+                    };\n+\n+                    let num_lifetimes = type_def_id.map_or(0, |def_id| {\n+                        if let Some(&n) = self.type_def_lifetime_params.get(&def_id) {\n+                            return n;\n+                        }\n+                        assert!(!def_id.is_local());\n+                        let item_generics = self\n+                            .resolver\n+                            .cstore()\n+                            .item_generics_cloned_untracked(def_id, self.sess);\n+                        let n = item_generics.own_counts().lifetimes;\n+                        self.type_def_lifetime_params.insert(def_id, n);\n+                        n\n+                    });\n+                    self.lower_path_segment(\n+                        p.span,\n+                        segment,\n+                        param_mode,\n+                        num_lifetimes,\n+                        parenthesized_generic_args,\n+                        itctx.reborrow(),\n+                        None,\n+                    )\n+                },\n+            )),\n+            span: p.span,\n+        });\n+\n+        // Simple case, either no projections, or only fully-qualified.\n+        // E.g., `std::mem::size_of` or `<I as Iterator>::Item`.\n+        if partial_res.unresolved_segments() == 0 {\n+            return hir::QPath::Resolved(qself, path);\n+        }\n+\n+        // Create the innermost type that we're projecting from.\n+        let mut ty = if path.segments.is_empty() {\n+            // If the base path is empty that means there exists a\n+            // syntactical `Self`, e.g., `&i32` in `<&i32>::clone`.\n+            qself.expect(\"missing QSelf for <T>::...\")\n+        } else {\n+            // Otherwise, the base path is an implicit `Self` type path,\n+            // e.g., `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n+            // `<I as Iterator>::Item::default`.\n+            let new_id = self.next_id();\n+            self.arena.alloc(self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path)))\n+        };\n+\n+        // Anything after the base path are associated \"extensions\",\n+        // out of which all but the last one are associated types,\n+        // e.g., for `std::vec::Vec::<T>::IntoIter::Item::clone`:\n+        // * base path is `std::vec::Vec<T>`\n+        // * \"extensions\" are `IntoIter`, `Item` and `clone`\n+        // * type nodes are:\n+        //   1. `std::vec::Vec<T>` (created above)\n+        //   2. `<std::vec::Vec<T>>::IntoIter`\n+        //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n+        // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n+        for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n+            let segment = self.arena.alloc(self.lower_path_segment(\n+                p.span,\n+                segment,\n+                param_mode,\n+                0,\n+                ParenthesizedGenericArgs::Err,\n+                itctx.reborrow(),\n+                None,\n+            ));\n+            let qpath = hir::QPath::TypeRelative(ty, segment);\n+\n+            // It's finished, return the extension of the right node type.\n+            if i == p.segments.len() - 1 {\n+                return qpath;\n+            }\n+\n+            // Wrap the associated extension in another type node.\n+            let new_id = self.next_id();\n+            ty = self.arena.alloc(self.ty_path(new_id, p.span, qpath));\n+        }\n+\n+        // We should've returned in the for loop above.\n+        span_bug!(\n+            p.span,\n+            \"lower_qpath: no final extension segment in {}..{}\",\n+            proj_start,\n+            p.segments.len()\n+        )\n+    }\n+\n+    crate fn lower_path_extra(\n+        &mut self,\n+        res: Res,\n+        p: &Path,\n+        param_mode: ParamMode,\n+        explicit_owner: Option<NodeId>,\n+    ) -> &'hir hir::Path<'hir> {\n+        self.arena.alloc(hir::Path {\n+            res,\n+            segments: self.arena.alloc_from_iter(p.segments.iter().map(|segment| {\n+                self.lower_path_segment(\n+                    p.span,\n+                    segment,\n+                    param_mode,\n+                    0,\n+                    ParenthesizedGenericArgs::Err,\n+                    ImplTraitContext::disallowed(),\n+                    explicit_owner,\n+                )\n+            })),\n+            span: p.span,\n+        })\n+    }\n+\n+    crate fn lower_path(\n+        &mut self,\n+        id: NodeId,\n+        p: &Path,\n+        param_mode: ParamMode,\n+    ) -> &'hir hir::Path<'hir> {\n+        let res = self.expect_full_res(id);\n+        let res = self.lower_res(res);\n+        self.lower_path_extra(res, p, param_mode, None)\n+    }\n+\n+    crate fn lower_path_segment(\n+        &mut self,\n+        path_span: Span,\n+        segment: &PathSegment,\n+        param_mode: ParamMode,\n+        expected_lifetimes: usize,\n+        parenthesized_generic_args: ParenthesizedGenericArgs,\n+        itctx: ImplTraitContext<'_, 'hir>,\n+        explicit_owner: Option<NodeId>,\n+    ) -> hir::PathSegment<'hir> {\n+        let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n+            let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n+            match **generic_args {\n+                GenericArgs::AngleBracketed(ref data) => {\n+                    self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n+                }\n+                GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n+                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n+                    ParenthesizedGenericArgs::Err => {\n+                        let mut err = struct_span_err!(self.sess, data.span, E0214, \"{}\", msg);\n+                        err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n+                        if let Ok(snippet) = self.sess.source_map().span_to_snippet(data.span) {\n+                            // Do not suggest going from `Trait()` to `Trait<>`\n+                            if data.inputs.len() > 0 {\n+                                if let Some(split) = snippet.find('(') {\n+                                    let trait_name = &snippet[0..split];\n+                                    let args = &snippet[split + 1..snippet.len() - 1];\n+                                    err.span_suggestion(\n+                                        data.span,\n+                                        \"use angle brackets instead\",\n+                                        format!(\"{}<{}>\", trait_name, args),\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                }\n+                            }\n+                        };\n+                        err.emit();\n+                        (\n+                            self.lower_angle_bracketed_parameter_data(\n+                                &data.as_angle_bracketed_args(),\n+                                param_mode,\n+                                itctx,\n+                            )\n+                            .0,\n+                            false,\n+                        )\n+                    }\n+                },\n+            }\n+        } else {\n+            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode, itctx)\n+        };\n+\n+        let has_lifetimes = generic_args.args.iter().any(|arg| match arg {\n+            GenericArg::Lifetime(_) => true,\n+            _ => false,\n+        });\n+        let first_generic_span = generic_args\n+            .args\n+            .iter()\n+            .map(|a| a.span())\n+            .chain(generic_args.bindings.iter().map(|b| b.span))\n+            .next();\n+        if !generic_args.parenthesized && !has_lifetimes {\n+            generic_args.args = self\n+                .elided_path_lifetimes(path_span, expected_lifetimes)\n+                .map(|lt| GenericArg::Lifetime(lt))\n+                .chain(generic_args.args.into_iter())\n+                .collect();\n+            if expected_lifetimes > 0 && param_mode == ParamMode::Explicit {\n+                let anon_lt_suggestion = vec![\"'_\"; expected_lifetimes].join(\", \");\n+                let no_non_lt_args = generic_args.args.len() == expected_lifetimes;\n+                let no_bindings = generic_args.bindings.is_empty();\n+                let (incl_angl_brckt, insertion_sp, suggestion) = if no_non_lt_args && no_bindings {\n+                    // If there are no (non-implicit) generic args or associated type\n+                    // bindings, our suggestion includes the angle brackets.\n+                    (true, path_span.shrink_to_hi(), format!(\"<{}>\", anon_lt_suggestion))\n+                } else {\n+                    // Otherwise (sorry, this is kind of gross) we need to infer the\n+                    // place to splice in the `'_, ` from the generics that do exist.\n+                    let first_generic_span = first_generic_span\n+                        .expect(\"already checked that non-lifetime args or bindings exist\");\n+                    (false, first_generic_span.shrink_to_lo(), format!(\"{}, \", anon_lt_suggestion))\n+                };\n+                match self.anonymous_lifetime_mode {\n+                    // In create-parameter mode we error here because we don't want to support\n+                    // deprecated impl elision in new features like impl elision and `async fn`,\n+                    // both of which work using the `CreateParameter` mode:\n+                    //\n+                    //     impl Foo for std::cell::Ref<u32> // note lack of '_\n+                    //     async fn foo(_: std::cell::Ref<u32>) { ... }\n+                    AnonymousLifetimeMode::CreateParameter => {\n+                        let mut err = struct_span_err!(\n+                            self.sess,\n+                            path_span,\n+                            E0726,\n+                            \"implicit elided lifetime not allowed here\"\n+                        );\n+                        crate::lint::builtin::add_elided_lifetime_in_path_suggestion(\n+                            &self.sess,\n+                            &mut err,\n+                            expected_lifetimes,\n+                            path_span,\n+                            incl_angl_brckt,\n+                            insertion_sp,\n+                            suggestion,\n+                        );\n+                        err.emit();\n+                    }\n+                    AnonymousLifetimeMode::PassThrough | AnonymousLifetimeMode::ReportError => {\n+                        self.resolver.lint_buffer().buffer_lint_with_diagnostic(\n+                            ELIDED_LIFETIMES_IN_PATHS,\n+                            CRATE_NODE_ID,\n+                            path_span,\n+                            \"hidden lifetime parameters in types are deprecated\",\n+                            builtin::BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n+                                expected_lifetimes,\n+                                path_span,\n+                                incl_angl_brckt,\n+                                insertion_sp,\n+                                suggestion,\n+                            ),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        let res = self.expect_full_res(segment.id);\n+        let id = if let Some(owner) = explicit_owner {\n+            self.lower_node_id_with_owner(segment.id, owner)\n+        } else {\n+            self.lower_node_id(segment.id)\n+        };\n+        debug!(\n+            \"lower_path_segment: ident={:?} original-id={:?} new-id={:?}\",\n+            segment.ident, segment.id, id,\n+        );\n+\n+        hir::PathSegment {\n+            ident: segment.ident,\n+            hir_id: Some(id),\n+            res: Some(self.lower_res(res)),\n+            infer_args,\n+            args: if generic_args.is_empty() {\n+                None\n+            } else {\n+                Some(self.arena.alloc(generic_args.into_generic_args(self.arena)))\n+            },\n+        }\n+    }\n+\n+    fn lower_angle_bracketed_parameter_data(\n+        &mut self,\n+        data: &AngleBracketedArgs,\n+        param_mode: ParamMode,\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> (GenericArgsCtor<'hir>, bool) {\n+        let &AngleBracketedArgs { ref args, ref constraints, .. } = data;\n+        let has_non_lt_args = args.iter().any(|arg| match arg {\n+            ast::GenericArg::Lifetime(_) => false,\n+            ast::GenericArg::Type(_) => true,\n+            ast::GenericArg::Const(_) => true,\n+        });\n+        (\n+            GenericArgsCtor {\n+                args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n+                bindings: self.arena.alloc_from_iter(\n+                    constraints.iter().map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow())),\n+                ),\n+                parenthesized: false,\n+            },\n+            !has_non_lt_args && param_mode == ParamMode::Optional,\n+        )\n+    }\n+\n+    fn lower_parenthesized_parameter_data(\n+        &mut self,\n+        data: &ParenthesizedArgs,\n+    ) -> (GenericArgsCtor<'hir>, bool) {\n+        // Switch to `PassThrough` mode for anonymous lifetimes; this\n+        // means that we permit things like `&Ref<T>`, where `Ref` has\n+        // a hidden lifetime parameter. This is needed for backwards\n+        // compatibility, even in contexts like an impl header where\n+        // we generally don't permit such things (see #51008).\n+        self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n+            let &ParenthesizedArgs { ref inputs, ref output, span } = data;\n+            let inputs = this.arena.alloc_from_iter(\n+                inputs.iter().map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed())),\n+            );\n+            let output_ty = match output {\n+                FunctionRetTy::Ty(ty) => this.lower_ty(&ty, ImplTraitContext::disallowed()),\n+                FunctionRetTy::Default(_) => this.arena.alloc(this.ty_tup(span, &[])),\n+            };\n+            let args = smallvec![GenericArg::Type(this.ty_tup(span, inputs))];\n+            let binding = hir::TypeBinding {\n+                hir_id: this.next_id(),\n+                ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n+                span: output_ty.span,\n+                kind: hir::TypeBindingKind::Equality { ty: output_ty },\n+            };\n+            (\n+                GenericArgsCtor { args, bindings: arena_vec![this; binding], parenthesized: true },\n+                false,\n+            )\n+        })\n+    }\n+}"}]}