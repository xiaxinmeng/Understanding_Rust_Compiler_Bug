{"sha": "cc47dc5c6e2502f554c465bef5a8f883139c0c4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNDdkYzVjNmUyNTAyZjU1NGM0NjViZWY1YThmODgzMTM5YzBjNGU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-08T16:54:29Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:04Z"}, "message": "rustc_metadata: store dense indexes in little-endian instead of big.", "tree": {"sha": "310acd45490eb2d1378046761d17a0555dd090a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/310acd45490eb2d1378046761d17a0555dd090a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc47dc5c6e2502f554c465bef5a8f883139c0c4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc47dc5c6e2502f554c465bef5a8f883139c0c4e", "html_url": "https://github.com/rust-lang/rust/commit/cc47dc5c6e2502f554c465bef5a8f883139c0c4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc47dc5c6e2502f554c465bef5a8f883139c0c4e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "html_url": "https://github.com/rust-lang/rust/commit/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719"}], "stats": {"total": 29, "additions": 10, "deletions": 19}, "files": [{"sha": "80d5141c99ca5568363407410db4d7e748afba09", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cc47dc5c6e2502f554c465bef5a8f883139c0c4e/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc47dc5c6e2502f554c465bef5a8f883139c0c4e/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=cc47dc5c6e2502f554c465bef5a8f883139c0c4e", "patch": "@@ -44,7 +44,7 @@ impl Index {\n         debug!(\"lookup_item: index={:?} words.len={:?}\",\n                index, words.len());\n \n-        let position = u32::from_be(words[index]);\n+        let position = u32::from_le(words[index]);\n         if position == u32::MAX {\n             debug!(\"lookup_item: position=u32::MAX\");\n             None\n@@ -61,7 +61,7 @@ impl Index {\n             if position == u32::MAX {\n                 None\n             } else {\n-                Some((DefIndex::new(index), u32::from_be(position)))\n+                Some((DefIndex::new(index), u32::from_le(position)))\n             }\n         })\n     }\n@@ -100,13 +100,11 @@ impl IndexData {\n                 \"recorded position for item {:?} twice, first at {:?} and now at {:?}\",\n                 item, self.positions[item], position);\n \n-        self.positions[item] = position;\n+        self.positions[item] = position.to_le();\n     }\n \n     pub fn write_index(&self, buf: &mut Cursor<Vec<u8>>) {\n-        for &position in &self.positions {\n-            write_be_u32(buf, position);\n-        }\n+        buf.write_all(words_to_bytes(&self.positions)).unwrap();\n     }\n }\n \n@@ -120,7 +118,7 @@ pub struct DenseIndex {\n impl DenseIndex {\n     pub fn lookup(&self, buf: &[u8], ix: u32) -> Option<u32> {\n         let data = bytes_to_words(&buf[self.start..self.end]);\n-        data.get(ix as usize).map(|d| u32::from_be(*d))\n+        data.get(ix as usize).map(|d| u32::from_le(*d))\n     }\n     pub fn from_buf(buf: &[u8], start: usize, end: usize) -> Self {\n         assert!((end-start)%4 == 0 && start <= end && end <= buf.len());\n@@ -135,23 +133,16 @@ pub fn write_dense_index(entries: Vec<u32>, buf: &mut Cursor<Vec<u8>>) {\n     let elen = entries.len();\n     assert!(elen < u32::MAX as usize);\n \n-    for entry in entries {\n-        write_be_u32(buf, entry);\n-    }\n+    buf.write_all(words_to_bytes(&entries)).unwrap();\n \n     info!(\"write_dense_index: {} entries\", elen);\n }\n \n-fn write_be_u32<W: Write>(w: &mut W, u: u32) {\n-    let _ = w.write_all(&[\n-        (u >> 24) as u8,\n-        (u >> 16) as u8,\n-        (u >>  8) as u8,\n-        (u >>  0) as u8,\n-    ]);\n-}\n-\n fn bytes_to_words(b: &[u8]) -> &[u32] {\n     assert!(b.len() % 4 == 0);\n     unsafe { slice::from_raw_parts(b.as_ptr() as *const u32, b.len()/4) }\n }\n+\n+fn words_to_bytes(w: &[u32]) -> &[u8] {\n+    unsafe { slice::from_raw_parts(w.as_ptr() as *const u8, w.len()*4) }\n+}"}]}