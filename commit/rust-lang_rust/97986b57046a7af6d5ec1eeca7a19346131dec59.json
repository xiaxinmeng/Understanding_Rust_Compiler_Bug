{"sha": "97986b57046a7af6d5ec1eeca7a19346131dec59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3OTg2YjU3MDQ2YTdhZjZkNWVjMWVlY2E3YTE5MzQ2MTMxZGVjNTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T12:49:32Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T17:57:05Z"}, "message": "typeck/pat.rs: some common imports.", "tree": {"sha": "d554dd59981f9a0b5a4ee3f992d872e358b455ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d554dd59981f9a0b5a4ee3f992d872e358b455ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97986b57046a7af6d5ec1eeca7a19346131dec59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97986b57046a7af6d5ec1eeca7a19346131dec59", "html_url": "https://github.com/rust-lang/rust/commit/97986b57046a7af6d5ec1eeca7a19346131dec59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97986b57046a7af6d5ec1eeca7a19346131dec59/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41e8aed3cfeabba102b1576db43871aa5f27eabd", "url": "https://api.github.com/repos/rust-lang/rust/commits/41e8aed3cfeabba102b1576db43871aa5f27eabd", "html_url": "https://github.com/rust-lang/rust/commit/41e8aed3cfeabba102b1576db43871aa5f27eabd"}], "stats": {"total": 81, "additions": 38, "deletions": 43}, "files": [{"sha": "1f6f7901c9e6e909b89d7f9fb075cff7fa8b7ea0", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/97986b57046a7af6d5ec1eeca7a19346131dec59/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97986b57046a7af6d5ec1eeca7a19346131dec59/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=97986b57046a7af6d5ec1eeca7a19346131dec59", "patch": "@@ -1,13 +1,13 @@\n use crate::check::FnCtxt;\n use crate::util::nodemap::FxHashMap;\n use errors::{Applicability, DiagnosticBuilder};\n-use rustc::hir::{self, PatKind, Pat};\n+use rustc::hir::{self, PatKind, Pat, HirId};\n use rustc::hir::def::{Res, DefKind, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::hir::ptr::P;\n use rustc::infer;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty, BindingMode, TypeFoldable};\n use rustc::ty::subst::Kind;\n use syntax::ast;\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -29,13 +29,8 @@ You can read more about trait objects in the Trait Objects section of the Refere\n https://doc.rust-lang.org/reference/types.html#trait-objects\";\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn check_pat_top(\n-        &self,\n-        pat: &'tcx hir::Pat,\n-        expected: Ty<'tcx>,\n-        discrim_span: Option<Span>,\n-    ) {\n-        let def_bm = ty::BindingMode::BindByValue(hir::Mutability::MutImmutable);\n+    pub fn check_pat_top(&self, pat: &'tcx Pat, expected: Ty<'tcx>, discrim_span: Option<Span>) {\n+        let def_bm = BindingMode::BindByValue(hir::Mutability::MutImmutable);\n         self.check_pat(pat, expected, def_bm, discrim_span);\n     }\n \n@@ -57,9 +52,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ```\n     fn check_pat(\n         &self,\n-        pat: &'tcx hir::Pat,\n+        pat: &'tcx Pat,\n         expected: Ty<'tcx>,\n-        def_bm: ty::BindingMode,\n+        def_bm: BindingMode,\n         discrim_span: Option<Span>,\n     ) {\n         debug!(\"check_pat(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n@@ -179,11 +174,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// as well as the pattern form we are currently checking.\n     fn calc_default_binding_mode(\n         &self,\n-        pat: &'tcx hir::Pat,\n+        pat: &'tcx Pat,\n         expected: Ty<'tcx>,\n-        def_bm: ty::BindingMode,\n+        def_bm: BindingMode,\n         is_non_ref_pat: bool,\n-    ) -> (Ty<'tcx>, ty::BindingMode) {\n+    ) -> (Ty<'tcx>, BindingMode) {\n         if is_non_ref_pat {\n             debug!(\"pattern is non reference pattern\");\n             self.peel_off_references(pat, expected, def_bm)\n@@ -209,7 +204,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Is the pattern a \"non reference pattern\"?\n     /// When the pattern is a path pattern, `opt_path_res` must be `Some(res)`.\n-    fn is_non_ref_pat(&self, pat: &'tcx hir::Pat, opt_path_res: Option<Res>) -> bool {\n+    fn is_non_ref_pat(&self, pat: &'tcx Pat, opt_path_res: Option<Res>) -> bool {\n         match pat.node {\n             PatKind::Struct(..) |\n             PatKind::TupleStruct(..) |\n@@ -242,10 +237,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// The adjustments vector, if non-empty is stored in a table.\n     fn peel_off_references(\n         &self,\n-        pat: &'tcx hir::Pat,\n+        pat: &'tcx Pat,\n         expected: Ty<'tcx>,\n-        mut def_bm: ty::BindingMode,\n-    ) -> (Ty<'tcx>, ty::BindingMode) {\n+        mut def_bm: BindingMode,\n+    ) -> (Ty<'tcx>, BindingMode) {\n         let mut expected = self.resolve_type_vars_with_obligations(&expected);\n \n         // Peel off as many `&` or `&mut` from the scrutinee type as possible. For example,\n@@ -403,18 +398,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_ident(\n         &self,\n-        pat: &hir::Pat,\n+        pat: &Pat,\n         ba: hir::BindingAnnotation,\n-        var_id: hir::HirId,\n-        sub: Option<&'tcx hir::Pat>,\n+        var_id: HirId,\n+        sub: Option<&'tcx Pat>,\n         expected: Ty<'tcx>,\n-        def_bm: ty::BindingMode,\n+        def_bm: BindingMode,\n         discrim_span: Option<Span>,\n     ) -> Ty<'tcx> {\n         // Determine the binding mode...\n         let bm = match ba {\n             hir::BindingAnnotation::Unannotated => def_bm,\n-            _ => ty::BindingMode::convert(ba),\n+            _ => BindingMode::convert(ba),\n         };\n         // ...and store it in a side table:\n         self.inh\n@@ -502,7 +497,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n+    pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat) -> bool {\n         if let PatKind::Binding(..) = inner.node {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n                 if let ty::Dynamic(..) = mt.ty.sty {\n@@ -530,12 +525,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_struct(\n         &self,\n-        pat: &'tcx hir::Pat,\n+        pat: &'tcx Pat,\n         qpath: &hir::QPath,\n         fields: &'tcx [hir::FieldPat],\n         etc: bool,\n         expected: Ty<'tcx>,\n-        def_bm: ty::BindingMode,\n+        def_bm: BindingMode,\n         discrim_span: Option<Span>,\n     ) -> Ty<'tcx> {\n         // Resolve the path and check the definition for errors.\n@@ -563,7 +558,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_path(\n         &self,\n-        pat: &hir::Pat,\n+        pat: &Pat,\n         path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment]),\n         qpath: &hir::QPath,\n         expected: Ty<'tcx>,\n@@ -596,12 +591,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_tuple_struct(\n         &self,\n-        pat: &hir::Pat,\n+        pat: &Pat,\n         qpath: &hir::QPath,\n-        subpats: &'tcx [P<hir::Pat>],\n+        subpats: &'tcx [P<Pat>],\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,\n-        def_bm: ty::BindingMode,\n+        def_bm: BindingMode,\n         match_arm_pat_span: Option<Span>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n@@ -700,10 +695,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_tuple(\n         &self,\n         span: Span,\n-        elements: &'tcx [P<hir::Pat>],\n+        elements: &'tcx [P<Pat>],\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,\n-        def_bm: ty::BindingMode,\n+        def_bm: BindingMode,\n         discrim_span: Option<Span>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n@@ -748,12 +743,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_struct_pat_fields(\n         &self,\n         adt_ty: Ty<'tcx>,\n-        pat_id: hir::HirId,\n+        pat_id: HirId,\n         span: Span,\n         variant: &'tcx ty::VariantDef,\n         fields: &'tcx [hir::FieldPat],\n         etc: bool,\n-        def_bm: ty::BindingMode,\n+        def_bm: BindingMode,\n     ) -> bool {\n         let tcx = self.tcx;\n \n@@ -922,9 +917,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_box(\n         &self,\n         span: Span,\n-        inner: &'tcx hir::Pat,\n+        inner: &'tcx Pat,\n         expected: Ty<'tcx>,\n-        def_bm: ty::BindingMode,\n+        def_bm: BindingMode,\n         discrim_span: Option<Span>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n@@ -948,11 +943,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_ref(\n         &self,\n-        pat: &hir::Pat,\n-        inner: &'tcx hir::Pat,\n+        pat: &Pat,\n+        inner: &'tcx Pat,\n         mutbl: hir::Mutability,\n         expected: Ty<'tcx>,\n-        def_bm: ty::BindingMode,\n+        def_bm: BindingMode,\n         discrim_span: Option<Span>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n@@ -1003,11 +998,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_slice(\n         &self,\n         span: Span,\n-        before: &'tcx [P<hir::Pat>],\n-        slice: Option<&'tcx hir::Pat>,\n-        after: &'tcx [P<hir::Pat>],\n+        before: &'tcx [P<Pat>],\n+        slice: Option<&'tcx Pat>,\n+        after: &'tcx [P<Pat>],\n         expected: Ty<'tcx>,\n-        def_bm: ty::BindingMode,\n+        def_bm: BindingMode,\n         discrim_span: Option<Span>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;"}]}