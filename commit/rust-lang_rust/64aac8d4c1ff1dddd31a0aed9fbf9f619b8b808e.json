{"sha": "64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0YWFjOGQ0YzFmZjFkZGRkMzFhMGFlZDlmYmY5ZjYxOWI4YjgwOGU=", "commit": {"author": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-10-31T14:16:46Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-13T11:28:43Z"}, "message": "Replace type params with bound vars in `rustc_traits::lowering`", "tree": {"sha": "d28fcfd3d1bbc5f0a3276aa55180637345938299", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d28fcfd3d1bbc5f0a3276aa55180637345938299"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e", "html_url": "https://github.com/rust-lang/rust/commit/64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "485397e49a02a3b7ff77c17e4a3f16c653925cb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/485397e49a02a3b7ff77c17e4a3f16c653925cb3", "html_url": "https://github.com/rust-lang/rust/commit/485397e49a02a3b7ff77c17e4a3f16c653925cb3"}], "stats": {"total": 204, "additions": 143, "deletions": 61}, "files": [{"sha": "c834166e67d881bdcae92e73212d9a982d9b37f9", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e", "patch": "@@ -687,7 +687,7 @@ define_queries! { <'tcx>\n         ) -> Clauses<'tcx>,\n \n         // Get the chalk-style environment of the given item.\n-        [] fn environment: Environment(DefId) -> traits::Environment<'tcx>,\n+        [] fn environment: Environment(DefId) -> ty::Binder<traits::Environment<'tcx>>,\n     },\n \n     Linking {"}, {"sha": "636014023e119cfcbb3dd2379dbfe1fd3066b348", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e", "patch": "@@ -179,6 +179,30 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         })\n     }\n \n+    pub fn bound_vars_for_item(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        def_id: DefId\n+    ) -> &'tcx Substs<'tcx> {\n+        Substs::for_item(tcx, def_id, |param, _| {\n+            match param.kind {\n+                ty::GenericParamDefKind::Type { .. } => {\n+                    tcx.mk_ty(ty::Bound(ty::BoundTy {\n+                        index: ty::INNERMOST,\n+                        var: ty::BoundVar::from(param.index),\n+                        kind: ty::BoundTyKind::Param(param.name),\n+                    })).into()\n+                }\n+\n+                ty::GenericParamDefKind::Lifetime => {\n+                    tcx.mk_region(ty::RegionKind::ReLateBound(\n+                        ty::INNERMOST,\n+                        ty::BoundRegion::BrNamed(param.def_id, param.name)\n+                    )).into()\n+                }\n+            }\n+        })\n+    }\n+\n     /// Creates a `Substs` for generic parameter definitions,\n     /// by calling closures to obtain each kind.\n     /// The closures get to observe the `Substs` as they're"}, {"sha": "c5dc91dec6bfecd6858b812d3f33eac16261d78b", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e", "patch": "@@ -88,12 +88,12 @@ impl ClauseVisitor<'set, 'a, 'tcx> {\n             ty::FnPtr(..) |\n             ty::Tuple(..) |\n             ty::Never |\n-            ty::Param(..) => (),\n+            ty::Infer(..) |\n+            ty::Bound(..) => (),\n \n             ty::GeneratorWitness(..) |\n             ty::UnnormalizedProjection(..) |\n-            ty::Infer(..) |\n-            ty::Bound(..) |\n+            ty::Param(..) |\n             ty::Error => {\n                 bug!(\"unexpected type {:?}\", ty);\n             }\n@@ -173,21 +173,28 @@ crate fn program_clauses_for_env<'a, 'tcx>(\n     );\n }\n \n-crate fn environment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Environment<'tcx> {\n+crate fn environment<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId\n+) -> ty::Binder<Environment<'tcx>> {\n     use super::{Lower, IntoFromEnvGoal};\n     use rustc::hir::{Node, TraitItemKind, ImplItemKind, ItemKind, ForeignItemKind};\n+    use rustc::ty::subst::{Subst, Substs};\n \n     // The environment of an impl Trait type is its defining function's environment.\n     if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n         return environment(tcx, parent);\n     }\n \n+    let bound_vars = Substs::bound_vars_for_item(tcx, def_id);\n+\n     // Compute the bounds on `Self` and the type parameters.\n-    let ty::InstantiatedPredicates { predicates } =\n-        tcx.predicates_of(def_id).instantiate_identity(tcx);\n+    let ty::InstantiatedPredicates { predicates } = tcx.predicates_of(def_id)\n+        .instantiate_identity(tcx);\n \n     let clauses = predicates.into_iter()\n         .map(|predicate| predicate.lower())\n+        .map(|predicate| predicate.subst(tcx, bound_vars))\n         .map(|domain_goal| domain_goal.map_bound(|bound| bound.into_from_env_goal()))\n         .map(|domain_goal| domain_goal.map_bound(|bound| bound.into_program_clause()))\n \n@@ -228,33 +235,43 @@ crate fn environment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> En\n \n     let mut input_tys = FxHashSet::default();\n \n-    // In an impl, we assume that the receiver type and all its constituents\n+    // In an impl, we assume that the header trait ref and all its constituents\n     // are well-formed.\n     if is_impl {\n-        let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n-        input_tys.extend(trait_ref.self_ty().walk());\n+        let trait_ref = tcx.impl_trait_ref(def_id)\n+            .expect(\"not an impl\")\n+            .subst(tcx, bound_vars);\n+\n+        input_tys.extend(\n+            trait_ref.substs.types().flat_map(|ty| ty.walk())\n+        );\n     }\n \n     // In an fn, we assume that the arguments and all their constituents are\n     // well-formed.\n     if is_fn {\n-        let fn_sig = tcx.fn_sig(def_id);\n+        // `skip_binder` because we move late bound regions to the root binder,\n+        // restored in the return type\n+        let fn_sig = tcx.fn_sig(def_id).skip_binder().subst(tcx, bound_vars);\n+\n         input_tys.extend(\n-            // FIXME: `skip_binder` seems ok for now? In a real setting,\n-            // the late bound regions would next be instantiated with things\n-            // in the inference table.\n-            fn_sig.skip_binder().inputs().iter().flat_map(|ty| ty.walk())\n+            fn_sig.inputs().iter().flat_map(|ty| ty.walk())\n         );\n     }\n \n     let clauses = clauses.chain(\n         input_tys.into_iter()\n+            // Filter out type parameters\n+            .filter(|ty| match ty.sty {\n+                ty::Bound(..) => false,\n+                _ => true,\n+            })\n             .map(|ty| DomainGoal::FromEnv(FromEnv::Ty(ty)))\n             .map(|domain_goal| domain_goal.into_program_clause())\n             .map(Clause::Implies)\n     );\n \n-    Environment {\n+    ty::Binder::bind(Environment {\n         clauses: tcx.mk_clauses(clauses),\n-    }\n+    })\n }"}, {"sha": "fc25faed3def88f8209a2fd319ae25761345b99e", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 85, "deletions": 44, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=64aac8d4c1ff1dddd31a0aed9fbf9f619b8b808e", "patch": "@@ -28,6 +28,7 @@ use rustc::traits::{\n };\n use rustc::ty::query::Providers;\n use rustc::ty::{self, List, TyCtxt};\n+use rustc::ty::subst::{Subst, Substs};\n use syntax::ast;\n \n use std::iter;\n@@ -189,9 +190,14 @@ fn program_clauses_for_trait<'a, 'tcx>(\n     // }\n     // ```\n \n+    let bound_vars = Substs::bound_vars_for_item(tcx, def_id);\n+\n     // `Self: Trait<P1..Pn>`\n     let trait_pred = ty::TraitPredicate {\n-        trait_ref: ty::TraitRef::identity(tcx, def_id),\n+        trait_ref: ty::TraitRef {\n+            def_id,\n+            substs: bound_vars,\n+        },\n     };\n \n     // `Implemented(Self: Trait<P1..Pn>)`\n@@ -208,11 +214,12 @@ fn program_clauses_for_trait<'a, 'tcx>(\n         category: ProgramClauseCategory::ImpliedBound,\n     };\n \n-    let clauses = iter::once(Clause::ForAll(ty::Binder::dummy(implemented_from_env)));\n+    let implemented_from_env = Clause::ForAll(ty::Binder::bind(implemented_from_env));\n \n     let where_clauses = &tcx.predicates_defined_on(def_id).predicates\n         .into_iter()\n         .map(|(wc, _)| wc.lower())\n+        .map(|wc| wc.subst(tcx, bound_vars))\n         .collect::<Vec<_>>();\n \n     // Rule Implied-Bound-From-Trait\n@@ -230,11 +237,21 @@ fn program_clauses_for_trait<'a, 'tcx>(\n         .cloned()\n \n         // `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`\n-        .map(|wc| wc.map_bound(|goal| ProgramClause {\n-            goal: goal.into_from_env_goal(),\n-            hypotheses,\n-            category: ProgramClauseCategory::ImpliedBound,\n-        }))\n+        .map(|wc| {\n+            // we move binders to the left\n+            wc.map_bound(|goal| ProgramClause {\n+                goal: goal.into_from_env_goal(),\n+\n+                // FIXME: As where clauses can only bind lifetimes for now,\n+                // and that named bound regions have a def-id, it is safe\n+                // to just inject `hypotheses` (which contains named vars bound at index `0`)\n+                // into this binding level. This may change if we ever allow where clauses\n+                // to bind types (e.g. for GATs things).\n+                hypotheses,\n+\n+                category: ProgramClauseCategory::ImpliedBound,\n+            })\n+        })\n         .map(Clause::ForAll);\n \n     // Rule WellFormed-TraitRef\n@@ -246,28 +263,27 @@ fn program_clauses_for_trait<'a, 'tcx>(\n     // }\n     // ```\n \n-    // `Implemented(Self: Trait<P1..Pn>) && WellFormed(WC)`\n-    let wf_conditions = iter::once(ty::Binder::dummy(trait_pred.lower()))\n-        .chain(\n-            where_clauses\n-                .into_iter()\n-                .map(|wc| wc.map_bound(|goal| goal.into_well_formed_goal()))\n-        );\n+    // `WellFormed(WC)`\n+    let wf_conditions = where_clauses\n+        .into_iter()\n+        .map(|wc| wc.map_bound(|goal| goal.into_well_formed_goal()));\n \n     // `WellFormed(Self: Trait<P1..Pn>) :- Implemented(Self: Trait<P1..Pn>) && WellFormed(WC)`\n     let wf_clause = ProgramClause {\n         goal: DomainGoal::WellFormed(WellFormed::Trait(trait_pred)),\n         hypotheses: tcx.mk_goals(\n-            wf_conditions.map(|wc| tcx.mk_goal(GoalKind::from_poly_domain_goal(wc, tcx))),\n+            iter::once(tcx.mk_goal(GoalKind::DomainGoal(impl_trait))).chain(\n+                wf_conditions.map(|wc| tcx.mk_goal(GoalKind::from_poly_domain_goal(wc, tcx)))\n+            )\n         ),\n         category: ProgramClauseCategory::WellFormed,\n     };\n-    let wf_clause = iter::once(Clause::ForAll(ty::Binder::dummy(wf_clause)));\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n \n     tcx.mk_clauses(\n-        clauses\n+        iter::once(implemented_from_env)\n             .chain(implied_bound_clauses)\n-            .chain(wf_clause)\n+            .chain(iter::once(wf_clause))\n     )\n }\n \n@@ -286,15 +302,20 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n     // }\n     // ```\n \n-    let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n+    let bound_vars = Substs::bound_vars_for_item(tcx, def_id);\n+\n+    let trait_ref = tcx.impl_trait_ref(def_id)\n+        .expect(\"not an impl\")\n+        .subst(tcx, bound_vars);\n \n     // `Implemented(A0: Trait<A1..An>)`\n     let trait_pred = ty::TraitPredicate { trait_ref }.lower();\n \n     // `WC`\n     let where_clauses = tcx.predicates_of(def_id).predicates\n         .into_iter()\n-        .map(|(wc, _)| wc.lower());\n+        .map(|(wc, _)| wc.lower())\n+        .map(|wc| wc.subst(tcx, bound_vars));\n \n     // `Implemented(A0: Trait<A1..An>) :- WC`\n     let clause = ProgramClause {\n@@ -305,7 +326,7 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n         ),\n         category: ProgramClauseCategory::Other,\n     };\n-    tcx.mk_clauses(iter::once(Clause::ForAll(ty::Binder::dummy(clause))))\n+    tcx.mk_clauses(iter::once(Clause::ForAll(ty::Binder::bind(clause))))\n }\n \n pub fn program_clauses_for_type_def<'a, 'tcx>(\n@@ -322,17 +343,20 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n     // }\n     // ```\n \n+    let bound_vars = Substs::bound_vars_for_item(tcx, def_id);\n+\n     // `Ty<...>`\n-    let ty = tcx.type_of(def_id);\n+    let ty = tcx.type_of(def_id).subst(tcx, bound_vars);\n \n     // `WC`\n     let where_clauses = tcx.predicates_of(def_id).predicates\n         .into_iter()\n         .map(|(wc, _)| wc.lower())\n+        .map(|wc| wc.subst(tcx, bound_vars))\n         .collect::<Vec<_>>();\n \n     // `WellFormed(Ty<...>) :- WC1, ..., WCm`\n-    let well_formed = ProgramClause {\n+    let well_formed_clause = ProgramClause {\n         goal: DomainGoal::WellFormed(WellFormed::Ty(ty)),\n         hypotheses: tcx.mk_goals(\n             where_clauses\n@@ -342,8 +366,7 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n         ),\n         category: ProgramClauseCategory::WellFormed,\n     };\n-\n-    let well_formed_clause = iter::once(Clause::ForAll(ty::Binder::dummy(well_formed)));\n+    let well_formed_clause = Clause::ForAll(ty::Binder::bind(well_formed_clause));\n \n     // Rule FromEnv-Type\n     //\n@@ -363,15 +386,23 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n         .into_iter()\n \n         // `FromEnv(WC) :- FromEnv(Ty<...>)`\n-        .map(|wc| wc.map_bound(|goal| ProgramClause {\n-            goal: goal.into_from_env_goal(),\n-            hypotheses,\n-            category: ProgramClauseCategory::ImpliedBound,\n-        }))\n+        .map(|wc| {\n+            // move the binders to the left\n+            wc.map_bound(|goal| ProgramClause {\n+                goal: goal.into_from_env_goal(),\n+\n+                // FIXME: we inject `hypotheses` into this binding level,\n+                // which may be incorrect in the future: see the FIXME in\n+                // `program_clauses_for_trait`\n+                hypotheses,\n+\n+                category: ProgramClauseCategory::ImpliedBound,\n+            })\n+        })\n \n         .map(Clause::ForAll);\n \n-    tcx.mk_clauses(well_formed_clause.chain(from_env_clauses))\n+    tcx.mk_clauses(iter::once(well_formed_clause).chain(from_env_clauses))\n }\n \n pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n@@ -403,7 +434,12 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n         ty::AssociatedItemContainer::TraitContainer(trait_id) => trait_id,\n         _ => bug!(\"not an trait container\"),\n     };\n-    let trait_ref = ty::TraitRef::identity(tcx, trait_id);\n+\n+    let trait_bound_vars = Substs::bound_vars_for_item(tcx, trait_id);\n+    let trait_ref = ty::TraitRef {\n+        def_id: trait_id,\n+        substs: trait_bound_vars,\n+    };\n \n     let projection_ty = ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, item.ident);\n     let placeholder_ty = tcx.mk_ty(ty::UnnormalizedProjection(projection_ty));\n@@ -417,6 +453,7 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n         hypotheses: ty::List::empty(),\n         category: ProgramClauseCategory::Other,\n     };\n+    let projection_eq_clause = Clause::ForAll(ty::Binder::bind(projection_eq_clause));\n \n     // Rule WellFormed-AssocTy\n     // ```\n@@ -430,11 +467,13 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n     let hypothesis = tcx.mk_goal(\n         DomainGoal::Holds(WhereClause::Implemented(trait_predicate)).into_goal()\n     );\n+\n     let wf_clause = ProgramClause {\n         goal: DomainGoal::WellFormed(WellFormed::Ty(placeholder_ty)),\n         hypotheses: tcx.mk_goals(iter::once(hypothesis)),\n         category: ProgramClauseCategory::WellFormed,\n     };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n \n     // Rule Implied-Trait-From-AssocTy\n     // ```\n@@ -447,16 +486,17 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n     let hypothesis = tcx.mk_goal(\n         DomainGoal::FromEnv(FromEnv::Ty(placeholder_ty)).into_goal()\n     );\n+\n     let from_env_clause = ProgramClause {\n         goal: DomainGoal::FromEnv(FromEnv::Trait(trait_predicate)),\n         hypotheses: tcx.mk_goals(iter::once(hypothesis)),\n         category: ProgramClauseCategory::ImpliedBound,\n     };\n+    let from_env_clause = Clause::ForAll(ty::Binder::bind(from_env_clause));\n \n     let clauses = iter::once(projection_eq_clause)\n         .chain(iter::once(wf_clause))\n         .chain(iter::once(from_env_clause));\n-    let clauses = clauses.map(|clause| Clause::ForAll(ty::Binder::dummy(clause)));\n     tcx.mk_clauses(clauses)\n }\n \n@@ -490,17 +530,18 @@ pub fn program_clauses_for_associated_type_value<'a, 'tcx>(\n         _ => bug!(\"not an impl container\"),\n     };\n \n+    let impl_bound_vars = Substs::bound_vars_for_item(tcx, impl_id);\n+\n     // `A0 as Trait<A1..An>`\n-    let trait_ref = tcx.impl_trait_ref(impl_id).unwrap();\n+    let trait_ref = tcx.impl_trait_ref(impl_id)\n+        .unwrap()\n+        .subst(tcx, impl_bound_vars);\n \n     // `T`\n     let ty = tcx.type_of(item_id);\n \n     // `Implemented(A0: Trait<A1..An>)`\n-    let trait_implemented = ty::Binder::dummy(ty::TraitPredicate { trait_ref }.lower());\n-\n-    // `Implemented(A0: Trait<A1..An>)`\n-    let hypotheses = vec![trait_implemented];\n+    let trait_implemented: DomainGoal = ty::TraitPredicate { trait_ref }.lower();\n \n     // `<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm>`\n     let projection_ty = ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, item.ident);\n@@ -509,16 +550,16 @@ pub fn program_clauses_for_associated_type_value<'a, 'tcx>(\n     let normalize_goal = DomainGoal::Normalize(ty::ProjectionPredicate { projection_ty, ty });\n \n     // `Normalize(... -> T) :- ...`\n-    let clause = ProgramClause {\n+    let normalize_clause = ProgramClause {\n         goal: normalize_goal,\n         hypotheses: tcx.mk_goals(\n-            hypotheses\n-                .into_iter()\n-                .map(|wc| tcx.mk_goal(GoalKind::from_poly_domain_goal(wc, tcx))),\n+            iter::once(tcx.mk_goal(GoalKind::DomainGoal(trait_implemented)))\n         ),\n         category: ProgramClauseCategory::Other,\n     };\n-    tcx.mk_clauses(iter::once(Clause::ForAll(ty::Binder::dummy(clause))))\n+    let normalize_clause = Clause::ForAll(ty::Binder::bind(normalize_clause));\n+\n+    tcx.mk_clauses(iter::once(normalize_clause))\n }\n \n pub fn dump_program_clauses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -548,7 +589,7 @@ impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n \n             if attr.check_name(\"rustc_dump_env_program_clauses\") {\n                 let environment = self.tcx.environment(def_id);\n-                clauses = Some(self.tcx.program_clauses_for_env(environment));\n+                clauses = Some(self.tcx.program_clauses_for_env(*environment.skip_binder()));\n             }\n \n             if let Some(clauses) = clauses {"}]}