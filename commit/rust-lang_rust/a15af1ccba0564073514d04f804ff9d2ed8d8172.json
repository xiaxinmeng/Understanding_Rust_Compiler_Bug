{"sha": "a15af1ccba0564073514d04f804ff9d2ed8d8172", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNWFmMWNjYmEwNTY0MDczNTE0ZDA0ZjgwNGZmOWQyZWQ4ZDgxNzI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-01-02T12:37:56Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-01-02T12:39:02Z"}, "message": "Rename load_value to load_scalar and make it support all Abi::Scalar types", "tree": {"sha": "a49ce6d2d97eb777914240f21e035242a6dae64f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a49ce6d2d97eb777914240f21e035242a6dae64f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a15af1ccba0564073514d04f804ff9d2ed8d8172", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a15af1ccba0564073514d04f804ff9d2ed8d8172", "html_url": "https://github.com/rust-lang/rust/commit/a15af1ccba0564073514d04f804ff9d2ed8d8172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a15af1ccba0564073514d04f804ff9d2ed8d8172/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7101bbfd478cc63d867297190d4c7c8859a1058", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7101bbfd478cc63d867297190d4c7c8859a1058", "html_url": "https://github.com/rust-lang/rust/commit/c7101bbfd478cc63d867297190d4c7c8859a1058"}], "stats": {"total": 99, "additions": 57, "deletions": 42}, "files": [{"sha": "d3bf41e79951e97c4765c884b85ba6ad9158bf66", "filename": "src/abi.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a15af1ccba0564073514d04f804ff9d2ed8d8172/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15af1ccba0564073514d04f804ff9d2ed8d8172/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=a15af1ccba0564073514d04f804ff9d2ed8d8172", "patch": "@@ -2,6 +2,7 @@ use std::borrow::Cow;\n use std::iter;\n \n use rustc::hir;\n+use rustc::ty::layout::{Scalar, Primitive, Integer, FloatTy};\n use rustc_target::spec::abi::Abi;\n \n use crate::prelude::*;\n@@ -23,6 +24,23 @@ impl PassMode {\n     }\n }\n \n+pub fn scalar_to_clif_type(tcx: TyCtxt, scalar: Scalar) -> Type {\n+    match scalar.value {\n+        Primitive::Int(int, _sign) => match int {\n+            Integer::I8 => types::I8,\n+            Integer::I16 => types::I16,\n+            Integer::I32 => types::I32,\n+            Integer::I64 => types::I64,\n+            Integer::I128 => unimpl!(\"u/i128\"),\n+        }\n+        Primitive::Float(flt) => match flt {\n+            FloatTy::F32 => types::F32,\n+            FloatTy::F64 => types::F64,\n+        }\n+        Primitive::Pointer => pointer_ty(tcx),\n+    }\n+}\n+\n fn get_pass_mode<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     abi: Abi,\n@@ -66,7 +84,7 @@ fn adjust_arg_for_abi<'a, 'tcx: 'a>(\n ) -> Value {\n     match get_pass_mode(fx.tcx, sig.abi, arg.layout().ty, false) {\n         PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n-        PassMode::ByVal(_) => arg.load_value(fx),\n+        PassMode::ByVal(_) => arg.load_scalar(fx),\n         PassMode::ByRef => arg.force_stack(fx),\n     }\n }\n@@ -251,7 +269,7 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n             .map(|arg| {\n                 (\n                     self.clif_type(arg.layout().ty).unwrap(),\n-                    arg.load_value(self),\n+                    arg.load_scalar(self),\n                 )\n             })\n             .unzip();\n@@ -441,13 +459,16 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n             let null = fx.bcx.ins().iconst(fx.pointer_type, 0);\n             fx.local_map.insert(\n                 RETURN_PLACE,\n-                CPlace::Addr(null, None, fx.layout_of(fx.return_type())),\n+                CPlace::Addr(null, None, ret_layout),\n             );\n         }\n-        PassMode::ByVal(ret_ty) => {\n-            fx.bcx.declare_var(mir_var(RETURN_PLACE), ret_ty);\n-            fx.local_map\n-                .insert(RETURN_PLACE, CPlace::Var(RETURN_PLACE, ret_layout));\n+        PassMode::ByVal(_) => {\n+            let is_ssa = !ssa_analyzed\n+                .get(&RETURN_PLACE)\n+                .unwrap()\n+                .contains(crate::analyze::Flags::NOT_SSA);\n+\n+            local_place(fx, RETURN_PLACE, ret_layout, is_ssa);\n         }\n         PassMode::ByRef => {\n             fx.local_map.insert(\n@@ -613,7 +634,7 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n         } else {\n             func_ref = if instance.is_none() {\n                 let func = trans_operand(fx, func.expect(\"indirect call without func Operand\"));\n-                Some(func.load_value(fx))\n+                Some(func.load_scalar(fx))\n             } else {\n                 None\n             };\n@@ -660,7 +681,7 @@ pub fn codegen_return(fx: &mut FunctionCx<impl Backend>) {\n         }\n         PassMode::ByVal(_) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n-            let ret_val = place.to_cvalue(fx).load_value(fx);\n+            let ret_val = place.to_cvalue(fx).load_scalar(fx);\n             fx.bcx.ins().return_(&[ret_val]);\n         }\n     }"}, {"sha": "f780a86515a9da713c8daa1b60b961a5a2fdd46d", "filename": "src/base.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a15af1ccba0564073514d04f804ff9d2ed8d8172/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15af1ccba0564073514d04f804ff9d2ed8d8172/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=a15af1ccba0564073514d04f804ff9d2ed8d8172", "patch": "@@ -184,7 +184,7 @@ fn codegen_fn_content<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx, impl Backend>)\n                 target,\n                 cleanup: _,\n             } => {\n-                let cond = trans_operand(fx, cond).load_value(fx);\n+                let cond = trans_operand(fx, cond).load_scalar(fx);\n                 // TODO HACK brz/brnz for i8/i16 is not yet implemented\n                 let cond = fx.bcx.ins().uextend(types::I32, cond);\n                 let target = fx.get_ebb(*target);\n@@ -202,7 +202,7 @@ fn codegen_fn_content<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx, impl Backend>)\n                 values,\n                 targets,\n             } => {\n-                let discr = trans_operand(fx, discr).load_value(fx);\n+                let discr = trans_operand(fx, discr).load_scalar(fx);\n                 let mut switch = ::cranelift::frontend::Switch::new();\n                 for (i, value) in values.iter().enumerate() {\n                     let ebb = fx.get_ebb(targets[i]);\n@@ -430,7 +430,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                 Rvalue::UnaryOp(un_op, operand) => {\n                     let operand = trans_operand(fx, operand);\n                     let layout = operand.layout();\n-                    let val = operand.load_value(fx);\n+                    let val = operand.load_scalar(fx);\n                     let res = match un_op {\n                         UnOp::Not => {\n                             match layout.ty.sty {\n@@ -492,7 +492,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                         | (ty::Uint(_), ty::Char)\n                         | (ty::Uint(_), ty::Int(_))\n                         | (ty::Uint(_), ty::Uint(_)) => {\n-                            let from = operand.load_value(fx);\n+                            let from = operand.load_scalar(fx);\n                             let res = crate::common::clif_intcast(\n                                 fx,\n                                 from,\n@@ -502,7 +502,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                             lval.write_cvalue(fx, CValue::ByVal(res, dest_layout));\n                         }\n                         (ty::Int(_), ty::Int(_)) | (ty::Int(_), ty::Uint(_)) => {\n-                            let from = operand.load_value(fx);\n+                            let from = operand.load_scalar(fx);\n                             let res = crate::common::clif_intcast(\n                                 fx,\n                                 from,\n@@ -512,7 +512,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                             lval.write_cvalue(fx, CValue::ByVal(res, dest_layout));\n                         }\n                         (ty::Float(from_flt), ty::Float(to_flt)) => {\n-                            let from = operand.load_value(fx);\n+                            let from = operand.load_scalar(fx);\n                             let res = match (from_flt, to_flt) {\n                                 (FloatTy::F32, FloatTy::F64) => {\n                                     fx.bcx.ins().fpromote(types::F64, from)\n@@ -526,7 +526,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                         }\n                         (ty::Int(_), ty::Float(_)) => {\n                             let from_ty = fx.clif_type(from_ty).unwrap();\n-                            let from = operand.load_value(fx);\n+                            let from = operand.load_scalar(fx);\n                             // FIXME missing encoding for fcvt_from_sint.f32.i8\n                             let from = if from_ty == types::I8 || from_ty == types::I16 {\n                                 fx.bcx.ins().sextend(types::I32, from)\n@@ -539,7 +539,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                         }\n                         (ty::Uint(_), ty::Float(_)) => {\n                             let from_ty = fx.clif_type(from_ty).unwrap();\n-                            let from = operand.load_value(fx);\n+                            let from = operand.load_scalar(fx);\n                             // FIXME missing encoding for fcvt_from_uint.f32.i8\n                             let from = if from_ty == types::I8 || from_ty == types::I16 {\n                                 fx.bcx.ins().uextend(types::I32, from)\n@@ -552,7 +552,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                         }\n                         (ty::Bool, ty::Uint(_)) | (ty::Bool, ty::Int(_)) => {\n                             let to_ty = fx.clif_type(to_ty).unwrap();\n-                            let from = operand.load_value(fx);\n+                            let from = operand.load_scalar(fx);\n                             let res = if to_ty != types::I8 {\n                                 fx.bcx.ins().uextend(to_ty, from)\n                             } else {\n@@ -695,7 +695,7 @@ pub fn trans_get_discriminant<'a, 'tcx: 'a>(\n \n     let discr = value.value_field(fx, mir::Field::new(0));\n     let discr_ty = discr.layout().ty;\n-    let lldiscr = discr.load_value(fx);\n+    let lldiscr = discr.load_scalar(fx);\n     match layout.variants {\n         layout::Variants::Single { .. } => bug!(),\n         layout::Variants::Tagged { ref tag, .. } => {\n@@ -782,8 +782,8 @@ macro_rules! binop_match {\n             $var:ident ($sign:pat) $name:tt $( ( $($next:tt)* ) )? ;\n         )*\n     ) => {{\n-        let lhs = $lhs.load_value($fx);\n-        let rhs = $rhs.load_value($fx);\n+        let lhs = $lhs.load_scalar($fx);\n+        let rhs = $rhs.load_scalar($fx);\n         match ($bin_op, $signed) {\n             $(\n                 (BinOp::$var, $sign) => binop_match!(@single $fx, $bug_fmt, $var, $signed, lhs, rhs, $ret_ty, $name $( ( $($next)* ) )?),\n@@ -887,8 +887,8 @@ pub fn trans_checked_int_binop<'a, 'tcx: 'a>(\n         );\n     }\n \n-    let lhs = in_lhs.load_value(fx);\n-    let rhs = in_rhs.load_value(fx);\n+    let lhs = in_lhs.load_scalar(fx);\n+    let rhs = in_rhs.load_scalar(fx);\n     let res = match bin_op {\n         BinOp::Add => fx.bcx.ins().iadd(lhs, rhs),\n         BinOp::Sub => fx.bcx.ins().isub(lhs, rhs),\n@@ -1060,7 +1060,7 @@ pub fn trans_place<'a, 'tcx: 'a>(\n                 ProjectionElem::Deref => base.place_deref(fx),\n                 ProjectionElem::Field(field, _ty) => base.place_field(fx, field),\n                 ProjectionElem::Index(local) => {\n-                    let index = fx.get_local_place(local).to_cvalue(fx).load_value(fx);\n+                    let index = fx.get_local_place(local).to_cvalue(fx).load_scalar(fx);\n                     base.place_index(fx, index)\n                 }\n                 ProjectionElem::ConstantIndex {"}, {"sha": "dad252d008ab438b3a715063466070b6ccd30978", "filename": "src/common.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a15af1ccba0564073514d04f804ff9d2ed8d8172/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15af1ccba0564073514d04f804ff9d2ed8d8172/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=a15af1ccba0564073514d04f804ff9d2ed8d8172", "patch": "@@ -151,24 +151,18 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n-    pub fn load_value<'a>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> Value\n+    /// Load a value with layout.abi of scalar\n+    pub fn load_scalar<'a>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> Value\n     where\n         'tcx: 'a,\n     {\n         match self {\n             CValue::ByRef(addr, layout) => {\n-                let clif_ty = fx.clif_type(layout.ty).unwrap_or_else(|| {\n-                    if layout.ty.is_box()\n-                        && !fx\n-                            .layout_of(layout.ty.builtin_deref(true).unwrap().ty)\n-                            .is_unsized()\n-                    {\n-                        // Consider sized box to be a ptr\n-                        pointer_ty(fx.tcx)\n-                    } else {\n-                        panic!(\"load_value of type {:?}\", layout.ty);\n-                    }\n-                });\n+                let scalar = match layout.abi {\n+                    layout::Abi::Scalar(ref scalar) => scalar.clone(),\n+                    _ => unreachable!(),\n+                };\n+                let clif_ty = crate::abi::scalar_to_clif_type(fx.tcx, scalar);\n                 fx.bcx.ins().load(clif_ty, MemFlags::new(), addr, 0)\n             }\n             CValue::ByVal(value, _layout) => value,\n@@ -355,7 +349,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n \n         match self {\n             CPlace::Var(var, _) => {\n-                let data = from.load_value(fx);\n+                let data = from.load_scalar(fx);\n                 fx.bcx.def_var(mir_var(var), data)\n             }\n             CPlace::Addr(addr, None, dst_layout) => {\n@@ -454,7 +448,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n     pub fn place_deref(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> CPlace<'tcx> {\n         let inner_layout = fx.layout_of(self.layout().ty.builtin_deref(true).unwrap().ty);\n         if !inner_layout.is_unsized() {\n-            CPlace::Addr(self.to_cvalue(fx).load_value(fx), None, inner_layout)\n+            CPlace::Addr(self.to_cvalue(fx).load_scalar(fx), None, inner_layout)\n         } else {\n             match self.layout().abi {\n                 Abi::ScalarPair(ref a, ref b) => {"}, {"sha": "a487012f96a550e8c337a20725ec1d5e10529b9c", "filename": "src/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a15af1ccba0564073514d04f804ff9d2ed8d8172/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15af1ccba0564073514d04f804ff9d2ed8d8172/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=a15af1ccba0564073514d04f804ff9d2ed8d8172", "patch": "@@ -14,7 +14,7 @@ macro_rules! intrinsic_arg {\n         $arg\n     };\n     (v $fx:expr, $arg:ident) => {\n-        $arg.load_value($fx)\n+        $arg.load_scalar($fx)\n     };\n }\n \n@@ -358,7 +358,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n         _ if intrinsic.starts_with(\"atomic_load\"), (c ptr) {\n             let inner_layout =\n                 fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n-            let val = CValue::ByRef(ptr.load_value(fx), inner_layout);\n+            let val = CValue::ByRef(ptr.load_scalar(fx), inner_layout);\n             ret.write_cvalue(fx, val);\n         };\n         _ if intrinsic.starts_with(\"atomic_store\"), (v ptr, c val) {"}, {"sha": "6837754a5524611e77fd16d6855b54cac98ab694", "filename": "src/unsize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a15af1ccba0564073514d04f804ff9d2ed8d8172/src%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15af1ccba0564073514d04f804ff9d2ed8d8172/src%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsize.rs?ref=a15af1ccba0564073514d04f804ff9d2ed8d8172", "patch": "@@ -97,7 +97,7 @@ pub fn coerce_unsized_into<'a, 'tcx: 'a>(\n             // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n             src.load_value_pair(fx)\n         } else {\n-            let base = src.load_value(fx);\n+            let base = src.load_scalar(fx);\n             unsize_thin_ptr(fx, base, src_ty, dst_ty)\n         };\n         dst.write_cvalue(fx, CValue::ByValPair(base, info, dst.layout()));"}]}