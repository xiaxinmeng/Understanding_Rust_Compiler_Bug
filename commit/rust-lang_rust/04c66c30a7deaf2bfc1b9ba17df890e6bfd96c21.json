{"sha": "04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0YzY2YzMwYTdkZWFmMmJmYzFiOWJhMTdkZjg5MGU2YmZkOTZjMjE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-22T04:47:07Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-22T04:47:07Z"}, "message": "Merge remote-tracking branch 'origin/master' into gen", "tree": {"sha": "93f5bb912c970bbab28cbc1fe2d29361423648dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93f5bb912c970bbab28cbc1fe2d29361423648dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "html_url": "https://github.com/rust-lang/rust/commit/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dc9d71521b80f6302d58d43a283efa92285871e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dc9d71521b80f6302d58d43a283efa92285871e", "html_url": "https://github.com/rust-lang/rust/commit/5dc9d71521b80f6302d58d43a283efa92285871e"}, {"sha": "942711e115834ea2b4d91e1b3d3ae84b69cad670", "url": "https://api.github.com/repos/rust-lang/rust/commits/942711e115834ea2b4d91e1b3d3ae84b69cad670", "html_url": "https://github.com/rust-lang/rust/commit/942711e115834ea2b4d91e1b3d3ae84b69cad670"}], "stats": {"total": 735, "additions": 667, "deletions": 68}, "files": [{"sha": "4b7706bac300fe4b1a1ebd1316c01cbb7d75d7bc", "filename": "src/libcore/array.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -124,6 +124,7 @@ macro_rules! array_impls {\n             }\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             impl<T:Copy> Clone for [T; $N] {\n                 fn clone(&self) -> [T; $N] {\n                     *self"}, {"sha": "2dc51718b97b23e0e0a7a491dd091f340585efbb", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -88,6 +88,7 @@\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(stage0), lang = \"clone\")]\n pub trait Clone : Sized {\n     /// Returns a copy of the value.\n     ///\n@@ -131,6 +132,7 @@ pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: ::marker::PhantomData\n pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: ::marker::PhantomData<T> }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n impl<'a, T: ?Sized> Clone for &'a T {\n     /// Returns a shallow copy of the reference.\n     #[inline]\n@@ -140,6 +142,7 @@ impl<'a, T: ?Sized> Clone for &'a T {\n macro_rules! clone_impl {\n     ($t:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(stage0)]\n         impl Clone for $t {\n             /// Returns a deep copy of the value.\n             #[inline]"}, {"sha": "63e9373e936068cc2085e6f8750abfbdcf9159ec", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -876,6 +876,7 @@ pub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n impl<T: ?Sized> Clone for *const T {\n     #[inline]\n     fn clone(&self) -> *const T {\n@@ -884,6 +885,7 @@ impl<T: ?Sized> Clone for *const T {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n impl<T: ?Sized> Clone for *mut T {\n     #[inline]\n     fn clone(&self) -> *mut T {\n@@ -895,6 +897,7 @@ impl<T: ?Sized> Clone for *mut T {\n macro_rules! fnptr_impls_safety_abi {\n     ($FnTy: ty, $($Arg: ident),*) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(stage0)]\n         impl<Ret, $($Arg),*> Clone for $FnTy {\n             #[inline]\n             fn clone(&self) -> Self {"}, {"sha": "555843dba418ecaeebb88d3c36015865edfb46fd", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -22,6 +22,7 @@ macro_rules! tuple_impls {\n     )+) => {\n         $(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             impl<$($T:Clone),+> Clone for ($($T,)+) {\n                 fn clone(&self) -> ($($T,)+) {\n                     ($(self.$idx.clone(),)+)"}, {"sha": "c9e3c8cc3e0cadb90f585ecc2bef051f72c9b369", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -677,6 +677,10 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::In\n                 def_id.hash_stable(hcx, hasher);\n                 t.hash_stable(hcx, hasher);\n             }\n+            ty::InstanceDef::CloneShim(def_id, t) => {\n+                def_id.hash_stable(hcx, hasher);\n+                t.hash_stable(hcx, hasher);\n+            }\n         }\n     }\n }"}, {"sha": "ae3e3a30f371ebb85d1229270491e436c005222e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -274,6 +274,7 @@ language_item_table! {\n     SizedTraitLangItem,              \"sized\",                   sized_trait;\n     UnsizeTraitLangItem,             \"unsize\",                  unsize_trait;\n     CopyTraitLangItem,               \"copy\",                    copy_trait;\n+    CloneTraitLangItem,              \"clone\",                   clone_trait;\n     SyncTraitLangItem,               \"sync\",                    sync_trait;\n     FreezeTraitLangItem,             \"freeze\",                  freeze_trait;\n "}, {"sha": "68f8c20b0f77ee82dd2be9bcd6e15add1a75b819", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -1306,6 +1306,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n          } else if self.tcx().lang_items.unsize_trait() == Some(def_id) {\n              self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n          } else {\n+             if self.tcx().lang_items.clone_trait() == Some(def_id) {\n+                 // Same builtin conditions as `Copy`, i.e. every type which has builtin support\n+                 // for `Copy` also has builtin support for `Clone`, + tuples and arrays of `Clone`\n+                 // types have builtin support for `Clone`.\n+                 let clone_conditions = self.copy_conditions(obligation);\n+                 self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates)?;\n+             }\n+\n              self.assemble_generator_candidates(obligation, &mut candidates)?;\n              self.assemble_closure_candidates(obligation, &mut candidates)?;\n              self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n@@ -2213,8 +2221,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         match candidate {\n             BuiltinCandidate { has_nested } => {\n-                Ok(VtableBuiltin(\n-                    self.confirm_builtin_candidate(obligation, has_nested)))\n+                let data = self.confirm_builtin_candidate(obligation, has_nested);\n+                Ok(VtableBuiltin(data))\n             }\n \n             ParamCandidate(param) => {\n@@ -2326,6 +2334,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 _ if Some(trait_def) == self.tcx().lang_items.copy_trait() => {\n                     self.copy_conditions(obligation)\n                 }\n+                _ if Some(trait_def) == self.tcx().lang_items.clone_trait() => {\n+                    self.copy_conditions(obligation)\n+                }\n                 _ => bug!(\"unexpected builtin trait {:?}\", trait_def)\n             };\n             let nested = match conditions {\n@@ -2346,6 +2357,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         debug!(\"confirm_builtin_candidate: obligations={:?}\",\n                obligations);\n+\n         VtableBuiltinData { nested: obligations }\n     }\n \n@@ -2687,8 +2699,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n     fn confirm_builtin_unsize_candidate(&mut self,\n                                         obligation: &TraitObligation<'tcx>,)\n-                                        -> Result<VtableBuiltinData<PredicateObligation<'tcx>>,\n-                                                  SelectionError<'tcx>> {\n+        -> Result<VtableBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>>\n+    {\n         let tcx = self.tcx();\n \n         // assemble_candidates_for_unsizing should ensure there are no late bound"}, {"sha": "674da297cd959ba5abaf6da8c9d42b62adbe3a6b", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -325,7 +325,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n                 })\n             }\n             traits::VtableParam(n) => Some(traits::VtableParam(n)),\n-            traits::VtableBuiltin(d) => Some(traits::VtableBuiltin(d)),\n+            traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n             traits::VtableObject(traits::VtableObjectData {\n                 upcast_trait_ref,\n                 vtable_base,"}, {"sha": "7d543f689c24d179283eaa80904b2906b4070bab", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -24,15 +24,22 @@ pub struct Instance<'tcx> {\n pub enum InstanceDef<'tcx> {\n     Item(DefId),\n     Intrinsic(DefId),\n-    // <fn() as FnTrait>::call_*\n-    // def-id is FnTrait::call_*\n+\n+    /// <fn() as FnTrait>::call_*\n+    /// def-id is FnTrait::call_*\n     FnPtrShim(DefId, Ty<'tcx>),\n-    // <Trait as Trait>::fn\n+\n+    /// <Trait as Trait>::fn\n     Virtual(DefId, usize),\n-    // <[mut closure] as FnOnce>::call_once\n+\n+    /// <[mut closure] as FnOnce>::call_once\n     ClosureOnceShim { call_once: DefId },\n-    // drop_in_place::<T>; None for empty drop glue.\n+\n+    /// drop_in_place::<T>; None for empty drop glue.\n     DropGlue(DefId, Option<Ty<'tcx>>),\n+\n+    /// Builtin method implementation, e.g. `Clone::clone`.\n+    CloneShim(DefId, Ty<'tcx>),\n }\n \n impl<'tcx> InstanceDef<'tcx> {\n@@ -43,9 +50,9 @@ impl<'tcx> InstanceDef<'tcx> {\n             InstanceDef::FnPtrShim(def_id, _) |\n             InstanceDef::Virtual(def_id, _) |\n             InstanceDef::Intrinsic(def_id, ) |\n-            InstanceDef::ClosureOnceShim { call_once: def_id }\n-                => def_id,\n-            InstanceDef::DropGlue(def_id, _) => def_id\n+            InstanceDef::ClosureOnceShim { call_once: def_id } |\n+            InstanceDef::DropGlue(def_id, _) |\n+            InstanceDef::CloneShim(def_id, _) => def_id\n         }\n     }\n \n@@ -80,6 +87,9 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n             InstanceDef::DropGlue(_, ty) => {\n                 write!(f, \" - shim({:?})\", ty)\n             }\n+            InstanceDef::CloneShim(_, ty) => {\n+                write!(f, \" - shim({:?})\", ty)\n+            }\n         }\n     }\n }"}, {"sha": "a7f6fa62ae04b6480b91ded21f26ba7c2bd6aa46", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -2236,7 +2236,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::InstanceDef::FnPtrShim(..) |\n             ty::InstanceDef::Virtual(..) |\n             ty::InstanceDef::ClosureOnceShim { .. } |\n-            ty::InstanceDef::DropGlue(..) => {\n+            ty::InstanceDef::DropGlue(..) |\n+            ty::InstanceDef::CloneShim(..) => {\n                 self.mir_shims(instance)\n             }\n         }"}, {"sha": "039651b7e93722e637d464b62814c876fe290c95", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 384, "deletions": 4, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -17,6 +17,7 @@ use rustc::mir::transform::MirSource;\n use rustc::ty::{self, Ty};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::maps::Providers;\n+use rustc_const_math::{ConstInt, ConstUsize};\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n@@ -98,14 +99,25 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         ty::InstanceDef::DropGlue(def_id, ty) => {\n             build_drop_shim(tcx, def_id, ty)\n         }\n+        ty::InstanceDef::CloneShim(def_id, ty) => {\n+            let name = tcx.item_name(def_id).as_str();\n+            if name == \"clone\" {\n+                build_clone_shim(tcx, def_id, ty)\n+            } else if name == \"clone_from\" {\n+                debug!(\"make_shim({:?}: using default trait implementation\", instance);\n+                return tcx.optimized_mir(def_id);\n+            } else {\n+                bug!(\"builtin clone shim {:?} not supported\", instance)\n+            }\n+        }\n         ty::InstanceDef::Intrinsic(_) => {\n             bug!(\"creating shims from intrinsics ({:?}) is unsupported\", instance)\n         }\n     };\n-        debug!(\"make_shim({:?}) = untransformed {:?}\", instance, result);\n-        no_landing_pads::no_landing_pads(tcx, &mut result);\n-        simplify::simplify_cfg(&mut result);\n-        add_call_guards::CriticalCallEdges.add_call_guards(&mut result);\n+    debug!(\"make_shim({:?}) = untransformed {:?}\", instance, result);\n+    no_landing_pads::no_landing_pads(tcx, &mut result);\n+    simplify::simplify_cfg(&mut result);\n+    add_call_guards::CriticalCallEdges.add_call_guards(&mut result);\n     debug!(\"make_shim({:?}) = {:?}\", instance, result);\n \n     tcx.alloc_mir(result)\n@@ -267,6 +279,374 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n     }\n }\n \n+/// Build a `Clone::clone` shim for `self_ty`. Here, `def_id` is `Clone::clone`.\n+fn build_clone_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+                              def_id: DefId,\n+                              self_ty: ty::Ty<'tcx>)\n+                              -> Mir<'tcx>\n+{\n+    debug!(\"build_clone_shim(def_id={:?})\", def_id);\n+\n+    let mut builder = CloneShimBuilder::new(tcx, def_id);\n+    let is_copy = !self_ty.moves_by_default(tcx, tcx.param_env(def_id), builder.span);\n+\n+    match self_ty.sty {\n+        _ if is_copy => builder.copy_shim(),\n+        ty::TyArray(ty, len) => builder.array_shim(ty, len),\n+        ty::TyTuple(tys, _) => builder.tuple_shim(tys),\n+        _ => {\n+            bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty);\n+        }\n+    };\n+\n+    builder.into_mir()\n+}\n+\n+struct CloneShimBuilder<'a, 'tcx: 'a> {\n+    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+    local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+    blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    span: Span,\n+    sig: ty::FnSig<'tcx>,\n+}\n+\n+impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n+    fn new(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Self {\n+        let sig = tcx.fn_sig(def_id);\n+        let sig = tcx.erase_late_bound_regions(&sig);\n+        let span = tcx.def_span(def_id);\n+\n+        CloneShimBuilder {\n+            tcx,\n+            def_id,\n+            local_decls: local_decls_for_sig(&sig, span),\n+            blocks: IndexVec::new(),\n+            span,\n+            sig,\n+        }\n+    }\n+\n+    fn into_mir(self) -> Mir<'tcx> {\n+        Mir::new(\n+            self.blocks,\n+            IndexVec::from_elem_n(\n+                VisibilityScopeData { span: self.span, parent_scope: None }, 1\n+            ),\n+            IndexVec::new(),\n+            self.sig.output(),\n+            self.local_decls,\n+            self.sig.inputs().len(),\n+            vec![],\n+            self.span\n+        )\n+    }\n+\n+    fn source_info(&self) -> SourceInfo {\n+        SourceInfo { span: self.span, scope: ARGUMENT_VISIBILITY_SCOPE }\n+    }\n+\n+    fn block(\n+        &mut self,\n+        statements: Vec<Statement<'tcx>>,\n+        kind: TerminatorKind<'tcx>,\n+        is_cleanup: bool\n+    ) -> BasicBlock {\n+        let source_info = self.source_info();\n+        self.blocks.push(BasicBlockData {\n+            statements,\n+            terminator: Some(Terminator { source_info, kind }),\n+            is_cleanup,\n+        })\n+    }\n+\n+    fn make_statement(&self, kind: StatementKind<'tcx>) -> Statement<'tcx> {\n+        Statement {\n+            source_info: self.source_info(),\n+            kind,\n+        }\n+    }\n+\n+    fn copy_shim(&mut self) {\n+        let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n+        let ret_statement = self.make_statement(\n+            StatementKind::Assign(\n+                Lvalue::Local(RETURN_POINTER),\n+                Rvalue::Use(Operand::Consume(rcvr))\n+            )\n+        );\n+        self.block(vec![ret_statement], TerminatorKind::Return, false);\n+    }\n+\n+    fn make_lvalue(&mut self, mutability: Mutability, ty: ty::Ty<'tcx>) -> Lvalue<'tcx> {\n+        let span = self.span;\n+        Lvalue::Local(\n+            self.local_decls.push(temp_decl(mutability, ty, span))\n+        )\n+    }\n+\n+    fn make_clone_call(\n+        &mut self,\n+        ty: ty::Ty<'tcx>,\n+        rcvr_field: Lvalue<'tcx>,\n+        next: BasicBlock,\n+        cleanup: BasicBlock\n+    ) -> Lvalue<'tcx> {\n+        let tcx = self.tcx;\n+\n+        let substs = Substs::for_item(\n+            tcx,\n+            self.def_id,\n+            |_, _| tcx.types.re_erased,\n+            |_, _| ty\n+        );\n+\n+        // `func == Clone::clone(&ty) -> ty`\n+        let func = Operand::Constant(box Constant {\n+            span: self.span,\n+            ty: tcx.mk_fn_def(self.def_id, substs),\n+            literal: Literal::Value {\n+                value: ConstVal::Function(self.def_id, substs),\n+            },\n+        });\n+\n+        let ref_loc = self.make_lvalue(\n+            Mutability::Not,\n+            tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n+                ty,\n+                mutbl: hir::Mutability::MutImmutable,\n+            })\n+        );\n+\n+        let loc = self.make_lvalue(Mutability::Not, ty);\n+\n+        // `let ref_loc: &ty = &rcvr_field;`\n+        let statement = self.make_statement(\n+            StatementKind::Assign(\n+                ref_loc.clone(),\n+                Rvalue::Ref(tcx.types.re_erased, BorrowKind::Shared, rcvr_field)\n+            )\n+        );\n+\n+        // `let loc = Clone::clone(ref_loc);`\n+        self.block(vec![statement], TerminatorKind::Call {\n+            func,\n+            args: vec![Operand::Consume(ref_loc)],\n+            destination: Some((loc.clone(), next)),\n+            cleanup: Some(cleanup),\n+        }, false);\n+\n+        loc\n+    }\n+\n+    fn loop_header(\n+        &mut self,\n+        beg: Lvalue<'tcx>,\n+        end: Lvalue<'tcx>,\n+        loop_body: BasicBlock,\n+        loop_end: BasicBlock,\n+        is_cleanup: bool\n+    ) {\n+        let tcx = self.tcx;\n+\n+        let cond = self.make_lvalue(Mutability::Mut, tcx.types.bool);\n+        let compute_cond = self.make_statement(\n+            StatementKind::Assign(\n+                cond.clone(),\n+                Rvalue::BinaryOp(BinOp::Ne, Operand::Consume(end), Operand::Consume(beg))\n+            )\n+        );\n+\n+        // `if end != beg { goto loop_body; } else { goto loop_end; }`\n+        self.block(\n+            vec![compute_cond],\n+            TerminatorKind::if_(tcx, Operand::Consume(cond), loop_body, loop_end),\n+            is_cleanup\n+        );\n+    }\n+\n+    fn make_usize(&self, value: usize) -> Box<Constant<'tcx>> {\n+        let value = ConstUsize::new(value as u64, self.tcx.sess.target.uint_type).unwrap();\n+        box Constant {\n+            span: self.span,\n+            ty: self.tcx.types.usize,\n+            literal: Literal::Value {\n+                value: ConstVal::Integral(ConstInt::Usize(value))\n+            }\n+        }\n+    }\n+\n+    fn array_shim(&mut self, ty: ty::Ty<'tcx>, len: usize) {\n+        let tcx = self.tcx;\n+        let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n+\n+        let beg = self.make_lvalue(Mutability::Mut, tcx.types.usize);\n+        let end = self.make_lvalue(Mutability::Not, tcx.types.usize);\n+        let ret = self.make_lvalue(Mutability::Mut, tcx.mk_array(ty, len));\n+\n+        // BB #0\n+        // `let mut beg = 0;`\n+        // `let end = len;`\n+        // `goto #1;`\n+        let inits = vec![\n+            self.make_statement(\n+                StatementKind::Assign(\n+                    beg.clone(),\n+                    Rvalue::Use(Operand::Constant(self.make_usize(0)))\n+                )\n+            ),\n+            self.make_statement(\n+                StatementKind::Assign(\n+                    end.clone(),\n+                    Rvalue::Use(Operand::Constant(self.make_usize(len)))\n+                )\n+            )\n+        ];\n+        self.block(inits, TerminatorKind::Goto { target: BasicBlock::new(1) }, false);\n+\n+        // BB #1: loop {\n+        //     BB #2;\n+        //     BB #3;\n+        // }\n+        // BB #4;\n+        self.loop_header(beg.clone(), end, BasicBlock::new(2), BasicBlock::new(4), false);\n+\n+        // BB #2\n+        // `let cloned = Clone::clone(rcvr[beg])`;\n+        // Goto #3 if ok, #5 if unwinding happens.\n+        let rcvr_field = rcvr.clone().index(Operand::Consume(beg.clone()));\n+        let cloned = self.make_clone_call(ty, rcvr_field, BasicBlock::new(3), BasicBlock::new(5));\n+\n+        // BB #3\n+        // `ret[beg] = cloned;`\n+        // `beg = beg + 1;`\n+        // `goto #1`;\n+        let ret_field = ret.clone().index(Operand::Consume(beg.clone()));\n+        let statements = vec![\n+            self.make_statement(\n+                StatementKind::Assign(\n+                    ret_field,\n+                    Rvalue::Use(Operand::Consume(cloned))\n+                )\n+            ),\n+            self.make_statement(\n+                StatementKind::Assign(\n+                    beg.clone(),\n+                    Rvalue::BinaryOp(\n+                        BinOp::Add,\n+                        Operand::Consume(beg.clone()),\n+                        Operand::Constant(self.make_usize(1))\n+                    )\n+                )\n+            )\n+        ];\n+        self.block(statements, TerminatorKind::Goto { target: BasicBlock::new(1) }, false);\n+\n+        // BB #4\n+        // `return ret;`\n+        let ret_statement = self.make_statement(\n+            StatementKind::Assign(\n+                Lvalue::Local(RETURN_POINTER),\n+                Rvalue::Use(Operand::Consume(ret.clone())),\n+            )\n+        );\n+        self.block(vec![ret_statement], TerminatorKind::Return, false);\n+\n+        // BB #5 (cleanup)\n+        // `let end = beg;`\n+        // `let mut beg = 0;`\n+        // goto #6;\n+        let end = beg;\n+        let beg = self.make_lvalue(Mutability::Mut, tcx.types.usize);\n+        let init = self.make_statement(\n+            StatementKind::Assign(\n+                beg.clone(),\n+                Rvalue::Use(Operand::Constant(self.make_usize(0)))\n+            )\n+        );\n+        self.block(vec![init], TerminatorKind::Goto { target: BasicBlock::new(6) }, true);\n+\n+        // BB #6 (cleanup): loop {\n+        //     BB #7;\n+        //     BB #8;\n+        // }\n+        // BB #9;\n+        self.loop_header(beg.clone(), end, BasicBlock::new(7), BasicBlock::new(9), true);\n+\n+        // BB #7 (cleanup)\n+        // `drop(ret[beg])`;\n+        self.block(vec![], TerminatorKind::Drop {\n+            location: ret.index(Operand::Consume(beg.clone())),\n+            target: BasicBlock::new(8),\n+            unwind: None,\n+        }, true);\n+\n+        // BB #8 (cleanup)\n+        // `beg = beg + 1;`\n+        // `goto #6;`\n+        let statement = self.make_statement(\n+            StatementKind::Assign(\n+                beg.clone(),\n+                Rvalue::BinaryOp(\n+                    BinOp::Add,\n+                    Operand::Consume(beg.clone()),\n+                    Operand::Constant(self.make_usize(1))\n+                )\n+            )\n+        );\n+        self.block(vec![statement], TerminatorKind::Goto { target: BasicBlock::new(6) }, true);\n+\n+        // BB #9 (resume)\n+        self.block(vec![], TerminatorKind::Resume, true);\n+    }\n+\n+    fn tuple_shim(&mut self, tys: &ty::Slice<ty::Ty<'tcx>>) {\n+        let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n+\n+        let mut returns = Vec::new();\n+        for (i, ity) in tys.iter().enumerate() {\n+            let rcvr_field = rcvr.clone().field(Field::new(i), *ity);\n+\n+            // BB #(2i)\n+            // `returns[i] = Clone::clone(&rcvr.i);`\n+            // Goto #(2i + 2) if ok, #(2i + 1) if unwinding happens.\n+            returns.push(\n+                self.make_clone_call(\n+                    *ity,\n+                    rcvr_field,\n+                    BasicBlock::new(2 * i + 2),\n+                    BasicBlock::new(2 * i + 1),\n+                )\n+            );\n+\n+            // BB #(2i + 1) (cleanup)\n+            if i == 0 {\n+                // Nothing to drop, just resume.\n+                self.block(vec![], TerminatorKind::Resume, true);\n+            } else {\n+                // Drop previous field and goto previous cleanup block.\n+                self.block(vec![], TerminatorKind::Drop {\n+                    location: returns[i - 1].clone(),\n+                    target: BasicBlock::new(2 * i - 1),\n+                    unwind: None,\n+                }, true);\n+            }\n+        }\n+\n+        // `return (returns[0], returns[1], ..., returns[tys.len() - 1]);`\n+        let ret_statement = self.make_statement(\n+            StatementKind::Assign(\n+                Lvalue::Local(RETURN_POINTER),\n+                Rvalue::Aggregate(\n+                    box AggregateKind::Tuple,\n+                    returns.into_iter().map(Operand::Consume).collect()\n+                )\n+            )\n+        );\n+       self.block(vec![ret_statement], TerminatorKind::Return, false);\n+    }\n+}\n+\n /// Build a \"call\" shim for `def_id`. The shim calls the\n /// function specified by `call_kind`, first adjusting its first\n /// argument according to `rcvr_adjustment`."}, {"sha": "8b864a7fdcfbbf782c592448fdd8668fb34929cf", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -701,7 +701,8 @@ fn visit_instance_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n         ty::InstanceDef::ClosureOnceShim { .. } |\n         ty::InstanceDef::Item(..) |\n-        ty::InstanceDef::FnPtrShim(..) => {\n+        ty::InstanceDef::FnPtrShim(..) |\n+        ty::InstanceDef::CloneShim(..) => {\n             output.push(create_fn_trans_item(instance));\n         }\n     }\n@@ -718,7 +719,8 @@ fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instan\n         ty::InstanceDef::Virtual(..) |\n         ty::InstanceDef::FnPtrShim(..) |\n         ty::InstanceDef::DropGlue(..) |\n-        ty::InstanceDef::Intrinsic(_) => return true\n+        ty::InstanceDef::Intrinsic(_) |\n+        ty::InstanceDef::CloneShim(..) => return true\n     };\n     match tcx.hir.get_if_local(def_id) {\n         Some(hir_map::NodeForeignItem(..)) => {"}, {"sha": "4989ca8cc938c24460eb24aa2415635961858c24", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -149,6 +149,12 @@ fn resolve_associated_item<'a, 'tcx>(\n                 substs: rcvr_substs\n             }\n         }\n+        traits::VtableBuiltin(..) if Some(trait_id) == tcx.lang_items.clone_trait() => {\n+            Instance {\n+                def: ty::InstanceDef::CloneShim(def_id, trait_ref.self_ty()),\n+                substs: rcvr_substs\n+            }\n+        }\n         _ => {\n             bug!(\"static call to invalid vtable: {:?}\", vtbl)\n         }"}, {"sha": "26256fa78dd4d51706722669445697cd961fd070", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -361,7 +361,8 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                                 InstanceDef::Virtual(..) |\n                                 InstanceDef::Intrinsic(..) |\n                                 InstanceDef::ClosureOnceShim { .. } |\n-                                InstanceDef::DropGlue(..) => {\n+                                InstanceDef::DropGlue(..) |\n+                                InstanceDef::CloneShim(..) => {\n                                     bug!(\"partitioning: Encountered unexpected\n                                           root translation item: {:?}\",\n                                           trans_item)\n@@ -603,7 +604,8 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n                 ty::InstanceDef::ClosureOnceShim { .. } |\n                 ty::InstanceDef::Intrinsic(..) |\n                 ty::InstanceDef::DropGlue(..) |\n-                ty::InstanceDef::Virtual(..) => return None\n+                ty::InstanceDef::Virtual(..) |\n+                ty::InstanceDef::CloneShim(..) => return None\n             };\n \n             // If this is a method, we want to put it into the same module as"}, {"sha": "5e5a27f2ba13719a7b640fb69d9df737856cbbb7", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -719,6 +719,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 continue;\n             }\n \n+            self.assemble_builtin_candidates(import_id, trait_def_id, item.clone());\n+\n             self.assemble_extension_candidates_for_trait_impls(import_id, trait_def_id,\n                                                                item.clone());\n \n@@ -734,6 +736,49 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n+    fn assemble_builtin_candidates(&mut self,\n+                                   import_id: Option<ast::NodeId>,\n+                                   trait_def_id: DefId,\n+                                   item: ty::AssociatedItem) {\n+        if Some(trait_def_id) == self.tcx.lang_items.clone_trait() {\n+            self.assemble_builtin_clone_candidates(import_id, trait_def_id, item);\n+        }\n+    }\n+\n+    fn assemble_builtin_clone_candidates(&mut self,\n+                                         import_id: Option<ast::NodeId>,\n+                                         trait_def_id: DefId,\n+                                         item: ty::AssociatedItem) {\n+        for step in Rc::clone(&self.steps).iter() {\n+            match step.self_ty.sty {\n+                ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n+                ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n+                ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n+                ty::TyRawPtr(..) | ty::TyError | ty::TyNever |\n+                ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) |\n+                ty::TyArray(..) | ty::TyTuple(..) => {\n+                    ()\n+                }\n+\n+                _ => continue,\n+            };\n+\n+            let substs = Substs::for_item(self.tcx,\n+                                          trait_def_id,\n+                                          |def, _| self.region_var_for_def(self.span, def),\n+                                          |def, substs| {\n+                if def.index == 0 {\n+                    step.self_ty\n+                } else {\n+                    self.type_var_for_def(self.span, def, substs)\n+                }\n+            });\n+\n+            let xform_self_ty = self.xform_self_ty(&item, step.self_ty, substs);\n+            self.push_inherent_candidate(xform_self_ty, item, TraitCandidate, import_id);\n+        }\n+    }\n+\n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n                                                      import_id: Option<ast::NodeId>,\n                                                      trait_def_id: DefId,"}, {"sha": "405d06dafbfdaa6383427dc57c8782536caf3789", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -599,9 +599,7 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n                 panic!(FatalError)\n             }\n         },\n-        \"path\" => {\n-            token::NtPath(panictry!(p.parse_path(PathStyle::Type)))\n-        },\n+        \"path\" => token::NtPath(panictry!(p.parse_path_common(PathStyle::Type, false))),\n         \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n         \"vis\" => token::NtVis(panictry!(p.parse_visibility(true))),\n         // this is not supposed to happen, since it has been checked"}, {"sha": "ef811abc159d6395e405ad52da349a1c569d443f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -84,7 +84,7 @@ pub enum PathStyle {\n     Expr,\n     /// In other contexts, notably in types, no ambiguity exists and paths can be written\n     /// without the disambiguator, e.g. `x<y>` - unambiguously a path.\n-    /// Paths with disambiguators are rejected for now, but may be allowed in the future.\n+    /// Paths with disambiguators are still accepted, `x::<Y>` - unambiguously a path too.\n     Type,\n     /// A path with generic arguments disallowed, e.g. `foo::bar::Baz`, used in imports,\n     /// visibilities or attributes.\n@@ -1755,7 +1755,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::ModSep)?;\n \n         let qself = QSelf { ty, position: path.segments.len() };\n-        self.parse_path_segments(&mut path.segments, style)?;\n+        self.parse_path_segments(&mut path.segments, style, true)?;\n \n         Ok((qself, ast::Path { segments: path.segments, span: lo.to(self.prev_span) }))\n     }\n@@ -1770,16 +1770,20 @@ impl<'a> Parser<'a> {\n     /// `a::b::C::<D>` (with disambiguator)\n     /// `Fn(Args)` (without disambiguator)\n     /// `Fn::(Args)` (with disambiguator)\n-    pub fn parse_path(&mut self, style: PathStyle) -> PResult<'a, ast::Path>\n-    {\n+    pub fn parse_path(&mut self, style: PathStyle) -> PResult<'a, ast::Path> {\n+        self.parse_path_common(style, true)\n+    }\n+\n+    pub fn parse_path_common(&mut self, style: PathStyle, enable_warning: bool)\n+                             -> PResult<'a, ast::Path> {\n         maybe_whole!(self, NtPath, |x| x);\n \n         let lo = self.meta_var_span.unwrap_or(self.span);\n         let mut segments = Vec::new();\n         if self.eat(&token::ModSep) {\n             segments.push(PathSegment::crate_root(lo));\n         }\n-        self.parse_path_segments(&mut segments, style)?;\n+        self.parse_path_segments(&mut segments, style, enable_warning)?;\n \n         Ok(ast::Path { segments, span: lo.to(self.prev_span) })\n     }\n@@ -1804,18 +1808,19 @@ impl<'a> Parser<'a> {\n         self.parse_path(style)\n     }\n \n-    fn parse_path_segments(&mut self, segments: &mut Vec<PathSegment>, style: PathStyle)\n-                           -> PResult<'a, ()> {\n+    fn parse_path_segments(&mut self, segments: &mut Vec<PathSegment>, style: PathStyle,\n+                           enable_warning: bool) -> PResult<'a, ()> {\n         loop {\n-            segments.push(self.parse_path_segment(style)?);\n+            segments.push(self.parse_path_segment(style, enable_warning)?);\n \n             if self.is_import_coupler() || !self.eat(&token::ModSep) {\n                 return Ok(());\n             }\n         }\n     }\n \n-    fn parse_path_segment(&mut self, style: PathStyle) -> PResult<'a, PathSegment> {\n+    fn parse_path_segment(&mut self, style: PathStyle, enable_warning: bool)\n+                          -> PResult<'a, PathSegment> {\n         let ident_span = self.span;\n         let ident = self.parse_path_segment_ident()?;\n \n@@ -1835,17 +1840,9 @@ impl<'a> Parser<'a> {\n                                       && self.look_ahead(1, |t| is_args_start(t)) {\n             // Generic arguments are found - `<`, `(`, `::<` or `::(`.\n             let lo = self.span;\n-            if self.eat(&token::ModSep) {\n-                // These errors are not strictly necessary and may be removed in the future.\n-                if style == PathStyle::Type {\n-                    let mut err = self.diagnostic().struct_span_err(self.prev_span,\n-                        \"unnecessary path disambiguator\");\n-                    err.span_label(self.prev_span, \"try removing `::`\");\n-                    err.emit();\n-                } else if self.token == token::OpenDelim(token::Paren) {\n-                    self.diagnostic().span_err(self.prev_span,\n-                        \"`::` is not supported before parenthesized generic arguments\")\n-                }\n+            if self.eat(&token::ModSep) && style == PathStyle::Type && enable_warning {\n+                self.diagnostic().struct_span_warn(self.prev_span, \"unnecessary path disambiguator\")\n+                                 .span_label(self.prev_span, \"try removing `::`\").emit();\n             }\n \n             let parameters = if self.eat_lt() {\n@@ -2390,7 +2387,7 @@ impl<'a> Parser<'a> {\n \n     // Assuming we have just parsed `.`, continue parsing into an expression.\n     fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n-        let segment = self.parse_path_segment(PathStyle::Expr)?;\n+        let segment = self.parse_path_segment(PathStyle::Expr, true)?;\n         Ok(match self.token {\n             token::OpenDelim(token::Paren) => {\n                 // Method call `expr.f()`"}, {"sha": "ffbd0c0c22a7c07d2b7513e12a7fdcb18444222a", "filename": "src/test/compile-fail/issue-32995.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Ftest%2Fcompile-fail%2Fissue-32995.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Ftest%2Fcompile-fail%2Fissue-32995.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32995.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -19,15 +19,11 @@ fn main() {\n     //~^ ERROR parenthesized parameters may only be used with a trait\n     //~| WARN previously accepted\n \n-    macro_rules! pathexpr {\n-        ($p:path) => { $p }\n-    }\n-\n-    let p = pathexpr!(::std::str()::from_utf8)(b\"foo\").unwrap();\n+    let p = ::std::str::()::from_utf8(b\"foo\").unwrap();\n     //~^ ERROR parenthesized parameters may only be used with a trait\n     //~| WARN previously accepted\n \n-    let p = pathexpr!(::std::str::from_utf8())(b\"foo\").unwrap();\n+    let p = ::std::str::from_utf8::()(b\"foo\").unwrap();\n     //~^ ERROR parenthesized parameters may only be used with a trait\n     //~| WARN previously accepted\n "}, {"sha": "3afbfa61984b566456317591534df18c0a5571ef", "filename": "src/test/compile-fail/issue-36116.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Ftest%2Fcompile-fail%2Fissue-36116.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Ftest%2Fcompile-fail%2Fissue-36116.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-36116.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -8,16 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Unnecessary path disambiguator is ok\n+\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+macro_rules! m {\n+    ($p: path) => {\n+        let _ = $p(0);\n+        let _: $p;\n+    }\n+}\n+\n struct Foo<T> {\n     _a: T,\n }\n \n-fn main() {\n-    let f = Some(Foo { _a: 42 }).map(|a| a as Foo::<i32>);\n-    //~^ ERROR unnecessary path disambiguator\n-    //~| NOTE try removing `::`\n+struct S<T>(T);\n+\n+fn f() {\n+    let f = Some(Foo { _a: 42 }).map(|a| a as Foo::<i32>); //~ WARN unnecessary path disambiguator\n+    let g: Foo::<i32> = Foo { _a: 42 }; //~ WARN unnecessary path disambiguator\n \n-    let g: Foo::<i32> = Foo { _a: 42 };\n-    //~^ ERROR unnecessary path disambiguator\n-    //~| NOTE try removing `::`\n+    m!(S::<u8>); // OK, no warning\n }\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "42fffe546c20c171bb57f56890008de761184328", "filename": "src/test/compile-fail/unboxed-closure-sugar-used-on-struct-3.rs", "status": "renamed", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-3.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n-\n-// Test that parentheses form doesn't work in expression paths.\n+// Test that parentheses form parses in expression paths.\n \n struct Bar<A,R> {\n     f: A, r: R\n@@ -21,10 +19,10 @@ impl<A,B> Bar<A,B> {\n }\n \n fn bar() {\n-    let b = Box::Bar::<isize,usize>::new(); // OK\n+    let b = Bar::<isize, usize>::new(); // OK\n \n-    let b = Box::Bar::()::new();\n-    //~^ ERROR `::` is not supported before parenthesized generic arguments\n+    let b = Bar::(isize, usize)::new(); // OK too (for the parser)\n+    //~^ ERROR parenthesized parameters may only be used with a trait\n }\n \n-fn main() { }\n+fn main() {}", "previous_filename": "src/test/parse-fail/unboxed-closure-sugar-used-on-struct-3.rs"}, {"sha": "cb018ff1bfa398f5272ca7e87c34add1747157a7", "filename": "src/test/parse-fail/type-parameters-in-field-exprs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Ftest%2Fparse-fail%2Ftype-parameters-in-field-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Ftest%2Fparse-fail%2Ftype-parameters-in-field-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftype-parameters-in-field-exprs.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -24,4 +24,6 @@ fn main() {\n     //~^ ERROR field expressions may not have generic arguments\n     f.x::<>;\n     //~^ ERROR field expressions may not have generic arguments\n+    f.x::();\n+    //~^ ERROR field expressions may not have generic arguments\n }"}, {"sha": "90a411352869ccf09bc42faa68970554750c2ccc", "filename": "src/test/run-pass/builtin-clone-unwind.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Ftest%2Frun-pass%2Fbuiltin-clone-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Ftest%2Frun-pass%2Fbuiltin-clone-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-clone-unwind.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that builtin implementations of `Clone` cleanup everything\n+// in case of unwinding.\n+\n+use std::thread;\n+use std::rc::Rc;\n+\n+struct S(Rc<()>);\n+\n+impl Clone for S {\n+    fn clone(&self) -> Self {\n+        if Rc::strong_count(&self.0) == 7 {\n+            panic!(\"oops\");\n+        }\n+\n+        S(self.0.clone())\n+    }\n+}\n+\n+fn main() {\n+    let counter = Rc::new(());\n+\n+    // Unwinding with tuples...\n+    let ccounter = counter.clone();\n+    let result = std::panic::catch_unwind(move || {\n+        let _ = (\n+            S(ccounter.clone()),\n+            S(ccounter.clone()),\n+            S(ccounter.clone()),\n+            S(ccounter)\n+        ).clone();\n+    });\n+\n+    assert!(result.is_err());\n+    assert_eq!(\n+        1,\n+        Rc::strong_count(&counter)\n+    );\n+\n+    // ... and with arrays.\n+    let ccounter = counter.clone();\n+    let child = std::panic::catch_unwind(move || {\n+        let _ = [\n+            S(ccounter.clone()),\n+            S(ccounter.clone()),\n+            S(ccounter.clone()),\n+            S(ccounter)\n+        ].clone();\n+    });\n+\n+    assert!(result.is_err());\n+    assert_eq!(\n+        1,\n+        Rc::strong_count(&counter)\n+    );\n+}"}, {"sha": "95903610931b2e9f7ec6d2a1482afc342038047a", "filename": "src/test/run-pass/builtin-clone.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Ftest%2Frun-pass%2Fbuiltin-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Ftest%2Frun-pass%2Fbuiltin-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-clone.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that `Clone` is correctly implemented for builtin types.\n+// Also test that cloning an array or a tuple is done right, i.e.\n+// each component is cloned.\n+\n+fn test_clone<T: Clone>(arg: T) {\n+    let _ = arg.clone();\n+}\n+\n+fn foo() { }\n+\n+#[derive(Debug, PartialEq, Eq)]\n+struct S(i32);\n+\n+impl Clone for S {\n+    fn clone(&self) -> Self {\n+        S(self.0 + 1)\n+    }\n+}\n+\n+fn main() {\n+    test_clone(foo);\n+    test_clone([1; 56]);\n+    test_clone((1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));\n+\n+    let a = [S(0), S(1), S(2)];\n+    let b = [S(1), S(2), S(3)];\n+    assert_eq!(b, a.clone());\n+\n+    let a = (\n+        (S(1), S(0)),\n+        (\n+            (S(0), S(0), S(1)),\n+            S(0)\n+        )\n+    );\n+    let b = (\n+        (S(2), S(1)),\n+        (\n+            (S(1), S(1), S(2)),\n+            S(1)\n+        )\n+    );\n+    assert_eq!(b, a.clone());\n+}"}, {"sha": "a8fb11f9c62bd58b4f94c71dcaa1cf142e1b0b9a", "filename": "src/test/run-pass/issue-37725.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Ftest%2Frun-pass%2Fissue-37725.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21/src%2Ftest%2Frun-pass%2Fissue-37725.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-37725.rs?ref=04c66c30a7deaf2bfc1b9ba17df890e6bfd96c21", "patch": "@@ -8,7 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn foo<'a>(s: &'a mut ()) where &'a mut (): Clone {\n-    s.clone();\n+trait Foo {\n+    fn foo(&self);\n+}\n+\n+fn foo<'a>(s: &'a mut ()) where &'a mut (): Foo {\n+    s.foo();\n }\n fn main() {}"}]}