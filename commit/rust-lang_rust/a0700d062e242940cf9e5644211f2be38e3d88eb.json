{"sha": "a0700d062e242940cf9e5644211f2be38e3d88eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNzAwZDA2MmUyNDI5NDBjZjllNTY0NDIxMWYyYmUzOGUzZDg4ZWI=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-05-23T22:40:41Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-05-25T21:52:43Z"}, "message": "Inline move_path_for_projection inside move_path_for", "tree": {"sha": "2cf7ecee888d42e9753502d76f1fa6db7129cebd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2cf7ecee888d42e9753502d76f1fa6db7129cebd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0700d062e242940cf9e5644211f2be38e3d88eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0700d062e242940cf9e5644211f2be38e3d88eb", "html_url": "https://github.com/rust-lang/rust/commit/a0700d062e242940cf9e5644211f2be38e3d88eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0700d062e242940cf9e5644211f2be38e3d88eb/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f492693982d1e252f5411ae3e4d560ab0dfea48a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f492693982d1e252f5411ae3e4d560ab0dfea48a", "html_url": "https://github.com/rust-lang/rust/commit/f492693982d1e252f5411ae3e4d560ab0dfea48a"}], "stats": {"total": 114, "additions": 53, "deletions": 61}, "files": [{"sha": "507e5a4abab3d8917d3713af2afca1a660ca5d5f", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 53, "deletions": 61, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/a0700d062e242940cf9e5644211f2be38e3d88eb/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0700d062e242940cf9e5644211f2be38e3d88eb/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=a0700d062e242940cf9e5644211f2be38e3d88eb", "patch": "@@ -101,7 +101,59 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                 Err(MoveError::cannot_move_out_of(self.loc, Static))\n             }\n             Place::Projection(ref proj) => {\n-                self.move_path_for_projection(place, proj)\n+                let base = self.move_path_for(&proj.base)?;\n+                let mir = self.builder.mir;\n+                let tcx = self.builder.tcx;\n+                let place_ty = proj.base.ty(mir, tcx).ty;\n+                match place_ty.sty {\n+                    ty::Ref(..) | ty::RawPtr(..) =>\n+                        return Err(MoveError::cannot_move_out_of(\n+                            self.loc,\n+                            BorrowedContent { target_place: place.clone() })),\n+                    ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n+                        return Err(MoveError::cannot_move_out_of(self.loc,\n+                                                                 InteriorOfTypeWithDestructor {\n+                            container_ty: place_ty\n+                        })),\n+                    // move out of union - always move the entire union\n+                    ty::Adt(adt, _) if adt.is_union() =>\n+                        return Err(MoveError::UnionMove { path: base }),\n+                    ty::Slice(_) =>\n+                        return Err(MoveError::cannot_move_out_of(\n+                            self.loc,\n+                            InteriorOfSliceOrArray {\n+                                ty: place_ty, is_index: match proj.elem {\n+                                    ProjectionElem::Index(..) => true,\n+                                    _ => false\n+                                },\n+                            })),\n+                    ty::Array(..) => match proj.elem {\n+                        ProjectionElem::Index(..) =>\n+                            return Err(MoveError::cannot_move_out_of(\n+                                self.loc,\n+                                InteriorOfSliceOrArray {\n+                                    ty: place_ty, is_index: true\n+                                })),\n+                        _ => {\n+                            // FIXME: still badly broken\n+                        }\n+                    },\n+                    _ => {}\n+                };\n+                match self.builder.data.rev_lookup.projections.entry((base, proj.elem.lift())) {\n+                    Entry::Occupied(ent) => Ok(*ent.get()),\n+                    Entry::Vacant(ent) => {\n+                        let path = MoveDataBuilder::new_move_path(\n+                            &mut self.builder.data.move_paths,\n+                            &mut self.builder.data.path_map,\n+                            &mut self.builder.data.init_path_map,\n+                            Some(base),\n+                            place.clone()\n+                        );\n+                        ent.insert(path);\n+                        Ok(path)\n+                    }\n+                }\n             }\n         }\n     }\n@@ -111,66 +163,6 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         // drop), so this not being a valid move path is OK.\n         let _ = self.move_path_for(place);\n     }\n-\n-    fn move_path_for_projection(&mut self,\n-                                place: &Place<'tcx>,\n-                                proj: &Projection<'tcx>)\n-                                -> Result<MovePathIndex, MoveError<'tcx>>\n-    {\n-        let base = self.move_path_for(&proj.base)?;\n-        let mir = self.builder.mir;\n-        let tcx = self.builder.tcx;\n-        let place_ty = proj.base.ty(mir, tcx).ty;\n-        match place_ty.sty {\n-            ty::Ref(..) | ty::RawPtr(..) =>\n-                return Err(MoveError::cannot_move_out_of(\n-                    self.loc,\n-                    BorrowedContent { target_place: place.clone() })),\n-            ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n-                return Err(MoveError::cannot_move_out_of(self.loc,\n-                                                         InteriorOfTypeWithDestructor {\n-                    container_ty: place_ty\n-                })),\n-            // move out of union - always move the entire union\n-            ty::Adt(adt, _) if adt.is_union() =>\n-                return Err(MoveError::UnionMove { path: base }),\n-            ty::Slice(_) =>\n-                return Err(MoveError::cannot_move_out_of(\n-                    self.loc,\n-                    InteriorOfSliceOrArray {\n-                        ty: place_ty, is_index: match proj.elem {\n-                            ProjectionElem::Index(..) => true,\n-                            _ => false\n-                        },\n-                    })),\n-            ty::Array(..) => match proj.elem {\n-                ProjectionElem::Index(..) =>\n-                    return Err(MoveError::cannot_move_out_of(\n-                        self.loc,\n-                        InteriorOfSliceOrArray {\n-                            ty: place_ty, is_index: true\n-                        })),\n-                _ => {\n-                    // FIXME: still badly broken\n-                }\n-            },\n-            _ => {}\n-        };\n-        match self.builder.data.rev_lookup.projections.entry((base, proj.elem.lift())) {\n-            Entry::Occupied(ent) => Ok(*ent.get()),\n-            Entry::Vacant(ent) => {\n-                let path = MoveDataBuilder::new_move_path(\n-                    &mut self.builder.data.move_paths,\n-                    &mut self.builder.data.path_map,\n-                    &mut self.builder.data.init_path_map,\n-                    Some(base),\n-                    place.clone()\n-                );\n-                ent.insert(path);\n-                Ok(path)\n-            }\n-        }\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {"}]}