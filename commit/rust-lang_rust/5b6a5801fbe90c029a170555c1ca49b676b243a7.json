{"sha": "5b6a5801fbe90c029a170555c1ca49b676b243a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNmE1ODAxZmJlOTBjMDI5YTE3MDU1NWMxY2E0OWI2NzZiMjQzYTc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-28T03:37:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-28T03:37:46Z"}, "message": "Rollup merge of #64802 - estebank:walk-parents-iterator, r=matthewjasper\n\nAccount for tail expressions when pointing at return type\n\nWhen there's a type mismatch we make an effort to check if it was\ncaused by a function's return type. This logic now makes sure to\nonly point at the return type if the error happens in a tail\nexpression.\n\nTurn `walk_parent_nodes` method into an iterator.\n\nCC #39968, CC #40799.", "tree": {"sha": "d9953bed1b140302f4cddce40c633787b87b178c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9953bed1b140302f4cddce40c633787b87b178c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b6a5801fbe90c029a170555c1ca49b676b243a7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdjtWKCRBK7hj4Ov3rIwAAdHIIAG6p6OZOR4MP18X9JAdq8hH7\npXwoBKumlDSfgOR9UqGrnfjeEf9y7wOtGcR1uM1PwqkFKIGr+6/7I96SPX1NCKiO\noDcPUbNla/Pq2m3yYIM5lb4M2hAe/keaeKrC8NInf0xpbzZlGswRn+rBfcBx+b4x\nM1Di9FI8K9GmwU1gJCF8LczpqPi6JezlaElSleoOGW/Uh2BQBBOC04hAcP7UQGPI\niYBG9c/ABQ3mdMItnmhIh28/2Cdeii6eH7x5mLJxwjupiaOaCfTry8Ir8e8qm1Qn\najfHCzR2VVJAx5JxZsBXJ+UmtuBTltEduhHcUm5RG4Mnm8NduOSN0+Mlga9Mg5g=\n=/W2A\n-----END PGP SIGNATURE-----\n", "payload": "tree d9953bed1b140302f4cddce40c633787b87b178c\nparent 85175b719b6d854744bf29099765eb06fb46cc70\nparent a284822e009e1e72443041219c7f3646c822ff89\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1569641866 +0200\ncommitter GitHub <noreply@github.com> 1569641866 +0200\n\nRollup merge of #64802 - estebank:walk-parents-iterator, r=matthewjasper\n\nAccount for tail expressions when pointing at return type\n\nWhen there's a type mismatch we make an effort to check if it was\ncaused by a function's return type. This logic now makes sure to\nonly point at the return type if the error happens in a tail\nexpression.\n\nTurn `walk_parent_nodes` method into an iterator.\n\nCC #39968, CC #40799.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b6a5801fbe90c029a170555c1ca49b676b243a7", "html_url": "https://github.com/rust-lang/rust/commit/5b6a5801fbe90c029a170555c1ca49b676b243a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b6a5801fbe90c029a170555c1ca49b676b243a7/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85175b719b6d854744bf29099765eb06fb46cc70", "url": "https://api.github.com/repos/rust-lang/rust/commits/85175b719b6d854744bf29099765eb06fb46cc70", "html_url": "https://github.com/rust-lang/rust/commit/85175b719b6d854744bf29099765eb06fb46cc70"}, {"sha": "a284822e009e1e72443041219c7f3646c822ff89", "url": "https://api.github.com/repos/rust-lang/rust/commits/a284822e009e1e72443041219c7f3646c822ff89", "html_url": "https://github.com/rust-lang/rust/commit/a284822e009e1e72443041219c7f3646c822ff89"}], "stats": {"total": 254, "additions": 136, "deletions": 118}, "files": [{"sha": "b45d3f03960479e9fae712f752efaabfe06693c7", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 127, "deletions": 108, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/5b6a5801fbe90c029a170555c1ca49b676b243a7/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b6a5801fbe90c029a170555c1ca49b676b243a7/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=5b6a5801fbe90c029a170555c1ca49b676b243a7", "patch": "@@ -23,8 +23,6 @@ use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n \n-use std::result::Result::Err;\n-\n pub mod blocks;\n mod collector;\n mod def_collector;\n@@ -183,6 +181,44 @@ pub struct Map<'hir> {\n     hir_to_node_id: FxHashMap<HirId, NodeId>,\n }\n \n+struct ParentHirIterator<'map> {\n+    current_id: HirId,\n+    map: &'map Map<'map>,\n+}\n+\n+impl<'map> ParentHirIterator<'map> {\n+    fn new(current_id: HirId, map: &'map Map<'map>) -> ParentHirIterator<'map> {\n+        ParentHirIterator {\n+            current_id,\n+            map,\n+        }\n+    }\n+}\n+\n+impl<'map> Iterator for ParentHirIterator<'map> {\n+    type Item = (HirId, Node<'map>);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.current_id == CRATE_HIR_ID {\n+            return None;\n+        }\n+        loop { // There are nodes that do not have entries, so we need to skip them.\n+            let parent_id = self.map.get_parent_node(self.current_id);\n+\n+            if parent_id == self.current_id {\n+                self.current_id = CRATE_HIR_ID;\n+                return None;\n+            }\n+\n+            self.current_id = parent_id;\n+            if let Some(entry) = self.map.find_entry(parent_id) {\n+                return Some((parent_id, entry.node));\n+            }\n+            // If this `HirId` doesn't have an `Entry`, skip it and look for its `parent_id`.\n+        }\n+    }\n+}\n+\n impl<'hir> Map<'hir> {\n     #[inline]\n     fn lookup(&self, id: HirId) -> Option<&Entry<'hir>> {\n@@ -682,45 +718,6 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-\n-    /// If there is some error when walking the parents (e.g., a node does not\n-    /// have a parent in the map or a node can't be found), then we return the\n-    /// last good `HirId` we found. Note that reaching the crate root (`id == 0`),\n-    /// is not an error, since items in the crate module have the crate root as\n-    /// parent.\n-    fn walk_parent_nodes<F, F2>(&self,\n-                                start_id: HirId,\n-                                found: F,\n-                                bail_early: F2)\n-        -> Result<HirId, HirId>\n-        where F: Fn(&Node<'hir>) -> bool, F2: Fn(&Node<'hir>) -> bool\n-    {\n-        let mut id = start_id;\n-        loop {\n-            let parent_id = self.get_parent_node(id);\n-            if parent_id == CRATE_HIR_ID {\n-                return Ok(CRATE_HIR_ID);\n-            }\n-            if parent_id == id {\n-                return Err(id);\n-            }\n-\n-            if let Some(entry) = self.find_entry(parent_id) {\n-                if let Node::Crate = entry.node {\n-                    return Err(id);\n-                }\n-                if found(&entry.node) {\n-                    return Ok(parent_id);\n-                } else if bail_early(&entry.node) {\n-                    return Err(parent_id);\n-                }\n-                id = parent_id;\n-            } else {\n-                return Err(id);\n-            }\n-        }\n-    }\n-\n     /// Retrieves the `HirId` for `id`'s enclosing method, unless there's a\n     /// `while` or `loop` before reaching it, as block tail returns are not\n     /// available in them.\n@@ -744,46 +741,64 @@ impl<'hir> Map<'hir> {\n     /// }\n     /// ```\n     pub fn get_return_block(&self, id: HirId) -> Option<HirId> {\n-        let match_fn = |node: &Node<'_>| {\n-            match *node {\n+        let mut iter = ParentHirIterator::new(id, &self).peekable();\n+        let mut ignore_tail = false;\n+        if let Some(entry) = self.find_entry(id) {\n+            if let Node::Expr(Expr { kind: ExprKind::Ret(_), .. }) = entry.node {\n+                // When dealing with `return` statements, we don't care about climbing only tail\n+                // expressions.\n+                ignore_tail = true;\n+            }\n+        }\n+        while let Some((hir_id, node)) = iter.next() {\n+            if let (Some((_, next_node)), false) = (iter.peek(), ignore_tail) {\n+                match next_node {\n+                    Node::Block(Block { expr: None, .. }) => return None,\n+                    Node::Block(Block { expr: Some(expr), .. }) => {\n+                        if hir_id != expr.hir_id {\n+                            // The current node is not the tail expression of its parent.\n+                            return None;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            match node {\n                 Node::Item(_) |\n                 Node::ForeignItem(_) |\n                 Node::TraitItem(_) |\n                 Node::Expr(Expr { kind: ExprKind::Closure(..), ..}) |\n-                Node::ImplItem(_) => true,\n-                _ => false,\n-            }\n-        };\n-        let match_non_returning_block = |node: &Node<'_>| {\n-            match *node {\n+                Node::ImplItem(_) => return Some(hir_id),\n                 Node::Expr(ref expr) => {\n                     match expr.kind {\n-                        ExprKind::Loop(..) | ExprKind::Ret(..) => true,\n-                        _ => false,\n+                        // Ignore `return`s on the first iteration\n+                        ExprKind::Loop(..) | ExprKind::Ret(..) => return None,\n+                        _ => {}\n                     }\n                 }\n-                _ => false,\n+                Node::Local(_) => return None,\n+                _ => {}\n             }\n-        };\n-\n-        self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n+        }\n+        None\n     }\n \n     /// Retrieves the `HirId` for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n     pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n-        match self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(_) |\n-            Node::ForeignItem(_) |\n-            Node::TraitItem(_) |\n-            Node::ImplItem(_) => true,\n-            _ => false,\n-        }, |_| false) {\n-            Ok(id) => id,\n-            Err(id) => id,\n+        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+            match node {\n+                Node::Crate |\n+                Node::Item(_) |\n+                Node::ForeignItem(_) |\n+                Node::TraitItem(_) |\n+                Node::ImplItem(_) => return hir_id,\n+                _ => {}\n+            }\n         }\n+        hir_id\n     }\n \n     /// Returns the `DefId` of `id`'s nearest module parent, or `id` itself if no\n@@ -795,60 +810,64 @@ impl<'hir> Map<'hir> {\n     /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent_node(&self, hir_id: HirId) -> HirId {\n-        match self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(&Item { kind: ItemKind::Mod(_), .. }) => true,\n-            _ => false,\n-        }, |_| false) {\n-            Ok(id) => id,\n-            Err(id) => id,\n+        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+            if let Node::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n+                return hir_id;\n+            }\n         }\n+        CRATE_HIR_ID\n     }\n \n     /// Returns the nearest enclosing scope. A scope is roughly an item or block.\n     pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n-        self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(i) => {\n-                match i.kind {\n-                    ItemKind::Fn(..)\n-                    | ItemKind::Mod(..)\n-                    | ItemKind::Enum(..)\n-                    | ItemKind::Struct(..)\n-                    | ItemKind::Union(..)\n-                    | ItemKind::Trait(..)\n-                    | ItemKind::Impl(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::ForeignItem(fi) => {\n-                match fi.kind {\n-                    ForeignItemKind::Fn(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::TraitItem(ti) => {\n-                match ti.kind {\n-                    TraitItemKind::Method(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::ImplItem(ii) => {\n-                match ii.kind {\n-                    ImplItemKind::Method(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::Block(_) => true,\n-            _ => false,\n-        }, |_| false).ok()\n+        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+            if match node {\n+                Node::Item(i) => {\n+                    match i.kind {\n+                        ItemKind::Fn(..)\n+                        | ItemKind::Mod(..)\n+                        | ItemKind::Enum(..)\n+                        | ItemKind::Struct(..)\n+                        | ItemKind::Union(..)\n+                        | ItemKind::Trait(..)\n+                        | ItemKind::Impl(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::ForeignItem(fi) => {\n+                    match fi.kind {\n+                        ForeignItemKind::Fn(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::TraitItem(ti) => {\n+                    match ti.kind {\n+                        TraitItemKind::Method(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::ImplItem(ii) => {\n+                    match ii.kind {\n+                        ImplItemKind::Method(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::Block(_) => true,\n+                _ => false,\n+            } {\n+                return Some(hir_id);\n+            }\n+        }\n+        None\n     }\n \n     /// Returns the defining scope for an opaque type definition.\n-    pub fn get_defining_scope(&self, id: HirId) -> Option<HirId> {\n+    pub fn get_defining_scope(&self, id: HirId) -> HirId {\n         let mut scope = id;\n         loop {\n-            scope = self.get_enclosing_scope(scope)?;\n+            scope = self.get_enclosing_scope(scope).unwrap_or(CRATE_HIR_ID);\n             if scope == CRATE_HIR_ID {\n-                return Some(CRATE_HIR_ID);\n+                return CRATE_HIR_ID;\n             }\n             match self.get(scope) {\n                 Node::Item(i) => {\n@@ -861,7 +880,7 @@ impl<'hir> Map<'hir> {\n                 _ => break,\n             }\n         }\n-        Some(scope)\n+        scope\n     }\n \n     pub fn get_parent_did(&self, id: HirId) -> DefId {"}, {"sha": "6a88ae077c8da642b8672cbeb4e4191db1869340", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b6a5801fbe90c029a170555c1ca49b676b243a7/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b6a5801fbe90c029a170555c1ca49b676b243a7/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5b6a5801fbe90c029a170555c1ca49b676b243a7", "patch": "@@ -1552,7 +1552,7 @@ pub enum ExprKind {\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n     MethodCall(P<PathSegment>, Span, HirVec<Expr>),\n-    /// A tuple (e.g., `(a, b, c ,d)`).\n+    /// A tuple (e.g., `(a, b, c, d)`).\n     Tup(HirVec<Expr>),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n     Binary(BinOp, P<Expr>, P<Expr>),"}, {"sha": "2e19c9c24e9b5fd11e3e79169092f1351c5bc13e", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b6a5801fbe90c029a170555c1ca49b676b243a7/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b6a5801fbe90c029a170555c1ca49b676b243a7/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=5b6a5801fbe90c029a170555c1ca49b676b243a7", "patch": "@@ -1213,7 +1213,7 @@ pub fn may_define_opaque_type(\n     let mut hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Named opaque types can be defined by any siblings or children of siblings.\n-    let scope = tcx.hir().get_defining_scope(opaque_hir_id).expect(\"could not get defining scope\");\n+    let scope = tcx.hir().get_defining_scope(opaque_hir_id);\n     // We walk up the node tree until we hit the root or the scope of the opaque type.\n     while hir_id != scope && hir_id != hir::CRATE_HIR_ID {\n         hir_id = tcx.hir().get_parent_item(hir_id);"}, {"sha": "0cdf2fa2a5b9e7192a4ce13490416aa098cf814b", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b6a5801fbe90c029a170555c1ca49b676b243a7/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b6a5801fbe90c029a170555c1ca49b676b243a7/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=5b6a5801fbe90c029a170555c1ca49b676b243a7", "patch": "@@ -620,8 +620,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr\n     ) -> Ty<'tcx> {\n         if self.ret_coercion.is_none() {\n-            struct_span_err!(self.tcx.sess, expr.span, E0572,\n-                                \"return statement outside of function body\").emit();\n+            struct_span_err!(\n+                self.tcx.sess,\n+                expr.span,\n+                E0572,\n+                \"return statement outside of function body\",\n+            ).emit();\n         } else if let Some(ref e) = expr_opt {\n             if self.ret_coercion_span.borrow().is_none() {\n                 *self.ret_coercion_span.borrow_mut() = Some(e.span);"}, {"sha": "db017394cd5f163fb636879097bddbe48ebf2727", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b6a5801fbe90c029a170555c1ca49b676b243a7/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b6a5801fbe90c029a170555c1ca49b676b243a7/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5b6a5801fbe90c029a170555c1ca49b676b243a7", "patch": "@@ -1717,9 +1717,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     }\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let scope = tcx.hir()\n-        .get_defining_scope(hir_id)\n-        .expect(\"could not get defining scope\");\n+    let scope = tcx.hir().get_defining_scope(hir_id);\n     let mut locator = ConstraintLocator {\n         def_id,\n         tcx,"}, {"sha": "85cbc787bc2db5b50e5156a3d4dd075572afb02a", "filename": "src/test/ui/struct-literal-variant-in-if.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b6a5801fbe90c029a170555c1ca49b676b243a7/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b6a5801fbe90c029a170555c1ca49b676b243a7/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr?ref=5b6a5801fbe90c029a170555c1ca49b676b243a7", "patch": "@@ -49,9 +49,6 @@ LL |     if x == E::V { field } {}\n error[E0308]: mismatched types\n   --> $DIR/struct-literal-variant-in-if.rs:10:20\n    |\n-LL | fn test_E(x: E) {\n-   |                 - help: try adding a return type: `-> bool`\n-LL |     let field = true;\n LL |     if x == E::V { field } {}\n    |                    ^^^^^ expected (), found bool\n    |"}]}